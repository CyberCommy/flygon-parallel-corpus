- en: Chapter 3. Developing a JavaFX Desktop and Web Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will cover how to develop compelling desktop and web applications
    that take advantage of the multicore, hardware-accelerated GPU to deliver high-performance
    UI-based applications that have an amazing look and feel.
  prefs: []
  type: TYPE_NORMAL
- en: As JavaFX is totally written from the ground up in Java, some Java SE 8 built-in
    core libraries will be used to power our application. In addition, we will learn
    how to package our application as a standalone application to be launched and
    distributed.
  prefs: []
  type: TYPE_NORMAL
- en: Also, we will cover the essential core web APIs in any web application levered
    by JavaFX 8, such as `javafx.scene.web.WebEngine`, `java.net.HttpURLConnection`
    and `javafx.scene.web.WebView`.
  prefs: []
  type: TYPE_NORMAL
- en: We will discuss the relationship between JavaFX and HTML5, which is important
    because JavaFX's APIs and the features of HTML5 complement one another. HTML5
    is a platform for rich web content to create a user experience that resembles
    a **RIA** (**Rich Internet Application**) web application with the characteristics
    of native desktop software.
  prefs: []
  type: TYPE_NORMAL
- en: More importantly, we will go through the development of a desktop version of
    the *Note-taking Application* and then run it on the Web.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, we will cover all the required knowledge and skills to deploy
    the *Note-taking as a web application* on the desktop and the Web.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the skills that will be learned during this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Developing and running desktop and web applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling application UIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to package a JavaFX 8 desktop application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loading HTML5 content inside a JavaFX application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending data from JavaFX to JavaScript and vice versa
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying a JavaFX web application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing a note-taking application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building an application for one platform just isn't good enough anymore. Desktop,
    Web, mobile, and embedded support are all required for a successful product, but
    learning the different environments is difficult. Here comes into play the power
    of JavaFX to write an application that will run on different platforms with simple
    tweaks, as we will see in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we are going to build a *note-taking* application for desktop and the
    Web as well. In this project, I'll show you how to create a complete JavaFX application
    from scratch using the JavaFX 8 SDK and the Java programming language using our
    previously installed developer tools (refer to [Chapter 1](ch01.html "Chapter 1. Getting
    Started with JavaFX 8"), *Getting Started with JavaFX 8*).
  prefs: []
  type: TYPE_NORMAL
- en: I'll then show you how to create the application's two screen layouts and create
    the Java classes that control them. I'll create buttons that control navigation
    between different scenes, saves data, and then gets your UI controls updated dynamically
    with the power of property bindings.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final project will look like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Developing a note-taking application](img/B03998_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: P'Note-Taking Application
  prefs: []
  type: TYPE_NORMAL
- en: 'This figure shows the add and edit screen opened from the main screen new note
    button to add new note, or edit button to edit one of listed notes as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Developing a note-taking application](img/B03998_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: So, what are you waiting for? Let's go!
  prefs: []
  type: TYPE_NORMAL
- en: Building the UI prototype
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first step in building any successful application with **complex UI** (even
    simple ones) is prototyping your layout, screens relationship, their state, and
    their navigation. Sketch it on a piece of paper and then get feedback from your
    team and manager. Rework it and, once approved, start building a real interactive
    prototype for your customers, in order to get their feedback for final production.
  prefs: []
  type: TYPE_NORMAL
- en: This is what we are going to do now, and our application has been laid out on
    piece of paper on any easy to use UI sketcher tools as in the following image.
    We will then develop it with the Scene Builder tool as a complete prototype.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, we are going to see the interoperability between NetBeans and the
    Scene builder tool.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that it is easier to sketch your layout by drawing it on paper first, as
    it is a very quick way to edit, enhance, and figure out the final application
    layout before interacting with the tools to develop it.
  prefs: []
  type: TYPE_NORMAL
- en: Now, as we have sketched our application, we are ready to build our application's
    real prototype.
  prefs: []
  type: TYPE_NORMAL
- en: The best way to get the most out of the tools is to create your application
    skeleton (*controller classes and FXML base page definitions*) inside the NetBeans
    IDE, and then create and develop FXML pages inside the Scene builder tool. Here
    comes the powerful interoperability between the two tools.
  prefs: []
  type: TYPE_NORMAL
- en: '![Building the UI prototype](img/B03998_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here are the steps to start with JavaFX FXML application:'
  prefs: []
  type: TYPE_NORMAL
- en: Open up the NetBeans IDE, and from the main menu, choose **File**, and then
    **New Project** a **New Project** dialog will open. From **Categories**, choose
    **JavaFX**, and then under **Projects**, choose JavaFX FXML Application. Then,
    click on the **Next** button:![Building the UI prototype](img/B03998_03_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A new JavaFX FXML application
  prefs: []
  type: TYPE_NORMAL
- en: In the **JavaFX FXML application** dialog, add the relevant information. From
    **Project name**, add the location and **FXML name** (in my case, `ListNotesUI`).
    In **Create Application class**, I have added `packt.taman.jfx8.ch3.NoteTakingApp`,
    as shown in the following figure. Hit **Finish**.![Building the UI prototype](img/B03998_03_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we have a project with the first FXML UI document (`ListNotesUI.fxml`),
    and we need to add the second FXML UI document (`AddEditUI.fxml`) alongside its
    controller.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To do that from the file, choose **New File**; then, under the **Categories**
    list, choose **JavaFX**, and from the **File Types** list, choose Empty FXML,
    and finally, click on **Next**, as shown in the following figure.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **New Empty FXML and Location** dialog, edit the **FXML Name** field
    to be `AddEditUI`, and then click on **Next**.![Building the UI prototype](img/B03998_03_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adding a new empty FXML document
  prefs: []
  type: TYPE_NORMAL
- en: In the Controller Class dialog as in the following screen, tick the **Use Java
    Controller** checkbox. Make sure that **Create New Controller** has been selected,
    with the **Controller Name** as `AddEditUIController`. Then, click on **Next**,
    skip the **Cascading Style Sheet** dialog, and finally, click on **Finish**:![Building
    the UI prototype](img/B03998_03_07.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adding a new controller to the FXML document
  prefs: []
  type: TYPE_NORMAL
- en: 'As we have built our project structure, it''s time to add our controls into
    our pages UI using Scene Builder, similar to what we sketched on paper. To do
    so is easy:'
  prefs: []
  type: TYPE_NORMAL
- en: From NetBeans, right-click on `ListNotesUI.fxml` and select Open or just double-click
    on it. **Scene Builder** will open with your FXML document in design mode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Note: It works only if Scene Builder is installed on your machine.'
  prefs: []
  type: TYPE_NORMAL
- en: Design the page as per the following screenshot. Most importantly, don't forget
    to save your changes before returning back to NetBeans or closing **Scene Builder**
    for logic implementation.![Building the UI prototype](img/B03998_03_08.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Complete ListNotesUI.fxml document design
  prefs: []
  type: TYPE_NORMAL
- en: Perform the same steps for `AddEditUI.fxml`, and your design should end up like
    this:![Building the UI prototype](img/B03998_03_09.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Complete AddEditUI.fxml document design
  prefs: []
  type: TYPE_NORMAL
- en: You need to check the FXML document to see how we nested many containers and
    UI controls to achieve the desired UI we had sketched earlier, in addition to
    using their properties to control the spacing, alignment, font, and coloring.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You have converted your sketched layout to something vivid
    that could be presented as a project without logic to your team leaders and managers
    to get their feedback regarding colors, theming, and the final layout. Moreover,
    once it gets approved, you can proceed for the final customer feedback before
    diving deeper into the business logic.
  prefs: []
  type: TYPE_NORMAL
- en: Bringing your application to life – adding interactions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After designing your application, you need to bring it to life by making it
    more interactive and responsive to the functionality it is supposed to perform
    and act on the customer's proposed functional requirement.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing I always do is to add the navigation handler from page to page,
    and I have done that in each FXML document controller class.
  prefs: []
  type: TYPE_NORMAL
- en: To eliminate redundancy and be modular, I have created a base navigation method
    in the `BaseController.java` class, which will be extended by all controllers
    in the system. This class will be useful for adding any common functionality and
    shared attributes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following method, `navigate(Event event, URL fxmlDocName)`, is one of the
    most important pieces of code that will be used in all of our system navigation
    (the comments illustrate the working mechanism):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This method will be called from the action handler of the **New Note** and edit
    button in the `ListNotesUI.fxml` page at `ListNotesUIController.java` and the
    **List Notes**, save, and **Cancel** buttons in the `AddEditUI.fxml` page at `AddEditUIController.java`
    as the following respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay attention to the relationship between buttons defined in the FXML document
    and the controller. The `@FXML` annotation comes into play here to bind FXML attributes
    (*using #)* with the defined actions in the controller:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The **New Note** button definition in the `ListNotesUI.fxml` file is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The **New Note** action is defined in `ListNotesUIController.java`, bound to
    the preceding button using `onAction="#newNote"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The **Back** button definition in the `AddEditUI.fxml` file is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The **Back** action is defined in `AddEditUIController.java`, bound to the
    preceding button using `onAction="#back"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: You may be wondering what the `FXMLPage.java` class does. It is an enum (for
    more about enums, visit [https://docs.oracle.com/javase/tutorial/java/javaOO/enum.html](https://docs.oracle.com/javase/tutorial/java/javaOO/enum.html)).
    I have created enums to define all our FXML document names and their locations,
    in addition to any utility methods relevant to those FXML document, helping to
    ease coding in our system.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This concept of maintainability helps in large systems to maintain constant
    properties and functionality in one place for future ease of refactoring, and
    allows us to change names in one place instead of roaming all over the system
    to change just one name.
  prefs: []
  type: TYPE_NORMAL
- en: If you check system controllers, you will find all the logic for handling other
    button's actions – deleting, editing, clearing, and saving notes.
  prefs: []
  type: TYPE_NORMAL
- en: Power application change synchronization with properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Properties are wrapper objects for JavaFX-based object attributes such as String
    or Integer. Properties allow you to add listener code to respond when the wrapped
    value of an object has changed or is flagged as invalid. In addition, property
    objects can be bound to one another.
  prefs: []
  type: TYPE_NORMAL
- en: Binding behavior allows properties to update or synchronize their values based
    on a changed value from another property.
  prefs: []
  type: TYPE_NORMAL
- en: Properties are wrapper objects that have the ability to make values accessible
    as read/writable or read-only.
  prefs: []
  type: TYPE_NORMAL
- en: In short, JavaFX's properties are wrapper objects holding actual values while
    providing change support, invalidation support, and binding capabilities. I will
    address binding later, but for now, let's examine the commonly used property classes.
  prefs: []
  type: TYPE_NORMAL
- en: All wrapper property classes are located in the `javafx.beans.property.* package`
    namespace. Listed here are the commonly used property classes. To see all of the
    property classes, refer to the documentation in Javadoc ([https://docs.oracle.com/javase/8/javafx/api/index.html?javafx/beans/property.html](https://docs.oracle.com/javase/8/javafx/api/index.html?javafx/beans/property.html)).
  prefs: []
  type: TYPE_NORMAL
- en: '`javafx.beans.property.SimpleBooleanProperty`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`javafx.beans.property.ReadOnlyBooleanWrapper`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`javafx.beans.property.SimpleIntegerProperty`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`javafx.beans.property.ReadOnlyIntegerWrapper`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`javafx.beans.property.SimpleDoubleProperty`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`javafx.beans.property.ReadOnlyDoubleWrapper`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`javafx.beans.property.SimpleStringProperty`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`javafx.beans.property.ReadOnlyStringWrapper`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The properties that have a prefix of `Simple` and a suffix of `Property` are
    the *read/writable property* classes, and the classes with a prefix of ReadOnly
    and a suffix of Wrapper are the read-only properties. Later, you will see how
    to create a JavaFX bean using these commonly used properties.
  prefs: []
  type: TYPE_NORMAL
- en: Let's fast-forward to JavaFX's Properties API to see how it handles the common
    issues. You may notice that the `TableView` control has been added to the main
    page to list the currently loaded notes and any new added notes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to populate `TableView` correctly with data, we should have a data
    model to represent the notes data, and this is the first place I used the Properties
    API in the JavaFX JavaBean-style Note class, which is defined as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In order to populate the `TableView` class with data already stored in the application
    database, for example (our database here is transient using `ObservableList<Note>`
    of the note object called data), we have to pass a collection of this data.
  prefs: []
  type: TYPE_NORMAL
- en: We need to remove the burden of updating the UI control (in our case, the `TableView`
    control) manually each time the notes data collection get updated. Therefore,
    we need a solution to automatically synchronize the changes between the table
    view and notes data collection model, for example, adding, updating, or deleting
    data, without any further modification to the UI controls from the code. Only
    the data model collection gets updated – the UI should be synchronized automatically.
  prefs: []
  type: TYPE_NORMAL
- en: This feature is already an integral part of JavaFX collections. We will use
    JavaFX's `ObservableList` class. The `ObservableList` class is a collection that
    is capable of notifying UI controls when objects are added, updated, or removed.
  prefs: []
  type: TYPE_NORMAL
- en: JavaFX's `ObservableList` class is typically used in list UI controls, such
    as `ListView` and `TableView`. Let's look at how we will use the `ObservableList`
    collection class.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `BaseController`, I have created static data as `ObservableList<Note>` to
    be shared between all controllers, to be able to add, update, and remove notes
    from it. Also, it is initialized with some data as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `ListNotesUIController.java` class, inside the `initialize()` method,
    I have created an instance of the `javafx.collections.transformation.FilteredList`
    class that will be used as the filtering class when we search in the table contents.
    It will pass the `data` object of type `ObservableList<Note>` as the source data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The second argument of `FilteredList` is the predicate used to filter data;
    here, it returns `true`, meaning no filtration, and we will add the filtration
    predicate later on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The created data list of type `ObservableList<Note>` should be passed to our
    `TableView` data in order for the table view to monitor the current data collection
    manipulations, such as addition, deletion, editing, and filtering, as the following
    in the `initialize()` method of the `ListNotesUIController.java` class, but instead
    we have passed the `filteredData` wrapper instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The final step is to acknowledge our `notesListTable` columns, of type `TableColumn`,
    and to which property of Note class to render and take care of. We use the `setCellValueFactory()`
    method to do the trick, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note that `title` and `description` are the instance variable names of the `Note`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: Check the final project code for the full implementation. Then, run the application
    from the NetBeans main menu, choose Run, and then click on **Run Main Project**.
  prefs: []
  type: TYPE_NORMAL
- en: Try to add a new note and watch the table view for your newly added note. Try
    to select and delete the note or update an existing note. You will notice the
    change immediately.
  prefs: []
  type: TYPE_NORMAL
- en: By checking the application code, you will see that all we have done is manipulated
    the data list and all the other synchronization work efforts are carried out with
    the help of the `ObservableList` class.
  prefs: []
  type: TYPE_NORMAL
- en: Filtering the TableView data list
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We will get in touch here with two of the most powerful Java SE 8 and JavaFX
    8 features `Predicate` and `FilteredList`. Let's state the problem we have at
    hand and how we are going to solve it with the `stream` feature.
  prefs: []
  type: TYPE_NORMAL
- en: In our `ListNotesUI.fxml` page, you may notice the text field located above
    the notes table; its purpose here is to filter the current table data to narrow
    the result to get a specific note. Also, we need to maintain the current list
    being careful not to remove any data from it or query the database for each search
    hit.
  prefs: []
  type: TYPE_NORMAL
- en: 'We already have the notes data list and we are going to use the text field
    to filter this list for any note title or description containing this character
    or a combination of characters, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Filtering the TableView data list](img/B03998_03_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Table populated with data
  prefs: []
  type: TYPE_NORMAL
- en: Now, after typing in `d`, `de`, `dev`, or `developing`, `JavaFX`, a table will
    be filtered, as seen in the following screenshot. Also, try to remove all the
    text; you will find that the data comes back again. Next, we will discover how
    we did that.
  prefs: []
  type: TYPE_NORMAL
- en: '![Filtering the TableView data list](img/B03998_03_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Table data filtered with text in the search field
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the magical piece of code that did that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `searchNotes` is a reference to the text field we are using to filter the
    notes data. We have registered it with a `setOnKeyReleased(EventHandler<? super
    KeyEvent> value)` method that gets our text to filter once any character is typed
    in. Also, note that we used the Lambda expression here to make the code more concise
    and clean.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the definition of the action method, `filteredData` is a `FilteredList<Note>`
    class, we have passed a predicate `test()` method implementation to `setPredicate(Predicate<?
    super E> predicate)` filter only the notes title or a description matching the
    `searchNotes` text input.
  prefs: []
  type: TYPE_NORMAL
- en: The filtered data is automatically updated to the table UI.
  prefs: []
  type: TYPE_NORMAL
- en: For more information about the Predicate API, visit [http://docs.oracle.com/javase/8/docs/api/java/util/function/Predicate.html](http://docs.oracle.com/javase/8/docs/api/java/util/function/Predicate.html).
  prefs: []
  type: TYPE_NORMAL
- en: Note-taking as a desktop application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once you have finished the application, it will be more professional to not
    distribute the final jar and instead ask the user to install the JRE environment
    to be able to run your application, especially if you targeting a large audience.
  prefs: []
  type: TYPE_NORMAL
- en: It's more professional to prepare your native installer packages as `.exe`,
    `.msi`, `.dmg`. or `.img`.
  prefs: []
  type: TYPE_NORMAL
- en: Every installer manages the application requirements from the required assets
    and runtime environments. This ensures that your application will run on multiple
    platforms too.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying the application for desktop distribution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One of the advanced NetBeans features is to allow you to bundle your application
    for different platforms via its deployment handler, which gives you the following
    main features:'
  prefs: []
  type: TYPE_NORMAL
- en: Deploy your application through native installers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manage application assets as application icons, splash screens, and native installer
    icons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accept the certificate for the final signing of your application when preparing
    the final package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manage the required JavaFX runtime version
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding desktop shortcuts of the Start menu when using Windows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling the Java Web Start technology requirements and customizations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s see the configuration of NetBeans deployment:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Deploying the application for desktop distribution](img/B03998_03_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: NetBeans deployment configurations
  prefs: []
  type: TYPE_NORMAL
- en: 'To know how to package your application into the native installer for each
    platform you are targeting, visit the following URL, which provides you with all
    the required steps and software to complete the task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://netbeans.org/kb/docs/java/native_pkg.html](https://netbeans.org/kb/docs/java/native_pkg.html)'
  prefs: []
  type: TYPE_NORMAL
- en: JavaFX on the Web
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will learn about JavaFX on the Web and how to deploy our
    note-taking application there.
  prefs: []
  type: TYPE_NORMAL
- en: WebEngine
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JavaFX provides a non-GUI component capable of loading HTML5 content, called
    the **WebEngine** API (`javafx.scene.web.WebEngine`). This API is basically an
    object instance of the `WebEngine` class to be used to load a file containing
    HTML5 content. The HTML5 file could be loaded from a local file system, a web
    server, or from inside a JAR file.
  prefs: []
  type: TYPE_NORMAL
- en: When a file is loaded using a web engine object, a background thread is used
    to load the file content to not block the *JavaFX application thread*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are two `WebEngine` methods for loading HTML5 content:'
  prefs: []
  type: TYPE_NORMAL
- en: load(String URL)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: loadContent(String HTML)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: WebView
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JavaFX provides a GUI `WebView` (`javafx.scene.web.WebView`) node that can render
    HTML5 content onto the Scene graph. A `WebView` node is basically a mini-browser
    that is capable of responding to web events and allows a developer to interact
    with the HTML5 content.
  prefs: []
  type: TYPE_NORMAL
- en: Because of the close relationship between loading web content and the ability
    to display web content, the `WebView` node object also contains a `WebEngine`
    instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'The JavaFX 8 `WebView` class implementation provides support for the following
    HTML5 features:'
  prefs: []
  type: TYPE_NORMAL
- en: Canvas and SVG
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Media playback
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Form controls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: History maintenance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interactive element tags
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DOM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Web workers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Web sockets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Web fonts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: WebView and engine in action
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We are going to have a simple example of how to load an HTML5 web document
    that contains Google Maps integrated with JavaFX as the scene control using `WebView`.
    We then use `WebEngine` to get the longitude and latitude from the JavaFX `TextField`
    controls to execute a JavaScript method that passes those parameters to position
    the map to be centered to the newly passed position with the marker indication,
    as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![WebView and engine in action](img/B03998_03_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The Google Maps viewer from the JavaFX 8 application
  prefs: []
  type: TYPE_NORMAL
- en: For the sake of clarity, I will show and explain only the important parts of
    the code, which demonstrates the concept mentioned in the preceding paragraph.
    For the complete code in this chapter, check the `web` package code `GoogleMapViewerFX.java`
    class and `map.html` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'To view Google Maps inside the JavaFX application, we need to first create
    an HTML file to load and integrate with the Maps API, and this is defined in the
    `map.html` file. As seen in the preceding picture, the location is centered on
    Cairo, Egypt, my city, and this is set as the longitude and latitude values passed
    to the map when we create it, as in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Next, we have to notice the JavaScript `goToLocation(lng, lat)` method; this
    will be called from the JavaFX application using the `webEngine` instance to position
    the map based on the passed longitude and latitude from the JavaFX controls.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside `GoogleMapViewerFX.java`, we have created four controls to compose our
    UI – two `TextField` classes for the longitude and latitude, one update button,
    and a `WebView` object to view the `map.html` document:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Note that I have created text controls with the initial longitude and latitude,
    which is different from the original map position. This position is my home position,
    and you can change it to yours and hit update to view the new position.
  prefs: []
  type: TYPE_NORMAL
- en: To load the `map.html` file, we have to pass it to the `WebEngine` class that
    we created from the `WebView` class we have created already, as seen in the previous
    code snippet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement the button''s `onAction()` method to allow integration between JavaFX
    controls and JavaScript using the `webEngine` `executeScript()` method, as in
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Run the application and you should see the previous figure positioned to Cairo
    city! Hit update and you should reach my home, as seen in the following figure.
  prefs: []
  type: TYPE_NORMAL
- en: Try getting your position longitude and latitude; then go to your home too!
  prefs: []
  type: TYPE_NORMAL
- en: Powerful, isn't it? It is very easy to integrate HTML5 content and interact
    with already developed web applications to add more rich content from the Web
    to your existing JavaFX application.
  prefs: []
  type: TYPE_NORMAL
- en: '![WebView and engine in action](img/B03998_03_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Change the Google Map position in the JavaFX 8 application
  prefs: []
  type: TYPE_NORMAL
- en: Note-taking as a web application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once your application is tested, as we have discussed before, you can distribute
    your application to multiple platforms and environments. We did that already for
    desktops with native installers using the distributed in this chapter, `.jar`
    file under the project's `dist` folder.
  prefs: []
  type: TYPE_NORMAL
- en: The same `.jar` file will be used for web deployment, and the application could
    be deployed as a web application in many ways, as we will see next.
  prefs: []
  type: TYPE_NORMAL
- en: Running the application for the Web
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are three ways to run your JavaFX application on the Web:'
  prefs: []
  type: TYPE_NORMAL
- en: Using **Java Web Start** to download and start your application once; then,
    you can use it offline from your machine
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Embed your JAR into your HTML file to run from an enterprise environment
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Load your HTML content from the `WebEngine` class and view it from the `WebView`
    class, as discussed previously
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Java Web Start
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Java Web Start software provides the power to launch full-featured applications
    with a single click. Users can download and launch applications, such as a complete
    spreadsheet program or an Internet chat client, without going through lengthy
    installation procedures.
  prefs: []
  type: TYPE_NORMAL
- en: With Java Web Start, users can launch a Java application by clicking on a link
    on a web page. The link points to a **JNLP** (**Java Network Launch Protocol**)
    file, which instructs Java Web Start to download, cache, and run the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Java Web Start provides Java developers and users with many deployment advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: With Java Web Start, you can place a single Java application on a web server
    for deployment to a wide variety of platforms, including Windows, Linux, and Solaris.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It supports multiple simultaneous versions of the Java platform. An application
    can request a specific version of the Java Runtime Environment (JRE) software
    without conflicting with the needs of other applications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Users can create a desktop shortcut to launch a Java Web Start application outside
    a browser.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java Web Start takes advantage of the inherent security of the Java platform.
    By default, applications have restricted access to local disk and network resources.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applications launched with Java Web Start are cached locally for improved performance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updates to a Java Web Start application are automatically downloaded when the
    application is run standalone from the user's desktop.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java Web Start is installed as part of the JRE software. Users do not have to
    install Java Web Start separately or perform additional tasks to use Java Web
    Start applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information about **Java Web Start**, see the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: Java Web Start Guide ([http://docs.oracle.com/javase/8/docs/technotes/guides/javaws/developersguide/contents.html](http://docs.oracle.com/javase/8/docs/technotes/guides/javaws/developersguide/contents.html))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `javax.jnlp` API Documentation ([http://docs.oracle.com/javase/8/docs/jre/api/javaws/jnlp/index.html](http://docs.oracle.com/javase/8/docs/jre/api/javaws/jnlp/index.html))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Java Web Start Developers Site ([http://www.oracle.com/technetwork/java/javase/javawebstart/index.html](http://www.oracle.com/technetwork/java/javase/javawebstart/index.html))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying the application for a web distribution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To deploy your JavaFX applications on to the Web, there is a very simple way
    using NetBeans.
  prefs: []
  type: TYPE_NORMAL
- en: 'NetBeans already provides three deployment types for your JavaFX application
    – desktop, Java Web Start, and Web-as seen in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Deploying the application for a web distribution](img/B03998_03_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have been learning how to develop JavaFX enterprise applications
    for both desktops and the Web.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we gained the skills to develop any application, starting with
    sketching a layout on a piece of paper; next, we translated it into an actual
    interactive, colorful UI prototype. We saw how to nest our containers and controls
    to achieve the desired layout. Once we got the approvals for final development,
    we brought the application to life by making it respond to customer actions and
    by delivering the functional requirements.
  prefs: []
  type: TYPE_NORMAL
- en: We made our code more powerful, clean, and concise with the power of Java SE
    8 features and JavaFX bindings. Finally, we learned how to deploy our application
    either to the target desktop customers or Web users for different platforms and
    environments.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to learn how to develop a JavaFX application
    for Android-based smart phones. Additionally, we will learn the required skills
    to download and install Android SDK tools and interact with loggers, emulators,
    and other tools that will help you in any future mobile development you need to
    do that isn't related to JavaFX.
  prefs: []
  type: TYPE_NORMAL
