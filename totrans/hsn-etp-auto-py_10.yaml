- en: Running System Administration Tasks with Fabric
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we used the `subprocess` module to run and spawn a
    system process inside the machine that hosted our Python script, and to return
    the output back to the Terminal. However, many automation tasks require access
    to remote servers to execute commands, which is not easy to do using a sub-process.
    This becomes a piece of cake with the use of another Python module: `Fabric`.
    The library makes connections to remote hosts and executes different tasks, such
    as uploading and downloading files, running commands with specific user IDs, and
    prompting users for input. The `Fabric` Python module is a robust tool for administrating
    dozens of Linux machines from a central point.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: What is Fabric?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executing your first Fabric file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other useful Fabric features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following tools should be installed and available in your environment:'
  prefs: []
  type: TYPE_NORMAL
- en: Python 2.7.1x.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PyCharm Community or Pro Edition.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: EVE-NG topology. Please refer to Chapter 8, *Preparing a Lab Environment*, for
    how to install and configure system servers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find the full scripts developed in this chapter at the following GitHub
    URL: [https://github.com/TheNetworker/EnterpriseAutomation.git](https://github.com/TheNetworker/EnterpriseAutomation.git).
  prefs: []
  type: TYPE_NORMAL
- en: What is Fabric?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Fabric ([http://www.fabfile.org/](http://www.fabfile.org/)) is a high-level
    Python library that is used to connect to remote servers (through the paramiko
    library) and execute predefined tasks on them. It runs a tool called **fab** on
    the machine that hosts the fabric module. This tool will look for a `fabfile.py`
    file, located in the same directory that you run the tool in. The `fabfile.py` file
    contains your tasks, defined as a Python function that is called from the command
    line to start the execution on the servers. The Fabric tasks themselves are just
    normal Python functions, but they contain special methods that are used to execute
    commands on remote servers. Also, at the beginning of `fabfile.py`, you need to
    define some environmental variables, such as the remote hosts, username, password,
    and any other variables needed during execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00154.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Installation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Fabric requires Python 2.5 to 2.7\. You can install Fabric and all of its dependencies
    using `pip`, or you can use a system package manager, such as `yum` or `apt`.
    In both cases, you will have the `fab` utility ready and executable from your
    operating system.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install `fabric` using `pip`, run the following command on your automation
    server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '![](../images/00155.gif)'
  prefs: []
  type: TYPE_IMG
- en: Notice that Fabric requires `paramiko`, which is a popular Python library that
    is used for establishing SSH connections.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can validate the Fabric installation with two steps. First, make sure that
    you have the `fab` command available in your system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The second step for verification is to open Python and try to import the `fabric`
    library. If there''s no error thrown, then Fabric has successfully installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Fabric operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many operations available in the `fabric` tool. These operations act
    as a functions inside the tasks in fabfile (there will be more about tasks later),
    but the following is a summary of the most important operations inside the `fabric`
    library.
  prefs: []
  type: TYPE_NORMAL
- en: Using run operation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The syntax for the `run` operation in Fabric is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This will execute the command on a remote host, while the `shell` argument controls
    whether a shell (such as `/bin/sh`) should be created before execution (the same
    parameter also exists in the sub-process).
  prefs: []
  type: TYPE_NORMAL
- en: 'After the command execution, Fabric will populate `.succeeded` or `.failed`,
    depending on the command output. You can check whether the command succeeded or
    failed by calling the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Using get operation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The syntax for the Fabric `get` operation is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This will download the files from the remote host to the machine running the
    `fabfile`, using either `rsync` or `scp` . This is commonly used when you need
    to gather log files to the server, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Using put operation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The syntax for the Fabric `put` operation is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This operation will upload the file from the machine running the `fabfile` (local)
    to the remote host. Using `use_sudo` will solve the permissions issue when you
    upload to the root directory. Also, you can keep the current file permissions
    on both the local and remote server, or you can set new permissions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Using sudo operation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The syntax for the Fabric `sudo` operation is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This operation can be considered another wrapper around the `run()` command.
    However, the `sudo` operation will run the command with the root username by default
    regardless of the username used to execute the `fabfile`. Also it contains a user
    argument which could be used to run the command with a different username. Also,
    the `user` argument executes the command with a specific UID, while the `group`
    argument defines the GID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Using prompt operation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The syntax for the Fabric `prompt` operation is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The user can provide a specific value for the task by using the `prompt` operation,
    and the input will be stored inside of a variable and used by tasks. Please note
    that you will be prompted for each host inside of the `fabfile`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Using reboot operation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The syntax for the Fabric `reboot` operation is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a simple operation that reboots the host by default. Fabric will wait
    for 120 seconds before attempting to reconnect, but you can change this value
    to another one by using the `wait` argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'For a full list of other supported operations, please check [http://docs.fabfile.org/en/1.14/api/core/operations.html](http://docs.fabfile.org/en/1.14/api/core/operations.html).
    You can also check them directly from PyCharm, by looking at all of the autocomplete
    functions that pop up when you type *Ctrl + spacebar*. From `fabric.operations`
    import <*ctrl*+*space*> under `fabric.operations`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00156.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Executing your first Fabric file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We now know how the operation works, so we will put it inside `fabfile` and
    create a full automation script that can work with remote machines. The first
    step for `fabfile` is to import the required classes. Most of them are located
    in `fabric.api`, so we will globally import all of them to our Python script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The next part is to define the remote machine IP addresses, usernames, and
    passwords. In the case of our environment, we have two machines (besides the automation
    server) that run Ubuntu 16.04 and CentOS 7.4, respectively, with the following
    details:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Machine Type** | **IP Address** | **Username** | **Password** |'
  prefs: []
  type: TYPE_TB
- en: '| Ubuntu 16.04 | `10.10.10.140` | `root` | `access123` |'
  prefs: []
  type: TYPE_TB
- en: '| CentOS 7.4 | `10.10.10.193` | `root` | `access123` |'
  prefs: []
  type: TYPE_TB
- en: 'We will include them inside the Python script, as shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we use the variable called `env`, which is inherited from the `_AttributeDict`
    class. Inside of this variable, we can set the username and password from the
    SSH connection. You can also use the SSH keys stored in your `.ssh` directory
    by setting `env.use_ssh_config=True`; Fabric will use the keys to authenticate
    the connection.
  prefs: []
  type: TYPE_NORMAL
- en: The last step is to define your tasks as a Python function. Tasks can use the
    preceding operations to execute commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the full script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, the following applies:'
  prefs: []
  type: TYPE_NORMAL
- en: We defined two tasks. The first one will execute the `uname -s` command and
    return the output, then verify whether the command executed successfully or not.
    The task uses the `run()` operation to accomplish it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The second task will use two operations: `prompt()` and `sudo()`. The first
    operation will ask the user to enter the full path to the directory, while the
    second operation will list all of the content in the directory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The final task, `main_tasks()`, will actually group the preceding two methods
    into one task, so that we can call it from the command line.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In order to run the script, we will upload the file to the automation server
    and use the `fab` utility to run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `-f` switch in the previous command is not mandatory if your filename is `fabfile.py`.
    If it is not, you will need to provide the name to the `fab` utility. Also, `fabfile`
    should be in the current directory; otherwise, you will need to provide the full
    path.Now we will run the `fabfile` by executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The first task will be executed, and will return the output to the Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will enter `/var/log/` to list the contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The same applies if you need to list the configuration files under the `network-scripts`
    directory in the CentOS machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, Fabric will disconnect from the two machines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: More about the fab tool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `fab` tool itself supports many operations. It can be used to list the
    different tasks inside `fabfile`. It can also set the `fab` environment during
    execution. For example, you can define the host that will run the commands on
    it by using the `-H` or `--hosts` switches, without the need to specify it inside
    `fabfile`. This actually sets the `env.hosts` variable inside `fabfile` during
    execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, you can define the command that you want to run by using
    the `fab` tool. This is something like Ansible ad hoc mode (we will discuss this
    in detail in [Chapter 13](part0168.html#506UG0-9cfcdc5beecd470bbeda046372f0337f),
    *Ansible for System Administration*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: If you don't want to store the password in clear text inside of the `fabfile`
    script, then you have two options. The first one is to use the SSH identity file
    (`private-key`) with the `-i` option, which loads the file during connection.
  prefs: []
  type: TYPE_NORMAL
- en: The other option is to force Fabric to prompt you for the session password before
    connecting to the remote machine by using the `-I` option.
  prefs: []
  type: TYPE_NORMAL
- en: Note that this option will overwrite the `env.password` parameter, if specified
    inside `fabfile`.
  prefs: []
  type: TYPE_NORMAL
- en: The `-D` switch will disable the known hosts and force Fabric not to load the
    `known_hosts` file from the `.ssh` directory. You can make Fabric reject connections
    to the hosts not defined in the `known_hosts` file with the `-r` or  `--reject-unknown-hosts`
    options.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, you can list all of the supported tasks inside of the fabfile by using `-l`
    or `--list`, providing the fabfile name to the `fab` tool. For example, applying
    that to the previous script will generate the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: You can see all of the available options and arguments for the `fab` command
    line with the `-h` switch, or at [http://docs.fabfile.org/en/1.14/usage/fab.html](http://docs.fabfile.org/en/1.14/usage/fab.html).
  prefs: []
  type: TYPE_NORMAL
- en: Discover system health using Fabric
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this use case, we will utilize Fabric to develop a script that executes
    multiple commands on remote machines. The goal of the script is to gather two
    types of output: the `discovery` command and the `health` command. The `discovery`
    command gathers the uptime, hostname, kernel release, and both private and public
    IP addresses, while the `health` command gathers the used memory, CPU utilization,
    number of spawned processes, and disk usage. We will design `fabfile` so that
    we can scale our script and add more commands to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that we created two dictionaries: `discover_commands` and `health_commands`.
    Each one of them contains the Linux commands as a key-value pair. The key represents
    the operation, while the value represents the actual Linux command. Then, we created
    a `tasks` list to group both dictionaries.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we created a nested `for` loop. The outer loop is used to iterate
    over the list items. The inner `for` loop is to iterate over the key-value pairs.
    Use the Fabric `run()` operation to send the command to the remote hosts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The same task (`get_system_health`) will also be executed on the second server,
    and will return the output to the Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the `fabric` module will terminate the established SSH session and
    disconnect from the two machines after executing all of the tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we could redesign the previous script and make the `discovery_commands`
    and `health_commands` a Fabric task, then include them within `get_system_health()`.
    When we execute the `fab` command, we will call `get_system_health()`, which will
    execute the other two functions; we will get the same output as before. The following
    is a modified sample script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Other useful features in Fabric
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Fabric has other useful features, such as roles and context managers.
  prefs: []
  type: TYPE_NORMAL
- en: Fabric roles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Fabric can define roles for hosts, and run only the tasks to role members.
    For example, we might have a bunch of database servers on which we need to validate
    whether the MySql service is up, and other web servers on which we need to validate
    whether the Apache service is up. We can group these hosts into roles, and execute
    functions based on those roles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we used the Fabric decorator `roles` (imported from `fabric.api`)
    when setting `env.roledef`. Then, we will assign  either webapp or databases roles
    to each server (think of the role assignment as tagging a server). This will give
    us flexibility to execute the `validate_mysql` function on servers  with database
    role only:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Fabric context managers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our first Fabric script, `fabfile_first.py`, we have a task that prompts
    the user for the directory, then switches to it and prints its content. This is
    done by using `;`, which appends two Linux commands together. However, running
    the same won't always work on other operating systems. That's where the Fabric
    context manager comes into the picture.
  prefs: []
  type: TYPE_NORMAL
- en: 'The context manager maintains the directory state when executing commands.
    It usually runs with Python by using `with-statement`, and, inside the block,
    you can write any of the previous Fabric operations. Let''s look at an example
    to explain the idea:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, first, we globally imported everything inside `fabric.context_managers`;
    then, we used the `cd` context manager to switch to the specific directory. We
    used the Fabric `run()` operation to execute the `ls` on that directory. This
    is the same as writing `cd /var/log ; ls` on the SSH session, but it provides
    a more Pythonic way to develop your code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `with` statement can be nested. For example, we can rewrite the preceding
    code with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Another useful context manager is the **local change directory** (**LCD**).
    This is the same as the `cd` context manager in the previous example, but it works
    on the local machine that runs `fabfile`. We can use it to change the context
    to a specific directory (for example, to upload or download a file to/from the
    remote machine, then change back to the execution directory automatically):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The `prefix` context manager will accept a command as input and execute it
    before any other commands, inside the `with` block. For example, you can source
    a file or a Python virtual `env` wrapper script before running each command to
    set up your virtual environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'This is actually equivalent to writing the following command in the Linux shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The final context manager is `shell_env(new_path, behavior=''append'')`, which
    can alter the shell environmental variables for wrapped commands; so, any calls
    inside of that block will take the modified path into consideration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Note that after the operation is done, Fabric will restore the old environments
    back to the original one.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Fabric is a fantastic and powerful tool that automates tasks, usually in remote
    machines. It integrates well with Python scripts, providing easy access to the
    SSH suite. You can develop many fab files for different tasks and integrate them
    together to create an automation workflow that includes deploying, restarting,
    and stopping servers or processes.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about collecting data and generating recurring
    reports for system monitoring.
  prefs: []
  type: TYPE_NORMAL
