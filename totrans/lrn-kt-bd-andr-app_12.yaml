- en: Setting Reminders for Tasks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With many real-world apps, there is the need to remind the user at some point
    to, say, take some action or give out some information. For example, a fitness
    app may alert the user to begin some workout sessions.
  prefs: []
  type: TYPE_NORMAL
- en: Here, you will build on the ToDoList app from the previous chapter by setting
    a reminder for a task, then pop up a notification when the reminder is due. You
    will learn a lot as we implement these features, using classes such as `IntentService`,
    `BroadcastReceiver`, and  `Notification`.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you are going to create a feature that allows the user to set
    reminders for tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you will have learned the following:'
  prefs: []
  type: TYPE_NORMAL
- en: To create and display notifications for the reminders set
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An introduction to push notifications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use cloud services, such as Firebase and Amazon SNS, to send push notifications,
    and
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to set up your app to receive and display push notifications to the user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All in all, the topics covered in this chapter include:'
  prefs: []
  type: TYPE_NORMAL
- en: Services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Broadcast receivers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In-app notifications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Push notifications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AlarmManager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Reminders in android can best be implemented by using the `AlarmManager`. Why?
    See what the official documentation has to say about it:'
  prefs: []
  type: TYPE_NORMAL
- en: '*These allow you to schedule your application to be run at some point in the
    future.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally:'
  prefs: []
  type: TYPE_NORMAL
- en: '*The Alarm Manager is intended for cases where you want to have your application
    code run at a specific time, even if your application is not currently running.
    For normal timing operations (ticks, timeouts, and so on) it is easier and much
    more efficient to use Handler.*'
  prefs: []
  type: TYPE_NORMAL
- en: This means you have come to the right place if you want to implement such a
    feature as a reminder. The alternative class to handle such a task, `Handler`,
    is best suited for tasks that are expected to be completed while the app is still
    in use. Your app will definitely have reminders spanning days, and probably weeks
    or months, so it is best to use the `AlarmManager` class.
  prefs: []
  type: TYPE_NORMAL
- en: This is how it will work, your app will start a background service to kick off
    the timer for the reminder, then send a broadcast to the app when it's due. Move
    on to see how to implement this.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the alarm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Basically, there are four types of alarms:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Elapsed Realtime:** This fires the pending intent based on the amount of
    time since the device was booted, but doesn''t wake up the device. The elapsed
    time includes any time during which the device was asleep.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Elapsed Realtime Wakeup:** This wakes up the device and fires the pending
    intent after the specified length of time has elapsed since device boot.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**RTC:** This fires the pending intent at the specified time, but does not
    wake up the device.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**RTC Wakeup:** This wakes up the device to fire the pending intent at the
    specified time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You are going to use RTC Wakeup alarm type to wake up the device to fire the
    alarm at the precise time the user sets.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create a dialog for the user to select the time the alarm should go
    off. Create a new class called `TimePickerFragment`. Then, update it with the
    code shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the `onCreateDialog` method, you created an instance of the  `TimePickerDialog` and
    set the default time to the current time. So, when the time picker starts, it
    will display the current time.
  prefs: []
  type: TYPE_NORMAL
- en: Then, you overrode the `onTimeSet` method to handle the user's set time. You
    first logged the time, then displayed a toast saying that the time had been set
    successfully and is recorded.
  prefs: []
  type: TYPE_NORMAL
- en: Then, you created an intent to execute the `AlarmReceiver` (you will create
    it very soon). Next was a `PendingIntent`, to be triggered when the alarm goes
    off. Then you (finally) created the alarm passing in the user's time. This alarm
    will be triggered at the exact time the user set. And, it will run only once.
  prefs: []
  type: TYPE_NORMAL
- en: Starting the reminder dialog
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open up the `MainActivity` file, to make some quick updates that will enable
    you to show the dialog.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `onCreateOptionsMenu`, make the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You have just added a reminder menu item to be displayed when the user clicks
    on a task. Now, go to `onOptionsItemSelected` to start the time picker when this
    menu item is selected. Use the following code to achieve that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, update the menu items in the `to_do_list_menu.xml` with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, add the `"reminder"` string resource in your `strings.xml` file using
    the code shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Okay, that was great. Now, remember the `AlarmReceiver` class above? What does
    it do? Move on to find out.
  prefs: []
  type: TYPE_NORMAL
- en: BroadcastReceiver
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is where you get to learn about the `BroadcastReceiver` class. According
    to the official documentation, it is the base class for code that receives and
    handles broadcast intents sent by `sendBroadcast(Intent)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Basically, it is responsible for receiving broadcast events in your app. There
    are two ways of registering this receiver:'
  prefs: []
  type: TYPE_NORMAL
- en: Dynamically, using an instance of this class with `Context.registerReceiver()`,
    or
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Statically, using the `<receiver>` tag in your AndroidManifest.xml
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An important note from the documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Beginning with Android 8.0 (API level 26), the system imposes additional restrictions
    on manifest-declared receivers. If your app targets API level 26 or higher, you
    cannot use the manifest to declare a receiver for most implicit broadcasts (broadcasts
    that do not target your app specifically).*'
  prefs: []
  type: TYPE_NORMAL
- en: Sending broadcasts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You will use the `LocalBroadcastManager` to send the notification to the user
    when the alarm sets off.  This tip from the documentation is why it is better
    to use this method of broadcasting:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"If you don''t need to send broadcasts across apps, use local broadcasts.
    The implementation is much more efficient (no interprocess communication needed)
    and you don''t need to worry about any security issues related to other apps being
    able to receive or send your broadcasts."*'
  prefs: []
  type: TYPE_NORMAL
- en: 'And, this tells us why it is efficient:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Local Broadcasts can be used as a general purpose pub/sub event bus in your
    app without any overheads of system wide broadcasts.*'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a broadcast receiver
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new file and name it `AlarmReceiver`, and have it extend `BroadcastReceiver`.
    Then, update it with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: All you did was to override the `onReceive` method to start an `IntentService`
    called `AlarmService` (this class will be responsible for showing the notification).
    Well, the log statement is only there to help with debugging.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before moving on, register the service in your `AndroidManifest.xml` just as
    the `MainActivity` component is. Here, you only need the `name` property, though:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now, proceed to create the `AlarmService` started by the `AlarmReceiver`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the AlarmService
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**IntentService**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first hear what the official documentation has to say:'
  prefs: []
  type: TYPE_NORMAL
- en: <q>"`IntentService` is a base class for `Services` that handles asynchronous
    requests (expressed as Intents) on demand. Clients send requests through `startService(Intent)` calls;
    the service is started as needed, handles each Intent in turn using a worker thread,
    and stops itself when it runs out of work."</q>
  prefs: []
  type: TYPE_NORMAL
- en: '`IntentService` is a `Service` component that handles requests via `Intents`.
    After receiving the `Intent`, it starts a worker thread to run the task, and stops
    when the work is done, or whenever it is appropriate as per the given work.'
  prefs: []
  type: TYPE_NORMAL
- en: The key thing here is the ability it gives your app to do some work without
    any interference. This is unlike the `Activity` component, for instance, which
    has to be in the foreground to run a task. `AsyncTasks` help with that but it's
    still not as flexible and is just not suitable for such a long-running task like
    this. Move on to see it in action.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note:**'
  prefs: []
  type: TYPE_NORMAL
- en: '`IntentService` has it''s own single worker thread for handling the requests'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Only one request will be processed at a time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an IntentService
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a subclass of the `IntentService` called `ReminderService`. You will
    have to override the `onHandleIntent()` method to well, handle the `Intent`. Then,
    you would build a `Notification` instance to notify the user that the reminder
    is due:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Stepping through the code, this is what you just did:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `onCreate()`, you saved an instance of the `applicationContext` for later
    use.
  prefs: []
  type: TYPE_NORMAL
- en: In `onHandleIntent()`, you used the Kotlin safety check feature to ensure you
    call the `showNotification()` method on a non-null instance.
  prefs: []
  type: TYPE_NORMAL
- en: In `showNotification()`, you used the `NotificationCompat` builder to create
    a Notification instance. You set the title and content for the notification as
    well. Then, using a `NotificationManager`, you triggered the notification. The
    ID parameter in the `notify()` method is an identification for this notification
    unique to your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'You need to register the service too. Here is how:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: You should be familiar with this, except for `android:exported`. That just means
    we are disallowing any external application from interacting with this service.
  prefs: []
  type: TYPE_NORMAL
- en: Here are a few important limitations to note about the `IntentService` class.
  prefs: []
  type: TYPE_NORMAL
- en: It can't interact directly with your user interface. To put its results in the
    UI, you have to send them to an Activity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Work requests run sequentially. If an operation is running in an `IntentService`,
    and you send it another request, the request waits until the first operation is
    finished.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An operation running on an `IntentService` can't be interrupted.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is now time to run your app. The alarm should fire and you should see a notification
    indicating that.
  prefs: []
  type: TYPE_NORMAL
- en: There are other ways to send notifications to your app. Keep reading to learn
    about push notifications.
  prefs: []
  type: TYPE_NORMAL
- en: Firebase Cloud Messaging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"Firebase Cloud Messaging (FCM) is a cross-platform messaging solution that
    lets you reliably deliver messages at no cost." That, I believe, is the best brief
    description of this service. It is actually part of a suite of many other services
    on the Firebase platform created and run by Google.'
  prefs: []
  type: TYPE_NORMAL
- en: You have integrated In-app notifications, and now you shall see how to implement
    push notifications using FCM.
  prefs: []
  type: TYPE_NORMAL
- en: In-app notifications basically means that the notification is triggered by and
    from within the app. Push notifications, on the other hand, are sent from an external
    source.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating FCM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Set up FCM SDK
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You first have to add the **SDK** (**Software Development Kit**) to your app.
    You should make sure you are targeting at least Android 4.0 (Ice Cream Sandwich).
    It should have the Google Play Store app installed, or an emulator running Android
    4.0 and Google APIs. Your Android Studio version should be at least 2.2\. You
    will use the Firebase Assistant window within Android Studio to do the integration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, make sure you have installed Google Repository version 26 or higher,
    using the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Click **Tools** | **Android** | **SDK Manager**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **SDK Tools** tab
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check the **Google Repository** checkbox, and click **OK**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **OK** to install
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Background** to complete the installation in the background, or wait
    for the installation to complete and click **Finish**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can now open and use the **Assistant** window in Android Studio by following
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click **Tools **| **Firebase** to open the **Assistant** window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6a103bf5-54c6-4953-bb1e-7fb70d374d00.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Click to expand and select Cloud Messaging, then click the **Set up Firebase
    Cloud Messaging** tutorial to connect to Firebase and add the necessary code to
    your app:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c7568e23-bace-4d3a-9697-159c82d508d0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This is how the assistant looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/25b92672-0964-4447-8cdb-5d4286a39680.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you complete the walk-through with the Firebase assistant successfully,
    you will have the following things done:'
  prefs: []
  type: TYPE_NORMAL
- en: Registered your app on Firebase
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added the SDK to your app by making the following updates to your root-level `build.gradle`
    file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in your module''s `build.gradle` file, it will add the `apply plugin` line
    at the bottom of the file, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Update your manifest with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This is required if you want to manually handle the message received from the
    FCM while the app is running. You, however, will not need this now as there is
    one a way of showing the notification without your intervention.
  prefs: []
  type: TYPE_NORMAL
- en: 'For that functionality, you will instead need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: You will now create the `MyFirebaseInstanceIDService` class to extend `FirebaseInstanceIdService`.
  prefs: []
  type: TYPE_NORMAL
- en: If, for some reason, any of these are not done, you can manually log in to Firebase
    website and follow the steps following to create the project on Firebase and update
    your app's build files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the Firebase website, the first thing to do after login is to add your
    project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/914faa3a-4529-45b6-b103-f400d3bb3acd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You will then be asked to enter the name of the project. Enter **ToDoList**
    for the **Project name**. It will automatically generate a globally unique **Project
    ID** for you. Then, choose your country of residence, and hit the **CREATE PROJECT**
    button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e4b145b2-7a66-4355-8d4f-0460f2d1b889.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After this, choose the desired platform. Note that Firebase is not only used
    for Android but iOS and web as well. Therefore, choose the **Add Firebase to your
    Android app** option:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a2c42a0d-1f87-4584-917b-dc01c619c669.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now you will be taken through a three-step process:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to register your app by supplying your package name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/2d277a5f-f983-442e-950f-14ab98434a00.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In this step, you will only download the **google-services.json** file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e58c83cd-c1b9-46de-bf7c-d5110e6a68d2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, in the final step, you add the SDK to your app. Note that this is not
    necessary if you have already done so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/16d7f695-9998-4fb9-a6dc-6f5a6b7c7927.png)'
  prefs: []
  type: TYPE_IMG
- en: 'That''s it. You have added your app on Firebase. You will now be shown the
    page for your newly created project. Here, you will see all the services available
    to your app. Select the **Notifications** service and click **GET STARTED**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b4675cee-3c50-4ef6-b5be-65aed39271ba.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You will now be shown the following page. Click on the **SEND YOUR FIRST MESSAGE**
    button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/93d004bb-9bd4-446d-bfdc-8aaa227f0d75.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, choose **Compose message**. Here, enter the message to be sent in the **Message
    text** box. Select **Single device** as the target. After entering the **FCM registration
    token**, you will hit the **SEND MESSAGE** button to send the notification. Read
    on to find out how to get the registration token:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6bae15c3-2af4-4d1d-8c3f-c1e22308904d.png)'
  prefs: []
  type: TYPE_IMG
- en: Registration Token
  prefs: []
  type: TYPE_NORMAL
- en: 'When you run your app for the first time after setting up the FCM, the FCM
    SDK will generate a token for your app. This token will change under the following
    circumstances, and a new one will be generated accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: The app deletes the instance ID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The app is restored on a new device
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The user uninstalls/reinstalls the app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The user clears app data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This token must be kept private. To access this token, you will log it to your
    `Logcat` console. First, open `MyFirebaseInstanceIDservice` and update it with
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now that you have the key, paste it into the **Compose message** box above and
    hit the **SEND MESSAGE** button. You should see the notification on your phone
    shortly after that.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you learned how to create background services, send broadcast
    messages, show in-app notifications and push notifications using Firebase. There
    are a few things you can do on your own to deepen your understanding of these
    topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Instead of notifying the user using some static message, use the description
    of the task for which the reminder was set
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Firebase, you can also try sending the push notification to a group of
    people instead of a single device
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
