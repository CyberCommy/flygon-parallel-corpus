- en: Handling Events with Signals and Slots
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Composing widgets into a nice-looking form is a good first step for designing
    an application, but for a GUI to be of any use, it needs to be connected to code
    that actually does something. In order to do this in PyQt, we need to learn about
    one of Qt's most vital features, **signals and slots**.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Signal and slot basics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating custom signals and slots
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automating our calendar form
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Along with the basic requirements listed in [Chapter 1](bce5f3b1-2979-4f78-817b-3986e7974725.xhtml), *Getting
    Started with PyQt*, you will need your calendar-form code and Qt Designer files
    from [Chapter 2](2e39f2dd-7df5-4139-8c26-1fec2dfb68d0.xhtml), *Building Comprehensive
    Forms with QtWidgets*. You may also wish to download the example code from our
    GitHub repository at [https://github.com/PacktPublishing/Mastering-GUI-Programming-with-Python/tree/master/Chapter03](https://github.com/PacktPublishing/Mastering-GUI-Programming-with-Python/tree/master/Chapter03).
  prefs: []
  type: TYPE_NORMAL
- en: Check out the following video to see the code in action: [http://bit.ly/2M5OFQo](http://bit.ly/2M5OFQo)
  prefs: []
  type: TYPE_NORMAL
- en: Signal and slot basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **signal** is a special property of an object that can be emitted in response
    to a type of **event**. An event may be something such as a user action, a timeout,
    or the completion of an asynchronous method call.
  prefs: []
  type: TYPE_NORMAL
- en: '**Slots** are object methods that can receive a signal and act in response
    to it. We connect signals to slots in order to configure our application''s response
    to an event.'
  prefs: []
  type: TYPE_NORMAL
- en: All classes descended from `QObject` (which accounts for most classes in Qt,
    including all `QWidget` classes) can send and receive signals. Each different
    class has its own set of signals and slots appropriate for the function of that
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, `QPushButton` has a `clicked` signal that is emitted whenever
    the button is clicked by a user. The `QWidget` class has a `close()` slot that
    causes it to close if it''s a top-level window. We could connect the two like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If you copy this code into our application template and run it, you'll find
    that clicking the Quit button closes the window and ends the program. The syntax
    for connecting a signal to a slot in PyQt5 is `object1.signalName.connect(object2.slotName)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also make connections when creating an object by passing a slot to
    a signal as a keyword argument. For example, the previous code could be rewritten
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: C++ and older versions of PyQt use a very different syntax for signals and slots,
    which uses `SIGNAL()` and `SLOT()` wrapper functions. These don't exist in PyQt5,
    so bear this in mind if you're following an older tutorial or non-Python documentation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Signals can also carry data with them that slots can receive. For example, `QLineEdit`
    has a `textChanged` signal that sends the text entered into the widget along with
    the signal. The line edit also has a `setText()` slot that accepts a string argument.
    We could connect those like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we've connected the `textChanged` signal of `entry1` to the
    `setText()` slot of `entry2`. That means whenever the text is changed in `entry1`,
    it will signal `entry2` with the text entered; `entry2` will set its own text
    to the received string, causing it to mirror whatever is entered in `entry1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In PyQt5, a slot doesn''t have to be an official Qt slot method; it can be
    any Python callable, such as a custom method or a built-in function. For example,
    let''s connect the `entry2` widget''s `textChanged` to good old `print()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now, you'll see that every change to `entry2` is printed to the console. The
    `textChanged` signal basically calls `print()` every time it fires, passing in
    the text carried with the signal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Signals can even be connected to other signals, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We've connected the `entry2` widget's `returnPressed` signal (which is emitted
    whenever the user presses *return*/*Enter* while focused on the widget) to the
    `entry1` widget's `editingFinished` signal, which in turn is connected to a `lambda`
    function that prints a message. When you connect a signal to another signal, the
    event and data are passed from one signal to the next. The net result is that
    triggering `returnPressed` on `entry2` causes `editingFinished` to be emitted
    by `entry1`, which in turn runs the `lambda` function.
  prefs: []
  type: TYPE_NORMAL
- en: Restrictions on signal and slot connections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While PyQt offers amazing flexibility by allowing us to connect signals to any
    Python callable, there are a few rules and limitations that you need to keep in
    mind. C++, unlike Python, is a **statically typed** language, which means that
    variables and function arguments must be given a type (`string`, `integer`, `float`,
    or one of many other types) and any value stored in the variable or passed to
    that function must have a matching type. This is called **type safety**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Native Qt signals and slots are type-safe. Suppose, for instance, we tried
    to connect a line edit''s `textChanged` signal to the button''s `clicked` signal,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This won''t work, because `textChanged` emits a string, and `clicked` emits
    (and therefore expects to receive) a Boolean. If you run this, you''ll get an
    error such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Slots can have multiple implementations, each with its own **signature**, allowing
    the same slot to take different argument types. This is called an **overloaded**
    slot. As long as our signal signature matches any of the overloaded slots, we
    can make the connection and Qt will work out which one we're connecting to.
  prefs: []
  type: TYPE_NORMAL
- en: When connecting to a slot that is a Python function, we don't have to be worried
    about argument types because Python is **dynamically typed** (though it's up to
    us to make sure our Python code does the right thing with whatever object is passed
    to it). As with any call to a Python function, however, we do need to make sure
    we pass in enough arguments to satisfy the function signature.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s add a method to our `MainWindow` class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This instance method needs three arguments (`self` is automatically passed).
    Let''s try to connect a button''s `clicked` signal to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This code doesn''t object to the connection itself, but when you click the
    button, the program crashes with this error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Since the `clicked` signal only sends one argument, the function call is incomplete
    and it throws an exception. This can be solved by making `arg2` and `arg3` into
    keyword arguments (by adding default values), or by creating a wrapper function
    that populates them with values some other way.
  prefs: []
  type: TYPE_NORMAL
- en: Incidentally, the inverse situation—where the slot takes fewer arguments than
    the signal sends—is not a problem. Qt just drops the extra data from the signal.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, for example, there is no problem connecting `clicked` to a method with
    no arguments, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Creating custom signals and slots
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Setting callbacks for button clicks and text changes is a common and very obvious
    use for signals and slots, but it is really only the beginning. At its core, the
    signals and slots mechanism can be seen as a way for any two objects in an application
    to communicate while remaining **loosely coupled**.
  prefs: []
  type: TYPE_NORMAL
- en: Loose coupling refers to keeping the amount of information two objects need
    to know about each other to a minimum. It's an essential trait to preserve when
    designing large, complex applications because it isolates code and prevents inadvertent
    breakage. The opposite is tight coupling, where one object's code depends heavily
    on the internal structures of another.
  prefs: []
  type: TYPE_NORMAL
- en: In order to take full advantage of this functionality, we'll need to learn how
    to create our own custom signals and slots.
  prefs: []
  type: TYPE_NORMAL
- en: Sharing data between windows using custom signals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Suppose you have a program that pops up a form window. When the user finishes
    filling in the form and submits it, we need to get the entered data back to the
    main application class for processing. There are a few ways we could approach
    this; for instance, the main application could watch for click events on the pop-up
    window's **Submit** button, then grab the data from its fields before destroying
    the dialog. But that approach requires the main form to know all about the pop-up
    dialog's widgets, and any refactor of the popup would risk breaking code in the
    main application window.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try a different approach using signals and slots. Open a fresh copy
    of our application template from [Chapter 1](bce5f3b1-2979-4f78-817b-3986e7974725.xhtml),
    *Getting Started with PyQt*, and start a new class called `FormWindow`, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The first thing we've defined in this class is a custom signal called `submitted`.
    To define a custom signal, we need to call the `QtCore.pyqtSignal()` function.
    The arguments to `pyqtSignal()` are the data types our signal will be carrying,
    in this case, `str`. We can use Python `type` objects here, or strings naming
    a C++ data type (`'QString'`, for example).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s build the form by defining the `__init__()` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we''re defining a `QLineEdit` for data entry and a `QPushButton` for
    submitting the form. The button-click signal is bound to a method called `onSubmit`,
    which we''ll define next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In this method, we call the `submitted` signal's `emit()` method, passing in
    the contents of `QLineEdit`. This means that any connected slots will be called
    with the string retrieved from `self.edit.text()`.
  prefs: []
  type: TYPE_NORMAL
- en: After emitting the signal, we close the `FormWindow`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Down in our `MainWindow` constructor, let''s build an application that uses
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Here, we've created a `QLabel` and a `QPushButton` and added them to a vertical
    layout. When clicked, the button calls a method called `onChange()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `onChange()` method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This method creates an instance of our `FormWindow`. It then binds our custom
    signal, `FormWindow.submitted`, to the `setText` slot of the label; `setText`
    takes a single string for an argument, and our signal sends a single string.
  prefs: []
  type: TYPE_NORMAL
- en: If you run this application, you'll see that when you submit the pop-up form
    window, the text in the label does indeed change.
  prefs: []
  type: TYPE_NORMAL
- en: The beauty of this design is that `FormWindow` doesn't need to know anything
    whatsoever about `MainWindow`, and `MainWindow` only needs to know that `FormWindow`
    has a `submitted` signal that emits the entered string. We could easily modify
    the structure and internals of either class, without causing issues for the other,
    as long as the same signal emits the same piece of data.
  prefs: []
  type: TYPE_NORMAL
- en: '`QtCore` also contains a `pyqtSlot()` function, which we can use as a decorator
    to indicate that a Python function or method is intended as a slot.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can decorate our `MainWindow.onChange()` method to declare
    it as a slot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This is purely optional, since we can use any Python callable as a slot, though
    it does give us the ability to enforce type safety. For instance, if we wanted
    to require that `onChange()` should always receive a string, we could decorate
    it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'If you do this and run the program, you''ll see that our attempt to connect
    a `clicked` signal would fail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Apart from imposing type safety, declaring a method as a slot reduces its memory
    usage and provides a small improvement in speed. So, while it's entirely optional,
    it may be worth doing for methods that will only ever be used as slots.
  prefs: []
  type: TYPE_NORMAL
- en: Overloading signals and slots
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just as C++ signals and slots can be overloaded to accept different argument
    signatures, we can overload our custom PyQt signals and slots. For instance, suppose
    that, if a valid integer string is entered into our pop-up window, we'd like to
    emit it as both a string and an integer.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we first have to redefine our signal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of just passing in a single variable type, we''re passing in two lists
    of variable types. Each list represents the argument list of a signal signature.
    So, we''ve registered two signals here: one that sends out a string only, and
    one that sends out an integer and a string.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `FormWindow.onSubmit()`, we can now examine the text in the line edit and
    send out the signal with the appropriate signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Here, we test the text in `self.edit` to see whether it's a valid number string.
    If it is, we convert it to `int` and emit the `submitted` signal with the integer
    and string version of the text. The syntax for selecting a signature is to follow
    the signal name with square brackets containing a list of the argument types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in the main window, we''ll define two new methods to handle these signals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve created two slots—one that accepts a string and another that accepts
    an integer and a string. We can now connect the two signals in `FormWindow` to
    the appropriate slot like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Run the script, and you'll find now that entering a string of digits will print
    a different message than an alphanumeric string.
  prefs: []
  type: TYPE_NORMAL
- en: Automating our calendar form
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To see how signal and slot usage works in an actual application, let''s take
    the calendar form that we built in [Chapter 2](2e39f2dd-7df5-4139-8c26-1fec2dfb68d0.xhtml), *Building
    Forms with QtWidgets*, and turn it into a working calendar application. To do
    this, we''re going to need to make the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: The app needs a way to store events that we enter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The All Day checkbox should disable the time entry when checked.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selecting a day on the calendar should populate the event list with the events
    for that day.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selecting an event in the event list should populate the form with the event's
    details.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clicking Add/Update should update the saved event details if an event was selected,
    or add a new event if one was not.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clicking Delete should remove the selected event.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If no event is selected, Delete should be disabled.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selecting New… as a category should open a dialog allowing us to enter a new
    category. If we choose to enter one, it should be selected.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll first go through this using our hand-coded form, then talk about how to
    approach the same issue using Qt Designer files.
  prefs: []
  type: TYPE_NORMAL
- en: Using our hand-coded form
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To get started, copy your `calendar_form.py` file from [Chapter 2](2e39f2dd-7df5-4139-8c26-1fec2dfb68d0.xhtml), *Building
    Forms with QtWidgets,* into a new file called `calendar_app.py` and open it in
    your editor. We're going to start editing our `MainWindow` class and flesh it
    out into a complete application.
  prefs: []
  type: TYPE_NORMAL
- en: 'To handle storing the events, we''ll just create a `dict` property in `MainWindow`,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re not going to bother persisting data to disk, though you can certainly
    add such a feature if you wish. Each item in `dict` will use a `date` object as
    its key and contain a list of `dict` objects holding the details of all the events
    on that date. The layout of the data will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Next, let's dig into the form automation. The easiest change to make is disabling
    the time entry when the All Day checkbox is clicked since this automation only
    requires dealing with built-in signals and slots.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `__init__()` method, we''ll add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The `QCheckBox.toggled` signal is emitted whenever the checkbox is toggled on
    or off, and sends out a Boolean indicating whether the checkbox is (post-change)
    unchecked (`False`) or checked (`True`). This connects nicely to `setDisabled`,
    which will disable the widget on `True` or enable it on `False`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and connecting our callback methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The rest of our required automation doesn't map to built-in Qt slots, so before
    we can connect any more signals, we'll need to create some methods that will be
    used to implement the slots. We'll create all these as methods of the `MainWindow`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we start with the callbacks, we''ll create a utility method to clear
    out the form, which several of the callback methods will need. It looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Essentially, this method goes through the fields in our form and sets them all
    to default values. Unfortunately, this requires a different method call for each
    widget, so we just have to spell it all out.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's go through the callback methods.
  prefs: []
  type: TYPE_NORMAL
- en: The populate _list () method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first actual callback method is `populate_list()`, which looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This will be called whenever the calendar selection is changed, and its job
    is to repopulate the `event_list` widget with the events from that day. It starts
    by clearing the list and the form. It then retrieves the selected date from the
    calendar widget using its `selectedDate()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we cycle through the list of events for the selected date's `self.events`
    dictionary, building a string containing the time and event title and adding it
    to the `event_list` widget. Note that our event time is a `QTime` object, so to
    use it as a string we need to convert it using its `toString()` method.
  prefs: []
  type: TYPE_NORMAL
- en: See the `QTime` documentation at [https://doc.qt.io/qt-5/qtime.html](https://doc.qt.io/qt-5/qtime.html)
    for details on how to format time values as strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'To connect this method, back in `__init__()`, we add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The `selectionChanged` signal is emitted whenever a new day is selected on the
    calendar. It does not send any data with the signal, so our callback does not
    expect any.
  prefs: []
  type: TYPE_NORMAL
- en: The populate _form () method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next callback is `populate_form()`, which will be called when an event
    is selected and populate the event details form. It begins like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Here, we start by clearing the form, then retrieving the selected date from
    the calendar, and the selected event from the event list. When no event is selected,
    `QListWidget.currentRow()` returns a value of `-1`; in that case, we'll just return,
    leaving the form blank.
  prefs: []
  type: TYPE_NORMAL
- en: 'The remainder of the method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Since the items on the list widget are displayed in the same order that they're
    stored in the `events` dictionary, we can use the row number of the selected item
    to retrieve an event from the selected date's list.
  prefs: []
  type: TYPE_NORMAL
- en: Once the data is retrieved, we just need to set each widget to the saved value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in `__init__()`, we''ll connect the slot like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '`QListWidget` emits `itemSelectionChanged` whenever a new item is selected.
    It doesn''t send any data with it, so again, our callback expects none.'
  prefs: []
  type: TYPE_NORMAL
- en: The save _event () method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `save_event()` callback will be called whenever the Add/Update button is
    pushed. It starts like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In this code, we are now calling the accessor methods to retrieve the values
    from the widgets and assign them to the appropriate keys of the event's dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we''ll retrieve the current event list for the selected date and determine
    whether this is an addition or an update:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember that `QListWidget.currentRow()` returns `-1` if no items are selected.
    In which case, we want to append our new event to the list. Otherwise, we replace
    the selected event with our new event dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: To finish this method, we're going to sort the list using the time value. Remember
    that we're using `None` for an all-day event, so those will be sorted first by
    replacing them in the sort with a `QTime` of 0:00.
  prefs: []
  type: TYPE_NORMAL
- en: After sorting, we replace the event list for the current date with our newly
    sorted list and repopulate the `QListWidget` with the new list.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll connect the `add_button` widget''s `clicked` event by adding this code
    to `__init__()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The delete _event () method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `delete_event` method will be called whenever the Delete button is clicked,
    and it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Once again, we retrieve the current date and currently selected row and use
    them to locate the event in `self.events` that we want to delete. After deleting
    the item from the list, we set the list widget to no selection by setting `currentRow`
    to `-1`. Then, we clear the form and populate the list widget.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we don't bother checking to see whether the currently selected row
    is `-1`, because we plan to disable the delete button when no row is selected.
  prefs: []
  type: TYPE_NORMAL
- en: 'This callback is pretty simple to connect to the `del_button` back in `__init__()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The check _delete _btn () method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our last callback is the simplest of all, and it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This method simply checks whether there is no event currently selected in the
    event list widget, and it enables or disables the delete button accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in `__init__()`, let''s connect to this callback:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: We're connecting this callback to the `itemSelectionChanged` signal. Note that
    we've already connected that signal to another slot as well. Signals can be connected
    to any number of slots without a problem. We also call the method directly, so
    that the `del_button` will start out disabled.
  prefs: []
  type: TYPE_NORMAL
- en: Building our new category pop-up form
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The last feature we want in our application is the ability to add new categories
    to our combo box. The basic workflow we need to implement is this:'
  prefs: []
  type: TYPE_NORMAL
- en: When a user changes the event category, check whether they selected New…
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If so, open a form in a new window that lets them type in a category
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the form is submitted, emit the name of the new category
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When that signal is emitted, add a new category to the combo box and select
    it
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the user opts not to enter a new category, default the combo box to Select
    Category…
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s start by implementing our pop-up form. This will be just like the form
    example we went through earlier in this chapter, and it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This class is the same as our `FormWindow` class with the addition of a label
    and a Cancel button. The `cancel_btn` widget will call the window's `close()`
    method when clicked, causing the window to close without emitting any signals.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in `MainWindow`, let''s implement a method to add a new category to the
    combo box:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This method is pretty simple; it just receives a category text, adds it to the
    end of the combo box, and sets the combo box selection to the new category.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need to write a method that will create an instance of our pop-up form
    whenever New… is selected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: This method takes the `text` value to which the category has been changed and
    checks to see whether it's New…. If it is, we create our `CategoryWindow` object
    and connect its `submitted` signal to our `add_category()` method. Then, we set
    the current index to `0`, which is our Select Category… option.
  prefs: []
  type: TYPE_NORMAL
- en: Now, when `CategoryWindow` is shown, the user will either click Cancel, in which
    case the window will close and the combo box will be set to Select Category… where
    `on_category_change()` left it, or the user will enter a category and click Submit,
    in which case `CategoryWindow` will emit a `submitted` signal with the new category.
    The `add_category()` method will receive that new category, add it, and set the
    combo box to it.
  prefs: []
  type: TYPE_NORMAL
- en: Our calendar app is now complete; fire it up and give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: Using Qt Designer .ui files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now let's back up and go through that same process using the Qt Designer files
    we created in [Chapter 2](2e39f2dd-7df5-4139-8c26-1fec2dfb68d0.xhtml), *Building
    Forms with QtWidgets*. This will require a rather different approach, but the
    end product will be the same.
  prefs: []
  type: TYPE_NORMAL
- en: To work through this section, you'll need both your `calendar_form.ui` file
    from [Chapter 2](2e39f2dd-7df5-4139-8c26-1fec2dfb68d0.xhtml), *Building Forms
    with QtWidgets* and a second `.ui` file for the category window. You can build
    this form on your own as practice, or use the one included with the example code
    for this chapter. If you choose to build your own, make sure to name each object
    just as we did in the code in the last section.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting slots in Qt Designer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Qt Designer has a limited capability to connect signals and slots to our GUI.
    For Python developers, its mainly only useful for connecting built-in Qt signals
    to built-in Qt slots between widgets in the same window. Connecting signals to
    Python callables or custom PyQt signals isn't really possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the calendar GUI, we do have one example of a native Qt signal-slot connection—the
    `allday_check` widget is connected to the `event_time` widget. Let''s look at
    how to connect these in Qt Designer:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `calendar_form.ui` file in Qt Designer
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the lower-right side of the screen, find the Signal/Slot Editor panel
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the + icon to add a new connection
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under Sender, open the pop-up menu and select `allday_check`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under Signal, choose toggled(bool)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For Receiver, choose `event_time`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, for Slot, choose setDisabled(bool)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The resulting entry should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/f8145b67-f651-4977-9b7f-6e0c23b01bf5.png)'
  prefs: []
  type: TYPE_IMG
- en: If you're building your own `category_window.ui` file, make sure you also connect
    the cancel button's `clicked` signal to the category window's `closed` slot.
  prefs: []
  type: TYPE_NORMAL
- en: Converting .ui files to Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you were to open your `calendar_form.ui` file in a text editor, you'd see
    that it is neither Python nor C++, but rather an XML representation of the GUI
    you've designed. PyQt offers us a few choices for how to use the `.ui` file in
    a Python application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first approach is to convert the XML into Python using the `pyuic5` tool
    included with PyQt. Open a command-line window in the directory where your `.ui`
    files are and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'This will generate a file called `calendar_form.py`. If you open this file
    in your code editor, you''ll see that it contains a single class definition for
    a `Ui_MainWindow` class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Notice that this class is not a subclass of `QWidget` or even `QObject`. By
    itself, this class will not display the window we built. Instead, this class will
    build the GUI we designed inside another widget, which we must create with code.
  prefs: []
  type: TYPE_NORMAL
- en: To do that, we'll import the class into another script, create a `QWidget` to
    serve as a container, and call the `setupUi()` method with our widget container
    as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: Don't be tempted to edit or add code to the generated Python file. If you ever
    want to update your GUI using Qt Designer, you'll lose all your edits when you
    generate the new file. Treat the generated code as if it were a third-party library.
  prefs: []
  type: TYPE_NORMAL
- en: Start by copying the PyQt app template from [Chapter 1](bce5f3b1-2979-4f78-817b-3986e7974725.xhtml), *Getting
    Started with PyQt*, into the directory with `calendar_form.py` and call it `calendar_app.py`.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top of the file, import the `Ui_MainWindow` class like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: There are a few ways we can use this class, but the cleanest is to use **multiple
    inheritances** by adding it as a second parent class for `MainWindow`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `MainWindow` class definition like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Note that our window's base class (the first parent class) remains `QWidget`.
    This base class needs to match the base class we chose when we initially designed
    the form (see [Chapter 2](2e39f2dd-7df5-4139-8c26-1fec2dfb68d0.xhtml), *Building
    Forms with QtWidgets*).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, inside the constructor, we can call `setupUi`, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run the application at this point, you''ll see that the calendar GUI
    is all there, including our connection between `allday_check` and `event_time`.
    You can then add the remaining connections and modifications into the `MainWindow`
    constructor, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The callback methods for this class are identical to the ones we defined in
    our code-only example. Go ahead and copy those into the `MainWindow` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to use the `Ui_` class created by `pyuic5` is to instantiate it
    as a property of our container widget. We''ll try this with our category window;
    add this class to the top of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: After creating the `Ui_CategoryWindow` object as a property of `CategoryWindow`,
    we then call its `setupUi()` method to build the GUI on `CategoryWindow`. However,
    all our references to the widgets are now under the `self.ui` namespace. So, for
    example, `category_entry` is not `self.category_entry` but `self.ui.category_entry`.
    While this approach is slightly more verbose, it may help to avoid name collisions
    if you're building a particularly complex class.
  prefs: []
  type: TYPE_NORMAL
- en: Automatic signal and slot connections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Take another look at the `Ui_` class generated by `pyuic5` and notice the last
    line of code in `setupUi`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '`connectSlotsByName()` is a method that will automatically connect signals
    and slots by matching up signals to methods named in the `on_object_name_signal()` format, where
    `object_name` matches the `objectName` property of a `PyQt` object and `signal`
    is the name of one of its built-in signals.'
  prefs: []
  type: TYPE_NORMAL
- en: For example, in our `CategoryWindow`, we would like to create a callback that
    runs when `submit_btn` is clicked (if you made your own `.ui` file, make sure
    you named your submit button `submit_btn`). That will happen automatically if
    we name the callback `on_submit_btn_clicked()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: If we get the names to match up, we don't have to explicitly call `connect()`
    anywhere; the callback will be wired up automatically.
  prefs: []
  type: TYPE_NORMAL
- en: You can use `connectSlotsByName()` with hand-coded GUIs as well; you just need
    to explicitly set each widget's `objectName` property so that the method has something
    to match the name against. Variable names alone won't work.
  prefs: []
  type: TYPE_NORMAL
- en: Using .ui files without conversion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you don't mind a little conversion overhead during runtime, you can actually
    avoid the step of manually converting your `.ui` files by converting them on the
    fly inside your program using PyQt's `uic` library (on which `pyuic5` is based).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try this with our `MainWindow` GUI. Start by commenting out your import
    of `Ui_MainWindow` and importing `uic`, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, before your `MainWindow` class definition, call `uic.loadUiType()`, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '`loadUiType()` takes a path to the `.ui` file and returns a tuple containing
    the generated UI class and the Qt base class on which it is based (in this case,
    `QWidget`).'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then use these as the parent classes for our `MainWindow` class, like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The downside of this approach is the additional conversion time, but with the
    added benefit of a simpler build and fewer files to maintain. This is a good approach
    to take during early development, when you may be iterating on your GUI design
    frequently.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about Qt's inter-object communication feature,
    signals and slots. You learned how to use them to automate form behavior, to connect
    functionality to user events, and to communicate between different windows in
    an application.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we're going to learn about `QMainWindow`, a class that
    simplifies building common application components. You'll learn how to quickly
    create menus, toolbars, and dialog, as well as how to save settings.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Try these questions to test your knowledge of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at the following table and determine which of the connections could actually
    be made, and which would result in an error. You may need to look up the signatures
    of these signals and slots in the documentation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| # | Signal | Slot |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | `QPushButton.clicked` | `QLineEdit.clear` |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | `QComboBox.currentIndexChanged` | `QListWidget.scrollToItem` |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | `QLineEdit.returnPressed` | `QCalendarWidget.setGridVisible` |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | `QLineEdit.textChanged` | `QTextEdit.scrollToAnchor` |'
  prefs: []
  type: TYPE_TB
- en: The `emit()` method does not exist on a signal object until the signal has been
    bound (that is, connected to a slot). Rewrite the `CategoryWindow.onSubmit()`
    method from our first `calendar_app.py` file to protect against the possibility
    of `submitted` being unbound.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You find an object in the Qt documentation with a slot that requires a `QString`
    as an argument. Can you connect your custom signal that sends Python's `str`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You find an object in the Qt documentation with a slot that requires a `QVariant`
    as an argument. What built-in Python types could you send to this slot?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You''re trying to create a dialog window that takes time and emits it when
    the user has finished editing the value. You''re trying to use automatic slot
    connections, but your code isn''t doing anything. Determine what is missing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: You've created a `.ui` file in Qt Designer for a calculator application, and
    you're trying to get it working in code, but it's not working. What are you doing
    wrong in the following source code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'You''re trying to create a new button class that emits an integer value when
    clicked; unfortunately, nothing happens when you click the button. Look at the
    following code and try to make it work:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Check out these resources for more information:'
  prefs: []
  type: TYPE_NORMAL
- en: PyQt's documentation on signal and slot support can be found here at [http://pyqt.sourceforge.net/Docs/PyQt5/signals_slots.html](http://pyqt.sourceforge.net/Docs/PyQt5/signals_slots.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PyQt's documentation on using Qt Designer can be found here at [http://pyqt.sourceforge.net/Docs/PyQt5/designer.html](http://pyqt.sourceforge.net/Docs/PyQt5/designer.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
