- en: Scratching the Tip of the Iceberg
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Working with graphs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visualizing graphs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a true random number generator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using portable math functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing test cases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combining multiple test cases in one test module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manipulating images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Boost is a huge collection of libraries. Some of these libraries are small and
    meant for everyday use, while others require a separate book to describe all their
    features. This chapter is devoted to some of those big libraries and provides
    a basic understanding of it.
  prefs: []
  type: TYPE_NORMAL
- en: The first two recipes will explain the usage of `Boost.Graph`. It is a big library
    with an insane number of algorithms. We'll see some basics and probably the most
    important part of development--visualization of graphs.
  prefs: []
  type: TYPE_NORMAL
- en: We'll also see a very useful recipe for generating true random numbers. This
    is a very important recipe for writing secure cryptography systems.
  prefs: []
  type: TYPE_NORMAL
- en: Some C++ standard libraries lack math functions. We'll see how that can be fixed
    using Boost. But, the format of this book leaves no space for describing all the
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: Writing test cases is described in the *Writing test cases* and *Combining multiple
    test cases in one test module* recipes. This is important for any production-quality
    system.
  prefs: []
  type: TYPE_NORMAL
- en: The last recipe is about a library that helped me in a lot of my course work
    during my university days. Images can be created and modified using it. I personally
    used it to visualize different algorithms, hide data in images, sign images, and
    generate textures.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, even this chapter cannot tell you about all the Boost libraries.
    Maybe someday, I'll write one more book, and then, a few more.
  prefs: []
  type: TYPE_NORMAL
- en: Working with graphs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some tasks require representing data as a graph. The `Boost.Graph` is a library
    that was designed to provide a flexible way of constructing and representing graphs
    in memory. It also contains a lot of algorithms to work with graphs, such as topological
    sort, breadth first search, depth first search, and Dijkstra shortest paths.
  prefs: []
  type: TYPE_NORMAL
- en: Well, let's perform some basic tasks with `Boost.Graph`!
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Only basic knowledge of C++ and templates are required for this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we'll describe a graph type, create a graph of that type, add
    some vertexes and edges to the graph, and search for a specific vertex. That should
    be enough to start with `Boost.Graph`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by describing the graph type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we construct it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s carry out some undocumented trick that speeds up graph construction:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we are ready to add vertexes to the graph:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'It is time to connect vertexes with edges:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We may make a function that searches for some vertex:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Next is a code that gets iterators to all vertexes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s time to run a search for the required vertex:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At *step 1*, we are describing what our graph must look like and on what types
    it must be based. The `boost::adjacency_list` is a class that represents graphs
    as two-dimensional structures, where the first dimension contains vertexes and
    the second dimension contains edges for that vertex. The `boost::adjacency_list`
    must be the default choice for representing a graph because it suits most cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first template parameter, `boost::adjacency_list`, describes the structure
    used to represent the edge list for each of the vertexes. The second one describes
    a structure to store vertexes. We may choose different standard library containers
    for those structures using specific selectors, as listed in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Selector | Standard library container |'
  prefs: []
  type: TYPE_TB
- en: '| `boost::vecS` | `std::vector` |'
  prefs: []
  type: TYPE_TB
- en: '| `boost::listS` | `std::list` |'
  prefs: []
  type: TYPE_TB
- en: '| `boost::slistS` | `std::slist` |'
  prefs: []
  type: TYPE_TB
- en: '| `boost::setS` | `std::set` |'
  prefs: []
  type: TYPE_TB
- en: '| `boost::multisetS` | `std::multiset` |'
  prefs: []
  type: TYPE_TB
- en: '| `boost::hash_setS` | `std::hash_set` |'
  prefs: []
  type: TYPE_TB
- en: The third template parameter is used to make an indirect, directed, or bidirectional
    graph. Use the `boost::undirectedS`, `boost::directedS`, and `boost::bidirectionalS`
    selectors respectively.
  prefs: []
  type: TYPE_NORMAL
- en: The fifth template parameter describes the datatype that is used as a vertex.
    In our example we choose `std::string`. We may also support a datatype for edges
    and provide it as a template parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '*Steps 2* and *3* are simple, but in *step 4* you may see some undocumented
    way to speed up graph construction. In our example, we use `std::vector` as a
    container for storing vertexes, so we may force it to reserve memory for the required
    number of vertexes. This leads to less memory allocations/deallocations and copy
    operations during insertion of vertexes into the graph. This step is not very
    portable and may break in one of the future versions of Boost, because the step
    is highly dependent on the current implementation of `boost::adjacency_list` and
    on the chosen container type for storing vertexes.'
  prefs: []
  type: TYPE_NORMAL
- en: At *step 4*, we see how vertexes can be added to the graph. Note how `boost::graph_traits<graph_type>`
    has been used. The `boost::graph_traits` class is used to get types that are specific
    for a graph type. We'll see its usage and the description of some graph-specific
    types later in this chapter. *Step 5* shows what we need to connect vertexes with
    edges.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we had provided some datatype for the edges, adding an edge would look as
    follows: `boost::add_edge(ansic, guru, edge_t(initialization_parameters), graph)`'
  prefs: []
  type: TYPE_NORMAL
- en: In *step 6,* the graph type is a `template` parameter. This is recommended to
    achieve better code re-usability and make this function work with other graph
    types.
  prefs: []
  type: TYPE_NORMAL
- en: At *step 7*, we see how to iterate over all the vertexes of the graph. The type
    of vertex iterator is received from `boost::graph_traits`. The function `boost::tie`
    is a part of `Boost.Tuple` and is used for getting values from tuples to the variables.
    So, calling `boost::tie(it, end) = boost::vertices(g)` puts the `begin` iterator
    into the `it` variable and the `end` iterator into the `end` variable.
  prefs: []
  type: TYPE_NORMAL
- en: It may come as a surprise to you, but dereferencing a vertex iterator does not
    return vertex data. Instead, it returns the vertex descriptor `desc`, which can
    be used in `boost::get(boost::vertex_bundle, g)[desc]` to get vertex data, just
    as we have done in *step 8*. The vertex descriptor type is used in many of the
    `Boost.Graph` functions. We already saw its use in the edge construction function
    in *step 5*.
  prefs: []
  type: TYPE_NORMAL
- en: As already mentioned, the `Boost.Graph` library contains implementations of
    many algorithms. You may find many search policies implemented, but we won't discuss
    them in this book. We limit this recipe just to the basics of the graph library.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Boost.Graph` library is not a part of C++17 and it won''t be a part of
    the next C++ standard. The current implementation does not support C++11 features
    like rvalue references. If we are using vertexes that are heavy to copy, we may
    gain speed using the following trick:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: It avoids copy constructions inside `boost::add_vertex(vertex_data, graph)`
    and uses the default construction with move assignment instead.
  prefs: []
  type: TYPE_NORMAL
- en: The efficiency of `Boost.Graph` depends on multiple factors, such as the underlying
    containers types, graph representation, edge, and vertex datatypes.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Reading the *Visualizing graphs* recipe can help you work easily with graphs.
    You may also consider reading its official documentation at the following link:
    [http://boost.org/libs/graph](http://boost.org/libs/graph)'
  prefs: []
  type: TYPE_NORMAL
- en: Visualizing graphs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Making programs that manipulate graphs was never easy because of issues with
    visualization. When we work with standard library containers such as `std::map`
    and `std::vector`, we can always print the container's contents and see what is
    going on inside. But when we work with complex graphs, it is hard to visualize
    the content in a clear way; textual representation is not human friendly because
    it typically contains too many vertexes and edges.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we'll take a look at the visualization of `Boost.Graph` using
    the **Graphviz** tool.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To visualize graphs, you will need a Graphviz visualization tool. Knowledge
    of the preceding recipe is also required.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Visualization is done in two phases. In the first phase, we make our program
    output the graph's description in a text format suitable for Graphviz. In the
    second phase, we import the output from the first step to the visualization tool.
    The numbered steps in this recipe are all about the first phase.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write the `std::ostream` operator for `graph_type` as done in the preceding
    recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `detail::vertex_writer` structure, used in the preceding step, must be
    defined as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s all. Now, if we visualize the graph from the previous recipe using
    the `std::cout << graph;` command, the output can be used to create graphical
    pictures using the `dot` command-line utility:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command is depicted in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00021.gif)'
  prefs: []
  type: TYPE_IMG
- en: We may also use the **Gvedit** or **XDot** programs for visualization, if the
    command line frightens you.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Boost.Graph` library contains function to output graphs in Graphviz (DOT)
    format. If we write `boost::write_graphviz(out, g)` with two parameters in *step
    1*, the function outputs a graph picture with vertexes numbered from `0`. That's
    not very useful, so we provide an instance of the hand-written `vertex_writer`
    class that outputs vertex names.
  prefs: []
  type: TYPE_NORMAL
- en: As we can see in *step 2*, the Graphviz tool understands DOT format. If you
    wish to output more info for your graph, then you may need to read the Graphviz
    documentation for more info about the DOT format.
  prefs: []
  type: TYPE_NORMAL
- en: If you wish to add some data to the edges during visualization, we need to provide
    an instance of the edge visualizer as a fourth parameter to `boost::write_graphviz`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C++17 does not contain `Boost.Graph` or the tools for graph visualization. But
    you do not need to worry, as there are a lot of other graph formats and visualization
    tools and `Boost.Graph` can work with plenty of them.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Working with graphs* recipe contains information about the construction
    of `Boost.Graphs`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You will find a lot of information about the DOT format and Graphviz at [http://www.graphviz.org/](http://www.graphviz.org/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Boost's official documentation of the `Boost.Graph` library contains multiple
    examples and useful information, and can be found at [http://boost.org/libs/graph](http://boost.org/libs/graph)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a true random number generator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I know of many examples of commercial products that use incorrect methods for
    getting random numbers. It's a shame that some companies still use `rand()` in
    cryptography and banking software.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how to get a fully random **uniform distribution** using `Boost.Random`
    that is suitable for banking software.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Basic knowledge of C++ is required for this recipe. Knowledge about different
    types of distributions will also be helpful. The code in this recipe requires
    linking against the `boost_random` library.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create a true random number, we need some help from the operating system
    or processor. This is how it can be done using Boost:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to include the following headers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Advanced random bits providers have different names under different platforms:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we are ready to initialize the generator with `Boost.Random`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s get a uniform distribution that returns a value between `1000` and `65535`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: That's it. Now, we may get true random numbers using the `random(device)` call.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Why does the `rand()` function not suit banking? Because it generates pseudo-random
    numbers, which means that the hacker may predict the next generated number. This
    is an issue with all pseudo-random number algorithms. Some algorithms are easier
    to predict and some harder, but it's still possible.
  prefs: []
  type: TYPE_NORMAL
- en: That's why, we are using `boost::random_device` in this example (see *step 3*).
    That device gathers **entropy**--information about random events from all around
    the operating system to produce unpredictable uniform random bits. The examples
    of such events are delays between pressed keys, delays between some of the hardware
    interruptions, and the internal CPU's random bits generators.
  prefs: []
  type: TYPE_NORMAL
- en: Operating systems may have more than one such type of random bit generator.
    In our example for POSIX systems, we used `/dev/urandom` instead of the more secure
    `/dev/random` because the latter remains in a blocked state until enough random
    events have been captured by the OS. Waiting for entropy may take seconds, which
    is usually unsuitable for applications. Use `/dev/random` for the long-lifetime
    **GPG**/**SSL**/**SSH** keys.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we are done with generators, it's time to move to *step 4* and talk
    about distribution classes. If the generator just generates uniform distributed
    bits, the distribution class makes a random number from those bits. In *step 4*,
    we made a uniform distribution that returns a random number of `unsigned short`
    type. The parameter `1000` means that distribution must return numbers greater
    or equal to `1000`. We can also provide the maximum number as a second parameter,
    which is by default equal to the maximum value storable in the return type.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Boost.Random` has a huge number of true/pseudo random bit generators and
    distributions for different needs. Avoid copying distributions and generators.
    This may turn out to be an expensive operation.
  prefs: []
  type: TYPE_NORMAL
- en: C++11 has support for different distribution classes and generators. You may
    find all the classes from this example in the `<random>` header in the `std::`
    namespace. The `Boost.Random` libraries do not use C++11 features, and they are
    not really required for that library either. Should you use Boost implementation
    or standard library? Boost provides better portability across systems. However,
    some standard libraries may have assembly-optimized implementations and may provide
    some useful extensions.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The official documentation contains a full list of generators and distributions
    with descriptions. It is available at the following link: [http://boost.org/libs/random.](http://boost.org/libs/random)'
  prefs: []
  type: TYPE_NORMAL
- en: Using portable math functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some projects require specific trigonometric functions, a library for numerically
    solving ordinary differential equations and working with distributions and constants.
    All those parts of `Boost.Math` will be hard to fit even in a separate book. A
    single recipe definitely won't be enough. So, let's focus on very basic everyday-use
    functions to work with float types.
  prefs: []
  type: TYPE_NORMAL
- en: We'll write a portable function that checks input value for infinity and **Not**-**a**-**Number**
    (**NaN**) values and changes the sign if the value is negative.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Basic knowledge of C++ is required for this recipe. Those who know C99 standard
    will find a lot common in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Perform the following steps to check the input value for infinity and NaN values
    and change the sign if the value is negative:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We need the following headers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Asserting for infinity and NaN can be done like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the following code to change the sign:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: That's it! Now, we may check that `check_float_inputs(std::sqrt(-1.0))` and
    `check_float_inputs(std::numeric_limits<double>::max() * 2.0)` will trigger asserts.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Real types have specific values that cannot be checked using equality operators.
    For example, if the variable `v` contains NaN, `assert(v != v)` may or may not
    pass depending on the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: For such cases, `Boost.Math` provides functions that may reliably check for
    infinity and NaN values.
  prefs: []
  type: TYPE_NORMAL
- en: '*Step 3* contains the `boost::math::signbit` function, which requires clarification.
    This function returns a signed bit, which is `1` when the number is negative and
    `0` when the number is positive. In other words, it returns `true` if the value
    is negative.'
  prefs: []
  type: TYPE_NORMAL
- en: Looking at *step 3,* some readers may ask, why can't we just multiply by `-1`
    instead of calling `boost::math::changesign`? We can. But, multiplication may
    work slower than `boost::math::changesign` and is not guaranteed at work for special
    values. For example, if your code can work with `nan`, the code in *step 3* is
    able to change the sign of `-nan` and write `nan` to the variable.
  prefs: []
  type: TYPE_NORMAL
- en: The `Boost.Math` library maintainers recommend wrapping math functions from
    this example in round parentheses to avoid collisions with C macro. It is better
    to write `(boost::math::isinf)(value)` instead of `boost::math::isinf(value)`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C99 contains all the functions described in this recipe. Why do we need them
    in Boost? Well, some compiler vendors think that programmers do not need the full
    support of C99, so you won't find those functions in at least one very popular
    compiler. Another reason is that the `Boost.Math` functions may be used for classes
    that behave like numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '`Boost.Math` is a very fast, portable, and reliable library. **Mathematical
    special functions** are part of the `Boost.Math` library and some mathematical
    special functions were accepted into C++17\. A `Boost.Math`, however, provides
    more of them and has highly usable recurrent versions that have better complexities
    and better suit some of the tasks (like numerical integrations).'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Boost's official documentation contains lots of interesting examples and tutorials
    that will help you get used to `Boost.Math`. Browse to [http://boost.org/libs/math](http://boost.org/libs/math)
    to read about it.
  prefs: []
  type: TYPE_NORMAL
- en: Writing test cases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This recipe and the next one are devoted to auto-testing using the `Boost.Test`
    library, which is used by many Boost libraries. Let''s get hands-on with it and
    write some tests for our own class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Basic knowledge of C++ is required for this recipe. To compile code of this
    recipe, define `BOOST_TEST_DYN_LINK` macro and link against the `boost_unit_test_framework`
    and `boost_system` libraries.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To be honest, there is more than one test library in Boost. We'll take a look
    at the most functional one.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use it, we need to define the macro and include the following header:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Each set of tests must be written in the test case:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Checking some function for the `true` result must be done as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Checking for nonequality must be implemented in the following way:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Checking for an exception being thrown must look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: That's it! After compilation and linking, we'll have a binary that automatically
    tests `foo` and outputs test results in a human-readable format.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Writing unit tests is easy. You know how the function works and what result
    it will produce in specific situations. Therefore, you just check if the expected
    result is the same as the function's actual output. That's what we did in *step
    3*. We know that `f1.is_not_null()` returns `true` and we checked it. At *step
    4*, we do know that `f1` is not equal to `f2`, so we checked it too. The call
    to `f1.throws()` produces the `std::logic_error` exception and we check that an
    exception of the expected type is thrown.
  prefs: []
  type: TYPE_NORMAL
- en: 'At *step 2*, we are making a test case--a set of checks to validate correct
    behavior of the `foo` structure. We may have multiple test cases in a single source
    file. For example, if we add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This code will run along with the `test_no_1` test case.
  prefs: []
  type: TYPE_NORMAL
- en: The parameter passed to the `BOOST_AUTO_TEST_CASE` macro is just a unique name
    of the test case that is shown in case of error.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: There is a small difference between the `BOOST_REQUIRE_*` and `BOOST_CHECK_*`
    macros. If the `BOOST_REQUIRE_*` macro check fails, the execution of the current
    test case stops and `Boost.Test` runs the next test case. However, failing `BOOST_CHECK_*`
    does not stop the execution of the current test case.
  prefs: []
  type: TYPE_NORMAL
- en: '*Step 1* requires additional care. Note the `BOOST_TEST_MODULE` macro definition.
    This macro must be defined before including the `Boost.Test` headers; otherwise,
    linking the program will fail. More information can be found in the *See also*
    section of this recipe.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Some readers may wonder, why did we write `BOOST_CHECK_NE(f1, f2)` in *step
    4* instead of `BOOST_CHECK(f1 != f2)`? The answer is simple: the macro at *step
    4* provides a more readable and verbose output on older versions of `Boost.Test`
    library.'
  prefs: []
  type: TYPE_NORMAL
- en: C++17 lacks support for unit testing. However, the `Boost.Test` library can
    be used to test C++17 and pre-C++11 code.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that the more tests you have, the more reliable code you get!
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Combining multiple test cases in one test module* recipe contains more
    information about testing and the `BOOST_TEST_MODULE` macro.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refer to Boost's official documentation at [http://boost.org/libs/test](http://boost.org/libs/test)
    for a full list of test macros and information about advanced features of `Boost.Test`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combining multiple test cases in one test module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Writing auto tests is good for your project. However, managing test cases is
    hard when the project is big and many developers work on it. In this recipe, we'll
    take a look at how to run individual tests and how to combine multiple test cases
    in a single module.
  prefs: []
  type: TYPE_NORMAL
- en: Let's pretend that two developers are testing the `foo` structure declared in
    the `foo.hpp` header and we wish to give them separate source files to write tests
    to. In that case, both developers won't bother each other and may work in parallel.
    However, the default test run must execute tests of both developers.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Basic knowledge of C++ is required for this recipe. This recipe partially reuses
    code from the previous recipe and it also requires the `BOOST_TEST_DYN_LINK` macro
    defined and linkage against the `boost_unit_test_framework` and `boost_system`
    libraries.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe uses the code from the previous one. This is a very useful recipe
    for testing big projects. Do not underestimate it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of all the headers in `main.cpp` from the previous recipe, leave only these
    two lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s move the test cases from the previous example into two different source
    files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: That's it! Thus compiling and linking all the sources and both test cases will
    work on program execution.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the magic is done by the `BOOST_TEST_MODULE` macro. If it is defined before
    `<boost/test/unit_test.hpp>`, `Boost.Test` thinks that this source file is the
    main one and all the helper testing infrastructure must be placed in it. Otherwise,
    only the test macro is be included from `<boost/test/unit_test.hpp>`.
  prefs: []
  type: TYPE_NORMAL
- en: All the `BOOST_AUTO_TEST_CASE` tests will run if you link them with the source
    file that contains the `BOOST_TEST_MODULE` macro. When working on a big project,
    each developer may enable compilation and linking only of their own sources. That
    gives independence from other developers and increases the speed of development
    - no need to compile alien sources and run alien tests while debugging.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Boost.Test` library is good because of its ability to run tests selectively.
    We may choose what tests to run and pass them as command-line arguments. For example,
    the following command runs only the `test_no_1` test case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The following command runs two test cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Unfortunately, C++17 standard does not have built-in testing support and it
    looks like C++20 also won't adopt the classes and methods of `Boost.Test`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Writing test cases* recipe contains more information about the `Boost.Test`
    library. Read Boost's official documentation at [http://boost.org/libs/test](http://boost.org/libs/test)
    for more information about `Boost.Test`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Brave ones may try to take a look at some of the test cases from the Boost library.
    Those test cases are allocated in the `libs` sub-folder located in the `boost`
    folder. For example, `Boost.LexicalCast` tests cases are allocated at `boost_1_XX_0/libs/lexical_cast/test`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manipulating images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I've left you something really tasty for dessert - Boost's Generic Image Library
    or just `Boost.GIL`, which allows you to manipulate images without worrying too
    much about image formats.
  prefs: []
  type: TYPE_NORMAL
- en: Let's do something simple and interesting with it. For example, let's make a
    program that negates any picture.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe requires basic knowledge of C++, templates, and `Boost.Variant`.
    The example requires linking against the `png` library.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For simplicity of the example, we'll be working only with PNG images.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by including the header files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to define the image types that we wish to work with:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Opening an existing PNG image can be implemented like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to apply the operation to the picture as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code line will help you to write an image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a look at the modifying operation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The body of `operator()` consists of getting a channel type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'It also iterates through pixels:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s see the results of our program:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00022.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'The previous picture is the negative of the one that follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00023.gif)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At *step 2*, we are describing the types of images we wish to work with. These
    images are gray images with 8 and 16 bits per pixel and RGB pictures with 8 bits
    per pixel.
  prefs: []
  type: TYPE_NORMAL
- en: The `boost::gil::any_image<img_types>` class is a kind of `Boost.Variant` that
    may hold an image of one of the `img_types` variables. As you may have already
    guessed, `boost::gil::png_read_image` reads images into image variables.
  prefs: []
  type: TYPE_NORMAL
- en: The `boost::gil::apply_operation` function at *step 4* is almost equal to `boost::apply_visitor`
    from the `Boost.Variant` library. Note the usage of `view(source)`. The `boost::gil::view`
    function constructs a light wrapper around the image that interprets it as a two-dimensional
    array of pixels.
  prefs: []
  type: TYPE_NORMAL
- en: Do you remember that for `Boost.Variant` we were deriving visitors from `boost::static_visitor`?
    When we are using GIL's version of variant, we need to make a `result_type` typedef
    inside `visitor`. You can see it in *step 6*.
  prefs: []
  type: TYPE_NORMAL
- en: 'A little bit of theory: images consist of points called **pixels**. One image
    has pixels of the same type. However, pixels of different images may differ in
    channels count and color bits for a single channel. A channel represents a primary
    color. In the case of an RGB image, we have a pixel consisting of three channels
    - red, green, and blue. In the case of a gray image, we have a single channel
    representing gray.'
  prefs: []
  type: TYPE_NORMAL
- en: Back to our image. At *step 2*, we described the types of images we wish to
    work with. At *step 3*, one of those image types is read from file and stored
    in the source variable. At *step 4*, the `operator()` method of the `negate` visitor
    is instantiated for all image types.
  prefs: []
  type: TYPE_NORMAL
- en: At *step 7*, we can see how to get the channel type from the image view.
  prefs: []
  type: TYPE_NORMAL
- en: At *step 8*, we iterate through pixels and channels and negate them. Negation
    is done via `max_val - source(x, y)[c]` and the result is written back to the
    image view.
  prefs: []
  type: TYPE_NORMAL
- en: We write an image back at *step 5*.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C++17 has no built-in methods to work with images. There is ongoing work to
    add 2D drawing to the C++ standard library, though it's a kind of orthogonal functionality.
  prefs: []
  type: TYPE_NORMAL
- en: The `Boost.GIL` library is fast and efficient. The compilers optimize its code
    well and we may even help the optimizer using some of the `Boost.GIL` methods
    to unroll loops. But this chapter talks about only some of the library basics,
    so it is time to stop.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: More information about `Boost.GIL` can be found at Boost's official documentation
    at [http://boost.org/libs/gil](http://boost.org/libs/gil)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See the *Storing multiple chosen types in a variable/container* recipe in [Chapter
    1](part0029.html#RL0A0-712b4ba1126a4c7c89e1d44de61b4bdd), *Starting to Write Your
    Application*, for more information about the `Boost.Variant` library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See the [https://isocpp.org/](https://isocpp.org/) for more news on C++
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Take a look at [https://stdcpp.ru/](https://stdcpp.ru/) for discussion of C++
    proposals on Russian
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
