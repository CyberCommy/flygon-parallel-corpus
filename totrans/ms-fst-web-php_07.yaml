- en: JavaScript and Danger-Driven Development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*"In JavaScript, there is a beautiful, elegant, highly expressive language
    that is buried under a steaming pile of good intentions and blunders."'
  prefs: []
  type: TYPE_NORMAL
- en: '–  Douglas Crockford, JavaScript: The Good Parts*'
  prefs: []
  type: TYPE_NORMAL
- en: This quotation expresses essentially what optimizing JavaScript code is all
    about.
  prefs: []
  type: TYPE_NORMAL
- en: Often fascinated by the latest shiny feature or by the need to deliberately
    or pretentiously display his own abilities, the developer's mind sometimes slips
    into a mysterious state of awaken sleep by which he is overcome by the need to
    show off overly complex code or by the desire to use the most recent features
    even though he knows, deep down, that this means that he will have to sacrifice
    long-term stability and the efficiency of his computer program. This way of building
    applications is what we might call "Danger-Driven Development". JavaScript has
    many very bad parts but has enough good parts to outweigh the bad ones. This being
    said, the problem with Danger-Driven Development is the fact that the developer
    listens to the sirens of JavaScript's awful parts at the expense of the end user’s
    satisfaction.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will cover a few of JavaScript’s best and worst parts, especially
    those that pertain to code efficiency and overall performance, and how a developer
    should always write safe, reliable and highly efficient JavaScript code even if
    doing so is not as enchanting as coding the latest shiny.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, we will cover the following points:'
  prefs: []
  type: TYPE_NORMAL
- en: The global object and local variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoiding bad idioms and keeping an eye on the very bad parts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the DOM efficiently
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Structuring and loading a JavaScript application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The global object and local variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'JavaScript’s global object is the container of all global variables. Any top-level
    variable of any compilation unit will be stored in the global object. The global
    object is one of the worst parts of JavaScript when it is not used correctly,
    as it can easily become bloated with unneeded variables and can be unknowingly
    abused by developers when JavaScript default behavior is heavily relied upon.
    Here are two examples of such misuse:'
  prefs: []
  type: TYPE_NORMAL
- en: When running a simple code such as `total = add(3, 4);`, you are, in fact, creating
    a property named `total` in the global object. This is not a good thing for performance
    as you might keep a lot of variables on the heap while most of them are only required
    at a certain moment of an application's execution.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When neglecting to use the `new` keyword in order to create an object, JavaScript
    will execute an ordinary function call and will bind the `this` variable to the
    global object. This is a very bad thing, not only for security reasons, as it
    is possible to clobber other variables, but also for performance reasons as the
    developer might think that he is storing values in an object's properties while
    he is, in fact, storing these values in the global object directly, thus bloating
    the global object and storing these values in two different memory spaces if he
    already instantiated the desired object elsewhere in his code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To use the global object efficiently, you should wrap all your variables in
    a single application object, apply functions to it as needed, enforce type verification
    within the functions that you are applying to the application object in order
    to make sure that it is instantiated correctly and access the global object by
    thinking of it as a sort of immutable object with a few side-effect functions
    that are the application objects.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding global variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Global variables can be accessed for reading or writing in any scope of an application.
    They are a necessary evil. Indeed, any application needs to organize its code
    structure in order to process input values and return the appropriate response
    or output. Problems and bugs start occurring when the code is not well organized
    and when any part of the code can therefore modify the global state of the rest
    of the application and modify the program's overall expected behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, poorly organized code means that the scripting engine, or interpreter,
    has more work to do when trying to look up a variable name, because it will have
    to go through many scopes until it finds it in the global scope.
  prefs: []
  type: TYPE_NORMAL
- en: Secondly, poorly organized code means that the heap in memory will always be
    larger than needed to run the same functionality, since many superfluous variables
    will remain in memory until the end of the script's execution.
  prefs: []
  type: TYPE_NORMAL
- en: The solution to this problem is to avoid using global variables as much as possible
    and to use namespaced variables almost all the time. Also, using locally scoped
    variables has the added advantage of making sure that variables are automatically
    unset when the local scope is lost.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example (`chap7_js_variables_1.html`) shows us how the use of
    global variables can be very problematic and ultimately very inefficient, especially
    in increasing complex applications:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The easy solution is to organize the code by using modules and namespaces.
    This is easily achieved by wrapping all variables and functions within a single
    application object in order to force a certain associated behavior when the variables
    are set or modified, and to preserve the application’s secrets from the global
    object. Closures can also be used to hide important values from the global scope.
    Let’s modify our previous script, keeping namespaces in mind this time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: By using the `let` keyword in this way, the developer would still obtain the
    correct value while avoiding to clobber a global variable and unintentionally
    modifying the global state of the entire application, even if he was to forget
    to use the `new` keyword. Furthermore, the global object remains lean and efficient
    by avoiding unnecessary bloat and by reducing time spent in namespace lookups
    in order to find a called function or a stored value.
  prefs: []
  type: TYPE_NORMAL
- en: Evaluating local variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have seen in the previous example, omitting the `let` or `var` keyword
    in front of the declaration of a local variable makes it global. In all cases,
    functions and objects should not be able to create functional side effects by
    modifying the value of variables outside of their local scope. Thus, the `let`
    keyword should always be used when declaring variables inside the scope of a function
    or structure. For example, simply moving global variables to the local scope of
    a function that is using them within a local loop translates into almost a 30%
    increase in performance in most browsers.
  prefs: []
  type: TYPE_NORMAL
- en: Also, when declaring variables with the `let` keyword, you get to use block
    scope, which should be used as much as possible. Thus, a variable used within
    a `for` loop will not stay within scope once the loop is done. This allows for
    better variable encapsulation and isolation, more efficient garbage collection
    and better performance in general.
  prefs: []
  type: TYPE_NORMAL
- en: One way to easily keep track of variable declarations is to use JavaScript’s
    strict mode. We will explain this ES5 feature in more detail in the next section
    of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding bad idioms and keeping an eye on the very bad parts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As with most C-based programming languages, it is best to avoid certain bad
    idioms that often cause code inefficiency and bugs.
  prefs: []
  type: TYPE_NORMAL
- en: Bad idioms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are a few bad idioms that should be identified as problematic:'
  prefs: []
  type: TYPE_NORMAL
- en: Declaring a variable at first use is a bad idea in JavaScript due to the fact
    that the developer will most likely give the variable global scope in order to
    access it later. It is better to organize the code from the start of the project
    and use intuitive and meaningful namespaces in order to organize the use of variables
    throughout the application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using structures in a way that is not explicit or that was not originally intended
    should be avoided in all cases. For example, letting a `switch` statement fall
    through or assigning a value to a variable within the condition of a conditional
    statement are very bad idioms and should never be used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Relying on automatic semicolon insertion is a bad idea and can lead to code
    misinterpretation. It should always be avoided.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Trailing commas in arrays and objects is a bad idea since some browsers will
    not interpret them correctly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When using a `block` statement with one single imperative line, omitting the
    curly braces should be avoided at all times.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of course, the art of structuring code adequately relies foremost upon a good
    knowledge of the structures themselves. There are bad constructs in JavaScript
    that should be avoided at all times. Let’s take the time to look at a few.
  prefs: []
  type: TYPE_NORMAL
- en: Bad constructs – the with statement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One example of these bad constructs is the `with` statement. The original intention
    of the `with` statement was to help developers access object properties without
    having to type the whole namespace every time. It was intended to be a sort of
    `use` statement as we might encounter them in other languages like PHP. For example,
    you could use the `with` statement in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The problem here is that, when we are looking at this code, we are not entirely
    sure that the engine is not clobbering global variables named `myVar` and `otherVar`.
    The best way to deal with long namespaces is to assign them to local variables
    and use them afterwards:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Bad constructs – the eval statement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another bad one is the `eval()` statement. This statement is not only very
    inefficient, but it is, most of the time, useless. Indeed, it is often believed
    that using the `eval()` statement is the proper way to deal with a provided string.
    But this is not the case. You can simply use an array syntax to do the same thing.
    For example, we could use the `eval()` statement in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'To get a substantial speed increase (from 80% to 95% faster), you could replace
    the previous code with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Bad constructs – the try-catch-finally construct
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is important to note that one should avoid using the try-catch-finally construct
    inside performance-critical functions. The reason is related to the fact that
    this construct must create a runtime variable to catch the exception object. This
    runtime creation is a special case in JavaScript and not all browsers handle it
    with the same degree of efficiency, which means that this operation can cause
    trouble along the application's critical path, especially when performance is
    crucial. You can easily replace this construct with simple testing conditions
    and insert error messages in an object that would act as error registry for the
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding inefficient loops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nesting loops is the first thing to avoid when coding these types of structures
    in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Also, most of the time, using `for-in` loops is not a good idea since the engine
    has to create a complete list of the enumerable properties, which is not very
    efficient. Most times, a `for` loop will do the job perfectly. This is particularly
    true of performance-critical functions that are found along the critical path
    of the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Furthermore, beware of implicit object conversions when dealing with loops.
    Often, at first glance, it is difficult to see what is happening under the hood
    when repeatedly accessing a `length` property on an object for example. But there
    are cases where JavaScript will create an object on each iteration of a loop when
    the object is not specifically created beforehand. Please see the following code
    example (`chap7_js_loops_1.html`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'When having a look at the console results in Google Chrome''s Developer tools,
    we get the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/112011fe-7e2a-40e0-bd67-405ae2bd7eb2.png)Seven string objects were
    created in all, one on each iteration of the ''for'' loop'
  prefs: []
  type: TYPE_NORMAL
- en: 'Under the hood, the JavaScript engine is actually creating a string object
    on each iteration of the loop. In order to avoid this problem, we will explicitly
    instantiate a string object before entering the loop (`chap7_js_loops_2.html`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The results of the new script are as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/864545b7-6a45-4ee7-82b7-7119adb29950.png)Only one object is created
    and is shown seven times'
  prefs: []
  type: TYPE_NORMAL
- en: The console's log is now showing us the same object seven times. It is easy
    to understand how this could optimize the performance of a loop, especially when
    the loop could cause the engine to create tens, hundreds or even thousands of
    objects in order to complete its work.
  prefs: []
  type: TYPE_NORMAL
- en: Linters and strict mode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are some other bad parts in JavaScript that could cause performance issues
    on some occasions. In order to keep an eye on all of these bad parts and replace
    them with JavaScript’s good parts, it is highly recommended that you use a tool
    that will allow you to find issues with a piece of code even before you run it
    for the first time. These tools are linters.
  prefs: []
  type: TYPE_NORMAL
- en: '*JSLint*, *ESLint*, and *Prettier* are tools that can help you find sloppy
    code and fix it, even automatically in some cases. Some linters, such as *ESLint*,
    might even help you improve your code by reducing the number of statements, reducing
    the nesting of structures by replacing them with functions and Promises, identifying
    cyclomatic complexity—which is measuring the number of branches a single piece
    of structural code has—and maybe allowing you to replace those structural pieces
    of code with more functional ones, as we will see in the next chapter. You can
    find these tools at the following addresses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.jslint.com/](http://www.jslint.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://eslint.org/](https://eslint.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/prettier/prettier](https://github.com/prettier/prettier)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An added benefit of using linters is the fact that they make JavaScript code
    compatible with ES5's strict mode. Whenever possible, strict mode should be used.
    It is as easy as adding a `use strict;` statement at the beginning of a script
    or a function in order to use it. Amongst the many benefits of using strict mode
    is a simplified mapping of variable names to variable definitions (optimized namespace
    lookups), prohibition of the `with` statement, prevention of unexpected introduction
    of variables into the current scope through the use of `eval` statements, protection
    against "boxing" (forced instantiation) of the `this` variable when it is not
    containing an object and it is passed to a function, which reduces performance
    cost considerably, and the removal of most performance preclusions, such as accessing
    the function caller’s variables and "walking" the JavaScript stack at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Many excellent books and videos on JavaScript performance have been published
    by Packt Publishing and I highly recommend that you read them in order to master
    all these fine tools.
  prefs: []
  type: TYPE_NORMAL
- en: Using the DOM efficiently
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Document Object Model** (**DOM**) manipulations remain amongst the costliest
    operations to do in JavaScript. Indeed, repaints or reflows should be kept to
    a bare minimum in order to avoid performance issues in general.'
  prefs: []
  type: TYPE_NORMAL
- en: This being said though, there are other pitfalls that must be avoided in order
    to maintain the speed of a script when DOM operations are required and lead to
    repaints or reflows. These pitfalls concern how to modify the document tree, how
    to update an invisible element, how to make style changes, how to search for nodes,
    how to manage references from one document to another and what to do when inspecting
    a large number of nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying the document tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is important to know that making modifications while traversing the tree
    is very expensive. It is best to create a temporary collection to work on rather
    than modifying the tree directly while looping over all of its nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Indeed, the best approach is to use a non-displayed DOM tree fragment, to make
    all the changes at once and then, to display them all together. Here is a theoretical
    example of how this can be accomplished:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'It is also possible to clone an element in order to modify it completely before
    triggering a reflow of the page. The following code shows how this can be done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: By using these techniques, a developer would avoid some of the costliest operations
    in JavaScript in terms of performance.
  prefs: []
  type: TYPE_NORMAL
- en: Updating an invisible element
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another technique is to set an element''s display style to `none`. Thus, it
    will not need a repaint when its content is being changed. Here is a code example
    that shows how this can be done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This is an easy and quick way to modify a node while avoiding multiple repaints
    or reflows.
  prefs: []
  type: TYPE_NORMAL
- en: Making style changes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the same way as when we mentioned how to modify many nodes at once when
    traversing the DOM tree, it is possible to make many style changes simultaneously
    on a document fragment in order to minimize the number of repaints or reflows.
    Take the following code snippet as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, any number of style attributes could be modified in this way
    in order to trigger only one repaint or reflow.
  prefs: []
  type: TYPE_NORMAL
- en: Searching for nodes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When searching for nodes through the entire DOM, it best to use XPath to do
    so. Often, a `for` loop is used, as per the following example where `h2`, `h3`
    and `h4` elements are being searched for:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of using this `for` loop, an XPath iterator object could be used to
    obtain the same result, only much more efficiently:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Using XPath with a DOM containing more than a thousand nodes will definitely
    make a difference performance-wise.
  prefs: []
  type: TYPE_NORMAL
- en: Inspecting a large number of nodes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another pitfall to avoid is trying to inspect a large number of nodes at once.
    It is much better to narrow down the search to a specific subset of nodes and
    then use built-in methods to find the desired nodes. For example, if we know that
    the node we are looking for can be found inside a specific `div` element, then
    we could use the following code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Thus, this search will be much more efficient and return results much faster
    than if we had searched for it within a large number of nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Managing references from one document to another
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When managing references to many documents within JavaScript, it is important
    to destroy these references when a document is no longer needed. For example,
    if a document was in a pop-up window, in a frame, in an inline frame or in an
    object, and the document was dismissed by the user, the document's nodes will
    remain in memory and will continue to bloat the DOM. Destroying these unused references
    can improve performance considerably.
  prefs: []
  type: TYPE_NORMAL
- en: Caching DOM values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When accessing an object repeatedly, it is much more efficient to store it
    in a local variable in order to use it over and over again. For example, the following
    code makes a local copy of the grouped DOM values instead of accessing each value
    separately:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Doing so will allow you to avoid the performance overhead associated with dynamic
    lookups.
  prefs: []
  type: TYPE_NORMAL
- en: Structuring and loading a JavaScript application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When thinking of how to structure and load a JavaScript application, it is important
    to remember certain important principles.
  prefs: []
  type: TYPE_NORMAL
- en: Minimizing costly operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The costliest operations to do in JavaScript are:'
  prefs: []
  type: TYPE_NORMAL
- en: Requesting a resource through network I/O
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Display repainting, also known as redrawing, of the web page due to dynamic
    content changes such as making an element visible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reflowing, which can be caused by a window resize
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A DOM manipulation or dynamic change to the page’s styling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Obviously, the bottom line is that all these operations should be kept to a
    bare minimum in order to preserve good performance in general. When working on
    a script that is executing too slowly, these are the most important elements to
    look for with Google Chrome's Timeline tool, which can be accessed through Chrome’s
    Developer tools, as mentioned in [Chapter 1](1e519ed0-2065-4d04-b589-e7af72645baa.xhtml), *Faster
    Web – Getting Started*, of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Cleaning up, minifying, and compressing resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Of course, excluding unused exports from bundles, also known as tree shaking,
    minifying scripts by cleaning up dead code and then, compressing script files,
    is always a good thing when it comes to JavaScript performance, especially when
    dealing with network latency. Amongst the very good tools that will help you do
    this is *Webpack* ([https://webpack.js.org/](https://webpack.js.org/)), combined
    with the *UglifyJS* plugin ([https://github.com/webpack-contrib/uglifyjs-webpack-plugin](https://github.com/webpack-contrib/uglifyjs-webpack-plugin))
    and its compression plugin ([https://github.com/webpack-contrib/compression-webpack-plugin](https://github.com/webpack-contrib/compression-webpack-plugin)),
    which will tree-shake your code, minify your script by removing any unused or
    dead code, and compress the resulting files.
  prefs: []
  type: TYPE_NORMAL
- en: 'The advantages of tree-shaking will be felt mostly when using tree shaking
    third-party dependencies. In order to better understand how to use these tools,
    it is highly recommended that you have a look at the following tutorials:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://2ality.com/2015/12/webpack-tree-shaking.html](http://2ality.com/2015/12/webpack-tree-shaking.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://medium.com/@roman01la/dead-code-elimination-and-tree-shaking-in-javascript-build-systems-fb8512c86edf](https://medium.com/@roman01la/dead-code-elimination-and-tree-shaking-in-javascript-build-systems-fb8512c86edf)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Another great tool to optimize JavaScript code (tree-shake, minify, and compress) is
    Google’s *Closure*, even though it is built with Java. You will find this tool
    at the following address: [https://developers.google.com/closure/](https://developers.google.com/closure/).'
  prefs: []
  type: TYPE_NORMAL
- en: Loading page resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is important to avoid blocking a page's rendering when loading the script
    files in the head section of the HTML document. Scripts should always be loaded
    at the end of the body section in order to make sure that rendering will not depend
    on network latency that might occur when fetching the required JavaScript files.
  prefs: []
  type: TYPE_NORMAL
- en: Also, it is important to know that it is best to place inline scripts before
    CSS stylesheets, as CSS will often prevent the scripts from running until they
    have finished downloading.
  prefs: []
  type: TYPE_NORMAL
- en: Also, splitting the script file payloads and downloading scripts asynchronously
    are all techniques that must be thought out when structuring a JavaScript application
    for performance.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, *Steve Souders* has written many great books and articles on boosting
    web page performance and you should read them to get more information on these
    very important techniques and principles ([https://stevesouders.com/](https://stevesouders.com/)).
  prefs: []
  type: TYPE_NORMAL
- en: Caching page resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another important thing to remember, as we will see in more detail in [Chapter
    9](0d522625-eba8-4884-a12e-42689458aa85.xhtml), *Boosting a Web Server's Performance*,
    is that caching techniques, both on the server side and on the client side, will
    help you significantly boost the performance of your web pages. Leveraging these
    techniques will allow you to reduce the number of requests needed to simply get
    the same JavaScript files over and over again.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have covered a few of JavaScript’s best and worst parts,
    especially the pitfalls that can cause issues performance-wise. We have seen how
    coding safe, reliable and highly-efficient JavaScript code might not be as exciting
    as using the latest shiny feature or as tempting as lazy coding, but will certainly
    help any JavaScript application be a part of the Faster Web.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will see how JavaScript is increasingly becoming a functional
    language and how this programming paradigm will be a vector for performance in
    the near future. We will take a quick look at upcoming language features that
    will help improve the performance of JavaScript applications.
  prefs: []
  type: TYPE_NORMAL
