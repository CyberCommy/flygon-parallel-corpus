- en: Improving Performance with Lazy Initialization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last chapter, we discussed thread-safe concurrent collections in C#.
    Concurrent collections help to improve the performance of parallel code without
    having a developer worry about synchronization overheads.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will discuss some more concepts that help to improve the
    performance of code, both using custom implementations as well as using built-in
    constructs. Here are the topics we are going to discuss during this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to lazy initialization concepts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to `System.Lazy<T>`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to handle exceptions with the lazy pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lazy initialization with thread-local storage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reducing the overhead with lazy initializations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get started by introducing the lazy initialization pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Readers should have a good understanding of TPL and C#. The source code for
    this chapter is available on GitHub at [https://github.com/PacktPublishing/-Hands-On-Parallel-Programming-with-C-8-and-.NET-Core-3/tree/master/Chapter07](https://github.com/PacktPublishing/-Hands-On-Parallel-Programming-with-C-8-and-.NET-Core-3/tree/master/Chapter07).
  prefs: []
  type: TYPE_NORMAL
- en: Introducing lazy initialization concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lazy loading is a commonly used design pattern in application programming wherein
    we defer the creation of an object until it is actually required in an application.
    Proper use of the lazy load pattern can significantly improve the performance
    of the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the common usages of this pattern can be seen in cache aside patterns.
    We use the cache aside pattern for objects whose creation is expensive either
    in terms of resources or memory. Instead of creating them multiple times, we create
    objects once and cache them for future use. This pattern is possible when the
    initialization of an object is moved out of the constructor to the method or properties.
    The object will only be initialized when the method or property is called for
    the first time by code. It will then be cached for subsequent calls. Take a look
    at the following code sample that initializes the underlying data member in the
    constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The problem with the preceding code is that the underlying data is initialized
    as soon as the object is created, even though the underlying object can only be
    accessed by calling the `GetOrCreate()` method. The program might not even call
    the method in some scenarios and so memory gets wasted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lazy loading can be implemented entirely using custom code, as shown in the
    following code sample:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the preceding code, we moved the initialization logic out
    from the constructor to the `GetOrCreate()` method, which checks whether the item
    is in the cache before returning it to the caller. Data is initialized if it is
    not present in the cache.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code calling the preceding method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/faf9b818-9c45-4d43-934f-72ff2a95e511.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding code, although lazy, has the potential problem of multiloading.
    This means the call to the database might run multiple times if the `GetOrCreate()`
    method is called by multiple threads at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be improved by introducing locking, as shown in the following code
    example. For the cache aside pattern, it makes sense to use another pattern, double-checked
    locking:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is self-explanatory. We can see that it is complex to create
    a lazy pattern from scratch. Fortunately, .NET Framework provides data structures
    for the lazy pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing System.Lazy<T>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: .NET Framework provides a `System.Lazy<T>` class that has all of the benefits
    of lazy initialization without the need to worry about synchronization overheads.
    Objects created using `System.Lazy<T>` are deferred until they are accessed for
    the first time. With the custom lazy code explained in previous sections, we can
    see that we moved the initialization part from the constructor to the method/property
    to support lazy initialization. With `Lazy<T>`, we don't need to modify any code.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are multiple ways to implement lazy initialization patterns in C#. These
    include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Construction logic encapsulated inside a constructor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Construction logic passed as a delegate to `Lazy<T>`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the subsequent sections, we will try to understand these scenarios in depth.
  prefs: []
  type: TYPE_NORMAL
- en: Construction logic encapsulated inside a constructor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s first try to implement the lazy initialization pattern with classes
    that encapsulate construction logic in the constructor. Let''s say we have a `Data`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the initialization happens inside the constructor. If we use
    this class normally, using the following code, the object is initialized at the
    moment the `DataWrapper` object is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/10b3be2a-9ff6-4517-b948-a390238f9752.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding code can be converted using `Lazy<T>` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, rather than creating an object directly, we wrapped it inside
    the lazy class. The constructor won''t be called until we access the `Value` property
    of the `Lazy` object, as you can see from the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c95f76e1-5465-41e6-b32b-742810896655.png)'
  prefs: []
  type: TYPE_IMG
- en: Construction logic passed as a delegate to Lazy<T>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Objects often don''t hold construction logic as they are plain data models.
    We need to fetch data the first time the lazy objects are accessed while also
    passing the logic to fetch the data. This can be made possible using another overload
    of `System.Lazy<T>`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following code, we are creating a `Lazy<Data>` object by passing the `Func<Data>`
    delegate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from the preceding code, we passed `Func<T>` to the `Lazy<T>`
    constructor. The logic gets called on the first access to the `Value` property
    of the `Lazy<T>` instance, as shown in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b0b1007b-a213-4b55-93ed-3b66ef79176e.png)'
  prefs: []
  type: TYPE_IMG
- en: In addition to having a good idea about how to construct and use lazy objects
    in .NET, we also need to understand how to handle exceptions with lazy initialization
    patterns! Let's see the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Handling exceptions with the lazy initialization pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Lazy objects are immutable by design. This means that they always return the
    same instance that they were initialized with. We have seen that we can pass initialization
    logic to `Lazy<T>` and that we can have initialization logic in the underlying
    object''s constructor. What will happen if the construction/initialization logic
    is faulty and throws an exception? The behavior of `Lazy<T>` in this scenario
    depends on the value of the `LazyThreadSafetyMode` enumeration and your choice
    of `Lazy<T>` constructor. There are many ways to handle exceptions while working
    with lazy patterns. Some of these are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: No exceptions occur during initialization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Random exception while initialization with exception caching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Not caching exceptions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the subsequent sections, we will try to understand these scenarios in depth.
  prefs: []
  type: TYPE_NORMAL
- en: No exceptions occur during initialization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The initialization logic runs once and the object is cached to be returned with
    subsequent access to the `Value` property. We have already seen this behavior
    while explaining `Lazy<T>` in a previous section.
  prefs: []
  type: TYPE_NORMAL
- en: Random exception while initialization with exception caching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this case, since the underlying object is not created, the initialization
    logic will run on every call to the `Value` property. This is helpful in scenarios
    where the construction logic depends on external factors such as an internet connection
    while calling the external service. If the internet goes down momentarily, then
    the initialization call will fail, but subsequent calls can return the data. By
    default, `Lazy<T>` will cache exceptions for all parameterized constructor implementations,
    but it will not cache exceptions for the parameter less constructor implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try to understand what happens when `Lazy<T>` initialization logic throws
    a random exception:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we create `Lazy<Data>` with the initialization logic provided by the
    `GetDataFromDatabase()` function, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we access the `Value` property of `Lazy<Data>`, which will execute the
    initialization logic and throw an exception since the value of the counter is
    `0`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we increment the counter by one and again try to access the `Value` property.
    According to the logic, this time, it should return the `Data` object, but we
    see that the code again throws an exception:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the exception is thrown a second time, even though we increased
    the counter by one. This is because the exception value was cached and returned
    the next time the `Value` property is accessed. The output is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1dd3d59a-bef7-47ac-8e3c-522c395924db.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding behavior is the same as creating `Lazy<T>` by passing `System.Threading.LazyThreadSafetyMode.None`
    as a second parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Not caching exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s change the initialization of `Lazy<Data>` in the preceding code to the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This will allow the initialization logic to be run multiple times by different
    threads until one of the threads succeeds in running the initialization without
    any errors. If any thread throws an error during the initialization process in
    a multithreaded scenario, then all instances of the underlying object created
    by the completed threads are discarded and the exception is propagated to the
    `Value` property. In the case of a single thread, an exception will return when
    the initialization logic is re-run upon subsequent access of the `Value` property.
    The exceptions are not cached.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4570a390-8e22-42d4-945b-8f097b577765.png)'
  prefs: []
  type: TYPE_IMG
- en: After seeing how to handle exceptions with the lazy initialization pattern,
    let's now learn about the usage of thread-local storage for lazy initialization.
  prefs: []
  type: TYPE_NORMAL
- en: Lazy initialization with thread-local storage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In multithreaded programming, we often want to create a variable that is local
    to a thread, which means that each thread will have its own copy of the data.
    This holds true for all local variables, but global variables are always shared
    across threads. In old versions of .NET, we used the `ThreadStatic` attribute
    to make a static variable behave as a thread-local variable. However, this is
    not foolproof and doesn''t work well with initialization. If we are initializing
    a `ThreadStatic` variable, then only the first thread gets the initialized value,
    whereas the rest of the threads get the default value of the variable, which is
    0 in the case of an integer. This can be demonstrated using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we initialized a static `counter` variable with a value
    of `1` and made it thread static so that every thread can have its own copy. For
    demonstration purposes, we created 10 tasks that print the value of the counter.
    According to the logic, all threads should print 1, but as you can see from the
    following output, only one thread prints 1, and the rest print 0:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dcd89412-e4cb-4589-b82e-fc44809811c3.png)'
  prefs: []
  type: TYPE_IMG
- en: '.NET Framework 4 provides `System.Threading.ThreadLocal<T>` as an alternative
    to `ThreadStatic` and works more like `Lazy<T>`. Using `ThreadLocal<T>`, we can
    create a thread-local variable that can be initialized by passing an initialization
    function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9dcdd5eb-679d-4f1a-a805-70f919680586.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The differences between `Lazy<T>` and `ThreadLocal<T>` are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Each thread initializes the `ThreadLocal` variable using its own private data
    whereas, in the case of `Lazy<T>`, the initialization logic only runs once.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unlike `Lazy<T>`, the `Value` property in `ThreadLocal<T>` is read/write.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the absence of any initialization logic, the default value of `T` will be
    assigned to the `ThreadLocal` variable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reducing the overhead with lazy initializations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Lazy<T>` uses a level of indirection by wrapping the underlying object. This
    can cause computational as well as memory issues. To avoid wrapping objects, we
    can use the static variant of `Lazy<T>` class, which is the `LazyInitializer`
    class.'
  prefs: []
  type: TYPE_NORMAL
- en: We can use `LazyInitializer.EnsureInitialized` to initialize a data member that
    is passed via a reference as well as an initialization function, like we did with
    `Lazy<T>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The method can be called via multiple threads, but once a value is initialized,
    it will be used as a result for all of the threads. For the sake of demonstration,
    I have added a line to the console inside the initialization logic. Though the
    loop runs 10 times, the initialization will happen only once for single-thread
    execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d3ec9d21-2259-45d7-9a8b-bfb5f6bf8355.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This is good for sequential execution. Let''s try to modify the code and run
    it via multiple threads:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6585d753-f0d7-47f2-a557-44db26b953d8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, with multiple threads, there is a race condition and all threads
    end up initializing the data. We can avoid this race condition by modifying the
    program as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from the preceding code, we have used an overload of the `EnsureInitialized`
    method and passed a Boolean variable and a `SyncLock` object as a parameter. This
    will ensure that the initialization logic can be executed only by one thread at
    a time, as demonstrated in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ca623fb2-493a-4413-b709-f6e1202bd876.png)'
  prefs: []
  type: TYPE_IMG
- en: In this section, we discussed how we can work around the overheads associated
    with `Lazy<T>` by utilizing another built-in static variant of `Lazy<T>` known
    as the `LazyInitializer` class.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed various aspects of lazy loading and the data structures
    provided by .NET Framework to make lazy loading easier to implement.
  prefs: []
  type: TYPE_NORMAL
- en: Lazy loading can significantly improve the performance of applications by reducing
    memory footprints as well as saving on computing resources by stopping duplicate
    initialization. We have a choice to either create lazy from scratch using `Lazy<T>`
    or avoid complexity by using the static `LazyInitializer` class. With optimal
    usage of thread storages and good exception handling logic, these are certainly
    great tools for developers.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will start discussing asynchronous programming approaches
    available in C#.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lazy initialization always involves creation object in the constructor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'False'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the lazy initialization pattern, object creation is deferred until it's actually
    needed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'False'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of these can be used to create lazy objects that do not cache exceptions?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`LazyThreadSafetyMode.DoNotCacheException`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`LazyThreadSafetyMode.PublicationOnly`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which attribute can be used to create a variable that's local to a thread?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`ThreadLocal`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`ThreadStatic`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Both
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
