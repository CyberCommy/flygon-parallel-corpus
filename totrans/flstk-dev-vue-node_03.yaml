- en: Introducing MongoDB
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The name MongoDB comes from the phrase huMONGOus data, meaning that it can handle
    a lot of data. MongoDB is a document-oriented database architecture. It enables
    us to develop faster and scale better. In relational database designs, we store
    data by creating tables and rows, but with MongoDB, we can model our data as JSON
    documents, which is much simpler compared to those relational databases. If we
    are agile and our requirements keep changing very often, and if we need to do
    continuous deployment, then MongoDB is our choice. Being a document-based data
    model, MongoDB is very flexible as well.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: The biggest advantage of using MongoDB is that the data is unstructured. We
    can customize our data in any format we like. In a **relational database management
    system** (**RDBMS**), we have to define exactly the number of fields a table can
    have, but with MongoDB, each document can have its own number of fields. We can
    add new data without even having to worry about changing the schema, which is
    why Mongo has a **schemaless design model** for the database.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: If our business is growing fast, we need to scale faster, we need to access
    data in a more flexible way, and if we need to make changes to our data without
    having to worry about updating our application's database schemas, then MongoDB
    is the best choice for us. Adding new columns to tables in RDBMS also creates
    some performance issues. But, since MongoDB is schemaless, adding new fields is
    done in an instant without compromising the performance of our application.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: In a relational database, the terminologies that we use are **database**, **tables**,
    and **rows**, whereas in MongoDB, we use **database**, **collections**, and **documents**,
    respectively.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a brief summary of what we will be covering in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: Introducing to MongoDB and the benefits of using MongoDB
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the MongoDB database, collections, and documents
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing to Mongoose, creating a connection with Mongoose, understanding
    Mongoose, and CRUD operations with Mongoose
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding default and custom validations with Mongoose
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why MongoDB?
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'MongoDB provides a lot of advantages, some of which are:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '**Flexible documents**: A MongoDB collection holds several documents. Each
    document under one collection can have variable field names and can have a different
    size as well, which means we don''t have to define the schema.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**No complex relationships**: The documents in MongoDB are stored as JSON documents,
    which means we no longer have to scratch our head learning about the relationships
    between various components of the application.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Easy to scale**: MongoDB is easy to scale as it minimizes the database size
    by using a partitioning method called sharding. Sharding is a database partitioning
    method that allows us to segregate a large database into smaller pieces.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MongoDB queries
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We did quickly review what Mongo queries look like in [Chapter 1](d95a8844-6413-49ed-8d4a-9607cb550211.xhtml), *Introduction
    to MEVN*. Here, we will dive deep into these queries.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we need to do is start the MongoDB server. We can do that with
    this command:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now, let's open the mongo shell by typing `mongo` in our Terminal. When we enter
    the mongo shell, to display the list of databases, we type `show dbs`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: 'If you see the database in the list, type `use {database_name}` to start using
    this database. If we haven''t created our database yet, just using `use {database_name}`
    will create a database for us. It''s as simple as that. For this exercise, let''s
    create a database called `mongo_test_queries`. So for that, we need to use:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This should output the following in the Terminal:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now, once we enter the database, the first thing that we need is a collection.
    We have a database but there are no collections. The best way to create a collection
    in MongoDB is by inserting a document. This not only initializes a collection
    but also adds the document to that collection. Simple as that. Now, let's move
    on to Mongo queries.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Creating documents
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are different queries to create a document in MongoDB, such as `insertOne()`,
    `insertMany()`, and `insert()`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: insertOne()
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `insertOne()` command adds a single document to our collection. For example:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This command takes only a single parameter, which is an object, and we can
    pass the field names and values we want for our `users` collection. When we run
    the preceding code in our Terminal inside the Mongo shell, we should get the following
    output:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/91f27147-b1ee-4f8f-9121-a09b3d2a3c84.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
- en: It returns the `_id` of the document that just got created. We have successfully
    created a collection and a document in the `users` collection.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: The `insertOne()` and `insertMany()` commands only work for Mongo version 3.2
    or higher.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: insertMany()
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This command is used for inserting multiple documents into a collection. In
    the preceding example, we saw that the `insertOne()` command takes an argument
    that is an object. The `insertMany()` command takes an array as a parameter so
    that we can pass multiple objects inside it and insert multiple documents in the
    collection. Let''s look at an example:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This snippet creates three documents in the `users` collection. When we run
    the command, the output should be:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2a0b35a8-6ce9-4aea-a11d-92c82bda78cf.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
- en: insert()
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This command inserts single as well as multiple documents into a collection.
    It does the job of both the `insertOne()` and the `insertMany()` commands. To
    insert a single document, we can use:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If the command is executed successfully, we should see the following output:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8a719b2a-0ff8-40a6-aa1a-f68d30c60f64.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
- en: 'Now, if we want to insert multiple documents, we can simply use:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The output should be as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e9a066be-5a9a-49cb-b34e-7d57f8edb430.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
- en: Retrieving documents
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Retrieving documents from collections in MongoDB is done using the `find()`
    command. There are many ways to use this command.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: Finding all documents
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To retrieve all documents from a collection, we can use:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We can also use the following:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This outputs the following:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/493ba105-c15e-4001-bec1-5c33c473e5e8.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
- en: Finding documents via filters
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can add filters to the `find()` command as well. Let''s retrieve documents
    with the name  `Mike`. For that, we can use:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'It should return a document with the following:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/48f4dda2-bd2a-4452-9a6c-6900e11ff9f5.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
- en: We can also specify multiple conditions with `AND` or `OR` queries.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: 'To find a collection with the name `Mike` and the email `mike@mongo.com`, we
    can simply use:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The comma operator means an `AND` operator. We can specify as many conditions
    as we like with comma-separated values. The preceding command should output:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5c263d37-43b8-433c-9a47-ff92862d4fe0.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
- en: 'Now, specifying conditions with `AND` or comma operators is simple. If we want
    to use the OR operator, then we should use:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here, we are saying: retrieve those documents for users whose name is Mike,
    and the email can be `josh@mongo.com` as well. The output is as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2fae1443-b58a-48ea-af6a-95deda33f5f3.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
- en: Updating documents
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Just like `insert()`, there are three methods of using the `update()` command
    in MongoDB: `updateOne()`, `updateMany()`, and `update()`.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: updateOne()
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This command updates only a single document in the collection. Here, we have
    inserted a couple of user entries with the incorrect emails. For the user with
    the name `Peter`, the email is `jack@mongo.com`. Let''s update this document using
    `updateOne()`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This command will update Peter''s email to `peter@mongo.com`. The output is:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a7c5fd07-4a23-4cad-9dcf-f086003367ba.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
- en: As the output says, the `modifiedCount` is `1` and the `matchedCount` is `1`,
    which means the document with the given condition was found and updated.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: updateMany()
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This command is used to update multiple documents in a collection. The command
    for updating documents with `updateOne()` and `updateMany()` is the same. To update
    the multiple records, we specify the condition and then set the desired values:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The only difference between `updateOne()` and `updateMany()` is that `updateOne()`
    updates only the first document that is matched whereas `updateMany()` updates
    all the documents that are matched.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: update()
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Just like insert, the `update()` command does the job for `updateOne()` and
    `updateMany()`. To remove confusion, we can just use the `update()` command instead
    of `updateOne()` and `updateMany()`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The output is as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/acd38c2b-330c-44af-bfe4-d799032d7288.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
- en: Deleting documents
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MongoDB provides multiple commands for deleting and removing documents from
    collections.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: deleteOne()
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`deleteOne()` removes only a single document from a collection:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This removes the entry of a user whose name is `John`. The output is as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4a229e2e-ac94-4654-bb52-3e0fc52b7cf8.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
- en: As you can see in the output, the `deletedCount` is `1`, which means the record
    has been deleted.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: deleteMany()
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The command for `deleteMany()` is the same as `deleteOne()`. The only difference
    is that `deleteOne()` removes only a single entry with the matched filter whereas
    `deleteMany()` removes all the documents which match the given criteria:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The output is as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f45587d2-a32a-44c1-88b3-e3a6f6b71bf6.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
- en: remove()
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `remove()` command works to remove a single entry, as well as multiple
    entries, from a collection. If we want to remove only a single document that matched
    certain criteria, then we can pass the count of entries that we wish to delete.
    For example, let''s first create an entry:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'With this, now we have two entries for `Mike`. Now, if we want to remove just
    one entry using `remove()`, we can do so with:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The output is as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9c069d94-4b75-4853-855d-d584cbb13044.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, we had two entries with the name `Mike`, but it only removed
    one. Similarly, if we want to remove all the documents, we can just use:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: All documents will be removed.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: We talked about the basic ideas on how we can query the documents in Mongo.
    To find out more details, visit [https://docs.mongodb.com/v3.2/tutorial/query-documents/](https://docs.mongodb.com/v3.2/tutorial/query-documents/).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Mongoose
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mongoose is an elegant MongoDB object modeling library for Node.js. As I mentioned
    earlier, MongoDB is a schemaless database design. While this has its own advantages,
    sometimes we need to add certain validations as well, and this means defining
    the schemas for our documents. Mongoose provides an easy way to add such validations
    and to typecast the fields in a document.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to insert data into a MongoDB document, we can use:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, if we want to add another document and we want an extra field in that
    document, we can use:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This is possible in MongoDB because no schemas are defined. These types of documents
    are also needed when building an application. MongoDB will silently accept any
    kind of document. However, there are times when we need to have documents look
    similar in order to behave in certain validations or to have a specific data type.
    In such situations, Mongoose comes to the rescue. We can also leverage these features
    with raw MongoDB as well, but writing validations in MongoDB is an extremely painful
    task. That's why Mongoose was created.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: 'Mongoose is a data modeling technique for Mongo written in Node.js. Every document
    inside a Mongoose collection requires a fixed amount of fields. We have to explicitly
    define a `Schema` and adhere to it. An example of a Mongoose schema is:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This means that the name and description fields must be a string, whereas the
    extras can take a whole JSON object in which we can store nested values as well.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: Installing Mongoose
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Like any other package, Mongoose can be installed in our project using NPM.
    Run the following command in our Terminal inside our `express_app` folder which
    we created in the previous chapter to install Mongoose inside that application:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If this is successfully installed, we should have a line added to our `package.json`
    file:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cd4d9ce0-ceaf-45cf-80ca-181b578da24d.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
- en: Connecting Mongoose to MongoDB
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once Mongoose is installed, we have to connect it to the MongoDB in order to
    start working with it. This is pretty straightforward with Mongoose; we just have
    to add a piece of code to `require` Mongoose in our `app.js` file and use the `mongoose.connect`
    method to connect it to the database. Let''s go ahead and do that. In the `app.js`
    file, add the following code:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This will import the Mongoose module into our codebase.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to connect to the MongoDB database, add the following line of code in
    our `app.js`:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This creates a connection with our Mongoose database. Now, let''s run the app
    with the following command:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'and displays a message in our Terminal if it succeeded or failed:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a9f674f8-65fb-4746-9de9-b5347303decc.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
- en: That's it! We have successfully made a connection to our MongoDB database. The
    URL here is the locally hosted database URL.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Creating records in Mongoose
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start by creating a new model in our application's `express_app`. Create
    a folder called `models` in the root of the project and name it `User.js`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: We are using a capital letter for the starting letter of the file name. Also,
    we are using the single form for `models`. Contrary to this, for `controllers`,
    we use the plural form and lowercase letters, such as `users.js`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we create the file, paste the following code into it:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The first line here just imports the Mongoose module. This Mongoose package
    provides us with several properties, one of which is to define the `Schema`. Now,
    the original `Schema` definition here is this highlighted part:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'What this does is it adds a validation to our `User` data model, where it says
    there must be two fields in total. It will not accept either one or more than
    two data fields while creating a document for a Mongoose collection. Also, it
    adds a validation layer to this `Schema` as well, which says that the two fields,
    both `name`, and `email`, should be a valid string. It won''t accept an integer,
    Boolean, or anything other than a string for both of these fields. This is how
    we define the `Schema`:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The highlighted part of this code represents the way to create a model. The
    first argument of the method is our model name, which maps to the corresponding
    plural version of the collection name. So, when we create a `User` model, this
    automatically maps to the `user` collections in our database.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to create a user, the first thing to do is to create a resource:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, finally, the part that actually creates the `user` is:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The previous code uses a Mongoose function called `save`. The save method has
    a callback function that is used for error handling. We can do whatever we want
    when we encounter an error while saving the resource to our database there:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The `res.send` method allows us to set what we want to send to the client when
    the resource is successfully saved to the database. The first element of the object
    is `success: true`, which denotes if the execution was successful or not. The
    second element is the status code or the response code. A `200` response code
    denotes successful execution. We will discuss this in further chapters as well.The
    last element is the message that is sent to the client; the users see this in
    the frontend.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: That's how we create a resource in Mongoose.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: Fetching records from Mongoose
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have successfully created a user, we have a record in the `users`
    collections in the database. There are two ways to fetch this record in our client:
    fetch all the records of users that we have or fetch a specific user.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Fetching all records
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are lots of methods that come out of the box with a Mongoose model to
    make our lives easier. Two such methods are `find()` and `findById()`. In MongoDB,
    we saw how we could retrieve a collection's records data via raw MongoDB queries.
    This is similar, the only  difference being that Mongoose has a very easy way
    to do it. I recommend you learn MongoDB first instead of Mongoose because MongoDB
    gives you an overall idea of what a database is and you will learn the fundamentals
    of the database and about its queries. Mongoose just adds a layer on top of MongoDB
    to make it look a little bit easier for faster developments.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: 'With that, let''s look into the code snippet here:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The Mongoose model `User` calls a method called `find()`. The first parameter
    is our query string, which is left empty: `{}` in the preceding query. So, if
    we want to retrieve all users who share the same name, say, Peter, then we can
    replace that empty `{}` with `{ name: ''Peter''}`.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: The second parameter denotes which fields we want to retrieve from the database.
    We can leave it blank if we want to retrieve all fields or we can just specify
    it here. For this example, we are just retrieving user names and emails.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: 'The third parameter has a callback function attached to it. This function takes
    two parameters, unlike the `create` method. The first parameter handles the error.
    If, somehow, the execution is not done successfully, it returns an error and we
    can customize it the way we want. The second parameter is the important one here;
    it returns the response when the execution is successfully done. In this case,
    the `users` parameter is an array of objects that are retrieved from the `users`
    collection. The output of this call would be:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Now we have all the records from the `users` collection.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Fetching a specific record
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is also as simple as fetching all records from a collection. We talked
    about using `find()` in the previous section. To fetch a single record, we have
    to use `findById()` or `findOne()`, or we can also use the `where` query. The
    `where` query is the same as we talked about previously when we had to pass a
    parameter to fetch records that fell under the same category.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s move ahead on using the following query:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'As you can see, the syntax for both `find()` and `findById()` are similar.
    Both take the same amount of parameters and behave the same. The only difference
    between these two is that the preceding `find()` method returned an array of records
    as a response, whereas `findById()` returns a single object. So, the response
    to the preceding query would be:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: That's it – simple!
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Updating records in Mongoose
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's move on to updating a record in a collection. There are multiple ways
    to update the collection records as well, just as in retrieving data from the
    collections. Updating a document in Mongoose is the combination of `read` and
    `create`(save) methods. To update a document, we first need to find that document
    using the read query of Mongoose, alter that document, and then save the changes.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: findById() and save()
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s look at an example as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: So, the first thing we need to do is find the user document, which we are doing
    by `findById()`. This method returns back the user with the given ID. Now that
    we have that user, we can alter whatever we like for this user. In the preceding
    case, we are changing the name and email of that person.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: 'Now the important part. The job of updating this user''s document is done by
    the `save()` method here. We have already altered the name and email of the user
    by doing:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We are changing the object that was returned via `findById()` in the first place
    directly. Now, when we use `user.save()`, this method overwrites whatever value
    it was before for this user with this new name and email.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: There are other methods we can use to update a document in Mongoose.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: findOneAndUpdate()
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This method can be used when we want to update a single entry. For example:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'As you can see, the first parameter defines the criteria describing the record
    we want to update, which, in this case, is the user whose name is Peter. The second
    parameter is the object in which we define what attributes of `user` do we want
    to update, which is defined by `{ $set: { name: "Sara" }`. This sets the `name`
    of `Peter` to `Sara`.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s make a small alteration to the preceding code:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Here, notice that I have added a second parameter to the callback function called
    `user`.  What this does is that when Mongoose is done updating that document in
    the database, it returns the object. This is very useful when we want to make
    some decisions after we update the record and want to play with the newly updated
    document.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: findByIdAndUpdate()
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is somewhat similar to `findOneAndUpdate()`. This method takes an ID as
    a parameter, unlike `findOneAndUpdate()`, where we can add our own criteria, and
    updates that document:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The only difference here is that the first parameter takes a single integer
    value, which is the ID of the document rather than an object. This method also
    returns the object that is being updated. So we can use:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Deleting records in Mongoose
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just as there are many ways to create, fetch and update records in Mongoose,
    it also provides several ways to delete records from collections as well, such
    as `remove()`, `findOneAndRemove()`, and `findByIdAndRemove()`. We can use `remove()`
    to remove one or many documents. We can also find the documents we want to remove
    first and then use the `remove()` command to remove only those documents. If we
    want to find a specific document with some criteria, we can use `findOneAndRemove()`.
    We can use `findByIdAndRemove()` when we know the ID of the document we wish to
    remove.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: remove()
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s look at a sample for using this method:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The first argument of the `remove()` method takes the criteria for filtering
    which user we want to remove. It takes an ID as a parameter. It finds the user
    with the given ID and removes the document from the collection. The second parameter
    is the callback function, which we talked about before. If something goes wrong
    with the above operation, it returns an error, which we can use to better handle
    the exceptions or the errors that occur in our application. In the case of success,
    we can define our own logic as to what to return. In the preceding case, we are
    returning `{ success: true }`.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: findOneAndRemove
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`findOneAndRemove()` behaves the same way as `remove()` does and takes the
    same amount of parameters:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We just have to define the criteria for which documents we want to delete.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can also modify the preceding code:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Here, I have highlighted the added piece of code. We can also pass on a second
    parameter to the callback function which returns the `user` object being deleted. Now,
    this is helpful if we want to display a certain message to the frontend and also
    add some user attributes such as `name` or `email` of the `user`. For example,
    if we want to display a message saying User with name {x} has been deleted. on
    the frontend, then we can pass `user` or other attributes of `user` here; in this
    case, it's the name, to be displayed on the frontend.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: The main difference between `remove()` and `findOneAndRemove()` is that remove
    does not return the documents that were deleted but `findOneAndRemove()` does.
    Now we know when to use these two methods.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: findByIdAndRemove()
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is the same as `findOneAndRemove()`, except that this always needs an
    `id` to be passed as a parameter:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Did you find any difference in the code between `findOneAndRemove()` and the
    preceding code for `findByIdAndRemove()`? If we look at the first parameter of
    this method, it only takes a simple integer value, which is the document ID. Now,
    if we look into the preceding `findOneAndRemove()` code, we will notice that we
    have passed an object in the first parameter. That''s because, for `findOneAndRemove()`,
    we can pass different arguments other than ID as well. For example, we can also
    pass `{ name: ''Anita'' }` in that parameter for `findOneAndRemove()`. But, for `findByIdAndRemove()`,
    as is obvious from the method name, we don''t need to pass an object but just
    an integer that denotes the document''s ID.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: It finds a document with the mentioned ID in the parameter and removes that
    document from the collections. Like `findOneAndRemove()`, this also returns the
    document that is being deleted.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: Adding validation with Mongoose
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Validations in Mongoose are defined at the schema level. Validations can be
    set in both strings and in numbers. Mongoose provides us with built-in validation
    techniques for strings and numbers. Also, we can customize these according to
    our need as well. Since validations are defined in the schemas, they are triggered
    when we hit the `save()` method for any document. If we only want to test these
    validations, we can do that as well by executing the validation method only via
    `{doc}.validate()`.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '`validate()` is also middleware, which means it has control when we are executing
    some methods in an asynchronous way.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: Default validations
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's talk about some of the default validations that Mongoose provides us with.
    These are also called built-in validators.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: required()
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `required()` validator checks if the field we added this validation on
    has some value or not. Previously, in the `User` model, we had this code:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This code also has a validation associated with the fields of the user. It requires
    the name and email of a user to be a string and not numbers, or Boolean, or anything
    else. But this code doesn't make sure the name and email fields are set for the
    user.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: 'So, if we want to add a `required()` validation, the code should be modified
    in this way:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'As you can see, we have changed the value of the name key to an object instead
    of just a string. Here, we can add as many validations as we want. So, the added
    validation `required: true` checks if there is some value set on the name and
    email of the user before saving that document in the collection. It returns an
    error if the validation is not met.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also pass a message when the validation returns an error. For example:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This way, we can also customize the messages as per our requirements. Very cool,
    right?
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: Type validation
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The type validation method defines the types of fields in a document. The different
    variations of type can be `String`, `boolean`, and `number`.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: String
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The string itself has several validators under it, such as `enum`, `match`,
    `maxlength`, and `minlength`.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '`maxlength` and `minlength` define the length of a string.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: Numbers
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Numbers have two validators: `min` and `max`. The `min` and `max` values define
    the range of values for a field in a collection.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: Custom validations
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can also add custom validations in case the default built-in validations
    are not enough.  We can pass a `validate` function and write our custom code into
    that function. Let''s look at an example:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Here, we have passed a `validate` method to the `Schema`. It takes a validator
    function where we can add our own code for the validation. The preceding method checks
    if the phone number field of the user is in the correct format or not. If it does
    not pass the validation, then it displays the message `{value} is not a valid
    phone number`.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also add nested validations in Mongoose: for example, if the name in
    our user collection is saved as `{ name: { first_name: ''Anita'', last_name: ''Sharma''
    } }`, we will need to add validations for both `first_name` and `last_name`. To
    do that, we can use:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '我们还可以在Mongoose中添加嵌套验证：例如，如果我们的用户集合中的名称保存为`{ name: { first_name: ''Anita'',
    last_name: ''Sharma'' } }`，我们将需要为`first_name`和`last_name`都添加验证。为了做到这一点，我们可以使用：'
- en: '[PRE51]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: First, we define the `Schema` for a low-level object, which is `first_name`
    and `last_name`. Then, for the `userSchema`, we pass on the `nameSchema` for the
    name field.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们为低级对象定义`Schema`，即`first_name`和`last_name`。然后，对于`userSchema`，我们将`nameSchema`传递给名称字段。
- en: 'Remember, we cannot add nested validations in a single `Schema` like this:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，我们不能像这样在单个`Schema`中添加嵌套验证：
- en: '[PRE52]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: You can look into Mongoose validations here: [http://mongoosejs.com/docs/validation.html](http://mongoosejs.com/docs/validation.html).
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在这里查看Mongoose验证：[http://mongoosejs.com/docs/validation.html](http://mongoosejs.com/docs/validation.html)。
- en: Summary
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we covered basic information about MongoDB and its benefits,
    how to make CRUD operations and queries in MongoDB, and the basic validations
    with Mongoose.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了关于MongoDB及其优势的基本信息，如何在MongoDB中进行CRUD操作和查询，以及Mongoose中的基本验证。
- en: Going further, in the next chapter, we will talk more about the REST APIs and
    the RESTful architecture design in our application.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将更多地讨论关于REST API和我们应用程序中的RESTful架构设计。
