- en: Chapter 19. Animations and Interpolations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here, we will see how we can use the `Animation` class to make our UI a little
    less static and a bit more interesting. As we have come to expect, the Android
    API will allow us to do some quite advanced things with relatively straightforward
    code, and the `Animation` class is no different.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter can be approximately divided into these parts:'
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to how animations in Android work and are implemented
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An introduction to a UI widget that we haven't explored yet, the `SeekBar` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A working animation app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First, let's explore how animations work in Android.
  prefs: []
  type: TYPE_NORMAL
- en: Animations in Android
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The normal way to create an animation in Android is through XML. We can write
    XML animations, and then load and play them through our Kotlin code on a specified
    UI widget. So, for example, we can write an animation that fades in and out five
    times over three seconds, then play that animation on an `ImageView` or any other
    widget. We can think of these XML animations as a script, as they define the type,
    order, and timing.
  prefs: []
  type: TYPE_NORMAL
- en: Let's explore some of the different properties we can assign to our animations,
    how to use them in our Kotlin code, and finally, we can make a neat animations
    app to try it all out.
  prefs: []
  type: TYPE_NORMAL
- en: Designing cool animations in XML
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have learned that XML can be used to describe animations as well as UI layouts,
    but let's find out exactly how. We can state values for properties of an animation
    that describe the starting and ending appearance of a widget. The XML can then
    be loaded by our Kotlin code by referencing the name of the XML file that contains
    the animation and turning it into a usable Kotlin object, again, not unlike a
    UI layout.
  prefs: []
  type: TYPE_NORMAL
- en: Many animation properties come in pairs. Here is a quick look at some of the
    animation property pairs we can use to create an animation. Straight after we
    have looked at some XML, we will see how to use it.
  prefs: []
  type: TYPE_NORMAL
- en: Fading in and out
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Alpha is the measure of transparency. So, by stating the starting `fromAlpha`
    and ending `toAlpha` values, we can fade items in and out. A value of `0.0` is
    invisible, and `1.0` is an object''s normal appearance. Steadily moving between
    the two makes a fading-in effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Move it, move it
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can move an object within our UI by using a similar technique; `fromXDelta`
    and `toXDelta` can have their values set as a percentage of the size of the object
    being animated.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code would move an object from left to right a distance equal
    to the width of the object itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In addition, there are the `fromYDelta` and `toYDelta` properties for animating
    upward and downward movement.
  prefs: []
  type: TYPE_NORMAL
- en: Scaling or stretching
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `fromXScale` and `toXScale` properties will increase or decrease the scale
    of an object. As an example, the following code will change the object running
    the animation from normal size to invisible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As another example, we could shrink the object to a tenth of its usual size
    using `android:fromYScale = "0.1"`, or make it 10 times as big using `android:fromYScale
    = "10.0"`.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling the duration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Of course, none of these animations would be especially interesting if they
    just instantly arrived at their conclusion. To make our animations more interesting,
    we can therefore set their duration in milliseconds. A millisecond is one thousandth
    of a second. We can also make timing easier, especially in relation to other animations,
    by setting the `startOffset` property, which is also in milliseconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next code would begin an animation one third of a second after we started
    it (in code), and it would take two thirds of a second to complete:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Rotate animations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you want to spin something around, just use the `fromDegrees` and `toDegrees`
    properties. This next code, probably predictably, will spin a widget around in
    a complete circle because, of course, there are 360 degrees in a circle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Repeating animations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Repetition might be important in some animations, perhaps a wobble or shake
    effect, so we can add a `repeatCount` property. In addition, we can specify how
    the animation is repeated by setting the `repeatMode` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code would repeat an animation 10 times, each time reversing
    the direction of the animation. The `repeatMode` property is relative to the current
    state of the animation. What this means is that if you rotated a button from 0
    to 360 degrees, for example, the second part of the animation (the first repeat)
    would rotate the other way, from 360 back to 0\. The third part of the animation
    (the second repeat) would, again, reverse and rotate from 0 to 360:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Combining an animation's properties with sets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To combine groups of these effects, we need a `set` of properties. This code
    shows how we can combine all the previous code snippets we have just seen into
    an actual XML animation that will compile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We still haven't seen any Kotlin with which to bring these animations to life.
    Let's fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: Instantiating animations and controlling them with Kotlin code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This next snippet of code shows how we would declare an object of the `Animation`
    type, initialize it with an animation contained in an XML file named `fade_in.xml`,
    and start the animation on an `ImageView` widget. We will soon do this in a project
    and also see where we can put the XML animations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We already have quite a powerful arsenal of animations and control features
    for things such as timing. But the Android API gives us a little bit more than
    this as well.
  prefs: []
  type: TYPE_NORMAL
- en: More animation features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can listen for the status of animations much like we can listen for clicks
    on a button. We can also use **interpolators** to make our animations more life-like
    and pleasing. Let's look at listeners first.
  prefs: []
  type: TYPE_NORMAL
- en: Listeners
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If we implement the `AnimationListener` interface, we can indeed listen to the
    status of animations by overriding the three functions that tell us when something
    has occurred. We could then act based on these events.
  prefs: []
  type: TYPE_NORMAL
- en: '`OnAnimationEnd` announces the end of an animation, `onAnimationRepeat` is
    called each time an animation begins a repeat, and – perhaps predictably – `onAnimationStart`
    is called when an animation has started animating. This might not be the same
    time as when `startAnimation` is called if a `startOffset` is set in the animations
    XML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We will see how `AnimationListener` works in the Animations demo app, and we'll
    also put another widget, `SeekBar`, into action.
  prefs: []
  type: TYPE_NORMAL
- en: Animation interpolators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you can think back to high school, you might remember exciting lessons about
    calculating acceleration. If we animated something at a constant speed, at first
    glance, things might seem OK. If we then compared the animation to another that
    uses gradual acceleration, then the latter would almost certainly be more pleasing
    to watch.
  prefs: []
  type: TYPE_NORMAL
- en: It is possible that if we were not told the only difference between the two
    animations was that one used acceleration and the other didn't, we wouldn't be
    able to say *why* we preferred it. Our brains are more receptive to things that
    conform to the norms of the world around us. Therefore, adding a bit of real-world
    physics, such as acceleration and deceleration, improves our animations.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we want to do, however, is start doing a bunch of mathematical
    calculations just to slide a button onto the screen or spin some text in a circle.
  prefs: []
  type: TYPE_NORMAL
- en: This is where **interpolators** come in. They are animation modifiers that we
    can set in a single line of code within our XML.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some examples of interpolators are `accelerate_interpolator` and `cycle_interpolator`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We will put some interpolators, along with some XML animations and the related
    Kotlin code, into action next.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can learn more about interpolators and the Android `Animation` class on
    the Android developer website here: [http://developer.android.com/guide/topics/resources/animation-resource.html](http://developer.android.com/guide/topics/resources/animation-resource.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Animations demo app – introducing SeekBar
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: That's enough theory, especially with something that should be so visible. Let's
    build an animation demo app that explores everything we have just discussed, and
    a bit more as well.
  prefs: []
  type: TYPE_NORMAL
- en: This app involves small amounts of code in lots of different files. Therefore,
    I have tried to make it plain what code is in what file, so you can keep track
    of what is going on. This will make the Kotlin we write for this app more understandable
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: The app will demonstrate rotations, fades, translations, animation events, interpolations,
    and controlling duration with a `SeekBar` widget. The best way to explain what
    `SeekBar` does is to build it and then watch it in action.
  prefs: []
  type: TYPE_NORMAL
- en: Laying out the animation demo
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new project called `Animation Demo` using the **Empty Activity** template,
    leaving all the other settings at their usual settings. As usual, should you wish
    to speed things up by copying and pasting the layout, the code, or the animation
    XML, it can all be found in the `Chapter19` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following reference screenshot of the finished layout to help guide
    you through the next steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Laying out the animation demo](img/B12806_19_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here is how you can lay out the UI for this app:'
  prefs: []
  type: TYPE_NORMAL
- en: Open `activity_main.xml` in the design view of the editor window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete the default **Hello world!** `TextView`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an **ImageView** to the top-center portion of the layout. Use the previous
    reference screenshot to guide you. Use the `@mipmap/ic_launcher` to show the Android
    robot in `ImageView` when prompted to do so by selecting **Project** | **ic_launcher**
    in the pop-up **Resources** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the `id` property of the `ImageView` to `imageView`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Directly below the `ImageView`, add a `TextView`. Set the `id` to `textStatus`.
    I made my `TextView` a little bigger by dragging its edges (not the constraint
    handles) and changed its `textSize` attribute to `40sp`. The layout so far should
    look something like this next screenshot:![Laying out the animation demo](img/B12806_19_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we will add a large selection of **Button** widgets to the layout. Exact
    positioning is not vital, but the exact `id` property values we add to them later
    in the tutorial will be. Follow this next screenshot to lay out 12 buttons in
    the layout. Alter the `text` attribute so that your buttons have the same text
    as those in the next screenshot. The `text` attributes are detailed specifically
    in the next step in case the screenshot isn't clear enough:![Laying out the animation
    demo](img/B12806_19_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To make the process of laying out the buttons quicker, lay them out just approximately
    at first, then add the `text` attributes from the next step, and then fine-tune
    the button positions to get a neat layout.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `text` values as they are in the screenshot; here are all the values
    from left to right and top to bottom: `FADE IN`, `FADE OUT`, `FADE IN OUT`, `ZOOM
    IN`, `ZOOM OUT`, `LEFT RIGHT`, `RIGHT LEFT`, `TOP BOT`, `BOUNCE`, `FLASH`, `ROTATE
    LEFT`, and `ROTATE RIGHT`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `SeekBar` widget from the **Widgets** category of the palette, on the
    left, below the buttons. Set the `id` property to `seekBarSpeed` and the `max`
    property to `5000`. This means that `SeekBar` widget will hold a value between
    0 and 5,000 as it is dragged by the user from left to right. We will see how we
    can read and use this data soon.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We want to make the `SeekBar` widget much wider. To achieve this, you use the
    exact same technique as with any widget; just drag the edges of the widget. However,
    as the `SeekBar` widget is quite small, it is hard to increase its size without
    accidentally selecting the constraint handles. To overcome this problem, zoom
    into the design view by holding the *Ctrl* key and rolling the middle mouse wheel
    forward. You can then grab the edges of the `SeekBar` widget without touching
    the constraint handles. I have shown this in action in the next screenshot:![Laying
    out the animation demo](img/B12806_19_07.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, add a `TextView` widget just to the right of the `SeekBar` widget and set
    its `id` property to `textSeekerSpeed`. This step, combined with the previous
    two, should look like this screenshot:![Laying out the animation demo](img/B12806_19_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tweak the positions to look like the reference screenshot at the start of these
    steps, and then click the **Infer Constraints** button to lock the positions.
    Of course, you can do this manually if you want the practice. Here is a screenshot
    with all the constraints in place:![Laying out the animation demo](img/B12806_19_08.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, add the following `id` properties to the buttons, as identified by the
    text property that you have already set. If you are asked whether you want to
    **Update usages…** as you enter these values, select **Yes**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| **Existing text property** | **Value of id property to set** |'
  prefs: []
  type: TYPE_TB
- en: '| Fade In | `btnFadeIn` |'
  prefs: []
  type: TYPE_TB
- en: '| Fade Out | `btnFadeOut` |'
  prefs: []
  type: TYPE_TB
- en: '| Fade In Out | `btnFadeInOut` |'
  prefs: []
  type: TYPE_TB
- en: '| Zoom In | `btnZoomIn` |'
  prefs: []
  type: TYPE_TB
- en: '| Zoom Out | `btnZoomOut` |'
  prefs: []
  type: TYPE_TB
- en: '| Left Right | `btnLeftRight` |'
  prefs: []
  type: TYPE_TB
- en: '| Right Left | `btnRightLeft` |'
  prefs: []
  type: TYPE_TB
- en: '| Top Bot | `btnTopBottom` |'
  prefs: []
  type: TYPE_TB
- en: '| Bounce | `btnBounce` |'
  prefs: []
  type: TYPE_TB
- en: '| Flash | `btnFlash` |'
  prefs: []
  type: TYPE_TB
- en: '| Rotate Left | `btnRotateLeft` |'
  prefs: []
  type: TYPE_TB
- en: '| Rotate Right | `btnRotateRight` |'
  prefs: []
  type: TYPE_TB
- en: We will see how to use this newcomer to our UI (`SeekBar`) when we get to coding
    the `MainActivity` class in a few sections time.
  prefs: []
  type: TYPE_NORMAL
- en: Coding the XML animations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Right-click on the **res** folder and select **New | Android resource directory**.
    Enter `anim` in the `Directory name:` field and left-click **OK**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now right-click on the new **anim** directory and select **New | Animation
    resource file**. In the **File name:** field, type `fade_in` and then left-click
    **OK**. Delete the contents and add this code to create the animation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Right-click on the **anim** directory and select **New | Animation resource
    file**. In the `File name:` field, type `fade_out` and then left-click **OK**.
    Delete the contents and add this code to create the animation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Right-click on the **anim** directory and select **New | Animation resource
    file**. In the `File name:` field, type `fade_in_out` and then left-click **OK**.
    Delete the contents and add this code to create the animation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Right-click on the **anim** directory and select **New | Animation resource
    file**. In the `File name:` field, type `zoom_in` and then left-click **OK**.
    Delete the contents and add this code to create the animation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Right-click on the **anim** directory and select **New** | **Animation resource
    file**. In the `File name:` field, type `zoom_out` and then left-click **OK**.
    Delete the contents and add this code to create the animation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Right-click on the **anim** directory and select **New | Animation resource
    file**. In the `File name:` field, type `left_right` and then left-click **OK**.
    Delete the contents and add this code to create the animation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, right-click on the **anim** directory and select **New | Animation resource
    file**. In the **File name:** field, type `right_left` and then left-click **OK**.
    Delete the entire contents and add this code to create the animation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'As before, right-click on the **anim** directory and select **New | Animation
    resource file**. In the **File name:** field, type `top_bot` and then left-click
    **OK**. Delete the entire contents and add this code to create the animation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'You guessed it; right-click on the **anim** directory and select **New | Animation
    resource file**. In the **File name:** field, type `flash` and then left-click
    **OK**. Delete the contents and add this code to create the animation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Just a few more to go – right-click on the **anim** directory and select **New
    | Animation resource file**. In the **File name:** field, type `bounce` and then
    left-click **OK**. Delete the contents and add this code to create the animation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Right-click on the **anim** directory and select **New | Animation resource
    file**. In the **File name:** field, type `rotate_left` and then left-click **OK**.
    Delete the contents and add this code to create the animation. Here we see something
    new, `pivotX="50%"` and `pivotY="50%"`. This makes the rotate animation central
    on the widget that will be animated. We can think of this as setting the *pivot*
    point of the animation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Right-click on the **anim** directory and select **New | Animation resource
    file**. In the **File name:** field, type `rotate_right` and then left-click **OK**.
    Delete the contents and add this code to create the animation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Phew! Now we can write the Kotlin code to add our animations to our UI.
  prefs: []
  type: TYPE_NORMAL
- en: Wiring up the Animation demo app in Kotlin
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open the `MainActivity.kt` file. Now, following the class declaration, we can
    declare the following properties for animations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You will need to add the following `import` statement at this point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we used the `lateinit` keyword when declaring the `Animation`
    instances. This will mean that Kotlin will check that each instance is initialized
    before it is used. This avoids us using `!!` (null checks) each time we use a
    function on one of these instances. For a refresher on the `!!` operator, refer
    to [Chapter 12](ch12.html "Chapter 12. Connecting Our Kotlin to the UI and Nullability"),
    *Connecting Our Kotlin to the UI and Nullability*.
  prefs: []
  type: TYPE_NORMAL
- en: We also added an `Int` property, `seekSpeedProgress`, which will be used to
    track the current value/position of `SeekBar`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s call a new function from `onCreate` after the call to `setContentView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: At this point, the new line of code will have an error until we implement the
    new function.
  prefs: []
  type: TYPE_NORMAL
- en: Now we will implement the `loadAnimations` function. Although the code in this
    function is quite extensive, it is also very straightforward. All we are doing
    is using the `loadAnimation` function of the `AnimationUtils` class to initialize
    each of our `Animation` references with one of our XML animations. You will also
    notice that, for the `animFadeIn` `Animation`, we also call `setAnimationListener`
    on it. We will write the functions to listen for events shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `loadAnimations` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You will need to import one new class at this point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will add a click-listener for each button. Add this code immediately
    before the closing curly brace of the `onCreate` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The code we just added creates errors in all the lines of code. We can ignore
    them for now, as we will fix them shortly and discuss what happened.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can use a lambda to handle the `SeekBar` interactions. We will override
    three functions, as it is required by the interface when implementing `OnSeekBarChangeListener`:'
  prefs: []
  type: TYPE_NORMAL
- en: A function that detects a change in the position of the `SeekBar` widget, called
    `onProgressChanged`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A function that detects the user starting to change the position, called `onStartTrackingTouch`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A function that detects when the user has finished using the `SeekBar` widget,
    called `onStopTrackingTouch`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To achieve our goals, we only need to add code to the `onProgressChanged` function,
    but we must still override them all.
  prefs: []
  type: TYPE_NORMAL
- en: All we do in the `onProgressChanged` function is assign the current value of
    the `SeekBar` object to the `seekSpeedProgress` member variable, so it can be
    accessed from elsewhere. Then, we use this value along with the maximum possible
    value of the `SeekBar` object, obtained by using `seekBarSpeed.max`, and output
    a message to the `textSeekerSpeed` `TextView`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the code we have just discussed before the closing curly brace of the `onCreate`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Now, we need to alter the `MainActivity` class declaration to implement two
    interfaces. In this app, we will be listening for clicks and for animation events,
    so the two interfaces we will be using are `View.OnClickListener` and `Animation.AnimationListener`.
    You will notice that to implement more than one interface, we simply separate
    the interfaces with a comma.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alter the `MainActivity` class declaration by adding the highlighted code we
    have just discussed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'At this stage, we can add and implement the required functions for those interfaces.
    First, the `AnimationListener` functions, `onAnimationEnd`, `onAnimationRepeat`,
    and `onAnimationStart`. We only need to add a little code to two of these functions.
    In `onAnimationEnd`, we set the `text` property of `textStatus` to `STOPPED`,
    and in `onAnimationStart`, we set it to `RUNNING`. This will demonstrate our animation
    listeners are indeed listening and working:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The `onClick` function is quite long, but nothing complicated. Each option of
    the `when` block handles each button from the UI, sets the duration of an animation
    based on the current position of the `SeekBar` widget, sets up the animation so
    it can be listened to for events, and then starts the animation.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You will need to use your preferred technique to import the `View` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the `onClick` function we have just discussed, and we have then completed
    this mini app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, run the app and move the `SeekBar` widget to roughly the center so that
    the animations run for a reasonable amount of time:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Wiring up the Animation demo app in Kotlin](img/B12806_19_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Click the **ZOOM IN** button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Wiring up the Animation demo app in Kotlin](img/B12806_19_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Notice how the text on the Android robot changes from **RUNNING** to **STOPPED**
    at the appropriate time. Now, click one of the **ROTATE** buttons:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Wiring up the Animation demo app in Kotlin](img/B12806_19_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Most of the other animations don't do themselves justice in a screenshot, so
    be sure to try them all out for yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Frequently asked questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Q.1) We know how to animate widgets now, but what about shapes or images that
    I create myself?
  prefs: []
  type: TYPE_NORMAL
- en: A) An `ImageView` widget can hold any image you like. Just add the image to
    the `drawable` folder and then set the appropriate `src` attribute on the `ImageView`
    widget. You can then animate whatever image is being shown in the `ImageView`
    widget.
  prefs: []
  type: TYPE_NORMAL
- en: Q.2) But what if I want more flexibility than this, more like a drawing app
    or even a game?
  prefs: []
  type: TYPE_NORMAL
- en: A) To implement this kind of functionality, we will need to learn about another
    general computing concept known as **threads**, as well as some more Android classes
    (such as `Paint`, `Canvas`, and `SurfaceView`). We will learn how to draw anything
    from a single pixel to shapes, and then move them around the screen, starting
    in the next chapter, [Chapter 20](ch20.html "Chapter 20. Drawing Graphics"), *Drawing
    Graphics*.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we have another app-enhancing trick up our sleeves. In this chapter, we
    saw that animations in Android are quite straightforward. We designed an animation
    in XML and added the file to the `anim` folder. Next, we got a reference to the
    animation in XML with an `Animation` object in our Kotlin code.
  prefs: []
  type: TYPE_NORMAL
- en: We then used a reference to a widget in our UI, set an animation to it using
    `setAnimation`, and passed in the `Animation` object. We commenced the animation
    by calling `startAnimation` on the reference to the widget.
  prefs: []
  type: TYPE_NORMAL
- en: We also saw that we can control the timing of animations and listen for animation
    events.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about drawing graphics in Android. This will
    be the start of several chapters on graphics, where we will build a kid's-style
    drawing app.
  prefs: []
  type: TYPE_NORMAL
