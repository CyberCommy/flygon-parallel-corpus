- en: Extracting Embedded Metadata Recipes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter covers the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Extracting audio and video metadata
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The big picture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mining for PDF metadata
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reviewing executable metadata
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading office document metadata
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating our metadata extractor with EnCase
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When an investigation comes down to just a few files of interest, it is critical
    to extract every piece of available information about the file. Embedded metadata,
    often overlooked, can provide us with crucial information that solidifies the
    evidentiary value of a given file. Whether it is gathering authorship information
    from Microsoft Office files, mapping GPS coordinates from pictures, or extracting
    compilation information from executables, we can learn a lot more about files
    we are investigating. In this chapter, we will develop scripts to examine these
    file formats, and others, to extract key information for our review. We will illustrate
    how to integrate these recipes with EnCase, the popular forensic suite, and add
    them to your investigative workflow.
  prefs: []
  type: TYPE_NORMAL
- en: 'In particular, we will develop code that highlights the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Parsing ID3 and QuickTime-formatted metadata from audio and video formats
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Revealing GPS coordinates embedded within images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identifying authorship and lineage information from PDF files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extracting embedded names, compilation dates, and other attributes of Windows
    executable files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reporting on document creation and source of Microsoft Office files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Launching Python scripts from EnCase
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visit [www.packtpub.com/books/content/support](http://www.packtpub.com/books/content/support)
    to download the code bundle for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Extracting audio and video metadata
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Recipe Difficulty: Easy'
  prefs: []
  type: TYPE_NORMAL
- en: 'Python Version: 2.7 or 3.5'
  prefs: []
  type: TYPE_NORMAL
- en: 'Operating System: Any'
  prefs: []
  type: TYPE_NORMAL
- en: Audio and video files are common file formats that make use of embedded metadata.
    This information, for example, is used by your preferred media player to show
    the artist, album, and track name information of the content you import. Though
    the majority of this information is standard and focused on providing information
    to the listener, we sometimes find important details in this area of the file.
    We begin our exploration of embedded metadata with the extraction of the common
    attributes from audio and video files.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This recipe requires the installation of the third-party library `mutagen`.
    All other libraries used in this script are present in Python''s standard library.
    This library allows us to extract metadata from audio and video files. This library
    can be installed using `pip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: To learn more about the `mutagen` library, visit [https://mutagen.readthedocs.io/en/latest](https://mutagen.readthedocs.io/en/latest).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this script, we perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Identify the input file type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extract embedded metadata from the file type processor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To extract information from a sample MP3 or MP4 file, we first import the three
    libraries needed for this recipe: `argparse`, `json`, and `mutagen`. The `json`
    library allows us to load definitions for the QuickTime MP4 metadata format used
    later in this recipe.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This recipe''s command-line handler takes one positional argument, `AV_FILE`,
    which represents the path to the MP3 or MP4 file to process. After parsing the
    user-supplied arguments, we use the `mutagen.File()` method to open a handle to
    the file. Depending on the extension of the input file, we send this handle to
    the appropriate function: `handle_id3()` or `handle_mp4()`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `handle_id3()` function is responsible for extracting metadata from MP3
    files. The MP3 format uses the ID3 standard for storing its metadata. In our ID3
    parsing function, we first create a dictionary, called `id3_frames`, mapping the
    ID3 fields, as they are represented in the raw file, to human-readable strings.
    We can add more fields to this definition to extend the information we extract.
    Before we extract the embedded metadata, we print appropriate column headers to
    the console.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Next, we use a loop to extract the names and various values of each `id3` frame.
    We query the name of the frame against the `id3_frames` dictionary to extract
    the human-readable version of it. Additionally, from each of the frames, we extract
    the description, text, and value(s) (if they are present) using the `getattr()`
    method. Finally, we print the pipe-delimited text to the console for review. That
    takes care of MP3 files, now let's move onto MP4 files.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `handle_mp4()` function is responsible for processing MP4 files and follows
    a similar workflow to the previous function. We begin by setting up the metadata
    mappings in a dictionary, called `qt_tag`, using the Unicode value for the copyright
    symbol (`u"\u00A9"`) as a prepended character to the field names. This mapping
    dictionary is designed so the tag name is the key and the human-readable string
    is the value. We then use the `json.load()` method to bring in a large list of
    definitions for types of media genres (Comedy, Podcasts, Country, and so on).
    By storing the JSON data to the `genre_ids` variable, in this case, we have a
    dictionary with genre look up values where keys are integers and their values
    are different genres. These definitions are from [http://www.sno.phy.queensu.ca/~phil/exiftool/TagNames/QuickTime.html#GenreID](http://www.sno.phy.queensu.ca/~phil/exiftool/TagNames/QuickTime.html#GenreID).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Next, we iterate through the MP4 file's embedded metadata key-value pairs. For
    each key, we use the `qt_tag` dictionary to look up the human-readable version
    of the key. If the value is a list, we join all of its elements into a semi-colon
    separated string. Alternatively, if the value is `"geID"`, we use the `genre_ids`
    dictionary to look up the integer and print the mapped genre for the user.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Using a MP3 podcast as an example, the script shows additional details otherwise
    unavailable. We now know the release date, what appears to be the software used,
    and several identifiers that we can use for keywords to try and identify the file
    elsewhere.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00031.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Let's look at another podcast, but this time, one that is an MP4\. After running
    the script, we are presenting with a great deal of information about the MP4 file's
    source and type of content. Again, we have several interesting identifiers, source
    URLs, and other attribution details available to us due to this exercise.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00032.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This script can be further improved. here''s a recommendation:'
  prefs: []
  type: TYPE_NORMAL
- en: Add additional support for other multimedia formats using the `mutagen` library.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The big picture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Recipe Difficulty: Easy'
  prefs: []
  type: TYPE_NORMAL
- en: 'Python Version: 2.7 or 3.5'
  prefs: []
  type: TYPE_NORMAL
- en: 'Operating System: Any'
  prefs: []
  type: TYPE_NORMAL
- en: Images can contain many metadata attributes, depending on the file format and
    the device that was used to capture the image. Fortunately, most devices will
    embed GPS information within the photos they take. Using third-party libraries,
    we will extract GPS coordinates and plot them with Google Earth. This script focuses
    exclusively on this task, however, the recipe can be easily tweaked to extract
    all embedded **Exchangeable Image File Format** (**EXIF**) metadata in JPEG and
    TIFF images as well.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This recipe requires the installation of two third-party libraries: `pillow`
    and `simplekml`. All other libraries used in this script are present in Python''s
    standard library. The `pillow` library provides a clean interface to the **Python
    Imaging Library** (**PIL**) and can be used to extract embedded metadata from
    images:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: To learn more about the `pillow` library, visit [https://pillow.readthedocs.io/en/4.2.x/](https://pillow.readthedocs.io/en/4.2.x/).
  prefs: []
  type: TYPE_NORMAL
- en: 'To add some extra flair to this recipe, we will be writing the GPS details
    to a KML file, for use in a program like Google Earth. To handle this, we will
    use the `simplekml` library, available for installation by executing the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: To learn more about the `simplekml` library, visit [http://www.simplekml.com/en/latest/](http://www.simplekml.com/en/latest/).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We extract metadata from image files in the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the input photo with `PIL`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use `PIL` to extract all `EXIF` tags.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If GPS coordinates are found, create a Google Earth KML file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Print the Google Maps URL to view the GPS data in the browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We begin by importing `argparse` along with the newly installed `simplekml`
    and `PIL` libraries. For this example, we will only need the `Image` and **`ExifTags.Tags`**
    classes from `PIL`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This recipe's command-line handler accepts one positional argument, `PICTURE_FILE`,
    which represents the file path to the photo to process.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'After configuring these arguments, we specify two URLs, `gmaps` and `open_maps`,
    that we will populate with coordinate information. Since the `PIL` library provides
    coordinates as a tuple of tuples in the **degrees minutes seconds** (**DMS**)
    format, we will need a function to convert them into decimal, which is another
    commonly used format for expressing coordinates. Each of the three elements in
    the provided tuple represents a different component of the coordinate. Additionally,
    within each tuple, there are two elements: the first element represents the value
    and the second is the scale that must be used to convert the value into an integer.'
  prefs: []
  type: TYPE_NORMAL
- en: For each component of the coordinate, we need to divide the first value in the
    nested tuple by the second value. This structure is used for the second and third
    tuple, which describe the minute and second values of the DMS coordinate. Additionally,
    we need to ensure that the minutes and seconds are added together properly by
    dividing each by the product of `60` to the power of the current iteration count
    (which will be `1` and `2`). While this won't change the first value (as enumeration
    begins at zero), it will ensure the second and third values are properly expressed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code block highlights an example of the coordinate format provided
    by the `PIL` library. Notice how the degree, minute, and second values are grouped
    into their own tuples. The first element represents the value of the coordinate
    and the second represents the scale. For example, for the seconds element (the
    third tuple), we need to divide the integer by `1000` before performing our other
    operations to ensure the value is represented correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Latitude**: `((41 , 1), (53 , 1), (23487 , 1000))`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Longitude**: `((12 , 1), (29 , 1), (10362 , 1000))`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GPS coordinates**: `41.8898575 , 12.486211666666666`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: With the DMS to decimal coordinate conversion process configured, we open the
    image using the `Image.open()` method to open a file by path as a `PIL` object.
    We then use the `_getexif()` method to extract a dictionary containing EXIF data.
    If `PIL` is unable to extract metadata from the photo, this variable will be `None`.
  prefs: []
  type: TYPE_NORMAL
- en: With the `EXIF` dictionary, we iterate through the keys and values to convert
    the numeric value to a human-readable name. This uses the `TAGS` dictionary from
    `PIL`, which maps the numeric value to a `string` representing the tag. The `TAGS`
    object acts in a similar manner to the manually specified mappings in the prior
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Once the `GPSInfo` tag is found, we extract four values of interest, found within
    the dictionary keys `1` through `4`. In pairs, we store the GPS reference and
    process the coordinates with the `process_coords()` method previously described.
    By storing the reference as a Boolean, we can easily use an `if` statement to
    determine whether the GPS decimal coordinates should be positive or negative.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: To add our KML support, we initiate a `kml` object from the `simplekml` library.
    From there, we add a new point with a name and the coordinates. For the name,
    we simply use the file's name. The coordinates are provided as a tuple within
    a list where the first element is the longitude and the second is the latitude.
    We could also provide a third element in this tuple to specify the zoom level,
    though we omit it in this instance. To produce our `KML` file, we call the `save()`
    method and write it to a `.kml` file with the same name as the input file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: With the processed GPS information, we can print the coordinates, KML file,
    and URLs to the console. Notice how we nest the format strings, allowing us to
    print a basic message along with the URL.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: When we run this script at the command line, we quickly see the coordinates,
    two links to view the location on a map, and the path to the KML file.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00033.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Following the two links we generated, we can see the pins on the two maps and
    share these links with others if so desired.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00034.jpeg)![](../images/00035.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Lastly, we can use the KML file to store and reference the location found within
    the image. Google Earth allows this file to be viewed through both the web and
    desktop clients.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00036.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This script can be further improved. We have provided one or more recommendations
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Integrate file recursion to process multiple photos to create larger KML files
    that map many GPS coordinates.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Experiment with the `simplekml` library to add additional detail to each point,
    such as a description, timestamp, coloring, and more.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mining for PDF metadata
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Recipe Difficulty: Easy'
  prefs: []
  type: TYPE_NORMAL
- en: 'Python Version: 2.7 or 3.5'
  prefs: []
  type: TYPE_NORMAL
- en: 'Operating System: Any'
  prefs: []
  type: TYPE_NORMAL
- en: While PDF documents can represent a wide variety of media, including images,
    text, and forms, they contain structured embedded metadata in the **Extensible
    Metadata Platform** (**XMP**) format that can provide us with some additional
    information. Through this recipe, we access a PDF using Python and extract metadata
    describing the creation and lineage of the document.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This recipe requires the installation of the third-party library `PyPDF2`.
    All other libraries used in this script are present in Python''s standard library.
    The `PyPDF2` module provides us with bindings to read and write PDF files. In
    our case, we will only use this library to read the metadata stored in the XMP
    format. To install this library, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: To learn more about the `PyPDF2` library, visit [http://mstamy2.github.io/PyPDF2/](http://mstamy2.github.io/PyPDF2/).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To handle PDFs for this recipe, we follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the PDF file with `PyPDF2` and extract embedded metadata.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define a custom print function for different Python object types.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Print various embedded metadata properties.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, we import the `argparse`, `datetime`, and `sys` libraries along with
    the newly installed `PyPDF2` module.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This recipe's command-line handler accepts one positional argument, `PDF_FILE`,
    which represents the file path to the PDF to process. For this script, we need
    to pass an open file object to the `PdfFileReader` class, so we use the `argparse.FileType`
    handler to open the file for us.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: After providing the open file to the `PdfFileReader` class, we call the `getXmpMetadata()`
    method to provide an object containing the available XMP metadata. If this method
    returns `None`, we print a succinct message to the user before exiting.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: With the `xmpm` object ready, we begin extracting and printing relevant values.
    We extract a number of different values including the title, creator, contributor,
    description, creation, and modification dates. These value definitions are from
    [http://wwwimages.adobe.com/content/dam/Adobe/en/devnet/xmp/pdfs/XMP%20SDK%20Release%20cc-2016-08/XMPSpecificationPart1.pdf](http://wwwimages.adobe.com/content/dam/Adobe/en/devnet/xmp/pdfs/XMP%20SDK%20Release%20cc-2016-08/XMPSpecificationPart1.pdf).
    Even though many of these elements are different data types, we pass them to the
    `custom_print()` method in the same manner. Let's take a look at how this function
    works.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Since the XMP values stored may differ based on the software used to generate
    the PDF, we use a custom print handling function, creatively called `custom_print()`.
    This allows us, as presented here, to handle the conversion of lists, dictionaries,
    dates, and other values into a readable format. This function is portable and
    can be brought into other scripts as needed. The function, through a series of
    `if-elif-else` statements, checks if the input `value` is a supported object type
    using the built-in `isinstance()` method and handles them appropriately. If the
    input `value` is an unsupported type, this is printed to the console instead.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Our next set of metadata includes more details about the document''s lineage
    and creation. The `xmp_creatorTool` attribute stores information about the software
    used to create the resource. Separately, we can also deduce additional lineage
    information based on the following two IDs:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Document ID` represents an identifier, usually stored as a GUID, that is
    generally assigned when the resource is saved to a new file. For example, if we
    create `DocA.pdf` and then save it as `DocB.pdf`, we would have two different
    `Document IDs`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Following the `Document ID` is the second identifier, `Instance ID`. This `Instance
    ID` is usually generated once per save. An example of this identifier updating
    is when we update `DocA.pdf` with a new paragraph of text and save it with the
    same filename.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When editing the same PDF, you would expect the `Document ID` to remain the
    same while the `Instance ID` would likely update, though this behavior can vary
    depending on the software used.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Following this, we continue extracting other common XMP metadata, including
    the language, publisher, resource type, and type. The resource type field should
    represent a **Multipurpose Internet Mail Extensions** (**MIME**) value and the
    type field should store a **Dublin Core Metadata Initiative** *(***DCMI**) value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Lastly, we extract any custom properties saved by the software. Since this should
    be a dictionary, we can print it without our `custom_print()` function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: When we execute the script, we can quickly see many of the attributes stored
    within the PDF. Notice how the `Document ID` does not match the `Instance ID`,
    this suggests this document may have been modified from the original PDF.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00037.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This script can be further improved. We have provided one or more recommendations
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Explore and integrate other PDF-related libraries, such as `slate` and `pyocr`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `slate` module, [https://github.com/timClicks/slate](https://github.com/timClicks/slate),
    can extract text from a PDF file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `pyocr` module, [https://github.com/openpaperwork/pyocr](https://github.com/openpaperwork/pyocr),
    can be used to OCR a PDF to capture handwritten text.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reviewing executable metadata
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Recipe Difficulty: Easy'
  prefs: []
  type: TYPE_NORMAL
- en: 'Python Version: 2.7 or 3.5'
  prefs: []
  type: TYPE_NORMAL
- en: 'Operating System: Any'
  prefs: []
  type: TYPE_NORMAL
- en: During the course of an investigation, we may identify a potentially suspicious
    or unauthorized portable executable file. This executable may be interesting because
    of the time it was used on the system, its location on the system, or other attributes
    specific to the investigation. Whether we are investigating it as malicious software
    or an unauthorized utility, we need to have the capability to learn more about
    it.
  prefs: []
  type: TYPE_NORMAL
- en: By extracting embedded metadata from Windows executable files, we can learn
    about the components that make up the file. In this recipe, we will expose the
    compilation date, useful **Indicator of Compromise** (**IOC**) data from the section
    headers, and the imported and exported symbols.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This recipe requires the installation of the third-party library `pefile`.
    All other libraries used in this script are present in Python''s standard library.
    The `pefile` module saves us from needing to specify all of the structures of
    Windows executable files. The `pefile` library can be installed like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: To learn more about the `pefile` library, visit [https://github.com/erocarrera/pefile](https://github.com/erocarrera/pefile).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We extract metadata from executable files via the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the executable and dump the metadata with `pefile`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If present, dynamically print metadata to the console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We begin by importing libraries to handle arguments, parsing dates, and interacting
    with executable files. Notice that we specifically import the `PE` class from
    `pefile`, allowing us to invoke the `PE` class attributes and methods directly
    later in the recipe.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This recipe’s command-line handler takes one positional argument, `EXE_FILE`,
    the path to the executable file we will be extracting metadata from. We will also
    take one optional argument, `v`, to allow the user to decide if they would like
    verbose or simplified output.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Using the `PE` class, we load the input executable file simply by providing
    it the file's path. Using the `dump_dict()` method, we dump the executable data
    to a dictionary object. This library allows us to explore the key-value pairs
    through this `ped` dictionary or as properties of the `pe` object. We will demonstrate
    how to extract embedded metadata using both techniques.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Let's start by extracting basic file metadata, such as the embedded authorship,
    version, and compilation time. This metadata is stored within the `StringTable`
    in the `FileInfo` object. Using `for` loops and `if` statements, we ensure the
    correct values are extracted and assign the string `"Unknown"` to values that
    are `None` or whose length is zero to better accommodate printing this data to
    the console. With all key-value pairs extracted and printed to the console, we
    move onto processing the executable's embedded compilation time, which is stored
    elsewhere.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The compilation timestamp is stored within the file and shows the date the executable
    was compiled. The `pefile` library interprets the raw data for us, whereas the
    `Value` key stores both the original hex value and an interpreted date within
    square brackets. We can either interpret the hex value ourselves or, more simply,
    convert the timestamp from the parsed date string into a `datetime` object.
  prefs: []
  type: TYPE_NORMAL
- en: We extract the parsed date string in square brackets using the `split()` and
    `strip()` methods to extract only the string contained within the brackets. An
    abbreviated time zone (for example, UTC, EST, or PST) must also be separated from
    the parsed date string prior to its conversion. Once the date string is isolated,
    we use the `datetime.strptime()` method with `datetime` formatters to properly
    convert and print the executable's embedded compilation date.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The next element we extract is metadata about the executable's sections. This
    time, rather than using the `pe` object and its attributes, we use the dictionary
    object we created, `ped`, to iterate through the sections and display the section
    name, address, sizes, and `MD5` hash of its content. This data can be added to
    your IOCs to assist with the identification of other malicious files on this and
    other hosts in the environment.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Another set of metadata within a portable executable file is a listing of its
    imports and exports. Let's start with the import entries. First, we ensure that
    the attribute exists before attempting to access this attribute of the `pe` variable.
    If it is present, we use two `for` loops to step through the imported DLLs and,
    if the user specified verbose output, each of the imports within the DLLs. If
    the user did not specify verbose output, the innermost loop is skipped and only
    the DLL names are presented to the console. From these loops, we extract the DLL
    names, addresses, and import names. We can use the `getattr()` built-in function
    to ensure we don't receive any errors in the instance where the attribute is not
    present.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Lastly, let's review the code block related to export metadata. Because some
    executable may not have exports, we use the `hasattr()` function to confirm the
    `DIRECTORY_ENTRY_EXPORT` attribute is present. If it is, we iterate through each
    symbol and print the names and addresses for each of the symbols in a bulleted
    list to better distinguish them in the console.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Using a Firefox installer as our example, we are able to extract a great deal
    of embedded metadata attributes from the executable. This information shows us
    a number of things, such as the compilation date; that this appears to be a packed
    executable, likely with 7-Zip; and the hash values for the different sections.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00038.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'When we run this same script against a DLL, we see many of the same fields
    from the executable run, in addition to the exports section. Due to the length
    of the output, we''ve omitted some of the text in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00039.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This script can be further improved. We have provided one or more recommendations
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Using recipes that we develop in [Chapter 5](part0158.html#4MLOS0-260f9401d2714cb9ab693c4692308abe),
    *Networking and Indicator of Compromise Recipes*, query the discovered hash values
    against online resources, such as VirusTotal, and report on any matches from other
    submissions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrate `pytz` to allow the user to interpret dates in a local or otherwise
    specified timezone
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading office document metadata
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Recipe Difficulty: Medium'
  prefs: []
  type: TYPE_NORMAL
- en: 'Python Version: 2.7 or 3.5'
  prefs: []
  type: TYPE_NORMAL
- en: 'Operating System: Any'
  prefs: []
  type: TYPE_NORMAL
- en: Reading metadata from office documents can expose interesting information about
    the authorship and history of those files. Conveniently, the 2007 formatted `.docx`,
    .`xlsx`, and `.pptx` files store metadata in XML. The XML tags can be easily processed
    with Python.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All libraries used in this script are present in Python's standard library.
    We use the built-in `xml` library and the `zipfile` library to allow us access
    to the XML documents within the ZIP container.
  prefs: []
  type: TYPE_NORMAL
- en: To learn more about the `xml` library, visit [https://docs.python.org/3/library/xml.etree.elementtree.html](https://docs.python.org/3/library/xml.etree.elementtree.html).
  prefs: []
  type: TYPE_NORMAL
- en: To Learn more about the `zipfile` library, visit [https://docs.python.org/3/library/zipfile.html](https://docs.python.org/3/library/zipfile.html)[.](https://docs.python.org/3/library/xml.etree.elementtree.html)
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We extract embedded Office metadata by performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Confirm that the input file is a valid ZIP file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extract the `core.xml` and `app.xml` files from Office file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Parse XML data and print embedded metadata.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, we import the `argparse` and `datetime` libraries, followed by `xml.etree`
    and `zipfile` libraries. The `ElementTree` class allows us to read an XML string
    into an object that we can iterate through and interpret.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This recipe’s command-line handler takes one positional argument, `Office_File`,
    the path to the office file we will be extracting metadata from.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Following our argument handling, we check to make sure the input file is a `zipfile`
    and raise an error if it is not. If it is, we open the valid ZIP file using the
    `ZipFile` class before accessing the two XML documents containing the metadata
    we are interested in. Though there are other XML files containing data describing
    the document, the two with the most metadata are named `core.xml` and `app.xml`.
    We will open the two XML files from the ZIP container with the `read()` method
    and send the returned string directly to the `etree.fromstring()` XML parsing
    method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: With the prepared XML objects, we can start extracting data of interest. We
    set up a dictionary, called `core_mapping`, to specify the fields we want to extract,
    as key names, and the value we want to display them as. This method allows us
    to easily print only the values important to us, if present, with a friendly title.
    This XML file contains great information about the authorship of the file. For
    instance, the two authorship fields, `creator` and `lastModifiedBy`, can show
    scenarios where one account modified a document created by another user account.
    The date values show us information about creation and modification of the document.
    Additionally, metadata fields like `revision` can give some indication to the
    number of versions of this document.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: In our `for` loop, we iterate over the XML using the `iterchildren()` method
    to access each of the tags within the XML root of the `core.xml` file. Using the
    `core_mapping` dictionary, we can selectively output specific fields if they are
    found. We have also added logic to interpret date values using the `strptime()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The next set of column mappings focuses on the `app.xml` file. This file contains
    statistical information about the contents of the document, including total edit
    time and counts of words, pages, and slides. It also contains information about
    the company name registered with the software and hidden elements. To print these
    values to the console, we use a similar set of `for` loops as we did with the
    `core.xml` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: When we run the script with a sample word document, as the following shows,
    a number of details about the document are in question.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00040.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Separately, we can use the script on a PPTX document and review format-specific
    metadata associated with PPTX files:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00041.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Integrating our metadata extractor with EnCase
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Recipe Difficulty: Medium'
  prefs: []
  type: TYPE_NORMAL
- en: 'Python Version: 2.7 or 3.5'
  prefs: []
  type: TYPE_NORMAL
- en: 'Operating System: Windows'
  prefs: []
  type: TYPE_NORMAL
- en: The embedded metadata extracting recipes we have designed work against loose
    files, not with files found within a forensic image. Annoyingly, this adds an
    extra step in our process, requiring us to export the files of interest from the
    image for this type of review. We show in this recipe, how to connect our scripts
    to a forensic tool, EnCase, and execute them without needing to export the files
    from a forensic image.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With EnCase installed, we need to create a case and add in the evidence file,
    as we would for any other case. This recipe demonstrates the steps required to
    perform this in EnCase V6, although the same techniques can be applied to later
    versions.
  prefs: []
  type: TYPE_NORMAL
- en: Before starting, we will also need to ensure Python 2.7 or 3.5, the script we
    wish to use, and the required dependencies are installed on the machine.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We integrate the metadata recipes with EnCase via the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open EnCase V6 and add evidence to a case.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the View file viewer menu to configure a custom file viewer with the `EXIF`
    metadata extractor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extract embedded GPS coordinates from a photo within EnCase using the newly
    created file viewer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the open case, we can look at the hex of a photo of interest to confirm
    we can see the `EXIF` header within the file. Following this header are the raw
    values processed by the script. With a good candidate identified, let's look at
    how we can configure EnCase to run the script.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00042.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Under the View menu, we select the File Viewers option. This opens a tab listing
    the available viewers. The instance of EnCase we used does not have any viewers
    and so we must add any we wish to use first.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00043.gif)'
  prefs: []
  type: TYPE_IMG
- en: In this tab, right-click on the top-level `File Viewers` element and select
    New... to create our custom viewer.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00044.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: A new window, shown in the following screenshot, allows us to specify the parameters
    to execute the script. In this example, we are implementing the GPS extraction
    script, though we can add others in this same manner. The first line specifies
    the name of the viewer. We should name this something memorable as it will be
    the only description available to us when selecting the file viewer later. The
    second line is the path to the executable. In our instance, we will launch the
    Command Prompt, since our Python script is not a standalone executable. We need
    to provide the full path to `cmd.exe` for EnCase to accept this parameter.
  prefs: []
  type: TYPE_NORMAL
- en: The last line is where we add in the script. This line allows us to specify
    the arguments to pass to the Command Prompt. We start with `/k` to keep our Command
    Prompt open after our script completes. This isn't required; although if your
    code displays information to the console (as ours does), we should implement this
    feature. Otherwise, the Command Prompt will close as soon as the code completes.
    Following the `/k` argument, we provide the parameters to launch the code. As
    shown here, this includes the Python executable and full path to the script. The
    last element, `[file]`, is a placeholder for EnCase that is replaced by the file
    we want to view when the file viewer is executed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00045.gif)'
  prefs: []
  type: TYPE_IMG
- en: The new file viewer entry is now displayed within the `File Viewer` tab and
    shows us the name, executable, and arguments we specified. If everything looks
    right, we can return to the photo of interest in the file entry tab.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00046.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Back on the file entry view, we can right-click on the photo of interest and
    select the file viewer from the `Send To` submenu.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00047.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: When we select this option, the command window appears and shows the output
    from the script. Notice that the KML file is automatically placed in the `Temp`
    directory for the case. This is because the file we are inspecting is cached in
    this directory during the script's execution.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00048.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This process can be further improved. We have provided one or more recommendations
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: While not Python-related, look into EnScripting as another option to automate
    and parse multiple files and display the output within the EnCase Console tab.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add the other recipes covered in this chapter to EnCase by following a similar
    method. Since the information for these scripts is printed to the console, we
    should use the `/k` argument or rework the logic to place the output in a directory
    for us.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
