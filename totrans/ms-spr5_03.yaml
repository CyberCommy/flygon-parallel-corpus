- en: Building a Web Application with Spring MVC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring MVC is the most popular web framework used to develop Java web applications.
    The beauty of Spring MVC lies in its clean, loosely coupled architecture. With
    a clean definition of roles for controllers, handler mappings, view resolvers,
    and **Plain Old Java Object** (**POJO**) command beans, Spring MVC makes use of
    all the core Spring features--like dependency injection and autowiring--to make
    it simple to create web applications. With its support for multiple view technologies,
    it is extensible too.
  prefs: []
  type: TYPE_NORMAL
- en: While Spring MVC can be used to create REST services, we discuss that in [Chapter
    5](72e55d58-492f-404a-adbf-c3f86cf583c9.xhtml), *Building Microservices with Spring
    Boot*.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will focus on reviewing the basics of Spring MVC with simple
    examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The Spring MVC architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The roles played by DispatcherServlet, view resolvers, handler mappings and
    controllers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Model attributes and session attributes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Form binding and validation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integration with Bootstrap
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basics of Spring Security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing simple unit tests for controllers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java web application architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The way we develop Java web applications has evolved during the last couple
    of decades. We will discuss the different architectural approaches to developing
    Java web applications and see where Spring MVC fits in:'
  prefs: []
  type: TYPE_NORMAL
- en: Model 1 architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Model 2 or MVC architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Model 2 with Front Controller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Model 1 architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Model 1 architecture is one of the initial architecture styles used to develop
    Java-based web applications. A few important details are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: JSP pages directly handled the requests from the browser
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JSP pages made use of the model containing simple Java beans
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In some applications of this architecture style, JSPs even performed queries
    to the database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'JSPs also handled the flow logic: which page to show next'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following picture represents typical Model 1 architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a74fb9ad-d01d-4d70-93fa-f980215c48f1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'There are a lot of disadvantages in this approach, leading to quick shelving
    and the evolution of other architectures. A few important disadvantages are listed
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Hardly any separation of concerns**: JSPs were responsible for retrieving
    data, displaying data, deciding which pages to show next (flow), and sometimes,
    even business logic as well'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Complex JSPs**: Because JSPs handled a lot of logic, they were huge and difficult
    to maintain'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Model 2 architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Model 2 architecture came in to solve the complexity involved with complex
    JSPs having multiple responsibilities. This forms the base for the MVC architecture
    style. The following image represents typical Model 2 architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cfce1c1a-1aa9-400d-b641-4bc8a2f4c0a0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Model 2 architecture has a clear separation of roles between Model, View, and
    Controller. This leads to more maintainable applications. A few important details
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Model**: Represents the data to be used to generate a View.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**View**: Uses the Model to render the screen.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Controller**: Controls the flow. Gets the request from the browser, populates
    the Model and redirects to the View. Examples are **Servlet1** and **Servlet2**
    in the preceding figure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Model 2 Front Controller architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the basic version of Model 2 architecture, the requests from the browser
    are handled directly by different servlets (or Controllers). In a number of business
    scenarios, one would want to do a few common things in servlets before we handle
    the request. An example would be to ensure that the logged-in user has the right
    authorization to execute the request. This is a common functionality that you
    would not want to be implemented in every servlet.
  prefs: []
  type: TYPE_NORMAL
- en: In Model 2 **Front Controller** architecture, all requests flow into a single
    controller called the Front Controller.
  prefs: []
  type: TYPE_NORMAL
- en: 'Picture below represents typical Model 2 Front Controller architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8afb2351-2192-4dac-8589-b197a1ff401b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following are some of the responsibilities of a typical Front Controller:'
  prefs: []
  type: TYPE_NORMAL
- en: It decides which Controller executes the request
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It decides which View to render
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It provides provisions to add more common functionality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring MVC uses an MVC pattern with Front Controller. The Front Controller is
    called **DispatcherServlet**. We will discuss DispatcherServlet a little later.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic flows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spring MVC uses a modified version of the Model 2 Front Controller architecture.
    Before we go into details about how Spring MVC works, we will focus on creating
    a few simple web flows using Spring MVC. In this section, we will create six typical
    web application flows using Spring MVC. The flows are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Flow 1**: Controller without a View; serving content on its own'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flow 2**: Controller with a View (a JSP)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flow 3**: Controller with a View and using ModelMap'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flow 4**: Controller with a View and using ModelAndView'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flow 5**: Controller for a simple form'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flow 6**: Controller for a simple form with validation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the end of every flow, we will discuss how to unit test the Controller.
  prefs: []
  type: TYPE_NORMAL
- en: Basic setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we start with the first flow, we would need to get the application set
    up to use Spring MVC. In the next section, we will start by understanding how
    to set up Spring MVC in a web application.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are using Maven to manage our dependencies. The following steps are involved
    in setting up a simple web application:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a dependency for Spring MVC.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add DispatcherServlet to `web.xml`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a Spring application context.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adding dependency for Spring MVC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start with adding the Spring MVC dependency to our `pom.xml`. The following
    code shows the dependency to be added in. Since we are using Spring BOM, we do
    not need to specify the artifact version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: DispatcherServlet is an implementation of the Front Controller pattern. Any
    request to Spring MVC will be handled by the Front Controller, that is, DispatcherServlet.
  prefs: []
  type: TYPE_NORMAL
- en: Adding DispatcherServlet to web.xml
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To enable this, we would need to add DispatcherServlet to `web.xml`. Let''s
    look at how to do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The first part is to define a servlet. We are also defining a context configuration
    location, `/WEB-INF/user-web-context.xml`. We will define a Spring context in
    the next step. In the second part, we are defining a servlet mapping. We are mapping
    a URL `/` to the DispatcherServlet. So, all requests will be handled by the DispatcherServlet.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Spring context
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have DispatcherServlet defined in `web.xml`, we can go ahead and
    create our Spring context. Initially, we will create a very simple context without
    really defining anything concrete:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We are defining a component scan for the `com.mastering.spring.springmvc` package
    so that all the beans and controllers in this package are created and auto-wired.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using `<mvc:annotation-driven/>` initializes support for a number of features
    that Spring MVC supports such as:'
  prefs: []
  type: TYPE_NORMAL
- en: Request mapping
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exception handling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data binding and validation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automatic conversion (for example, JSON) when the `@RequestBody` annotation
    is used
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That's all the setup we need to be able to set up a Spring MVC application.
    We are ready to get started with the first flow.
  prefs: []
  type: TYPE_NORMAL
- en: Flow 1 - Simple controller flow without View
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start with a simple flow by showing some simple text that is output from
    a Spring MVC controller on screen.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Spring MVC controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create a simple Spring MVC controller as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'A few important things to note here are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@Controller`: This defines a Spring MVC controller that can contain request
    mappings--mapping URLs to controller methods.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@RequestMapping(value = "/welcome")`: This defines a mapping of the URL `/welcome`
    to the `welcome` method. When the browser sends a request to `/welcome`, Spring
    MVC does the magic and executes the `welcome` method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@ResponseBody`: In this specific context, the text returned by the `welcome`
    method is sent out to the browser as the response content. `@ResponseBody` does
    a lot of magic--especially in the context of REST services. We will discuss this
    in [Chapter 5](72e55d58-492f-404a-adbf-c3f86cf583c9.xhtml), *Building Microservices
    with Spring Boot*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running the web application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are using Maven and Tomcat 7 to run this web application.
  prefs: []
  type: TYPE_NORMAL
- en: Tomcat 7 server launches up on port 8080 by default.
  prefs: []
  type: TYPE_NORMAL
- en: We can run the server by invoking the `mvn tomcat7:run` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a screenshot of how this would look on the screen when the `http://localhost:8080/welcome`
    URL is hit on the browser as in following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fa4a0b7a-e415-4331-a0e3-707430ee9550.png)'
  prefs: []
  type: TYPE_IMG
- en: Unit testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Unit testing is a very important part of developing maintainable applications.
    We will be using the Spring MVC Mock framework to unit test the Controllers that
    we will write in this chapter. We will add in a dependency on the Spring test
    framework to use the Spring MVC Mock framework:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The approach we will be taking would involve the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the Controller to test.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Writing the test method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Setting up the Controller to test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The controller we want to test is `BasicController`. The convention to create
    a unit test is a class name with a suffix `Test`. We will create a test class
    named `BasicControllerTest`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic setup is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'A few important things to note are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mockMvc`: This variable can be used across different tests. So, we define
    an instance variable of the `MockMvc` class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Before setup`: This method is run before every test in order to initialize
    `MockMvc`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MockMvcBuilders.standaloneSetup(new BasicController()).build()`: This line
    of code builds a `MockMvc` instance. It initializes DispatcherServlet to serve
    requests to the configured controller(s), `BasicController` in this instance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing the Test method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The complete `Test` method is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'A few important things to note are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`MockMvc` `mockMvc.perform`: This method executes the request and returns an
    instance of ResultActions that allows chaining calls. In this example, we are
    chaining the andExpect calls to check expectations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`get("/welcome").accept(MediaType.parseMediaType("application/html;charset=UTF-8"))`:
    This creates an HTTP get request accepting a response with the media type `application/html`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`andExpect`: This method is used to check expectations. This method will fail
    the test if the expectation is not met.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`status().isOk()`: This uses ResultMatcher to check whether the response status
    is that of a successful request - 200.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`content().contentType("application/html;charset=UTF-8"))`: This uses ResultMatcher
    to check whether the content type of the response is as specified.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`content().string("Welcome to Spring MVC")`: This uses ResultMatcher to check
    whether the response content contains the specified string.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flow 2 - Simple controller flow with a View
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous flow, the text to show on the browser was hardcoded in the Controller.
    That is not a good practice. The content to be shown on the browser is typically
    generated from a View. The most frequently used option is a JSP.
  prefs: []
  type: TYPE_NORMAL
- en: In this flow, let's redirect from the Controller to a View.
  prefs: []
  type: TYPE_NORMAL
- en: Spring MVC controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Similar to the previous example, let''s create a simple Controller. Consider
    the example of a controller here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'A few important things to note are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@RequestMapping(value = "/welcome-view")`: We are mapping an URL `/welcome-view`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public String welcome()`: There is no `@RequestBody` annotation on this method.
    So, Spring MVC tries to match the string that is returned, `welcome`, to a view.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a View - a JSP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create `welcome.jsp` in the `src/main/webapp/WEB-INF/views/welcome.jsp`
    folder with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This is a simple HTML with head, body, and some text in the body.
  prefs: []
  type: TYPE_NORMAL
- en: Spring MVC has to map the string returned from the `welcome` method to the real
    JSP at `/WEB-INF/views/welcome.jsp`. How does this magic happen?
  prefs: []
  type: TYPE_NORMAL
- en: View resolver
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A view resolver resolves a View name to the actual JSP page.
  prefs: []
  type: TYPE_NORMAL
- en: The View name in this example is `welcome`, and we would want it to resolve
    to `/WEB-INF/views/welcome.jsp`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A view resolver can be configured in the spring context `/WEB-INF/user-web-context.xml`.
    Here''s the code snippet for that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'A few important points to note:'
  prefs: []
  type: TYPE_NORMAL
- en: '`org.springframework.web.servlet.view.InternalResourceViewResolver`: A view
    resolver supporting JSPs. `JstlView` is typically used. It also supports tiles
    with a TilesView.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<property name="prefix"> <value>/WEB-INF/views/</value> </property><property
    name="suffix"> <value>.jsp</value> </property>`: This maps the prefix and suffix
    to be used by view resolver. View resolver takes the string from the controller
    method and resolves to the view: `prefix` + viewname + `suffix`. So, the view
    name welcome is resolved to `/WEB-INF/views/welcome.jsp`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is a screenshot of how this would look on the screen when the URL is hit:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5b609f94-2dc2-4d2f-9c2e-30483d38677e.png)'
  prefs: []
  type: TYPE_IMG
- en: Unit testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A standalone setup of MockMvc Framework creates the bare minimum infrastructure
    required by DispatcherServlet. If provided with a view resolver, it can execute
    view resolution. However, it would not execute the view. So, during a unit test
    with the standalone setup, we cannot verify the content of the view. However,
    we can check whether the correct view is being delivered.
  prefs: []
  type: TYPE_NORMAL
- en: In this unit test, we want to set up `BasicViewController`, execute a get request
    to `/welcome-view`, and check whether the view name returned is `welcome`. In
    a future section, we will discuss how to execute the integration test, including
    the rendering of view. As far as this test is concerned, we restrict our purview
    to verifying the view name.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the Controller to test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This step is very similar to the previous flow. We want to test `BasicViewController`.
    We instantiate MockMvc using `BasicViewController`. We also configure a simple
    view resolver:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Writing the Test method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The complete test method is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'A few important things to note are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`get("/welcome-model-view")`: This executes the get request to the specified
    URL'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`view().name("welcome")`: This uses Result Matcher to check whether the view
    name returned is as specified'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flow 3 - Controller redirecting to a View with Model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Typically, in order to generate the view, we would need to pass some data to
    it. In Spring MVC, data can be passed to the view using a model. In this flow,
    we would set up a model with a simple attribute and use the attribute in the view.
  prefs: []
  type: TYPE_NORMAL
- en: Spring MVC controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create a simple Controller. Consider the following example controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'A few important things to note are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@RequestMapping(value = "/welcome-model-map")`: The URI mapped is `/welcome-model-map`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public String welcome(ModelMap model)`: The new parameter added is `ModelMap
    model`. Spring MVC will instantiate a model and make it available for this method.
    The attributes put into the model will be available for use in the view.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`model.put("name", "XYZ")`: This adds an attribute with the `name` name and
    `XYZ` value to the model.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a View
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create a view using the model attribute `name` that was set in the model
    in the controller. Let''s create a simple JSP in the `WEB-INF/views/welcome-model-map.jsp`
    path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'One thing to note is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`${name}`: This uses the **Expression Language** (**EL**) syntax to access
    the attribute from the model.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is a screenshot of how this would look on the screen when the URL is hit:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c46d8dab-18e6-4964-9122-95ecebdee805.png)'
  prefs: []
  type: TYPE_IMG
- en: Unit testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this unit test, we want to set up `BasicModelMapController`, execute a get
    request to `/welcome-model-map`, and check whether the model has the expected
    attribute and whether the expected view name is returned.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the Controller to test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This step is very similar to the previous flow. We instantiate Mock MVC with
    `BasicModelMapController`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Writing the Test method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The complete Test method is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'A few important things to note:'
  prefs: []
  type: TYPE_NORMAL
- en: '`get("/welcome-model-map")`: Execute `get` request to the specified URL'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`model().attribute("name", "XYZ")`: Result Matcher to check if the model contains
    specified attribute **name** with specified value **XYZ**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`view().name("welcome-model-map")`: Result Matcher to check if the view name
    returned is as specified'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flow 4 - Controller redirecting to a View with ModelAndView
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous flow, we returned a view name and populated the model with attributes
    to be used in the view. Spring MVC provides an alternate approach using `ModelAndView`.
    The controller method can return a `ModelAndView` object with the view name and
    appropriate attributes in the Model. In this flow, we will explore this alternate
    approach.
  prefs: []
  type: TYPE_NORMAL
- en: Spring MVC controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Take a look at the following controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'A few important things to note are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@RequestMapping(value = "/welcome-model-view")`: The URI mapped is `/welcome-model-view`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public ModelAndView welcome(ModelMap model)`: Note that the return value is
    no longer a String. It is `ModelAndView`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`return new ModelAndView("welcome-model-view", model)`: Create a `ModelAndView`
    object with the appropriate view name and model.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a View
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create a view using the model attribute `name` that was set in the model
    in the controller. Create a simple JSP in the `/WEB-INF/views/welcome-model-view.jsp`
    path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a screenshot of how this would look on the screen when the URL is hit:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9f4dccc1-4ac3-4fa6-9f46-c2bc20e0c77c.png)'
  prefs: []
  type: TYPE_IMG
- en: Unit testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unit testing for this flow is similar to the previous flow. We would need to
    check if the expected view name is returned.
  prefs: []
  type: TYPE_NORMAL
- en: Flow 5 - Controller redirecting to a View with a form
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now let's shift our attention to creating a simple form to capture input from
    the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps will be needed:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a simple POJO. We want to create a user. We will create a POJO User.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a couple of Controller methods--one to display the form, and the other
    to capture the details entered in the form.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a simple View with the form.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a command or form backing object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: POJO stands for Plain Old Java Object. It is usually used to represent a bean
    following the typical JavaBean conventions. Typically, it contains private member
    variables with getters and setters and a no-argument constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create a simple POJO to act as a command object. Important parts of
    the class are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'A few important things to note are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: This class does not have any annotations or Spring-related mappings. Any bean
    can act as a form-backing object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are going to capture the `name`, `user ID`, and `password` in the form. We
    have a password confirmation field, `password2`, and unique identifier field guid.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Constructor`, `getters`, `setters`, and `toString` methods are not shown for
    brevity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Controller method to show the form
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start with creating a simple controller with a logger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s add the following method to the controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Important things to note are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@RequestMapping(value = "/create-user", method = RequestMethod.GET)`: We are
    mapping a `/create-user` URI. For the first time, we are specifying a `Request`
    method using the method attribute. This method will be invoked only for HTTP Get
    Requests. HTTP `Get` Requests are typically used to show the form. This will not
    be invoked for other types of HTTP requests, such as Post.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public String showCreateUserPage(ModelMap model)`: This is a typical control
    method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`model.addAttribute("user", new User())`: This is used to set up the model
    with an empty form backing object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the View with a form
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Java Server Pages is one of the view technologies supported by Spring Framework.
    Spring Framework makes it easy to create views with JSPs by providing a tag library.
    This includes tags for various form elements, binding, validation, setting themes
    and internationalizing messages. We will use the tags from the Spring MVC tag
    library as well as standard JSTL tag libraries to create our view in this example.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with creating the `/WEB-INF/views/user.jsp` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s add the reference to the tag libraries to be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The first two entries are for JSTL core and formatting tag libraries. We will
    use the Spring form tags extensively. We provide a `prefix` to act as a shortcut
    to refer to tags.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a form with one field first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Important things to note are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<form:form method="post" modelAttribute="user">`: This is the `form` tag from
    the Spring form tag library. Two attributes are specified. Data in the form is
    sent using the post method. The second attribute, `modelAttribute`, specifies
    the attribute from the model that acts as the form backing object. In the model,
    we added an attribute with the name user. We use that attribute as `modelAttribute`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<fieldset>`: This is the HTML element to group a set of related controls--labels,
    form fields, and validation messages**.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<form:label path="name">Name</form:label>`: This is the Spring form tag to
    show a label. The path attribute specifies the field name (from bean) this label
    is applied to.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<form:input path="name" type="text" required="required" />`: This is the Spring
    form tag to create a text input field. The `path` attribute specifies the field
    name in the bean that this input field has to be mapped to. The required attribute
    indicates that this is a `required` field.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we use the Spring form tags, the values from the form backing object (`modelAttribute="user"`)
    are bound automatically to the form, and on submitting the form, the values from
    the form are automatically bound to the form backing object.
  prefs: []
  type: TYPE_NORMAL
- en: 'A more complete list of the form tags including the name and user ID fields
    are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Controller get method to handle form submit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When the user submits the form, the browser sends an HTTP **POST** request.
    Now let''s create a method to handle this. To keep things simple, we will log
    the content of the form object. The complete listing of the method is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'A few important details are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@RequestMapping(value = "/create-user", method = RequestMethod.POST)`: Since
    we want to handle the form submit, we use the `RequestMethod.POST` method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public String addTodo(User user)`: We are using the form backing object as
    the parameter. Spring MVC will automatically bind the values from the form to
    the form backing object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`logger.info("user details " + user)`: Log the details of the user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'return `redirect:list-users`: Typically, on submitting a form, we save the
    details of a database and redirect the user to a different page. Here, we are
    redirecting the user to `/list-users`. When we use `redirect`, Spring MVC sends
    an HTTP Response with status `302`; that is, `REDIRECT` to the new URL. The browser,
    on processing the `302` response, will redirect the user to the new URL. While
    the `POST`/`REDIRECT`/`GET` pattern is not a perfect fix for the duplicate form
    submission problem, it does reduce the occurrences, especially those that occur
    after the view is rendered.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code for list users is pretty straightforward and is listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Unit testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will discuss unit testing when we add validations in the next flow.
  prefs: []
  type: TYPE_NORMAL
- en: Flow 6 - Adding validation to the previous flow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous flow, we added a form. However, we did not validate the values
    in the form. While we can write JavaScript to validate the form content, it is
    always secure to do validation on the server. In this flow, let's add validation
    to the form that we created earlier on the server side using Spring MVC.
  prefs: []
  type: TYPE_NORMAL
- en: Spring MVC provides great integration with the Bean Validation API. *JSR 303*
    and *JSR 349* define specifications for the the Bean Validation API (version 1.0
    and 1.1, respectively), and Hibernate Validator is the reference implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Hibernate Validator dependency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start with adding Hibernate Validator to our project `pom.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Simple validations on the bean
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Bean Validation API specifies a number of validations that can be specified
    on attributes on the beans. Take a look at the following listing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'An important thing to note are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@Size(min = 6, message = "Enter at least 6 characters")` : This specifies
    that the field should at least have six characters. If the validation does not
    pass, the text from the message attribute is used as a validation error message.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Other validations that can be performed using Bean Validation are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@NotNull`: It should not be null'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Size(min =5, max = 50)`: Maximum size of 50 characters and minimum of 5 characters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Past`: Should be a date in the past'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Future`: Should be a future date'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Pattern`: Should match the provided regular expression'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Max`: Maximum value for the field'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Min`: Minimum value for the field'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now let''s focus on getting the controller method to validate the form on submits.
    The complete method listing is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Some important things are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`public String addTodo(@Valid User user, BindingResult result)`: When the `@Valid`
    annotation is used, Spring MVC validates the bean. The result of the validation
    is made available in the `BindingResult` instance result.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`if (result.hasErrors())`: Checks whether there are any validation errors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`return "user"`: If there are validation errors, we send the user back to the
    user page.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We need to enhance the `user.jsp` to show the validation messages in case of
    validation errors. The complete list for one of the fields is shown here. Other
    fields have to be similarly updated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '`<form:errors path="name" cssClass="text-warning"/>`: This is the Spring form
    tag to display the errors related to the field name specified in the path. We
    can also assign the CSS class used to display the validation error.'
  prefs: []
  type: TYPE_NORMAL
- en: Custom validations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'More complex custom validations can be implemented using the `@AssertTrue`
    annotation. The following list an example method added to the `User` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '`@AssertTrue(message = "Password fields don''t match")` is the message to be
    shown if the validation fails.'
  prefs: []
  type: TYPE_NORMAL
- en: Any complex validation logic with multiple fields can be implemented in these
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unit testing for this part is focused on checking for validation errors. We
    will write a test for an empty form, which triggers four validation errors.
  prefs: []
  type: TYPE_NORMAL
- en: Controller setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The controller setup is very simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The Test method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The complete `Test` method is listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Some points to note here are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`post("/create-user-with-validation")`: Creates an HTTP `POST` request to the
    specified URI. Since we are not passing any request parameters, all attributes
    are null. This will trigger validation errors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`model().errorCount(4)`: Checks whether there are four validation errors on
    the model.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`model().attributeHasFieldErrorCode("user", "name", "Size")`: Checks whether
    the `user` attribute has a field `name` with the validation error named `Size`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An overview of Spring MVC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we've looked at a few basic flows with Spring MVC, we will switch our
    attention to understanding how these flows work. How does the magic happen with
    Spring MVC?
  prefs: []
  type: TYPE_NORMAL
- en: Important features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When working with the different flows, we looked at some of the important features
    of the Spring MVC Framework. These include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Loosely coupled architecture with well-defined, independent roles for each of
    the objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Highly flexible Controller method definitions. Controller methods can have a
    varied range of parameters and return values. This gives flexibility to the programmer
    to choose the definition that meets their needs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allows the reuse of domain objects as form backing objects. Reduces the need
    to have separate form objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Built-in tag libraries (Spring, spring-form) with localization support.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Model uses a HashMap with key-value pairs. Allows integration with multiple
    view technologies.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flexible binding. Type mismatches while binding can be handled as validation
    errors instead of runtime errors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mock MVC Framework to unit test controllers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How it works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Key components in the Spring MVC architecture are shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e7d21789-55e6-4613-802e-632509dc37b3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s look at an example flow and understand the different steps involved
    in executing the flow. We will take flow **4**, returning `ModelAndView` as the
    specific example. The URL of flow **4** is `http://localhost:8080/welcome-model-view`.
    The different steps are detailed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The browser issues a request to a specific URL. DispatcherServlet is the Front
    Controller, handling all requests. So, it receives the request.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Dispatcher Servlet looks at the URI (in the example, `/welcome-model-view`)
    and needs to identify the right controller to handle it. To help find the right
    controller, it talks to the handler mapping.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Handler mapping returns the specific handler method (in the example, the `welcome`
    method in `BasicModelViewController`) that handles the request.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: DispatcherServlet invokes the specific handler method (`public ModelAndView
    welcome(ModelMap model)`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The handler method returns the model and view. In this example, the ModelAndView
    object is returned.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: DispatcherServlet has the logical view name (from ModelAndView; in this example,
    `welcome-model-view`). It needs to figure out how to determine the physical view
    name. It checks whether there are any view resolvers available. It finds the view
    resolver that was configured (`org.springframework.web.servlet.view.InternalResourceViewResolver`).
    It calls the view resolver, giving it the logical view name (in this example,
    `welcome-model-view`) as the input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: View resolver executes the logic to map the logical view name to the physical
    view name. In this example, `welcome-model-view` is translated to `/WEB-INF/views/welcome-model-view.jsp`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: DispatcherServlet executes the View. It also makes the Model available to the
    View.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: View returns the content to be sent back to DispatcherServlet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: DispatcherServlet sends the response back to the browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Important concepts behind Spring MVC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have completed an example with Spring MVC, we are ready to understand
    the important concepts behind Spring MVC.
  prefs: []
  type: TYPE_NORMAL
- en: RequestMapping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we've discussed in earlier examples, a `RequestMapping` is used to map a
    URI to a Controller or a Controller method. It can be done at class and/or method
    levels. An optional method parameter allows us to map the method to a specific
    request method (`GET`, `POST`, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: Examples of request mapping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A few examples in the upcoming sections illustrate the variations.
  prefs: []
  type: TYPE_NORMAL
- en: Example 1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the following example, there is only one `RequestMapping` in the `showPage`
    method. The `showPage` method will be mapped to `GET`, `POST`, and any other request
    types for URI `/show-page`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Example 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the following example, there is a method defined on `RequestMapping`--`RequestMethod.GET`.
    The `showPage` method will be mapped only to the `GET` request for URI `/show-page`.
    All other request method types would throw "method not supported exception":'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Example 3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the following example, there are two `RequestMapping` methods--one in the
    class and the other in the method. A combination of both `RequestMapping` methods
    is used to determine the URI. The `showPage` method will be mapped only to the
    `GET` request for the URI `/user/show-page`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Request Mapping methods - supported method arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are some of the types of arguments that are supported in Controller
    methods with Request Mapping:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Argument Type/Annotatio**n | **Use** |'
  prefs: []
  type: TYPE_TB
- en: '| `java.util.Map` / `org.springframework.ui.Model` / `org.springframework.ui.ModelMap`
    | Acts as the model (MVC) that will be the container for values that are exposed
    to the view. |'
  prefs: []
  type: TYPE_TB
- en: '| Command or form objects | Used to bind request parameters to beans. Support
    for validation as well. |'
  prefs: []
  type: TYPE_TB
- en: '| `org.springframework.validation.Errors` / `org.springframework.validation.BindingResult`
    | Result of validating the command or form object (the form object should be the
    immediately preceding method argument). |'
  prefs: []
  type: TYPE_TB
- en: '| `@PreDestroy` | On any spring bean, a pre-destroy method can be provided
    using the `@PreDestroy` annotation. This method is called just before a bean is
    removed from the container. It can be used to release any resources that are held
    by the bean. |'
  prefs: []
  type: TYPE_TB
- en: '| `@RequestParam` | The annotation to access specific HTTP request parameters.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `@RequestHeader` | The annotation to access specific HTTP request headers.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `@SessionAttribute` | The annotation to access attributes from HTTP Session.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `@RequestAttribute` | The annotation to access specific HTTP request attributes.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `@PathVariable` | The annotation allows access to variables from the URI
    template. `/owner/{ownerId}`. We will look at this in depth when we discuss microservices.
    |'
  prefs: []
  type: TYPE_TB
- en: RequestMapping methods - supported return types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `RequestMapping` methods support a varied range of return types. Thinking
    conceptually, a request mapping method should answer two questions:'
  prefs: []
  type: TYPE_NORMAL
- en: What's the view?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What's the model that the view needs?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'However, with Spring MVC, the view and model need not be explicitly declared
    at all times:'
  prefs: []
  type: TYPE_NORMAL
- en: If a view is not explicitly defined as part of the return type, then it is implicitly
    defined.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Similarly, any model object is always enriched as detailed in the rules below.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Spring MVC uses simple rules to determine the exact view and model. A couple
    of important rules are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Implicit enriching of the Model**: If a model is part of the return type,
    it is enriched with command objects (including results from validation of the
    command objects). In addition, the results of methods with the `@ModelAttribute`
    annotations are also added to the model.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Implicit determination of the View**: If a view name is not present in the
    return type, it is determined using `DefaultRequestToViewNameTranslator`. By default,
    `DefaultRequestToViewNameTranslator` removes the leading and trailing slashes
    as well as the file extension from the URI; for example, the `display.html` becomes
    display.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following are some of the return types that are supported on Controller
    methods with Request Mapping:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Return Type** | **What happens?** |'
  prefs: []
  type: TYPE_TB
- en: '| ModelAndView | The object includes a reference to the model and the view
    name. |'
  prefs: []
  type: TYPE_TB
- en: '| Model | Only Model is returned. The view name is determined using `DefaultRequestToViewNameTranslator`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Map | A simple map to expose a model. |'
  prefs: []
  type: TYPE_TB
- en: '| View | A view with a model implicitly defined. |'
  prefs: []
  type: TYPE_TB
- en: '| String | Reference to a view name. |'
  prefs: []
  type: TYPE_TB
- en: View resolution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spring MVC provides very flexible view resolution. It provides multiple view
    options:'
  prefs: []
  type: TYPE_NORMAL
- en: Integration with JSP, Freemarker.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Multiple view resolution strategies. A few of them are listed as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`XmlViewResolver`: View resolution based on an external XML configuration'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ResourceBundleViewResolver`: View resolution based on a property file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UrlBasedViewResolver`: Direct mapping of the logical view name to a URL'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ContentNegotiatingViewResolver`: Delegates to other view resolvers based on
    the Accept request header'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support for chaining of view resolvers with the explicitly defined order of
    preference.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Direct generation of XML, JSON, and Atom using Content Negotiation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring JSP view resolver
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following example shows the commonly used approach to configure a JSP view
    resolver using `InternalResourceViewResolver`. The physical view name is determined
    using the configured prefix and suffix for the logical view name using `JstlView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: There are other approaches using property and XML files for mapping.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Freemarker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following example shows the typical approach used to configure a Freemarker
    view resolver.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, the `freemarkerConfig` bean is used to load the Freemarker templates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The following bean definition shows how to configure a Freemarker view resolver:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: As with JSPs, the view resolution can be defined using properties or an XML
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Handler mappings and Interceptors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the version before Spring 2.5 (before there was support for Annotations),
    the mapping between a URL and a Controller (also called a handler) was expressed
    using something called a handler mapping. It is almost a historical fact today.
    The use of annotations eliminated the need for an explicit handler mapping.
  prefs: []
  type: TYPE_NORMAL
- en: HandlerInterceptors can be used to intercept requests to handlers (or **controllers**).
    Sometimes, you would want to do some processing before and after a request. You
    might want to log the content of the request and response, or you might want to
    find out how much time a specific request took.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two steps in creating a HandlerInterceptor:'
  prefs: []
  type: TYPE_NORMAL
- en: Define the HandlerInterceptor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Map the HandlerInterceptor to the specific handlers to be intercepted.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Defining a HandlerInterceptor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are the methods you can override in `HandlerInterceptorAdapter`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`public boolean preHandle(HttpServletRequest request, HttpServletResponse response,
    Object handler)`: Invoked before the handler method is invoked'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public void postHandle(HttpServletRequest request, HttpServletResponse response,
    Object handler, ModelAndView modelAndView)`: Invoked after the handler method
    is invoked'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public void afterCompletion(HttpServletRequest request, HttpServletResponse
    response, Object handler, Exception ex)`: Invoked after the request processing
    is complete'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following example implementation shows how to create a HandlerInterceptor.
    Let''s start with creating a new class that extends `HandlerInterceptorAdapter`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The `preHandle` method is invoked before the handler is called. Let''s place
    an attribute on the request, indicating the start time of handler invocation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The `postHandle` method is invoked after the handler is called. Let''s place
    an attribute on the request, indicating the end time of the handler invocation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The `afterCompletion` method is invoked after the request processing is complete.
    We will identify the time spent in the handler using the attributes that we set
    into the request earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Mapping HandlerInterceptor to handlers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'HandlerInterceptors can be mapped to specific URLs you would want to intercept.
    The following example shows an example XML context configuration. By default,
    the interceptor will intercept all handlers (**controllers**):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'We can configure precise URIs to be intercepted. In the following example,
    all handlers except those with URI mapping starting with `/secure/`are intercepted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Model attributes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Common web forms contain a number of drop-down values--the list of states, the
    list of countries, and so on. These lists of values need to be available in the
    model so that the view can display the list. Such common things are typically
    populated into the model using methods that are marked with `@ModelAttribute`
    annotations.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two variations possible. In the following example, the method returns
    the object that needs to be put into the model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The approach in this example is used to add multiple attributes to the model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: An important thing to note is that there is no limitation to the number of methods
    that can be marked with the `@ModelAttribute` annotation.
  prefs: []
  type: TYPE_NORMAL
- en: Model attributes can be made common across multiple controllers using Controller
    Advice. We will discuss Controller Advice later in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Session attributes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the attributes and values that we discussed until now are used within a
    single request. However, there might be values such as a specific web user configuration
    that might not change across requests. These kinds of values will typically be
    stored in an HTTP session. Spring MVC provides a simple type level (class level)
    annotation `@SessionAttributes` to specify the attributes that would be stored
    in the session.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Putting an attribute in the session
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once we define an attribute in the `@SessionAttributes` annotation, it is automatically
    added to the session if the same attribute is added to the model.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding example, if we put an attribute with the name `exampleSessionAttribute`
    into the model, it would be automatically stored into the session conversation
    state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Reading an attribute from the session
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This value can be accessed in other controllers by first specifying the `@SessionAttributes`
    annotation at a type level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The value of the session attribute will be directly made available to all model
    objects. So, it can be accessed from the model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Removing an attribute from the session
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is important to remove values from the session when they are no longer needed.
    There are two ways in which we can remove values from the session conversational
    state. The first way is demonstrated in the following snippet. It uses the `removeAttribute`
    method available in the `WebRequest` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'This example shows the second approach using the `cleanUpAttribute` method
    in `SessionAttributeStore`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: InitBinders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Typical web forms have dates, currencies, and amounts. The values in the forms
    need to be bound to the form backing objects. Customization of how binding happens
    can be introduced using the `@InitBinder` annotation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Customization can be done in a specific controller or a set of controllers
    using Handler Advice. This example shows how to set the default date format to
    use for form binding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The @ControllerAdvice annotation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some of the functionality we defined at the controller level can be common across
    the application. For example, we might want to use the same date format across
    the application. So, `@InitBinder` that we defined earlier can be applicable across
    the application. How do we achieve that? `@ControllerAdvice` helps us make the
    functionality common across all Request Mappings by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider the Controller advice example listed here. We use a `@ControllerAdvice`
    annotation on the class and define the method with `@InitBinder` in this class.
    By default, the binding defined in this method is applicable to all request mappings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Controller advice can also be used to define common model attributes (`@ModelAttribute`)
    and common exception handling (`@ExceptionHandler`). All you would need to do
    is create methods marked with appropriate annotations. We will discuss exception
    handling in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Spring MVC - advanced features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will discuss about advanced features related to Spring
    MVC, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: How do we implement generic exception handling for the web application?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do we internationalize messages?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do we write integration tests?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do we expose static content and integrate with frontend frameworks like
    Bootstrap?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do we secure our web application with Spring Security?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exception handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Exception handling is one of the critical parts of any application. It is very
    important to have a consistent exception handling strategy across the application.
    One of the popular misconceptions is that only bad applications need exception
    handling. Nothing can be further from the truth. Even well-designed, well-written
    applications need good exception handling.
  prefs: []
  type: TYPE_NORMAL
- en: Before the emergence of the Spring Framework, exception handling code was needed
    across application code due to the wide use of checked exceptions. For example,
    most of the JDBC methods threw checked exceptions, requiring a try catch to handle
    the exception in every method (unless you would want to declare that the method
    throws a JDBC exception). With Spring Framework, most of the exceptions were made
    unchecked exceptions. This made sure that, unless specific exception handling
    was needed, exception handling could be handled generically across the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will look at couple of example implementations of exception
    handling as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Common exception handling across all controllers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specific exception handling for a Controller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common exception handling across controllers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Controller advice can also be used to implement common exception handling across
    controllers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Some things to note are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@ControllerAdvice`: Controller Advice, by default, is applicable to all controllers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@ExceptionHandler(value = Exception.class)`: Any method with this annotation
    will be called when an exception of the type or the sub-type of the class specified(`Exception.class`)
    is thrown in the controllers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public ModelAndView handleException (HttpServletRequest request, Exception
    ex)`: The exception that is thrown is injected into the Exception variable. The
    method is declared with a ModelAndView return type to be able to return a model
    with the exception details and an exception view.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mav.addObject("exception", ex)`: Adding the exception to the model so that
    the exception details can be shown in the view.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mav.setViewName("common/spring-mvc-error")`: The exception view.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The error view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Whenever an exception happens, `ExceptionController` redirects the user to
    the `ExceptionController` spring-mvc-error view after populating the model with
    exception details. The following snippet shows the complete jsp `/WEB-INF/views/common/spring-mvc-error.jsp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Important things to note are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`URL: ${url}`: Shows the URL from the model.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Exception: ${exception.message}`: Displays the exception message. The exception
    is populated into the model from `ExceptionController`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`forEach around ${exceptionStackTrace}`: Displays the stack trace from exception
    handling specific to `ExceptionController`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specific exception handling in a Controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In some situations, there is a need for specific exception handling in a Controller.
    This situation can easily be handled by implementing a method annotated with `@ExceptionHandler(value
    = Exception.class)`.
  prefs: []
  type: TYPE_NORMAL
- en: In case specific exception handling is needed only for a specific exception,
    the specific exception class can be provided as the value for the value attribute
    of the annotation.
  prefs: []
  type: TYPE_NORMAL
- en: Internationalization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we develop applications, we would want them to be usable in multiple locales.
    You would want the text that is shown to the user to be customized based on the
    location and language of the user. This is called **internationalization**. Internationalization,
    `i18n`, is also called **Localization**.
  prefs: []
  type: TYPE_NORMAL
- en: 'It can be implemented using two approaches:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SessionLocaleResolver`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CookieLocaleResolver`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the case of `SessionLocaleResolver`, the locale chosen by the user is stored
    in the user session and, therefore, is valid for the user session only. However,
    in the case of a `CookieLocaleResolver`, the locale chosen is stored as a cookie.
  prefs: []
  type: TYPE_NORMAL
- en: Message bundle setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, let''s set up a message bundler. The code snippet from the spring context
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Important points to note are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`class="org.springframework.context.support.ReloadableResourceBundleMessageSource"`:
    We are configuring a reloadable resource bundle. Support reloading properties
    through the cacheSeconds setting.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<property name="basename" value="classpath:messages" />`: Configure the loading
    of properties from the `messages.properties` and `messages_{locale}.properties
    file`. We will discuss the locale soon.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s configure a couple of property files and make them available in the
    `src/main/resources folder`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'We can display the message from the message bundle in a view using the `spring:message`
    tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Configuring a SessionLocaleResolver
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two parts to configuring a `SessionLocaleResolver`. The first one
    is to configure a `localeResolver`. The second one is to configure an interceptor
    to handle the change in locale:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Important things to note are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<property name="defaultLocale" value="en" />`: By default, `en` locale is
    used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<mvc:interceptors>`: `LocaleChangeInterceptor` is configured as a HandlerInterceptor.
    It would intercept all the handler requests and check for the locale.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<property name="paramName" value="language" />`: `LocaleChangeInterceptor`
    is configured to use a request param name called language to indicate the locale.
    So, any URL of the `http://server/uri?language={locale}` format would trigger
    a change in the locale.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you append `language=en` to any URL, you would be using `en` locale for the
    duration of the session. If you append `language=fr` to any URL, then you would
    be using a French locale.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring a CookieLocaleResolver
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We use a `CookieLocaleResolver` in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Important things to note are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<property name="cookieName" value="userLocaleCookie"/>`: The name of the cookie
    stored in the browser will be `userLocaleCookie`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<property name="cookieMaxAge" value="7200"/>`: The lifetime of the cookie
    is 2 hours (`7200` seconds).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since we are using `LocaleChangeInterceptor` from the previous example, if you
    append `language=en` to any URL, you would be using `en` locale for a duration
    of 2 hours (or until the locale is changed). If you append `language=fr` to any
    URL, then you would be using a French locale for 2 hours (or until locale is changed).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integration testing Spring controllers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the flows we discussed, we looked at using real unit tests--ones that only
    load up the specific controllers that are being tested.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another possibility is to load up the entire Spring context. However, this
    would be more of an integration test as we would load up the entire context. The
    following code shows you how to do a complete launch of a Spring context, launching
    all controllers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'A few things to note are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@RunWith(SpringRunner.class)`: `SpringRunner` helps us launch a Spring context.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@WebAppConfiguration`: Used to launch a web app context with Spring MVC'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@ContextConfiguration("file:src/main/webapp/WEB-INF/user-web-context.xml")`:
    Specifies the location of the spring context XML.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`this.mockMvc = MockMvcBuilders.webAppContextSetup(this.wac).build()`: In the
    earlier examples, we used a standalone setup. However, in this example, we want
    to launch the entire web app. So, we use `webAppContextSetup`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The execution of the test is very similar to how we did it in earlier tests.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serving static resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most teams today have separate teams delivering frontend and backend content.
    The frontend is developed with modern JavaScript frameworks, such as AngularJs,
    Backbone, and so on. Backend is built through web applications or REST services
    based on frameworks such as Spring MVC.
  prefs: []
  type: TYPE_NORMAL
- en: With this evolution in frontend frameworks, it is very important to find the
    right solutions to version and deliver frontend static content.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are some of the important features provided by the Spring MVC
    framework:'
  prefs: []
  type: TYPE_NORMAL
- en: They expose static content from folders in the web application root
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They enable caching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They enable GZip compression of static content
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exposing static content
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Web applications typically have a lot of static content. Spring MVC provides
    options to expose static content from folders on the web application root as well
    locations on the classpath. The following snippet shows that content within the
    war can be exposed as static content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Things to note are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`location="/static-resources/"`: The location specifies the folders inside
    the war or classpath that you would want to expose as static content. In this
    example, we want to expose all the content in the `static-resources` folder inside
    the root of war as static content. We can specify multiple comma-separated values
    to expose multiple folders under the same external facing URI.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mapping="/resources/**"`: The mapping specifies the external facing URI path.
    So, a CSS file named `app.css` inside the static-resources folder can be accessed
    using the `/resources/app.css` URI.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The complete Java configuration for the same configuration is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Caching static content
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Caching for static resources can be enabled for improved performance. The browser
    would cache the resources served for the specified time period. The `cache-period`
    attribute or the `setCachePeriod` method can be used to specify the caching interval
    (in seconds) based on the type of configuration used. The following snippets show
    the details:'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the Java configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the XML configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Cache-Control: max-age={specified-max-age}` response header will be sent
    to the browser.'
  prefs: []
  type: TYPE_NORMAL
- en: Enabling GZip compression of static content
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Compressing a response is a simple way to make web applications faster. All
    modern browsers support GZip compression. Instead of sending the full static content
    file, a compressed file can be sent as a response. The browser will decompress
    and use the static content.
  prefs: []
  type: TYPE_NORMAL
- en: The browser can specify that it can accept the compressed content with a request
    header. If the server supports it, it can deliver the compressed content--again,
    marked with a response header.
  prefs: []
  type: TYPE_NORMAL
- en: 'Request Header sent from browser is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Response Header sent from the web application is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'The following snippet shows how to add a Gzip resolver to deliver compressed
    static content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Things to note are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`resourceChain(true)`: We would want to enable Gzip compression, but would
    want to fall back to delivering the full file if full file was requested. So,
    we use resource chaining (chaining of resource resolvers).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`addResolver(new PathResourceResolver()): PathResourceResolver`: This is the
    default resolver. It resolves based on the resource handlers and locations configured.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`addResolver(new GzipResourceResolver()): GzipResourceResolver`: This enables
    Gzip compression when requested.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating Spring MVC with Bootstrap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the approaches to using Bootstrap in a web application is to download
    the JavaScript and CSS files and make them available in their respective folders.
    However, this would mean that every time there is a new version of Bootstrap,
    we would need to download and make it available as part of the source code. The
    question is this--is there a way that we can introduce Bootstrap or any other
    static (JS or CSS) libraries using dependency management such as Maven?
  prefs: []
  type: TYPE_NORMAL
- en: The answer is WebJars. WebJars are client-side JS or CSS libraries packaged
    into JAR files. We can use Java build tools (Maven or Gradle) to download and
    make them available to the application. The biggest advantage is that WebJars
    are resolve transitive dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s use Bootstrap WebJar and include it in our web application. The
    steps involved are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Add Bootstrap WebJars as a Maven dependency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configure the Spring MVC resource handler to deliver static content from WebJar
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use Bootstrap resources (CSS and JS) in the JSP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bootstrap WebJar as Maven dependency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s add this to the `pom.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Configure Spring MVC resource handler to deliver WebJar static content
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is very simple. We need to add the following mapping to the spring context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: With this configuration, `ResourceHttpRequestHandler` makes the content from
    WebJars available as static content.
  prefs: []
  type: TYPE_NORMAL
- en: As discussed in the section on static content, we can specifically cache a period
    if we want to cache the content.
  prefs: []
  type: TYPE_NORMAL
- en: Using Bootstrap resources in JSP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can add bootstrap resources just like other static resources in the JSP:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Spring Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A critical part of web applications is authentication and authorization. Authentication
    is the process of establishing a user's identity, verifying that the user is who
    he/she claims to be. Authorization is checking whether the user has access to
    perform a specific action. Authorization specifies the access a user has. Can
    the user view a page? Can the user edit a page? Can the user delete a page?
  prefs: []
  type: TYPE_NORMAL
- en: A best practice is to enforce authentication and authorization on every page
    in the application. User credentials and authorization should be verified before
    executing any request to a web application.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Security provides a comprehensive security solution for Java EE enterprise
    applications. While providing great support to Spring-based (and Spring MVC-based)
    applications, it can be integrated with other frameworks as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following list highlights some of vast range of authentication mechanisms
    that Spring Security supports:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Form-based authentication**: Simple integration for basic applications'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**LDAP**: Typically used in most Enterprise applications'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Java Authentication and Authorization Service (JAAS)**: Authentication and
    authorization standard; part of Java EE standard specification'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Container managed authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom authentication systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's consider a simple example to enable Spring Security on simple web application.
    We will use an in-memory configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'The steps involved are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Add Spring Security dependency.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure the interception of all requests.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure Spring Security.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the logout functionality.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adding Spring Security dependency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will start with adding the Spring Security dependencies to `pom.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: The dependencies added in are `spring-security-web` and `spring-security-config`.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring a filter to intercept all requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The best practice when implementing security is to validate all incoming requests.
    We would want our security framework to look at the incoming request, authenticate
    the user and allow the action to be performed only if the user has access to perform
    the operation. We will make use of a filter to intercept and validate the request.
    The following example shows more details.
  prefs: []
  type: TYPE_NORMAL
- en: 'We would want to configure Spring Security to intercept all requests to a web
    application. We will use a filter, `DelegatingFilterProxy`, which delegates to
    a Spring-managed bean `FilterChainProxy`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, all requests to our web application will go through the filter. However,
    we have not configured anything related to security yet. Let''s use a simple Java
    configuration example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Things to note are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@EnableWebSecurity`: This annotation enables any Configuration class to contain
    the definition of Spring Configuration. In this specific instance, we override
    a couple of methods to provide our specific Spring MVC configuration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WebSecurityConfigurerAdapter`: This class provides a base class to create
    a Spring configuration (`WebSecurityConfigurer`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`protected void configure(HttpSecurity http)`: This method provides the security
    needs for different URLs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`antMatchers("/*secure*/**").access("hasRole(''USER'')")`: You would need a
    role of USER to access any URL containing the sub-string `secure`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`antMatchers("/login").permitAll()`: Permits access to the login page to all
    users.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public void configureGlobalSecurity(AuthenticationManagerBuilder auth)`: In
    this example, we are using in-memory authentication. This can be used to connect
    to a database (`auth.jdbcAuthentication()`), or an LDAP(`auth.ldapAuthentication()`),
    or a custom authentication provider (created extending `AuthenticationProvider`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`withUser("firstuser").password("password1")`: Configures an in-memory valid
    user ID and password combination.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.roles("USER", "ADMIN")`: Assigns roles to the user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we try to access any secure URLs, we will be redirected to a login page.
    Spring Security provides ways of customizing the Logic page as well as the redirection.
    Only authenticated users with the right roles will be allowed to access the secured
    application pages.
  prefs: []
  type: TYPE_NORMAL
- en: Logout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spring Security provides features to enable a user to log out and be redirected
    to a specified page. The URI of the `LogoutController` is typically mapped to
    the Logout link in the UI. The complete listing of `LogoutController` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Things to note are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`if (auth != null)`: If there is a valid authentication, then end the session'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`new SecurityContextLogoutHandler().logout(request, response, auth)`: `SecurityContextLogoutHandler`
    performs a logout by removing the authentication information from `SecurityContextHolder`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`return "redirect:/secure/welcome"`: Redirects to the secure welcome page'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed the basics of developing web applications with
    Spring MVC. We also discussed implementing exception handling, internationalization
    and securing our applications with Spring Security.
  prefs: []
  type: TYPE_NORMAL
- en: Spring MVC can also be used to build REST services. We will discuss that and
    more related to REST services in the subsequent chapters.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will shift our attention toward microservices. We will
    try to understand why the world is looking keenly at microservices. We will also
    explore the importance of applications being Cloud-Native.
  prefs: []
  type: TYPE_NORMAL
