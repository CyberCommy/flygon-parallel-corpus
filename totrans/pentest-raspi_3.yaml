- en: Chapter 3. Penetration Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until this point, we have covered how to build a Raspberry Pi, install Kali
    Linux, and prepare your Raspberry Pi for a penetration test through various forms
    of remote access techniques. Now you are ready to learn how to use the Raspberry
    Pi to capture data on a target network. This chapter will provide you with various
    LAN- and wireless-based attack scenarios, using tools found in Kali Linux that
    are optimized for a Raspberry Pi or tools that you can download using the `apt-get`
    command. There are other tools that are available in Kali Linux as well as online;
    however, we will focus on applications that we have found to function properly
    on a Raspberry Pi.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Network scanning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nmap
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wireless security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cracking WPA/WPA2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating wordlists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Capturing traffic on the network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting data to the Pi
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tuning your network capture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scripting tcpdump for future access
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wireshark and TShark
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Beating HTTPS with SSLstrip
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Raspberry Pi has limited performance capabilities due to its size and processing
    power. It is highly recommended that you test the following techniques in a lab
    prior to using a Raspberry Pi for a live penetration test.
  prefs: []
  type: TYPE_NORMAL
- en: Network scanning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Network reconnaissance is typically time-consuming, yet it is the most important
    step when performing a penetration test. The more you know about your target,
    the more likely it is that you will find the fastest and easiest path to success.
    The best practice is starting with reconnaissance methods that do not require
    you to interact with your target; however, you will need to make contact eventually.
    Upon making contact, you will need to identify any open ports on a target system
    as well as map out the environment to which it's connected. Once you breach a
    system, typically there are other networks that you can scan to gain deeper access
    to your target's network. We will cover breaching systems in [Chapter 4](ch04.html
    "Chapter 4. Raspberry Pi Attacks"), *Raspberry Pi Attacks*.
  prefs: []
  type: TYPE_NORMAL
- en: One huge advantage of the Raspberry Pi is its size and mobility. Typically,
    Kali Linux is used from an attack system outside a target's network; however,
    tools such as PWNIE Express and small systems that run Kali Linux, such as a Raspberry
    Pi, can be placed inside a network and be remotely accessed as explained in [Chapter
    2](ch02.html "Chapter 2. Preparing the Raspberry Pi"), *Preparing the Raspberry
    Pi*, of this book. This gives an attacker a system inside the network, bypassing
    typical perimeter defenses while performing internal reconnaissance. This approach
    brings the obvious risks of having to physically place the system on the network
    as well as create a method to communicate with it remotely without being detected;
    however, if successful, this can be very effective.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at a few popular methods to scan a target network. We'll continue
    forward assuming that you have established a foothold on a network and now want
    to understand the current environment that you have connected to.
  prefs: []
  type: TYPE_NORMAL
- en: Nmap
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most popular open source tool used to scan hosts and services on a network
    is **Nmap** (short for **Network Mapper**). Nmap's advanced features can detect
    different applications running on systems as well as offer services such as the
    OS fingerprinting features. Nmap can be very effective; however, it can also be
    easily detected unless used properly. We recommend using Nmap in very specific
    situations to avoid triggering a target's defense systems.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more information on how to use Nmap, visit [http://nmap.org/](http://nmap.org/).
  prefs: []
  type: TYPE_NORMAL
- en: To use Nmap to scan a local network, open a terminal window and type `nmap (target)`,
    for example, `nmap www.somewebsite.com` or `nmap 192.168.1.2`. There are many
    other commands that can be used to tune your scan. For example, you can tune how
    stealthy you want to be or specify to store the results in a particular location.
    The following screenshot shows the results after running Nmap against [www.thesecurityblogger.com](http://www.thesecurityblogger.com).
    Note that this is an example and is considered a noisy scan. If you simply type
    in either of the preceding two commands, it is most likely that your target will
    easily recognize that you are performing an Nmap scan.
  prefs: []
  type: TYPE_NORMAL
- en: '![Nmap](img/Insert6435OT_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'There are plenty of online resources available to learn how to master the various
    features for Nmap. We will show other examples of using Nmap later in this chapter.
    Here is a reference list of popular `nmap` commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '`nmap 192.168.1.0/24`: This scans the entire class C range'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nmap -p <port ranges>`: This scans specific ports'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nmap -sP 192.168.1.0/24`: This scans the network/find servers and devices
    that are running'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nmap –iflist`: This shows host interfaces and routes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nmap –sV 192.168.1.1`: This detects remote services'' version numbers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nmap –sS 192.168.1.1`: This performs a stealthy TCP SYN scan'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nmap –sO 192.168.1.1`: This scans for the IP protocol'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nmap -192.168.1.1 > output.txt`: This saves the output from the scan to the
    text file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nmap –sA 192.168.1.254`: This checks whether the host is protected by a firewall'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nmap –PN 192.168.1.1`: This scans the host when it is protected by a firewall'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nmap --reason 192.168.1.1`: This displays the reason a port is in a particular
    state'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nmap --open 192.168.1.1`: This only shows open or possibly open ports'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Nmap GUI software Zenmap is not included in the Kali Linux ARM image. It
    is also not recommended over using the command line when running Kali Linux on
    a Raspberry Pi.
  prefs: []
  type: TYPE_NORMAL
- en: Wireless security
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another attack vector that can be leveraged on a Raspberry Pi with a Wi-Fi adapter
    is targeting wireless devices such as mobile tablets and laptops. Scanning wireless
    networks, once they are connected, is similar to how scanning is done on a LAN;
    however, typically a layer of password decryption is required before you can connect
    to a wireless network. Also, wireless network identifier known as **Service Set
    Identifier** (**SSID**) might not be broadcasted but will still be visible when
    you use the right tools. This section will cover how to bypass wireless onboarding
    defenses so that you can access a target's Wi-Fi network and perform the penetration
    testing steps described in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at a Raspberry Pi with Kali Linux, one of the use cases is hiding the
    system inside or near a target's network and launching wireless attacks remotely.
    The goal will be to enable the Raspberry Pi to access the network wirelessly and
    provide a remote connection back to the attacker. The attacker can be nearby using
    wireless to control the Raspberry Pi until it gains wireless access. Once on the
    network, a backdoor can be established so that the attacker can communicate with
    the Raspberry Pi from anywhere in the world and launch attacks, as explained in
    [Chapter 2](ch02.html "Chapter 2. Preparing the Raspberry Pi"), *Preparing the
    Raspberry Pi*. We will cover the building of this attack example using a rogue
    access point in the *Rogue access honeypots* section of [Chapter 4](ch04.html
    "Chapter 4. Raspberry Pi Attacks"), *Raspberry Pi Attacks*.
  prefs: []
  type: TYPE_NORMAL
- en: Cracking WPA/WPA2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A commonly found security protocol for protecting wireless networks is **Wi-Fi
    Protected Access** (**WPA**). WPA was later replaced by WPA2 and it will be probably
    what you will be up against when you perform a wireless penetration test.
  prefs: []
  type: TYPE_NORMAL
- en: WPA and WPA2 can be cracked with **Aircrack**. Kali Linux includes the Aircrack
    suite, which is one of the most popular applications to break wireless security.
    Aircrack works by gathering packets seen on a wireless connection to either mathematically
    analyze the data to crack weaker protocols such as **Wired Equivalent Privacy**
    (**WEP**), or use brute force on the captured data with a wordlist.
  prefs: []
  type: TYPE_NORMAL
- en: Cracking WPA/WPA2 can be done due to a weakness in the four-way handshake between
    the client and the access point. In summary, a client will authenticate to an
    access point and go through a four-step process. This is the time when the attacker
    is able to grab the password and use a brute force approach to identify it. The
    time-consuming part in this is based on how unique the network password is, how
    extensive your wordlist that will be used to brute force against the password
    is, and the processing power of the system. Unfortunately, the Raspberry Pi lacks
    the processing power and the hard drive space to accommodate large wordlist files.
    So, you might have to crack the password off-box with a tool such as **John the
    Ripper**. We recommend this route for most WPA2 hacking attempts.
  prefs: []
  type: TYPE_NORMAL
- en: Here is the process to crack a WPA running on a Linksys WRVS4400N wireless router
    using a Raspberry Pi on-box options. We are using a WPA example so that the time-consuming
    part can be accomplished quickly with a Raspberry Pi. Most WPA2 cracking examples
    would take a very long time to run from a Raspberry Pi; however, the steps to
    be followed are the same to run on a faster off-box system.
  prefs: []
  type: TYPE_NORMAL
- en: 'The steps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Start Aircrack by opening a terminal and typing `airmon-ng`;![Cracking WPA/WPA2](img/Insert6435OT_03_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Aircrack, we need to select the desired interface to use for the attack.
    In the previous screenshot, `wlan0` is my Wi-Fi adapter. This is a USB wireless
    adapter that has been plugged into my Raspberry Pi.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is recommended that you hide your Mac address while cracking a foreign wireless
    network. Kali Linux ARM does not come with the program **macchanger**. So, you
    should download it by using the `sudo apt-get install macchanger` command in a
    terminal window. There are other ways to change your Mac address, but macchanger
    can provide a spoofed Mac so that your device looks like a common network device
    such as a printer. This can be an effective way to avoid detection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we need to stop the interface used for the attack so that we can change
    our Mac address. So, for this example, we will be stopping `wlan0` using the following
    commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s change the Mac address of this interface to hide our true identity.
    Use macchanger to change your Mac to a random value and specify your interface.
    There are options to switch to another type of device; however, for this example,
    we will just leave it as a random Mac address using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Our random value is `b0:43:3a:1f:3a:05` in the following screenshot. Macchanger
    shows our new Mac as `unknown`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Cracking WPA/WPA2](img/Insert6435OT_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that our Mac is spoofed, let''s restart `airmon-ng` with the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to locate available wireless networks so that we can pick our target
    to attack. Use the following command to do this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: You should now see networks within range of your Raspberry Pi that can be targeted
    for this attack. To stop the search once you identify a target, press *Ctrl* +
    *C*. You should write down the Mac address, also known as `BSSID`, and the channel,
    also known as `CH`, used by your target network. The following screenshot shows
    that our target with `ESSID` **HackMePlease** is running `WPA` on `CH` `6`:![Cracking
    WPA/WPA2](img/Insert6435OT_03_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The next step is running `airodump` against the Mac address that you just copied.
    You will need the following things to make this work:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The channel being used by the target
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Mac address (`BSSID`) that you copied
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A name for the file to save your data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s run the `airodump` command in the following manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This will open a new terminal window after you execute it. Keep that window
    open.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open another terminal window that will be used to connect to the target''s
    wireless network. We will run `aireplay` using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'For our example, the command will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the launch of the preceding command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Cracking WPA/WPA2](img/Insert6435OT_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You may not get the full handshake when you run this command. If that happens,
    you will have to wait for a live user to authenticate you to the access point
    prior to launching the attack. The output on using Aircrack may show you something
    like **Opening [file].cap** a few times followed by **No valid WPA handshakes
    found**, if you didn't create a full handshake and somebody hasn't authenticated
    you by that time. Do not proceed to the next step until you capture a full handshake.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last step is to run Aircrack against the captured data to crack the WPA
    key. Use the `–w` option to specify the location of a wordlist that will be used
    to scan against the captured data. You will use the `.cap` file that was created
    earlier during step 9, so we will use the name `capturefile.cap` in our example.
    We''ll do this using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Kali Linux ARM image does not include a `wordlist.lst` file for cracking
    passwords. Usually, default wordlists are not good anyway. So, it is recommended
    that you use Google to find an extensive wordlist (see the next section on wordlists
    for more information). Make sure to be mindful of the hard drive space that you
    have on the Raspberry Pi, as many wordlists might be too large to be used directly
    from the Raspberry Pi. The best practice for running process-intensive steps such
    as brute forcing passwords is to do them off-box on a more powerful system.
  prefs: []
  type: TYPE_NORMAL
- en: You will see Aircrack start and begin trying each password in the wordlist file
    against the captured data. This process could take a while depending on the password
    you are trying to break, the number of words in your list, and the processing
    speed of the Raspberry Pi. We found that it ranges from a few hours to days, as
    it's a very tedious process and is possibly better-suited for an external system
    with more horsepower than a Raspberry Pi. You may also find that your wordlist
    doesn't work after waiting a few days to sort through the entire wordlist file.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If Aircrack doesn't open and start trying keys against the password, you either
    didn't specify the location of the `.cap` file or the location of the `wordlist.lst`
    file, or you don't have the captured handshake data. By default, the previous
    steps store files in the root directory. You can move your wordlist file in the
    root directory to mimic how we ran the commands in the previous steps since all
    our files are located in the root directory folder. You can verify this by typing
    `ls` to list the current directory files. Make sure that you list the correct
    directories of each file that are called by each command.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your attack is successful, you should see something like the following screenshot
    that shows the identified password as **sunshine**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Cracking WPA/WPA2](img/Insert6435OT_03_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It is a good idea to perform this last step on a remote machine. You can set
    up a FTP server and push your `.cap` files to that FTP server or use steps similar
    to those covered under the *Scripting tcpdump for future access* section found
    later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can learn more about setting up an FTP server at [http://www.raspberrypi.org/forums/viewtopic.php?f=36&t=35661](http://www.raspberrypi.org/forums/viewtopic.php?f=36&t=35661).
  prefs: []
  type: TYPE_NORMAL
- en: Creating wordlists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many sources and tools that can be used to develop a wordlist for
    your attack. One popular tool called **Custom Wordlist Generator** (**CeWL**),
    allows you to create your own custom dictionary file. This can be extremely useful
    if you are targeting individuals and want to scrape their blogs, LinkedIn, or
    other websites for commonly used words. CeWL doesn't come preinstalled on the
    Kali Linux ARM image, so you will have to download it using `apt-get install cewl`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use CeWL, open a terminal window and put in your target website. CeWL will
    examine the URL and create a wordlist based on all the unique words it finds.
    In the following example, we are creating a wordlist of commonly used words found
    on the security blog [www.drchaos.com](http://www.drchaos.com) using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the launch of the preceding command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating wordlists](img/Insert6435OT_03_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can also find many examples of popular wordlists used as dictionary files
    on the Internet. Here are a few wordlist examples sources that you can use; however,
    be sure to research Google for other options as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://crackstation.net/buy-crackstation-wordlist-password-cracking-dictionary.html](https://crackstation.net/buy-crackstation-wordlist-password-cracking-dictionary.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://wiki.skullsecurity.org/Passwords](https://wiki.skullsecurity.org/Passwords)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is a dictionary that one of the coauthors of this book put together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.drchaos.com/public_files/chaos-dictionary.lst.txt](http://www.drchaos.com/public_files/chaos-dictionary.lst.txt)'
  prefs: []
  type: TYPE_NORMAL
- en: Capturing traffic on the network
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is great to get access to a target network. However, typically the next step,
    once a foothold is established, is to start looking at the data. To do this, you
    will need a method to capture and view network packets. This means turning your
    Raspberry Pi into a remotely accessible network tap.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Many of these tools could overload and crash your Raspberry Pi. Look out for
    our recommendations regarding when to use a tuning method to avoid this from happening.
  prefs: []
  type: TYPE_NORMAL
- en: Tcpdump
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Tcpdump is a command-line-based packet analyzer. You can use `tcpdump` to intercept
    and display TCP/IP and other packets that are transmitted and seen attached by
    the system This means the Raspberry Pi must have access to the network traffic
    that you intend to view or using tcpdump won't provide you with any useful data.
    Tcpdump is not installed with the default Kali Linux ARM image, so you will have
    to install it using the `sudo apt-get install tcpdump` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once installed, you can run `tcpdump` by simply opening a terminal window and
    typing `sudo tcpdump`. The following screenshot shows the traffic flow visible
    to us after the launch of the preceding command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Tcpdump](img/Insert6435OT_03_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As the previous screenshot shows, there really isn't much to see if you don't
    have the proper traffic flowing through the Raspberry Pi. Basically, we're seeing
    our own traffic while being plugged into an 802.1X-enabled switch, which isn't
    interesting. Let's look at how to get other system's data through your Raspberry
    Pi.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Running `tcpdump` consumes a lot of the Raspberry Pi's processing power. We
    found that this could crash the Raspberry Pi by itself or while using it with
    other applications. We recommend that you tune your data capture to avoid this
    from happening. Tuning a data capture will be covered later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Man-in-the-middle attacks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One common method to capture sensitive information is by performing a man-in-the-middle
    attack. By definition, a man-in-the-middle attack is when an attacker makes independent
    connections with victims while actively eavesdropping on the communication. This
    is typically done between a host and the systems. For example, a popular method
    to capture passwords is to act as a middleman between login credentials passed
    by a user to a web server. We will cover this as well as a few other common man-in-the-middle
    attacks performed with tools found in Kali Linux.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at a few versions of man-in-the-middle attacks used to get data into
    your Raspberry Pi.
  prefs: []
  type: TYPE_NORMAL
- en: Getting data to the Pi
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a few methods to get data to your Raspberry Pi. One method is placing
    the Raspberry Pi in line between two systems using two Ethernet ports. This requires
    a USB to Ethernet adapter and the ability to physically connect the Raspberry
    Pi in this fashion. In the following example, we are connecting a windows laptop
    to one end of our Raspberry Pi and the network switch to the other. One of the
    Ethernet ports is a USB adapter.
  prefs: []
  type: TYPE_NORMAL
- en: For live penetration testing, you can customize the Raspberry Pi's protective
    case, as shown in the following image, to mimic anything from a power plug to
    a network hub to hide your attack system. We found that the average person won't
    mess with a small box attached to a network device if it looks like it belongs
    there. Once, we also placed a Raspberry Pi in office stationery, such as a hollow
    alarm clock, to conceal it during an authorized penetration test.
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting data to the Pi](img/Insert6435OT_03_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The Raspberry Pi needs to be configured to bridge the target system's Ethernet
    port to the network-facing port and vice versa in order to see traffic. Without
    doing this, traffic will die once it hits the Pi. Before doing this, you will
    need to install the `bridge` utility that will be used to bridge the two ports
    together. To install this, use the `apt-get install bridge-utils` command. Once
    installed, here is the procedure to turn your Raspberry Pi into a network bridge
    for network taping purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Setting up a Raspberry Pi in this manner is also ideal to use it as an intrusion
    detection/prevention asset. We will cover this in [Chapter 6](ch06.html "Chapter 6. Other
    Raspberry Pi Projects"), *Other Raspberry Pi Projects*.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will need to configure both Ethernet ports as open IP addresses, which
    is also known as setting them to `0.0.0.0`. To do this. use the `ifconfig eth[interface
    number] 0.0.0.0` command for both interfaces in the following manner:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Make sure that you download the `bridge-utils` utility before doing this, or
    you will have to reset the Internet-facing interface back to a working state to
    download the utility prior to proceeding. Another work around is installing a
    USB to Wi-Fi adapter or another USB to Ethernet adapter temporarily to get back
    online and download the missing application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will bridge the interfaces to a `bridge0` interface using the `brctl`
    command and add both the Ethernet interfaces:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This command won't work if you haven't installed the `bridge-utils` utility.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last step is turning on the new bridge containing both the Ethernet interfaces
    using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows what all the commands look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting data to the Pi](img/Insert6435OT_03_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following screenshot shows the output of tcpdump viewing traffic as the
    target laptop surfs the Internet:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting data to the Pi](img/Insert6435OT_03_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You may find that some traffic such as the web-based SSL traffic is encrypted.
    We will cover how to beat this using SSLstrip later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Another approach to get data through the Raspberry Pi is to redirect traffic
    from a system on the same network subnet using a man-in-the-middle approach so
    that you don't have to mess with the physical connection of that target. Let's
    look at how this works.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Many network switches made by vendors such as Cisco and Juniper offer techniques
    to avoid **Address Resolution Protocol** (**ARP**) poisoning. For this reason,
    we recommend the network tap approach for real penetration testing environments.
  prefs: []
  type: TYPE_NORMAL
- en: ARP spoofing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The second method to capture data with your Raspberry Pi is identifying a target
    system on the same network and ARP spoofing its traffic through your Raspberry
    Pi. To do this, you will need to download the `dsniff` package since it doesn''t
    come preinstalled on the Kali Linux ARM image. Use the `sudo apt-get install dsniff`
    command to install the package prior to launching the ARP spoofing exercise. Once
    you install `dsniff`, you are ready to start your ARP spoofing attack using the
    following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This approach will not work if a target's switch has ARP poisoning mitigation
    enabled. For example, on Cisco switches, enabling **DHCP snooping** and **Dynamic
    ARP Inspection** will prevent this. These commands on a Cisco switch will look
    like `ip dhcp snooping` and `ip arm inspection vlan [vlan number]`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enable IP forwarding to enable ARP spoofing to pass packets to and fro between
    the target to the Raspberry Pi using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can verify whether IP forwarding is enabled by using the `cat` command
    to display **1** on the screen, representing that it is operating. The command
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you need to find the default gateway and subnet mask of the network to
    which your Raspberry Pi is connected. You can find this using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows our default gateway as `10.0.2.1` on a class
    C network, also known as network mask `255.255.255.0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ARP spoofing](img/Insert6435OT_03_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, let''s identify a target to attack. As mentioned earlier in this chapter,
    `nmap` is a great tool for identifying what systems are on the network. In this
    case, we want to do a reverse lookup using `–R` and include `sn` to avoid port
    scanning since we are just looking for a target. The previous screenshot showed
    that the default gateway network is a class C, so we can scan the entire subnet
    for a target with `nmap` using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '![ARP spoofing](img/Insert6435OT_03_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Our scan shows a `Dell` laptop with the IP address `10.0.2.63` that is available
    for our attack. The other devices look like `Cisco` and `Meraki` network devices.
    Let's target the host laptop.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now its time to start ARP cache poisoning the traffic between our target and
    the default gateway so that we can tap into that traffic. Our interface is `eth0`
    that is represented by the `–i` option, the target is `10.0.2.63` that is represented
    by the `–t` option, and the default route that is also known as a gateway is `10.0.2.1`.
    This is represented by the `-r` option. The command is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this use case, we are using the physical Ethernet adapter on the Raspberry
    Pi for this attack. If you use a USB wireless adapter, you would most likely use
    `wlan0` as your interface.
  prefs: []
  type: TYPE_NORMAL
- en: You should start to see traffic from the ARP cache poisoning running in the
    window as shown in the following screenshot. Leave this open and run a tool such
    as Wireshark to view the traffic for a data capture. We will cover this later
    in this chapter.![ARP spoofing](img/Insert6435OT_03_14.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ettercap
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are utilities available that simplify the ARP spoofing or the port bridging
    process. Ettercap is a very popular man-in-the-middle attack suite that includes
    handling the ARP spoofing steps previously described. Its other key features include
    sniffing live connections, filtering content on the fly, and various other attacks
    on victims. Go to [ettercap.github.io/ettercap/](http://ettercap.github.io/ettercap/)
    for more information on this tool.
  prefs: []
  type: TYPE_NORMAL
- en: The Kali Linux ARM image does not include Ettercap. There are two options to
    install Ettercap, as shown in the following screenshot, after you run the `apt-get
    install ettercap` command. We will start by using the Ettercap GUI option and
    use the `apt-get ettercap-graphical` command to install it.
  prefs: []
  type: TYPE_NORMAL
- en: '![Ettercap](img/Insert6435OT_03_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To run Ettercap once it is installed, type `sudo ettercap -G`. This will bring
    up the Ettercap GUI as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Ettercap](img/Insert6435OT_03_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Ettercap has two sniffing options. Option one is Unified sniffing, which means
    sniffing all packets that pass on the cable via one interface. This method has
    options such as using promiscuous mode, which means packets that are not directed
    to the host are automatically forwarded to it using layer three routing. Ettercap
    will disable the `kernel ip-forwarding` to avoid sending the packets twice via
    the kernel and Ettercap.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This approach will not work if a target's switch has ARP poisoning mitigation
    enabled. For example, on Cisco switches, enabling **DHCP snooping** and **Dynamic
    ARP Inspection** will prevent this. These commands on a Cisco switch will look
    like `ip dhcp snooping` and `ip arm inspection vlan [vlan number]`.
  prefs: []
  type: TYPE_NORMAL
- en: Option two is Bridged sniffing, which means using two network interfaces and
    forwarding traffic between them. This is similar to how we used the `brctl` command
    to bridge two ports earlier in this chapter. Using this sniffing method is recommended
    over ARP poisoning since it is stealthier and more likely to be successful. This
    is due to the fact that advanced switches have methods to battle ARP poisoning
    attacks. The downside of this approach is to physically connect a Raspberry Pi
    in this fashion.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Setting up a Raspberry Pi in this manner is also ideal to use your Raspberry
    Pi as an intrusion detection/prevention asset. We will cover this in [Chapter
    5](ch05.html "Chapter 5. Ending the Penetration Test"), *Ending the Penetration
    Test*.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our example, we will use Unified sniffing since our Raspberry Pi is using
    one `eth0` port for the attack. Click on the **Sniff** menu and select **Unified
    sniffing...** as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Ettercap](img/Insert6435OT_03_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Ettercap will ask you to select an interface from your Raspberry Pi. We are
    only using the standard `eth0` port for this attack so we have selected that,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Ettercap](img/Insert6435OT_03_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Ettercap will display some details about the plugs and ports that it has in
    the bottom window. You will also notice in the following screenshot that some
    new options will appear in the top menu. Now, we need to scan for hosts on the
    network to attack. You can do this by clicking on **Hosts** from the menu and
    selecting **Scan for hosts**. You will see a progress bar while Ettercap scans
    the network for targets.
  prefs: []
  type: TYPE_NORMAL
- en: '![Ettercap](img/Insert6435OT_03_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You will see that the results appear at the bottom of the text box. In our
    example, we found four hosts. You can view the hosts by clicking on **Hosts**
    and choosing **Host list**. The following screenshot shows the **Host List** with
    four hosts:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Ettercap](img/Insert6435OT_03_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You will need to select which hosts you want to place in your **Target 1** and
    **Target 2** areas in order for things to work. For our example, we will select
    `10.0.2.1`, which is the default gateway, as **Target 2**. We will use the victim
    system `10.0.2.64` as **Target 1**. This will place our Raspberry Pi between both
    these targets.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add an IP address to a target, click on it in the **IP Address** section
    in the **Host List** and click on **Add to Target** X, where X is the target that
    you are adding. You will see Ettercap display in the bottom window that the IP
    address you selected was added to the target you selected. You can also verify
    this by selecting **Targets** from the menu and choosing **Current Targets**.
    The following screenshot shows the addition of host `10.0.2.64` as **Target 1**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Ettercap](img/Insert6435OT_03_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To ARP spoof our selected targets, we can select **Mitm** and choose **Arp Poisoning...**.
    This will bring up a window asking you to select between two additional options
    of **Sniff remote connections** or **Only poison one-way** as shown in the following
    screenshot. Select **Sniff remote connections** and click on the **OK** button.
  prefs: []
  type: TYPE_NORMAL
- en: '![Ettercap](img/Insert6435OT_03_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once you click on the **OK** button, Ettercap should display in the bottom
    window that it''s ARP poisoning all victims in Group 1 and Group 2 lists that
    we selected as **Target 1** and **Target 2** from the host scan. The final step
    is to select **Start sniffing** from the **Start** menu, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Ettercap](img/Insert6435OT_03_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The Raspberry Pi should now be placed in the middle between the target system
    and the default gateway, and let you to view the traffic with a sniffing software
    such as Wireshark. Ettercap has a sniffing option but it is not as good as other
    tools such as Wireshark, which we will cover later in this chapter. To monitor
    the ARP spoofing attack in Ettercap while it's running, click on **View** and
    select **Connections**.
  prefs: []
  type: TYPE_NORMAL
- en: Ettercap command line
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ettercap also offers a command-line flavor of the software that consumes less
    resources than the GUI. You can download this version of Ettercap by using the
    `apt-get install ettercap-text-only` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say you want to perform all the steps covered in the GUI example and
    attack all devices on the same network as the Raspberry Pi. The following command
    string will quickly accomplish this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows an output similar to the GUI approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Ettercap command line](img/Insert6435OT_03_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: However, for this example, we are attacking all the hosts in **Group 1** and
    **Group 2**, which means everybody on the network. You can see that we're listening
    on `eth0` as specified in the command, and Ettercap has found four hosts and added
    them to both groups. You will also notice that we couldn't decrypt SSL traffic;
    however, this will be covered later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can verify whether this Ettercap is working with any network monitoring
    software such as the `urlsnarf` part of the `dsniff` package. To do this, use
    the `urlsnarf –i [the network interface]` command, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Ettercap command line](img/Insert6435OT_03_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You will start seeing network traffic in a terminal window representing what
    is being captured while your attack is in progress, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Ettercap command line](img/Insert6435OT_03_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Driftnet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One utility that is used to see images captured during a man-in-the-middle attack
    is a program called Driftnet. There are better ways to find more interesting data;
    however, driftnet can be useful if you are focusing on viewing images. Driftnet
    does not come preinstalled on Kali Linux ARM. You can download it by using the
    `apt-get install driftnet` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once installed, use the driftnet `–i eth0` command to run it. This will open
    up a new terminal window that will be blank. Any images seen by a victim during
    the man-in-the-middle attack will start populating in this window. The following
    screenshot shows a host accessing [www.cisco.com](http://www.cisco.com) while
    driftnet is capturing images:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Driftnet](img/Insert6435OT_03_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tuning your network capture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: During real penetration testing exercises, we found that running raw `tcpdump`
    captures or using tools such as Wireshark consume a lot of processing power and
    sometimes crash the Raspberry Pi or render it useless. For this reason, the best
    practice is to avoid using such tools in real environments unless you tune what
    is captured to reduce the overhead on the Raspberry Pi. Here are some steps to
    capture network traffic using `tcpdump` in a controlled manner.
  prefs: []
  type: TYPE_NORMAL
- en: Tcpdump is a very useful tool and knowing what you are doing with the utility
    will help you to get the most out of the tool on the Raspberry Pi. The following
    section will provide a few tuning pointers but it is not intended to be a tcpdump
    tutorial.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing to consider is how to narrow down what tcpdump is looking for.
    You can do this in a few ways. The first way is to specify the `host` keyword.
    The `host` keyword will look for traffic specified by a hostname or IP address.
    It can be done in the following manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, we can do it using the IP address in the following manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also specify the source IP address, destination IP address, or both
    the source and the destination. In the following example, we have defined both
    the source and the destination:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: If needed, you don't have to be this specific and can limit the search to only
    the source or the destination.
  prefs: []
  type: TYPE_NORMAL
- en: You may have a need to look at all the traffic belonging to a particular network's
    subnet. To do this, use the `net` command in `tcpdump`. You should, however, keep
    in mind a few things before doing this. On a busy network, your Raspberry Pi will
    most likely not be able to keep up with this traffic capture. It is not only limited
    by the processing power, but also by the 100 MB network interface. If you exceed
    the capabilities of the Raspberry Pi, the best-case scenario is that it will drop
    traffic and not capture what you expected. The worst-case scenario could mean
    crashing the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following commands are used to look at all the traffic belonging to a particular
    network''s subnet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'You can search for specific protocols as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Although it is called tcpdump, you can specify **Transmission Control Protocol**
    (**TCP**), **User Datagram Protocol** (**UDP**), and **Internet Control Message
    Protocol** (**ICMP**) protocols.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can specify specific port numbers to monitor. You can also specify whether
    this is going to be a source port or a destination port. You can see from the
    following example that we combined several options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'You should write your findings to a file that can be analyzed later. To write
    your findings to a file, use the `–w` option followed by the name of the file
    in which you are going to save them. It is good practice to use `.cap` as a file
    extension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'You can read the file directly from tcpdump using the `–r` option as shown
    in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: However, we recommend that you remotely transfer the file to an FTP, SCP, HTTPS
    or any other type of server.
  prefs: []
  type: TYPE_NORMAL
- en: Scripting tcpdump for future access
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may want to export network captures to avoid running out of space on the
    local Raspberry Pi. Here are some steps to export the captured data to an external
    source for more resource-intensive tasks such as password cracking or for reporting
    purposes. These are also ideal for other sections of this book that require exporting
    data.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 2](ch02.html "Chapter 2. Preparing the Raspberry Pi"), *Preparing
    the Raspberry Pi*, we recommended setting up a remote server that is also known
    as a C&C server. We also mentioned transferring captured files to an FTP server
    in one of the previous steps in this chapter. Regarding the use of FTP, it is
    important to remember that FTP is inherently insecure. People have used FTP for
    a variety of different reasons. However, for real world penetration testing exercises,
    it is critical to protect FTP through another form of encryption such as an **Internet
    Protocol Secutiry** (**IPsec**) tunnel or **SSH/Secure File Transfer Protocol**
    (**SFTP**). IPsec ensures all data transfers never occur over the Internet that
    is, in the open for others to capture and view. Protecting your FTP also gives
    you full control of the both sides of the networks meaning the client and server,
    as well the transport medium.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You may ask "Why go to these lengths and not just use FTP?" If you plan to capture
    sensitive information, it would make sense to protect that data. This begs the
    question, why consider FTP in the first place? We used FTP in previous sections
    because of industry familiarity and the availability of automatic scripting for
    file transfers. However, you can achieve the same results by searching for more
    secure protocols.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at how to develop a simple FTP script to extract data from a remote
    Raspberry Pi in the following manner. First, open up a text editor and save the
    file with a `.py` extension. We saved our file as `ftp.py`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Next, you will need to change the permissions on the file. You can do this by
    issuing the `chmod 777 ftp.py` command to make it an executable file.
  prefs: []
  type: TYPE_NORMAL
- en: This is a very basic script. You will need to specify the file you would like
    to transfer, the username, password, and the IP address of your server.
  prefs: []
  type: TYPE_NORMAL
- en: If you find that you use this script method often, you probably will want to
    add options such as automatically monitoring a directory for captures and then
    using FTP to automate an upload. You may even want to change the upload directory.
  prefs: []
  type: TYPE_NORMAL
- en: Tcpdump and files exported from a Raspberry Pi containing tons of captured packet
    data might be difficult to view as well as organize. A more popular approach of
    working with such data is using the industry standard GUI-based network analyzer
    Wireshark for this purpose. Let's look at how that application works.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We found that Wireshark requires more processing power than many lightweight
    command-line tools and sometimes might cause the Raspberry Pi to become unstable
    or flat out crash. For this reason, we recommend that you use tcpdump and tune
    the capture , which we just covered as the primary method to capture data. Wireshark
    is better suited to use on your C&C server to view captured data rather than directly
    from your Raspberry Pi.
  prefs: []
  type: TYPE_NORMAL
- en: Wireshark
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Wireshark is one of the most popular open source packet analyzer programs available
    today. It can be used to troubleshoot network problems, analyzing communication
    between systems, and in the case of a penetration test, to capture data once you
    breach a network. Think of Wireshark as tcpdump with a pretty graphical interface
    and nifty data sorting features. Wireshark comes preinstalled on the Kali Linux
    ARM image and can be found under the top ten tools category in the Kali Linux
    application drop-down menu.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Test out your Wireshark use case in a lab prior to using it in a live environment.
    We found that Wireshark sometimes crashed our Raspberry Pi during real exercises.
    For this reason, we recommend that you use a tuned tcpdump approach directly on
    a Raspberry Pi and Wireshark on a remote C&C server. If you must use Wireshark,
    use TShark on the Raspberry Pi and the full-blown Wireshark on your C&C server.
  prefs: []
  type: TYPE_NORMAL
- en: There are two ways of using Wireshark. Let's start by looking at the full-blown
    GUI.
  prefs: []
  type: TYPE_NORMAL
- en: When you start Wireshark, you will see an error message and later a warning
    message stating that you are running Wireshark as a super user, also known as
    root. Just click on **OK** to access the main GUI.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows a Wireshark GUI:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Wireshark](img/Insert6435OT_03_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At this point, we assume that you have traffic running through your Raspberry
    Pi using methods previously covered in this chapter and are now looking at live
    data. The first step is viewing what interfaces you want to examine with Wireshark
    by clicking on the **Interface List** button. This will bring up a window showing
    all the interfaces and which interfaces are seeing traffic:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Wireshark](img/Insert6435OT_03_29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you are running the Raspberry Pi as a bridge between two Ethernet interfaces,
    you will need to select the `bridge0` interface as your data source. If you are
    using the ARP poisoning method to read data, meaning you are only using one interface,
    you will need to select a network facing port such as `eth0`, as shown in the
    previous screenshot example. Click on the **Start** button once you click the
    check box next to the interface you are going to monitor.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can also use Wireshark to view the data previously captured, such as in
    a **Packet Capture** (**pcap**) file. This is ideal when placing a Raspberry Pi
    on a network to do a network capture and later view what was found. This method
    will eat up memory, so it is recommended to work with live data rather than archiving
    large amounts of packet capture files on a Raspberry Pi due to its limited storage
    capabilities. A possible workaround is storing and exporting network captures
    to an external C&C server to meet the penetration testing purpose.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you select an interface, it will bring up the Wireshark live capture feed
    page. You will probably see a ton of data including the ARP poisoning packets,
    shown in black, if you are using the ARP spoofing method to get traffic through
    your Raspberry Pi:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Wireshark](img/Insert6435OT_03_30.jpg)'
  prefs: []
  type: TYPE_IMG
- en: One of Wireshark's popular features is being able to sort through tons of logs
    very quickly. You can enter the information into the filter line such as a particular
    host, type of packet, and so on, and quickly narrow down to a specific packet
    of interest. Let's walk you through an example attack.
  prefs: []
  type: TYPE_NORMAL
- en: Capturing a WordPress password example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, we're going to log in to a WordPress website as an administrator
    with the target system before stopping the Wireshark live capture. This will capture
    the host's login session so that the attacker can view the captured password.
    To stop the Wireshark capture, click on the red square. It may take a minute or
    so for the Wireshark interface to catch up with the display.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we want to look for the WordPress login information. This can
    be found in a POST packet, meaning data sent from a user to a system such as a
    username and password. We can use the filter to filter out traffic and zero in
    on our target data. So, for this example, we're going to look for the target's
    IP address using the `ip.src ==` command and the http request login information
    using the `http.request.full_url` command, then click on **Apply** to execute
    it. You can see the command in the previous screenshot in the green filter area
    and also what the output looks like once filtered.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Notice that the color of the filter section is green after we entered the command
    string. Wireshark verifies text as you enter it and offers possible filter expressions.
    If the output has an error, the filter box color will turn red.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we use the following command to filter out the target IP address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To avoid the Raspberry Pi crashing, it is recommended that you pause a network
    capture and wait a minute prior to entering filtering expressions.
  prefs: []
  type: TYPE_NORMAL
- en: It may take a few minutes for Wireshark to weed out all the unwanted data once
    you apply a filter. You will see a progress window as Wireshark processes the
    filter on the captured data.
  prefs: []
  type: TYPE_NORMAL
- en: We can ignore the GET packets since that is the host loading the website prior
    to logging in as well as the TCP packets since they are the ARP spoof data. To
    quickly look through the data, we can click on one of the tabs such as the **Protocol**
    tab to sort the data in **Alphabetical** order based on that tab's function. Doing
    this will take a few seconds and will once again bring up a process tab during
    the compute time.
  prefs: []
  type: TYPE_NORMAL
- en: 'What we want is the POST line that shows when a user submits information to
    the server. This is shown highlighted in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Capturing a WordPress password example](img/Insert6435OT_03_31.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To view the raw packets, we need to click on this packet line, right-click
    on it to bring up the options, and then select **Follow TCP String**. This will
    open a process string and bring up the raw login data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Capturing a WordPress password example](img/Insert6435OT_03_32.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the raw data capture previously shown, we can see lots of useful data (key
    items are distorted since this is a live server). The line to note is the one
    containing **log=** showing the user name and **pwd=** showing the password in
    clear text.
  prefs: []
  type: TYPE_NORMAL
- en: TShark
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TShark is the command-line version of Wireshark. If you have to run Wireshark
    from a Raspberry pi, TShark is the best option. Consider TShark as an alternative
    to using tcpdump for capturing packets.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run TShark, simply type `tshark` in a command-line terminal and it will
    select an available interface. You can also manually select the interface to capture
    by using `tshark eth0` to select the `eth0` port. The following screenshot shows
    `tshark` doing a basic capture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![TShark](img/6435OT_03_A.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You will most probably want to capture data to a file so that you can export
    it to your C&C server. You can specify a file to save the captured data by using
    the `tshark –w [file name].cap` command. The following screenshot shows running
    a capture that saves the data to a file named `capture.cap`. We can show this
    file using the `ls` command once we stop the capture using the *Ctrl* + *C* command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![TShark](img/6435OT_03_B.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you don't stop a TShark capture, at some point you will run out of memory.
    To avoid this, you can specify how many packets you want to capture by adding
    `–c [number]` to the command. In our example, we could have used the command `tshark
    –c 500 –w capture.cap` to capture five hundred packets before stopping. This is
    the ideal situation when performing a targeted penetration test, meaning you specify
    the available storage space for your capture, save that information to a file,
    and export it to your C&C server using the steps covered in this book. We covered
    a similar process by creating a script that did this using tcpdump. You could
    adjust that script to run TShark rather than tcpdump if you want an alternative
    option for the packet capture tool.
  prefs: []
  type: TYPE_NORMAL
- en: Beating HTTPS with SSLstrip
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One defense that host systems have against man-in-the-middle attacks on web
    servers is SSL encryption. You typically run into this when you access a sensitive
    service such as online banking or online shopping. Many browsers showcase that
    HTTPS is in place by displaying a little lock giving the end user a sense of security.
  prefs: []
  type: TYPE_NORMAL
- en: Thanks to a security researcher Moxie Marlinspike, this layer of defense can
    be bypassed using SSLstrip. SSLstrip works by proxying HTTPS requests from the
    victim and sending them using HTTP. The HTTP traffic is not encrypted, making
    it vulnerable to eavesdropping. Once SSLstrip forces the HTTP connection, an attacker
    can use tcpdump to view the unencrypted login credentials of people accessing
    accounts such as Facebook.
  prefs: []
  type: TYPE_NORMAL
- en: The **HTTP Strict Transport Security** (**HSTS**) specification was subsequently
    developed to combat these attacks; however, deployment of HSTS has been slow.
    Also, some businesses such as online banking are adopting the policy of not hosting
    an HTTP version of their website, which would show a message saying "page not
    found" on the host if this attack is performed. Unfortunately, many other businesses
    would rather host an HTTP and HTTPS version of their website to avoid looking
    as if their website is down regardless of the risk of a man-in-the-middle attack
    with SSLstrip. For this and other reasons, SSLstrip attacks are still commonly
    seen today.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an SSLstrip attack between a host and the Internet, which is
    trying to access his/her Facebook account. The following screenshot shows how
    communication should happen between the user and Facebook:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Beating HTTPS with SSLstrip](img/Insert6435OT_03_33.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When a man-in-the-middle SSLstrip attack is involved, the SSL encrypted session
    is prevented and HTTP responses are sent back to the victim. As they send information,
    they do not know that the information is in plain text and is easy to view with
    a network sniffer.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following image shows the SSL connection intercepted by SSLstrip:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Beating HTTPS with SSLstrip](img/Insert6435OT_03_34.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The use case for a Raspberry Pi with Kali Linux is placing the attack system
    on a network and scanning for systems to attack. Using the steps in this section,
    an attacker can perform a man-in-the-middle SSLstrip attack against internal users
    with the goal of mining user passwords.
  prefs: []
  type: TYPE_NORMAL
- en: Launching an SSLstrip attack
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An SSLstrip attack is launched using the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: The Kali Linux ARM image doesn't come with an installed SSLstrip, so before
    we do anything, we must download it. Issue the `apt-get install sslstrip` command
    to download the utility.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The first thing we need to do once we install SSLstrip is launch an ARP spoof.
    This was covered earlier in this chapter, so we will quickly cover the ARP spoofing
    process. To summarize the steps, do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enable IP forward using `echo 1 > /proc/sys/net/ipv4/ip_forward`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identify the default gateway and subnet mask using `netstat –nr`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `nmap` to identify a target on the network using `nmap –Rsn [network/subnet
    mask]`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Start ARP cache poisoning using `arpspoof –i eth0 –t [target IP] –r [default
    gateway]`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This will show traffic from the ARP cache poisoning. Leave this window open
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once this is running, you should start seeing the ARP spoofing traffic as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Launching an SSLstrip attack](img/Insert6435OT_03_35.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Once the ARP cache poisoning is set up, open a new terminal window to set up
    port redirection using `iptables`. This enables the attacker to capture traffic
    sent to an HTTP server on TCP 80 and redirect that traffic to the SSLstrip listener
    port. The attacker can use any applicable value. For example, we will show this
    using `8080` for both the destination port and the redirection destination using
    the following command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The selected redirection destination must also be used for setting the listener
    port for the SSLstrip.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the launch of the preceding command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Launching an SSLstrip attack](img/Insert6435OT_03_36.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To disable the `PREROUTING` rule in this command, replace the `–A` with a `–D`
    to clear all table rules used.
  prefs: []
  type: TYPE_NORMAL
- en: To flush, use the command `iptables –t nat –F`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To verify, use the command `iptables –t nat –L`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: ARP spoof has many configuration options. You can use the `man tables` command
    to see additional options.
  prefs: []
  type: TYPE_NORMAL
- en: Launch the SSLstrip attack. For this example, we will use TCP `8080` as the
    listening port. So, the command will be `sslstrip -l 8080,` as shown in the following
    screenshot:![Launching an SSLstrip attack](img/Insert6435OT_03_37.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To see the results of your attack, open another terminal window and type `tail
    –n 50 –f sslstrip.log`.
  prefs: []
  type: TYPE_NORMAL
- en: To test this attack, open a web browser on a victim's system and access a system
    requiring access using SSL encryption such as online mail. Go back to your terminal
    window showing the `sslstrip.log` file and you should see the username and password
    in clear text, as highlighted in the following screenshot. This data can be packaged
    in a text file so that an attacker can retrieve it at a later time.
  prefs: []
  type: TYPE_NORMAL
- en: '![Launching an SSLstrip attack](img/Insert6435OT_03_38.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This attack is limited to the LAN networks.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we started using the Raspberry Pi with Kali Linux for penetration
    testing purposes. We first covered how to use nmap to assess a network for devices,
    ports, and other data points for possible exploitation. Next, we looked at how
    to crack wireless networks so that we could access the network and run nmap or
    other scanning tool sets.
  prefs: []
  type: TYPE_NORMAL
- en: Once we covered basic network reconnaissance for LAN and wireless, we looked
    at a few attack techniques that could be launched while on the network. The first
    attack that we covered was performing a man-in-the-middle attack with the purpose
    of getting data through the Raspberry Pi. Later, we covered how to break SSL encryption
    while monitoring traffic between a trusted source and a victim. We also included
    how to tune packet captures and export data to avoid crashing the Raspberry Pi.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will look at how to leverage the Raspberry Pi to compromise
    systems and advanced tactics to capture sensitive data.
  prefs: []
  type: TYPE_NORMAL
