- en: Chapter 5. Web Header Manipulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Testing HTTP methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fingerprinting servers through HTTP headers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing for insecure headers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Brute forcing login through the Authorization header
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing for clickjacking vulnerabilities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identifying alternative sites by spoofing user agents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing for insecure cookie flags
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Session fixation through a cookie injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A key area of penetration testing web servers is to focus in deep on the server's
    ability to handle requests and serve responses. If you're penetration testing
    a standard web server deployment, for example Apache or Nginx, then you will want
    to concentrate on breaking the configuration that's been deployed and enumerating/manipulating
    the content of the site. If it's a custom web server that you're penetration testing,
    then it's a good idea to have a copy of the HTTP RFC handy (available at [http://tools.ietf.org/html/rfc7231](http://tools.ietf.org/html/rfc7231))
    and to additionally test how the web server handles corrupted packets or unexpected
    requests.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will focus on creating recipes that manipulate requests in a way
    that should uncover the underlying web technologies and parse responses to highlight
    common issues or key areas for further testing.
  prefs: []
  type: TYPE_NORMAL
- en: Testing HTTP methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A good place to start with testing web servers is at the beginning of the `HTTP`
    request, by enumerating the `HTTP` methods. The `HTTP` method is sent by the client
    and indicates to the web server the type of action that the client is expecting.
  prefs: []
  type: TYPE_NORMAL
- en: As specified in RFC 7231, all web servers must support `GET` and `HEAD` methods,
    and all other methods are optional. As there are a lot of common methods beyond
    the initial `GET` and `HEAD` methods, this makes it a good place to focus testing
    on, as each server will be written to handle requests and send responses in a
    different way.
  prefs: []
  type: TYPE_NORMAL
- en: An interesting `HTTP` method to look out for is `TRACE`, as its availability
    leads to **Cross Site Tracing** (**XST**). TRACE is a loop-back test and basically
    echoes the request it receives back to the user. This means it can be used for
    Cross-site scripting attacks (called in this case Cross Site Tracing). To do this,
    the attacker gets a victim to send a `TRACE` request, with a JavaScript payload
    in the body, which would then get executed locally when returned. Modern browsers
    now have defenses built-in to protect the user from these attacks by blocking
    TRACE requests made through JavaScript, so this technique now only works against
    old browsers or when leveraging other technologies such as Java or Flash.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we are going to connect to the target web server and attempt
    to enumerate the various `HTTP` methods available. We shall also be looking for
    the presence of the `TRACE` method and highlighting it, if available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first line imports the requests library; this will be used a lot in this
    section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The next line creates an array of the `HTTP` methods we are going to send.
    Notice the standard ones—`GET`, `POST`, `PUT`, `HEAD`, `DELETE,` and `OPTIONS`—followed
    by a non-standard `TEST` method. This has been added to check how the server handles
    input that it''s not expecting. Some web frameworks treat a non-standard verb
    as a `GET` request and respond accordingly. This can be a good way to bypass firewalls,
    as they may have a strict list of methods to match against and not process requests
    from unexpected methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Next is the main loop of the script. This part sends the HTTP packet; in this
    case, to the target `http://packtpub.com` web server. It prints out the method
    and the response status code and reason:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, there is a section of code to specifically test for XST:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This code checks the server response when sending a `TRACE` call, checking to
    see if the response contains the request text.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the script gives the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/B04044_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here, we can see that the web server is correctly handling the first five requests,
    returning a `200 OK` response for all these methods. The `TRACE` response returns
    `405 Not Allowed`, showing that this has been explicitly denied by the web server.
    One interesting thing with the target server here is that it returns a `200 OK`
    response for the `TEST` method. This means that the server is processing the `TEST`
    request as a different method; for example, it's treating it as a `GET` request.
    As earlier mentioned, this makes a good way to bypass some firewalls, as they
    may not process the unexpected `TEST` method.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we've shown how to test a target web server for the XST vulnerability
    and test how it handles various `HTTP` methods. This script could be extended
    further by expanding the example `HTTP` method array to include various other
    valid and invalid data values; perhaps you could try sending Unicode data to test
    how the web server handles unexpected character sets or send a very long HTTP
    method and to test for buffer overflows in custom web servers. A good resource
    for this data is to check back to the fuzzing scripts in [Chapter 3](ch03.html
    "Chapter 3. Vulnerability Identification"), *Vulnerability Identification*, for
    example, using payloads from Mozilla's FuzzDB.
  prefs: []
  type: TYPE_NORMAL
- en: Fingerprinting servers through HTTP headers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next part of the HTTP protocol that we will be concentrating on are the
    HTTP headers. Found in both the requests and responses from the web server, these
    carry extra information between the client and server. Any area with extra data
    makes a great place to parse information about the servers and to look for potential
    issues.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following is a simple header grabbing script that will parse the response
    headers in an attempt to identify the web server technology in use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first part of the script makes a simple `GET` request to the target web
    server, through the familiar `requests` library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we generate an array of headers to look out for:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In this script, we have used a try/except block around the main code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We need this error handling because headers are not mandatory; therefore, if
    we tried to retrieve a key from the array for a header that didn't exist, Python
    would raise an exception. To overcome this, we simply print out `Not found` if
    the specified header wasn't present in the response.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a screenshot of the output from running the script against
    the target server in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/B04044_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The first output line show the `Server` header, which displays the underlying
    web server technology. This is a great place for finding vulnerable web server
    versions, but be aware that it is possible to disable and also spoof this header,
    so don't explicitly rely on this for guessing the target server platform.
  prefs: []
  type: TYPE_NORMAL
- en: The `Date` header contains useful information that can be used to guess where
    the server is located. For example, you can figure out the time difference relative
    to your local time zone to give a rough indication of where it is.
  prefs: []
  type: TYPE_NORMAL
- en: The `Via` header is used by proxies, both outgoing and incoming, and will display
    the proxy name, in this case `1.1 varnish`.
  prefs: []
  type: TYPE_NORMAL
- en: The `X-Powered-By` is a standard header used in common web frameworks such as
    PHP. A default PHP installation will respond with PHP and the version number,
    making it another great target for reconnaissance.
  prefs: []
  type: TYPE_NORMAL
- en: The final line prints the `X-Country-Code` short code, another useful piece
    of information to identify where the server is located.
  prefs: []
  type: TYPE_NORMAL
- en: Be aware that all these headers can be set or overridden on the server side,
    so do not rely on this information explicitly and be wary of parsing data directly
    from remote servers; even these headers could contain malicious values.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This script currently contain the version of the server, but it could then be
    extended further to query online CVE databases, such as [https://cve.mitre.org/cve/](https://cve.mitre.org/cve/),
    looking for vulnerabilities affecting the web server version.
  prefs: []
  type: TYPE_NORMAL
- en: Another technique that can be used to increase the confidence of fingerprinting
    is to check the order of the response headers. For example, Microsoft IIS returns
    the `Server` header before the `Date` header, whereas Apache returns `Date` and
    then `Server`. This slightly different ordering can be used to verify any server
    versions that you may have deduced from the header values in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Testing for insecure headers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've previously seen how the HTTP responses can be a great source of information
    for enumerating the underlying web framework in place. We are now going to take
    this to the next level by using the `HTTP` header information to test for insecure
    web server configurations and flagging up anything that can lead to a vulnerability.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, you will need a list of URLs that you want to test for insecure
    headers. Save these into a text file called `urls.txt`, with each URL on a new
    line, alongside your recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following code will highlight any vulnerable headers received in the HTTP
    response from each of the target URLs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This recipe is configured for testing many sites, so the first part reads in
    the URLs from the text file and prints out the current target:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Each header is then tested inside a try/except block. This is similar to the
    previous recipe in which this coding style is needed because the headers are not
    mandatory. If we attempted to reference a key for a header that doesn't exist,
    Python would raise an exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first `X-XSS-Protection` header should be set to `1; mode=block` to enable
    XSS protection in the browser. The script prints out a warning if the header does
    not explicitly match that format or if it''s not set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The next `X-Content-Type-Options` header should be set to `nosniff` to prevent
    MIME type confusion. A MIME type specifies the content of the target resource,
    for example, text/plain means the remote resource should be a text file. Some
    web browsers attempt to guess the MIME type of a resource if it''s not specified.
    This can lead to Cross-site scripting attacks; if a resource contains a malicious
    script, but it only indicates to be a plain text file, it may bypass content filters
    and be executed. This check will print a warning if the header is not set or if
    the response does not explicitly match to `nosniff`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The next `Strict-Transport-Security` header is used to force communication
    over a HTTPS channel, to prevent **man in the middle** (**MITM**) attacks. The
    lack of this header means that the communication channel could be downgraded to
    HTTP by an MITM attack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The final `Content-Security-Policy` header is used to restrict the type of
    resources that can load on the web page, for example, restricting where JavaScript
    can run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The output from the recipe is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/B04044_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Brute forcing login through the Authorization header
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many websites use HTTP basic authentication to restrict access to content. This
    is especially prevalent in embedded devices such as routers. The Python `requests`
    library has built-in support for basic authentication, making an easy way to create
    an authentication brute force script.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before creating this recipe, you're going to need a list of passwords to attempt
    to authenticate with. Create a local text file called `passwords.txt`, with each
    password on a new line. Check out Brute forcing passwords in [Chapter 2](ch02.html
    "Chapter 2. Enumeration"), *Enumeration*, for password lists from online resources.
    Also, spend some time to scope out the target server as you're going to need to
    know how it responds to a failed login request, so that we can differentiate when
    the brute force works or not.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following code will attempt to brute force entry to website through basic
    authentication:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first part of this script reads in the password list, line by line. Then,
    it sends an HTTP `GET` request to the login page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This request has an additional `auth` parameter, which contains the username
    `admin` and the `password` read from the `passwords.txt` file. When sending an
    HTTP request with a basic `Authorization` header, the raw data looks like the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/B04044_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Notice that in the `Authorization` header the data is sent in an encoded format,
    such as `YWRtaW46cGFzc3dvcmQx`. This is the username and password in a `base64`
    encoded form of `username:password`; the `requests.auth.HTTPBasicAuth` class just
    does this conversion for us. This can be verified by using the `base64` library,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/B04044_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Knowing this information means that you could still get the script to run without
    the external requests library; instead, it crafts an `Authorization` header manually
    using the `base64` default library.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a screenshot of the brute force script in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/B04044_05_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, we've used a fixed username of admin in the authorization request,
    as this was known. If this is unknown, you could create a `username.txt` text
    file and loop through each of those lines too, just as we've done with the password
    text file. Note that this is a much slower process and creates a lot of HTTP requests
    to the target site, which is likely to get you blacklisted, unless you implement
    rate limiting.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Check out the *Checking username validity* and *Brute forcing usernames* recipes
    in [Chapter 2](ch02.html "Chapter 2. Enumeration"), *Enumeration*, for further
    ideas on username and password combinations.
  prefs: []
  type: TYPE_NORMAL
- en: Testing for clickjacking vulnerabilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Clickjacking is a technique used to trick users into performing actions on a
    target site without them realizing. This is done by a malicious user placing a
    hidden overlay on top of a legitimate website, so when the victim thinks they
    are interacting with the legitimate site, they are really clicking on hidden items
    on the hidden top overlay. This attack can be crafted in such a way that it causes
    the victim to type in credentials or click and drag on items without realizing
    they are being attacked. These attacks can be used against banking sites to trick
    victims into transferring funds and were also common among social networking sites
    in an attempt to gain more followers or likes, although most have defensive measures
    in place now.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two main ways websites can prevent clickjacking: either by setting
    an `X-FRAME-OPTIONS` header, which tells the browser not to render the site if
    it''s inside a frame, or by using JavaScript to escape out of frames (commonly
    known as frame-busting). This recipe will show you how to detect both defenses
    so that you can identify websites that have neither:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first part of this script checks for the first clickjacking defense, the
    `X-FRAME-OPTIONS` header, in a similar fashion as we''ve seen in the previous
    recipe. `X-FRAME-OPTIONS` takes three values: `DENY`, `SAMEORIGIN`, or `ALLOW-FROM
    <url>`. Each of these values give a different level of protection against clickjacking,
    so, in this recipe, we are attempting to detect the lack of any:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The next part of the code creates a local html `clickjack.html` file, containing
    a few very simple lines of HTML code, and saves them into a local `clickjack.html`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This HTML code creates an iframe with the source set to the target website.
    The HTML file will be loaded into ghost in an attempt to render the website and
    detect if the target site is loaded in the iframe. Ghost is a WebKit rendering
    engine, so it should be similar to what would happen if the site is loaded in
    a Chrome browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next part sets up ghost logging to redirect to a local log file (the default
    is printing to `stdout`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The next line renders the local HTML page in ghost and contain any extra resources
    that were requested by the target page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We then open the log file and check for the `X-FRAME-OPTIONS` error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The next part of the script checks for framebusting; if the iframe has JavaScript
    code to detect it''s being loaded inside an iframe it will break out of the frame,
    causing the page to redirect to the target website. We can detect this by executing
    JavaScript in ghost with `ghost.evaluate` and reading the current location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The final part of code is for clean-up, closing any open files or any open
    logging handlers, and deleting the temporary HTML and log files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'If the script outputs `Frame busting not detected, page is likely vulnerable
    to clickjacking`, then the target website can be rendered inside a hidden iframe
    and used in a clickjacking attack. An example of the log from a vulnerable site
    is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/B04044_05_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you view the generating clickjack.html file in a web browser, it will confirm
    that the target web server can be loaded in an iframe and is therefore susceptible
    to clickjacking, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/B04044_05_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Identifying alternative sites by spoofing user agents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some websites restrict access or display different content-based on the browser
    or device you're using to view it. For example, a web site may show a mobile-oriented
    theme for users browsing from an iPhone or display a warning to users with an
    old and vulnerable version of Internet Explorer. This can be a good place to find
    vulnerabilities because these might have been tested less rigorously or even forgotten
    about by the developers.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will show you how to spoof your user agent, so you appear
    to the website as if you''re using a different device in an attempt to uncover
    alternative content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We first set up an array of user agents, with a friendly name assigned to each
    key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'There are four user agents here: Chrome on Windows 8.1, Safari on iOS, Internet
    Explorer 6 on Windows XP, and finally, the Googlebot. This gives a wide range
    of browsers and examples of which you would expect to find different content behind
    each request. The final user agent in the list, Googlebot, is the crawler that
    Google sends when spidering data for their search engine.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The next part loops through each of the user agents and sets the `User-Agent`
    header in the request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The next section sends the HTTP request, using the familiar requests library,
    and stores each response in the responses array, using the user friendly name
    as the key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The next part of the code creates an `md5s` array and then iterates through
    the responses, grabbing the `response.text` file. From this, it generates an `md5`
    hash of the response content and stores it into the `md5s` array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The final part of the code iterates through the `md5s` array and compares each
    item to the original baseline request, in this recipe `Chrome on Windows 8.1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We hashed the response text so that it keeps the resulting array small, thus
    reducing the memory footprint. You could compare each response directly by its
    content, but this would be slower and use more memory to process.
  prefs: []
  type: TYPE_NORMAL
- en: 'This script will print out the user agent friendly name if the response from
    the web server is different from the Chrome on Windows 8.1 baseline response,
    as seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/B04044_05_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe is based upon being able to manipulate headers in the HTTP requests.
    Check out *Header-based Cross-site scripting* and *Shellshock checking* sections
    in [Chapter 3](ch03.html "Chapter 3. Vulnerability Identification"), *Vulnerability
    Identification*, for more examples of data that can be passed into the headers.
  prefs: []
  type: TYPE_NORMAL
- en: Testing for insecure cookie flags
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next topic of interest from the HTTP protocol is cookies. As HTTP is a stateless
    protocol, cookies provide a way to store persistent data on the client side. This
    allows a web server to have session management by persisting data to the cookie
    for the length of the session.
  prefs: []
  type: TYPE_NORMAL
- en: Cookies are set from the web server in the HTTP response using a `Set-Cookie`
    header. They are then sent back to the server through the `Cookie` header. This
    recipe will look at ways to audit the cookies being set by a website to verify
    if they have secure attributes or not.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following is a recipe to enumerate through each of the cookies set on a
    target site and flag any insecure settings that are present:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We enumerate each cookie sent from the web server and check their attributes.
    The first two attributes are the `name` and `value` of the cookie:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We then check for the `secure` flag on the cookie:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The `Secure` flag on a cookies means it is only sent over HTTPS. This is good
    for cookies used for authentication because it means they can't be sniffed over
    the wire if, for example, someone is monitoring open network traffic.
  prefs: []
  type: TYPE_NORMAL
- en: Also note that the `\x1b[31m` code is a special ANSI escape code used to change
    the color of the terminal font. Here, we've highlighted the headers that are insecure
    in red. The `\x1b[39;49m` code resets the color back to default. See the Wikipedia
    page on ANSI for more information at [http://en.wikipedia.org/wiki/ANSI_escape_code](http://en.wikipedia.org/wiki/ANSI_escape_code).
  prefs: []
  type: TYPE_NORMAL
- en: 'The next check is for the `httponly` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: If this is set to `True`, it means JavaScript cannot access the contents of
    the cookie, and it is sent to the browser and can only be read by the browser.
    This is used to mitigate against XSS attempts, so when penetration testing, the
    lack of this cookie attribute is a good thing.
  prefs: []
  type: TYPE_NORMAL
- en: 'We finally check for the domain in the cookie, to see if it starts with a dot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: If the `domain` attribute of the cookie starts with a dot, it indicates the
    cookie is used across all subdomains and therefore possibly visible beyond the
    intended scope.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows how the insecure flags are highlighted in red
    for the target website:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/B04044_05_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We've previously seen how to enumerate the technologies used to serve a website
    by extracting the headers. Certain frameworks also store information in the cookie,
    for example, PHP creates a cookies called **PHPSESSION** , which is used to store
    session data. Therefore, the presence of this data indicates the use of PHP, and
    the server can then be enumerated further in an attempt to test it for known PHP
    vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Session fixation through a cookie injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Session fixation is a vulnerability that relies on re-use of a session ID. First,
    the attacker must be able to force the victim to use a specific session ID by
    setting a cookie on their client or by already knowing the value of the victim's
    session ID. Then, when the victim authenticates, the cookies remain the same on
    the client. Therefore, the attacker knows the session ID and now has access to
    the victim's session.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe will require some initial reconnaissance performed against the target
    site to identify how it's performs authentication, for example through data in
    the `POST` requests or through basic `auth`. It will also require a valid user
    account to authenticate with.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This recipe will be testing for session fixation through a cookie injection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This script has two stages; the first step is sending an initial `get` request
    to the target website and then displaying the cookies received:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The second stage of the script sends another request to the target site, this
    time authenticating with valid user credentials:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Notice here that we set the request cookies to the cookies that we received
    in the initial `GET` request earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'The script ends by printing out the final cookie state and printing a warning
    if the authenticated cookies match the cookies that were sent in the initial request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Cookies are another data source that is user-controlled and parsed by the web
    server. Similar to headers, this makes it a great place to test for XSS vulnerabilities.
    Try adding XSS payloads to cookie data and sending it to the target server to
    see how it handles the data. Remember that cookies may be read in from the web
    server backend or may be printed out to the logs, and therefore XSS might be possible
    against the log reader (if, for example, it's later read by an admin).
  prefs: []
  type: TYPE_NORMAL
