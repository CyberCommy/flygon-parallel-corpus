- en: Cluster Administration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've learned most of our basic DevOps skills with Kubernetes in previous chapters,
    from how to containerize our application to deploying our containerized software
    into Kubernetes seamlessly via continuous deployment. Now, it's time to have a
    deeper insight into how to administer a Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll learn:'
  prefs: []
  type: TYPE_NORMAL
- en: How to utilize namespaces to set administrative boundaries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using kubeconfig to switch between multiple clusters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kubernetes authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kubernetes authorization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While minikube is a fairly simple environment, we will use the **Google Container
    Engine** (**GKE**) and self-hosted cluster in AWS as the example, instead of minikube
    in this chapter. For the detailed setting, please refer to [Chapter 9](part0226.html#6NGV40-6c8359cae3d4492eb9973d94ec3e4f1e),
    *Kubernetes on AWS*, and [Chapter 10](part0247.html#7BHQU0-6c8359cae3d4492eb9973d94ec3e4f1e),
    *Kubernetes on GCP*.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes namespaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Kubernetes has a namespace concept to divide the resources from a physical
    cluster to multiple virtual clusters. In this way, different groups could share
    the same physical cluster with isolation. Each namespace provides:'
  prefs: []
  type: TYPE_NORMAL
- en: A scope of names; object name in each namespace is unique
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Policies to ensure trusted authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ability to set up resource quotas for resource management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Namespaces are ideal for different teams or projects in the same company, so
    different groups can have their own virtual clusters, which have the resource
    isolation but share the same physical cluster. Resources in one namespace are
    invisible from other namespaces. Different resource quotas could be set to different
    namespaces and provide different levels of QoS. Note that not all objects are
    in a namespace, such as nodes and Persistent Volumes, which belong to entire clusters.
  prefs: []
  type: TYPE_NORMAL
- en: Default namespaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By default, Kubernetes has three namespaces: `default`, `kube-system` and `kube-public`.
    The `default` namespace contains the objects which are created without specifying
    any namespace, and `kube-system` contains the objects which are created by Kubernetes
    systems, usually used by the system components, such as Kubernetes dashboard or
    Kubernetes DNS. The `kube-public` is newly introduced in 1.6, which intends to
    locate the resources that everybody can access. It mainly focuses on public ConfigMap
    now, such as cluster info.'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new namespace
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s see how to create a namespace. A namespace is also a Kubernetes object.
    We could just specify the kind as a namespace like other objects. Below is the
    example to create one namespace, `project1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Then let''s try to start two nginx containers via deployment in `project1`
    namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'When we list pods by `kubectl get pods`, we''ll see nothing in our cluster.
    Why? Because Kubernetes uses the current context to decide which namespace is
    current. If we don''t explicitly specify namespace in the context or `kubectl`
    command line, the `default` namespace will be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: You could use `--namespace <namespace_name>`, `--namespace=<namespace_name>`,
    `-n <namespace_name>` or `-n=<namespace_name>` to specify the namespace for a
    command. To list the resources across namespaces, use `--all-namespaces` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Another way is changing the current context to point to the desired namespace
    rather than the default namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Context
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Context** is a concept of the combination of cluster information, a user
    for authentication and a namespace. For example, the following is the context
    information for one of our clusters in GKE:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We could use the `kubectl config current-context` command to see the current
    context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: To list all config info including contexts, you could use the `kubectl config
    view` command; to checkout what context is currently in use, use `kubectl config
    get-contexts` command.
  prefs: []
  type: TYPE_NORMAL
- en: Create a context
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next step is to create a context. As in the preceding example, we''ll need
    to set a user and cluster name for the context. If we don''t specify those, the
    empty value will be set. The command to create a context is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Multiple contexts could be created in the same cluster. The following is an
    example of how to create a context for `project1` in my GKE cluster `gke_devops-with-kubernetes_us-central1-b_cluster`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Switch the current context
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Then we could switch the context by the `use-context` sub-command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'After the context is switched, every command we invoke via `kubectl` is under
    the `project1` context. We don''t need to explicitly specify the namespace to
    see our pods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: ResourceQuota
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By default, pods in Kubernetes are resource-unbounded. Then the running pods
    might use up all the compute or storage resources in a cluster. ResourceQuota
    is a resource object that allows us to restrict the resource consumption that
    a namespace could use. By setting up the resource limit, we could reduce the noisy
    neighbor symptom. The team working for `project1` won't use up all the resources
    in the physical cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we can ensure the quality of service for other teams working in other
    projects which share the same physical cluster. There are three kinds of resource
    quotas supported in Kubernetes 1.7\. Each kind includes different resource names,
    ([https://kubernetes.io/docs/concepts/policy/resource-quotas](https://kubernetes.io/docs/concepts/policy/resource-quotas)):'
  prefs: []
  type: TYPE_NORMAL
- en: Compute resource quota (CPU, memory)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storage resource quota (requested storage, Persistent Volume Claims)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Object count quotas (pods, RCs, ConfigMaps, services, LoadBalancers)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Created resources won't be affected by newly created resource quotas. If the
    resource creation request exceeds the specified ResourceQuota, the resources won't
    be able to start up.
  prefs: []
  type: TYPE_NORMAL
- en: Create a ResourceQuota for a namespace
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s learn the syntax of `ResourceQuota`. Below is one example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The template is like other objects, just this kind becomes `ResourceQuota`.
    The quota we specified is valid across the pods which are in a succeeded or failed
    state (that is, non-terminal state). There are several resource constraints that
    are supported. In the preceding example, we demonstrate how to set compute ResourceQuota,
    storage ResourceQuota and object CountQuota. Any time, we could still use the
    `kubectl` command to check the quota we set: `kubectl describe resourcequota <resource_quota_name>`.'
  prefs: []
  type: TYPE_NORMAL
- en: Right now let's modify our existing nginx Deployment by the command `kubectl
    edit deployment nginx`, changing replica from `2` to `4` and save. Let's list
    the state now.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'It indicates some pods failed on creation. If we check the corresponding ReplicaSet,
    we could find out the reason:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we''ve specified the request limits on memory and CPU, Kubernetes doesn''t
    know the default request limits on the newly desired three pods. We could see
    the original two pods are still up and running, since the resource quota doesn''t
    apply to existing resources. We now then use `kubectl edit deployment nginx` to
    modify container specs as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00116.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, we specify the requests and limits for CPU and memory in the pod spec.
    It indicates the pod can''t exceed the specified quota, otherwise it will be unable
    to start:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Available pods become four instead of two, but still not equal to our desired
    four. What went wrong? If we take a step back and check our resource quota, we
    can find we''ve used all the quota of pods. Since Deployments use the rolling
    update deployment mechanism by default, it''ll require pod numbers larger than
    four, which is exact object limit we set earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: After modifying the pods quota from `4` to `8` by `kubectl edit resourcequota
    project1-resource-quota` command, the Deployment has sufficient resource to launch
    the pods. Once the `Used` quota exceeds the `Hard` quota, the request will be
    rejected by the ResourceQuota admission controller, otherwise, the resource quota
    usage will be updated to ensure sufficient resource allocation.
  prefs: []
  type: TYPE_NORMAL
- en: Since ResourceQuota won't affect already created resources, sometimes we might
    need to tweak the failed resources, such as deleting an empty change set of RS
    or scale up and down Deployment, in order to let Kubernetes create new pods or
    RS which will soak the latest quota limits.
  prefs: []
  type: TYPE_NORMAL
- en: Request pods with default compute resource limits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We could also specify default resource requests and limits for a namespace.
    Default setting will be used if we don't specify the requests and limits during
    pod creation. The trick is using `LimitRange` resource object. A `LimitRange`
    object contains a set of `defaultRequest` (request) and `default` (limits).
  prefs: []
  type: TYPE_NORMAL
- en: LimitRange is controlled by the LimitRanger admission controller plugin. Be
    sure you enable it if you launch a self-hosted solution. For more information,
    check out the admission controller section in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Below is an example where we set `cpu.request` as `250m` and `limits` as `500m`,
    `memory.request` as `256Mi` and `limits` as `512Mi`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: When we launch pods inside this namespace, we don't need to specify the `cpu`
    and `memory` requests and `limits` anytime, even if we have a total limitation
    set inside ResourceQuota.
  prefs: []
  type: TYPE_NORMAL
- en: The unit of CPU is core, which is an absolute quantity. It can be an AWS vCPU,
    a GCP core or a hyperthread on a machine with hyperthreading processor equipped.
    The unit of memory is a byte. Kubernetes uses the first alphabet or power-of-two
    equivalents. For example, 256M would be written as 256,000,000, 256 M or 244 Mi.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, we can set minimum and maximum CPU and memory values for a pod
    in LimitRange. It acts differently as default values. Default values are only
    used if a pod spec doesn't contain any requests and limits. The minimum and maximum
    constraint is used for verifying if a pod requests too much resource. The syntax
    is `spec.limits[].min` and `spec.limits[].max`. If the request exceeds the minimum
    and maximum values, forbidden will be thrown from the server.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Quality of service for pods: There are three QoS classes for pods in Kubernetes:
    Guaranteed, Burstable and BestEffort. It''s tied together with the namespace and
    resource management concept we learned above. We also learned QoS in [Chapter
    4](part0103.html#3279U0-6c8359cae3d4492eb9973d94ec3e4f1e), *Working with Storage
    and Resources*. Please refer to the last section *Kubernetes Resource Management*
    in [Chapter 4](part0103.html#3279U0-6c8359cae3d4492eb9973d94ec3e4f1e), *Working
    with Storage and Resources* for recap.'
  prefs: []
  type: TYPE_NORMAL
- en: Delete a namespace
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just like any other resources, deleting a namespace is `kubectl delete namespace
    <namespace_name>`. Please be aware that if a namespace is deleted, all the resources
    associated with that namespace will be evicted.
  prefs: []
  type: TYPE_NORMAL
- en: Kubeconfig
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kubeconfig is a file that you can use to switch multiple clusters by switching
    context. We can use `kubectl config view` to view the setting. The following is
    an example of a minikube cluster in a `kubeconfig` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like what we learned previously. We could use `kubectl config use-context`
    to switch the cluster to manipulate. We could also use `kubectl config --kubeconfig=<config
    file name>` to specify which `kubeconfig` file we''d like to use. Only the specified
    file will be used. We could also specify `kubeconfig` files by the environment
    variable `$KUBECONFIG`. In this way, config files could be merged. For example,
    the following command will merge `kubeconfig-file1` and `kubeconfig-file2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: You might find we didn't do any specific setting previously. Then where does
    the output of `kubectl config view` come from? By default, it exists under `$HOME/.kube/config`.
    This file will be loaded if none of the preceding are set.
  prefs: []
  type: TYPE_NORMAL
- en: Service account
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Unlike normal users, **service account** is used by processes inside a pod
    to contact the Kubernetes API server. By default, a Kubernetes cluster creates
    different service accounts for different purposes. In GKE, there are bunch of
    service accounts that have been created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Kubernetes will create a default service account in each namespace, which will
    be used if no service account is specified in pod spec during pod creation. Let''s
    take a look at how the default service account acts for our `project1` namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We could see a service account is basically using mountable secrets as a token.
    Let''s dig into what contents are inside the token:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The secret will be automatically mounted to the directory `/var/run/secrets/kubernetes.io/serviceaccount`.
    When the pod accesses the API server, the API server will check the cert and token
    to do the authentication. The concept of a service account will be with us in
    the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication and authorization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Authentication and authorization are important from DevOps' point of view. Authentication
    verifies users and checks if the users are really who they represent themselves
    to be. Authorization, on the other hand, checks what permission levels users have.
    Kubernetes supports different authentication and authorization modules.
  prefs: []
  type: TYPE_NORMAL
- en: The following is an illustration that shows how the Kubernetes API server processes
    the access control when it receives a request.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00117.jpeg)Access control in API server'
  prefs: []
  type: TYPE_NORMAL
- en: When the request comes to API server, firstly, it establishes a TLS connection
    by validating the clients' certificate with the **certificate authority** (**CA**)
    in the API server. The CA in the API server is usually at `/etc/kubernetes/`,
    and the clients' certificate is usually at `$HOME/.kube/config`. After the handshake,
    it goes to the authentication stage. In Kuberentes, authentication module are
    chain-based. We could use more than one authentication and authorization modules.
    When the request comes, Kubernetes will try all the authenticators one by one
    until it succeeds. If the request fails on all authentication modules, it will
    be rejected as HTTP 401 Unauthorized. Otherwise, one of the authenticators verifies
    the user's identity and the requests are authenticated. Then Kubernetes authorization
    modules will come into play. It will verify if the user has the permission to
    do the action that they request to do by a set of policies. Authorization modules
    are also chain-based. It keeps trying every module until it succeeds. If the request
    fails on all the modules, it'll get a HTTP 403 Forbidden response. Admission control
    is a set of configurable plugins in an API server that determine if a request
    is admitted or denied. At this stage, if the request doesn't pass through one
    of the plugins, then the request is denied immediately.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By default, a service account is token-based. When you create a service account
    or a namespace with default service account, Kubernetes creates the token and
    stores it as a secret which is encoded by base64, and mounts the secret as a volume
    into the pod. Then the processes inside the pod have the ability to talk to the
    cluster. The user account, on the other hand, represents a normal user, who might
    use `kubectl` to manipulate the resource directly.
  prefs: []
  type: TYPE_NORMAL
- en: Service account authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we create a service account, a signed bearer token will be created automatically
    by the Kubernetes service account admission controller plugin.
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 7](part0163.html#4REBM0-6c8359cae3d4492eb9973d94ec3e4f1e), *Continuous
    Delivery*, in the example that we demonstrated how to do the deployment of `my-app`,
    we created a namespace named `cd`, and we used the script `get-sa-token.sh` ([https://github.com/DevOps-with-Kubernetes/examples/blob/master/chapter7/get-sa-token.sh](https://github.com/DevOps-with-Kubernetes/examples/blob/master/chapter7/get-sa-token.sh))
    to export the token for us. Then we create a user `mysa` via `kubectl config set-credentials
    <user> --token=$TOKEN` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we set the context to bind with user and namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we set our context `myctxt` as default context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: When the service account sends a request, the token will be verified by the
    API server to check if the requester is eligible and it is what it claims to be.
  prefs: []
  type: TYPE_NORMAL
- en: User account authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are several implementations for user account authentication. From client
    certificates, bearer tokens, static files to OpenID connect tokens. You can choose
    more than one as authentication chains. Here, we'll demonstrate how client certificates
    works.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 7](part0163.html#4REBM0-6c8359cae3d4492eb9973d94ec3e4f1e), *Continuous
    Delivery* we've learned how to export cert and token for service account. Now,
    let's learn how to do it for a user. Assume we are still inside `project1` namespace,
    and we want to create a user for our new DevOps member Linda, who will help us
    to do the Deployment for my-app.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll generate a private key by OpenSSL ([https://www.openssl.org](https://www.openssl.org)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''ll create a certificate sign request (`.csr`) for Linda:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Now, `linda.key` and `linda.csr` should be located in the current folder. For
    approving the sign request, we'll need to locate the CA of our Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: In minikube, it's under `~/.minikube/`. For other self-hosted solutions, normally
    it's under `/etc/kubernetes/`. If you use kops to deploy the cluster, the location
    is under `/srv/kubernetes`, where you could find the path in `/etc/kubernetes/manifests/kube-apiserver.manifest`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assume we have `ca.crt` and `ca.key` under the current folder, we could generate
    the cert by our sign request. Using the `-days` parameter we could define the
    expired date:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: After we have cert signed by our cluster, we could set a user in the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember the concept of context: it''s the combination of cluster information,
    a user for authentication and a namespace. Now, we''ll set a context entry in
    `kubeconfig`. Remember to replace your cluster name, namespace and user from the
    following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, Linda should have zero permission:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Linda now passes the authentication stage while Kubernetes knows she is Linda.
    However, to make Linda have the permission to do the Deployment, we need to set
    up the polices in authorization modules.
  prefs: []
  type: TYPE_NORMAL
- en: Authorization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Kubernetes supports several authorization modules. At the time we''re writing,
    it supports:'
  prefs: []
  type: TYPE_NORMAL
- en: ABAC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RBAC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Node authorization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Webhook
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Attribute-based access control** (**ABAC**) was the major authorization mode
    before **role-based access control** (**RBAC**) was introduced. Node authorization
    is used by kubelet to make a request to the API server. Kubernetes supports webhook
    authorization mode to establish a HTTP callback with an external RESTful service.
    It''ll do a POST whenever it faces an authorization decision. Another common way
    is you could implement your in-house module by following along the pre-defined
    authorizer interface. For more implementation information, refer to [https://kubernetes.io/docs/admin/authorization/#custom-modules](https://kubernetes.io/docs/admin/authorization/#custom-modules).
    In this section, we''ll describe more details for ABAC and RBAC.'
  prefs: []
  type: TYPE_NORMAL
- en: Attribute-based access control (ABAC)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ABAC allows admin to define a set of user authorization polices into a file
    with one JSON per line format. The major drawback of ABAC mode is the policy file
    has to exist when launching the API server. Any change in the file requires restarting
    the API server with `--authorization-policy-file=<policy_file_name>` command.
    Another authorization method RBAC was introduced since Kubernetes 1.6\. which
    is more flexible and doesn't require restarting the API server. RBAC has now become
    the most common authorization mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of how ABAC works. The format of the policy file
    is one JSON object per line. The configuration file of the policy is similar to
    our other configuration files. Just with different syntax in spec. There are four
    main properties in ABAC:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Properties type** | **Supported values** |'
  prefs: []
  type: TYPE_TB
- en: '| Subject-matching | user, group |'
  prefs: []
  type: TYPE_TB
- en: '| Resource-matching | `apiGroup`, namespace, and resource |'
  prefs: []
  type: TYPE_TB
- en: '| Non-resource-matching | Used for non-resource type requests, such as `/version`,
    `/apis`, `/cluster` |'
  prefs: []
  type: TYPE_TB
- en: '| readonly | true or false |'
  prefs: []
  type: TYPE_TB
- en: 'The following are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we have a user admin who could access everything.
    Another user named `linda` who can only read the Deployment and ReplicaSets in
    the namespace `project1`.
  prefs: []
  type: TYPE_NORMAL
- en: Role-based access control (RBAC)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: RBAC was in beta in Kubernetes 1.6, which is enabled by default. In RBAC, admin
    creates several `Roles` or `ClusterRoles`, which define the fine-grained permissions
    that specifies a set of resources and actions (verbs) that roles could access
    and manipulate. After that, admin grants the `Role` permission to users by `RoleBinding`
    or `ClusterRoleBindings`.
  prefs: []
  type: TYPE_NORMAL
- en: If you're running a minikube, add `--extra-config=apiserver.Authorization.Mode=RBAC`
    when doing `minikube start`. If you're running self-hosted cluster on AWS via
    kops, adding `--authorization=rbac` when launching the cluster. Kops launches
    API server as a pod; using `kops edit cluster` command could modify the spec of
    the containers.
  prefs: []
  type: TYPE_NORMAL
- en: Roles and ClusterRoles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A `Role` in Kubernetes is bound within a namespace, a `ClusterRole`, on the
    other hand, is cluster-wide. The following is an example of `Role`, which could
    do all the operations, including `get`, `watch`, `list`, `create`, `update`, `delete`,
    `patch` to the resources Deployment, ReplicaSet and pods.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The `apiVersion` is still `v1beta1` at the time we wrote the book. If it happens
    that the API version changes, Kubernetes will throw the error and remind you to
    change. In `apiGroups`, an empty string indicates the core API group. The API
    group is part of the RESTful API call. The core indicates original API call path,
    such as `/api/v1`. The newer REST path has the group name and API version in it,
    such as `/apis/$GROUP_NAME/$VERSION`; for looking up API groups you''d like to
    use, check out API References at [https://kubernetes.io/docs/reference](https://kubernetes.io/docs/reference).
    Under resources you could add the resources you''d like to grant the access to,
    and under verbs lists an array of actions that this role could perform. Let''s
    get into a more advanced example for `ClusterRoles`, which we used in previous
    chapter as Continuous Delivery role:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '`ClusterRole` is cluster-wide. Some resources don''t belong to any namespace,
    such as nodes, only could be controlled by `ClusterRole`. The namespaces it could
    access depends on the `namespaces` field in `ClusterRoleBinding` it associates
    with. We could see we grant the permission to allow this role read and write Deployments,
    ReplicaSets and ingresses in both extensions and apps groups. In the core API
    group, we grant only access for namespace and events, and all permission for other
    resources, such as pods and services.'
  prefs: []
  type: TYPE_NORMAL
- en: RoleBinding and ClusterRoleBinding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A `RoleBinding` is used to bind a `Role` or `ClusterRole` to a list of users
    or service accounts. If a `ClusterRole` is bound with a `RoleBinding` instead
    of a `ClusterRoleBinding`, it''ll be only granted the permissions within the namespace
    that `RoleBinding` specified. The following is an example of `RoleBinding` spec:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we bind a `Role` with a user by `roleRef`. Kubernetes supports
    different kind of `roleRef`; we could replace the kind from `Role` to `ClusterRole`
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Then `cd-role` can only access the resources in namespace `project1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, a `ClusterRoleBinding` is used to grant permission in all
    namespace. Let''s review what we did in [Chapter 7](part0163.html#4REBM0-6c8359cae3d4492eb9973d94ec3e4f1e),
    *Continuous Delivery*. We first created a service account named `cd-agent`, then
    create a `ClusterRole` named `cd-role`. At the end, we created a `ClusterRoleBinding`
    for `cd-agent` and `cd-role`. We then used `cd-agent` to do the Deployment on
    our behalf:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The `cd-agent` is bound with a `ClusterRole` via `ClusterRoleBinding`, so it
    can have the permission specified in `cd-role` across namespaces. Since a service
    account is created in a namespace, we''ll need to specify its full name including
    namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Let's launch the `Role` and `RoleBinding` via `8-5-2_role.yml` and `8-5-2_rolebinding_user.yml:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we don''t get forbidden anymore:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'What about if Linda wants to list namespaces, is it allowed?:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The answer is no, since Linda is not granted permission for listing namespaces.
  prefs: []
  type: TYPE_NORMAL
- en: Admission control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Admission control takes place before Kubernetes processes the request and after
    authentication and authorization are passed. It's enabled when launching API server
    by adding `--admission-control` parameter. Kubernetes recommends officially to
    have the following plugins with the cluster if the cluster version is >= 1.6.0.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The following introduces the usage of these plugins, and why should we need
    them. For more latest information about supported admission control plugins, please
    visit official document [https://kubernetes.io/docs/admin/admission-controllers](https://kubernetes.io/docs/admin/admission-controllers).
  prefs: []
  type: TYPE_NORMAL
- en: Namespace life cycle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we learned earlier, when a namespace is deleted, all objects in that namespace
    will be evicted as well. This plugin ensures no new object creation requests could
    be made in the namespace that is terminating or non-existed. It also prevents
    Kubernetes native namespaces from deletion.
  prefs: []
  type: TYPE_NORMAL
- en: LimitRanger
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This plugin ensures `LimitRange` could work properly. With `LimitRange`, we
    could set default requests and limits in a namespace, which will be used when
    launching a pod without specifying the requests and limits.
  prefs: []
  type: TYPE_NORMAL
- en: Service account
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The service account plugin must be added if you use service account objects.
    For more information about service account, revisit again service account section
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: PersistentVolumeLabel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`PersistentVolumeLabel` adds labels to newly-created PV, based on the labels
    provided by the underlying cloud provider. This admission controller has been
    deprecated from 1.8.'
  prefs: []
  type: TYPE_NORMAL
- en: DefaultStorageClass
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This plugin ensures default storage classes could work expectedly if no `StorageClass`
    is set in a Persistent Volume Claim. Different provisioning tools with different
    cloud providers will leverage `DefaultStorageClass` (such as GKE uses Google Cloud
    Persistent Disk). Be sure you have this enabled.
  prefs: []
  type: TYPE_NORMAL
- en: ResourceQuota
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just like the `LimitRange`, if you're using the `ResourceQuota` object to administer
    different level of QoS, this plugin must be enabled. The ResourceQuota should
    be always be put at the end of the admission control plugin list. As we mentioned
    in the ResourceQuota section, if used quota is less than hard quota, resource
    quota usage will be updated to ensure cluster have the sufficient resource for
    accepting request. Putting it into the end of admission controller list could
    prevent the request from increasing quota usage prematurely if it eventually gets
    rejected by the following controllers.
  prefs: []
  type: TYPE_NORMAL
- en: DefaultTolerationSeconds
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before introducing this plugin, we have to learn what **taints** and **tolerations**
    are.
  prefs: []
  type: TYPE_NORMAL
- en: Taints and tolerations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Taints and toleration are used to prevent a set of pods from scheduling running
    on some nodes. Taints are applied to nodes, while tolerations are specified to
    pods. The value of taints could be `NoSchedule` or `NoExecute`. If pods running
    one tainted node have no matching toleration, the pods will be evicted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say we have two nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Let's run a nginx pod now by `kubectl run nginx --image=nginx:1.12.0 --replicas=1
    --port=80` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'The pod is running on the first node `ip-172-20-56-91.ec2.internal`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'By the pod description, we can see there are two default tolerations attached
    to the pod. It means if the node is not ready or unreachable yet, wait for 300
    s before the pod is evicted from the node. These two tolerations are applied by
    DefaultTolerationSeconds admission controller plugin. We''ll talk about this later.
    Next, we''ll set a taint to the first node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we set the action as `NoExecute`, and `experimental=true` doesn''t match
    any tolerations on our pod, the pod will be removed from the node immediately
    and reschedule. Multi-taints could be applied to a node. The pods must match all
    the tolerations in order to run on that node. The following is an example that
    could pass the tainted node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Other than `Equal` operator, we could use `Exists` as well. In that case, we
    don't need to specify the value. As long as the key presents and effect matches,
    then the pod is eligible to run on that tainted node.
  prefs: []
  type: TYPE_NORMAL
- en: The `DefaultTolerationSeconds` plugin is used to set those pods without any
    toleration set. It will then apply for the default toleration for the taints `notready:NoExecute`
    and `unreachable:NoExecute` for 300 s. If you don't want this behavior to occur
    in the cluster, disabling this plugin could work.
  prefs: []
  type: TYPE_NORMAL
- en: PodNodeSelector
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This plugin is used to set `node-selector` annotation to the namespace. When
    the plugin is enabled, passing along a configuration file with `--admission-control-config-file`
    command using the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Then the `node-selector` annotation will be applied to namespace. The pods on
    that namespace will then run on those matched nodes.
  prefs: []
  type: TYPE_NORMAL
- en: AlwaysAdmit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This always admits all the requests, its possible to use for test only.
  prefs: []
  type: TYPE_NORMAL
- en: AlwaysPullImages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pull policy defines the behavior when kubelet pulling the images. The default
    pull policy is `IfNotPresent`, that is, it will pull the image if it is not present
    locally. If this plugin is enabled, the default pull policy will become `Always`,
    which is, always pull the latest image. This plugin also brings another benefit
    if your cluster is shared by different teams. Whenever a pod is scheduled, it'll
    always pull the latest image whether the image exists locally or not. Then we
    can ensure pod creation request always go through authorization check against
    the image.
  prefs: []
  type: TYPE_NORMAL
- en: AlwaysDeny
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This always denies all the requests. It may only be used for testing only.
  prefs: []
  type: TYPE_NORMAL
- en: DenyEscalatingExec
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This plugin denies any `kubectl exec` and `kubectl attach` command to be escalated
    privilege mode. Pods with privilege mode have the access of host namespace, which
    could become a security risk.
  prefs: []
  type: TYPE_NORMAL
- en: Other admission controller plugins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many more other admission controller plugins we could use, such as
    NodeRestriciton to limit kubelet's permission, ImagePolicyWebhook to establish
    a webhook to control the access of the images, SecurityContextDeny for controlling
    the privilege for a pod or a container. Please refer to official documents at
    ([https://kubernetes.io/docs/admin/admission-controllers)](https://kubernetes.io/docs/admin/admission-controllers/))
    to find out other plugins.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned what is namespace and context and how do they work,
    how to switch between physical cluster and virtual cluster by setting the context.
    We then learned about the important object—service account, which provides to
    identify the processes running within a pod. Then we get to know how to control
    access flow in Kubernetes. We learned what the difference are between authentication
    and authorization, and how they work in Kubernetes. We also learn how to leverage
    RBAC to have fine-grained permission to users. At the end, we learned a couple
    of admission controller plugins, which are the last goalkeepers in the access
    control flow.
  prefs: []
  type: TYPE_NORMAL
- en: AWS is the most major player in public IaaS providers. We've used it lots as
    self-hosted cluster examples in this chapter. In next chapter [Chapter 9](part0226.html#6NGV40-6c8359cae3d4492eb9973d94ec3e4f1e),
    *Kubernetes on AWS*, we'll finally learn how to deploy the cluster on AWS and
    basic concept when using AWS.
  prefs: []
  type: TYPE_NORMAL
