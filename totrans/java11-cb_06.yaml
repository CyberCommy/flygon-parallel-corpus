- en: Database Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter covers both basic and commonly used interactions between a Java
    application and a **database** (**DB**), right from connecting to the DB and performing
    CRUD operations to creating transactions, storing procedures, and working with
    **large objects** (**LOBs**). We will be covering the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to a database using JDBC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the tables required for DB interactions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing CRUD operations using JDBC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the **Hikari Connection Pool** (**HikariCP**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using prepared statements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using transactions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with large objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executing stored procedures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using batch operations for a large set of data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using **MyBatis** for CRUD operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the **Java Persistence API** and **Hibernate**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is difficult to imagine a complex software application that does not use
    some kind of structured and accessible data storage called a database. This is
    why any modern language implementation includes a framework that allows you to
    access the DB and **create, read, update, and delete** (**CRUD**) data in it.
    In Java, the **Java Database Connectivity** (**JDBC**) API provides access to
    any data source, from relational databases to spreadsheets and flat files.
  prefs: []
  type: TYPE_NORMAL
- en: Based on this access, an application can manipulate data in the database directly,
    using database language (SQL, for example), or indirectly, using an **Object-Relational
    Mapping (ORM) **framework, which allows for the mapping of objects in memory to
    the tables in the database. The **Java Persistence API (JPA)** is the ORM specification
    for Java. When an ORM framework is used, the CRUD operations on the mapped Java
    objects are translated into the database language automatically. The list of the
    most popular ORM frameworks includes Apache Cayenne, Apache OpenJPA, EclipseLink,
    jOOQ, MyBatis, and Hibernate, to name a few.
  prefs: []
  type: TYPE_NORMAL
- en: The `java.sql` and `javax.sql` packages that compose the JDBC API are included in
    the **Java Platform Standard Edition** (**Java SE**). The `java.sql` package provides
    the API for accessing and processing data stored in a data source (usually a relational
    database)*.* The `javax.sql` package provides the API for server-side data source
    access and processing. Specifically, it provides the `DataSource` interface for
    establishing a connection with a database, connection and statement pooling, distributed
    transactions, and rowsets. The `javax.persistence` package that contains interfaces
    that are compliant with JPA is not included in Java SE and has to be added as
    a dependency to the Maven configuration file `pom.xml`. The specific JPA implementation—the
    preferred ORM framework—has to be included as a Maven dependency too. We will
    discuss the usage of JDBC, JPA, and two ORM frameworks—Hibernate and MyBatis—in
    the recipes of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: To actually connect `DataSource` to a physical database, you also need a database-specific
    driver (provided by a database vendor, such as MySQL, Oracle, PostgreSQL, or SQL
    server database, for example). It may be written in Java or in a mixture of Java
    and **Java Native Interface** (**JNI**) native methods. This driver implements
    the JDBC API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Working with a database involves eight steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing the database by following the vendor instructions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adding the dependency on a `.jar` to the application with the database-specific
    driver.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating a user, database, and database schema—tables, views, stored procedures,
    and so on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connecting to the database from the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Constructing an SQL statement directly using JDBC or indirectly using JPA.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Executing the SQL statement directly using JDBC or committing data changes using
    JPA.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the result of the execution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Closing the database connection and other resources.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Steps 1 –3 are done only once at the database setup stage, before the application
    is run.
  prefs: []
  type: TYPE_NORMAL
- en: Steps 4 – 8 are performed by the application repeatedly, as needed.
  prefs: []
  type: TYPE_NORMAL
- en: Steps 5 – 7 can be repeated multiple times with the same database connection.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to a database using JDBC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to connect to a database.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Select the database you would like to work with. There are good commercial databases
    and good open source databases. The only thing we are going to assume is that
    the database of your choice supports **Structured Query Language** (**SQL**),
    which is a standardized language that allows you to perform CRUD operations on
    a database. In our recipes, we will use the standard SQL and avoid constructs
    and procedures specific to a particular database type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the database is not installed yet, follow the vendor instructions and install
    it. Then, download the database driver. The most popular ones are of types 4 and
    5, written in Java. They are very efficient and talk to the database server through
    a socket connection. If a `.jar` file with such a driver is placed on the classpath,
    it is loaded automatically. Type 4 and 5 drivers are database specific because
    they use a database native protocol for accessing the database. We are going to
    assume that you are using a driver of such a type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If your application has to access several types of databases, then you need
    a driver of type 3\. Such a driver can talk to different databases via a middleware
    application server.
  prefs: []
  type: TYPE_NORMAL
- en: Use drivers of type 1 and 2 only when there are no other driver types available
    for your database.
  prefs: []
  type: TYPE_NORMAL
- en: Set the downloaded `.jar` file with the driver on your application's classpath. Now,
    your application can access the database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Your database might have a console, a GUI, or some other way to interact with
    it. Read the instructions and first create a user, that is, `cook`, and then a
    database, namely `cookbook`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For example, here are the commands for PostgreSQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We selected the `SUPERUSER` role for our user; however, a good security practice
    is to assign such a powerful role to an administrator and create another application-specific
    user who can manage data but cannot change the database structure. It is good
    practice to create another logical layer, called a **schema**, that can have its
    own set of users and permissions. This way, several schemas in the same database
    could be isolated, and each user (one of them is your application) will have access
    only to a certain schema.
  prefs: []
  type: TYPE_NORMAL
- en: Also, at the enterprise level, the common practice is to create synonyms for
    the database schema so that no application can access the original structure directly.
    You can even create a password for each user, but, again, for the purpose of this
    book, this is not needed. So, we leave it to the database administrators to establish
    the rules and guidelines suitable for the particular working conditions of each
    enterprise.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we connect our application to the database. In the following demonstration
    code, we will use, as you may have probably guessed by now, the open source PostgreSQL
    database.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is the code fragment that creates a connection to the local PostgreSQL
    database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The commented lines show how you can set a user and password for your connection.
    Since, for this demonstration, we are keeping the database open and accessible
    to anyone, we could use an overloaded `DriverManager.getConnection(String url)` method.
    However, we will show the most general implementation that would allow anyone to
    read from a property file and pass other useful values (`ssl` as true/false, `autoReconnect`
    as true/false, `connectTimeout` in seconds, and so on) to the connection-creating
    method. Many keys for the passed-in properties are the same for all major database
    types, but some of them are database-specific.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, for passing only a user and a password, we could use the third
    overloaded version, namely `DriverManager.getConnection(String url, String user,
    String password)`. It's worth mentioning that it is a good practice to keep the
    password encrypted. We are not going to show you how to do this, but there are
    plenty of guides available online.
  prefs: []
  type: TYPE_NORMAL
- en: Also, the `getConnection()` method throws `SQLException`, so we need to wrap
    it in a `try...catch` block.
  prefs: []
  type: TYPE_NORMAL
- en: 'To hide all of this plumbing, it is a good idea to keep the connection-establishing
    code inside a method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Another way of connecting to a database is to use the `DataSource` interface.
    Its implementation is typically included in the same `.jar` file as the database
    driver. In the case of PostgreSQL, there are two classes that implement the `DataSource` interface:
    `org.postgresql.ds.PGSimpleDataSource` and `org.postgresql.ds.PGPoolingDataSource`.
    We can use them instead of `DriverManager`. Here is an example of the usage of
    `PGSimpleDataSource`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'And the following is an example of the usage of `PGPoolingDataSource`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The last version of the `getDbConnection()` method is usually the preferred
    way of connecting because it allows you to use connection pooling and some other
    features, in addition to those available when connecting via `DriverManager`.
    Please note though that the class `PGPoolingDataSource` is deprecated, since version
    `42.0.0` was in favor of the third-party connection-pooling software. One such
    framework, HikariCP, which we have mentioned previously, will be discussed and
    demonstrated in the recipe *Using the Hikari Connection Pool*.
  prefs: []
  type: TYPE_NORMAL
- en: Whatever version of the `getDbConnection()` implementation you choose, you can
    use it in all the code examples the same way.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is good practice to close the connection as soon as you do not need it.
    The way to do this is by using the `try-with-resources` construct, which ensures
    that the resource is closed at the end of the `try...catch` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Such a construct can be used with any object that implements the `java.lang.AutoCloseable`
    or the `java.io.Closeable` interface.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the tables required for DB interactions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to create, change, and delete tables and
    other logical database constructs that compose a database schema.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The standard SQL statement for table creation looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here, `table_name` and `column_name` have to be alphanumeric and unique (inside
    the schema) identifiers. The limitations for the names and possible data types
    are database-specific. For example, Oracle allows the table name to have 128 characters,
    while in PostgreSQL, the maximum length of the table name and column name is 63
    characters. There are differences in the data types too, so read the database
    documentation.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is an example of a command that creates the `traffic_unit` table in PostgreSQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `size` parameter is optional. If not set, as in the previous example code,
    it means that the column can store values of any length. The `integer` type, in
    this case, allows you to store numbers from `Integer.MIN_VALUE` (which is -2147483648)
    to `Integer.MAX_VALUE` (which is +2147483647). The `NOT NULL` type was added because,
    by default, the column would be nullable and we wanted to make sure that all the
    columns will be populated.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also identified the `id` column as the `PRIMARY KEY`, which indicates that
    the column (or the combination of columns) uniquely identifies the record. For
    example, if there is a table that contains information about all the people of
    all the countries, the unique combination would *probably* be their full name,
    address, and date of birth. Well, it is plausible to imagine that in some households,
    twins are born and given the same name, so we said *probably*. If the chance of
    such an occasion is high, we would need to add another column to the primary key
    combination, which is an order of birth, with the default value of `1`. Here is
    how we can do this in PostgreSQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the case of the `traffic_unit` table, there is no combination of columns
    that can serve as a primary key. Many cars have the same values in any combination
    of columns. But we need to refer to a `traffic_unit` record so we could know,
    for example, which units have been selected and processed and which were not.
    This is why, we added an `id` column to populate it with a unique generated number,
    and we would like the database to generate this primary key automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you issue the command `\d traffic_unit` to display the table description,
    you will see the function `nextval(''traffic_unit_id_seq''::regclass)` assigned
    to the `id` column. This function generates numbers sequentially, starting with
    1\. If you need a different behavior, create the sequence number generator manually.
    Here''s an example of how to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This sequence starts from 1,000, and caches 10 numbers for a better performance,
    if there is a need to generate numbers in quick succession.
  prefs: []
  type: TYPE_NORMAL
- en: 'According to the code examples given in the previous chapters, the values of `vehicle_type`,
    `road_condition`, and `tire_condition` are limited by the `enum` type. That''s
    why when the `traffic_unit` table is populated, we would like to make sure that
    only the values of the corresponding `enum` type can be set in the column. To
    accomplish this, we''ll create a lookup table called `enums` and populate it with
    the values from our `enum` types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: PostgreSQL has an `enum` data type, but it incurs an overhead if the list of
    possible values is not fixed and has to be changed over time. We think it is quite
    possible that the list of values in our application will expand. So, we decided
    not to use a database `enum` type but create the lookup table ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can refer to the values of the `enums` table from the `traffic_unit`
    table by using their ID as a foreign key. First, we delete the table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we recreate it with a slightly different SQL command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The columns `vehicle_type`, `road_condition`, and `tire_condition` must now
    be populated by the values of a primary key of the corresponding record of the
    `enums` table. This way, we can make sure that our traffic-analyzing code will
    be able to match the values in these columns to the values of the `enum` types
    in the code.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We would also like to make sure that the `enums` table does not contain a duplicate
    combination type and value. To ensure this, we can add a unique constraint to
    the `enums` table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now, if we try to add a duplicate, the database will not allow it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another important consideration of database table creation is whether an index
    has to be added. An *index* is a data structure that helps to accelerate data
    searches in the table without having to check every table record. It can include
    one or more columns of a table. For example, an index for a primary key is created
    automatically. If you bring up the description of the table we have created already,
    you will see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also add an index ourselves if we think (and have proven by experimentation)
    it will help the application performance. In the case of `traffic_unit`, we discovered
    that our code often searches this table by `vehicle_type` and `passengers_count`.
    So, we measured the performance of our code during the search and added these
    two columns to the index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we measure the performance again. If it does improve, we would leave
    the index in place, but, in our case, we have removed it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The index did not improve the performance significantly, probably because an
    index has an overhead of additional writes and storage space.
  prefs: []
  type: TYPE_NORMAL
- en: In our examples of primary key, constraints, and indexes, we followed the naming
    convention of PostgreSQL. If you use a different database, we suggest you look
    up its naming convention and follow it, so that your naming aligns with the names
    created automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Performing CRUD operations using JDBC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to populate, read, change, and delete data
    in the using JDBC.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have already seen examples of SQL statements that create (populate) data
    in the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve also seen examples of instances where several table records have to
    be added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: If a column has a default value specified, there is no need to list it in the
    `INSERT INTO` statement, unless a different value has to be inserted.
  prefs: []
  type: TYPE_NORMAL
- en: 'The reading of the data from the database is done by a `SELECT` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s a general definition of the `WHERE` clause:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `column_name operator value` construct can be combined with logical operators
    `AND` and `OR` and grouped with the brackets `(` and `)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The selected values can be returned in a certain order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The order can be marked as ascending (default) or descending:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The data can be changed with the `UPDATE` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, it can be deleted with the `DELETE` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Without the `WHERE` clause, all the records of the table are going to be affected
    by the `UPDATE` or `DELETE` statement.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have already seen an `INSERT` statement. Here is an example of other types
    of statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/456f0881-a644-4c13-b79f-68f96a8876e1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding `SELECT` statement brings up the values from all the columns
    of all the rows of the table. To limit the amount of returned data, a `WHERE`
    clause can be added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1ac573ef-e7fd-47fd-8922-ef05c578f9bf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following screenshot captures three statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e186a7aa-af83-4997-b7f5-3f1a9f05fe97.png)'
  prefs: []
  type: TYPE_IMG
- en: The first one is an `UPDATE` statement that changes values in the `value` column
    to `NEW`, but only in the rows where the `value` column contains value `new` (apparently,
    the value is case-sensitive). The second statement deletes all the rows that do
    not have the value `NEW` in the `value` column. The third statement (`SELECT`)
    retrieves values from all the rows of all columns.
  prefs: []
  type: TYPE_NORMAL
- en: It is worth noting that we would not be able to delete the records of the `enums`
    table if these records were referred to (as foreign keys) by the `traffic_unit` table.
    Only after deleting the corresponding records of the `traffic_unit` table it is
    possible to delete the records of the `enums` table.
  prefs: []
  type: TYPE_NORMAL
- en: 'To execute any of the CRUD operations in the code, one has to acquire a JDBC
    connection first, then create and execute a statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: It is good practice to use the `try-with-resources` construct for the `Statement`
    object. The closing of the `Connection` object would close the `Statement` object
    automatically. However, when you close the `Statement` object explicitly, the
    cleanup happens immediately, instead of you having to wait for the necessary checks
    and actions to propagate through the layers of the framework.
  prefs: []
  type: TYPE_NORMAL
- en: The `execute()` method is the most generic one among the three methods that
    can execute a statement. The other two include `executeQuery()` (for `SELECT`
    statements only) and `executeUpdate()` (for `UPDATE`, `DELETE`, `CREATE`, or `ALTER`
    statements). As you can see from the preceding example, the `execute()` method returns
    `boolean`, which indicates whether the result is a `ResultSet` object or just
    a count. This means that `execute()` acts as `executeQuery()` for the `SELECT`
    statement and `executeUpdate()` for the other statements that we have listed.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can demonstrate this by running the preceding code for the following sequence
    of statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The result will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cf42e0dc-980d-4553-8b9e-aee5f1c48817.png)'
  prefs: []
  type: TYPE_IMG
- en: We used the positional extraction of the values from `ResultSet` because this
    is more efficient than using the column name (as in `rs.getInt("id")` or `rs.getInt("type")`).
    The difference in performance is very small, though, and becomes important only
    when the operation happens many times. Only the actual measuring and testing can
    tell you whether this difference is significant for your application. Bear in
    mind that getting values by name provides better code readability, which pays
    well in the long term during application maintenance.
  prefs: []
  type: TYPE_NORMAL
- en: 'We used the `execute()` method for demonstration purposes. In practice, the `executeQuery()` method is
    used for `SELECT` statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the preceding code cannot be generalized as a method that receives
    the SQL statement as a parameter. The code that extracts the data is specific
    to the executed SQL statement. By contrast, the call to `executeUpdate()` can
    be wrapped in a generic method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'SQL is a rich language, and we do not have enough space to cover all of its
    features. But we would like to enumerate a few of its most popular ones so that
    you are aware of their existence and can look them up when needed:'
  prefs: []
  type: TYPE_NORMAL
- en: The `SELECT` statement allows the use of the `DISTINCT` keyword, to get rid
    of all the duplicate values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The keyword `LIKE` allows you to set the search pattern to the `WHERE` clause
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The search pattern can use several wildcards—`%, _`, `[charlist]`, `[^charlist]`,
    or `[!charlist]`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Matching values can be enumerated with the `IN` keyword
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `SELECT` statement can include several tables using the `JOIN` clause
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SELECT * INTO table_2 from table_1` creates `table_2` and copies data from
    `table_1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TRUNCATE` is faster and uses fewer resources when removing all the rows of
    a table'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are many other useful methods in the `ResultSet` interface as well. Here
    is an example of how some of its methods can be used to write generic code that
    would traverse the returned result and use metadata to print out the column name
    and the returned value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We used `ResultSetMetaData` only once to collect the returned column names
    and the length (number of columns) of one row. Then, we extracted the values from
    each row by position and created `List<String>` elements with the corresponding
    column names. To print, we used something you are already familiar with—a programmer''s
    delight—the joining collector (we discussed it in the previous chapter). If we
    call the `traverseRS("select * from enums")` method, the result will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e39680bf-4ea3-44d3-ac17-e0ae0bbe2e4f.png)'
  prefs: []
  type: TYPE_IMG
- en: Using the Hikari Connection Pool (HikariCP)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to set up and use the high-performance HikariCP.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The HikariCP framework was created by Brett Wooldridge, who lives in Japan.
    *Hikari* in Japanese means *light*. It is a lightweight and relatively small API
    that is highly optimized and allows for tuning via many properties, some of which
    are not available in other pools. In addition to standard user, password, maximum
    pool size, various timeout settings, and cache configuration properties, it also
    exposes such properties as `allowPoolSuspension`, `connectionInitSql`, `connectionTestQuery`,
    and many others, even including a property that deals with the not-timely-closed
    connections, `leakDetectionThreshold`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the latest (at the time of writing this book) version of Hikari pool,
    add the following dependency to the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: For demonstration purposes, we will use the database created in the previous
    recipe of this chapter, *Connecting to a database using JDBC*. We will also assume
    that you have studied that recipe and there is no need to repeat what was said
    there about the database, JDBC, and how they work together.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are several ways to configure the Hikari connection pool. All of them
    are based on the usage of the `javax.sql.DataSource` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The most obvious and straightforward method is to set the pool properties on
    the `DataSource` object directly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We have commented out password because we did not set one for our database. Between
    properties `jdbcUrl` and `dataSourceClassName`, only one of them can be used at
    a time, except when using some older drivers that may require setting both of
    these properties. Also, please notice how we have used the general method `addDataSourceProperty()`
    when there is no dedicated setter for the particular property.
  prefs: []
  type: TYPE_NORMAL
- en: To switch from PostgreSQL to another relational database, all you need to do
    is change the driver class name and the database URL. There are also many other
    properties; some of them are database specific, but we are not going to dive into
    such details, because this recipe demonstrates how to use HikariCP. Read the database
    documentation about database-specific pool configuration properties and how to
    use them for tuning the pool for the best performance, which also very much depends
    on how the particular application interacts with the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to configure the Hikari pool is to use the `HikariConfig` class
    to collect all the properties and then set the `HikariConfig` object in the `HikariDataSource`
    constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we have used the general method `addDataSourceProperty()` again
    because there are no dedicated setters for those properties in the `HikariConfig` class
    either.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `HikariConfig` object, in turn, can be populated with data using the class
    `java.util.Properties`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Please, note that we have used the prefix `dataSource` for the properties that
    do not have dedicated setters in the `HikariConfig` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make the configuration even easier to load, the `HikariConfig` class has
    a constructor that accepts a file with the properties. For example, let''s create
    a file called `database.properties` in the folder `resources` with the following
    content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice how we used the prefix `dataSource` with the same properties again.
    Now, we can load the preceding file directly into the `HikariConfig` constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Behind the scenes, as you could guess, it just loads properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can use the following functionality that''s included in the
    `HikariConfig` default constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'It means that we can set the system property as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can configure HikariCP as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: All the preceding methods of the pool configuration produce the same result,
    so it is only up to the style, convention, or just your personal preference to
    decide which of them to use.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following method is using the created `DataSource` object to access the
    database and select all the values from the table `enums`, which were created
    in the recipe *Connecting to a database using JDBC*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run the preceding code, the result will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5414536a-6a29-4968-9f6d-00b03b826ae7.png)'
  prefs: []
  type: TYPE_IMG
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can read more about HikariCP's features on GitHub ([https://github.com/brettwooldridge/HikariCP](https://github.com/brettwooldridge/HikariCP)).
  prefs: []
  type: TYPE_NORMAL
- en: Using prepared statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to use a **prepared statement**—a statement
    template that can be stored in the database and executed efficiently with different
    input values.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An object of `PreparedStatement`—a subinterface of `Statement`—can be precompiled
    and stored in the database and then used to efficiently execute the SQL statement
    multiple times for different input values. Similar to an object of `Statement` (created
    by the `createStatement()` method), it can be created by the `prepareStatement()`
    method of the same `Connection` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same SQL statement that was used to generate `Statement` can be used to
    generate `PreparedStatement` too. In fact, it is a good idea to consider using
    `PrepdaredStatement` for any SQL statement that is called multiple times, because
    it performs better than `Statement`. To do this, all we need to change are these
    two lines in the sample code of the previous section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'We change these lines to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The true usefulness of `PreparedStatement` shines because of its ability to
    accept parameters—the input values that substitute (in order of appearance) the
    `?` symbol. Here''s an example of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/35314b63-dd97-4fae-8663-b4e6215e850f.png)'
  prefs: []
  type: TYPE_IMG
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is not a bad idea to always use prepared statements for CRUD operations.
    They might be slower if executed only once, but you can test and see whether this
    is the price you are willing to pay. By using prepared statements systematically,
    you will produce a consistent (better readable) code that provides more security
    (prepared statements are not vulnerable to SQL injection).
  prefs: []
  type: TYPE_NORMAL
- en: Using transactions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will learn what a database transaction is and how it can
    be used in Java code.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **transaction** is a unit of work that includes one or many operations that
    change data. If successful, all the data changes are **committed** (applied to
    the database). If one of the operations errors out, the transaction is **rolled
    back**,and none of the changes included in the transaction will be applied to
    the database.
  prefs: []
  type: TYPE_NORMAL
- en: Transaction properties are set up on the `Connection` object. They can be changed
    without closing the connection, so different transactions can reuse the same `Connection`
    object.
  prefs: []
  type: TYPE_NORMAL
- en: JDBC allows transaction control only for CRUD operations. Table modification
    (`CREATE TABLE`, `ALTER TABLE`, and so on) is committed automatically and cannot
    be controlled from the Java code.
  prefs: []
  type: TYPE_NORMAL
- en: By default, a CRUD operation transaction is set to be **auto-committed**. This
    means that every data change that was introduced by a SQL statement is applied
    to the database as soon as the execution of this statement is completed. All the
    preceding examples in this chapter use this default behavior.
  prefs: []
  type: TYPE_NORMAL
- en: To change this behavior, you have to use the `setAutoCommit(boolean)` method
    of the `Connection` object. If set to `false`, the data changes will not be applied
    to the database until the `commit()` method on the `Connection` object is invoked.
    Also, if the `rollback()` method is called instead, all the data changes since
    the beginning of the transaction or since the last call to `commit()` will be
    discarded.
  prefs: []
  type: TYPE_NORMAL
- en: Explicit programmatic transaction management improves performance, but it is
    insignificant in the case of short atomic operations that are called once and
    not very often. Taking over transaction control becomes crucial when several operations
    introduce changes that have to be applied either all together or none of them.
    It allows for group database changes into atomic units and thus avoids accidental
    violation of data integrity.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, let''s add an output to the `traverseRS()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: This will help you analyze the output when many different SQL statements are
    executed in the same demo example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s run the following code that reads data from the `enums` table,
    then inserts a row, and then reads all the data from the table again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we took over transaction control by calling `conn.setAutoCommit(false)`.
    The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/63dd3a04-23c6-4544-b564-656112337f7b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, the changes were not applied because the call to `commit()` was
    commented out. When we uncomment it, the result changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/585677de-5653-4928-9304-f01cb41ee08d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s execute two inserts, but introduce a spelling error in the second
    insert:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'We get an exception stack trace (we do not show it to save space) and this
    message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Nevertheless, the first insert was executed successfully:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e419c1af-ae1e-4f52-942c-a47dacd0d441.png)'
  prefs: []
  type: TYPE_IMG
- en: The second row was not inserted. If there was no `conn.commit()` after the first
    `INSERT INTO` statement, the first insert would not be applied either. This is
    the advantage of the programmatic transaction control in the case of many independent
    data changes—if one fails, we can skip it and continue applying other changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s try to insert three rows with an error (by setting a letter instead
    of a number as the `id` value) in the second row:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'We put each insert execution in the `try...catch` block and commit the changes
    before printing out the result (update count or error message). The result is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5a3508cd-c51f-4528-84f5-ab1488060a72.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the second row was not inserted, although `conn.rollback()`
    was commented out. Why? This is because the only SQL statement included in this
    transaction failed, so there was nothing to roll back.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s create a `test` table with only one column `name` using the database
    console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6ca14c11-e647-4987-be46-5c990139bfb0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We will insert in the table `test` the vehicle type before inserting a record
    in the `enums` table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the previous code commits the changes after the second insert,
    which, as in the previous example, is not successful for the second element of
    the array `values`. With `conn.rollback()` commented out, the result will be as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/df8484ad-6982-4d0c-881e-2b3898f82cbb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The row with `truck` was not inserted in the `enums` table but added to the
    `test` table. That is, when the usefulness of a rollback was demonstrated. If
    we uncomment `conn.rollback()`, the result will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b69ab672-bf8d-4297-b83e-29fbbbda6850.png)'
  prefs: []
  type: TYPE_IMG
- en: This demonstrates that `conn.rollback()` rolls back all the changes not committed
    yet.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another important property of a transaction is the** transaction isolation level**.
    It defines the boundaries between database users. For example, can other users
    see your database changes before they are committed? The higher the isolation
    (the highest is **serializable**), the more time it takes a transaction to complete
    in the case of concurrent access to the same records. The less restrictive the
    isolation (the least restrictive is **read uncommitted**), the dirtier the data
    is, which means that other users can get the values you have not committed yet
    (and are maybe never going to commit).
  prefs: []
  type: TYPE_NORMAL
- en: Usually, it is enough to use the default level, which is typically `TRANSACTION_READ_COMMITTED`, although
    it may be different for different databases. JDBC allows you to get the current
    transaction isolation level by calling the method `getTransactionIsolation()` on
    the `Connection` object. The method `setTransactionIsolation()` of the `Connection`
    object allows you to set any isolation level as needed.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of complex decision-making logic about which changes need to be
    committed and which need to be rolled back, one can use two other `Connection`
    methods to create and delete **savepoints**. The `setSavepoint(String savepointName)` method creates
    a new savepoint and returns a `Savepoint` object, which can later be used to roll
    back all the changes up to this point using the `rollback (Savepoint savepoint)`
    method. A savepoint can be deleted by calling `releaseSavepoint(Savepoint savepoint)`.
  prefs: []
  type: TYPE_NORMAL
- en: The most complex types of database transactions are **distributed transactions**.
    They are sometimes called **global transactions**, **XA transactions**, or **JTA
    transactions** (the latter is a Java API that consists of two Java packages, namely `javax.transaction`
    and `javax.transaction.xa`). They allow for the creation and execution of a transaction
    that spans operations across two different databases. Providing a detailed overview
    of distributed transactions is outside the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Working with large objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to store and retrieve a LOB that can be one
    of three types—**Binary Large Object** (**BLOB**), **Character Large Object**
    (**CLOB**), and **National Character Large Object** (**NCLOB**).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The actual processing of LOB objects inside a database is vendor-specific, but
    JDBC APIs hide these implementation details from the application by representing
    the three LOB types as interfaces—`java.sql.Blob`, `java.sql.Clob`, and `java.sql.NClob`.
  prefs: []
  type: TYPE_NORMAL
- en: '`Blob` is usually used to store images or other non-alphanumeric data. On the
    way to the database, an image can be converted into a stream of bytes and stored
    using the `INSERT INTO` statement. The `Blob` interface allows you to find the
    length of the object and convert it into an array of bytes that can be processed
    by Java for the purpose of displaying the image, for example.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Clob` allows you to store character data. `NClob` stores Unicode character
    data as a way to support internationalization. It extends the `Clob` interface
    and provides the same methods. Both interfaces allow you to find the length of
    LOB and to get a substring inside the value.'
  prefs: []
  type: TYPE_NORMAL
- en: The methods in the `ResultSet`, `CallableStatement` (we will discuss this in
    the next recipe), and `PreparedStatement` interfaces allow an application to store
    and access the stored value in a variety of ways—some of them via setters and
    getters of the corresponding objects, while others as `bytes[]`, or as a binary,
    character, or ASCII stream.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Each database has its specific way of storing a LOB. In the case of PostgreSQL,
    `Blob` is usually mapped to the `OID` or `BYTEA` data type, while `Clob` and `NClob` are
    mapped to the `TEXT` type. To demonstrate how to do this, let''s create tables
    that can store each of the large object types. We will write a new method that
    creates tables programmatically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can create three tables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Look at the JDBC interfaces `PreparedStatement` and `ResultSet` and you'll notice
    the setters and getters for the objects—`get/setBlob()`, `get/setClob()`, `get/setNClob()`,
    `get/setBytes()`—and the methods that use `InputStream` and `Reader`—`get/setBinaryStream()`,
    `get/setAsciiStream()`, or `get/setCharacterStream()`. The big advantage of streaming
    methods is that they move data between the database and source without storing
    the whole LOB in memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, the object''s setters and getters are closer to our heart being in
    line with object-oriented coding. So we will start with them, using objects that
    aren''t too big, for demonstration purposes. We expect the following code to work
    just fine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, in the case of `Clob`, we write this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'It turns out that not all methods that are available in the JDBC API are actually
    implemented by the drivers of all the databases. For example, `createBlob()` seems
    to work just fine for Oracle and MySQL, but in the case of PostgreSQL, we get
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2f4a350b-2998-4002-bd0e-84a9f5767a20.png)'
  prefs: []
  type: TYPE_IMG
- en: 'For  `Clob`, we get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/321c623c-b082-4b55-abf2-fd0a1de83494.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can try to retrieve an object from `ResultSet` via the getter as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The result will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/31e08560-ab43-4f7c-950b-b51ed9df254b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Apparently, knowing the JDBC API is not enough; you have to read the documentation
    for the database too. Here is what the documentation for PostgreSQL ([https://jdbc.postgresql.org/documentation/80/binary-data.html](https://jdbc.postgresql.org/documentation/80/binary-data.html))
    has to say about LOB handling:'
  prefs: []
  type: TYPE_NORMAL
- en: '"To use the BYTEA data type you should simply use the `getBytes()`, `setBytes()`,
    `getBinaryStream()`, or `setBinaryStream()` methods.'
  prefs: []
  type: TYPE_NORMAL
- en: To use the Large Object functionality you can use either the `LargeObject` class
    provided by the PostgreSQL JDBC driver, or by using the `getBLOB()` and `setBLOB()`
    methods."
  prefs: []
  type: TYPE_NORMAL
- en: Also, you must access large objects within an SQL transaction block. You can
    start a transaction block by calling `setAutoCommit(false)`.
  prefs: []
  type: TYPE_NORMAL
- en: Without knowing such specifics, figuring out a way to handle LOBs would require
    a lot of time and cause much frustration.
  prefs: []
  type: TYPE_NORMAL
- en: 'When dealing with LOBs, the streaming methods are preferred because they transfer
    data directly from the source into the database (or the other way around) and
    do not consume memory as much as the setters and getters do (which have to load
    all the LOB in memory first). Here is the code that streams `Blob` in and from
    PostgreSQL database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look at the result. We have cut the screenshot arbitrarily on the right-hand
    side; otherwise, it is too long horizontally:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b260d44f-2343-4d92-b53f-66a43e2efdb2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Another way to process the retrieved image is to use `byte[]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'PostgreSQL limits the `BYTEA` size to 1 GB. Larger binary objects can be stored
    as the **object identifier** (**OID**) data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The result will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f99937f5-82a8-464b-bcd8-4474f59e2f42.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Please note that the `select` statement returns a long value from the `lob` column.
    This is because the `OID` column does not store the value itself like `BYTEA`
    does. Instead, it stores the reference to the object that is stored somewhere
    else in the database. Such an arrangement makes deleting the row with the OID
    type not as straightforward as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'If you do just that, it leaves the actual object an orphan that continues to
    consume disk space. To avoid this problem, you have to `unlink` the LOB first
    by executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Only after this can you safely execute the `delete from lobs where id = 100` commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you forgot to `unlink` first, or if you created an orphan LOB accidentally
    (because of an error in the code, for example), there is a way to find orphans
    in system tables. Again, database documentation should provide you with instructions
    on how to do this. In the case of PostgreSQL v.9.3 or later, you can check whether
    you have an orphan LOB by executing the `select count(*) from pg_largeobject` command.
    If it returns a count that is bigger than 0, then you can delete all the orphans
    with the following join (assuming that the `lobs` table is the only one that can
    contain a reference to a LOB):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: This is the price one has to pay for storing a LOB in a database.
  prefs: []
  type: TYPE_NORMAL
- en: It's worth noting that although `BYTEA` does not require such complexity during
    the delete operation, it has a different kind of overhead. According to the PostgreSQL
    documentation, when close to 1 GB, *it w**ould require a huge amount of memory
    to process such a large value.*
  prefs: []
  type: TYPE_NORMAL
- en: 'To read LOB data, you can use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, it is possible to use a simpler code by getting `Blob` directly
    from the `ResultSet` object if the LOB is not too big:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'To store `Clob` in PostgreSQL, you can use the same code as the preceding one.
    While reading from the database, you can convert bytes into a `String` data type
    or something similar (again, if the LOB is not too big):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'However, `Clob` in PostgreSQL can be stored directly as data type `TEXT` that
    is unlimited in size. This code reads the file where this code is written and
    stores/retrieves it in/from the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The result will be as follows (we have shown only the first few lines of the
    output):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f762b169-3217-4bd3-9a84-254c4b414e97.png)'
  prefs: []
  type: TYPE_IMG
- en: 'For bigger objects, streaming methods would be a better (if not the only) choice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Note that, as of the time of writing this book, `setCharacterStream(int, Reader,
    long)` is not implemented, while `setCharacterStream(int, Reader, int)` works
    just fine.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also read the file from the `texts` table as a character stream and
    limit it to the first 160 characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The result will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1da666ee-263a-4240-a5db-ac07702ff50a.png)'
  prefs: []
  type: TYPE_IMG
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is another recommendation from the PostgreSQL documentation (you can access
    it at [https://jdbc.postgresql.org/documentation/80/binary-data.html](https://jdbc.postgresql.org/documentation/80/binary-data.html)):'
  prefs: []
  type: TYPE_NORMAL
- en: '"The BYTEA data type is not well suited for storing very large amounts of binary
    data. While a column of type BYTEA can hold up to 1 GB of binary data, it would
    require a huge amount of memory to process such a large value.'
  prefs: []
  type: TYPE_NORMAL
- en: The Large Object method for storing binary data is better suited to storing
    very large values, but it has its own limitations. Specifically deleting a row
    that contains a Large Object reference does not delete the Large Object. Deleting
    the Large Object is a separate operation that needs to be performed. Large Objects
    also have some security issues since anyone connected to the database can view
    and/or modify any Large Object, even if they don't have permissions to view/update
    the row containing the Large Object reference."
  prefs: []
  type: TYPE_NORMAL
- en: While deciding to store LOBs in a database, you need to remember that the bigger
    the database, the more difficult it is to maintain it. The speed of access—the
    main advantage of choosing a database as a storage facility—also decreases, and
    it is not possible to create indices for LOB types to improve the search. Also,
    you cannot use LOB columns in a `WHERE` clause, except for a few CLOB cases, or
    use LOB columns in multiple rows of `INSERT` or `UPDATE` statements.
  prefs: []
  type: TYPE_NORMAL
- en: So, before thinking about a database for a LOB, you should always consider whether
    storing the name of a file, keywords, and some other content properties in the
    database would be enough for the solution.
  prefs: []
  type: TYPE_NORMAL
- en: Executing stored procedures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to execute a database-stored procedure from
    a Java program.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once in a while, a Java programmer encounters the need to manipulate and/or
    select data in/from several tables, and so the programmer comes up with a set
    of complex SQL statements that are impractical to implement in Java or it is strongly
    suspected that the Java implementation might not yield an adequate performance.
    This is when the set of SQL statements can be wrapped into a stored procedure
    that is compiled and stored in the database and then invoked via the JDBC interface.
    Or, in another twist of fate, a Java programmer might encounter the need for incorporating
    a call to an existing stored procedure into the program. To accomplish this, the
    interface `CallableStatement` (which extends the `PreparedStatement` interface)
    can be used, although some databases allow you to call a stored procedure using
    either an interface `Statement` or a `PreparedStatement`.
  prefs: []
  type: TYPE_NORMAL
- en: '`CallableStatement` can have parameters of three types—`IN` for an input value,
    `OUT` for the result, and `IN OUT` for either an input or an output value. `OUT`
    parameters must be registered by the `registerOutParameter()` method of `CallableStatement`.
    The `IN` parameters can be set the same way as the parameters of `PreparedStatement`.'
  prefs: []
  type: TYPE_NORMAL
- en: Bear in mind that executing a stored procedure from Java programmatically is
    one of the least standardized areas. PostgreSQL, for example, does not support
    stored procedures directly, but they can be invoked as functions, which have been
    modified for this purpose by interpreting `OUT` parameters as return values. Oracle,
    on the other hand, allows `OUT` parameters for functions too.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is why the following differences between database functions and stored
    procedures can serve only as a general guideline and not as a formal definition:'
  prefs: []
  type: TYPE_NORMAL
- en: A function has a return value, but it does not allow `OUT` parameters (except
    for some databases) and can be used in a SQL statement.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A stored procedure does not have a return value (except for some databases);
    it allows `OUT` parameters (for most databases) and can be executed using the
    JDBC interface `CallableStatement`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is why reading the database documentation to learn how to execute a stored
    procedure is very important.
  prefs: []
  type: TYPE_NORMAL
- en: Since stored procedures are compiled and stored on the database server, the
    `execute()` method of `CallableStatement` performs better for the same SQL statement
    than the corresponding method of `Statement` or `PreparedStatement`. This is one
    of the reasons a lot of Java code is sometimes replaced by one or several stored
    procedures that include even the business logic. But there is no right answer
    for every case and problem, so we will refrain from making specific recommendations,
    except to repeat the familiar mantra about the value of testing and the clarity
    of the code you are writing.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As in the previous recipe, we will continue using the PostgreSQL database for
    demonstration purposes. Before writing custom SQL statements, functions, and stored
    procedures, you should look at the list of already existing functions first. Usually,
    they provide a wealth of functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of calling the `replace(string text, from text, to text)`
    function that searches the first parameter (`string text`) and replaces it with
    all the substrings that match the second parameter (`from text `) with the substring
    provided by the third parameter (`string text`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5629dab5-57b2-4b6e-9c01-d1fee37bd23f.png)'
  prefs: []
  type: TYPE_IMG
- en: We will incorporate this function into our custom functions and stored procedures
    to show you how this can be done.
  prefs: []
  type: TYPE_NORMAL
- en: 'A stored procedure can be without any parameters at all, with `IN` parameters
    only, with `OUT` parameters only, or with both. The result may be one or multiple
    values, or a `ResultSet` object. Here is an example of creating a stored procedure
    without any parameters in PostgreSQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we use the method `execute()`, which we are already
    familiar with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: This stored procedure (it is always a function in PostgreSQL) creates the `texts` table
    (after dropping it if the table existed already). You can find the syntax of the
    SQL for function creation in the database documentation. The only thing we would
    like to comment on here is that instead of the symbol `$$` that denotes the function
    body, you can use single quotes. We prefer `$$`, though, because it helps avoid
    the escaping of single quotes if we need to include them in the body of the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'After being created and stored in the database, the procedure can be invoked
    by `CallableStatement`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, it can be invoked with the SQL statement `select createTableTexts()` or `select
    * from createTableTexts()`. Both statements return a `ResultSet` object (which
    is `null` in the case of the `createTableTexts()` function), so we can traverse
    it by our method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: We have already used this method in the previous recipes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The function can be deleted by using the following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s put all of this together in Java code, create a function, and invoke
    it in three different styles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/16547c6c-f4c8-410c-ac89-85d2b6907f29.png)'
  prefs: []
  type: TYPE_IMG
- en: As was expected, the returned `ResultSet` object is `null`. Note that the name
    of the function is case-insensitive. We keep it in camel case style for human
    readability only.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s create and call another stored procedure (function) with two input
    parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'In the body of the function, the input parameters are referred to by their
    position as `$1` and `$2`. As was mentioned before, we also used the built-in
    `replace()` function to manipulate the values of the second input parameter before
    inserting it into the table. The newly created stored procedure is called twice:
    first via `CallableStatment` and then via the `execute()` method, with different
    input values. Then, we looked inside the table using `traverseRS("select * from
    texts")` and dropped the newly created function to perform a cleanup. We dropped
    the function just for this demo. In real-life code, the function, once created,
    stays and takes advantage of being there, compiled and ready to run.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run the preceding code, we''ll get the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3b9eb46d-9339-48fd-aba3-d616bb91f34c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now let''s add two rows to the `texts` table and then look into it and create
    a stored procedure (function) that counts the number of rows in the table and
    returns the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Note the `bigint` value of the returned value and the matching type for the `OUT` parameter `Types.BIGINT`. The
    newly created stored procedure is executed three times and then deleted. The result
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dc60f770-b493-45d3-9fa5-d984d1fbf62e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s look at an example of a stored procedure with one input parameter
    of the type `int` that returns the `ResultSet` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Note the return type defined as `setof texts`, where `texts` is the name of
    the table. If we run the preceding code, the result will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/da57a6ac-c2d8-4e27-8e76-638b967f48f2.png)'
  prefs: []
  type: TYPE_IMG
- en: It's worth analyzing the difference in the `ResultSet` content of two different
    calls to the stored procedure. Without `select *`, it contains the name of the
    procedure and the returned object (of the `ResultSet` type). But with `select
    *`, it returns the actual `ResultSet` content from the last SQL statement in the
    procedure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Naturally, the question arises why we could not call this stored procedure
    via `CallableStatement`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'We tried, but it did not work. Here is what the PostgreSQL documentation has
    to say about it:'
  prefs: []
  type: TYPE_NORMAL
- en: '"Functions that return data as a set should not be called via the CallableStatement
    interface, but instead should use the normal Statement or PreparedStatement interfaces."'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a way around this limitation, though. The same database documentation
    describes how to retrieve a `refcursor` (a PostgreSQL-specific feature) value
    that can then be cast to `ResultSet`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'A few comments about the preceding code would probably help you understand
    how this was done:'
  prefs: []
  type: TYPE_NORMAL
- en: Autocommit has to be turned off.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inside the function, `$1` refers to the first `IN` parameter (not counting the
    `OUT` parameter).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The language is set to `plpgsql` to access the `refcursor` functionality (PL/pgSQL
    is a loadable procedural language of the PostgreSQL database).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To traverse `ResultSet`, we wrote a new method, as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'So, our old friend the `traverseRS(String sql)` method can now be refactored
    into the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run the last example, the result will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bc185a01-c374-498a-ab21-ade478c6451b.png)'
  prefs: []
  type: TYPE_IMG
- en: You can see that the result-traversing methods that do not extract an object
    and cast it to `ResultSet` don't show the correct data in this case.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We covered the most popular cases of calling stored procedures from Java code.
    The scope of this book does not allow us to present more complex and potentially
    useful forms of stored procedures in PostgreSQL and other databases. However,
    we would like to mention them here, so that you have an idea of other possibilities:'
  prefs: []
  type: TYPE_NORMAL
- en: Functions on composite types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions with parameter names
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions with variable numbers of arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions with default values for arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions as table sources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions returning tables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Polymorphic SQL functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions with collations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using batch operations for a large set of data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to create and execute many **batches** of
    SQL statements with a single call to a database.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Batch processing is required when many SQL statements have to be executed at
    the same time to insert, update, or read database records. Executing several SQL
    statements can be done by iterating over them and sending each to the database
    one by one, but it incurs a network overhead that can be avoided by sending all
    the queries to the database at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: To avoid this network overhead, all the SQL statements can be combined into one
    `String` value, and each statement is separated by a semicolon, so they all can
    be sent to the database in one call. The returned result, if present, is also
    sent back as a collection of result sets generated by each statement. Such a processing
    is usually called bulk processing to distinguish it from a batch processing that's
    available only for `INSERT` and `UPDATE` statements. Batch processing allows you
    to combine many SQL statements using `addBatch()` method of the interface `java.sql.Statement`
    or `java.sql.PreparedStatement`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the PostgreSQL database and the following table, `person`, to insert,
    update, and read data from it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, each record of the table can contain two attributes of a person—name
    and age.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to demonstrate both **bulk processing** and **batch processing**.
    In order to accomplish it, let''s follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of bulk processing is a single `INSERT` statement with multiple
    `VALUES` clauses:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'The code that constructs such a statement looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the preceding code constructs a statement with 100,000 `VALUES`
    clauses, which means it inserts 100,000 records in one trip to a database. In
    our experiment, it took 1,082 milliseconds to complete this job. As the result,
    the table `person` now contains 100,000 records of persons with names from `Name0` to
    `Name99999` and age as a random number from 1 to 99 inclusive.
  prefs: []
  type: TYPE_NORMAL
- en: There are two disadvantages of this method of bulk processing—it is susceptible
    to the SQL injection attack and can consume too much memory. SQL injection can
    be addressed by using `PreparedStatement`, but it is limited by the number of
    bind variables. In the case of PostgreSQL, it cannot be more than `32767`. This
    means that we would need to break the single `PreparedStatement` into several
    smaller ones, each having no more than `32767` bind variables. Incidentally, it
    will also address the memory consumption problem, since each statement is now
    much smaller than the large one. The previous single statement, for example, includes
    200,000 values.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code addresses both problems by breaking the single SQL statement
    into smaller `PreparedStatement` objects, each with no more than `32766` bind
    variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: The previous code executes as quickly as our previous example. It took 1,175
    milliseconds to complete this job. But we ran this code on the same computer where
    the database is installed, so there is no the network overhead from the seven
    trips to the database (that was how many queries were added to the `List queries`).
    But, as you can see, the code is quite complex. It can be substantially simplified
    by using batch processing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Batch processing is based on the usage of the methods `addBatch()` and `executeBatch()`,
    which are available in both—`Statement` and `PreparedStatement`—interfaces. For
    our demonstration, we will use `PreparedStatement` for two reasons—it is not susceptible
    to SQL injection and performs better when executed many times (that is the main
    purpose of `PreparedStatement`—to take advantage of multiple executions of the
    same statement with different values):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: It took 2,299 milliseconds to insert 100,000 records in the `person` table,
    which is almost twice as long if compared with using a single statement with multiple
    `VALUES` clauses (the first example) or using multiple `PreparedStatement` objects
    (the second example). Although its execution takes longer, this code has the obvious
    advantage of being much simpler. And it sends the batch of statements to the database
    in one trip, which means that the gap in performance between this implementation
    and the previous one (with seven trips to the database) will be smaller when the
    database is not collocated with the application.
  prefs: []
  type: TYPE_NORMAL
- en: But this implementation can be improved too.
  prefs: []
  type: TYPE_NORMAL
- en: 'To improve the batch processing, let''s add the `reWriteBatchedInserts` property
    to the `DataSource` object and set it to `true`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Now, if we run the same batch processing code using the connection `createDataSource().getConnection()`,
    the time it takes to insert same 100,000 records drops to 750 milliseconds, which
    is 25% better than any of the implementations we have tested so far. And the code
    remains much simpler than any of the previous implementations.
  prefs: []
  type: TYPE_NORMAL
- en: But what about memory consumption?
  prefs: []
  type: TYPE_NORMAL
- en: 'As the size of the batch grows, at some point, JVM may run out of memory. In
    such a case, batch processing can be broken into several batches, each delivered
    to the database in a separate trip:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: We use variable the `execute` as the flag that indicates that we need to call
    `executeBatch()` one more time when the last statement is added to the batch if
    this last batch is smaller than the `batchSize` value. As you can see from the
    comment to the previous code, `executeBatch()` was called four times, including
    when the last statement was added (when `i=99999`). The performance of this code
    in our runs was the same as without generating multiple batches, because our database
    is located on the same computer as the application. Otherwise, the delivery of
    each batch over the network would add to the time that it took to execute this
    code.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last example (step 5) of the previous sub-section is an ultimate implementation
    of a batch process that can be used for inserting and updating records in a database.
    The method `executeBatch()` returns an array of `int`, which, in the case of success,
    indicates how many rows were updated by each of the statements in the batch. In
    the case of an `INSERT` statement, this value equals -2 (negative two), which
    is the value of the static constant `Statement.SUCCESS_NO_INFO`. The value of
    -3 (negative three), which is the value of the constant `Statement.EXECUTE_FAILED`,
    indicates a statement failure.
  prefs: []
  type: TYPE_NORMAL
- en: If the returned updated row count is expected to be bigger than `Integer.MAX_VALUE`,
    use the method `long[] executeLargeBatch()` to execute the batch.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is no batch processing for reading data from the database. To read data
    in bulk, you can send many statements separated by a semicolon as one string to
    the database and then iterate over the returned multiple result sets. For example,
    let''s submit `SELECT` statements that count the number of records for each of
    the age values from 1 to 99 inclusive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'In our test run, it took 2,162 milliseconds to execute the preceding code and
    display the following message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Moving large sets of data to and from PostgreSQL database can also be done using
    the `COPY` command, which copies data to and from a file. You can read more about
    it in the database documentation ([https://www.postgresql.org/docs/current/static/sql-copy.html](https://www.postgresql.org/docs/current/static/sql-copy.html)).
  prefs: []
  type: TYPE_NORMAL
- en: Using MyBatis for CRUD operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipes, while using JDBC, we had the write code, which extracts
    the results of the query from a `ResultSet` object returned by the query. The
    disadvantage of this approach is that you have to write quite a bit of boilerplate
    code to create and populate domain objects that represent records in the database.
    As we have mentioned already in the introduction to this chapter, there are several
    ORM frameworks that can do this for you and create the corresponding domain objects
    automatically (or, in other words, to map database records to the corresponding
    domain objects). Naturally, every such framework takes away some of the control
    and flexibility in constructing SQL statements. So, before committing to a particular
    ORM framework, you need to research and experiment with different frameworks to
    find the one that provides everything the application needs with respect to the
    database and does not create too much of an overhead.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn about the SQL Mapper tool MyBatis, which simplifies
    database programming compared to using JDBC directly.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'MyBatis is a lightweight ORM framework that allows not only mapping the results
    to Java objects but also executing an arbitrary SQL statement. There are principally
    two ways to describe the mapping:'
  prefs: []
  type: TYPE_NORMAL
- en: Using Java annotations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using XML configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this recipe, we are going to use XML configuration. But, whichever style
    you prefer, you need to create an object of the type `org.apache.ibatis.session.SqlSessionFactory`
    and then use it to start a MyBatis session by creating an object of the type `org.apache.ibatis.session.SqlSession`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'The `SqlSessionFactoryBuilder` object has nine overloaded `build()` methods
    that create the `SqlSession` object. These methods allow for configuring the SQL
    execution environment. Using them, you can define the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Whether you prefer to auto-commit database changes or to do them explicitly
    (we use the latter in our examples)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whether you will use the configured datasource (as in our examples) or use the
    externally provided database connection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whether you will use the default database-specific transaction isolation level
    (as in our example) or would like to set your own
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which of the following `ExecutorType` values you will use—`SIMPLE` (default,
    creates a new `PreparedStatement` for each execution of a statement), `REUSE`
    (reuses `PreparedStatements`), or `BATCH` (batches all update statements and demarcate
    them as necessary if `SELECT`s are executed between them)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which environment (`development`, `test`, or `production`, for example) this
    code is deployed to, so the corresponding section of the configuration will be
    used (we will discuss it shortly)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Properties` object that contains the configuration of the datasource
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `SqlSession` object provides methods that allow you to execute `SELECT`,
    `INSERT`, `UPDATE`, and `DELETE` statements that are defined in the SQL mapping
    XML files. It also allows you to commit or rollback the current transaction.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Maven dependency we used for this recipe is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: At the time of writing this book, the latest MyBatis documentation can be found
    here: [http://www.mybatis.org/mybatis-3/index.html ](http://www.mybatis.org/mybatis-3/index.html)
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will start with CRUD operations by using the PostgreSQL database and the
    class `Person1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: We need the previous `getId()` method to get an ID value (to demonstrate how
    to find a database record by ID). The method `setName()` will be used to update
    the database record, and the method `toString()` will be used to display the results.
    We use the name `Person1` to distinguish it from another version of the same class, `Person2`,
    which we will use to demonstrate how to implement the relationship between classes
    and the corresponding tables.
  prefs: []
  type: TYPE_NORMAL
- en: 'The matching database table can be created using the following SQL statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'Then execute the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by creating an XML configuration file. We will call it `mb-config1.xml`
    and place it in the folder `mybatis` under `resources`. This way, Maven will put
    it on a classpath. Another option would be to place the file in any other folder
    along with the Java code and modify `pom.xml` to tell Maven to put the `.xml`
    files from that folder on the classpath too. The content of the `mb-config1.xml` file
    looks as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: The `<settings>` tag allows for defining some behavior globally—lazy loading
    of the values, enable/disable the cache, set auto-mapping behavior (to populate
    nested data or not), and more. We have chosen to set the usage of auto-generated
    keys globally because we need the inserted objects to be populated with IDs generated
    in the database.
  prefs: []
  type: TYPE_NORMAL
- en: The `<typeAiases>` tag contains aliases of the fully qualified class names,
    which work similar to the `IMPORT` statement. The only difference is that an alias
    can be any word, not just a class name. After the alias is declared, everywhere
    else in the MyBatis `.xml` files, the class can be referred by this alias only.
    We will see how to do this while reviewing the content of the file `Person1Mapper.xml`
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: The `<environments>` tag contains configuration for different environments.
    For example, we could have a configuration for the environment `env42` (any string
    would do). Then, while creating a `SqlSession` object, you can pass this name
    as the parameter of the method `SqlSessionFactory.build()` and the configuration
    included in the tags `<environment id="env42"></environment>` will be used. It
    defines the transaction manager to be used and the datasource.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `TransactionManager` may be one of two types—JDBC, which uses the connection
    provided by the datasource to commit, rollback, and manage the scope of the transaction,
    and `MANAGED`, which does nothing and allows the container to manage the lifecycle
    of the transaction—well, it closes the connection by default, but that behavior
    can be changed by setting the following property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: The tag `<mappers>` contains references to all the `.xml` files that contain
    SQL statements that map database records and Java objects, which in our case is
    the file `Person1Mapper.xml`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `Person1Mapper.xml` file and put it in the same folder as the `mb-config1.xml` file.
    This file can have any name you like, but it contains all SQL statements that
    map database records and objects of the class `Person1`, so we have named it `Person1Mapper.xml` just
    for the sake of clarity:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `<mapper>` tag has a `namespace` attribute which is used
    to resolve files with the same name in different locations. It may or may not
    match the mapper file location. The mapper file location is specified in the configuration
    file `mb-config1.xml` as the attribute resource of the tag `<mapper>` (see the
    previous step).
  prefs: []
  type: TYPE_NORMAL
- en: The attributes of the tags `<insert>`, `<select>`, `<update>`, and `<delete>`
    are self-explanatory for the most part. The attributes `keyProperty`, `keyColumn`,
    and `useGeneratedKeys` (in the configuration `<settings>`) are added to populate
    the inserted object with the value generated by the database. If you don't need
    it globally, the attribute `useGeneratedKeys` can be removed from the settings
    in the configuration and added only to those insert statements where you would
    like to take advantage of the auto-generation of some value. We did this because
    we wanted to get the generated ID and use it in the code later to demonstrate
    how the record can be retrieved by ID.
  prefs: []
  type: TYPE_NORMAL
- en: The ID attribute of `<select>` and similar tags are used to invoke, them along
    with the mapper namespace value. We will show you how this is done shortly. The
    construct `#{id}` refers to the value passed in as a parameter if the value is
    of a primitive type. Otherwise, the passed in object is expected to have such
    a field. Having a getter on the object is not required. If a getter is present,
    it has to comply with the JavaBean method format.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the return value, by default, the name of a column matches the name of
    the object field or setter (has to be compliant with JavaBean method format).
    If the field (or the setter name) and the column name are different, you can provide
    mapping using the tag `<resultMap>`. For example, if the table `person` has the
    columns `person_id` and `person_name`, while the domain object `Person` has the
    fields `id` and `name`, we can create a map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'This `resultMap` can then used to populate the domain object `Person` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, it is possible to use the standard select clause aliases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'Write code that inserts a record in the table `person1` and then reads this
    record by `id`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will produce an output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: The utility `Resources` has ten overloaded methods for reading the configuration
    file. We have already described how to make sure that Maven places the configuration
    and mapper files on the classpath.
  prefs: []
  type: TYPE_NORMAL
- en: The `SqlSession` object implements the `AutoCloseable` interface, so we can
    use the try-with-resources block and not worry about leaking resources. The `SqlSession` interface
    provides many execution methods, including the overloaded methods `insert()`,
    `select()`, `selectList()`, `selectMap()`, `selectOne()`, `update()`, and `delete()`,
    to name the most often used and straightforward ones. We also have used `insert()`
    and `selectOne()`. The latter makes sure that only one result is returned. Otherwise,
    it throws an exception. It also throws an exception when the column used to identify
    a single record by a value does not have a unique constraint. That is why we have
    added the `PRIMARY KEY` qualification to the column ID. Alternatively, we could
    just add a unique constraint (marking it as `PRIMARY KEY` does this implicitly).
  prefs: []
  type: TYPE_NORMAL
- en: The `selectList()` method, on the other hand, produces a `List` object, even
    when only one result is returned. We will demonstrate this now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Write code that reads all the records from the table `person1`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will produce the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'To demonstrate an update, let''s change the name of `"John"` to `"Bill"` and
    read it all the records in the `person1` again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will produce the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice how the change was committed: `session.commit()`. Without this line,
    the result is the same, but the change does not persist because the transaction
    is not autocomitted by default. It can be changed by setting autocommit to `true`
    while opening the session:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, call the `DELETE` statement and remove all the records from the table
    `person1`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will produce the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'To demonstrate how MyBatis supports relationships, create the table `family`
    and the table `person2`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the records in the tables `family` and `person2` have one-to-many
    relationships. Each record of the table `person2` may belong to a family (refer
    to a `family` record) or not. Several persons can belong to the same family. We
    have also added the `ON DELETE CASCADE` clause so that the `person2` records can
    be deleted automatically when the family they belong to is deleted.
  prefs: []
  type: TYPE_NORMAL
- en: 'The corresponding Java classes look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: As you see, the class `Family` has a collection of `Person2` objects. For the
    methods `getId()` and `getMembers()`, we need to establish the relationship with
    the `Person2` class. Will will use the method `getName()` for the demonstration
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The class `Person2` looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new configuration file called `mb-config2.xml`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we now had two aliases and two mapper `.xml` files.
  prefs: []
  type: TYPE_NORMAL
- en: 'The content of the `Person2Mapper.xml` file is much smaller than the content
    of the `Person1Mapper.xml` file that we used before:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: That is because we are not going to update or manage these persons directly.
    We are going to do this via the families they belong to. We have added a new query
    that returns the count of the records in the `person2` table.
  prefs: []
  type: TYPE_NORMAL
- en: 'The content of the `FamilyMapper.xml` file is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'The family mapper is much more involved because we manage the relationship
    in it. First, look at the query `selectMembersOfFamily`. If you don''t want to
    populate the field `family` in the object of `Person2`, the SQL would be much
    simpler, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: But we wanted to set the corresponding `Family` object value in the `Person2`
    object, so we used the `ResultMap` `personMap` that describes only the mapping
    that cannot be done by default—we used the `<association>` tag to associate the
    field `family` with the column `family_id` a using the query `selectFamilyById`.
    This last query will not populate the field `members` of the `Family` object,
    but we decided it is not needed for our demonstration.
  prefs: []
  type: TYPE_NORMAL
- en: We reuse the query `selectMembersOfFamily` in the query `selectFamilies`. To
    populate the field `members` of the `Family` object, we created a `ResultMap`
    `familyMap` that uses `selectMembersOfFamily` to do that.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s write the code that demonstrates CRUD operations on the `family` table.
    First, here''s how a `family` record can be created and associated with two `person2`
    records:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can read the created records by using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code snippet produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can delete all `family` records and check if any of the tables for `family`
    and `person2` contain any records after it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code snippet is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: The table `person2` is empty now too because we added the clause `ON DELETE
    CASCADE` while creating the table.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MyBatis also provides facilities for building a dynamic SQL, a SqlBuilder class,
    and many other ways to construct and execute SQL of any complexity or a stored
    procedure. For the details, read the documentation at [http://www.mybatis.org/mybatis-3](http://www.mybatis.org/mybatis-3).
  prefs: []
  type: TYPE_NORMAL
- en: Using the Java Persistence API and Hibernate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to populate, read, change, and delete data
    in the database using a **Java Persistence API** (**JPA**) implementation called
    the **Hibernate Object-Relational Mapping** (**ORM**) framework.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'JPA is a specification that defines a possible solution for ORM. You can find
    JPA Version 2.2 at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'The interfaces, enums, annotations, and exceptions described in the specification
    belong to the package `javax.persistence` ([https://javaee.github.io/javaee-spec/javadocs](https://javaee.github.io/javaee-spec/javadocs))
    that is included in **Java Enterprise Edition** (**EE**). The JPA is implemented
    by several frameworks, the most popular of them being:'
  prefs: []
  type: TYPE_NORMAL
- en: Hibernate ORM ([http://hibernate.org/orm](http://hibernate.org/orm))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: EclipseLink ([http://www.eclipse.org/eclipselink](http://www.eclipse.org/eclipselink))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Oracle TopLink ([http://www.oracle.com/technetwork/middleware/toplink/overview/index.html](http://www.oracle.com/technetwork/middleware/toplink/overview/index.html))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: jOOQ ([https://www.jooq.org](https://www.jooq.org))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JPA is designed around entities—the Java beans that are mapped to the database
    tables using annotations. Alternatively, the mapping can be defined using XML
    or a combination of both. The mapping defined by XML supersedes the one defined
    by the annotations. The specification also defines an SQL-like query language
    for static and dynamic data queries.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the JPA implementations allow for the creation of a database schema
    using the mapping defined by annotations and XML.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start with adding the `javax.persistence` package dependency to the
    Maven configuration file `pom.xml`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: We don't need any of the JPA implementations yet. This way, we can make sure
    that our code does not use any framework-specific code and uses only JPA interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the class `Person1`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: We don't add getters, setters, or any other methods; this is so that we can
    keep our code example short and simple. To convert this class into an entity we
    need, according to the JPA spec, to add the annotation `@Entity` to the class
    declaration (requires importing  `java.persistence.Entity`). This means that we
    would like this class to represent a record in a database table called `person`.
    By default, the name of the entity's class matches the name of the table. But
    it is possible to map the class to a table with another name using the annotation `@Table(name="<another
    table name>")`. Similarly, each class property is mapped to a column with the
    same name, and it is possible to change the default name by using the annotation
    `@Column (name="<another column name>")`.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, an entity class must have a primary key—a field depicted by the
    annotation `@Id`. A composite key that combines several fields can be defined
    using the annotation `@IdClass` too (not used in our examples). If the primary
    key is auto-generated in the database, the `@GeneratedValue` annotation can be
    placed in front of that field.
  prefs: []
  type: TYPE_NORMAL
- en: 'And, finally, an entity class must have a constructor without arguments. With
    all these annotations, the entity class `Person` now looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: Neither the class nor any of its persistent instance variables can be declared
    final. This way, the implementing frameworks can extend the entity classes and
    implement the required functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, the persistence annotations can be added to the getters and setters,
    instead of the instance fields (if the method names follow Java bean conventions).
    But mixing up fields and methods annotations is not allowed and may lead to unexpected
    consequences.
  prefs: []
  type: TYPE_NORMAL
- en: It is also possible to use an XML file instead of an annotation to define the
    mapping between a Java class and a database table and columns, but we are going
    to stay with field level annotations in order to provide the most compact and
    clear method to express the intent.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a database table called `person1` using the following SQL script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: We have defined the column `id` as `SERIAL`, which means that we ask the database
    to generate the next integer value automatically every time a new row is inserted
    into the table `person1`. It matches the annotations of the property `id` of the
    class `Person1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s write some code that inserts a record into the table `person1`
    and then reads all the records from it. To create, update, and delete an entity
    (and the corresponding record in the corresponding table), you need to use an
    entity manager such as `javax.persistence.EntityManager`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, an object of `EntityManagerFactory` is created using some configuration,
    that is, `jpa-demo`. We will talk about it shortly. The factory allows for the
    creation of an `EntityManager` object, which controls the persistence process:
    creates, commits, and rolls back a transaction, stores a new `Person1` object
    (thus inserting a new record in the table `person1`), supports reading data using **Java
    Persistence Query Language** (**JPQL**), and many other database operations and
    transaction management processes.'
  prefs: []
  type: TYPE_NORMAL
- en: After the entity manager is closed, the managed entities are in a detached state.
    To synchronize them again with the database, one can use the method `merge()`
    of `EntityManager`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous example, we have JPQL to query the database. Alternatively,
    we could use the Criteria API defined by the JPA specification, too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: But it seems that JPQL is less verbose and supports the intuition of those programmers
    who know SQL, so we are going to use JPQL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Define the persistence configuration in the file `persistence.xml` located
    in the folder `resources/META-INF`. The tag `<persistence-unit>` has an attribute
    name. We have set the attribute value to `jpa-demo`, but you can use any other
    name you like. This configuration specifies JPA implementation (provider), database
    connection properties, and many other persistence-related properties in an XML
    format:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: Refer to the Oracle documentation ([https://docs.oracle.com/cd/E16439_01/doc.1013/e13981/cfgdepds005.htm](https://docs.oracle.com/cd/E16439_01/doc.1013/e13981/cfgdepds005.htm))
    about the configuration of the `persistence.xml` file. For this recipe, we used
    the Hibernate ORM and, thus, specified `org.hibernate.jpa.HibernatePersistenceProvider`
    as a provider.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we need to add JPA implementation (Hibernate ORM) as a dependency
    in `pom.xml`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: As you may have noticed, we have marked Hibernate dependencies as scoped for `runtime`.
    We did this to avoid using Hibernate-specific features while writing the code.
    We have also added the `jaxb-api` dependency, which is used by Hibernate, but
    this library is not Hibernate-specific, so we did not make it used at runtime
    only.
  prefs: []
  type: TYPE_NORMAL
- en: 'For better result presentation, we will add the following `toString()` method
    to the class `Person1`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can run our JPA code example and observe the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: The first two lines of the preceding output come from JPQL usage, and the last
    line comes from the Criteria API usage fragment of our code example.
  prefs: []
  type: TYPE_NORMAL
- en: 'JPA also has a provision for establishing relationships between classes. An
    entity class (and the corresponding database table) can have one-to-one, one-to-many,
    many-to-one, and many-to-many relationships with another entity class (and its
    table). The relationship can be bidirectional or unidirectional. This specification
    defines the following rules for a bidirectional relationship:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The inverse side must refer to its owning side using the `mappedBy` attribute
    of the annotation `@OneToOne`, `@OneToMany`, or `@ManyToMany`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The many side of one-to-many and many-to-one relationships must own this relationship,
    so the `mappedBy` attribute cannot be specified on the `@ManyToOne` annotation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In one-to-one relationships, the owning side is the side that contains the foreign
    key.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In many-to-many relationships, either side may be the owning side.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With a unidirectional relationship, only one class has a reference to the other
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate these rules, let''s create a class called `Family` that has a
    one-to-many relationship with the class `Person2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: 'The SQL script that creates the table `family` is straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: 'We need also to add the `Family` field to the class `Person2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Person2` class is a "many" side, so, according to this rule, it owns the
    relationship, so the table `person2` has to have a foreign key that points to
    the record of the table `family`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: 'Reference to a column requires this column value to be unique. That is why
    we have marked the column `id` of the table `person2` as `PRIMARY KEY`. Otherwise,
    an error `ERROR:  42830: there is no unique constraint matching given keys for
    referenced table` would be raised.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can use the classes `Family` and `Person2` to create the records in
    the corresponding tables and read from these tables, too:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code, we created an object of the class `Family` and persisted
    it. This way, the object acquires an `id` value from the database. We then passed
    it into the constructor of the class `Person2` and established the relationship
    on the many sides. Then, we persisted the `Person2` object (so that it acquired
    an `id` from the database, too) and added to the collection `members` of the `Family` object,
    so the one side of the relationship is established too. To preserve data, the
    transaction has to be committed. When the transaction is committed, all the entity
    objects associated with an `EntityManager`  (such objects are said to be in a** managed**
    state) are persisted automatically.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we run the preceding code, the result will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, that is exactly what we expected—an object of class `Family The
    Jones` has one member—an object of class `Person2`, and the record in the table
    `person2` refers to the corresponding record of the table `family`.
  prefs: []
  type: TYPE_NORMAL
