- en: Chapter 5. Design Patterns in Laravel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will discuss the design patterns Laravel uses, and how and
    why are they used, with examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics that will be discussed in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Design patterns used in Laravel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The reasons these patterns are used in Laravel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Builder (Manager) pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This design pattern aims to gain simpler, reusable objects. Its goal is to separate
    bigger and more convoluted object construction layers from the rest so that the
    separated layers can be used in different layers of the application.
  prefs: []
  type: TYPE_NORMAL
- en: The need for the Builder (Manager) pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Laravel, the `AuthManager` class needs to create some secure elements to
    reuse with selected auth storage drivers such as cookie, session, or custom elements.
    To achieve this, the `AuthManager` class needs to use storage functions such as
    `callCustomCreator()` and `getDrivers()` from the `Manager` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how the Builder (Manager) pattern is used in Laravel. To see what
    happens in this pattern, navigate to the `vendor/Illuminate/Support/Manager.php`
    and `vendor/Illuminate/Auth/AuthManager.php` files, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, navigate to the `/vendor/Illuminate/Auth/AuthManager.php` file, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As we can see in the preceding code, the `AuthManager` class extends from the
    `Manager` class. Laravel ships with a basic auth mechanism. So, we need to store
    auth credentials in a database. First, the class checks our default database configuration
    with the `AuthManager::setDefaultDriver()` function. This function actually uses
    the `Manager` class for eloquent operations. All the database and auth options
    (such as cookie name) are obtained from the application's config file, except
    the auth model table name.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand this Builder (Manager) pattern better, we can take the following
    presentation as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The need for the Builder (Manager) pattern](Image00009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding example diagram, we assumed that we want to fetch data, for
    example, pizza, from the previous illustration. The client ordered two pizzas:
    an Asian pizza and/or a Chinese pizza. This pizza is requested through the `Waiter`
    class. The `PizzaBuilder` class (which is the `Manager` class, in our case) made
    a pizza according to the `AuthRequest` request, in our case, and delivered the
    pizza through the waiter.'
  prefs: []
  type: TYPE_NORMAL
- en: Also, you can navigate to `vendor/Illuminate/Session/SessionManage.php` and
    check for the use of this pattern in Laravel Framework.
  prefs: []
  type: TYPE_NORMAL
- en: 读累了记得休息一会哦~
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**公众号：古德猫宁李**'
  prefs: []
  type: TYPE_NORMAL
- en: 电子书搜索下载
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 书单分享
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 书友学习交流
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**网站：**[沉金书屋 https://www.chenjin5.com](https://www.chenjin5.com)'
  prefs: []
  type: TYPE_NORMAL
- en: 电子书搜索下载
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 电子书打包资源分享
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 学习资源分享
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Factory pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this subsection, we'll examine the Factory pattern and its usage in Laravel
    Framework. The Factory pattern is based on creating template method objects, which
    is based on defining the algorithm of a class in a subclass to implement an algorithm.
    There is a subclass, which is derived from a big superclass, in this pattern structure.
    The main class, which we may call a superclass, only holds major and generic logic;
    the subclasses are derived from this superclass. As a result, there may be more
    than one subclass inherited from this superclass, which are aimed at different
    purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike other design patterns used in Laravel, the `Factory` method is more customizable.
    For an extended subclass plus main class, you don't need to set a new class, just
    a new operation. This method is beneficial if the class or its components usually
    change, or methods need to be overridden, much like initialization.
  prefs: []
  type: TYPE_NORMAL
- en: While creating a design, developers usually start with using the Factory pattern
    in their applications. Such a pattern is changed into an abstract Factory, Builder,
    or Prototype pattern. Unlike the Factory pattern, the Prototype pattern requires
    initialization once. Due to the pattern's architecture, the methods of the Factory
    pattern (Factory methods) are usually called inside template methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are some differences between the Factory pattern and the Abstract Factory
    or Prototype pattern. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Unlike an Abstract Factory pattern, the Factory pattern can't be implemented
    using the Prototype pattern.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unlike the Prototype pattern, the Factory pattern doesn't need an initialization,
    but it needs subclassing. This is an advantage when compared with other patterns.
    Thanks to this approach, the Factory pattern can return an injected subclass instead
    of an object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since the classes designed with the Factory pattern may return subclasses directly
    for other components, no other class or component needs to know and access the
    constructor methods. Due to this, it's recommended that all constructor methods
    and variables should be protected or private.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is another thing to take into consideration. As this pattern might return
    subclasses aimed for the exact need, it's not recommended to make a new instance
    of the class using this pattern using the key new.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The need for the Factory pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Laravel ships various types of validation rules with the `Validation` class.
    When we develop applications, we usually need to validate data as we proceed.
    To do this, a common approach is to set the validation rules in the Model and
    call them from the Controller. By "rules" here, we mean both validation type and
    its range.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, we need to set custom rules and custom error messages to validate
    the data. Let's examine how it works and how we are able to extend the `Validation`
    class to create custom rules. The Controller in the MVC pattern can also be described
    as a bridge between Model and View. This can best be explained with a live world
    example.
  prefs: []
  type: TYPE_NORMAL
- en: Let's assume we have a news aggregation website. In the administration panel,
    an administrator tries to delete the news item. In the SOLID design pattern, this
    happens if an admin clicks on the **Delete News** button.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, as an example to check, let''s open the `vendor/Illuminate/Validation/Factory.php`
    file, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see in the preceding code, the `Validation Factory` class is constructed
    with the `Translator` class and an IoC container. The `addExtensions()` function
    is set after this. This method includes the user-defined extensions to a `Validator`
    instance, thus allowing us to write the template (structure) to create the `Validator`
    class''s extensions. The functions, which are public, allow us to implement the
    `Translator` class, and by this we mean that they allow us to write custom validation
    rules and messages. Refer to the following **CarFactory** diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The need for the Factory pattern](Image00010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding diagram, you can see that all cars are based on **CarFactory**
    (the basics of all cars), regardless of the brand. For all brands, the main process
    is the same (all cars have an engine, tires, brakes, bulbs, gear, and so on).
    You may want either a **Suzuki** car or a **Toyota** car, and depending on this
    choice, the **SuzukiFactory** or **ToyotaFactory** creates a **Suzuki** car or
    a **Toyota** car from the **CarFactory** .
  prefs: []
  type: TYPE_NORMAL
- en: The Repository pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Repository pattern is usually used to create an interface between two distinct
    layers of an application. In our case, the developers of Laravel use this pattern
    to create an abstract layer between `NamespaceItemResolver` (the class that resolves
    the namespaces and understands which file is in which namespace) and `Loader`
    (a class that requires and loads another class into the application). The `Loader`
    class simply loads the given namespace's configuration group. As you might know,
    nearly all of the Laravel Framework code is developed using namespaces.
  prefs: []
  type: TYPE_NORMAL
- en: The need for the Repository pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's assume you're trying to fetch a product from your database using Eloquent
    ORM. The method will be something like `Product::find(1)` in your Controller.
    For abstraction purposes, this approach is not ideal. If you now put a code such
    as this, your Controller knows you're using Eloquent, which ideally shouldn't
    happen in a good and abstracted structure. If you want to contain the changes
    done to the database scheme so that the calls outside of the class do not reference
    to the fields directly but through a repository, you have to dig all codes one
    by one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s create an `imaginart` repository interface (a list of methods that
    will be used in the pattern) for the users. Let''s call it `UserRepository.php`
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, you can see that all the methods'' names used in the Model are declared
    one by one. Now, let''s create the repository and name it `EloquentUserRepository.php`
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this repository class implemented our `UserRepository` that
    we created earlier. Now, you need to bind the two so that when the `UserRepositoryInterface`
    interface is called, we actually acquire `EloquentUserRepository` .
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be done either with a service provider or by a simple command, such
    as the following, in Laravel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now, in your Controllers, you can simply use the repositories as `Use Arda\Storage\User\UserRepository
    as User` .
  prefs: []
  type: TYPE_NORMAL
- en: Every time the controller uses a `User::find($id)` code, it first goes to the
    interface, and then goes to the binded repository, which is the Eloquent repository
    in our case. Through this, it goes to the Eloquent ORM. This way, it's impossible
    for the Controller to know how the data is fetched.
  prefs: []
  type: TYPE_NORMAL
- en: The Strategy pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The best approach to describe the Strategy pattern is through a problem.
  prefs: []
  type: TYPE_NORMAL
- en: The need for the Strategy pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this design pattern, the logic is extracted from complex classes into easier
    components so that they can be replaced easily with simpler methods. For example,
    you want to show popular blog posts on your website. In a classic approach, you
    will calculate the popularity, make the pagination, and list the items relative
    to the current paginated offset and popularity, and make all calculations in a
    simple class. This pattern aims to separate each algorithm into separate components
    so that they can be reused or combined in other parts of the application easily.
    This approach also brings flexibility and makes it easy to change an algorithm
    system wide.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand this better, let''s take a look at the following loader interface
    located at `vendor/Illuminate/Config/LoaderInterface` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: When we dig the code, the `LoaderInterface` works will follow a certain structure.
    The `getNamespaces()` function loads all namespaces defined in the `app\config\app.php`
    file. The `addNamespace()` method passes the namespaces to the `load()` function
    as grouped. If the `exist()` function returns `true` , there is at least one configuration
    group that belongs to a given namespace. For the full structure, you can refer
    to the repository section of this chapter. As a result, you can easily call the
    method that you need through an interface of the `Loader` class to load various
    configuration options. If we download a package through the composer, or implement
    a package to an application that is being authored, the pattern makes all of them
    available and loads them from their own namespaces without any conflicts, though
    they are inside different namespaces or have the same filenames.
  prefs: []
  type: TYPE_NORMAL
- en: The Provider pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Provider pattern was formulated by Microsoft for use in the ASP.NET Starter
    Kits and formalized in .NET Version 2.0 ([http://en.wikipedia.org/wiki/Provider_model](http://en.wikipedia.org/wiki/Provider_model)
    ). It is a mid layer between an API class and the Business Logic/Data Abstraction
    Layer of the application. The provider is the implementation of the API separated
    from the API itself.
  prefs: []
  type: TYPE_NORMAL
- en: This pattern, its aims, and its usage are quite similar to the Strategy pattern.
    This is why many developers are already discussing whether to accept this approach
    as a design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand these patterns better, let''s open `vendor/Illuminate/Auth/AuthServiceProvider.php`
    and `vendor/Illuminate/Hashing/HashServiceProvider.php` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, both the classes extend `ServiceProvider` . The `AuthServiceProvider`
    class allows us to provide all services to `AuthManager` when an authentication
    request, such as checking whether a cookie and session is created or whether the
    content is invalid, is sent. After the authentication service has been requested,
    the developer can define whether a session or cookie is set through the response
    through `AuthDriver` .
  prefs: []
  type: TYPE_NORMAL
- en: However, `HashServiceProvider` provides us with the related methods when a secure
    hash request is done so that we can use, fetch, check, or do other things with
    these hashes. Both providers return the values as an array.
  prefs: []
  type: TYPE_NORMAL
- en: The Facade pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Facade (façade) pattern allows a developer to unite various complicated
    interfaces into a single class interface. This pattern also allows you to wrap
    various methods from various classes into a single structure.
  prefs: []
  type: TYPE_NORMAL
- en: '![The Facade pattern](Image00011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In Laravel 4, as you may already know, almost every method looks like a static
    method, for example, `Input::has()` , `Config::get()` , `URL::route()` , `View::make()`
    , and `HTML::style()` . However, they are not static methods. If they were static
    methods, it would be quite hard to make tests for them all. They are actually
    the mimics of this behavior. In the background, with the help of the IoC Container
    (a way to inject dependencies into a class), Laravel actually calls another class(es)
    through a `Facade` class. The Facade base class benefits from PHP's own `__callStatic()`
    magic method to call the required methods, such as static methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s assume we have a method called `URL::to(''home'')` . Let''s
    check what the URL is and what it refers to. First, let''s open `app/config/app.php`
    . In the aliases array, there is a line like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: So, if we call `URL::to('home')` , we actually call `Illuminate\Support\Facades
    \URL::to('home')` .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s check what''s inside the file. Open the `vendor/Illuminate/Support/Facades/URL.php`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the class actually extends from the `Facade` class, and there
    is no static method called `to()` . Instead, there is a method called `getFacadeAccessor()`
    , which returns the string `url` . The `getFacadeAccessor()` method's purpose
    is to define what to inject. This way, Laravel understands that this class is
    looking for `$app['url']` .
  prefs: []
  type: TYPE_NORMAL
- en: 'This is defined in `vendor/Illuminate/Routing/RoutingServiceProvider.php` ,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, it returns a new instance of the `UrlGenerator` class in the
    same namespace, which holds the `to()` method we''re looking for:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: So each time you use a method like this, Laravel first goes to and checks the
    facade, it then checks what's injected through, and then the real method through
    the `injected` class is called.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about various design pattern uses in the Laravel
    PHP framework, how and why they are used, and what problems they can solve.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll learn about best practices to create an application
    using Laravel using the design patterns in our code in a Laravel project.
  prefs: []
  type: TYPE_NORMAL
