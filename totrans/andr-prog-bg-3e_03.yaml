- en: '*Chapter 3*: Exploring Android Studio and the Project Structure'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will create and run two more Android projects. The purpose
    of these exercises is to explore more deeply Android Studio and the structure
    of Android projects.
  prefs: []
  type: TYPE_NORMAL
- en: When we build our apps ready for deployment, the code and the resource files
    need to be packed away in an **Android Package** (**APK**) file—just right. Therefore,
    all the layout files (and other resources that we will soon discover) need to
    be in their correct structures.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, Android Studio handles this for us when we create a project from
    a template. However, we still need to know how to find and amend these files,
    how to add our own (and sometimes remove) files created by Android Studio, and
    how the resource files are interlinked, sometimes with each other and sometimes
    with the Java code (autogenerated and our own).
  prefs: []
  type: TYPE_NORMAL
- en: Along with understanding the composition of our projects, it will also be beneficial
    to make sure we get the most from the emulator.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Emulators are particularly useful when you want to make sure that your app will
    work on hardware that you don't own. Also, learning about some of the latest features
    (as we will in this book) often requires the latest handset, and an emulator is
    a cost-effective way of following along with all the mini-apps without buying
    the latest phone.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will look at the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the file and folder structure of the **Empty Activity** project template
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring the file and folder structure of the **Basic Activity** project template
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Seeing the difference between the **Empty Activity** and **Basic Activity**
    templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring the Android emulator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter will leave us in a good position to build and deploy multiple different
    **user interface** (**UI**) designs in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find the code present in this chapter on GitHub at [https://github.com/PacktPublishing/Android-Programming-for-Beginners-Third-Edition/tree/main/chapter%2003](https://github.com/PacktPublishing/Android-Programming-for-Beginners-Third-Edition/tree/main/chapter%2003).
  prefs: []
  type: TYPE_NORMAL
- en: Project Explorer and project anatomy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we create a new Android project, we most often do so using a project template,
    just as we did in [*Chapter 1*](B16773_01_ePub_RK.xhtml#_idTextAnchor014)*,* *Beginning
    Android and Java*. The template we use determines the exact selection and contents
    of files that Android Studio will generate. While there are big similarities across
    all projects that are worth noting, seeing the differences can also help. Let's
    build two template projects and examine the files, their contents, and how they
    are all linked together through the code (**Extensible Markup Language** (**XML**)
    and Java). We begin by creating an **Empty Activity** project.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the file and folder structure of the Empty Activity project template
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The simplest project type with an autogenerated UI is the **Empty Activity**
    project template. The UI is almost empty, but it is there ready to be added to.
    When we create a project even with an empty UI, Android Studio also autogenerates
    the Java code to display the UI. Therefore, when we add it to the empty UI, it
    is ready to be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: Let's create an **Empty Activity** project. This is almost the same process
    as in [*Chapter 1*](B16773_01_ePub_RK.xhtml#_idTextAnchor014), *Beginning Android
    and Java*, with one slight difference that I will point out.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have the project from [*Chapter 2*](B16773_02_ePub_RK.xhtml#_idTextAnchor043)*,
    First Contact: Java, XML, and the UI Designer,* open, select **File** | **New**
    | **New Project…**. Alternatively, if you are on the Android Studio welcome screen,
    select **Start a new Android Studio project**. Then, proceed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: On the **Select a Project Template** window, select **Empty Activity**. This
    is the bit that is different from what we did in [*Chapter 1*](B16773_01_ePub_RK.xhtml#_idTextAnchor014)*,*
    *Beginning Android and Java*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `Empty Activity App`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The rest of the settings can be left at their defaults, so just click **Finish**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Android Studio will generate all the code and the other project resources. Now,
    we can see what has been generated and relate it to what we already know about
    what to expect in the **Project Explorer** window.
  prefs: []
  type: TYPE_NORMAL
- en: If the emulator is not already running, launch it by selecting **Tools** | **AVD
    Manager**, and then start your emulator in the **Your Virtual Devices** window.
    Run the app on the emulator by clicking the play button in the quick launch bar,
    as we have done a few times already for our previous project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at the app and notice how it is a little bit different from that of the
    first project. It is—well—empty: no menu at the top; no floating button at the
    bottom. It does, however, still have some text that says **Hello World!**, as
    can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – Hello world!'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.01_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.1 – Hello world!
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a brand-new **Empty Activity** project, let's explore the files
    and folders that Android Studio has generated for us.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring an Empty Activity project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, it is time to go on a deep dive into the files and folders of our app.
    This will save us lots of time and head-scratching later in the book. Please note,
    however, that there is no need to memorize where all these files go, and there
    is even less need to understand the code within the files. In fact, parts of the
    XML will remain a mystery even at the end of the book, but this will not stop
    you designing, coding, and releasing amazing apps.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following screenshot, look at the Project Explorer window as it is just
    after the project is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – Project Explorer window'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.02_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.2 – Project Explorer window
  prefs: []
  type: TYPE_NORMAL
- en: Notice the two arrows indicated in the previous screenshot? These, as you can
    probably guess, allow us to expand the `app` and `Gradle Scripts` folders. It
    is possible that your folders are already expanded. Why not try out the arrows,
    and expand and collapse them a few times?
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: We do not need to explore the `Gradle Scripts` folder in the context of this
    book. Gradle is a significant part of Android Studio, but its role is to hide
    from the user the quite complicated processes that Android Studio performs—things
    such as adding resource files, and compiling and building projects. Therefore,
    we don't need to dig into this any further. If, however, you decide to take Android
    to the next level, then getting a good understanding of Gradle and its relationship
    with Android Studio is time well invested.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will explore in detail the `app` folder. Click the arrow next to the `app`
    folder to expand its contents, and we will begin exploring. The first level of
    contents is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3 – Exploring the app folder'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.03_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.3 – Exploring the app folder
  prefs: []
  type: TYPE_NORMAL
- en: 'We have revealed four more folders: `manifests`, `java`, `java(generated)`,
    and `res`. Let''s look at all four, starting at the top.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The style guidelines that Packt uses for its books suggest `this font` for filenames
    and folder names. As the files and folders that we are discussing are both files
    and folders, as well as appearing on the screen, I have opted for using just the
    latter font for consistency and because it is more compact, and I will use this
    option whenever the choice is ambiguous throughout the book.
  prefs: []
  type: TYPE_NORMAL
- en: The manifests folder
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `manifests` folder has just one file inside it. Expand the `manifests`
    folder and double-click the `AndroidManifest.xml` file. Notice that the file has
    been opened in the editor window, and a tab has been added so that we can easily
    switch back between this and other files. The next screenshot shows the new tab
    that has been added, as well as the XML code contained in the `AndroidManifest.xml`
    file within the `manifests` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4 – New tab added'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.04_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.4 – New tab added
  prefs: []
  type: TYPE_NORMAL
- en: We don't need to understand everything in this file, but it is worth pointing
    out that we will make occasional amendments here—for example, when we need to
    ask the user for permission to access features of their device. We will also edit
    this file when we want to make a fullscreen app for immersivity, such as the drawing
    app that starts in [*Chapter 21*](B16773_21_ePub_RK.xhtml#_idTextAnchor366)*,*
    *Threads and Starting the Live Drawing App*.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the structure of the file is similar to the structure of the layout
    file we saw in the previous chapter—for instance, there are clearly denoted sections
    that start with `<section name` and end with `</section name>`. Real examples
    of this are `<application` and `</application>`, as well as `<activity` and `</activity>`.
  prefs: []
  type: TYPE_NORMAL
- en: Indeed, the entire file contents, apart from the first line, are wrapped in
    `<manifest` and `</manifest>`.
  prefs: []
  type: TYPE_NORMAL
- en: Just as if we were entering the brackets of a calculation into a calculator,
    these opening and closing parts must match or the file will cause an error in
    our project. Android Studio indents (places tabs) in front of the lines to make
    the sections and their depth in this structure clearer.
  prefs: []
  type: TYPE_NORMAL
- en: A couple of specific parts of this code are worth noting, so I will point out
    some of the lines.
  prefs: []
  type: TYPE_NORMAL
- en: 'The line shown next tells Android that the icon we want to show the user in
    their app drawer/home screen to launch the app is contained in the `mipmap` folder
    and is called `ic_launcher`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We will verify this for ourselves as we continue our exploration.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next line has two aspects worth discussing. First, it denotes the name
    that we gave our app; and second, that name is contained as a `app_name`, as illustrated
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In programming, including with Java and XML, a String is any alphanumeric value.
    We will learn loads more about Strings throughout the book, starting in [*Chapter
    7*](B16773_07_ePub_RK.xhtml#_idTextAnchor134), *Java Variables, Operators, and
    Expressions*. We can therefore guess that the alphanumeric value of the label
    of `app_name` is `Empty Activity App` because that is what we called the app when
    we created it.
  prefs: []
  type: TYPE_NORMAL
- en: This might sound slightly odd, but we will see this file soon (and its label),
    and in later projects, we will add more labels and values to it. We will also
    come to understand the reasons why we add text to our apps in what might at this
    stage seem quite a convoluted manner.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could discuss every line in the `AndroidManifest.xml` file but we don''t
    need to. Let''s look at just two more, as they are related to each other. The
    line shown next indicates the name of our Activity, which Android Studio chose
    when we created the project. I have highlighted the Activity name here, just to
    make it stand out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'And this next line, which appears within the `<activity` and `</activity>`
    tags, denotes that it is an attribute of `activity` and shows that this Activity
    is the one that should run when the app is started. It is `LAUNCHER`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This implies that our apps can have more than one Activity. Very often, if you
    have an app with multiple screens—such as a home screen, a settings screen, and
    so on—they are built from multiple `Activity` class **instances**.
  prefs: []
  type: TYPE_NORMAL
- en: A note about `Activity` and `activity`. In XML, as with the `AndroidManifest`
    file, `activity` is in lowercase, but in Java the `Activity` class has an uppercase
    `A`. This is just convention and is nothing to be concerned about. As we have
    just seen, `activity` in XML has a `name` attribute with a value that refers to
    an instance of a Java `Activity`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's dig into the `java` folder. I wonder what we will find in there.
  prefs: []
  type: TYPE_NORMAL
- en: The java folder
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'I apologize for the slightly sarcastic comment. We will, of course, find all
    the Java code. To begin with, this consists of just one file, but as our projects
    grow we will add more. Expand the `java` folder and you will find three more folders,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.5 – Expand the java folder'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.05_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.5 – Expand the java folder
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this book, we will only need one of these three folders—the top one.
    The names of these folders are composed of the package name (chosen when we created
    the app) and the app name, in all lowercase and with no spaces (also chosen when
    we created the app).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The reason there is more than one folder with the same name is for advanced
    reasons to do with automated testing, which is beyond the scope of this book.
    Therefore, you can safely ignore folders that end with `(androidTest)` and `(test)`.
  prefs: []
  type: TYPE_NORMAL
- en: The only folder we are interested in during the course of this book is the top
    one, which for this app (on my screen) is `com.gamecodeschool.emptyactivityapp`.
    Depending upon your chosen package name and the name of the app we are currently
    working on, the folder name will change, but it will always be the top one that
    we need to access and add—or edit—the contents of.
  prefs: []
  type: TYPE_NORMAL
- en: 'Expand the `com.gamecodeschool.emptyactivityapp` (or whatever yours is called)
    folder now to view its contents. In the next screenshot, you can see that the
    folder has just one file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.6 – com.gamecodeschool.emptyactivityapp folder'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.06_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.6 – com.gamecodeschool.emptyactivityapp folder
  prefs: []
  type: TYPE_NORMAL
- en: This file is `MainActivity.java`, although the file extension isn't shown in
    the project window even though it is in the tabs above the editor window. In fact,
    all the files in the `java/packagename.appname` folder will have a `.java` extension.
    If you double-click the `MainActivity.java` file, it will open in the editor window,
    although we could have just clicked the `MainActivity.java` tab above the editor
    window. As we add more Java files, knowing where they are kept will be useful.
  prefs: []
  type: TYPE_NORMAL
- en: Examine the `MainActivity.java` file, and you will see it is a simplified version
    of the Java file we worked with in the first project. It is the same except that
    there are fewer methods and less autogenerated code in the `onCreate` method.
    The methods are missing because the UI is simpler and therefore they are not needed,
    and Android Studio didn't generate them.
  prefs: []
  type: TYPE_NORMAL
- en: 'For reference, look at the contents of the `MainActivity.java` file in this
    next screenshot. I have outlined one line from the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.7 – MainActivity.java file'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.07_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.7 – MainActivity.java file
  prefs: []
  type: TYPE_NORMAL
- en: 'It still has the `onCreate` method that executes when the app is run by the
    user, but there is much less code in it and `onCreate` is the only method. Look
    at the last line of code in the `onCreate` method—we will discuss this before
    moving on to explore the `res` folder. Here is the line of code under discussion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The code is calling a method named `setContentView` and it is passing some data
    into the `setContentView` method, for the code in the `setContentView` method
    to make use of. The data being passed to `setContentView` is `R.layout.activity_main`.
  prefs: []
  type: TYPE_NORMAL
- en: For now, I will just mention that the `setContentView` method is provided by
    the Android `R.layout.activity_main`?
  prefs: []
  type: TYPE_NORMAL
- en: We will find out by exploring the `res` folder, but a quick mention of the `Java
    (generated)` folder so that we don't trouble ourselves with it as we progress.
    The first thing to note is that the folder is autogenerated the first time the
    app is run on the emulator or a real device, so if you haven't run the app, you
    won't see it.
  prefs: []
  type: TYPE_NORMAL
- en: The Java (generated) folder
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This folder contains code generated by Android Studio and we do not need to
    concern ourselves with what goes in it. Even advanced users who might need it
    generally only use it for reference.
  prefs: []
  type: TYPE_NORMAL
- en: Let's get on to the `res` folder and that `R.layout.activity_main` code.
  prefs: []
  type: TYPE_NORMAL
- en: The res folder
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `res` folder is where all the resources go. Left-click to expand the `res`
    folder, and we will examine what''s inside. Here is a screenshot of the top level
    of folders inside this folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.8 – res folder'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.08_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.8 – res folder
  prefs: []
  type: TYPE_NORMAL
- en: Let's begin at the top of the list, with the `drawable` folder.
  prefs: []
  type: TYPE_NORMAL
- en: The res/drawable folder
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The name gives things away a little bit, but the `drawable` folder holds much
    more than just graphics. As we progress through the book, we will indeed add graphics
    to this folder. However, now, it holds just two files.
  prefs: []
  type: TYPE_NORMAL
- en: These files are `ic_launcher_foreground` and `ic_launcher_background`. We will
    not examine either file because we will never need to alter them, but I will just
    mention what they are.
  prefs: []
  type: TYPE_NORMAL
- en: If you open the files, you will see they are quite long and technical. They
    include what appear to be lists of coordinates, colors, and more besides. They
    are what is known as a **graphical mask**, used by Android to adapt/mask other
    graphics—specifically, in this case, the launcher icon of the app. The files give
    instructions to Android on how to adapt the app launcher icon.
  prefs: []
  type: TYPE_NORMAL
- en: This system is made available so that different device manufacturers can create
    their own masks to suit their own Android devices. The masks, which are in the
    `drawable` folder by default (`ic_launcher_foreground` and `ic_launcher_background`),
    are default adaptive masks that add visually pleasing shadows and depth to the
    launcher icon.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If the concept of adaptive icons is interesting to you, then you can see a full
    and very visual explanation at this link to the *Android Developers* website,
    at [https://developer.android.com/guide/practices/ui_guidelines/icon_design_adaptive](https://developer.android.com/guide/practices/ui_guidelines/icon_design_adaptive).
    You do not need to see this page to continue.
  prefs: []
  type: TYPE_NORMAL
- en: We know enough about the `drawable` folder for now, so let's move on to the
    `layout` folder.
  prefs: []
  type: TYPE_NORMAL
- en: The res/layout folder
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `res` folder is where all the resources for your app go, such as icons,
    layouts (XML files), sounds, and strings. Let's take a closer look.
  prefs: []
  type: TYPE_NORMAL
- en: Expand the `layout` folder and you will see a layout file named `activity_main.xml`,
    and if you open it to view its contents, you will see it is much like the one
    we edited in the previous chapter. There is less in it this time because we generated
    an `ConstraintLayout` element, wrapping a `TextView` widget that says `Hello World!`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Be sure to look at the contents, but this is not the most interesting thing
    here. Look closely at the name of the file (without the XML file extension): `activity_main`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, think back to the Java code in the `MainActivity.java` file. Here is the
    line of code that we said sets up the UI. I have highlighted a portion of the
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `R.layout.activity_main` code is indeed a reference to the `activity_main`
    file within the `res/layout` file. This is the connection between our Java code
    and our XML layout/design.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: There is a difference from the first project other than the contents of `activity_main.xml`—in
    the `layout` folder of the first project, there were multiple additional files.
    Later in this chapter, we will build another project using the same template we
    used in the first chapter (**Basic Activity**) to understand why.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before that, let''s explore the final two folders and all their sub-folders,
    starting with the next in the list: `mipmap`.'
  prefs: []
  type: TYPE_NORMAL
- en: The res/mipmap folder
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `mipmap` folder is straightforward—well, fairly. Expand the folder to see
    its contents, as illustrated in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.9 – mipmap folder'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.09_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.9 – mipmap folder
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we can see two sub-folders: `ic_launcher` and `ic_launcher_round`. The
    contents of `ic_launcher` are graphics for the regular launcher icon we see in
    the app drawer/home screen of the device, and `ic_launcher_round` contains graphics
    for devices that use round icons. Double-click on one of the `.png` files from
    each folder to have a look. I have Photoshopped one of each side by side in this
    next screenshot to aid our discussion:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.10 – Launcher icons'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.10_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.10 – Launcher icons
  prefs: []
  type: TYPE_NORMAL
- en: You are probably also wondering why there are five `ic_launcher….png` files
    in each folder. The reason for this is it is good practice to provide icons suitably
    scaled for different screen sizes and resolutions. By providing an image with
    the `hdpi`, `mdpi`, `xhdpi`, `xxhdpi`, and `xxxhdpi` qualifications, this allows
    different Android devices to choose an icon that will look best for the user.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The letters `dpi` stand for `h`, `m`, `xh`, `xxh`, and `xxxh` prefixes stand
    for high, medium, extra high, extra extra high, and so on. These are known as
    **qualifiers**, and we will see as we progress that Android has lots of qualifiers
    that help us build our apps to suit the wide range of different Android devices.
  prefs: []
  type: TYPE_NORMAL
- en: The final conundrum of the `mipmap` folder is that there is also an XML file
    in each of the two sub-folders. Open one of them up and you will see that they
    refer to the `ic_launcher_foreground` and `ic_launcher_background` files that
    we looked at in the `drawable` folder. This tells the Android device where to
    get details of the adaptive icons. These files are not required but they make
    the icons look better, as well as adding flexibility to their appearance.
  prefs: []
  type: TYPE_NORMAL
- en: We have one more folder and all its files, and then we will understand the structure
    of an Android app well.
  prefs: []
  type: TYPE_NORMAL
- en: The res/values folder
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Open the `res/values` folder to reveal three files that we will talk about briefly
    in turn. All these files interlink/refer to each other and/or other files that
    we have seen already.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the sake of completeness, here is a screenshot of the three files in the
    `res/values` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.11 – res/values folder'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.11_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.11 – res/values folder
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: There is also a `themes` folder inside the `values` folder, but we do not need
    to explore this in the context of this book.
  prefs: []
  type: TYPE_NORMAL
- en: The key to understanding is not in memorizing the connections, and certainly
    not trying to memorize or even understand the code in the files, but rather to
    get an appreciation of the interlinked nature of all the files and code we have
    seen so far.
  prefs: []
  type: TYPE_NORMAL
- en: Let's glance inside the files one at a time.
  prefs: []
  type: TYPE_NORMAL
- en: '**The colors.xml file**'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll look next at the contents of the `colors.xml` file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the starting and closing tags take the usual pattern we have come
    to expect from XML files. There is an opening `<resources>` tag and a closing
    `</resources>` tag. As children of resources, there are three pairs of `<color>
    … </color>` tags.
  prefs: []
  type: TYPE_NORMAL
- en: Within each `color` tag is a `name` attribute and curious-looking code, consisting
    of numbers and letters. The `name` attribute is the name of a color. We will see
    in another of the files that follow that various names are referred to.
  prefs: []
  type: TYPE_NORMAL
- en: The code is what defines an actual color itself. Therefore, when the name is
    referred to, the color defined by the related code is what is produced on the
    screen. We will see where these names are referred to in a moment.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The code is called `0` through `9` and `a` through `f` can be used, giving
    16 possible values. If you want to find out more and play around with hex colors,
    visit [http://www.color-hex.com/color-wheel/](http://www.color-hex.com/color-wheel/).
    If you are intrigued about number bases such as hexadecimal (base 16), binary
    (base 2), and others, then look at the following article that explains them and
    talks about why humans typically use base 10: [https://betterexplained.com/articles/numbers-and-bases/](https://betterexplained.com/articles/numbers-and-bases/).
    You do not need to explore these articles to proceed with the book.'
  prefs: []
  type: TYPE_NORMAL
- en: '**The strings.xml file**'
  prefs: []
  type: TYPE_NORMAL
- en: Most modern apps are made for as wide an audience as possible. Furthermore,
    if an app is of a significant size or complexity, then roles in a software company
    are often divided up into many different teams—for example, the person writing
    the Java code for an Android app very possibly had little to do with designing
    the layout of the UI.
  prefs: []
  type: TYPE_NORMAL
- en: By separating the content of the app from the programming of the app it is easier
    to make changes at any time, and it is also possible to create content for multiple
    different spoken languages without altering the Java code for each.
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at the content of the `strings.xml` file, reproduced next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We can see that within the now-familiar `<resources>…</resources>` tags, we
    have a `<string>…</string>` tag. Within the `string` tag, there is an attribute
    called `name` with an `app_name` value, and then a further value of `Empty Activity
    App`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at one more line from the `AndroidManifest.xml` file we explored
    earlier in the *The manifests folder* section. The line in question follows next,
    but refer to the file itself in Android Studio if you want to see the line in
    its full context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `android:label` attribute is being assigned a value of `@string/app_name`.
    In Android, `@string` refers to all the strings in the `strings.xml` file. In
    this specific app, the `string` attribute with the `app_name` label has an `Empty
    Activity App` value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, the line of code in the `AndroidManifest.xml` file shown previously
    has the following effect on the screen when the app is running:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.12 – AndroidManifest.xml file effect'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.12_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.12 – AndroidManifest.xml file effect
  prefs: []
  type: TYPE_NORMAL
- en: Although at first this system might seem convoluted, in practice it separates
    design and content from the coding, which is very efficient to do. If the designers
    of an app want to change its name, they simply edit the `strings.xml` file, with
    no need to interact with the Java programmers; and if all text in an app is provided
    as a string resource, then all of it can be easily altered and adapted as the
    project proceeds.
  prefs: []
  type: TYPE_NORMAL
- en: Android takes this flexibility further by allowing developers to use different
    files for string resources for each language/locale. This means that a developer
    can cater to a planet full of happy users with exactly the same Java code. A Java
    programmer just needs to refer to the `name` attribute of a string resource instead
    of **hardcoding** the text itself into the Java, and then other departments can
    design the text content and handle tasks such as language translation. We will
    make an app multilingual in [*Chapter 18*](B16773_18_ePub_RK.xhtml#_idTextAnchor320),
    *Localization*.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to hardcode the actual text directly into the Java code instead
    of using string resources, and from time to time we will do so for the sake of
    easily showing some Java without getting bogged down with editing or adding to
    the `strings.xml` file. We did this in the previous chapter when we made toast
    messages and output text to the console.
  prefs: []
  type: TYPE_NORMAL
- en: The Android system allows designers to choose a selection of colors, text, images,
    sound, and other resources as well, and easily produce a variation of their app
    for different regions of the world.
  prefs: []
  type: TYPE_NORMAL
- en: For example, in Western culture, green can represent themes such as nature and
    correctness; and in many Middle Eastern countries, green represents fertility
    and is the color associated with Islam. While you might just about get away with
    distributing green in both these regions, your app will be perceived very differently.
  prefs: []
  type: TYPE_NORMAL
- en: If you then roll your app out into Indonesia, green is culturally despised among
    many (although not all) Indonesians. Next, you launch in China, and green has
    potential negative connotations to do with unfaithful spouses. It is a minefield
    that a typical Java programmer will never learn to navigate—and fortunately, because
    of the way we can divide up responsibilities in Android Studio, they don't need
    to learn about this.
  prefs: []
  type: TYPE_NORMAL
- en: Colors—and, therefore, styles and themes—is a very specialized topic. While
    we won't be exploring any more deeply than that quick foray into green, hopefully
    you see the benefit of a system that separates responsibility for programming,
    layout, color, and textual content.
  prefs: []
  type: TYPE_NORMAL
- en: It is also worth mentioning that it is entirely possible to produce a fantastic
    app that is enjoyed by thousands—or even millions—of users without catering individually
    to every region. However, even if we are not going to employ teams of designers,
    translators, and cultural experts, we still must work within this system that
    was designed to enable them, and that is why we are going into such depth.
  prefs: []
  type: TYPE_NORMAL
- en: At this stage, we have a good grasp of what goes into an Android project and
    how the different aspects link together. Let's build one more app, not to go into
    it in the same detail but to see the differences that different app templates
    make to the underlying files that Android Studio generates.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the file and folder structure of the Basic Activity project template
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next-simplest project type with an autogenerated UI is a **Basic Activity**
    project. This is the same type of project that we created in [*Chapter 1*](B16773_01_ePub_RK.xhtml#_idTextAnchor014)*,
    Beginning Android and Java*. Feel free to open that project up now, but it is
    just as quick to generate a new one, and we can then also examine it without any
    of our alterations and additions clouding the discussions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Proceed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Run Android Studio and left-click the **Start a new Android Studio project**
    option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The window that follows is the **Select a Project Template** window. Select
    **Basic Activity** and click **Next**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Configure Your Project** window, set up the project as follows:![](img/B16773_03_Table_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **Finish** button, and we will run the app to see what we have achieved.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we can dig into the files. We won't look at everything in the same detail
    that we did for the **Empty Activity** project; instead, we will just look at
    the interconnectedness of the files and make a few comparisons.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring a Basic Activity project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's look at the Java code first in the `MainActivity.java` tab in the code
    editor. As already stated, a **Basic Activity** project has more to it than an
    **Empty Activity** project.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can open as many instances of Android Studio as you like. If you want to
    compare projects side by side, select **File** | **Open** then choose the project,
    and when prompted select **New Window** to open the project, without closing any
    projects that are already open.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing to note is that there is some extra code in the `onCreate` method.
  prefs: []
  type: TYPE_NORMAL
- en: The MainActivity.java file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'I mentioned very briefly back in [*Chapter 2*](B16773_02_ePub_RK.xhtml#_idTextAnchor043)*,
    First Contact: Java, XML, and the UI Designer,* these interconnections in the
    Java code and the XML code. Let''s look through the resource files and point out
    the XML files that this Java code points to.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the Java code shown next. I have slightly reformatted it to make it
    more readable in a book:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: To understand this code fully will take quite a few more chapters, but to point
    out where this code uses files in the resources will only take a moment and will
    then leave us even more aware of the components that make up our projects.
  prefs: []
  type: TYPE_NORMAL
- en: The code refers to two resources. The first is a `Toolbar` resource and is referred
    to via `R.id.toolbar`. The second is a `FloatingActionBar` resource and refers
    to the XML files we will see soon via `R.id.fab`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we open the `res/layout` folder and the `java` folder in the project window,
    we can see that things look different from how they did in the **Empty Activity**
    project, as illustrated in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.13 – res/layout folder and java folder'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.13_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.13 – res/layout folder and java folder
  prefs: []
  type: TYPE_NORMAL
- en: There are now three Java files that were autogenerated, and four XML layout
    files that were autogenerated.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that this app has two screens—a first screen with a **Hello first fragment**
    message and a **Next** button; and a second screen, which simply had a **Previous**
    button.
  prefs: []
  type: TYPE_NORMAL
- en: What is happening is that Android Studio is not only providing separate layout
    files for the appearance of each screen, but it is also providing separate Java
    files for the code that controls each screen. If you take what I just said at
    face value, you would, therefore, expect two layout files and two Java files,
    but we have more.
  prefs: []
  type: TYPE_NORMAL
- en: As we already know, when the app is run by the user, the `onCreate` method of
    the `MainActivity.java` file is executed. This sets up the app, including the
    layout. The layout is in `activity_main.xml` but this file no longer controls
    the layout of the two main screens. It has elements that are consistent between
    both screens and delegates the layout to `content_main.xml`. The `content_main.xml`
    file then defines an area of the screen that it occupies and delegates the details
    that will appear in this area to yet another file, the `nav_graph.xml` file in
    the `res/navigation` folder. This `nav_graph.xml` file then determines which layout
    to use (`fragment_first.xml` or `fragment_second.xml`) and which corresponding
    Java file will control the layout (`FirstFragment.java` or `SecondFragment.java`).
  prefs: []
  type: TYPE_NORMAL
- en: 'At this stage, the apparent convolution might be overwhelming. It is my guess
    that this is one of the things could make learning Android development without
    any previous development experience so challenging. But the good news is this:'
  prefs: []
  type: TYPE_NORMAL
- en: We don't need to remember and understand the details of all this interconnectedness.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can build loads of apps without using any of it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we progress through the book and work with the different pieces of this puzzle,
    we will become familiar with them a piece at a time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Take a look at this next figure, which shows how the **Basic Activity** template
    app works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.14 – Basic Activity template'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.14_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.14 – Basic Activity template
  prefs: []
  type: TYPE_NORMAL
- en: If the apparent complexity seems frustrating, then understanding why it is done
    like this might help. We have already talked about separating layouts from programming
    and further separating out text and graphics, to allow different teams to work
    on different aspects of an app. Well, now, we can further separate out not just
    navigation between different screens of our app—say, the main menu screen, the
    settings screen, and some other screen—but as the layouts and programming associated
    with each of these screens are separate, they too can be worked on simultaneously
    by separate teams. More on this as we progress through the chapters.
  prefs: []
  type: TYPE_NORMAL
- en: We will look into coding separate fragment layouts and separate Java code that
    controls each of them, as well as learning more about why we want to do it like
    this, from [*Chapter 24*](B16773_24_ePub_RK.xhtml#_idTextAnchor411), *Design Patterns,
    Multiple Layouts, and Fragments,* onward, and we will be digging deeper into interconnected
    layout files such as `activity_main.xml` and `content_main.xml` in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: For now, let's look a little deeper at how the `MainActivity.java` file code
    links up with the `activity_main.xml` layout. We will see that although the `activity_main.xml`
    file is responsible for placing the toolbar and the floating action button, the
    `MainActivity.java` file is responsible for controlling what happens when the
    user interacts with them.
  prefs: []
  type: TYPE_NORMAL
- en: The activity_main.xml file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For now, open up the `activity_main.xml` file, and you will see that there are
    some elements to represent both `toolbar` and `fab`. The Java code referring to
    these elements is setting up the toolbar and the floating action bar ready for
    use. The XML code, as we have come to expect, describes what they look like.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the XML code for the toolbar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Notice that it refers to a toolbar, a color, and a style, as well as some other
    aspects.
  prefs: []
  type: TYPE_NORMAL
- en: 'For clarity, this is the toolbar in the actual working app:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.15 – Toolbar of the app'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.15_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.15 – Toolbar of the app
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the XML code for the floating action button. I have slightly reformatted
    the first line of the code onto two lines so that it displays better in the printed
    version of this book:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice it has an `id` value of `fab`. It is through this `id` value that we
    gain access to the floating action button in our Java code—specifically, this
    line in `MainActivity.java`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: After this line of code executes, the `fab` object in our Java code can now
    directly control the floating action button and all its attributes. In [*Chapter
    13*](B16773_13_ePub_RK.xhtml#_idTextAnchor228), *Anonymous Classes – Bringing
    Android Widgets to Life*, we will learn how to do this in detail.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the floating action button in the actual app:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.16 – Floating action button'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.16_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.16 – Floating action button
  prefs: []
  type: TYPE_NORMAL
- en: 'I haven''t explained the code in detail, as there is no point at this stage.
    Just start to make a mental note of the interconnections, outlined here:'
  prefs: []
  type: TYPE_NORMAL
- en: XML files can refer to other XML files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java can refer to XML files (and, as we will see soon, other Java files).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And now, we have seen that in Java we can grab control of a specific part of
    the UI in an XML file via its `id` attribute.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have seen enough from this file, so let's move on and dip into the remaining
    files.
  prefs: []
  type: TYPE_NORMAL
- en: The extra methods in MainActivity.java
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So, what do the methods do and when are they called, and by whom? The next
    difference is this extra method (again, slightly reformatted for presentation):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This code prepares (inflates) the menu that is defined in the `menu_main.xml`
    file, and just as with the `onCreate` method, the `onCreateOptionsMenu` method
    is an overridden method and is called by the operating system directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, there is yet another method, shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is overridden as well, and it too is called directly by the operating
    system. It handles what happens when an item (option) from the menu is selected
    by a user. At the moment, it handles just one option—the settings option—and currently,
    it takes no action, as can be seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This determines whether any options from the `return true` code executes, and
    control is returned to whatever part of the app was executing before it was interrupted
    by a user clicking the **Settings** menu option.
  prefs: []
  type: TYPE_NORMAL
- en: We know nearly enough for now. Don't worry about memorizing all these connections.
    We will be coming back to each connection, investigating more deeply, and cementing
    our understanding of each.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can take a closer look at the Android emulator.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the Android emulator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we progress, it helps to be familiar with exactly how to use the Android
    emulator. If you haven't used the latest version of Android, some of the ways
    even simple tasks are executed (such as viewing all the apps) can be different
    from how your current device works. In addition, we want to know how to use the
    extra controls that come with all emulators.
  prefs: []
  type: TYPE_NORMAL
- en: Emulator control panel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You probably noticed the mini control panel that appears beside the emulator
    when you run it. Let''s go through some of the most useful controls. Look at this
    screenshot of the emulator control panel. I have annotated it to aid discussion
    of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.17 – Emulator control panel'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.17_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.17 – Emulator control panel
  prefs: []
  type: TYPE_NORMAL
- en: 'I will just mention the more obvious controls as follows, and go into a bit
    more depth when necessary:'
  prefs: []
  type: TYPE_NORMAL
- en: These are the window controls. Minimize or close the emulator window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From top to bottom, power off the emulator, simulating powering off the actual
    device. The next two icons raise and lower the volume.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: These two buttons allow you to rotate the emulator left and right. This means
    you can test what your app looks like in all orientations, as well as how it handles
    orientation changes while the app is running. The icons immediately below these
    take a screenshot and zoom in, respectively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: These icons simulate the back button and home button, and viewing running apps.
    Have a play with these buttons as we will need to use them from time to time,
    including in [*Chapter 6*](B16773_06_ePub_RK.xhtml#_idTextAnchor119), *The Android
    Lifecycle*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press this button to launch the **Advanced Settings** menu, where you can interact
    with things such as sensors, the **Global Positioning System** (**GPS**), the
    battery, the fingerprint reader, and more. Have a play around with some of these
    settings if you are curious.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's have a play with the emulator itself.
  prefs: []
  type: TYPE_NORMAL
- en: Using the emulator as a real device
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The emulator can emulate every feature of a real phone, so it would be possible
    to write a whole book on using it. If you want to write apps that your users love,
    then understanding a whole range of Android devices is well worth taking the time
    to do. I just want to point out a few of the most basic features here, because
    without these basic interactions it will be hard to follow along with the book.
    Furthermore, if you have an older Android device, then some essential basics (such
    as accessing the app drawer) have changed and you might be left a little baffled.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing the app drawer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Hold the mouse cursor on the bottom of the home screen and drag upward to access
    the app drawer (all the apps). The following screenshot shows this action halfway
    through:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.18 – Drag upwards to access app drawer'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.18_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.18 – Drag upwards to access app drawer
  prefs: []
  type: TYPE_NORMAL
- en: Now, you can run any app installed on the emulator. Note that when you run one
    of your apps through Android Studio, it remains installed on the emulator and
    is therefore runnable from the app drawer. However, every change you make to the
    app in Android Studio will require you to run/install the app again by clicking
    the play button on the Android Studio quick launch bar—as we have been doing.
  prefs: []
  type: TYPE_NORMAL
- en: Viewing active apps and switching between apps
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To view active apps, you can use the emulator control panel, the square labeled
    as number **4** on the screenshot of the emulator control panel (*Figure 3.17*).
    To access the same option using the phone screen (as you would have to do on a
    real device), swipe up, just as when accessing the app drawer, but do so only
    for about one quarter the length of the screen. This process is illustrated in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.19 – Swipe up'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.19_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.19 – Swipe up
  prefs: []
  type: TYPE_NORMAL
- en: You can now swipe left and right through recent apps, swipe an app up to close
    it, or tap the back button to return to what you were doing before you viewed
    this option. Do try this out as we will use these basic features quite often.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Remember that the goal of this chapter was familiarization with the system/structure
    of Android/an Android project? Android projects are a sometimes-complex interweaving
    of Java and a multitude of resource files. Resource files can contain XML to describe
    our layouts, textual content, styles, and colors, as well as images. Resources
    can be produced to target different languages and regions of the world. Other
    resource types that we will see and use throughout the book include themes and
    sound effects.
  prefs: []
  type: TYPE_NORMAL
- en: It is not important to remember all the different ways in which different resource
    files and Java files are interconnected. It is only important to realize that
    they are, and be able to examine files of various types and realize when they
    are dependent on code in another file. Whenever we create connections from our
    Java code to the XML code, I will always point out details of the connection again.
  prefs: []
  type: TYPE_NORMAL
- en: We do not need to learn XML as well as Java, but we will become a little bit
    familiar with it. Java will be the focus of this book but our Java will frequently
    refer to the XML code, so understanding and having seen some examples of the interconnections
    will stand you in good stead to make faster progress.
  prefs: []
  type: TYPE_NORMAL
- en: We have also explored the emulator to get the most out of it when testing our
    apps.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will build two custom layouts using two different Android
    layout schemes. We will also write some Java code so that we can switch between
    them with the tap of a button.
  prefs: []
  type: TYPE_NORMAL
