- en: Chapter 13. Advanced OOP – Inheritance and Polymorphism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will further extend our knowledge of OOP by looking at
    the slightly more advanced concepts of **inheritance** and **polymorphism**. We
    will then be able to use this new knowledge to implement the star characters of
    our game, Thomas and Bob. Here is what we will cover in this chapter in a little
    more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: How to extend and modify a class using inheritance?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Treating an object of a class as if it is more than one type of class by using
    polymorphism
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Abstract classes and how designing classes that are never instantiated can actually
    be useful
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building an abstract `PlayableCharacter` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Puting inheritance to work with `Thomas` and `Bob` classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding Thomas and Bob to the game project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen how we can use other people's hard work by instantiating/creating
    objects from the classes of the SFML library. But this whole OOP thing goes even
    further than that.
  prefs: []
  type: TYPE_NORMAL
- en: What if there is a class that has loads of useful functionality in it, but is
    not quite what we want? In this situation we can **inherit** from the other class.
    Just like it sounds, **inheritance** means we can harness all the features and
    benefits of other people's classes, including the encapsulation, while further
    refining or extending the code specifically to our situation. In this project,
    we will inherit from and extend some SFML classes. We will also do so with our
    own classes.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at some code that uses inheritance,
  prefs: []
  type: TYPE_NORMAL
- en: Extending a class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With all this in mind, let's look at an example class and see how we can extend
    it, just to see the syntax and as a first step.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we define a class to inherit from. This is no different from how we
    created any of our other classes. Take a look at this hypothetical `Soldier` class
    declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code, we define a `Soldier` class. It has four private variables,
    `m_Health`, `m_Armour`, `m_Range`, and `m_ShotPower`. It has four public functions
    `setHealth`, `setArmour`, `setRange`, and `setShotPower`. We don't need to see
    the definition of the functions, they will simply initialize the appropriate variable
    that their name makes obvious.
  prefs: []
  type: TYPE_NORMAL
- en: We can also imagine that a fully implemented `Soldier` class would be much more
    in-depth than this. It would probably have functions such as `shoot`, `goProne`,
    and others. If we implemented a `Soldier` class in an SFML project, it would likely
    have a `Sprite` object, as well as an `update` and a `getPostion` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The simple scenario presented here is suitable for learning about inheritance.
    Now let''s look at something new, actually inheriting from the `Soldier` class.
    Look at this code, especially the highlighted part:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'By adding the `: public Soldier` code to the `Sniper` class declaration, `Sniper`
    inherits from `Soldier`. But what does this mean, exactly? `Sniper` is a `Soldier`.
    It has all the variables and functions of `Soldier`. Inheritance is more than
    this, however.'
  prefs: []
  type: TYPE_NORMAL
- en: Notice also that in the previous code, we declare a `Sniper` constructor. This
    constructor is unique to `Sniper`. We have not only inherited from `Soldier`,
    we have **extended ** `Soldier`. All the functionality (definitions) of the `Soldier`
    class are handled by the `Soldier` class, but the definition of the `Sniper` constructor
    must be handled by the `Sniper` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what the hypothetical `Sniper` constructor definition might look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We could go ahead and write a bunch of other classes that are an extension of
    the `Soldier` class, perhaps `Commando` and `Infantryman`. Each would have the
    exact same variables and functions, but each could also have a unique constructor
    that initializes those variables appropriate to the type of `Soldier`. `Commando`
    might have very high `m_Health` and `m_ShotPower` but really puny `m_Range`. `Infantryman`
    might be in between `Commando` and `Sniper`, with mediocre values for each variable.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As if OOP were not useful enough already, we can now model real-world objects,
    including their hierarchies. We achieve this by sub-classing, extending, and inheriting
    from other classes.
  prefs: []
  type: TYPE_NORMAL
- en: The terminology we might like to learn here is that the class that is extended
    from is the **super-class**, and the class that inherits from the super-class
    is the **sub-class**. We can also say **parent** and **child** class.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You might find yourself asking this question about inheritance: Why? The reason
    is something like this: we can write common code once; in the parent class, we
    can update that common code and all classes that inherit from it are also updated.
    Furthermore, a sub-class only gets to use public and **protected** instance variables
    and functions. So, designed properly, this also further enhances the goals of
    encapsulation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Did you say protected? Yes. There is an access specifier for class variables
    and functions called **protected**. You can think of protected variables as being
    somewhere between public and private. Here is a quick summary of access specifiers,
    along with more details about the protected specifier:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Public` variables and functions can be accessed and used by anyone.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Private` variables and functions can only be accessed/used by the internal
    code of the class. This is good for encapsulation, and when we need to access/change
    private variables, we can provide public `getter` and `setter` functions (such
    as `getSprite` and so on). If we extend a class that has `private` variables and
    functions, that child class *cannot* directly access the private data of its parent.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Protected` variables and functions are almost the same as private. They cannot
    be accessed/used directly by an instance of the class. However, they *can* be
    used directly by any class that extends the class they are declared in. So it
    is like they are private, except to child classes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To fully understand what protected variables and functions are and how they
    can be useful, let's look at another topic first and then we can see them in action.
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Polymorphism** allows us to write code that is less dependent on the types
    we are trying to manipulate. This can make our code clearer and more efficient.
    Polymorphism means different forms. If the objects that we code can be more than
    one type of thing, then we can take advantage of this.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'What does polymorphism mean to us? Boiled down to its simplest definition,
    polymorphism is this: any sub-class can be used as part of the code that uses
    the super-class. This means we can write code that is simpler and easier to understand
    and also easier to modify or change. Also, we can write code for the super-class
    and rely on the fact that no matter how many times it is sub-classed, within certain
    parameters, the code will still work.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's discuss an example.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose we want to use polymorphism to help write a zoo management game where
    we have to feed and tend to the needs of animals. We will probably want to have
    a function such as `feed`. We will also probably want to pass an instance of the
    Animal to be fed into the `feed` function.
  prefs: []
  type: TYPE_NORMAL
- en: A zoo, of course, has lots of types of animal—`Lion`, `Elephant`, and `ThreeToedSloth`.
    With our new knowledge of C++ inheritance, it will make sense to code an `Animal`
    class and have all the different types of animal inherit from it.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to write a function (`feed`) that we can pass Lion, Elephant, and
    ThreeToedSloth into as a parameter, it might seem like we need to write a `feed`
    function for each and every type of `Animal`. However, we can write polymorphic
    functions, with polymorphic return types and arguments. Take a look at this definition
    of the hypothetical `feed` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The preceding function has the `Animal` reference as a parameter, meaning that
    any object that is built from a class that extends `Animal` can be passed into
    it.
  prefs: []
  type: TYPE_NORMAL
- en: So, you can even write code today and make another sub-class in a week, month,
    or year, and the very same functions and data structures will still work. Also,
    we can enforce upon our sub-classes a set of rules for what they can and cannot
    do, as well as how they do it. So, good design in one stage can influence it at
    other stages.
  prefs: []
  type: TYPE_NORMAL
- en: But will we ever really want to instantiate an actual Animal?
  prefs: []
  type: TYPE_NORMAL
- en: Abstract classes - virtual and pure virtual functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An **abstract class** is a class that cannot be instantiated and therefore cannot
    be made into an object.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some terminology we might like to learn here is **concrete** class. A **concrete
    class** is any class that isn't abstract. In other words, all the classes we have
    written so far have been concrete classes and can be instantiated into usable
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: So, it's code that will never be used, then? But that's like paying an architect
    to design your home and then never building it!
  prefs: []
  type: TYPE_NORMAL
- en: If we, or the designer of a class, want to force its users to inherit it before
    using their class, they can make a class **abstract**. Then, we cannot make an
    object from it; therefore, we must extend it first and make an object from the
    sub-class.
  prefs: []
  type: TYPE_NORMAL
- en: To do so, we can make a function **pure virtual** and not provide any definition.
    Then that function must be **overridden** (re-written) in any class that extends
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example; it will help. We make a class abstract by adding
    a pure virtual function such as this abstract `Animal` class that can only perform
    the generic action of makeNoise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we add the C++ keyword, `virtual`, before, and `= 0` after the
    function declaration. Now, any class that extends/inherits from `Animal` must
    override the `makeNoise` function. This might make sense, since different types
    of animal make very different types of noise. We could perhaps have assumed that
    anybody who extends the `Animal` class is smart enough to notice that the `Animal`
    class cannot make a noise and that they will need to handle it, but what if they
    don't notice? The point is that by making a pure virtual function we guarantee
    that they will, because they have to.
  prefs: []
  type: TYPE_NORMAL
- en: Abstract classes are also useful because sometimes, we want a class that can
    be used as a polymorphic type, but we need to guarantee it can never be used as
    an object. For example, `Animal` doesn't really make sense on its own. We don't
    talk about animals; we talk about types of animal. We don't say, *"Ooh, look at
    that lovely, fluffy, white animal!"* or, *"Yesterday we went to the pet shop and
    got an animal and an animal bed"*. It's just too, well, abstract.
  prefs: []
  type: TYPE_NORMAL
- en: So, an abstract class is kind of like a **template** to be used by any class
    that extends it (inherits from it). If we were building an *Industrial Empire*-type
    game where the player manages businesses and their employees, we might want a
    `Worker` class, for example, and extend it to make `Miner`, `Steelworker`, `OfficeWorker`,
    and, of course, `Programmer`. But what exactly does a plain `Worker` do? Why would
    we ever want to instantiate one?
  prefs: []
  type: TYPE_NORMAL
- en: The answer is we wouldn't want to instantiate one, but we might want to use
    it as a polymorphic type so we can pass multiple `Worker` sub-classes between
    functions and have data structures that can hold all types of workers.
  prefs: []
  type: TYPE_NORMAL
- en: All pure virtual functions must be overridden by any class that extends the
    parent class that contains the pure virtual function. This means that the abstract
    class can provide some of the common functionality that would be available in
    all its sub-classes. For example, the `Worker` class might have the `m_AnnualSalary`,
    `m_Productivity`, and `m_Age` member variables. It might also have the `getPayCheck`
    function, which is not pure virtual and is the same in all the sub-classes, but
    it might have a `doWork` function, which is pure virtual and must be overridden,
    because all the different types of `Worker` will `doWork` very differently.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By the way, **virtual**, as opposed to pure virtual, is a function that can
    be **optionally overridden**. You declare a virtual function the same way as a
    pure virtual function, but leave the `= 0` off the end. In the current game project,
    we will use a pure virtual function.
  prefs: []
  type: TYPE_NORMAL
- en: If any of this virtual, pure virtual, or abstract stuff is unclear, using it
    is probably the best way to understand it.
  prefs: []
  type: TYPE_NORMAL
- en: Building the PlayableCharacter class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we know the basics about inheritance, polymorphism, and pure virtual functions,
    we will put them to use. We will build a `PlayableCharacter` class that has the
    vast majority of the functionality that any character from our game is going to
    need. It will have one pure virtual function, `handleInput`. The `handleInput`
    function will need to be quite different in the sub-classes, so this makes sense.
  prefs: []
  type: TYPE_NORMAL
- en: As `PlayableCharacter` will have a pure virtual function, it will be an abstract
    class and no objects of it will be possible. We will then build both `Thomas`
    and `Bob` classes, which will inherit from `PlayableCharacter`, implement the
    definition of the pure virtual function, and allow us to instantiate `Bob` and
    `Thomas` objects in our game.
  prefs: []
  type: TYPE_NORMAL
- en: Coding PlayableCharacter.h
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As usual, when creating a class, we will start off with the header file that
    will contain the member variables and function declarations. What is new is that
    in this class, we will declare some **protected** member variables. Remember that
    protected variables can be used as if they are `Public` by classes, which inherit
    from the class with the protected variables.
  prefs: []
  type: TYPE_NORMAL
- en: Right-click **Header Files** in the **Solution Explorer** and select **Add**
    | **New Item...**. In the **Add New Item** window, highlight (by left-clicking)
    **Header File (** `.h` **)** and then in the **Name** field, type `PlayableCharacter.h`.
    Finally, click the **Add** button. We are now ready to code the header file for
    the `PlayableCharacter` class.
  prefs: []
  type: TYPE_NORMAL
- en: We will add and discuss the contents of the `PlayableCharacter.h` file in three
    sections. First, the **protected** section, followed by **private**, then **public**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the code shown next to the `PlayableCharacter.h` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The first thing to notice in the code we just wrote is that all the variables
    are `protected`. This means that when we extend the class, all the variables we
    just wrote will be accessible to those classes that extend it. We will extend
    this class with `Thomas` and `Bob` classes.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from the `protected` access specification, there is nothing new or complicated
    about the previous code. It is worth paying attention to some of the details,
    however. Then it will be easy to understand how the class works as we progress.
    So, let's run through those `protected` variables, one at a time.
  prefs: []
  type: TYPE_NORMAL
- en: We have our somewhat predictable `Sprite`, `m_Sprite`. We have a float called
    `m_JumpDuration`, which will hold a value representing the time that the character
    is able to jump for. The greater the value, the further/higher the character will
    be able to jump.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we have a Boolean, `m_IsJumping`, which is `true` when the character is
    jumping and `false` otherwise. This will be useful for making sure that the character
    can't jump while in mid-air.
  prefs: []
  type: TYPE_NORMAL
- en: The `m_IsFalling` variable has a similar use to `m_IsJumping`. It will be useful
    to know when a character is falling.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we have two Booleans that will be true if the character's left or right
    keyboard buttons are currently being pressed. These are relative depending upon
    the character (*A* and *D* for Thomas, Left and Right arrow keys for Bob). How
    we respond to these Booleans will be seen in the `Thomas` and `Bob` classes.
  prefs: []
  type: TYPE_NORMAL
- en: The `m_TimeThisJump` float variable is updated each and every frame that `m_IsJumping`
    is `true`. We can then know when `m_JumpDuration` has been reached.
  prefs: []
  type: TYPE_NORMAL
- en: The final `protected` variable is the Boolean `m_JustJumped`. This will be `true`
    if a jump was initiated in the current frame. It will be useful for knowing when
    to play a jump sound effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add the following `private` variables to the `PlayableCharacter.h` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code, we have some interesting `private` variables. Remember
    that these variables will only be directly accessible to the code in the `PlayableCharacter`
    class. The `Thomas` and `Bob` classes will not be able to access them directly.
  prefs: []
  type: TYPE_NORMAL
- en: The `m_Gravity` variable will hold the number of pixels per second that the
    character will fall. The `m_Speed` variable will hold the number of pixels per
    second that the character can move left or right.
  prefs: []
  type: TYPE_NORMAL
- en: The `Vector2f`, `m_Position` variable is the position in the world (not the
    screen) where the center of the character is.
  prefs: []
  type: TYPE_NORMAL
- en: The next four `FloatRect` objects are important to discuss. When we did collision
    detection in the *Zombie Arena* game, we simply checked to see if two `FloatRect`
    objects intersected. Each `FloatRect` object represented an entire character,
    a pick-up, or a bullet. For the non-rectangular shaped objects (zombies and the
    player), this was a little bit inaccurate.
  prefs: []
  type: TYPE_NORMAL
- en: In this game, we will need to be more precise. The `m_Feet`, `m_Head`, `m_Right`,
    and `m_Left` `FloatRect` objects will hold the coordinates of the different parts
    of a character's body. These coordinates will be updated in each and every frame.
  prefs: []
  type: TYPE_NORMAL
- en: Through these coordinates, we will be able to tell exactly when a character
    lands on a platform, bumps his head during a jump, or rubs shoulders with a tile
    to his side.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we have `Texture`. `Texture` is `private` as it is not used directly
    by the `Thomas` or `Bob` classes but, as we saw, `Sprite` is `protected` because
    it is used directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add all the `public` functions to the `PlayableCharacter.h` file and then
    we will discuss them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Let's talk about each of the function declarations that we just added. This
    will make coding their definitions easier to follow.
  prefs: []
  type: TYPE_NORMAL
- en: The `spawn` function receives a `Vector2f` called `startPosition` and a `float`
    called `gravity`. As the names suggest, `startPosition` will be the coordinates
    in the level at which the character will start and `gravity` will be the number
    of pixels per second at which the character will fall.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `bool virtual handleInput() = 0` is, of course, our pure virtual function.
    As `PlayableCharacter` has this function, any class that extends it, if we want
    to instantiate it, must provide a definition for this function. Therefore, when
    we write all the function definitions for `PlayableCharacter` in a minute, we
    will not provide a definition for `handleInput`. There will of course need to
    be definitions in both the `Thomas` and `Bob` classes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `getPosition` function returns a `FloatRect` that represents the position
    of the whole character.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `getFeet()` function, as well as `getHead`, `getRight`, and `getLeft`, each
    return a `FloatRect` that represents the location of a specific part of the character's
    body. This is just what we need for detailed collision detection.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `getSprite` function, as usual, returns a copy of `m_Sprite` to the calling
    code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `stopFalling`, `stopRight`, `stopLeft`, and `stopJump` function receive
    a single `float` value, which the function will use to reposition the character
    and stop it walking or jumping through a solid tile.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `getCenter` function returns a `Vector2f` to the calling code to let it
    know exactly where the center of the character is. This value is, of course, held
    in `m_Position`. We will see later that it is used by the `Engine` class to center
    the appropriate `View` around the appropriate character.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `update` function we have seen many times before and as usual, it takes
    a `float` parameter, which is the fraction of a second that the current frame
    has taken. This `update` function will need to do more work than previous `update`
    functions (from other projects), however. It will need to handle jumping, as well
    as updating the `FloatRect` objects that represent the head, feet, left, and right.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now we can write the definitions for all the functions, except, of course, `handleInput`.
  prefs: []
  type: TYPE_NORMAL
- en: Coding PlayableCharacter.cpp
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Right-click **Source Files** in the **Solution Explorer** and select **Add**
    | **New Item...**. In the **Add New Item** window, highlight (by left-clicking)
    **C++ File (** `.cpp` **)** and then in the **Name** field, type `PlayableCharacter.cpp`.
    Finally, click the **Add** button. We are now ready to code the `.cpp` file for
    the `PlayableCharacter` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will break up the code and discussion into a number of chunks. First, add
    the include directives and the definition of the `spawn` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `spawn` function initializes `m_Position` with the passed-in position, as
    well as initializing `m_Gravity`. The final line of code moves `m_Sprite` to its
    starting position.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add the definition for the `update` function, immediately after the preceding
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The first two parts of the code check whether `m_RightPressed` or `m_LeftPressed`
    is `true`. If either of them is, `m_Position` is changed using the same formula
    as the previous project (elapsed time multiplied by speed).
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we see whether or not the character is currently executing a jump. We
    know this from `if(m_IsJumping)`. If this `if` statement is `true`, these are
    the steps the code takes:'
  prefs: []
  type: TYPE_NORMAL
- en: Update `m_TimeThisJump` with `elapsedTime`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check if `m_TimeThisJump` is still less than `m_JumpDuration`. If it is, change
    the y coordinate of `m_Position` by twice gravity multiplied by the elapsed time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `else` clause that executes when `m_TimeThisJump` is not lower than `m_JumpDuration`,
    then `m_Falling` is set to `true`. The effect of doing this will be seen next.
    Also, `m_Jumping` is set to `false`. This prevents the code we have just been
    discussing from executing, because `if(m_IsJumping)` is now false.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `if(m_IsFalling)` block moves `m_Position` down each frame. It is moved
    using the current value of `m_Gravity` and the elapsed time.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code (almost all of the remaining code) updates the body parts
    of the character, relative to the current position of the sprite as a whole. Take
    a look at the following diagram to see how the code calculates the position of
    the virtual head, feet, left, and right sides of the character:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Coding PlayableCharacter.cpp](img/image_13_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The final line of code uses the `setPosition` function to move the sprite to
    its correct location after all of the possibilities of the `update` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the definition for the `getPosition`, `getCenter`, `getFeet`, `getHead`,
    `getLeft`, `getRight`, and `getSprite` functions, immediately after the previous
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `getPosition` function returns a `FloatRect` that wraps the entire sprite,
    and `getCenter` returns a `Vector2f`, which contains the center of the sprite.
    Notice that we divide the height and width of the sprite by two in order to dynamically
    arrive at this result. This is because Thomas and Bob will be of different heights.
  prefs: []
  type: TYPE_NORMAL
- en: The `getFeet`, `getHead`, `getLeft`, and `getRight` functions return the `FloatRect`
    objects that represent the body parts of the character that we update each frame
    in the `update` function. We will write the **collision detection code** that
    uses these functions in the following chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The `getSprite` function, as usual, returns a copy of `m_Sprite`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, for the `PlayableCharacter` class, add the definitions for the `stopFalling`,
    `stopRight`, `stopLeft`, and `stopJump` functions. Do so immediately after the
    previous code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Each of the previous functions receives a value as a parameter that is used
    to reposition either the top, bottom, left, or right of the sprite. Exactly what
    these values are and how they are obtained will be seen in the following chapter.
    Each of the previous functions also repositions the sprite.
  prefs: []
  type: TYPE_NORMAL
- en: The final function is the `stopJump` function that will also be used in collision
    detection. It sets the necessary values for `m_IsJumping` and `m_IsFalling` to
    end a jump.
  prefs: []
  type: TYPE_NORMAL
- en: Building the Thomas and Bob classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we get to use inheritance for real. We will build a class for Thomas and
    a class for Bob. They will both inherit from the `PlayableCharacter` class we
    just coded. They will then have all the functionality of the `PlayableCharacter`
    class, including direct access to its `protected` variables. We will also add
    the definition for the pure virtual function `handleInput`. You will notice that
    the `handleInput` functions for `Thomas` and `Bob` will be different.
  prefs: []
  type: TYPE_NORMAL
- en: Coding Thomas.h
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Right-click **Header Files** in the **Solution Explorer** and select **Add**
    | **New Item...**. In the **Add New Item** window, highlight (by left-clicking)
    **Header File** (`.h`) and then in the **Name** field, type `Thomas.h`. Finally,
    click the **Add** button. We are now ready to code the header file for the `Thomas`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add this code to the `Thomas.h` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The previous code is very short and sweet. We can see that we have a constructor
    and that we are going to implement the pure virtual `handleInput` function, so
    let's do that now.
  prefs: []
  type: TYPE_NORMAL
- en: Coding Thomas.cpp
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Right-click **Source Files** in the **Solution Explorer** and select **Add**
    | **New Item...**. In the **Add New Item** window, highlight (by left-clicking)
    **C++ File** (`.cpp`) and then in the **Name** field, type `Thomas.cpp`. Finally,
    click the **Add** button. We are now ready to code the `.cpp` file for the `Thomas`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `Thomas` constructor to the `Thomas.cpp` file, as shown in the following
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: All we need to do is load the `thomas.png` graphic and set the duration of a
    jump (`m_JumpDuration`) to `.45` (nearly half a second).
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the definition of the `handleInput` function, as shown in the following
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This code should look quite familiar. We are using the SFML `isKeyPressed` function
    to see whether any of the *W, A,* or *D* keys are pressed.
  prefs: []
  type: TYPE_NORMAL
- en: When *W* is pressed, the player is attempting to jump. The code then uses the
    `if(!m_IsJumping && !m_IsFalling)` code, which checks that the character is not
    already jumping and that it is not falling either. When these tests are both true,
    `m_IsJumping` is set to `true`, `m_TimeThisJump` is set to zero, and `m_JustJumped`
    is set to true.
  prefs: []
  type: TYPE_NORMAL
- en: When the previous two tests don't evaluate to `true`, the `else` clause is executed
    and `m_Jumping` is set to `false` and `m_IsFalling` is set to true.
  prefs: []
  type: TYPE_NORMAL
- en: The handling of the *A* and *D* keys being pressed is as simple as setting `m_LeftPressed`
    and/or `m_RightPressed` to `true` or ` false`. The `update` function will now
    be able to handle moving the character.
  prefs: []
  type: TYPE_NORMAL
- en: The last line of code in the function returns the value of `m_JustJumped`. This
    will let the calling code know if it needs to play a jumping sound effect.
  prefs: []
  type: TYPE_NORMAL
- en: We will now code the `Bob` class, although this is nearly identical to the `Thomas`
    class, except it has different jumping abilities, a different `Texture`, and uses
    different keys on the keyboard.
  prefs: []
  type: TYPE_NORMAL
- en: Coding Bob.h
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Bob` class is identical in structure to the `Thomas` class. It inherits
    from `PlayableCharacter`, it has a constructor, and it provides the definition
    of the `handleInput` function. The difference compared to `Thomas` is that we
    initialize some of Bob's member variables differently and we handle input (in
    the `handleInput` function) differently as well. Let's code the class and see
    the details.
  prefs: []
  type: TYPE_NORMAL
- en: Right-click **Header Files** in the **Solution Explorer** and select **Add**
    | **New Item...**. In the **Add New Item** window, highlight (by left-clicking)
    **Header File (** `.h` **)** and then in the **Name** field, type `Bob.h`. Finally,
    click the **Add** button. We are now ready to code the header file for the `Bob`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to the `Bob.h` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The previous code is identical to the `Thomas.h` file apart from the class name,
    and therefore, the constructor name.
  prefs: []
  type: TYPE_NORMAL
- en: Coding Bob.cpp
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Right-click **Source Files** in the **Solution Explorer** and select **Add**
    | **New Item...**. In the **Add New Item** window, highlight (by left-clicking)
    **C++ File (** `.cpp` **)** and then in the **Name** field, type `Thomas.cpp`.
    Finally, click the **Add** button. We are now ready to code the `.cpp` file for
    the `Bob` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the code for the `Bob` constructor to the `Bob.cpp` file. Notice that the
    texture is different (`bob.png`) and that `m_JumpDuration` is initialized to a
    significantly smaller value. Bob is now his own, unique self:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the `handleInput` code immediately after the `Bob` constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the code is nearly identical to the code in the `handleInput` function
    of the `Thomas` class. The only difference is that we respond to different keys
    (**Left** arrow key, **Right** arrow key, and **Up** arrow key for jump.)
  prefs: []
  type: TYPE_NORMAL
- en: Now we have a `PlayableCharacter` class that has been extended by `Bob` and
    `Thomas`, we can add a `Bob` and a `Thomas` instance to the game.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the game engine to use Thomas and Bob
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to be able to run the game and see our new characters, we have to declare
    instances of them, call their `spawn` functions, update them each frame, and draw
    them each frame. Let's do that now.
  prefs: []
  type: TYPE_NORMAL
- en: Updating Engine.h to add an instance of Bob and Thomas
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open up the `Engine.h` file and add the highlighted lines of code, as shown
    in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Now we have an instance of both `Thomas` and `Bob`, which are derived from `PlayableCharacter`.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the input function to control Thomas and Bob
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now we will add the ability to control the two characters. This code will go
    in the input part of the code. Of course, for this project, we have a dedicated
    `input` function. Open up `Input.cpp` and add this highlighted code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Note how simple the previous code is, as all the functionality is contained
    within the `Thomas` and `Bob` classes. All the code has to do is add an include
    directive for each of the `Thomas` and `Bob` classes. Then, within the `input`
    function, the code just calls the pure virtual `handleInput` functions on `m_Thomas`
    and `m_Bob`. The reason we wrap each of the calls in an `if` statement is because
    they return `true` or `false` based upon whether a new jump has just been successfully
    initiated. We will handle playing the jump sound effects in [Chapter 15](ch15.html
    "Chapter 15. Sound Spatialization and HUD"), *Sound Spacialization and HUD*.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the update function to spawn and update the PlayableCharacter instances
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is broken down into two parts. First, we need to spawn Bob and Thomas at
    the start of a new level, and second, we need to update (by calling their `update`
    functions) each frame.
  prefs: []
  type: TYPE_NORMAL
- en: Spawning Thomas and Bob
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We need to call the spawn functions of our `Thomas` and `Bob` objects in a
    few different places as the project progresses. Most obviously, we need to spawn
    the two characters when a new level begins. In the following chapter, as the number
    of tasks we need to perform at the beginning of a level increases, we will write
    a `loadLevel` function. For now, lets just call `spawn` on `m_Thomas` and `m_Bob`
    in the `update` function, as shown in the following highlighted code. Add the
    code, but keep in mind that this code will eventually be deleted and replaced:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The previous code simply calls `spawn` and passes in a location in the game
    world, along with the gravity. The code is wrapped in an `if` statement that checks
    whether a new level is required. The actual spawning code will be moved to a dedicated
    `loadLevel` function, but the `if` condition will be part of the finished project.
    Also, `m_TimeRemaining` is set to a somewhat arbitrary 10 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Updating Thomas and Bob each frame
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Next, we will update Thomas and Bob. All we need to do is call their `update`
    functions and pass in the time this frame has taken.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following highlighted code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Now that the characters can move, we need to update the appropriate `View` objects
    to center around the characters and make them the center of attention. Of course,
    until we have some objects in our game world, the sensation of actual movement
    will not be achieved.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the highlighted code, as shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The previous code handles the two possible situations. First, the `if(mSplitScreen)` condition
    positions the left-hand view around `m_Thomas` and the right-hand view around
    `m_Bob`. The `else` clause that executes when the game is in fullscreen mode tests
    to see if `m_Character1` is `true`. If it is, then the fullscreen view (`m_MainView`)
    is centered around Thomas, otherwise it is centered around Bob. You probably remember
    that the player can use the *E* key to toggle split screen mode and the *Q* key
    to toggle between Bob and Thomas, in fullscreen mode. We coded this in the `input`
    function of the `Engine` class, back in [Chapter 12](ch12.html "Chapter 12. Abstraction
    and Code Management – Making Better Use of OOP"), *Abstraction and Code Management
    - Making Better Use of OOP*.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing Bob and Thomas
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Make sure the `Draw.cpp` file is open and add the highlighted code, as shown
    in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we draw both Thomas and Bob for the full screen, the left, and the
    right. Also note the very subtle difference in the way that we draw the characters
    in split screen mode. When drawing the left side of the screen, we switch the
    order the characters are drawn and draw Thomas after Bob. So, Thomas will always
    be on top on the left, and Bob on the right. This is because the player controlling
    Thomas is catered for on the left and Bob the right.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can run the game and see Thomas and Bob in the center of the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Drawing Bob and Thomas](img/image_13_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you press the *Q* key to switch focus from Thomas to Bob, you will see the
    `View` make the slight adjustment. If you move either of the characters left or
    right (Thomas with *A* and *D*, Bob with the arrow keys) you will see them move
    relative to each other.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try pressing the *E* key to toggle between fullscreen and split-screen. Then
    try moving both characters again to see the effect. In the following screenshot,
    you can see that Thomas is always centered in the left-hand window and Bob is
    always centered in the right-hand window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Drawing Bob and Thomas](img/image_13_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you leave the game running long enough, the characters will re-spawn in their
    original positions every ten seconds. This is the beginnings of the functionality
    we will need for the finished game. This behavior is caused by `m_TimeRemaining`
    going below zero and then setting the `m_NewLevelRequired` variable to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: Also note that we can't see the full effect of movement until we draw the details
    of the level. In fact, although it can't be seen, both characters are continuously
    falling at 300 pixels per second. As the camera is centering around them every
    frame and there are no other objects in the game-world, we cannot see this downward
    movement.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to demonstrate this to yourself, just change the call to `m_Bob.spawn`,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that Bob has no gravitational effect, Thomas will visibly fall away from
    him. This is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Drawing Bob and Thomas](img/image_13_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We will add some playable levels to interact with in the following chapter.
  prefs: []
  type: TYPE_NORMAL
- en: FAQ
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Q) We learned about polymorphism, but I didn't notice anything polymorphic in
    the game code so far.
  prefs: []
  type: TYPE_NORMAL
- en: A) We will see polymorphism in action in the following chapter, when we write
    a function that takes a `PlayableCharacter` as a parameter. We will see how we
    can pass either Bob or Thomas to this new function and it will work the same with
    either of them.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned some new C++ concepts. First, Inheritance allows
    us to extend a class and gain all of its functionality. We also learned that we
    can declare variables as protected, and that will give the child class access
    to them, but they will still be encapsulated (hidden) from all other code. We
    also used pure virtual functions, which make a class abstract, meaning that the
    class cannot be instantiated and must therefore be inherited/extended from. We
    were also introduced to the concept of polymorphism, but will need to wait until
    the following chapter to use it in our game.
  prefs: []
  type: TYPE_NORMAL
- en: Next up, we will add some major functionality to the game. By the end of the
    following chapter, Thomas and Bob will be walking, jumping, and falling. They
    will even be able to jump on each other's heads, as well as explore some level
    designs that are loaded from a text file.
  prefs: []
  type: TYPE_NORMAL
