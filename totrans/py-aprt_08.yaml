- en: Chapter 3 – Modularity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Modularity is an important property for anything but trivial software systems
    as it gives us the power to make self-contained, reusable pieces which can be
    combined in new ways to solve different problems. In Python, as with most programming
    languages, the most fine-grained modularization facility is the definition of
    reusable functions. But Python also gives us several other powerful modularization
    mechanisms.
  prefs: []
  type: TYPE_NORMAL
- en: Collections of related functions are themselves grouped together a form modularity
    called *modules*. Modules are source code files ^([3](chap21.xhtml#fn-modules-as-files))
    that can be referenced by other modules, allowing the functions defined in one
    module to be re-used in another. So long as you take care to avoid any circular
    dependencies, modules are a simple and flexible way to organize programs.
  prefs: []
  type: TYPE_NORMAL
- en: In previous chapters we’ve seen that we can import modules into the REPL. We’ll
    also show you how modules can be executed directly as programs or scripts. As
    part of this we’ll investigate the Python execution model, to ensure that you
    have a good understanding of exactly *when* code is evaluated and executed. We’ll
    round off this chapter by showing you how to use command-line arguments to get
    basic configuration data into your program and make your program executable.
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate this chapter, we’ll start with the code snippet for retrieving
    words from a web-hosted text document that we developed at the end of the previous
    chapter. We’ll elaborate on that code by organizing it into a fully-fledged Python
    module.
  prefs: []
  type: TYPE_NORMAL
- en: Organizing code in a .py file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s start with the snippet we worked with in Chapter 2\. Open a text editor
    – preferably one with syntax highlighting support for Python – and configure it
    to insert four spaces per indent level when you press the tab key. You should
    also check that your editor saves the file using the UTF 8 encoding as that’s
    what the Python 3 runtime expects by default.
  prefs: []
  type: TYPE_NORMAL
- en: Create a directory called `pyfund` in your home directory. This is where we’ll
    put the code for the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'All Python source files use the `.py` extension, so let’s get the snippet we
    wrote at the REPL at end of the previous module into a text file called `pyfund/words.py`.
    The file’s contents should looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You’ll notice some minor differences between the code above and what we wrote
    previously at the REPL. Now that we’re using a text file for our code we can pay
    a little more attention to readability, so, for example, we’ve put a blank line
    after the `import` statement.
  prefs: []
  type: TYPE_NORMAL
- en: Save this file before moving on.
  prefs: []
  type: TYPE_NORMAL
- en: Running Python programs from the operating system shell
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Switch to a console with your operating system’s shell prompt and change to
    the new `pyfund` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We can execute our module by calling Python and passing the module’s filename:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'on Mac or Linux, or:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: on Windows.
  prefs: []
  type: TYPE_NORMAL
- en: When you press return, after a short delay you’ll be returned to the system
    prompt. Not very impressive, but if you got no response then the program is running
    as expected. If, on the other hand, you saw some error out, then something it
    wrong. An `HTTPError`, for example, indicates there’s a network problem, whilst
    other types of errors probably mean you have mistyped the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add another for-loop to the end of the program to print out one word
    per line. Add this code to the end of your Python file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: If you go to your command prompt and execute the code again, you should see
    some output. Now we have the beginnings of a useful program!
  prefs: []
  type: TYPE_NORMAL
- en: Importing modules into the REPL
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Our module can also be imported into the REPL. Let’s try that and see what
    happens. Start the REPL and import your module. When importing a module, you use
    `import <module-name>`, omitting the `.py` extension from the module name. In
    our case, it looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The code in your module is executed immediately when imported! That’s maybe
    not what you expected, and it’s certainly not very useful. To give us more control
    over when our code is executed, and to allow it to be reused, we’ll need to put
    our code in a function.
  prefs: []
  type: TYPE_NORMAL
- en: Defining functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Functions are defined using the `def` keyword followed by the function name,
    an argument list in parentheses, and a colon to start a new block. Let’s quickly
    define a few functions at the REPL to get the idea:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We use the `return` keyword to return a value from the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we’ve seen previously, we call functions by providing the actual arguments
    in parentheses after the function name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Functions aren’t required to explicitly return a value though — perhaps they
    produce side effects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'You can return early from a function by using the `return` keyword with no
    parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If you don’t have an explicit `return` in your function, Python will implicitly
    add one at the end if your function. This implicit return, or a `return` without
    a parameter, actually causes the function to return `None`. Remember, though,
    that the REPL doesn’t display `None` results, so we don’t see them. By capturing
    the returned object into a named variable we can test for `None`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Organizing our module into functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s organize our words module using functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'First we’ll move all the code except the import statement into a function called
    `fetch_words()`. You do that by adding the `def` statement and indenting the code
    below it by one extra level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Save the module, and reload the module using a fresh Python REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The module imports, but the words are not fetched until we call the `fetch_words()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively we can import our specific function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: So far so good, but what happens when we try to run our module directly from
    the operating system shell?
  prefs: []
  type: TYPE_NORMAL
- en: 'Exit from the REPL with `Ctrl-D` from Mac or Linux or `Ctrl-Z` for Windows,
    and run Python 3 passing the module filename:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: No words are printed. This is because all the module does now is to define a
    function and then immediately exit. To make a module from which we can usefully
    import functions into the REPL *and* which can be run as a script, we need to
    learn a new Python idiom.
  prefs: []
  type: TYPE_NORMAL
- en: '`__name__` and executing modules from the command line'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The Python runtime system defines some special variables and attributes, the
    names of which are delimited by double underscores. One such special variable
    is called `__name__`, and it gives us the means for our module to determine whether
    it has been run as a script or, instead, imported into another module or the REPL.
    To see how, add:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: add the end of your module, outside of the `fetch_words()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, let’s import the modified words module back into the REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We can see that when imported `__name__` does indeed evaluate to the module’s
    name.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a brief aside, if you import the module again, the print statement will
    *not* be executed; module code is only executed once, on first import:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let’s try running the module as a script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case the special `__name__` variable is equal to the string “**main**”
    which is also delimited by double underscores. Our module can use this behavior
    to detect how it is being used. We replace the print statement with an if-statement
    which tests the value of `__name__`. If the value is equal to “**main**” then
    our function is executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can safely import our module without unduly executing our function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'and we can usefully run our function as a script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The Python execution model
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In order to have a really solid foundation in Python, it’s important to understand
    the Python *execution model*. By this, we mean the rules defining precisely when
    function definitions and other important events occur during module import and
    execution. To help you develop this understanding, we’ll focus on the `def` keyword
    since you’re already familiar with it. Once you have an understanding of how `def`
    is processed by Python, you’ll know most of what you need to know about Python’s
    execution model.
  prefs: []
  type: TYPE_NORMAL
- en: 'What’s important to understand is this: **`def` isn’t merely a declaration,
    it’s a *statement***. What this means is that `def` is actually executed at runtime
    along with the rest of the top-level module-scope code. What `def` does is to
    bind the code in the function’s body to the name following `def`. When modules
    are imported or run, all of the top-level statements are run, and this is the
    means by which the functions within the module namespace are defined.'
  prefs: []
  type: TYPE_NORMAL
- en: To reiterate, `def` is executed at runtime. This is very different from how
    function definitions are handled in many other languages, especially compiled
    languages like C++, Java, and C#. In those languages, function definitions are
    processed by the compiler at *compile time*, not at runtime.^([4](chap21.xhtml#fn-dynamic-functions))
    By the time the program is actually executing, those function definitions are
    fixed. In Python there is no compiler ^([5](chap21.xhtml#fn-no-compiler)), and
    functions don’t exist in any form — except that of source code — until execution.
    In fact, since a function is only defined when its `def` is processed on import,
    a function in a module which is never imported will never be defined.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding this dynamic nature of Python function definitions is critical
    to understanding important concepts later in this book, so make sure you’re comfortable
    with it. If you’ve access to a Python debugger, e.g. in an IDE, you might spend
    some time stepping through your `words.py` module as it’s imported.
  prefs: []
  type: TYPE_NORMAL
- en: The difference between modules, scripts, and programs
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’re sometimes asked about the differences between Python modules, Python scripts,
    and Python programs. Any `.py` file constitutes a Python module, but as we have
    seen modules can be written for convenient import, convenient execution, or, using
    the `if __name__ == "__main__"` idiom, both.
  prefs: []
  type: TYPE_NORMAL
- en: We strongly recommend making even simple scripts importable since it eases development
    and testing so much if you can access your code from the Python REPL. Likewise,
    even modules which are only ever meant to be imported in production settings benefit
    from having executable test code. For this reason nearly all modules we create
    have this form of defining one or more importable functions with a postscript
    to facilitate execution.
  prefs: []
  type: TYPE_NORMAL
- en: Whether you consider a module to be a Python script or Python program is a matter
    of context and usage. It’s certainly wrong to consider Python to be merely a scripting
    tool — in the vein of Windows batch files or Unix shell scripts — as many large
    and complex applications have been built exclusively with Python.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a main function with command line argument
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s refine our word fetching module a little further. First, we’ll perform
    a small refactoring and separate the word retrieval and collection on the one
    hand from the word printing on the other:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We do this because it separates two important concerns: when importing we’d
    rather get the words as a list, but when running directly, we’d prefer the words
    to be printed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we’ll extract the code from our `if __name__ == ''__main__''` block into
    a function called `main()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: By moving this code into a function we can test it from the REPL, something
    which isn’t possible while it’s in the module scope if-block.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now try these functions from the REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We’ve used this opportunity to introduce a couple of new forms of the `import`
    statement. The first new form imports multiple objects from a module using a comma
    separated list. The parentheses are optional, but they do allow you to break this
    list over multiple lines if it gets long. This form is perhaps the most widely
    used form of the import statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'A second new form imports everything from a module using an asterisk wildcard:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This latter form is recommended only for casual use at the REPL. It can wreak
    havoc in programs since what is imported is now potentially beyond your control,
    opening yourself up to potential namespace clashes at some future time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having done this, we can fetch words from the URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we’ve separated the fetching code from the printing code, we can also
    print *any* list of words:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Indeed, we can even run the main program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that the `print_words()` function isn’t fussy about the type items in
    the list. It’s perfectly happy to print a list of numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'So perhaps `print_words()` isn’t the best name. In fact, the function doesn’t
    mention lists either - it will happily print any collection that the for-loop
    is capable of iterating over, such as a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'So let’s perform a minor refactoring and rename this function to `print_items()`,
    changing the variable names within the function to suit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, one obvious improvement to our module would be to replace the hard-coded
    URL with a value we can pass in. Let’s extract that value into an argument of
    the `fetch_words()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Accepting command line arguments
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'That last change actually breaks our `main()` since it’s not passing the new
    `url` argument. When running our module as a standalone program, we’ll need to
    accept the URL as a command line argument. Access to command line arguments in
    Python is through an attribute of the `sys` module called `argv` which is a list
    of strings. To use it we must first import the `sys` module at the top of our
    program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We then get the second argument (with an index of one) from the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'And of course this works as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'This looks fine until we realize that we can’t usefully test `main()` any longer
    from the REPL because it refers to `sys.argv[1]` which is unlikely to have a useful
    value in that environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The solution is to allow the argument list to be passed as a formal argument
    to the `main()` function, using `sys.argv` as the actual parameter in the `if
    __name__ == ''__main__''` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Testing from the REPL again, we can see that everything works as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Python is a great tool for developing command line tools, and you’ll likely
    find that you need to handle command line arguments for many situations. For more
    sophisticated command line processing we recommend you look at the [Python Standard
    Library `argparse`](https://docs.python.org/3/library/argparse.html) module or
    [the inspired third-party `docopt` module](http://docopt.org/).
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Moment of zen
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '![](images/m03----zen-sparse-is-better-than-dense.png)'
  prefs: []
  type: TYPE_IMG
- en: You’ll notice that our top level functions have two blank lines between them.
    This is conventional for modern Python code.
  prefs: []
  type: TYPE_NORMAL
- en: According to [the PEP 8 style-guide](https://www.python.org/dev/peps/pep-0008/)
    it’s customary to use two blank lines between module-level functions. We find
    this convention has served us well, making code easier to navigate. Similarly,
    we use single blank lines for logical breaks within functions.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Docstrings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We saw previously how it was possible to ask at the REPL for help on Python
    functions. Let’s look at how to add this self-documenting capability to our own
    module.
  prefs: []
  type: TYPE_NORMAL
- en: 'API documentation in Python uses a facility called *docstrings*. Docstrings
    are literal strings which occur as the first statement within a named block, such
    as a function or module. Let’s document the `fetch_words()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: We use triple-quoted strings even for single-line docstrings because they can
    be easily expanded to add more detail.
  prefs: []
  type: TYPE_NORMAL
- en: 'One Python convention for docstrings is documented in [PEP 257](https://www.python.org/dev/peps/pep-0257/),
    although it is not widely adopted. Various tools, such as [Sphinx](http://www.sphinx-doc.org/),
    are available to build HTML documentation from Python docstrings, and each tool
    mandates its preferred docstring format. Our preference is to use the form presented
    in [Google’s Python style-guide](https://google.github.io/styleguide/pyguide.html),
    since it is amenable to being machine parsed whilst still remaining readable at
    the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we’ll access this `help()` from the REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll add similar docstrings for our other functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'and one for the module itself. Module docstrings should be placed at the beginning
    of the module, before any statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Now when we request `help()` on the module as a whole, we get quite a lot of
    useful information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Comments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We believe docstrings are the right place for most documentation in Python code.
    They explain how to consume the facilities your module provides rather than how
    it works. Ideally your code should be clean enough that ancillary explanation
    is not required. Nevertheless, it’s sometimes necessary to explain *why* a particular
    approach has be chosen or a particular technique used, and we can do that using
    Python comments. Comments in Python begin with `#` and continue to the end of
    the line.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a demonstration, let’s document the fact that it might not be immediately
    obvious why we’re using `sys.argv[1]` rather than `sys.argv[0]` in our call to
    `main()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Shebang
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s common on Unix-like systems to have the first line of a script include
    a special comment, `#!`, called a *shebang*. This allows the program loader to
    identify which interpreter should be used to run the program. Shebangs have an
    additional purpose of conveniently documenting at the top of a file whether the
    Python code therein is Python 2 or Python 3.
  prefs: []
  type: TYPE_NORMAL
- en: 'The exact details of your shebang command depend on the location of Python
    on your system. Typical Python 3 shebangs use the Unix `env` program to locate
    Python 3 on your `PATH` environment variable, which importantly is compatible
    with Python virtual environments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Executable Python programs on Linux and Mac
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'On Mac or Linux, we must mark our script as executable using the `chmod` command
    before the shebang will have any effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Having done that, we can now run our script directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Executable Python programs on Windows
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Starting with Python 3.3, Python on Windows also supports the use of the shebang
    to make Python scripts directly executable with the correct version of the Python
    interpreter, even to the extent that shebangs that look like they should only
    work on Unix-like systems will work as expected on Windows. This works because
    Windows Python distributions now use a program called *PyLauncher*. PyLauncher,
    the executable for which is called `py.exe`, will parse the shebang and locate
    the appropriate version of Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, on Windows at the `cmd` prompt, this command will be sufficient
    to run your script with Python 3 (even if you also have Python 2 installed):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'In Powershell the equivalent is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: You can read more about PyLauncher in [PEP 397](https://www.python.org/dev/peps/pep-0397/).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Python modules:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python code is placed in `*.py` files called modules.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modules can be executed directly by passing them as the first argument to the
    Python interpreter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modules can also be imported into the REPL, at which point all top-level statements
    in the module are executed in order.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Python functions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Named functions are defined using the `def` keyword followed by the function
    name and the argument list in parentheses.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can return objects from functions using the `return` statement.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Return statements without a parameter return `None`, as does the implicit `return`
    at the end of every function body.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Module execution:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can detect whether a module has been imported or executed by examining the
    value of the special `__name__` variable. If it is equal to the string `"__main__"`
    our module has been executed directly as a program. By executing a function if
    this condition is met using the top-level `if __name__ == '__main__'` idiom at
    the end of our module, we can make our module both usefully importable and executable,
    an important testing technique even for short scripts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Module code is only executed once, on first import.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `def` keyword is a statement which binds executable code to a function name.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Command line arguments can be accessed as a list of strings accessible through
    the `argv` attribute of the `sys` module. The zero-th command line argument is
    the script filename, so the item at index one is the first true argument.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python’s dynamic typing means our functions can be very generic with respect
    to the type of their arguments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Docstrings:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A literal string as the first line of a function’s definition forms the function’s
    docstring. They are typically triple-quoted multiline strings containing usage
    information.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function documentation provided in docstrings can be retrieved using `help()`
    in the REPL.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Module docstrings should be placed near the beginning of the module prior to
    any Python statements such as import statements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Comments:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comments in Python commence with a hash character and continue to the end of
    the line.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first line of the module can contain a special comment called a shebang,
    allowing the program loader to launch the correct Python interpreter on all major
    platforms.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
