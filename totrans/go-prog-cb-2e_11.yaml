- en: Distributed Systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, application-level parallelism is not enough, and things that seem
    simple in development can become complex during deployment. Distributed systems
    provide a number of challenges that aren't found when developing on a single machine.
    These applications have added complexity for things such as monitoring, writing
    applications that require strong consistency guarantees, and service discovery.
    In addition, you must always be mindful of single points of failure, such as a
    database, otherwise your distributed applications can fail when this single component
    fails.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will explore methods of managing distributed data, orchestration,
    containerization, metrics, and monitoring. These will become part of your toolbox
    for writing and maintaining microservices and large distributed applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Using service discovery with Consul
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing basic consensus using Raft
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using containerization with Docker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Orchestration and deployment strategies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collecting metrics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To follow all the recipes in this chapter, configure your environment according
    to these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Download and install Go 1.12.6 or above on your operating system from [https://golang.org/doc/install](https://golang.org/doc/install).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install Consul from [https://www.consul.io/intro/getting-started/install.html](https://www.consul.io/intro/getting-started/install.html).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open a Terminal or console application and create and navigate to a project
    directory such as `~/projects/go-programming-cookbook`. All the code will be run
    and modified from this directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Clone the latest code into `~/projects/go-programming-cookbook-original` and
    (optionally) work from that directory rather than typing in the examples manually:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Using service discovery with Consul
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When using the microservice approach to applications, you end up with a lot
    of servers listening on a variety of IPs, domains, and ports. These IP addresses
    will vary by environment (staging versus production), and it can be tricky to
    keep them static for configuration between services. You also want to know when
    a machine or service is down or unreachable due to a network partition. A network
    partition occurs when two parts of the network cannot reach each other. For example,
    if a switch fails between two data centers, then the services within one datacenter
    cannot reach services in the other datacenter. Consul is a tool that provides
    a lot of functionality, but here, we'll explore registering services with Consul
    and querying them from our other services.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These steps cover writing and running your application:'
  prefs: []
  type: TYPE_NORMAL
- en: From your Terminal or console application, create a new directory called `~/projects/go-programming-cookbook/chapter11/discovery` and
    navigate to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see a file called `go.mod` that contains the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Copy the tests from `~/projects/go-programming-cookbook-original/chapter11/discovery`,
    or use this as an opportunity to write some of your own code!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a file called `client.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file called `operations.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file called `exec.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Create a new directory named `example` and navigate to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a file named `main.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Start Consul in a separate Terminal using the `consul agent -dev -node=localhost`
    command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the `go run main.go` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You may also run the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `go.mod` file may be updated and the `go.sum` file should now be present
    in the top-level recipe directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you copied or wrote your own tests, go up one directory and run `go test`.
    Ensure that all the tests pass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Consul provides a robust Go API library. It can feel daunting when you're starting
    for the first time, but this recipe shows how you might approach wrapping it.
    Configuring Consul further is beyond the scope of this recipe; this shows the
    basics of registering a service and querying for other services when given a key
    and tag.
  prefs: []
  type: TYPE_NORMAL
- en: It would be possible to use this to register new microservices at startup time,
    query for all dependent services, and deregister at shutdown. You may also want
    to cache this information so that you're not hitting Consul for every request,
    but this recipe provides the basic tools that you can expand upon. The Consul
    agent also makes these repeated requests fast and efficient ([https://www.consul.io/intro/getting-started/agent.html](https://www.consul.io/intro/getting-started/agent.html)).
    Once you've s
  prefs: []
  type: TYPE_NORMAL
- en: Implementing basic consensus using Raft
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Raft is a consensus algorithm. It allows distributed systems to keep a shared
    and managed state ([https://raft.github.io/](https://raft.github.io/)). Setting
    up a Raft system is complex in many ways – for one, you need consensus for an
    election to occur and succeed. This can be difficult to bootstrap when you're
    working with multiple nodes and can be difficult to get started. It is possible
    to run a basic cluster on a single node/leader. However, if you want redundancy,
    at least three nodes are needed to prevent data loss in the case of a single node
    failure. This concept is known as quorum, where you must maintain (*n*/2)+1 available
    nodes to ensure new logs can be committed to the Raft cluster. Basically, if you
    can maintain quorum, the cluster remains healthy and usable.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe implements a basic in-memory Raft cluster, constructs a state machine
    that can transition between certain allowed states, and connects the distributed
    state machine to a web handler that can trigger the transition. This can be useful
    when you're implementing the base finite state machine interface that Raft requires,
    or when testing. This recipe uses [https://github.com/hashicorp/raft](https://github.com/hashicorp/raft)
    for the base Raft implementation.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following steps cover writing and running your application:'
  prefs: []
  type: TYPE_NORMAL
- en: From your Terminal or console application, create a new directory called `~/projects/go-programming-cookbook/chapter11/consensus` and
    navigate to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see a file called `go.mod` that contains the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Copy the tests from `~/projects/go-programming-cookbook-original/chapter11/consensus`,
    or use this as an opportunity to write some of your own code!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a file called `state.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file called `raftset.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file called `config.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file called `fsm.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file called `handler.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Create a new directory named `example` and navigate to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a file named `main.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the `go run main.go` command. Alternatively, you may also run the following
    commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'You should now see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In a separate Terminal, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `go.mod` file may be updated and the `go.sum` file should now be present
    in the top-level recipe directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you copied or wrote your own tests, go up one directory and run `go test`.
    Ensure that all the tests pass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When the application starts, we initialize multiple Raft objects. These each
    have their own address and transport. The `InmemTransport{}` function also provides
    a method for connecting the other transports, and is called `Connect()`. Once
    these connections are established, the Raft cluster holds an election. When communicating
    in a Raft cluster, clients must communicate with the leader. In our case, one
    handler can talk to all of the nodes, so the handler is responsible for having
    the `Raft` leader's `call Apply()` object. This in turn runs `apply()` on all
    of the other nodes.
  prefs: []
  type: TYPE_NORMAL
- en: The `InmemTransport{}` function simplifies the election and bootstrapping process
    by allowing everything to reside in memory. In practice, this isn't very helpful,
    except for testing and proof of concepts, since Goroutines can freely access shared
    memory. A more production-minded implementation would use something like an HTTP
    Transport such that service instances can communicate across machines. This may
    require some additional bookkeeping or service discovery as the service instances
    have to listen and serve as well as have the ability discover and establish connections
    with one another.
  prefs: []
  type: TYPE_NORMAL
- en: Using containerization with Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker is a container technology for packaging and shipping applications. Other
    advantages include portability, since a container will run the same way regardless
    of the host OS. It provides a lot of the advantages of a virtual machine, but
    in a more lightweight container. It's possible to limit the resource consumption
    of individual containers and sandbox your environment. It can be extremely useful
    to have a common environment for your applications locally and when you ship your
    code to production. Docker is written in Go and is open source, so it's simple
    to take advantage of the client and libraries. This recipe will set up a Docker
    container for a basic Go application, store some version information about the
    container, and demonstrate hitting a handler from a Docker endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Configure your environment according to these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Refer to the *Technical requirements* section in this chapter for steps to configure
    your environment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install Docker from [https://docs.docker.com/install](https://docs.docker.com/install/).
    This will also include Docker Compose.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These steps cover writing and running your application:'
  prefs: []
  type: TYPE_NORMAL
- en: From your Terminal or console application, create a new directory called `~/projects/go-programming-cookbook/chapter11/docker` and
    navigate to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see a file called `go.mod` that contains the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Copy the tests from `~/projects/go-programming-cookbook-original/chapter11/docker`,
    or use this as an opportunity to write some of your own code!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a file called `dockerfile` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file called `setup.sh` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file called `version.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Create a new directory named `example` and navigate to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a `main.go` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Navigate back to the starting directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'You should now see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The `go.mod` file may be updated and the `go.sum` file should now be present
    in the top-level recipe directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you copied or wrote your own tests, go up one directory and run `go test`.
    Ensure that all the tests pass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe created a script that compiles the Go binary for the Linux architecture
    and sets a variety of private variables in `main.go`. These variables are used
    to return version information on a version endpoint. Once the binary is compiled,
    a Docker container is created that contains the binary. This allows us to use
    very small container images since the Go runtime is self-contained in the binary.
    We then run the container while exposing the port on which the container is listening
    for HTTP traffic. Lastly, we `curl` the port on localhost and see our version
    information returned.
  prefs: []
  type: TYPE_NORMAL
- en: Orchestration and deployment strategies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker makes orchestration and deployment much simpler. In this recipe, we'll
    set up a connection to MongoDB and then insert a document and query it all from
    Docker containers. This recipe will set up the same environment as the *Using
    NoSQL with MongoDB and mgo* recipe from [Chapter 6](43f5a4d2-84e0-47a5-ada0-3b221d08ddd3.xhtml),
    *All about Databases and Storage*, but will run the application and environment
    inside of containers and will use Docker Compose to orchestrate and connect to
    them.
  prefs: []
  type: TYPE_NORMAL
- en: This can later be used in conjunction with Docker Swarm, an integrated Docker
    tool that allows you to manage a cluster, create and deploy nodes that can be
    scaled up or down easily, and manage load balancing ([https://docs.docker.com/engine/swarm/](https://docs.docker.com/engine/swarm/)).
    Another good example of container orchestration is Kubernetes ([https://kubernetes.io/](https://kubernetes.io/)),
    a container orchestration framework written by Google using the Go programming
    language.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following steps cover writing and running your application:'
  prefs: []
  type: TYPE_NORMAL
- en: From your Terminal or console application, create a new directory called `~/projects/go-programming-cookbook/chapter11/orchestrate` and
    navigate to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see a file called `go.mod` that contains the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Copy the tests from `~/projects/go-programming-cookbook-original/chapter11/orchestrate`,
    or use this as an opportunity to write some of your own code!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a file called `Dockerfile` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file called `docker-compose.yml` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file called `config.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file called `exec.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Create a new directory named `example` and navigate to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a `main.go` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Navigate back to the starting directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the `go mod vendor` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the `docker-compose up -d` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the `docker logs orchestrate_app_1` command. You should now see the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The `go.mod` file may be updated and the `go.sum` file should now be present
    in the top-level recipe directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you copied or wrote your own tests, go up one directory and run `go test`.
    Ensure that all the tests pass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This configuration is good for local development. Once the `docker-compose up`
    command is run, the local directory is rebuilt, Docker establishes a connection
    to a MongoDB instance using the latest version, and begins operating against it.
    This recipe uses the go mod vendor for dependency management. As a result, we
    disable the `go mod cache` and tell the `go build` command to use the vendor directory
    we created.
  prefs: []
  type: TYPE_NORMAL
- en: This can provide a good baseline when starting on apps that require connections
    to external services; all of the recipes in [Chapter 6](43f5a4d2-84e0-47a5-ada0-3b221d08ddd3.xhtml),
    *All about Databases and Storage*, can make use of this approach rather than creating
    a local instance of the database. For production, you probably won't want to run
    your data storage behind a Docker container, but you'll also generally have static
    host names for configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a variety of ways to monitor Go applications. One of the easiest ways
    is to set up Prometheus, a monitoring application written in Go ([https://prometheus.io](https://prometheus.io)).
    This is an application that polls an endpoint based on your configuration file
    and collects a lot of information about your app, including the number of Goroutines,
    memory usage, and much more. This app will use the techniques from the previous
    recipe to set up a Docker environment to host Prometheus and connect to it.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following steps cover writing and running your application:'
  prefs: []
  type: TYPE_NORMAL
- en: From your Terminal or console application, create a new directory called `~/projects/go-programming-cookbook/chapter11/monitoring` and
    navigate to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see a file called `go.mod` that contains the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Copy the tests from `~/projects/go-programming-cookbook-original/chapter11/monitoring`,
    or use this as an opportunity to write some of your own code!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a file called `Dockerfile` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file called `docker-compose.yml` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file called `main.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file called `prometheus.yml` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Run the `go mod vendor` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the `docker-compose up`  command. You should now see the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The `go.mod` file may be updated and the `go.sum` file should now be present
    in the top-level recipe directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate your browser to `http://localhost:9090/`. You should see a variety
    of metrics related to your app!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe creates a simple handler in Go that exports stats about the running
    application to prometheus using the prometheus go client. We connect our application
    to a prometheus server that is running in docker and handle the network connection
    and startup using docker-compose. Settings for how often to collect data, which
    port the application is serving on, and the name of the app are all specified
    in the `prometheus.yml` file. Once both containers start, the prometheus server
    begins harvesting and monitoring the app on the specified port. It also exposes
    a web interface which we visit in the browser to see more information about our
    app.
  prefs: []
  type: TYPE_NORMAL
- en: The Prometheus client handler will return a variety of stats about your application
    to a Prometheus server. This allows you to point multiple Prometheus servers at
    an app, without the need to reconfigure or deploy the app. Most of these stats
    are generic and beneficial for things such as detecting memory leaks. A lot of
    other solutions require you to periodically send information to a server instead.
    The next recipe, *Collecting metrics*, will demonstrate how to ship custom metrics
    to the Prometheus server.
  prefs: []
  type: TYPE_NORMAL
- en: Collecting metrics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to general information about your app, it can be helpful to emit
    metrics that are app-specific. For example, we might want to collect timing data
    or keep track of the number of times an event occurs.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will use the `github.com/rcrowley/go-metrics` package to collect
    metrics and expose them via an endpoint. There are various exporter tools that
    you can use to export metrics to places such as Prometheus and InfluxDB, which
    are also written in Go.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Configure your environment according to these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Refer to the *Technical requirements* section in this chapter for steps to configure
    your environment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the `go get github.com/rcrowley/go-metrics` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These steps cover writing and running your application:'
  prefs: []
  type: TYPE_NORMAL
- en: From your Terminal or console application, create a new directory called `~/projects/go-programming-cookbook/chapter11/metrics` and
    navigate to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see a file called `go.mod` that contains the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Copy the tests from `~/projects/go-programming-cookbook-original/chapter11/metrics`,
    or use this as an opportunity to write some of your own code!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a file called `handler.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file called `report.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Create a new directory named `example` and navigate to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a file named `main.go` :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Run `go run main.go`. Alternatively, you may also run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'You should now see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following commands from a separate shell:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Try hitting all the endpoints a few more times to see how they change.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `go.mod` file may be updated and the `go.sum` file should now be present
    in the top-level recipe directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you copied or wrote your own tests, go up one directory and run `go test`.
    Ensure that all the tests pass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `gometrics` keeps all of your metrics in a registry. Once it's set up, you
    can use any of the metric emit options, such as `counter` or `timer`, and it will
    store this update in the registry. There are multiple exporters that will export
    metrics to third-party tools. In our case, we set up a handler that emits all
    the metrics in JSON format.
  prefs: []
  type: TYPE_NORMAL
- en: We set up three handlers—one that increments a counter, one that records the
    time to exit the handler, and one that prints a report (while also incrementing
    an additional counter). The `GetOrRegister` functions are useful for atomically
    getting or creating a metric emitter if it doesn't currently exist in a thread-safe
    way. Alternatively, you can register everything once in advance.
  prefs: []
  type: TYPE_NORMAL
