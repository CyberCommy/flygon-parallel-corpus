- en: Distributed Systems
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, application-level parallelism is not enough, and things that seem
    simple in development can become complex during deployment. Distributed systems
    provide a number of challenges that aren't found when developing on a single machine.
    These applications have added complexity for things such as monitoring, writing
    applications that require strong consistency guarantees, and service discovery.
    In addition, you must always be mindful of single points of failure, such as a
    database, otherwise your distributed applications can fail when this single component
    fails.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will explore methods of managing distributed data, orchestration,
    containerization, metrics, and monitoring. These will become part of your toolbox
    for writing and maintaining microservices and large distributed applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Using service discovery with Consul
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing basic consensus using Raft
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using containerization with Docker
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Orchestration and deployment strategies
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring applications
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collecting metrics
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To follow all the recipes in this chapter, configure your environment according
    to these steps:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Download and install Go 1.12.6 or above on your operating system from [https://golang.org/doc/install](https://golang.org/doc/install).
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install Consul from [https://www.consul.io/intro/getting-started/install.html](https://www.consul.io/intro/getting-started/install.html).
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open a Terminal or console application and create and navigate to a project
    directory such as `~/projects/go-programming-cookbook`. All the code will be run
    and modified from this directory.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Clone the latest code into `~/projects/go-programming-cookbook-original` and
    (optionally) work from that directory rather than typing in the examples manually:'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Using service discovery with Consul
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When using the microservice approach to applications, you end up with a lot
    of servers listening on a variety of IPs, domains, and ports. These IP addresses
    will vary by environment (staging versus production), and it can be tricky to
    keep them static for configuration between services. You also want to know when
    a machine or service is down or unreachable due to a network partition. A network
    partition occurs when two parts of the network cannot reach each other. For example,
    if a switch fails between two data centers, then the services within one datacenter
    cannot reach services in the other datacenter. Consul is a tool that provides
    a lot of functionality, but here, we'll explore registering services with Consul
    and querying them from our other services.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These steps cover writing and running your application:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: From your Terminal or console application, create a new directory called `~/projects/go-programming-cookbook/chapter11/discovery` and
    navigate to it.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the following command:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You should see a file called `go.mod` that contains the following content:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Copy the tests from `~/projects/go-programming-cookbook-original/chapter11/discovery`,
    or use this as an opportunity to write some of your own code!
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a file called `client.go` with the following content:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Create a file called `operations.go` with the following content:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Create a file called `exec.go` with the following content:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Create a new directory named `example` and navigate to it.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a file named `main.go` with the following content:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Start Consul in a separate Terminal using the `consul agent -dev -node=localhost`
    command.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the `go run main.go` command.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You may also run the following commands:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You should see the following output:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `go.mod` file may be updated and the `go.sum` file should now be present
    in the top-level recipe directory.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you copied or wrote your own tests, go up one directory and run `go test`.
    Ensure that all the tests pass.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Consul provides a robust Go API library. It can feel daunting when you're starting
    for the first time, but this recipe shows how you might approach wrapping it.
    Configuring Consul further is beyond the scope of this recipe; this shows the
    basics of registering a service and querying for other services when given a key
    and tag.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: It would be possible to use this to register new microservices at startup time,
    query for all dependent services, and deregister at shutdown. You may also want
    to cache this information so that you're not hitting Consul for every request,
    but this recipe provides the basic tools that you can expand upon. The Consul
    agent also makes these repeated requests fast and efficient ([https://www.consul.io/intro/getting-started/agent.html](https://www.consul.io/intro/getting-started/agent.html)).
    Once you've s
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Implementing basic consensus using Raft
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Raft is a consensus algorithm. It allows distributed systems to keep a shared
    and managed state ([https://raft.github.io/](https://raft.github.io/)). Setting
    up a Raft system is complex in many ways – for one, you need consensus for an
    election to occur and succeed. This can be difficult to bootstrap when you're
    working with multiple nodes and can be difficult to get started. It is possible
    to run a basic cluster on a single node/leader. However, if you want redundancy,
    at least three nodes are needed to prevent data loss in the case of a single node
    failure. This concept is known as quorum, where you must maintain (*n*/2)+1 available
    nodes to ensure new logs can be committed to the Raft cluster. Basically, if you
    can maintain quorum, the cluster remains healthy and usable.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: This recipe implements a basic in-memory Raft cluster, constructs a state machine
    that can transition between certain allowed states, and connects the distributed
    state machine to a web handler that can trigger the transition. This can be useful
    when you're implementing the base finite state machine interface that Raft requires,
    or when testing. This recipe uses [https://github.com/hashicorp/raft](https://github.com/hashicorp/raft)
    for the base Raft implementation.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following steps cover writing and running your application:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: From your Terminal or console application, create a new directory called `~/projects/go-programming-cookbook/chapter11/consensus` and
    navigate to it.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the following command:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You should see a file called `go.mod` that contains the following content:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Copy the tests from `~/projects/go-programming-cookbook-original/chapter11/consensus`,
    or use this as an opportunity to write some of your own code!
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a file called `state.go` with the following content:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Create a file called `raftset.go` with the following content:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Create a file called `config.go` with the following content:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Create a file called `fsm.go` with the following content:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Create a file called `handler.go` with the following content:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Create a new directory named `example` and navigate to it.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a file named `main.go` with the following content:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Run the `go run main.go` command. Alternatively, you may also run the following
    commands:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You should now see the following output:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In a separate Terminal, run the following command:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `go.mod` file may be updated and the `go.sum` file should now be present
    in the top-level recipe directory.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you copied or wrote your own tests, go up one directory and run `go test`.
    Ensure that all the tests pass.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When the application starts, we initialize multiple Raft objects. These each
    have their own address and transport. The `InmemTransport{}` function also provides
    a method for connecting the other transports, and is called `Connect()`. Once
    these connections are established, the Raft cluster holds an election. When communicating
    in a Raft cluster, clients must communicate with the leader. In our case, one
    handler can talk to all of the nodes, so the handler is responsible for having
    the `Raft` leader's `call Apply()` object. This in turn runs `apply()` on all
    of the other nodes.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: The `InmemTransport{}` function simplifies the election and bootstrapping process
    by allowing everything to reside in memory. In practice, this isn't very helpful,
    except for testing and proof of concepts, since Goroutines can freely access shared
    memory. A more production-minded implementation would use something like an HTTP
    Transport such that service instances can communicate across machines. This may
    require some additional bookkeeping or service discovery as the service instances
    have to listen and serve as well as have the ability discover and establish connections
    with one another.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: Using containerization with Docker
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker is a container technology for packaging and shipping applications. Other
    advantages include portability, since a container will run the same way regardless
    of the host OS. It provides a lot of the advantages of a virtual machine, but
    in a more lightweight container. It's possible to limit the resource consumption
    of individual containers and sandbox your environment. It can be extremely useful
    to have a common environment for your applications locally and when you ship your
    code to production. Docker is written in Go and is open source, so it's simple
    to take advantage of the client and libraries. This recipe will set up a Docker
    container for a basic Go application, store some version information about the
    container, and demonstrate hitting a handler from a Docker endpoint.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Configure your environment according to these steps:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: Refer to the *Technical requirements* section in this chapter for steps to configure
    your environment.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install Docker from [https://docs.docker.com/install](https://docs.docker.com/install/).
    This will also include Docker Compose.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These steps cover writing and running your application:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: From your Terminal or console application, create a new directory called `~/projects/go-programming-cookbook/chapter11/docker` and
    navigate to it.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the following command:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'You should see a file called `go.mod` that contains the following content:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Copy the tests from `~/projects/go-programming-cookbook-original/chapter11/docker`,
    or use this as an opportunity to write some of your own code!
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a file called `dockerfile` with the following content:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Create a file called `setup.sh` with the following content:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Create a file called `version.go` with the following content:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Create a new directory named `example` and navigate to it.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a `main.go` file with the following content:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Navigate back to the starting directory.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the following command:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'You should now see the following output:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Run the following commands:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `go.mod` file may be updated and the `go.sum` file should now be present
    in the top-level recipe directory.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you copied or wrote your own tests, go up one directory and run `go test`.
    Ensure that all the tests pass.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe created a script that compiles the Go binary for the Linux architecture
    and sets a variety of private variables in `main.go`. These variables are used
    to return version information on a version endpoint. Once the binary is compiled,
    a Docker container is created that contains the binary. This allows us to use
    very small container images since the Go runtime is self-contained in the binary.
    We then run the container while exposing the port on which the container is listening
    for HTTP traffic. Lastly, we `curl` the port on localhost and see our version
    information returned.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Orchestration and deployment strategies
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker makes orchestration and deployment much simpler. In this recipe, we'll
    set up a connection to MongoDB and then insert a document and query it all from
    Docker containers. This recipe will set up the same environment as the *Using
    NoSQL with MongoDB and mgo* recipe from [Chapter 6](43f5a4d2-84e0-47a5-ada0-3b221d08ddd3.xhtml),
    *All about Databases and Storage*, but will run the application and environment
    inside of containers and will use Docker Compose to orchestrate and connect to
    them.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: This can later be used in conjunction with Docker Swarm, an integrated Docker
    tool that allows you to manage a cluster, create and deploy nodes that can be
    scaled up or down easily, and manage load balancing ([https://docs.docker.com/engine/swarm/](https://docs.docker.com/engine/swarm/)).
    Another good example of container orchestration is Kubernetes ([https://kubernetes.io/](https://kubernetes.io/)),
    a container orchestration framework written by Google using the Go programming
    language.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following steps cover writing and running your application:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: From your Terminal or console application, create a new directory called `~/projects/go-programming-cookbook/chapter11/orchestrate` and
    navigate to it.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the following command:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'You should see a file called `go.mod` that contains the following content:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Copy the tests from `~/projects/go-programming-cookbook-original/chapter11/orchestrate`,
    or use this as an opportunity to write some of your own code!
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a file called `Dockerfile` with the following content:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Create a file called `docker-compose.yml` with the following content:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Create a file called `config.go` with the following content:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Create a file called `exec.go` with the following content:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Create a new directory named `example` and navigate to it.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a `main.go` file with the following content:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Navigate back to the starting directory.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the `go mod vendor` command.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the `docker-compose up -d` command.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the `docker logs orchestrate_app_1` command. You should now see the following
    output:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The `go.mod` file may be updated and the `go.sum` file should now be present
    in the top-level recipe directory.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you copied or wrote your own tests, go up one directory and run `go test`.
    Ensure that all the tests pass.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This configuration is good for local development. Once the `docker-compose up`
    command is run, the local directory is rebuilt, Docker establishes a connection
    to a MongoDB instance using the latest version, and begins operating against it.
    This recipe uses the go mod vendor for dependency management. As a result, we
    disable the `go mod cache` and tell the `go build` command to use the vendor directory
    we created.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: This can provide a good baseline when starting on apps that require connections
    to external services; all of the recipes in [Chapter 6](43f5a4d2-84e0-47a5-ada0-3b221d08ddd3.xhtml),
    *All about Databases and Storage*, can make use of this approach rather than creating
    a local instance of the database. For production, you probably won't want to run
    your data storage behind a Docker container, but you'll also generally have static
    host names for configuration.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring applications
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a variety of ways to monitor Go applications. One of the easiest ways
    is to set up Prometheus, a monitoring application written in Go ([https://prometheus.io](https://prometheus.io)).
    This is an application that polls an endpoint based on your configuration file
    and collects a lot of information about your app, including the number of Goroutines,
    memory usage, and much more. This app will use the techniques from the previous
    recipe to set up a Docker environment to host Prometheus and connect to it.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following steps cover writing and running your application:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: From your Terminal or console application, create a new directory called `~/projects/go-programming-cookbook/chapter11/monitoring` and
    navigate to it.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the following command:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'You should see a file called `go.mod` that contains the following content:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Copy the tests from `~/projects/go-programming-cookbook-original/chapter11/monitoring`,
    or use this as an opportunity to write some of your own code!
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a file called `Dockerfile` with the following content:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Create a file called `docker-compose.yml` with the following content:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Create a file called `main.go` with the following content:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Create a file called `prometheus.yml` with the following content:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Run the `go mod vendor` command.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the `docker-compose up`  command. You should now see the following output:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The `go.mod` file may be updated and the `go.sum` file should now be present
    in the top-level recipe directory.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate your browser to `http://localhost:9090/`. You should see a variety
    of metrics related to your app!
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe creates a simple handler in Go that exports stats about the running
    application to prometheus using the prometheus go client. We connect our application
    to a prometheus server that is running in docker and handle the network connection
    and startup using docker-compose. Settings for how often to collect data, which
    port the application is serving on, and the name of the app are all specified
    in the `prometheus.yml` file. Once both containers start, the prometheus server
    begins harvesting and monitoring the app on the specified port. It also exposes
    a web interface which we visit in the browser to see more information about our
    app.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: The Prometheus client handler will return a variety of stats about your application
    to a Prometheus server. This allows you to point multiple Prometheus servers at
    an app, without the need to reconfigure or deploy the app. Most of these stats
    are generic and beneficial for things such as detecting memory leaks. A lot of
    other solutions require you to periodically send information to a server instead.
    The next recipe, *Collecting metrics*, will demonstrate how to ship custom metrics
    to the Prometheus server.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Collecting metrics
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to general information about your app, it can be helpful to emit
    metrics that are app-specific. For example, we might want to collect timing data
    or keep track of the number of times an event occurs.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will use the `github.com/rcrowley/go-metrics` package to collect
    metrics and expose them via an endpoint. There are various exporter tools that
    you can use to export metrics to places such as Prometheus and InfluxDB, which
    are also written in Go.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Configure your environment according to these steps:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: Refer to the *Technical requirements* section in this chapter for steps to configure
    your environment.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the `go get github.com/rcrowley/go-metrics` command.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These steps cover writing and running your application:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: From your Terminal or console application, create a new directory called `~/projects/go-programming-cookbook/chapter11/metrics` and
    navigate to it.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the following command:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'You should see a file called `go.mod` that contains the following content:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Copy the tests from `~/projects/go-programming-cookbook-original/chapter11/metrics`,
    or use this as an opportunity to write some of your own code!
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a file called `handler.go` with the following content:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`handler.go`的文件，内容如下：
- en: '[PRE46]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Create a file called `report.go` with the following content:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`report.go`的文件，内容如下：
- en: '[PRE47]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Create a new directory named `example` and navigate to it.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`example`的新目录并进入。
- en: 'Create a file named `main.go` :'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`main.go`的文件：
- en: '[PRE48]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Run `go run main.go`. Alternatively, you may also run the following command:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`go run main.go`。或者，您也可以运行以下命令：
- en: '[PRE49]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'You should now see the following output:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您应该看到以下输出：
- en: '[PRE50]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Run the following commands from a separate shell:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从单独的shell中运行以下命令：
- en: '[PRE51]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Try hitting all the endpoints a few more times to see how they change.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试多次访问所有端点，看看它们如何变化。
- en: The `go.mod` file may be updated and the `go.sum` file should now be present
    in the top-level recipe directory.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`go.mod`文件可能会被更新，而`go.sum`文件现在应该存在于顶层的配方目录中。'
- en: If you copied or wrote your own tests, go up one directory and run `go test`.
    Ensure that all the tests pass.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您复制或编写了自己的测试，请返回上一级目录并运行`go test`。确保所有测试都通过。
- en: How it works...
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `gometrics` keeps all of your metrics in a registry. Once it's set up, you
    can use any of the metric emit options, such as `counter` or `timer`, and it will
    store this update in the registry. There are multiple exporters that will export
    metrics to third-party tools. In our case, we set up a handler that emits all
    the metrics in JSON format.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`gometrics`将所有度量标准保存在注册表中。一旦设置好，您可以使用任何度量发射选项，比如`counter`或`timer`，它将把这个更新存储在注册表中。有多个导出器将度量标准导出到第三方工具。在我们的情况下，我们设置了一个以JSON格式发射所有度量标准的处理程序。'
- en: We set up three handlers—one that increments a counter, one that records the
    time to exit the handler, and one that prints a report (while also incrementing
    an additional counter). The `GetOrRegister` functions are useful for atomically
    getting or creating a metric emitter if it doesn't currently exist in a thread-safe
    way. Alternatively, you can register everything once in advance.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设置了三个处理程序——一个用于增加计数器，一个用于记录退出处理程序的时间，以及一个用于打印报告（同时还增加了一个额外的计数器）。`GetOrRegister`函数对于以线程安全的方式原子地获取或创建度量发射器非常有用。或者，您可以提前注册所有内容。
