- en: Service Registry and Discovery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After handling core concerns in our distributed system through a gateway, we
    will now talk about service registry and discovery in this chapter. The more services
    we have, the more complicated it becomes to handle them using only predefined
    ports. In the previous chapter, we saw the gateway interacting with the service
    registry, which maintains the service location in a database. The client request
    is dispatched to service based on the information contained in a database. In
    this chapter, we will see how the service registry is populated, and in what ways
    services, clients, and gateways interact with it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will commence by understanding service discovery, how the service
    registry is maintained dynamically, different ways of registering services in
    the registry, and pros and cons of each way. We will understand the end to end
    process of maintaining a service registry and how a service is discovered based
    on a registry. We will see the available options for designing a service registry,
    get acquainted with each of the steps, and then we will design our dynamic service
    registry using the best practices available. In this chapter, we will look at
    the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to the service registry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The what, why, and how of service registry and discovery
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Service discovery patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Service registry patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Service registry and discovery options
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to choose the service registry and discovery
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to the service registry
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will see the need for service discovery and the need for
    the service registry and try to understand the difference between service registry
    and discovery. We already have some of our shopping cart microservices set ups,
    but with core dependency on a network location that was static. Our code reads
    a value from a configuration file and on any change in the location of a service,
    we update it in our configurations. In the practical world, it is very difficult
    to maintain this as service instances are dynamically assigned locations. Moreover,
    service instances change dynamically based on the needs for autoscaling, failure
    handling, and updating process that is abstracted from a consumer client in the
    microservice world. Hence, clients need to use a more enhanced service discovery
    mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: 'Service discovery can be defined as:'
  prefs: []
  type: TYPE_NORMAL
- en: A complete end to end process of registering services in a central place (API
    Gateway or database) and reaching out to targeted service of consuming via looking
    up in the service registry.
  prefs: []
  type: TYPE_NORMAL
- en: In the microservices world, different microservices are typically distributed
    in a **platform as a service** (**PaaS**) environment. The infrastructure is typically
    immutable as we usually have containers or immutable VM images. Services can usually
    scale up or down based on traffic and pre-fixed metrics. As everything is constantly
    dynamic, the exact address of the service may not be known until the service is
    ready to be used and deployed. This dynamic nature is one of the most important
    aspects to be handled in the microservice world. A logical and obvious solution
    is persisting these endpoints somewhere and that itself is the basis of a service
    registry. In this approach, each microservice registers with a central broker
    (the component that we saw in [Chapter 5](720d1d4e-1795-457c-903e-65c5a5fb5433.xhtml),
    *Understanding API Gateway*) and it provides all details about that microservice,
    such as the endpoint address, the contract details, the communication protocol,
    and so on. Consuming services usually query the broker to find the available location
    of a service at that point and then invoke it based on the location retrieved.
    Some of the commonly available options for this are Zookeeper, Consul, Netflix
    Eureka, and Kubernetes, which we will look at in much more detail soon.
  prefs: []
  type: TYPE_NORMAL
- en: What, why, and how of service registry and discovery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After looking briefly at service registry, we will understand the what, why,
    and how of service registry and discovery in this section. From understanding
    the need for service discovery, we will then understand the process and components
    involved in that process.
  prefs: []
  type: TYPE_NORMAL
- en: The why of service registry and discovery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whatever container technology we go for, in production environments we will
    always have three four hosts and a number of containers inside each. In general,
    the way we distribute our services across all available hosts is totally dynamic
    and dependent on business capabilities, and can change at any point in time as
    hosts are just servers and they are not going to last forever. This is where service
    discovery and registry comes in. We need an external system that solves the limitations
    of a common web server, keeps an eye on all the services at all times, and maintains
    a combination of IP and port so that clients can seamlessly route to those service
    providers.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand the need for service registry and discovery, we will take a classic
    example. Let''s say we have 10 instances of our product catalog microservice running
    on an arbitrary number of nodes. Now in order to have a resilient system, someone
    needs to keep track of those 10 nodes because whenever there would be a need to
    consume a product catalog service, at least one proper IP address or hostname
    should be available or else the consumer must query a central place where it can
    find the location of the product-catalog service. This approach very much resembles
    a DNS, the difference being that this is just for internal services to service
    communication. Most microservice-based architecture is dynamically moving. Services
    scale up and down based on development, depreciation, and traffic. Whenever a
    service endpoint changes, the registry needs to know about the change. The service
    registry is all about this: maintaining all information about how to reach every
    service.'
  prefs: []
  type: TYPE_NORMAL
- en: There are lots of available tools in the market to solve this problem and as
    an architect, we need to decide the right tool based on our need. We need to consider
    factors such as how much automation can be done and how much control we have over
    the tool. There exist right from low-level tools such as Consul, to high-level
    tools such as Kubernetes or Docker swarm,which take care of advanced requirements
    such as load balancing containers and container scheduling capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: How service registry and discovery?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Today, three basic approaches are prevalent for service registry and discovery:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first rudimentary and preliminary approach is using existing DNS infrastructure.
    A well deployed DNS would be highly available and distributed. Examples of this
    approach include `httpd`, `confd`, `systemd`, and so on. In this approach, standard
    DNS libraries are used as registrar clients. Each microservice entry receives
    an entry in a DNS zone file and does a DNS lookup to connect to or locate a microservice.
    Another approach is using proxies such as NGINX, which periodically poll DNS for
    service discovery. The advantage of this approach includes being language agnostic:
    it works with any language with minimal or zero changes. However, it has several
    flaws, such as DNS does not provide a real-time view, managing new zone files
    on service registrations and deregistrations, and maintaining the high availability
    of this component for resiliency.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second approach is more dynamic and more suitable to microservices using
    consistent key-value data stores such as Hashicorp's Consul, Apache Zookeeper,
    etcd, and so on. These tools are highly distributed systems. With the key-value
    store and sidecar pattern, it solves all the issues that we had while using DNS.
    This approach is meant to be completely transparent to any developer writing the
    code. A developer can write code in any programming language and not think of
    how microservices interact with other services. It has several limitations, such
    as sidecar being limited to service discovery of hosts and not more granular routes.
    It also adds extra latency by introducing an extra hop for every microservice.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The final approach for service discovery is adopting ready-made frameworks such
    as Netflix Eureka, specially designed and optimized for service discovery. This
    model exposes functionality directly to end developers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whichever tool we select, each of the microservices needs a central client to
    communicate for service discovery, whose main function is to allow service registration
    and resolution. Whenever a service starts, the service discovery uses the registration
    process to signal its availability to other services. Once available, other services
    use service resolution to locate the service on the network. The two processes
    involved around are as follows.
  prefs: []
  type: TYPE_NORMAL
- en: Service registration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: On startup and shutdown, the service registers itself, or through third-party
    registration, a service registration client also sends constant heartbeats so
    that the client knows that the service is alive. A heartbeat is a message that
    is sent periodically to other services to say that the service is running and
    alive. They should be sent asynchronously or implemented as event-based, in order
    to avoid performance issues. Other approaches include polling the service constantly.
    The service registration stage is also responsible for setting the contract of
    the service, that is, service name, protocol, version, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Service resolution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is the process of returning the network address of microservices. An ideal
    service discovery client has several critical features such as caching, failover,
    and load balancing. In order to avoid network latency when caching services, addresses
    are critical. The cache layer subscribes to updates from service discovery to
    ensure that it is always up to date. A typical microservice implementation layer
    is deployed in various locations for high availability; the service resolution
    client must know how to return the address of service instances based on load
    availability and other factors.
  prefs: []
  type: TYPE_NORMAL
- en: The what of service registry and discovery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will look at the what of service registry and discovery.
    We will see all aspects involved in a service registry and have a look at all
    the possible options involved regarding maintaining it.
  prefs: []
  type: TYPE_NORMAL
- en: Maintaining service registry
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will see how a consumer ultimately finds a service provider.
    We will see all available approaches and look at the pros and cons of each option:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Updation through sockets**: Regular polling soon becomes a problem as consumers
    are least concerned with registering themselves with the discovery service, and
    it also becomes painful for the discovery service to maintain a list of the consumers.
    A better solution would be for the client to open up a socket connection with
    the discovery service and continuously get an up-to-date list of all the service
    changes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Service discovery as a proxy**: This is more of a server-side implementation
    where logic for routing is present in the discovery service, making it not necessary
    for the clients to maintain any lists. They simply make outbound requests to the
    discovery service, which forwards the request to an appropriate service provider
    and returns the results to the providers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Timely health checks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two approaches for performing timely health checks for discovery.
    One method states that services should send a message to a centralized discovery
    service, whereas another method has the discovery service sending requests to
    the service providers:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Service polls registrar: **In this approach, a service provider actively
    sends messages at a predefined regular interval to the registrar discovery service.
    The discovery service keeps track of all the last time requests were received
    and considers a service provider dead if a certain time threshold has not been
    made.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Registrar polls service: **This is the approach where a central discovery
    service sends requests to the service providers. However, a shortcoming to this
    approach is that a centralized discovery service may get exhausted with the task
    of making so many outbound requests. Furthermore, if service providers disappear,
    then the registrar has to make a lot of failed health lookups, which would be
    network waste.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Service discovery patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Discovery is the counterpart of service registry from the view of clients.
    Whenever a client wants to access a service, it must find details about the service,
    where it is located, and other contract information. This is typically done using
    two approaches, client-side discovery and server-side discovery. Service discovery
    can be briefly summarized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Microservices or consumers don't have any prior knowledge about the physical
    location of other services. They don't know when a service goes down or another
    node of the service is going up.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Services broadcast their existence and disappearance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Services are able to other service instances based on other broadcasted metadata.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instance failures are detected and any request to that failed node is prevented
    and is made invalid.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Service discovery is not a single point of failure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we will both look at the patterns of service discovery and
    understand the pros and cons of each pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Client-side discovery pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While using a client-side pattern, it is the client's or the gateway's duty
    to determine the location of a network of available service instances and also
    to load balance the requests among them. The client queries a service registry,
    which is nothing but a set of available service instances, stores its response,
    and then routes the request according to the location address in that response.
    The client uses some famous load balancing algorithms to choose one of the service
    instances and make a request to that instance. The physical network location of
    that service instance is registered with the registry whenever the service starts
    and deregistered when the service goes down. The service instance registration
    is refreshed using a heartbeat mechanism or polling or through sockets for real-time
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: '**Advantages:**'
  prefs: []
  type: TYPE_NORMAL
- en: The pattern is pretty static except for the service registry, so it is a lot
    easier to maintain
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As the client is aware of the service instance, the client can make intelligent,
    application-specific, situation-dependent load balancing decisions such as constantly
    using a hash
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pain areas:**'
  prefs: []
  type: TYPE_NORMAL
- en: The client is tightly coupled to the service registry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There would be a need to implement client-side service discovery in every programming
    language and framework that is used by a service client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A famous tool for client-side registration process is Netflix Eureka. It provides
    a REST API for managing service instance registrations and for querying available
    instances. A full list of APIs and available options can be found at [https://github.com/Netflix/eureka/wiki/Eureka-REST-operations](https://github.com/Netflix/eureka/wiki/Eureka-REST-operations),
    which has all available operations that can be done.
  prefs: []
  type: TYPE_NORMAL
- en: Server-side discovery pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The counter approach to this is having a separate component for a registry,
    which is the server-side discovery pattern. In this approach, a client makes a
    request to the service through a load balancer in between. The load balancer then
    queries the service registry and routes each request to an available service instance
    to provide a service response to the consumer. A classic example of such an approach
    is an inbuilt AWS load balancer. An Amazon **Elastic Load Balancer** (**ELB**)
    is commonly used to handle the huge external traffic from the internet and load
    balance among the incoming traffic, but the use of an ELB goes way beyond this.
    An ELB can also be used to load balance traffic internal traffic to the VM. When
    a client makes a request to an ELB through its DNS, the ELB load balances the
    traffic among a set of registered EC2 instances or containers.
  prefs: []
  type: TYPE_NORMAL
- en: One of the approaches in maintaining server-side discovery is using a proxy
    on each host. This proxy plays the role of server-side discovery load balancer.
    A proxy transparently forwards the request to available service instances running
    anywhere on that server. Kubernetes runs on a similar approach. Some of the available
    tools are NGINX and Consul templates. These tools configure reverse proxying and
    reload NGINX or HAProxy servers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Advantages of the server-side discovery pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: Simpler code for client-side discovery on the server side as we don't have to
    write code for discovery in each service and it is totally abstracted from the
    client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functionalities such as load balancing are taken care of through this approach
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Disadvantages of the server-side discovery pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: The router is yet another component that needs to be maintained on the server.
    If the environment is clustered, then it needs to be replicated everywhere.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unless the router is a TCP router, the router should have support for protocols
    such as HTTP, RPC, and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It needs more network hops compared to client-side discovery.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s look at both approaches in this diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a55feab0-118a-4e26-af33-9a55c0dccbd8.png)'
  prefs: []
  type: TYPE_IMG
- en: Client-side vs server-side service discovery
  prefs: []
  type: TYPE_NORMAL
- en: Service registry patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the key aspects of discovering services in a distributed system is service
    registry. The service registry is just a database that has all the network locations
    of service instances. As it contains crucial information, it must be highly available
    and stay up to date on an efficient system. Based on the system clients (in our
    case, API Gateway), we can even cache network locations obtained from the service
    registry. However, it must be updated on a daily basis, otherwise clients won't
    be able to discover service instances and communicate per service. A service registry,
    in order to be highly available, consists of clusters where a replication protocol
    is used to maintain consistency. The service registry saves the metadata of microservice
    instances, which includes things such as actual locations, host ports, communication
    protocol, and so on. Startup and shutdown processes of microservices are constantly
    monitored. In this section, we will look at service registry and common service
    registration options. We will look at the pros and cons of each approach.
  prefs: []
  type: TYPE_NORMAL
- en: All service instances must register and deregister from the central registry
    in order to have a fault tolerant system. There are various ways to handle this
    registration and deregistration process. One option is the service registry providing
    endpoints and the service instance registers itself, that is, self-registration.
    Another option is using some other system components to manage the registration
    of service instances. Let's dive deep into both of these patterns to understand
    them in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Self-registration pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While using the self-registration process, a service instance itself is responsible
    for registering and deregistering within the service registry. Also, the service
    instance must constantly send heartbeat requests in order to let the registry
    know the status of the service. If the registry doesn't receive heartbeats, the
    registry can assume that the service no longer exists and can deregister or stop
    listening for that service. The self-registration pattern forces microservices
    to communicate with the service registry by themselves. Whenever a service goes
    up or down, it has to communicate with the registry to inform it of its status.
    Microservices deal with single concerns, so introducing yet another concern everywhere
    might be an extra burden and may seem an anti-pattern; however, it has the added
    advantage that a service maintains its own state model, knowing the current state,
    that is, **STARTING**, **AVAILABLE**, **SHUTDOWN**, without being dependent on
    any other third-party services.
  prefs: []
  type: TYPE_NORMAL
- en: A well-known example of a self-registration process is the Netflix OSS Eureka
    client. The Eureka client handles all aspects of client registration and deregistration.
    We will see a detailed implementation of Eureka in a later section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Disadvantages of the self-registration pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: The service is coupled to the service registry. It must constantly communicate
    with the server to tell it about the service's state.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Service registry logic is not centralized and must be implemented in every language
    we have in the ecosystem.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Third-party registration pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When using a third-party registration process and service instances, microservices
    stick to the principle of single responsibility and are no longer responsible
    for registering themselves with the service registry. Instead, we introduce a
    new component in the system, *service registrar*, which handles the responsibility
    of maintaining service registry. The service registrar, in order to maintain the
    registry, keeps track of instances either by polling the environment or by subscribing
    to startup and shutdown events. Whenever it notices a newly available service,
    it registers the instance with the registry. Likewise, if it fails to receive
    health checks, then it deregisters that service from the registry. Unlike the
    self-registration pattern, the microservice code is far less complex as it is
    not responsible for registering itself, but it has drawbacks too. If the registrar
    is not selected carefully, it becomes yet another component that has to be installed,
    configured, maintained, and highly available since it is a critical component
    of the system. Third-party registration is normally the preferred choice in industry
    as it automatically manages the registry. Additional data required for the registry
    can be provided in the form of policies or contracts, which can be updated in
    the database. Tools such as Apache Zookeeper or Netflix Eureka, in combination
    with others, are widely used.
  prefs: []
  type: TYPE_NORMAL
- en: Third-party registration has various advantages. Say a service goes down, a
    third-party registrar can take appropriate action such as providing safe fallbacks,
    triggering a self-repair mechanism, and so on. If there is heavy traffic on a
    service, the registry process can automatically add a new endpoint by requesting
    a new instantiation of that microservice. These health checks performed on services
    can help in auto-deregistering to stop the failure cascading to the entire system.
    A well-known example is Registrator, which we are going to see later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the famous available examples of third-party registration patterns
    include:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Netflix Prana: **Outsourced by Netflix, Netflix OSS Prana is especially for
    non-JVM languages. It is an implementation of the sidecar pattern, which runs
    side by side with service instances and exposes them over HTTP. Prana registers
    and deregisters service instances over HTTP with Netflix Eureka.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Built-in components such as the ELB:** Most deployment environments have
    inbuilt components. EC2 instances created automatically through scaling are automatically
    registered to the ELB. Similarly, Kubernetes services are automatically registered
    and made available for discovery (we will look at this in more detail in the scaling
    section of [Chapter 10](ccd4f3a3-dcbc-4cf9-ae9b-3e1b55206644.xhtml), *Hardening
    Your Application*).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Advantages of the third-party registration pattern are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The code is less complex as each service doesn't have to write code for registering
    and deregistering itself
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The central registrar also contains code for performing health checks and this
    doesn't need to be replicated everywhere
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Disadvantages of third-party registration pattern are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Unless it is provided by a service discovery tool, it is yet another component
    that needs to be maintained and made highly available
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Service registry and discovery options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will look at some of the commonly available options in the
    market for service discovery and registry. Options range right from low-level
    solutions providing a high degree of control to the architect (etcd from CoreOS
    and Consul from HashiCorp) to high-end solutions providing container scheduling
    solutions (Kubernetes from Google, Docker swarm, and so on). In this section,
    we will understand various options and look at the pros and cons of each.
  prefs: []
  type: TYPE_NORMAL
- en: Eureka
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Eureka is a service registry and discovery framework outsourced by Netflix with
    a need for primary usage of locating services for the purpose of load balancing
    and failover for any middle-tier servers. In this section, we will look at service
    discovery and registry using Eureka.
  prefs: []
  type: TYPE_NORMAL
- en: 'The overall Eureka architecture consists of two components: the Eureka server
    and client. The Eureka server is a standalone server application that is responsible
    for:'
  prefs: []
  type: TYPE_NORMAL
- en: Managing a registry of service instances
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing the means to register any service, deregister any microservice, and
    query instances as part of service discovery
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Registry propagation of instances to other Eureka servers and clients provides
    a mechanism similar to heartbeats to constantly monitor services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Eureka client is a part of an ecosystem and has the following responsibilities:'
  prefs: []
  type: TYPE_NORMAL
- en: Register and unregister bound microservices with the Eureka server on processes
    such as startup, shutdown, and so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keep the connection alive with the Eureka server by constantly sending heartbeats
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retrieve other service instance information, cache it, and update it on a daily
    basis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will be using the following terminology in Eureka frequently:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Eureka server** | It is the discovery server. It has a registry of all
    services with their current state by means of registering and deregistering any
    service, and APIs for discovering any service. |'
  prefs: []
  type: TYPE_TB
- en: '| **Eureka service** | Anything that is found in Eureka service registry and
    anything that is registered for others and is meant to be discovered. Each service
    has a logical identifier that can refer to the instance ID of that application
    and it is called the VIP or service ID. |'
  prefs: []
  type: TYPE_TB
- en: '| **Eureka instance** | Any application that registers with the Eureka server
    so that it can be discovered by other services. |'
  prefs: []
  type: TYPE_TB
- en: '| **Eureka client** | Any microservice application that can register and discover
    any microservice. |'
  prefs: []
  type: TYPE_TB
- en: In this section, we will set up the Eureka server register a sample microservice
    with the Eureka server, and find the location of that microservice in our other
    microservice. So, let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the Eureka server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Eureka server is a Netflix OSS product and a service discovery pattern implementation
    where every microservice is registered and a client looks up on the server to
    get dependent microservices. A Eureka server runs on the JVM platform, so we will
    directly use an available template.
  prefs: []
  type: TYPE_NORMAL
- en: To run a Eureka server, you will need Java 8 and Maven set up.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the steps to set up Eureka server:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to the `eureka` folder inside the extracted source code for this chapter.
    You will find a ready-to-use Java project for Eureka server named `euraka-server`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside the root directory, open up the Terminal and run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You should see dependencies getting installed and at the end, you will get a
    message confirming a successful build and that your `target` folder is generated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `target` folder, inside which you will be able to see Eureka server
    `.jar` file (`demo-service-discovery-0.0.1-SNAPSHOT.jar`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open up a Terminal and hit the following command. You should see your server
    startup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The output for the preceding command is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/752cdf41-7b07-4a3f-952b-110ad52026d5.png)'
  prefs: []
  type: TYPE_IMG
- en: Starting up Spring Eureka server
  prefs: []
  type: TYPE_NORMAL
- en: 'Hit `http://localhost:9091/` and you should be able to see Eureka server started.
    You should see something like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/27767950-8a0c-4e57-94c0-57b1596cbd3b.png)'
  prefs: []
  type: TYPE_IMG
- en: Spring Eureka server
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have started Eureka server, we will register our services with it.
    We will be able to see our service under Instances currently registered with Eureka
    after registering with Eureka server.
  prefs: []
  type: TYPE_NORMAL
- en: Registering with Eureka server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that our Eureka server is up and running and ready to accept the registration
    of microservices, we will register a demo microservice and see it on the Eureka
    dashboard. You can follow along with the source code attached to the source files
    (`first-microservice-register`). Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Pull up our first microservice code from [Chapter 2](c1987454-3c62-4e25-abf5-28a9abf833e8.xhtml), *Gearing
    up for the Journey*. We will be using the `eureka-js-client` ([https://www.npmjs.com/package/eureka-js-client](https://www.npmjs.com/package/eureka-js-client))
    module in the project, which is a JavaScript implementation of Netflix OSS Eureka.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open up a Terminal and install `eureka-js-client`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Next, we will install the types of `eureka-js-client` to be used in our TypeScript
    project. At the time of writing, the types available in the `DefinitelyTyped`
    repository were not up to date. So, we will now write our custom types.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a folder, `custom_types`, and inside it add `eureka-js-client.d.ts`.
    Copy the contents either from attached source code or from my gist at [https://gist.github.com/insanityrules/7461385aa561db5835c5c35279eb12bf](https://gist.github.com/insanityrules/7461385aa561db5835c5c35279eb12bf)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we will register our Express app with Eureka. Open `Application.ts` and
    inside it write the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'What did we just do? Have a look at the following points for a better understanding:'
  prefs: []
  type: TYPE_NORMAL
- en: We registered our app instance named `hello-world-chapter-6` with a key, `myvip`,
    and data center, `myOwn`, with Eureka
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: We provided `statusPageURL` and `IpAddress`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We added Eureka information with host, port, and service paths
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The full list of configurations can be found here ([https://www.npmjs.com/package/eureka-js-client](https://www.npmjs.com/package/eureka-js-client))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, we will start with the client; just add the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Our register is all ready; we can now start our service with `npm start`. Now,
    navigate to `localhost:9091` to check the server instances:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6c317192-06e7-4606-b2f3-5b3c95d2ba77.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Service registered in Eureka server
  prefs: []
  type: TYPE_NORMAL
- en: 'Our service will constantly fetch service registries and send heartbeats to
    tell that service is running. Let''s stop and deregister the service when our
    microservice is killed. Just add the following code to `Application.ts`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now that our service is synced with Eureka, in the next section we will see
    how to discover a service.
  prefs: []
  type: TYPE_NORMAL
- en: Discovering with Eureka server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will discover our register service in another microservice.
    We will be getting a response from that service without knowing the service address
    or hardcoding the location anywhere. Copy the structure of `first-microservice`
    from [Chapter 2](c1987454-3c62-4e25-abf5-28a9abf833e8.xhtml), *Gearing up for
    the Journey*. As we will need Eureka client everywhere, we will create `EurekaService.ts`.
    You can find the full source code in the `eureka/eureka-service-discovery/src`
    folder of the project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the steps to discover our registered service:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file called `EurekaService.ts`, and create static methods for initializing
    clients:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In `Application.ts`, start your client and add stop processes as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In our `HelloWorld.ts` we will call the service from `first-microservice-register`
    and fetch its response. We won''t hardcode locations. Add the following LOCs in
    `HelloWorld.ts`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we selected the protocol, port, and IP address from our service
    registry.
  prefs: []
  type: TYPE_NORMAL
- en: Run your application and you will be able to see the response from `first-microservice-register`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Key points for Eureka
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After this exercise on Eureka service registry and discovery, let''s take a
    look at some salient points on Eureka:'
  prefs: []
  type: TYPE_NORMAL
- en: Eureka consists of a server component and a client-side component. The server
    component is the one that all microservices communicate with. They register their
    availability by constantly sending out heartbeats. The consuming services also
    use server components for discovering services.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a microservice is bootstrapped using our Eureka service, it reaches out
    to the Eureka server and broadcasts its existence with contract details. After
    registration, the service endpoint sends heartbeat requests every 30 seconds to
    renew its lease period. If a service endpoint fails to do so a certain number
    of times, it gets taken out of service registry.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can enable debug logs by setting either of the following options:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NODE_DEBUG=request`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '``client.logger.level(''debug'');``'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The client constantly fetches the registry at every predefined point and caches
    it. Hence, when it wants to discover another service, the extra network hop is
    prevented.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Eureka client provides a list of available services with options to provide
    them by hostname or instance name.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Eureka server is zone aware. Zone information can be supplied when registering
    a service in the same zone. To further introduce a load balancer, we can use a
    resilient client ([https://www.npmjs.com/package/resilient](https://www.npmjs.com/package/resilient))
    which is equivalent to Netflix Ribbon.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has options for a health check, status page, registering, deregistering,
    maximum number of retries, and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Eureka is a classic example of a server-side client registry and self-registration
    option.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consul
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another option we have for service registry and discovery is HashiCorp Consul
    ([https://www.consul.io/](https://www.consul.io/)). Consul is an open source implementation
    of a distributed key-value store and other service discovery and registry features.
    It can run either as the master or as an agent. The master orchestrates the whole
    network and maintains the registry. A Consul agent acts as a proxy to the master
    and forwards all requests to the master. In this section, we will understand service
    discovery and registry using Consul.
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we will do service registry and discovery using Consul. We
    will look at ways of self-registering/deregistering using Consul. Let's get started;
    we'll be using Linux OS in this exercise.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the Consul server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s take a look at the steps to set up Consul sever:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Setting up Consul server is pretty straightforward. Just download the executable
    from [https://www.consul.io/downloads.html](https://www.consul.io/downloads.html) and
    unzip it to the location of your choice. After unzipping, hit the following command
    to make it available to the binary executions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Test your Consul installation by opening up a Terminal and typing `consul -v`;
    you should be able to see version 1.0.7.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, we will open Consul UI terminal. Consul comes by default with a UI dashboard;
    to start the Consul terminal with a UI dashboard, hit the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Open up `localhost:8500`; you should be able to see something like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f80d0fe1-1a21-440a-931b-9d1e4cb7e0af.png)'
  prefs: []
  type: TYPE_IMG
- en: Consul server
  prefs: []
  type: TYPE_NORMAL
- en: We have successfully started Consul server; next we will register some services
    inside Consul.
  prefs: []
  type: TYPE_NORMAL
- en: Talking with Consul server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Like Eureka, Consul has also exposed some REST endpoints that can be used to
    interact with the Consul server. In this section, we will see how to:'
  prefs: []
  type: TYPE_NORMAL
- en: Register a service instance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Send heartbeats and do a health check
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deregister a service instance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Subscribe to updates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Registering a service instance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start by taking clones of the first microservice from [Chapter 2](c1987454-3c62-4e25-abf5-28a9abf833e8.xhtml),
    *Gearing up for the Journey*. You can find the entire source code in the `chapter-6/consul/consul-producer`
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open up the Terminal and hit the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now in `Application.ts`, we will initialize our Consul client. Write this code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will register our service with Consul:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the program and you should be able to see successful logs. You will be
    able to see output similar to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f200cf26-9b2b-44ce-9acf-950dc9d45f23.png)'
  prefs: []
  type: TYPE_IMG
- en: Service registry with Consul and Consul dashboard
  prefs: []
  type: TYPE_NORMAL
- en: Sending heartbeats and doing a health check
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we will add one scheduler that constantly sends heartbeats to tell our
    Consul server that it is active. In the same code as the previous exercise, just
    add the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: What did we do?
  prefs: []
  type: TYPE_NORMAL
- en: Every five seconds, we send out heartbeats to Consul, to ensure that our service
    with the `CONSUL_ID` that we generated is active.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Periodic heartbeats are sent out to make sure that Consul knows that our service
    is active and it doesn't disconnect our service. Earlier, we kept TTL values in
    our settings as 10 seconds, which means that if Consul server doesn't receive
    heartbeats after 10 seconds, it will assume that the service is down.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A higher TTL value means that Consul will know very late when the application
    is dead or unable to serve requests. A short TTL value, on the other hand, means
    that we are sending too much data over the network, which can flood Consul, so
    this value should be selected carefully.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You always need to pass a unique ID, so in this exercise, we generated UUID
    and mixed host and port with it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The health check API is available over HTTP. All we have to do is hit the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Deregistering an application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will deregister our application whenever the server terminates
    or someone kills the server. This ensures that Consul doesn''t have to wait until
    the TTL period to actually know that the service is down. Simply add the following
    lines of code in `Application.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Now, when you check Consul server when you gracefully kill the application,
    you won't be able to see our Consul producer registered.
  prefs: []
  type: TYPE_NORMAL
- en: Subscribing to updates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Just like Eureka, we will constantly get the Consul registry, so whenever we
    need to communicate to another registry we won''t need to make another registry
    call, as the registry is already cached at our end. Consul takes care of this
    by providing a feature called `watch`. Responses to a service will have an index
    number, which can be used for future requests to compare. They are nothing but
    a cursor to keep track of where we have left off. Let''s add watchers to our application:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new watcher by adding the following code. Here, we have created a
    watcher on the service named `data` in Consul:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will add a change event on our watcher, so whenever it receives new
    updates we will just cache the registry for our service data. Create one array
    and persist the entries that it receives while watching:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Add an error handler:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s it. Now, run the program using `npm start` and register another service
    with the name `data` (the steps are the same as registering a new service). Then,
    you should be able to see output like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: That's it. We just did service registry and interacted with Eureka server. Whenever
    the data service goes down, this value will also be dynamically updated. Now that
    we have the dynamic address and port, we can use it anytime to discover the location
    of services.
  prefs: []
  type: TYPE_NORMAL
- en: Key points for Consul
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After completing the exercise on Consul, let''s now summarize the key points
    for Consul:'
  prefs: []
  type: TYPE_NORMAL
- en: Consul works on the gossip protocol (tell everyone who is alive and has been
    in constant touch with others) to form dynamic clusters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It has an inbuilt key-value store that not only stores data, but is also used
    to register watches, which can be used for a number of tasks, such as notifying
    others about data changes, running different health checks, and some custom commands
    depending on use cases.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Service discovery is embedded, so we do not need any third-party tools. It has
    inbuilt features such as health checks, watches, and so on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It has out-of-the-box support for multiple data centers, and the gossip protocol
    works across all data centers as well. It can also be used to discover information
    about other deployed services and nodes on which they reside. It has inbuilt health
    checks, TTLs, and custom command support where we can add our own middleware functions.
  prefs: []
  type: TYPE_NORMAL
- en: Registrator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While Consul seems a great alternative for service discovery and registration,
    there is quite a big drawback where each service needs to maintain their startup
    and shutdown codes, which seems like quite a lot of duplicated code everywhere.
    We need a tool that auto-registers a service to the Consul server based on listening
    to their startup and shutdown events. Registrator is just the right tool for that.
    It is a service registry bridge for Docker with options to plug adapters as per
    the need. Registrator automatically registers and deregisters services when they
    come online or go dead. It has pluggable options for service registries, meaning
    it can be used with various other service registry clients such as Consul, etcd,
    and more.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s get started with using Registrator. In this exercise, we will use service
    registry for Consul, plug it into Registrator, and then start a service and let
    Registrator autoregister it in Consul server:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, start the Consul server using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will pull the Docker image of Registrator and specify to plug it into
    Consul registry, so that when Registrator finds any services they will be automatically
    added to Consul server. Open up the Terminal and hit the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We run the container in detached mode and name it. We run in host network mode
    to make sure that Registrator has the hostname and IP address of the actual host.
    The last line is our registry URI. Registrator needs to be run on every host;
    for our exercise, we went ahead with a single host. To start Registrator, the
    essential configuration that we need to provide is how to connect to a registry,
    in this case Consul.
  prefs: []
  type: TYPE_NORMAL
- en: 'To ensure that Registrator has successfully started, hit the following command
    and you should be able to see logs streaming and the message `Listening for Docker
    events ...`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will just start any service using Docker and our service will be automatically
    registered with Consul. Open up Terminal and just start our service from [Chapter
    2](https://cdp.packtpub.com/typescript_microservices/wp-admin/post.php?post=121&action=edit#post_48), *Gearing
    up for the Journey* in Docker using the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Or you can just start any service, let''s say `redis`, by simply typing the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Open up Consul user interface and you will be able to see our service registered
    there.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Here, we efficiently implemented auto discovery using Registrator and Consul.
    It works as auto discovery.
  prefs: []
  type: TYPE_NORMAL
- en: Key points for Registrator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s discuss the key points for Registrator:'
  prefs: []
  type: TYPE_NORMAL
- en: Registrator acts as an auto-discovery agent, where it listens for Docker startup
    and shutdown events.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Registrator has the following inbuilt options taken from their GitHub `Readme`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Using Registrator with Consul gives a very viable solution for our service discovery
    and registry without duplicating code everywhere.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: These are some of the widely used solutions available right now. Besides these,
    there are other solutions too such as ELB, Kubernetes, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we saw service registry and discovery using Eureka, Consul,
    and Registrator and saw some other options based on our service discovery and
    registry patterns. In the next section, we will understand how to choose the correct
    service registry and discovery solution.
  prefs: []
  type: TYPE_NORMAL
- en: How to choose service registry and discovery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Previously, we saw various service registry and discovery options based on
    service registry and discovery patterns. So, the next question that arises is
    pretty obvious, which solution to go for? That question is pretty wide and it
    actually depends on the requirements. Your requirements are most likely to be
    different than most other companies, so rather than going with the most common
    solutions, a better approach would be to evaluate your requirements and devise
    your own strategy based on that. To devise a strategy, the following questions
    should be properly evaluated:'
  prefs: []
  type: TYPE_NORMAL
- en: Is the system going to be coded in only one language or is there a polyglot
    environment? Writing the same code in different languages is pretty cumbersome.
    In this case, Registrator is pretty helpful.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is there a legacy system involved? Are both the systems going to run for some
    time? In this case, self registering solutions can be pretty helpful.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How simplified is service discovery process? Is there going to be a gateway?
    Is there going to be a load balancer in between?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is there a requirement for an API for the service discovery? Do individual microservices
    need to communicate with other microservices? In this case, HTTP or DNS-based
    solutions are pretty helpful.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Are service discovery solutions embedded in each microservice or is there a
    need to embed the logic centrally?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do we need separate application configurations or can we store these in key-value
    stores such as Redis or MongoDB?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the deployment strategy? Is there a need for deployment strategies such
    as the blue-green strategy? Based on appropriate service discovery, solutions
    should be selected.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Blue-green is a deployment strategy where the downtime is reduced by running
    two identical production environments named blue and green.
  prefs: []
  type: TYPE_NORMAL
- en: How is the system going to run? Are there going to be multiple data centers?
    If that's the case, then running Eureka is most appropriate.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do you maintain your acknowledgments? How is the access control list maintained?
    If that's the case, then Consul has inbuilt solutions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How much support is there? Is it open sourced and does it have widespread support?
    Are there too many issues?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How are auto-scaling solutions decided?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Based on these questions, and after properly evaluating them, we can decide
    on appropriate solutions. After carefully evaluating these, we can select any
    solution. Given here is a list of careful points that need to be taken care of
    while selecting any solution.
  prefs: []
  type: TYPE_NORMAL
- en: Take care of these points while selecting either Consul or Eureka.
  prefs: []
  type: TYPE_NORMAL
- en: If you select Consul
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While Consul has lots of benefits, the following points need to be taken care
    of while selecting Consul:'
  prefs: []
  type: TYPE_NORMAL
- en: Clients need to write their own load-balancing, timeout, and retry logic. To
    avoid writing complete logic, we can utilize the following `node` module at [https://www.npmjs.com/package/resilient](https://www.npmjs.com/package/resilient).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The client needs to implement fetch logic, and cache, and Consul failure handling
    individually unless we utilized Registrator. These needs to be written separately
    for each language in the ecosystem.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Priorities cannot be set for servers; custom logic needs to be written.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you select Eureka
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While Eureka has many added advantages, the following points need to be taken
    care of while selecting Eureka:'
  prefs: []
  type: TYPE_NORMAL
- en: Clients have to add their own load-balancing, timeout, and retry logic, so we
    need to integrate it with external tools such as Netflix Ribbon.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documentation is very poor. If you have a non-JVM environment, you won't be
    able to use Eureka. Eureka server needs to be run on JVM platforms. Documentation
    is very vague for non-JVM clients.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Web UI is extremely dull and noninformative.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we learned about major takeaways while selecting Eureka or
    Consul. We summarized major points to actually help us decide a service registry
    and discovery solution.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about service registry and discovery. We went through
    the when, what, and why of service discovery and understood the service registry
    and discovery patterns. We saw the pros and cons of each pattern and the available
    options for each of them. Then, we implemented service discovery and registry
    using Eureka, Consul, and service registrator. In the end, we saw how to choose
    a service discovery and registry solution and the key takeaways while selecting
    Eureka or Consul.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will see service state and how microservices communicate
    with each other. We will learn more design patterns such as event-based communication
    and the publisher-subscriber pattern, see a service bus in action, share database
    dependencies, and so on. We will learn about stateful and stateless services with
    some live examples.
  prefs: []
  type: TYPE_NORMAL
