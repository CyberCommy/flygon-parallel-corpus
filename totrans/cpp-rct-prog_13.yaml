- en: Advanced Streams and Handling Errors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this book, we have covered quite a bit of ground in explaining modern C++
    techniques and the `RxCpp` library. We started with a set of prerequisites for
    undertaking reactive programming using C++. The first six chapters were mostly
    about prerequisites and getting acclimatized with the features that are embodied
    in functional reactive programming in general, and in the `RxCpp` library in particular.
    We have used the term functional reactive programming in a loose sense—we are
    leveraging functional programming techniques to write reactive programs. Some
    purists differ from us on this. They do not consider the Rx family of libraries
    to be a complete implementation of functional reactive programming. The biggest
    shift a programmer has to undergo is the mindset change to adopt a declarative
    programming paradigm.
  prefs: []
  type: TYPE_NORMAL
- en: Traditionally, we design elaborate data structures, and write algorithms upon
    those data structures, to write our programs. This is appropriate for programs
    that manipulate data that exists in space. When time comes into the picture, asynchrony
    is a natural consequence. In reactive programming, we reduce complicated data
    structures into Streams of data and place Operators in the Streams, before getting
    notified to perform some action, based on the notification. We have seen how this
    can simplify programming in the case of GUI programs, web programs, and console
    applications, using the C++ programming language.
  prefs: []
  type: TYPE_NORMAL
- en: In our examples, we have omitted exception handling (and error handling) logic
    in reactive programs. This was on purpose, so as to focus on the core reactive
    elements and their interactions. Now that we have covered all of the essentials,
    and beyond, we will focus on exception handling in a reactive program. Before
    getting into error and exception handling, we will cover the characteristics of
    reactive systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: A short recap of the characteristics of a reactive system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RxCpp`—error handling Operators'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scheduling and error handling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Event-based Stream handling—some examples
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A short recap of the characteristics of a reactive system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We now live in a world that warrants increased scalability and rapid response.
    The concept of reactive programming is a need that has arisen to meet the demands
    of high availability, scalability, and quick response. As per the reactive manifesto
    ([https://www.reactivemanifesto.org/](https://www.reactivemanifesto.org/)), reactive
    systems are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Responsive**: The ability (of a system) to complete assigned tasks within
    a timeframe. Responsiveness also means that the problems are detected quickly,
    and dealt with effectively. The key point is the consistent behavior of a system.
    Consistency helps the users to build confidence in the system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resilient**: In the context of changes in behavior, the ability of a system
    to defend itself from failure is resilience. It is correlated to the responsiveness,
    as the consistency guarantees error handling as well. Resilience is achieved by
    the isolation and containment of components subject to error situation and protecting
    the system from failures.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Elastic**: Elasticity is the ability of a system to adapt to workload changes
    by reallocating the resources required in an automated manner. In turn, at each
    instance of time, the resources in use match the demand as closely as possible.
    reactive systems achieve elasticity by providing relevant live performance measures.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Message-driven**: Reactive systems achieve isolation and the loose coupling
    of systems through the ability to communicate through the asynchronous message-passing
    mechanism. With the use of a message queue, the interdependent processing of different
    modules and commands is made possible in reactive systems. Non-blocking communication
    through message-driven architecture allows the recipients to consume resources
    only when active:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram from the Reactive Manifesto demonstrates how all the
    pillars of a reactive system are inter-related:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/007efdbe-d0c0-4004-a4dc-a228e3667bc0.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The reactive systems are made composable by applying these principles at all
    levels of their construction.
  prefs: []
  type: TYPE_NORMAL
- en: The focus of this chapter will be the resilient properties of the reactive systems,
    through explaining advanced Streams and error handling.
  prefs: []
  type: TYPE_NORMAL
- en: RxCpp error and exception handling Operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a real-world scenario, no system is perfect. As we discussed in the previous
    section, resilience is one of the qualities of a reactive system. How a system
    handles errors and exceptions decides the future of that system. Early detection
    and the seamless handling of errors makes a system consistent and responsive.
    Compared to imperative programming approaches, the reactive programming model
    helps the user to handle errors separately, as and when the system detects an
    error or throws an exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will take a look at how to handle exceptions and errors
    by using the `RxCpp` library. There are a variety of `RxCpp` Operators that can
    be used to react to `on_error` notifications from Observables. For instance, we
    might:'
  prefs: []
  type: TYPE_NORMAL
- en: Handle the error by exiting from the sequence gracefully
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ignore the error and switch over to a backup Observable to continue the sequence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ignore the error and emit a default value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ignore the error and immediately try to restart the failed Observable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ignore the error and try to restart the failed Observable, after some back-off
    interval
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The exception handling is possible because the `observer<>` contains three
    methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`on_next`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`on_completed`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`on_error`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `on_error` method is meant to handle exceptions when they occur, or when
    they are thrown by `observable<>` or any Operators in the composition chain. The
    examples so far have ignored the error handling aspects of the system. The prototypes
    for the observer methods are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`void observer::on_next(T);`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void observer::on_error(std::exception_ptr);`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void observer::on_completed();`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executing an action on an error
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When an error occurs, we need to handle it in a graceful manner. So far, in
    the `RxCpp` programs discussed in this book, the programs were written to only
    handle the `on_next` and `on_completed` scenarios in the `subscribe` method. The
    `subscribe` function has one more method, where it can accept a Lambda function
    for `on_error` scenarios as well. Let''s look at a simple example to understand
    how to use the error handler inside the `subscribe` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'With the second Lambda, the function passed into the `subscribe` function invokes
    the action that is needed when there is an error. The output of the code will
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous code, the error is appended to the Observable Stream to kick-start
    the discussion on exception/error handling at the subscriber end. Let''s see how
    an exception can be propagated to the subscriber level, through the Observable
    Streams:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous code creates an instance of a `subject<T>` class, which we covered
    in chapter-10, Creating Custom Operators in RxCpp. We subscribe to the Observable
    part of the `subject<T>`. We also retrieve the subscriber handle to emit the value
    or exception into the Stream:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `on_next()` function emits a new value to the subscriber, and the function
    will be called multiple times. The `on_next()` function won't be called once `on_completed()`
    or `on_error()` is being invoked on the Stream. The `on_completed()` function
    notifies the subscriber that the Observable has finished sending **push-based
    notifications**. The Observable will not call this function if it has already
    invoked the `on_error()` function. Finally, the `on_error()` function notifies
    the subscriber that the Observable has experienced an error condition, and if
    the Observable calls this function, it will not call `on_next()` or `on_completed()`
    thereafter.
  prefs: []
  type: TYPE_NORMAL
- en: Resuming when an error occurs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An error occurrence breaks the sequence flow of a standard reactive Stream.
    The `RxCpp` library provides mechanisms to invoke actions on an error occurrence,
    also. Sometimes, however, users want to resume the sequence with a default option;
    that''s what `on_error_resume_next()` does:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The Observable Operator `on_error_resume_next()` gets executed if there is
    an error in the Stream. In this code, a new Stream is returned from the Lambda
    given as a parameter, to resume the sequence with this new Stream. This way, the
    error propagation can be prevented, by continuing with a meaningful sequence.
    The output of the previous program will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'As well as resuming with another sequence, the sequence can be resumed with
    a default single item. In the previous example, replace the invocation of the
    Operator `on_error_resume_next()` with the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The output, after replacing the code, will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look at the marble diagram that depicts the `on_error_resume_next()`
    Operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7123ec6c-c8c7-49c9-84f3-7f38fc0d0c9e.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In short, the `on_error_resume_next()` function returns an Observable instance
    when it encounters an error from a particular Observable. The Stream switches
    to the new Observable and resumes the execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `on_error_resume_next()` Operator comes in handy in many places, where
    the user needs to continue the propagation of an error. For instance, between
    the creation and subscription of the Streams, there is a chance that the Streams
    may undergo different transformations and reductions. Also, as explained in [Chapter
    9](b59c2b7c-703d-4c1d-8c31-db01506c57db.xhtml), *Reactive GUI Programming Using
    Qt/C++*, the user-defined Operators can be constructed by composing existing `RxCpp`
    Operators. In such cases, it is intended to use the `on_error_resume_next()` Operator
    at every single stage of aggregation and transformations to translate the exceptions/errors
    till the subscription phase. Similar to the default value or a sequence emitted
    from this Operator, the error itself can be retransmitted, to resume the flow
    of the error until the `subscribe()` Operator''s error handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The previous fragment of code explains how the `on_error_resume_next()` Operator
    can be used to translate the error.
  prefs: []
  type: TYPE_NORMAL
- en: Retry when an error occurs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In many situations, the normal sequence may be broken by a temporary failure
    on the producer end. In such scenarios, it is worthwhile to have an option to
    wait until the anomalies are fixed at the producer end, to continue the normal
    execution flow. `RxCpp` gives the users a very similar option to retry when an
    error occurs. The retry option is best suited to when you are expecting the sequence
    to encounter predictable issues.
  prefs: []
  type: TYPE_NORMAL
- en: 'The retry Operator responds to an `on_error` notification from the source Observable
    by resubscribing to the source Observable, instead of passing that call through
    to its Observers. This gives the source another opportunity to complete its sequence
    without an error. The retry always passes `on_next` notifications through to its
    Observers, even from sequences that terminate with an error; this can cause duplicate
    emissions. The following marble diagram will explain this further:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fd2af045-7ce4-4ec5-b231-048b028fc152.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here is an example that uses the `retry()` Operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In this example, as the error is appended to the Stream using the `concat()`
    Operator, we are using the `take()` Operator to avoid the infinite wait. Because
    of the infinite wait on the retry Operator in error scenarios, the subscriber
    can omit error handler used in the subscription.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of this code will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Most of the time, it is better to use a fixed number of retries for error situations.
    This can be achieved by another overload of `retry()`, which accepts the number
    of retries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The output for the code will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Cleanup with the finally() Operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, in this chapter, we have seen that the source sequence in `RxCpp` can
    terminate gracefully after throwing exceptions. The `finally()` Operator is useful
    when we are using external resources, or when there''s a need to free up some
    resources allocated in some other parts of the program. As we know, there are
    millions of lines of code that are already written for building various systems
    in C++, and it is highly likely that we need to handle resource management when
    using legacy external dependencies. This is a place where `finally()` comes in
    handy in `RxCpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `finally()` Operator adds a new action at the end of the newly created
    Observables. The output of the previous program is as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: It can be seen, in the previous output, that if the source generates an error,
    the final action is still called.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we remove the error concatenated to the source Observable, the output of
    the program will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Schedulers and error handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We already covered the topic of scheduling in Chapter 8, *RxCpp – the Key Elements*.
    The schedulers in `RxCpp` queue up the values and deliver the queued up value using
    the supplied coordination. The coordination could be the current execution thread,
    the `RxCpp` run loop, the `RxCpp` event loop, or a new thread. The execution of
    scheduler operations can be achieved by using the `RxCpp` Operators, such as `observe_on()`
    or `subscribe_on()`. These Operators accept the chosen coordination as an argument.
    By default, the `RxCpp` library is single-threaded, so it does the scheduler operations.
    The user has to explicitly choose the thread in which execution happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We have created an Observable Stream using the range Operator, and have concatenated
    an error, to demonstrate how basic error handling works with schedulers in `RxCpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Using `observe_on()` Operator, the Observable stream is subscribed into a new
    thread as its coordination. Similar to the previous examples that we discussed
    in this chapter, the error handler is provided with the `subscribe()` function.
    The output of the code may look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s take a look at another example, with two subscribers from the same
    source. The subscribers are supposed to be notified in two different threads:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'A `subject` instance is created to add data to the source Stream; from the
    subject instance, one subscriber and two Observables are created, to be scheduled
    in two distinct threads:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Two Lambda functions are declared for use with the `subscribe` method, with
    mutex synchronization applied on the usage of the `std::ostream` Operator to get
    an organized output. Placing a mutex around `std::ostream` will avoid interleaved
    output if the thread switch happens during a write to the Stream:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Two Observables are retrieved from the source Stream, and they are scheduled
    to observe from separate threads. For the `observable1` function object, a separate
    C++ thread is specified as the coordinator by passing `rxcpp::synchronize_new_thread()`
    as the argument in the `observe_on()` Operator. For the `observable2` object,
    an event loop is specified as the coordinator by passing `rxcpp::observe_on_event_loop()`
    into `observe_on()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the values are added to the Observable Stream by using a subject instance,
    and an exception is passed into the Stream explicitly, to understand the behavior
    of the schedulers and error handlers together. The output of this code will be
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This example demonstrates how the propagation of data happens through two separate
    Observables that are subscribed to a common source. The error generated in the
    source is received and handled by both of the Observables at the corresponding
    `subscribe` functions. Now, let''s look at an example that demonstrates how error
    handling can be done in scheduling by using the `subscribe_on()` Operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Two random Observable Streams on integers are created using the `rxcpp::observable<>::range()`
    Operator and one Stream is concatenated with an error, to explain error handling
    in scheduled sequences:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The Observable Streams are queued up in different threads using the `subscribe_on()`
    Operator. The first Stream is scheduled with an event loop as its coordination
    thread, and the second Stream is scheduled on another C++ thread:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding Lambda functions are defined to be passed as parameters in place
    of the `on_next` and `on_error` functions of the `subscribe` method. These Lambda
    functions are protected with mutex, to synchronize the calls to the `std::ostream`
    Operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the code will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Event-based Stream handling – some examples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we conclude this chapter, let's discuss a few examples, to work with
    an event-based system using the `RxCpp` library. In this section, we'll discuss
    two examples to understand how effective the `RxCpp` library can be in meeting
    real-world scenarios. We will discuss an example that demonstrates the aggregation
    of data in a Stream and application event handling, using the `RxCpp` library.
  prefs: []
  type: TYPE_NORMAL
- en: Aggregation based on Stream data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, the Stream item is a user-defined type to represent an employee,
    and the code is intended to group the input Stream based on the roles and salaries
    of employees:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The libraries and namespaces required in the code are included, and the data
    structure to represent an `Employee` is declared. The `Employee` type is a simple
    structure, with data items such as `name`, `role`, and `salary`. We have treated
    the salary field as an integer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `main()` function, a subject is created with the `Employee` type, to
    create a **hot Observable**. The grouping based on the role is performed and salary attribute
    is extracted out of it to form the resultant Grouped Observable. The `RxCpp` Operator, `group_by()`,
    returns an Observable that emits `grouped_observables`, each of which corresponds
    to a unique key/value pair from the source Observable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the resultant Observable combines the Observable based on the role, and
    the reduction, based on the salary, is performed by appending the minimum salary,
    maximum salary, and average salary per role. The Lambda inside of the `zip()`
    will be called when all of the arguments have a value. In this case, when a particular
    group completes, all of the values inside of the Streams corresponding to the
    group are reduced to single tuples. Therefore, the Lambda is called only once
    per role, with the final value of each iteration. Here, the map applied on the
    `group` returns an Observable of the type `observable<tuple<string, int, int,
    int, double>>`, and the `merge()` Operator returns an Observable of the type `tuple<string,
    int, int, int, double>`. The merge is applied to prevent the data loss, as the
    grouped Observable is hot, and the data will be lost if it is not subscribed to
    immediately:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The resultant Observable is then subscribed, in order to display the aggregated
    result of input data. The data items are supplied to the subscriber from the `employees`
    subject, created with the `Employees` type. In the previous code, the source can
    be anything, such as data retrieved from the network or from another thread. Since
    the Observable created here is a hot Observable, aggregation is performed based
    on the latest data supplied.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of this code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Application event handling example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following example is a command-line program, with events to represent the
    primitive operations of a user interface application. We will be handling the
    flow of these events by using `RxCpp` in this program. This has been done for
    brevity in the code listing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The libraries and namespaces that we will be using in the programs are included
    (declared) here. Also, an enum `AppEvent` is declared, to represent some of the
    basic event states that can be emitted from a generic system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous code, we created an Observable Stream of the `AppEvent` type
    by mapping some of the keyboard entries to defined event types. The infinite loop
    inside the Lambda of the `create` function represents the `event_loop/message_loop`
    in GUI applications. To convert the cold Observable into a hot Observable and
    to get the connections to the source independent of following subscriptions, the
    `publish()` Operator is used. It also helps to send the most recent value in the
    Stream to new subscribers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Some filtered Observables are defined, to handle the use cases of the reactive
    system. The `appActive` is an Observable contains `AppEvent::Active` event filtered
    from source Observable whenever it is available in the source stream. Similarly, `appInactive` Observable
    contains `AppEvent::Inactive ` events, `appData` Observable contains `AppEvent::Data` events,
    and `appClose` Observable extracts `AppEvent::Close` events out of the source
    Observable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The program will start accepting the data Streams from the events Observable
    only if the `AppEvent::Active` event is received. Then, the application will accept
    the data until `AppEvent::Inactive` is received. The event flow will resume only
    when the next `AppEvent::Active` is emitted. When `AppEvent::Close` or `AppEvent::Finish`
    is emitted, the application will exit gracefully, similar to a **Close** or **Apply**
    event/message in a GUI application.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed error handling in `RxCpp`, along with some of
    the advanced constructs and Operators to handle Streams in the `RxCpp` library.
    We visited the basic principles of a reactive system, and gave more emphasis to
    one of the key pillars of a reactive system, resilience, when we discussed error
    handling mechanisms. We discussed features such as error handlers (`on_error`),
    which need to be used with subscription. Also, we discussed `RxCpp` Operators,
    such as `on_error_resume_next()`, `retry()`, and `finally()`, to discuss how to
    continue Streams when an error comes, how to wait for the producer of the Stream
    to correct the error and continue the sequence, and how to perform common operations
    that are applicable to both success and error paths. Finally, we discussed two
    sample programs, to understand more about Stream processing. These programs illustrated
    how the `RxCpp` library can be used to process a Stream of UX events (simulated
    using a console program) and aggregate data Streams.
  prefs: []
  type: TYPE_NORMAL
