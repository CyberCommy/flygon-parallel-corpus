- en: Unit Testing – Focusing on What You Do and Not on What Has Been Done
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"To create something exceptional, your mindset must be relentlessly focused
    on the smallest detail."'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: – Giorgio Armani
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: As promised, each chapter will explore a different Java testing framework and
    this one is no exception. We'll use TestNG to build our specifications.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: In the previous [Chapter 3](80748be2-41bd-4ee8-bdff-ce9260cd1225.xhtml), *Red-Green-Refactor –
    From Failure Through Success until Perfection*, we practiced the Red-Green-Refactor
    procedure. We used unit tests without going deeper into how unit testing works
    in the context of TDD. We'll build on the knowledge from the last chapter and
    go into more detail by trying to explain what unit tests really are and how they
    fit into the TDD approach to building software.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: The goal of this chapter is to learn how to focus on the unit we're currently
    working on and how to ignore or isolate those that were done before.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: Once we're comfortable with TestNG and unit testing, we'll dive right into the
    requirements of our next application and start coding.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit testing with TDD
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TestNG
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remote-controlled ship requirements
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing the remote-controlled ship
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit testing
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Frequent manual testing is too impractical for any but the smallest systems.
    The only way around this is the use of automated tests. They are the only effective
    method to reduce the time and cost of building, deploying, and maintaining applications.
    In order to effectively manage applications, it is of the utmost importance that
    both the implementation and test codes are as simple as possible. Simplicity is
    one of the core **extreme programming** (**XP**) values ([http://www.extremeprogramming.org/rules/simple.html](http://www.extremeprogramming.org/rules/simple.html))
    and the key to TDD and programming in general. It is most often accomplished through
    division into small units. In Java, units are methods. Being the smallest, the
    feedback loop they provide is the fastest so we spend most of our time thinking
    and working on them. As a counterpart to implementation methods, unit tests should
    constitute by far the biggest percentage of all tests.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: What is unit testing?
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Unit testing** is a practice that forces us to test small, individual, and
    isolated units of code. They are usually methods, even though in some cases classes
    or even whole applications can be considered to be units, as well. In order to
    write unit tests, code under tests needs to be isolated from the rest of the application.
    Preferably, that isolation is already ingrained in the code or it can be accomplished
    with the use of **mocks** (more on mocks will be covered in [Chapter 6](97f02bdf-43f8-4862-a3b7-600e3b963f5e.xhtml),
    *Mocking – Removing External Dependencies*). If unit tests of a particular method
    cross the boundaries of that unit, then they become integration tests. As such,
    it becomes less clear what is under the tests. In case of a failure, the scope
    of a problem suddenly increases and finding the cause becomes more tedious.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Why unit testing?
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A common question, especially within organizations that rely heavily on manual
    testing, is *Why should we use unit instead of functional and integration testing?*
    This question in itself is flawed. Unit testing does not replace other types of
    testing. Instead, unit testing reduces the scope of other types of tests. By its
    nature, unit testing is easier and faster to write than any other type of tests,
    thus reducing the cost and **time to market** (**TTM**). Due to the reduced time
    to write and run them, they tend to detect problems much sooner. The faster we
    detect problems, the cheaper it is to fix them. A bug that was detected minutes
    after it was created is much easier to fix than if that same bug was found days,
    weeks, or even months after it was made.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Code refactoring
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Code refactoring** is the process of changing the structure of an existing
    code without changing its external behavior. The purpose of refactoring is to
    improve an existing code. This improvement can be made for many different reasons.
    We might want to make the code more readable, less complex, easier to maintain,
    cheaper to extend, and so on. No matter what the reason for refactoring is, the
    ultimate goal is always to make it better in one way or another. The effect of
    this goal is a reduction in technical debt; a reduction in pending work that needs
    to be done due to suboptimal design, architecture, or coding.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Typically, we approach refactoring by applying a set of small changes without
    modifying intended behavior. Reducing the scope of refactoring changes allows
    us continuously to confirm that those changes did not break any existing functionality.
    The only way to effectively obtain this confirmation is through the use of automated
    tests.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: One of the great benefits of unit tests is that they are the best refactoring
    enablers. Refactoring is too risky when there are no automated tests to confirm
    that the application still behaves as expected. While any type of test can be
    used to provide the code coverage required for refactoring, in most cases only
    unit tests can provide the required level of details.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Why not use unit tests exclusively?
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this moment, you might be wondering whether unit testing could provide a
    solution for all your testing needs. Unfortunately, that is not the case. While
    unit tests usually cover the biggest percentage of your testing needs, functional
    and integration tests should be an integral part of your testing toolbox.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll cover other types of tests in more detail in later chapters. For now,
    a few important distinctions between them are as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests try to verify small units of functionality. In the Java world, those
    units are methods. All external dependencies, such as invocations of other classes
    and methods or database calls, should be done in memory with the use of mocks,
    stubs, spies, fakes, and dummies. Gerard Meszaros coined a more general term, **test
    doubles***,* that envelops all those ([http://en.wikipedia.org/wiki/Test_double](http://en.wikipedia.org/wiki/Test_double)).
    Unit tests are simple, easy to write, and fast to run. They are usually the biggest
    percentage of a testing suite.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Functional** and **acceptance** tests have a job to verify that the application
    we''re building works as expected, as a whole. While those two differ in their
    purpose, both share a similar goal. Unlike unit tests that are verifying the internal
    quality of the code, functional and acceptance tests are trying to ensure that
    the system is working correctly from the customer''s or user''s point of view.
    Those tests are usually smaller in number when compared with unit tests due to
    the cost and effort needed to both write and run them.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integration** tests intend to verify that separate units, modules, applications,
    or even whole systems are properly integrated with each other. You might have
    a frontend application that uses backend APIs that, in turn, communicate with
    a database. The job of integration tests would be to verify that all three of
    those separate components of the system are indeed integrated and can communicate
    with each other. Since we already know that all the units are working and all
    functional and acceptance tests are passed, integration tests are usually the
    smallest of all three as their job is only to confirm that all the pieces are
    working well together:'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/a224c9c4-bee4-445c-9b8f-4c353dc040d6.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
- en: The testing pyramid states that you should have many more unit tests than higher-level
    tests (UI tests, integration tests, and so on). Why is that? Unit tests are much
    cheaper to write, faster to run, and, at the same time, provide much bigger coverage.
    Take, for example, registration functionality. We should test what happens when
    a username is empty, when a password is empty, when a username or password is
    not in the correct format, when the user already exists, and so on. Only for this
    single functionality there can be tens, if not hundreds of tests. Writing and
    running all those tests from the UI can be very expensive (time-consuming to write
    and slow to run). On the other hand, unit testing a method that does this validation
    is easy, fast to write, and fast to run. If all those cases are covered with unit
    tests, we could be satisfied with a single integration test that checks whether
    our UI is calling the correct method on the backend. If it is, details are irrelevant
    from an integration point of view since we know that all cases are already covered
    on the unit level.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 测试金字塔表明，你应该有比高级测试（UI测试，集成测试等）更多的单元测试。为什么呢？单元测试的编写成本更低，运行速度更快，并且同时提供更大的覆盖范围。以注册功能为例。我们应该测试当用户名为空时会发生什么，当密码为空时会发生什么，当用户名或密码不符合正确格式时会发生什么，当用户已经存在时会发生什么，等等。仅针对这个单一功能，可能会有数十甚至数百个测试。从UI编写并运行所有这些测试可能非常昂贵（编写耗时且运行缓慢）。另一方面，对执行此验证的方法进行单元测试很容易，编写快速，运行迅速。如果所有这些情况都通过单元测试覆盖，我们可以满意地进行单一集成测试，检查我们的UI是否在后端调用了正确的方法。如果是的话，从集成的角度来看，细节是无关紧要的，因为我们知道所有情况已经在单元级别上得到了覆盖。
- en: Unit testing with TDD
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用TDD的单元测试
- en: What is the difference in the way we write unit tests in the context of TDD?
    The major differentiator is in *when*. While traditionally unit tests are written
    after the implementation code is done, in TDD we write tests before—the order
    of things is inverted. Without TDD, the purpose of unit tests is to validate an
    existing code. TDD teaches us that unit tests should drive our development and
    design. They should define the behavior of the smallest possible unit. They are
    micro-requirements pending development. A test tells you what to do next and when
    you're done doing it. Depending on the type of tests (unit, functional, integration,
    and so on), the scope of what should be done next differs. In the case of TDD
    with unit tests, this scope is the smallest possible, meaning a method or, more
    often, a part of it. Moreover, with TDD driven by unit tests, we are forced to
    comply to some design principles, such as **keep it simple, stupid** (**KISS**).
    By writing simple tests with a very small scope, the implementation of those tests
    tends to be simple as well. By forcing tests not to use external dependencies,
    we are forcing the implementation code to have a separation of concerns that is
    well-designed. There are many other examples of how TDD helps us to write better
    code. Those same benefits cannot be accomplished with unit testing alone. Without
    TDD, unit tests are forced to work with an existing code and have no influence
    on the design.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在TDD的环境中，我们编写单元测试的方式有何不同？主要的区别在于*何时*。传统上，单元测试是在实现代码完成后编写的，而在TDD中，我们在此之前编写测试—事情的顺序被颠倒了。没有TDD，单元测试的目的是验证现有代码。TDD教导我们，单元测试应该驱动我们的开发和设计。它们应该定义最小可能单元的行为。它们是待开发的微需求。一个测试告诉你接下来该做什么，以及何时完成它。根据测试的类型（单元测试、功能测试、集成测试等），下一步应该做什么的范围不同。在使用TDD进行单元测试的情况下，这个范围是最小可能的，意味着一个方法或者更常见的是其中的一部分。此外，通过由单元测试驱动的TDD，我们被迫遵守一些设计原则，比如**保持简单，愚蠢**（**KISS**）。通过编写简单的测试，范围很小，这些测试的实现也往往很简单。通过强制测试不使用外部依赖，我们迫使实现代码具有良好设计的关注点分离。TDD如何帮助我们编写更好的代码还有许多其他例子。这些好处无法仅通过单元测试实现。没有TDD，单元测试被迫使用现有代码，并且对设计没有影响。
- en: To summarize, the main goal of unit testing without TDD is the validation of
    the existing code. Unit testing written in advance using the TDD procedure has
    the main objective specification and design, with validation being a side product.
    This side product is often of a higher quality than when tests are written after
    the implementation.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，没有TDD的单元测试的主要目标是验证现有代码。使用TDD程序提前编写的单元测试的主要目标是规范和设计，验证只是一个附带产品。这个附带产品通常比在实现之后编写测试时的质量要高。
- en: TDD forces us to think through our requirements and design, write clean code
    that works, create executable requirements, and refactor safely and often. On
    top of all that, we end up with high test code coverage that is used to regression-test
    all our code whenever some change is introduced. Unit testing without TDD gives
    us only tests and, often, with doubtful quality.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: TDD迫使我们深思熟虑我们的需求和设计，编写能够运行的干净代码，创建可执行的需求，并安全而频繁地进行重构。最重要的是，我们最终得到了高测试代码覆盖率，用于在引入变更时对我们的所有代码进行回归测试。没有TDD的单元测试只给我们测试，而且通常质量存疑。
- en: TestNG
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TestNG
- en: JUnit and TestNG are two major Java testing frameworks. You already wrote tests
    with JUnit in the previous chapter, [Chapter 3](80748be2-41bd-4ee8-bdff-ce9260cd1225.xhtml), *Red-Green-Refactor –
    From Failure Through Success until Perfection*,  and, hopefully, got a good understanding
    of how it works. How about TestNG? It was born out of a desire to make JUnit better.
    Indeed, it contains some functionalities that JUnit doesn't have.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: JUnit和TestNG是两个主要的Java测试框架。在上一章中，您已经使用JUnit编写了测试，*Red-Green-Refactor – 从失败到成功直至完美*，并且希望您对其工作原理有了很好的理解。那TestNG呢？它诞生于对JUnit进行改进的愿望。事实上，它包含了一些JUnit没有的功能。
- en: The following subsections summarize some of the differences between the two
    of them. We'll try not only to provide an explanation of the differences, but
    also their evaluation in the context of unit testing with TDD.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 以下小节总结了它们之间的一些区别。我们不仅会尝试解释这些区别，还会在TDD的单元测试环境中对它们进行评估。
- en: The @Test annotation
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '@Test注释'
- en: 'Both JUnit and TestNG use the `@Test` annotation to specify which method is
    considered to be a test. Unlike JUnit, which requires every method to be annotated
    with `@Test`, TestNG allows us to use this annotation on a class level, as well.
    When used in this way, all public methods are considered tests unless specified
    otherwise:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: JUnit和TestNG都使用`@Test`注释来指定哪个方法被视为测试。与JUnit不同，后者要求每个方法都要有`@Test`注释，而TestNG允许我们在类级别上使用这个注释。当以这种方式使用时，除非另有规定，否则所有公共方法都被视为测试：
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this example, we put the `@Test` annotation above the `DirectionSpec` class.
    As a result, both the `whenGetFromShortNameNThenReturnDirectionN` and `whenGetFromShortNameWThenReturnDirectionW`
    methods are considered tests.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将`@Test`注释放在`DirectionSpec`类的上面。结果，`whenGetFromShortNameNThenReturnDirectionN`和`whenGetFromShortNameWThenReturnDirectionW`方法都被视为测试。
- en: If that code was written using JUnit, both the methods would need to have the `@Test`
    annotation.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果该代码是使用JUnit编写的，那么这两个方法都需要有`@Test`注释。
- en: The @BeforeSuite, @BeforeTest, @BeforeGroups, @AfterGroups, @AfterTest, and
    @AfterSuite annotations
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '@BeforeSuite，@BeforeTest，@BeforeGroups，@AfterGroups，@AfterTest和@AfterSuite注释'
- en: Those six annotations do not have their equivalents in JUnit. TestNG can group
    tests into suites, using XML configuration. Methods annotated with `@BeforeSuite`
    and `@AfterSuite` are run before and after all the tests in the specified suite
    have run. Similarly, the `@BeforeTest` and `@AfterTest` annotated methods are
    run before any test method belonging to the test classes has run. Finally, TestNG
    tests can be organized into groups. The `@BeforeGroups` and `@AfterGroups` annotations
    allow us to run methods before the first test and after the last test, in specified
    groups, are run.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这六个注释在JUnit中没有对应的。TestNG可以使用XML配置将测试分组为套件。使用`@BeforeSuite`和`@AfterSuite`注释的方法在指定套件中的所有测试运行之前和之后运行。类似地，使用`@BeforeTest`和`@AfterTest`注释的方法在测试类的任何测试方法运行之前运行。最后，TestNG测试可以组织成组。`@BeforeGroups`和`@AfterGroups`注释允许我们在指定组中的第一个测试之前和最后一个测试之后运行方法。
- en: While those annotations can be very useful when tests are written after the
    implementation code, they do not provide much usage in the context of TDD. Unlike
    traditional testing, which is often planned and written as a separate project,
    TDD teaches us to write one test at a time and keep everything simple. Most importantly,
    unit tests are supposed to run quickly so there is no need to group them into
    suites or groups. When tests are fast, running anything less than everything is
    a waste. If, for example, all tests are run in less than 15 seconds, there is
    no need to run only a part of them. On the other hand, when tests are slow, it
    is often a sign that external dependencies are not isolated. No matter what the
    reason is behind slow tests, the solution is not to run only a part of them, but
    to fix the problem.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些注释在编写实现代码后的测试时可能非常有用，但在TDD的上下文中并没有太多用处。与通常的测试不同，通常是计划并作为一个独立项目编写的，TDD教导我们一次编写一个测试并保持一切简单。最重要的是，单元测试应该快速运行，因此没有必要将它们分组到套件或组中。当测试快速运行时，运行除了全部之外的任何内容都是浪费。例如，如果所有测试在15秒内运行完毕，就没有必要只运行其中的一部分。另一方面，当测试很慢时，通常是外部依赖没有被隔离的迹象。无论慢测试背后的原因是什么，解决方案都不是只运行其中的一部分，而是解决问题。
- en: Moreover, functional and integration tests do tend to be slower and require
    us to have some kind of separation. However, it is better to separate them in,
    for example, `build.gradle` so that each type of test is run as a separate task.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，功能和集成测试往往会更慢，并且需要我们进行某种分离。然而，最好是在`build.gradle`中将它们分开，以便每种类型的测试作为单独的任务运行。
- en: The @BeforeClass and @AfterClass annotations
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '@BeforeClass和@AfterClass注释'
- en: These annotations have the same function in both JUnit and TestNG. Annotated
    methods will be run before the first test and after the last test, in a current
    class. The only difference is that TestNG does not require those methods to be
    static. The reason behind this can be found in the different approaches those
    two frameworks take when running test methods. JUnit isolates each test into its
    own instance of the test class, forcing us to have those methods defined as static
    and, therefore, reusable across all test runs. TestNG, on the other hand, executes
    all test methods in the context of a single test class instance, eliminating the
    need for those methods to be static.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这些注释在JUnit和TestNG中具有相同的功能。在当前类中的第一个测试之前和最后一个测试之后运行带注释的方法。唯一的区别是TestNG不要求这些方法是静态的。这背后的原因可以在这两个框架运行测试方法时采取的不同方法中找到。JUnit将每个测试隔离到其自己的测试类实例中，迫使我们将这些方法定义为静态的，因此可以在所有测试运行中重复使用。另一方面，TestNG在单个测试类实例的上下文中执行所有测试方法，消除了这些方法必须是静态的需要。
- en: The @BeforeMethod and @AfterMethod annotations
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '@BeforeMethod和@AfterMethod注释'
- en: The `@Before` and `@After` annotations are equivalent to JUnit. Annotated methods
    are run before and after each test method.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Before`和`@After`注释等同于JUnit。带注释的方法在每个测试方法之前和之后运行。'
- en: The @Test(enable = false) annotation argument
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '@Test(enable = false)注释参数'
- en: Both JUnit and TestNG can disable tests. While JUnit uses a separate `@Ignore`
    annotation, TestNG uses the `@Test` annotation Boolean argument, `enable`. Functionally,
    both work in the same way and the difference is only in the way we write them.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: JUnit和TestNG都可以禁用测试。虽然JUnit使用单独的`@Ignore`注释，但TestNG使用`@Test`注释的布尔参数`enable`。在功能上，两者的工作方式相同，区别只在于我们编写它们的方式。
- en: The @Test(expectedExceptions = SomeClass.class) annotation argument
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '@Test(expectedExceptions = SomeClass.class)注释参数'
- en: This is the case where JUnit has the advantage. While both provide the same
    way to specify the expected exception (in the case of JUnit, the argument is called
    simply `expected`), JUnit introduces rules that are a more elegant way to test
    exceptions (we already worked with them in [Chapter 2](2b33a0f7-c645-4266-891b-8572251f083e.xhtml),
    *Tools, Frameworks, and Environment*).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: TestNG versus JUnit summary
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many other differences between those two frameworks. For brevity,
    we do not cover all of them in this book. Consult their documentation for further
    information.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: More information about JUnit and TestNG can be found at [http://junit.org/](http://junit.org/)
    and [http://testng.org/](http://testng.org/).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: TestNG provides more features and is more advanced than JUnit. We'll work with
    TestNG throughout this chapter, and you'll get to know it better. One thing that
    you'll notice is that we won't use any of those advanced features. The reason
    is that, with TDD, we rarely need them when working with unit tests. Functional
    and integration tests are of a different kind and would serve as a better demonstration
    of TestNG's superiority. However, there are tools that are more suited for those
    types of tests, as you'll see in the following chapters.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Which one should you use? I'll leave that choice up to you. By the time you
    finish this chapter, you'll have hands-on knowledge of both JUnit and TestNG.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: Remote-controlled ship requirements
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll work on a variation of a well-known kata called **Mars Rover**, originally
    published in *Dallas Hack Club* ([http://dallashackclub.com/rover](http://dallashackclub.com/rover)).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: Imagine that a naval ship is placed somewhere on Earth's seas. Since this is
    the 21^(st) century, we can control that ship remotely.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: Our job will be to create a program that can move the ship around the seas.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Since this is a TDD book and the subject of this chapter is unit tests, we'll
    develop an application using a TDD approach with the focus on unit tests. In the
    previous chapter, [Chapter 3](80748be2-41bd-4ee8-bdff-ce9260cd1225.xhtml), *Red-Green-Refactor
    – From Failure Through Success until Perfection*, you learned the theory and had
    practical experience with the Red-Green-Refactor procedure. We'll build on top
    of that and try to learn how to employ unit testing effectively. Specifically,
    we'll try to concentrate on a unit we're developing and learn how to isolate and
    ignore dependencies that a unit might use. Not only that, but we'll try to concentrate
    on one requirement at a time. For this reason, you were presented only with high-level
    requirements; we should be able to move the remote-controlled ship, located somewhere
    on the planet, around.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: To make things easier, all the supporting classes have been already made and
    tested. This will allow us to concentrate on the main task at hand and, at the
    same time, keep this exercise concise.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: Developing the remote-controlled ship
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start by importing the existing Git repository.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Project setup
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start setting up the project:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Open IntelliJ IDEA. If an existing project is already opened, select File|Close
    Project.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will be presented with a screen similar to the following:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8b78ff11-66a4-4ad7-8a8e-bb57a01a0e65.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
- en: 'To import the project from the Git repository, click on Check out from Version
    Control and select Git. Type `https://bitbucket.org/vfarcic/tdd-java-ch04-ship.git`
    in to the Git Repository URL field and click on Clone:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/fdadac00-35ba-452f-af9b-18e0d3ea84d9.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
- en: Answer Yes when asked whether you would like to open the project.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next you will be presented with the Import Project from Gradle dialog. Click
    on OK:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ed6a55a5-96b3-4dca-8d65-00ef75210725.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
- en: 'IDEA will need to spend some time downloading the dependencies specified in
    the `build.gradle` file. Once that is done, you''ll see that some classes and
    corresponding tests are already created:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/75ac992a-edaf-42a6-a088-3dd628a59ce9.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
- en: Helper classes
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Imagine that a colleague of yours started working on this project. He''s a
    good programmer and a TDD practitioner, and you trust his abilities to have good
    test code coverage. In other words, you can rely on his work. However, that colleague
    did not finish the application before he left for his vacations and it''s up to
    you to continue where he stopped. He created all the helper classes: `Direction`,
    `Location`, `Planet`, and `Point`. You''ll notice that the corresponding test
    classes are there as well. They have the same name as the class they''re testing
    with the `Spec` suffix (that is, `DirectionSpec`). The reason for using this suffix
    is to make clear that tests are not only intended to validate the code, but also
    to serve as an executable specification.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: On top of the helper classes, you'll find the `Ship` (implementation) and `ShipSpec`
    (specifications/tests) classes. We'll spend most of our time in those two classes.
    We'll write tests in `ShipSpec` and then we'll write the implementation code in
    the `Ship` class (just as we did before).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: Since we already learned that tests are not only used as a way to validate the
    code, but also as executable documentation, from this moment on, we'll use the
    phrase specification or spec instead of test.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: 'Every time we finish writing a specification or the code that implements it,
    we''ll run `gradle test` either from the command prompt or by using the Gradle
    projects IDEA Tool Window:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f2f9ca0b-3bb2-4db0-a208-d913811f1e0a.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
- en: With the project set up, we're ready to dive into the first requirement.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: Requirement – starting point and orientation
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We need to know what the current location of the ship is in order to be able
    to move it. Moreover, we should also know which direction it is facing: north,
    south, east, or west. Therefore, the first requirement is the following:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: You are given the initial starting point (*x*, *y*) of a ship and the direction
    (*N*, *S*, *E*, or *W*) it is facing.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we start working on this requirement, let''s go through the helper classes
    that can be used. The `Point` class holds the `x` and `y` coordinates. It has
    the following constructor:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Similarly, we have the `Direction enum` class with the following values:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Finally, there is the `Location` class that requires both of those classes
    to be passed as constructor arguments:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Knowing this, it should be fairly easy to write a test for this first requirement.
    We should work in the same way as we did in the previous chapter, [Chapter 3](80748be2-41bd-4ee8-bdff-ce9260cd1225.xhtml), *Red-Green-Refactor –
    From Failure Through Success until Perfection*.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: Try to write specs by yourself. When done, compare them with the solution in
    this book. Repeat the same process with the code that implements specs. Try to
    write it by yourself and, once done, compare it with the solution we're proposing.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: Specification – keeping position and direction in memory
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The specification for this requirement can be the following:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This was an easy one. We're just checking whether the `Location` object we're
    passing as the `Ship` constructor is stored and can be accessed through the `location`
    getter.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: The `@Test` annotation—When TestNG has the `@Test` annotation set on the class
    level, there is no need to specify which methods should be used as tests. In this
    case, all public methods are considered to be TestNG tests.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The implementation of this specification should be fairly easy. All we need
    to do is set the constructor argument to the `location` variable:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The full source can be found in the `req01-location` branch of the `tdd-java-ch04-ship`
    repository ([https://bitbucket.org/vfarcic/tdd-java-ch04-ship/branch/req01-location](https://bitbucket.org/vfarcic/tdd-java-ch04-ship/branch/req01-location)).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We know that we''ll need to instantiate `Ship` for every spec, so we might
    as well refactor the specification class by adding the `@BeforeMethod` annotation.
    The code can be the following:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: No new behavior has been introduced. We just moved part of the code to the `@BeforeMethod`
    annotation in order to avoid duplication, which would be produced by the rest
    of the specifications that we are about to write. Now, every time a test is run,
    the `ship` object will be instantiated with `location` as the argument.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 没有引入新的行为。我们只是将代码的一部分移动到`@BeforeMethod`注解中，以避免重复，这将由我们即将编写的其余规范产生。现在，每次运行测试时，`ship`对象将以`location`作为参数实例化。
- en: Requirement – forward and backward moves
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 要求-向前和向后移动
- en: Now that we know where our ship is, let's try to move it. To begin with, we
    should be able to go both forwards and backwards.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了我们的飞船在哪里，让我们试着移动它。首先，我们应该能够向前和向后移动。
- en: Implement commands that move the ship forwards and backwards (*f* and *b*).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 实现将飞船向前和向后移动的命令（*f*和*b*）。
- en: 'The `Location` helper class already has the `forward` and `backward` methods
    that implement this functionality:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: “位置”辅助类已经有了实现这一功能的“向前”和“向后”方法：
- en: '[PRE7]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Specification – moving forward
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规范-向前移动
- en: What should happen when, for example, we are facing north and we move the ship
    forwards? Its location on the *y*-axis should decrease. Another example would
    be that when the ship is facing east, it should increase its *x*-axis location
    by 1.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当我们面向北方并向前移动飞船时，它在*y*轴上的位置应该减少。另一个例子是，当飞船面向东方时，它应该将*x*轴位置增加1。
- en: 'The first reaction can be to write specifications similar to the following
    two:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个反应可能是编写类似以下两个规范：
- en: '[PRE8]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We should create at least two more specifications related to cases where a ship
    is facing south and west.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该创建至少另外两个与飞船面向南方和西方的情况相关的规范。
- en: However, this is not how unit tests should be written. Most people new to unit
    testing fall into the trap of specifying the end result that requires the knowledge
    of the inner workings of methods, classes, and libraries used by the method that
    is being specified. This approach is problematic on many levels.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这不是编写单元测试的方式。大多数刚开始进行单元测试的人会陷入指定需要了解方法、类和库的内部工作知识的最终结果的陷阱。这种方法在许多层面上都存在问题。
- en: When including external code in the unit that is being specified, we should
    take into account, at least in our case, the fact that the external code is already
    tested. We know that it is working since we're running all the tests every time
    any change to the code is made.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在将外部代码包含在被指定的单元中时，我们应该考虑到，至少在我们的情况下，外部代码已经经过测试。我们知道它是有效的，因为我们每次对代码进行更改时都会运行所有测试。
- en: Rerun all the tests every time the implementation code changes.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 每次实现代码更改时重新运行所有测试。
- en: This ensures that there is no unexpected side-effect caused by code changes.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这确保了代码更改不会引起意外的副作用。
- en: Every time any part of the implementation code changes, all tests should be
    run. Ideally, tests are fast to execute and can be run by a developer locally.
    Once code is submitted to the version control, all tests should be run again to
    ensure that there was no problem due to code merges. This is especially important
    when more than one developer is working on the code. CI tools, such as Jenkins,
    Hudson, Travind, Bamboo, and Go-CD should be used to pull the code from the repository,
    compile it, and run tests.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 每当实现代码的任何部分发生更改时，都应该运行所有测试。理想情况下，测试执行速度快，可以由开发人员在本地运行。一旦代码提交到版本控制，应该再次运行所有测试，以确保由于代码合并而出现问题。当有多个开发人员在代码上工作时，这一点尤为重要。CI工具，如Jenkins、Hudson、Travind、Bamboo和Go-CD，应该用于从存储库中拉取代码、编译代码并运行测试。
- en: Another problem with this approach is that if an external code changes, there
    will be many more specifications to change. Ideally, we should be forced to change
    only specifications directly related to the unit that will be modified. Searching
    for all other places where that unit is called from might be very time-consuming
    and error-prone.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的另一个问题是，如果外部代码发生更改，将有更多的规范需要更改。理想情况下，我们应该只被迫更改与将要修改的单元直接相关的规范。搜索所有其他调用该单元的地方可能非常耗时且容易出错。
- en: 'A much easier, faster, and better way to write specifications for this requirement
    would be the following:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 为此要求编写规范的另一个更简单、更快、更好的方法是：
- en: '[PRE9]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Since `Location` already has the `forward` method, all we'd need to do is to
    make sure that the proper invocation of that method is performed. We created a
    new `Location` object called `expected`, invoked the `forward` method, and compared
    that object with the location of the ship after its `moveForward` method is called.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 由于“位置”已经有“向前”方法，我们只需要确保执行该方法的适当调用。我们创建了一个名为“expected”的新“位置”对象，调用了“向前”方法，并将该对象与飞船在调用其“moveForward”方法后的位置进行了比较。
- en: Note that specifications are not only used to validate the code, but are also
    used as executable documentation and, most importantly, as a way to think and
    design. This second attempt specifies more clearly what the intent is behind it.
    We should create a `moveForward` method inside the `Ship` class and make sure
    that the `location.forward` is called.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，规范不仅用于验证代码，而且还用作可执行文档，更重要的是，作为一种思考和设计的方式。这第二次尝试更清楚地指定了其背后的意图。我们应该在`Ship`类内创建一个`moveForward`方法，并确保调用`location.forward`。
- en: Implementation
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施
- en: 'With such a small and clearly defined specification, it should be fairly easy
    to write the code that implements it:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这样一个小而明确定义的规范，编写实现它的代码应该相当容易：
- en: '[PRE10]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Specification – moving backward
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规范-向后移动
- en: 'Now that we have a forward movement specified and implemented, the backward
    movement should almost be the same:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经指定并实现了向前移动，向后移动应该几乎相同：
- en: '[PRE11]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Implementation
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施
- en: 'Just like the specification, the backward movement implementation is just as
    easy:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 与规范一样，向后移动的实现同样简单：
- en: '[PRE12]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The full source code for this requirement can be found in the `req02-forward-backward`
    branch of the `tdd-java-ch04-ship` repository ([https://bitbucket.org/vfarcic/tdd-java-ch04-ship/branch/req02-forward-backward](https://bitbucket.org/vfarcic/tdd-java-ch04-ship/branch/req02-forward-backward)).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: Requirement – rotating the ship
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Moving the ship only back and forth won't get us far. We should be able to change
    the direction by rotating the ship to the left or right as well.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Implement commands that turn the ship left and right (*l* and *r*).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: After implementing the previous requirement, this one should be very easy since
    it can follow the same logic. The `Location` helper class already contains the
    `turnLeft` and `turnRight` methods that perform exactly what is required by this
    requirement. All we need to do is integrate them into the `Ship` class.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Specification – turning left
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using the same guidelines as those we have used so far, the specification for
    turning left can be the following:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Implementation
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You probably did not have a problem writing the code to pass the previous specification:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Specification – turning right
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Turning right should be almost the same as turning left:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Implementation
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finally, let''s finish this requirement by implementing the specification for
    turning right:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The full source for this requirement can be found in the `req03-left-right`
    branch of the `tdd-java-ch04-ship` repository ([https://bitbucket.org/vfarcic/tdd-java-ch04-ship/branch/req03-left-right](https://bitbucket.org/vfarcic/tdd-java-ch04-ship/branch/req03-left-right)).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Requirement – commands
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Everything we have done so far was fairly easy since there were helper classes
    that provided all the functionality. This exercise was to learn how to stop attempting
    to test the end outcome and focus on a unit we're working on. We are building
    trust; we had to trust the code done by others (the helper classes).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Starting from this requirement, you'll have to trust the code you wrote by yourself.
    We'll continue in the same fashion. We'll write specifications, run tests, and
    see them fail; we'll write implementations, run tests, and see them succeed; finally,
    we'll refactor if we think the code can be improved. Continue thinking how to
    test a unit (method) without going deeper into methods or classes that the unit
    will be invoking.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have individual commands (forwards, backwards, left, and right)
    implemented, it's time to tie it all together. We should create a method that
    will allow us to pass any number of commands as a single string. Each command
    should be a character with *f* meaning forwards, *b* being backwards, *l* for
    turning left, and *r* for turning right.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: The ship can receive a string with commands (`lrfb`, which are equivalent to
    left, right, forwards, and backwards).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Specification – single commands
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start with the command argument, that only has the `f` (forwards) character:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This specification is almost the same as the `whenMoveForwardThenForward` specification
    except that, this time, we're invoking the `ship.receiveCommands("f")` method.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We already spoke about the importance of writing the simplest possible code
    that passes the specification.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: Write the simplest code to pass the test. This ensures a cleaner and clearer
    design and avoids unnecessary features
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: The idea is that the simpler the implementation, the better and easier it is
    to maintain the product. The idea adheres to the KISS principle. It states that
    most systems work best if they are kept simple rather than made complex; therefore,
    simplicity should be a key goal in design and unnecessary complexity should be
    avoided.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a good opportunity to apply this rule. You might be inclined to write
    a piece of code similar to the following:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In this example code, we are verifying whether the first character is `f` and,
    if it is, invoking the `moveForward` method. There are many other variations that
    we can do. However, if we stick to the simplicity principle, a better solution
    would be the following:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This is the simplest and shortest possible code that will make the specification
    pass. Later on, we might end up with something closer to the first version of
    the code; we might use some kind of a loop or come up with some other solution
    when things become more complicated. As for now, we are concentrating on one specification
    at a time and trying to make things simple. We are attempting to clear our mind
    by focusing only on the task at hand.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: For brevity, the rest of the combinations (`b`, `l`, and `r`) are not presented
    here (continue to implement them by yourself). Instead, we'll jump to the last
    specification for this requirement.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Specification – combined commands
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we are able to process one command (whatever that the command is),
    it is time to add the option to send a string of commands. The specification can
    be the following:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This is a bit longer, but is still not an overly complicated specification.
    We're passing commands `rflb` (right, forwards, left, and backwards) and expecting
    that the `Location` changes accordingly. As before, we're not verifying the end
    result (seeing whether the if coordinates have changed), but checking whether
    we are invoking the correct calls to helper methods.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The end result can be the following:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: If you tried to write specifications and the implementation by yourself and
    if you followed the simplicity rule, you probably had to refactor your code a
    couple of times in order to get to the final solution. Simplicity is the key and
    refactoring is often a welcome necessity. When refactoring, remember that all
    specifications must be passing all the time.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: Refactor only after all the tests have passed.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: 'Benefits: refactoring is safe.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: If all the implementation code that can be affected has tests and if they are
    all passing, it is relatively safe to refactor. In most cases, there is no need
    for new tests; small modifications to existing tests should be enough. The expected
    outcome of refactoring is to have all the tests passing both before and after
    the code is modified.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: The full source for this requirement can be found in the `req04-commands` branch
    of the `tdd-java-ch04-ship` repository ([https://bitbucket.org/vfarcic/tdd-java-ch04-ship/branch/req04-commands](https://bitbucket.org/vfarcic/tdd-java-ch04-ship/branch/req04-commands)).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Requirement – representing spheric maps
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Earth is a sphere, as is any other planet. When Earth is presented as a map,
    reaching one edge wraps us to another; for example, when we move east and reach
    the furthest point in the Pacific Ocean, we are wrapped to the west side of the
    map and we continue moving towards America. Furthermore, to make the movement
    easier, we can define the map as a grid. That grid should have length and height
    expressed as an *x*-axis and *y*-axis. That grid should have maximum length (x)
    and height (y).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: Implement wrapping from one edge of the grid to another.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: Specification – planet information
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first thing we can do is pass the `Planet` object with the maximum `X`
    and `Y` axis coordinates to the `Ship` constructor. Fortunately, `Planet` is one
    more of the helper classes that have already been made (and tested). All we need
    to do is instantiate it and pass it to the `Ship` constructor:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We're defining the size of the planet as 50 x 50 and passing that to the `Planet`
    class. In turn, that class is afterwards passed to the `Ship` constructor. You
    might have noticed that the constructor needs an extra argument. In the current
    code, our constructor requires only `location`. To implement this specification,
    it should accept `planet`, as well.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: How would you implement this specification without breaking any of the existing
    specifications?
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s take a bottom-up approach. An `assert` requires us to have a `planet`
    getter:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Next, the constructor should accept `Planet` as a second argument and assign
    it to the previously added `planet` variable. The first attempt might be to add
    it to the existing constructor, but that would break many existing specifications
    that are using a single argument constructor. This leaves us with only one option—a
    second constructor:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Run all the specifications and confirm that they are all successful.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our specifications forced us to create the second constructor, since changing
    the original one would break the existing tests. However, now that everything
    is green, we can do some refactoring and get rid of the single argument constructor.
    The specification class already has the `beforeTest` method that is run before
    each test. We can move everything, but the `assert` itself to this method:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: With this change, we effectively removed the usage of the `Ship` single argument
    constructor. By running all specifications, we should confirm that this change
    worked.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, with a single argument constructor that is not in use anymore, we can
    remove it from the implementation class, as well:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: By using this approach, all specifications were green all the time. Refactoring
    did not change any existing functionality, nothing got broken, and the whole process
    was done quickly.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's move into wrapping itself.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: Specification – dealing with map boundaries
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Like in other cases, the helper classes already provide all the functionality
    that we need. So far, we used the `location.forward` method without arguments.
    To implement wrapping, there is the overloaded `location.forward(Point max)` method
    that will wrap the location when we reach the end of the grid. With the previous
    specification, we made sure that `Planet` is passed to the `Ship` class and that
    it contains `Point max`. Our job is to make sure that `max` is used when moving
    forward. The specification can be the following:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Implementation
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By now, you should be getting used to focusing on one unit at a time and to
    trust that those that were done before are working as expected. This implementation
    should be no different. We just need to make sure that the maximum coordinates
    are used when the `location.forward` method is called:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The same specification and implementation should be done for the `backward`
    method. For brevity, it is excluded from this book, but it can be found in the
    source code.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: The full source for this requirement can be found in the `req05-wrap` branch
    of the `tdd-java-ch04-ship` repository ([https://bitbucket.org/vfarcic/tdd-java-ch04-ship/branch/req05-wrap](https://bitbucket.org/vfarcic/tdd-java-ch04-ship/branch/req05-wrap)).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: Requirement – detecting obstacles
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We're almost done. This is the last requirement.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: Even though most of the Earth is covered in water (approximately 70%), there
    are continents and islands that can be considered as obstacles for our remotely-controlled
    ship. We should have a way to detect whether our next move would hit one of those
    obstacles. If such a thing happens, the move should be aborted and the ship should
    stay on the current position and report the obstacle.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: Implement surface detection before each move to a new position. If a command
    encounters a surface, the ship aborts the move, stays on the current position,
    and reports the obstacle.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: The specifications and the implementation of this requirement are very similar
    to those we did previously, and we'll leave that to you.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few tips that can be useful:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: The `Planet` object has the constructor that accepts a list of obstacles.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each obstacle is an instance of the `Point` class.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: The `location.foward` and `location.backward` methods have overloaded versions
    that accept a list of obstacles. They return `true` if a move was successful and
    `false` if it failed. Use this Boolean to construct a status report required for
    the `Ship.receiveCommands` method.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `receiveCommands` method should return a string with the status of each
    command. `0` can represent OK and `X` can be for a failure to move (`00X0` = OK,
    OK, Failure, OK).
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The full source for this requirement can be found in the `req06-obstacles` branch
    of the `tdd-java-ch04-ship` repository ([https://bitbucket.org/vfarcic/tdd-java-ch04-ship/branch/req06-obstacles](https://bitbucket.org/vfarcic/tdd-java-ch04-ship/branch/req06-obstacles)).
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we used TestNG as our testing framework of choice. There wasn't
    much difference when compared to JUnit, simply because we didn't use any of the
    more advanced features of TestNG (for example, data providers, factories, and
    so on). With TDD, it is questionable whether we'll ever have a need for those
    features.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: Visit [http://testng.org/](http://testng.org/), explore it, and decide for yourself
    which framework best suits your needs.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: The main objective of this chapter was to learn how to focus on one unit at
    a time. We already had a lot of helper classes and we tried our best to ignore
    their internal workings. In many cases, we did not write specifications that verified
    that the end result was correct, but we checked whether the method we were working
    on invoked the correct method from those helper classes. In the real-world, you
    will be working on projects together with other team members, and it is important
    to learn how to focus on your tasks and trust that what others do works as expected.
    The same can be said for third-party libraries. It would be too expensive to test
    all inner processes that can happen when we invoke them. There are other types
    of tests that will try to cover those possibilities. When working with unit tests,
    the focus should only be on the unit we're currently working on.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have a better grasp of how to use unit tests effectively in the
    context of TDD, it is time to dive into some other advantages that TDD provides.
    Specifically, we'll explore how to design our applications better.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
