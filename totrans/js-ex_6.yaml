- en: Building a Blog with React
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用React构建博客
- en: 'Hey! Good work making it to the last section of the book, where you are going
    to learn Facebook''s React library. Before we start with this chapter, let''s
    take a look at your journey through the book:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 嘿！做到了书的最后一节，你将学习Facebook的React库。在我们开始本章之前，让我们回顾一下你在书中的学习之旅：
- en: You first built a simple ToDo list app using the JavaScript's ES6 syntax and
    then created a build script to compile it down to ES5 so that it will be compatible
    with older browsers.
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你首先使用JavaScript的ES6语法构建了一个简单的待办事项应用，然后创建了一个构建脚本将其编译为ES5，以便与旧版浏览器兼容。
- en: Then, you built a Meme Creator while setting up your own automated development
    environment, learning lots of new concepts and tools along the way.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，在设置自己的自动化开发环境的同时，你构建了一个Meme Creator，学习了许多新概念和工具。
- en: Next, you used the development environment and built an Event Registration app
    in which you built your first reusable JavaScript module for API calls and form
    validation.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，你使用开发环境构建了一个活动注册应用程序，在其中构建了你的第一个可重用的JavaScript模块，用于API调用和表单验证。
- en: Then, you utilized the power of JavaScript WebAPIs to build a peer-to-peer video
    calling app with WebRTC.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，你利用JavaScript WebAPI的强大功能构建了一个使用WebRTC的点对点视频通话应用程序。
- en: Lastly, you built your own HTML5 custom element that will display a weather
    widget and can be easily imported and used with other projects.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，你构建了自己的HTML5自定义元素，它将显示一个天气小部件，并可以轻松导入和在其他项目中使用。
- en: From a beginner level, you built some really awesome applications and now you
    are familiar with many important concepts of modern JavaScript. Now, it's time
    for you to employ these skills to learn a JavaScript framework, which will turbocharge
    your development process. This chapter will focus on helping you get started with
    React.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 从初学者级别开始，你构建了一些非常棒的应用程序，现在你熟悉了现代JavaScript的许多重要概念。现在，是时候利用这些技能学习JavaScript框架了，这将加速你的开发过程。本章将重点帮助你开始使用React。
- en: Why use a framework?
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么使用框架？
- en: Modern application development is all about speed, maintainability, and scalability.
    Given the web is the major platform for many applications, the same will be expected
    for any web applications. JavaScript may be a great language but writing plain
    JavaScript can be a tedious process at times when you are dealing with a large
    application in a team environment.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 现代应用程序开发都是关于速度、可维护性和可扩展性的。鉴于Web是许多应用程序的主要平台，对于任何Web应用程序都会有相同的期望。JavaScript可能是一种很棒的语言，但在团队环境中处理大型应用程序时，编写纯JavaScript有时可能是一个繁琐的过程。
- en: In such applications, you will have to manipulate a lot of DOM elements. Whenever
    you make changes to the CSS of a DOM element, it is called a repaint. It will
    affect how an element appears on the browser. Whenever you remove, change, or
    add an element in the DOM, then it is called a reflow. A reflow of a parent element
    causes all its child elements to reflow too. Repaints and reflows are expensive
    operations because they are synchronous. It means when a repaint or reflow happens,
    JavaScript will not be able to run at that time. This will lead to lagging or
    slow execution of web applications (especially on smaller devices, such as low-end
    smartphones). So far, we have been building very small applications; therefore,
    we haven't noticed any performance issues but for applications, such as Facebook,
    this is crucial (there are literally 1,000s of DOM elements).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在这样的应用程序中，你将不得不操作大量的DOM元素。每当你更改DOM元素的CSS时，它被称为重绘。这将影响元素在浏览器上的显示。每当你在DOM中删除、更改或添加一个元素时，这被称为回流。父元素的回流也会导致其所有子元素的回流。重绘和回流是昂贵的操作，因为它们是同步的。这意味着当重绘或回流发生时，JavaScript将无法在那个时候运行。这将导致Web应用程序的延迟或缓慢执行（特别是在较小的设备上，如低端智能手机）。到目前为止，我们一直在构建非常小的应用程序；因此，我们还没有注意到任何性能问题，但对于像Facebook这样的应用程序来说，这是至关重要的（有成千上万的DOM元素）。
- en: Also, writing lot of JavaScript code means increasing the file size of your
    code. For mobile users who rely on 3G or lower connections, it means your application
    will take a longer time to load. This causes a bad user experience.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，编写大量的JavaScript代码意味着增加代码文件的大小。对于依赖3G或更低连接的移动用户来说，这意味着你的应用程序加载时间会更长。这会导致糟糕的用户体验。
- en: Finally, frontend JavaScript code needs to deal with a lot of side effects (events
    such as click, scroll, hover, and network requests). When working in a team environment,
    every developer should know what kind of side effects your code deals with. When
    the web application grows, every side effect needs to be properly tracked. In
    plain JavaScript, writing maintainable code in such an environment is also difficult.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，前端JavaScript代码需要处理大量的副作用（例如点击、滚动、悬停和网络请求等事件）。在团队环境中工作时，每个开发人员都应该知道你的代码处理的是什么类型的副作用。当Web应用程序增长时，每个副作用都需要被正确跟踪。在纯JavaScript中，在这样的环境中编写可维护的代码也是困难的。
- en: Luckily, the JavaScript community is well aware of all these scenarios and,
    hence, there are lots of open source JavaScript libraries and frameworks created
    and actively maintained to address the preceding issues and improve developer
    productivity.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，JavaScript社区对所有这些情况都有很好的认识，因此有许多开源的JavaScript库和框架被创建并积极维护，以解决上述问题并提高开发人员的生产力。
- en: Selecting a framework
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择一个框架
- en: Choosing a JavaScript framework in 2017 is more difficult than learning JavaScript
    itself (yeah, it's true!) due to the release of a new framework almost every week.
    But unless your requirement is very specific, you won't need to worry about most
    of them. Currently, there are a few frameworks that are really popular among the
    developers, such as React, Vue.js, Angular, Ember, and so on.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在2017年选择JavaScript框架比学习JavaScript本身更困难（是的，这是真的！）因为几乎每周都会发布一个新的框架。但除非你的需求非常具体，否则大多数情况下你不需要担心它们。目前，有一些框架在开发者中非常受欢迎，比如React、Vue.js、Angular、Ember等。
- en: These frameworks are really popular because they get you up and running with
    your application in almost no time, followed by excellent support from the huge
    community of developers who use these frameworks. These frameworks also come with
    their own build tools, which will save you the trouble of setting up your own
    development environment.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: React
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are going to learn the basics of building web applications
    with React. React is built and is widely used by Facebook. Many other famous applications,
    such as Instagram, Airbnb, Uber, Pinterest, Periscope, and so on, also use React
    in their web applications, which has helped to develop React into a mature and
    battle-tested JavaScript library. At the time of writing this book, React is the
    most popular frontend JavaScript framework in GitHub with an active community
    of over 70,000 developers.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Unlike most of the other JavaScript frameworks, React does not consider itself
    a framework but as a library for building user interfaces. It perfectly handles
    the view layer of your application by composing each section of your app into
    smaller functional components.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: 'Functions are simple JavaScript code that perform a task. We have been using
    functions since the very beginning of this book. React uses the concept of functions
    to build each component of the web app. For example, look at the following element:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Say you want to replace the word `world` with a dynamic variable, for example,
    someone''s name. React achieves this by converting the element into a result of
    a function:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, the function `hello` contains the required elements as its result. If
    you try, `hello(''Rahul'')`, you will get the following:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: But wait! What is that `React.createElement()` method? Forgot to tell you. That
    is how React creates HTML elements. But applying that to building applications
    is impossible for us! Imagine how many of those you will have to type in order
    to create an application with lots of DOM elements.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: 'For this purpose, React introduced **JavaScript inside XML** (**JSX**). It
    is the process of writing an XML-styled markup inside JavaScript, which gets compiled
    to the `React.createElement()` method by React to cut a long story short, you
    can also write the `hello` function as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This will make more sense because we are simply writing HTML inside the return
    statement of JavaScript. What''s cool about this is the content of the element
    depends directly on the parameter of the function. You need to note a few things
    while working with JSX:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: The attributes of JSX elements cannot contain JavaScript keywords. See that
    the class attribute is replaced with `className` because a class is a reserved
    keyword in JavaScript. Similarly, for attribute, it becomes `htmlFor`.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To include variables or expressions inside JSX, you should wrap them inside
    curly braces `{}`. It is similar to `${}` we use in template strings.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JSX requires the Babel React preset to get compiled to JavaScript.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the HTML elements in JSX should only use small case letters.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example: `<p></p>`, `<div></div>`, and `<a></a>`.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Having capital letters for HTML is invalid.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example: `<Div></Div>` and `<Input></Input>` are all invalid.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The custom components we created should start with capital letters.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example: consider the `hello` function that we created before, which is
    a stateless React component. To include it in JSX, you should name it as `Hello`
    and include it as `<Hello></Hello>`.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The preceding function is a simple **stateless** React component. A stateless
    React component outputs elements directly depending on the variables supplied
    as parameters to the function. Its output does not depend on any other factors.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Detailed information on JSX can be found at: [https://facebook.github.io/react/docs/jsx-in-depth.html](https://facebook.github.io/react/docs/jsx-in-depth.html).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: This representation is suitable for smaller elements but many DOM elements come
    with a variety of side effects, such as DOM events and AJAX calls that will cause
    modification of DOM elements from factors (or variables) outside the scope of
    the function. To address this, React came up with a concept of **stateful** components.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这种表示适用于较小的元素，但许多DOM元素带有各种副作用，例如DOM事件和会导致DOM元素修改的AJAX调用，这些副作用来自于函数范围之外的因素（或变量）。为了解决这个问题，React提出了**有状态**组件的概念。
- en: 'A stateful component has a special variable called `state`. The `state` variable
    contains a JavaScript object and it should be immutable. We''ll look at immutability
    in a moment. For now, look at the following code:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有状态的组件有一个特殊的变量叫做`state`。`state`变量包含一个JavaScript对象，它应该是不可变的。我们稍后会看不可变性。现在，看看以下代码：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This is a simple stateful React component. As you can see, we are extending
    a class from the `React.Component` interface similar to how we extended it from
    `HTMLElement` to create our custom elements in the previous chapter and, just
    like custom elements, React components also have life cycle methods.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的有状态React组件。正如你所看到的，我们正在从`React.Component`接口扩展一个类，类似于我们如何从`HTMLElement`扩展它来创建我们在上一章中的自定义元素，就像自定义元素一样，React组件也有生命周期方法。
- en: 'The react lifecycle methods are called at different stages of a component being
    inserted into the DOM or when it gets updated. The following life cycle methods
    are called (in the exact order) when a component is being inserted into the DOM:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: React生命周期方法在组件被插入到DOM中或更新时的不同阶段被调用。以下生命周期方法在组件被插入到DOM中时被调用（按照确切的顺序）：
- en: constructor()
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: constructor()
- en: componentWillMount()
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: componentWillMount()
- en: render()
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: render()
- en: componentDidMount()
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: componentDidMount()
- en: The following lifecycle methods are called when an update is caused due to change
    of state or props of the component.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 以下生命周期方法在组件状态或属性改变导致更新时被调用。
- en: componentWillReceiveProps()
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: componentWillReceiveProps()
- en: shouldComponentUpdate()
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: shouldComponentUpdate()
- en: componentWillUpdate()
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: componentWillUpdate()
- en: render()
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: render()
- en: componentDidUpdate()
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: componentDidUpdate()
- en: 'There is also a lifecycle method which is called when the component is being
    removed from the DOM:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个生命周期方法在组件从DOM中移除时被调用：
- en: componentWillUnmount()
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: componentWillUnmount()
- en: For a detailed explanation of how each of the lifecycle method works in react,
    refer the following page in react documentation: [https://facebook.github.io/react/docs/react-component.html#the-component-lifecycle](https://facebook.github.io/react/docs/react-component.html#the-component-lifecycle)
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 有关React中每个生命周期方法如何工作的详细解释，请参考React文档中的以下页面：[https://facebook.github.io/react/docs/react-component.html#the-component-lifecycle](https://facebook.github.io/react/docs/react-component.html#the-component-lifecycle)
- en: The `render` method in the preceding `Counter` class is one of the lifecycle
    methods of a React component. As the name suggests, a `render()` method is used
    to render the elements in the DOM. The `render` method is called whenever a component
    is mounted and updated.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的`Counter`类中的`render`方法是React组件的生命周期方法之一。顾名思义，`render()`方法用于在DOM中渲染元素。每当组件被挂载和更新时，都会调用`render`方法。
- en: An update in a React component happens whenever a `state` or `props` of the
    component get changed. We haven't looked at props yet. To detect the change of
    the state variable, React requires the state to be an immutable object.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在React组件中，当`state`或`props`发生变化时会发生更新。我们还没有看过props。为了检测状态变量的变化，React要求状态是不可变对象。
- en: Immutable state
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不可变状态
- en: An immutable object is an object that cannot be changed once it is set! Yup,
    that's right. Once you create that object, there is no going back. That gets you
    wondering *"What if I need to modify a property of that object?"* Well, it's simple;
    you simply create a new object from the old object but with the new property this
    time.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变对象是一旦设置就无法更改的对象！是的，没错。一旦你创建了那个对象，就无法回头了。这让你想知道“如果我需要修改该对象的属性怎么办？”好吧，很简单；你只需从旧对象创建一个新对象，但这次带有新属性。
- en: 'Now, that may seem like a lot of work, but trust me, it is actually better
    to create a new object. Because, most of the time, React simply needs to know
    if the object is changed to update the view. For example:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这可能看起来是很多工作，但相信我，创建一个新对象实际上更好。因为大多数时候，React只需要知道对象是否改变以更新视图。例如：
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This is a standard way of changing the property of a JavaScript object. Here,
    let's call it the mutable way. Great! You just modified the state. But how can
    React know that the state is modified and it should call its lifecycle methods
    to update the DOM elements? Now that's a problem.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这是改变JavaScript对象属性的标准方式。在这里，我们称之为可变方式。太棒了！你刚刚修改了状态。但是React如何知道状态已经修改并且应该调用它的生命周期方法来更新DOM元素呢？现在这是一个问题。
- en: 'To overcome this, the React component has a special method called `setState()`,
    which can update the state in an immutable way and call the required life cycle
    methods (including `render`, which will update the DOM element). Let''s see how
    to update the state in an immutable way:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服这一点，React组件有一个特殊的方法叫做`setState()`，它可以以不可变的方式更新状态并调用所需的生命周期方法（包括`render`，它将更新DOM元素）。让我们看看如何以不可变的方式更新状态：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This will update your state by creating a new state object instead of the older
    one. Now, the old state and new state are two different objects:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这将通过创建一个新的状态对象而不是旧的状态对象来更新你的状态。现在，旧状态和新状态是两个不同的对象：
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: React can now easily check whether the state is changed by a simple comparison
    of two objects, `oldState !== newState`, which will return true if the state is
    changed; therefore, giving a fast update in the view. Comparing objects this way
    is much faster and efficient than iterating over the properties of each object
    and checking whether any property is changed.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: React现在可以通过简单比较两个对象`oldState !== newState`来轻松检查状态是否改变，如果状态改变则返回true，因此在视图中进行快速更新。以这种方式比较对象比迭代每个对象的属性并检查是否有任何属性改变要快得多和更有效率。
- en: The goal of using `setState()` is to call the `render` method, which will update
    the view. Hence, `setState()` should not be used inside the `render` method, or
    else it will result in an infinite loop.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript data types are not immutable; however, working with immutable data
    types are very important and you'll learn more about them soon.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: Props
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Props are data passed to a react component from a parent component. Props are
    similar to states except that props are read-only. You should not change props
    of a component from within the component itself. For example, consider the following
    component:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, the name attribute passed to `ChildrenComponent` element inside the render
    method of `ParentComponent` has become a prop for the `ChildrenComponent`. This
    prop should not be changed by the `ChildrenComponent`. However, if the value is
    changed from the `ParentComponent`, the `ChildrenComponent` will also get re-rendered
    with the new props.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: To learn more about components and props, visit the following page in react
    documentation: [https://facebook.github.io/react/docs/components-and-props.html](https://facebook.github.io/react/docs/components-and-props.html)
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: Building the Counter
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Take a look at the `Counter` class we created before. As the name suggests,
    it should render a counter that increases by 1 every second. For that, we need
    to use `setInterval` to increase the count property of the counter's state object.
    We can use either the `componentWillMount` or `componentDidMount` lifecycle methods
    to add `setInterval`. Since this process does not need any reference to DOM elements,
    we can use `componentWillMount`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `Counter` class, we need to add the following lines of code:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This will automatically perform the increment every second and the `render`
    method will update the required DOM element. To see the counter in action, visit
    the following JSFiddle page: [https://jsfiddle.net/reb5ohgk/](https://jsfiddle.net/reb5ohgk/).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, on the JSFiddle page, look at the External Resources section in the top
    left corner. You should see three resources included in it, as shown in the following
    screenshot:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00037.jpeg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
- en: 'Along with this, in the JavaScript code block, I have selected the language
    as Babel+JSX. If you click on the settings icon in the top right corner of the
    JavaScript section, you will be able to see a set of options as shown in the following
    screenshot:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00038.jpeg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
- en: 'Here''s what the configurations are all about:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: The first JavaScript file I have included is the `react.js` library. The React
    library is the core that is responsible for creating the DOM elements as components.
    However, React renders the components in a *virtual DOM* instead of the real DOM.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The second library I have included is `ReactDOM`. It is used to provide a wrapper
    for React components so that they can be rendered in the DOM. Consider the following
    line:'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This will render the `Counter` component into the `<app></app>` element in the
    DOM using the `ReactDOM.render()` method.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third library is Bootstrap; I just added it for the styles. So, let's look
    into the next step of the configuration.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the JavaScript code block, I have selected the language as Babel + JSX. It
    is because the browsers only know JavaScript. They have no idea about JSX in the
    same way that older browsers didn't have any idea about ES6.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, I just instructed JSFiddle to use the in-browser Babel transformer to compile
    the ES6 and JSX code back to normal JavaScript so that it will work with all the
    browsers.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the real applications, we will use the Webpack and Babel loaders with the
    React preset to compile JSX just as we did for ES6.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By now, you should have a good idea of React So, let's get started with building
    your first React application-a ToDo list-in the next section.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: The React crash course
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to spend 10 minutes building your first React
    application. For this section, you don't need any text editor because you will
    be building the app in JSFiddle!
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将花费10分钟构建你的第一个React应用程序。在本节中，你不需要任何文本编辑器，因为你将在JSFiddle中构建应用程序！
- en: Get started by visiting the JSFiddle page at: [https://jsfiddle.net/uhxvgcqe/](https://jsfiddle.net/uhxvgcqe/),
    where I have set up all the libraries and configurations needed for building a
    React application. You should write the code for the React crash course section
    in this page.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 通过访问JSFiddle页面[https://jsfiddle.net/uhxvgcqe/](https://jsfiddle.net/uhxvgcqe/)开始。我已经在这个页面中设置了构建React应用程序所需的所有库和配置。你应该在这个页面中为React速成课程部分编写代码。
- en: 'This page has React and `ReactDOM` available as the properties of a window
    object (global scope), since I have included these libraries in the external resources.
    We''ll also create a component object from the React object. In ES6, there is
    a trick to obtain properties or methods of an object into standalone variables.
    Look at the following example:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这个页面有React和`ReactDOM`作为window对象（全局范围）的属性可用，因为我已经在外部资源中包含了这些库。我们还将从React对象创建一个组件对象。在ES6中，有一个技巧可以将对象的属性或方法获取为独立的变量。看下面的例子：
- en: '[PRE11]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This will now create two new constants, `fourWheeler` and `twoWheeler`, from
    the vehicle object''s respective properties. This is called a destructuring assignment
    and it works with both objects and arrays. Following the same principle, in the
    first line of your JSFiddle, add the following code:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将从车辆对象的相应属性中创建两个新的常量`fourWheeler`和`twoWheeler`。这被称为解构赋值，它适用于对象和数组。遵循相同的原则，在你的JSFiddle的第一行中，添加以下代码：
- en: '[PRE12]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This will create the component object from the component property of the React
    object. Followed by that, I have included an `<app></app>` element in the HTML
    section, which is where we are going to render our React component. So, create
    a reference to the `<app>` element using the following line of code:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这将从React对象的组件属性创建组件对象。在HTML部分中，我已经包含了一个`<app></app>`元素，这是我们将渲染我们的React组件的地方。因此，使用以下代码创建对`<app>`元素的引用：
- en: '[PRE13]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let''s create a stateful app component that will render our ToDo list. In the
    JSFiddle, type the following code:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个有状态的应用组件，它将渲染我们的待办事项列表。在JSFiddle中，输入以下代码：
- en: '[PRE14]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Outside the class, add the following code block that will render the React
    component in the DOM:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在类外部，添加以下代码块，它将在DOM中渲染React组件：
- en: '[PRE15]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now, click Run in the top left corner of the JSFiddle page. Your app should
    now look like this: [https://jsfiddle.net/uhxvgcqe/1/](https://jsfiddle.net/uhxvgcqe/1/).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，点击JSFiddle页面左上角的运行。你的应用程序现在应该看起来像这样：[https://jsfiddle.net/uhxvgcqe/1/](https://jsfiddle.net/uhxvgcqe/1/)。
- en: For more information and usage details regarding destructuring assignments,
    visit the following MDN page: [https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 有关解构赋值的更多信息和用法详情，请访问以下MDN页面：[https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment)。
- en: Adding and managing states
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加和管理状态
- en: 'The most important part of a stateful React component is its state, which provides
    the required data to render the DOM elements. For our application, we need two
    state variables: one containing the array of tasks while another containing the
    input value of the text field. Being a fully functional representation, we always
    need to maintain a state for every view change, including the value of input fields.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有状态的React组件最重要的部分是它的状态，它提供了渲染DOM元素所需的数据。对于我们的应用程序，我们需要两个状态变量：一个包含任务数组，另一个包含文本字段的输入值。作为一个完全功能的表示，我们总是需要为每个视图更改维护一个状态，包括输入字段的值。
- en: 'In your `App` class, add the following lines of code:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的`App`类中，添加以下代码行：
- en: '[PRE16]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This will add a constructor to the class, where we should make a call to `super()`
    first, since our class is an extended class. `super()` will call the constructor
    for the `Component` interface. In the next line, we have created the state variable's
    tasks and `inputValue`. `tasks` is an array, which will contain an array of strings
    with task names.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这将向类添加一个构造函数，在构造函数中，我们应该首先调用`super()`，因为我们的类是一个扩展类。`super()`将调用`Component`接口的构造函数。在下一行，我们创建了状态变量`tasks`和`inputValue`。`tasks`是一个数组，它将包含一个包含任务名称的字符串数组。
- en: Managing the state for the input field
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理输入字段的状态
- en: 'First, we''ll attach the `inputValue` state with the input field. Inside your
    `render()` method, add the value attribute for the input JSX element, as shown
    in the following code:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将把`inputValue`状态与输入字段关联起来。在你的`render()`方法中，添加输入JSX元素的value属性，如下所示：
- en: '[PRE17]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We have explicitly binded the value of the input field with the state variable.
    Now, try clicking Run and editing the input field. You should not be able to edit
    it.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经明确地将输入字段的值与状态变量绑定在一起。现在，尝试点击运行并编辑输入字段。你不应该能够编辑它。
- en: This is because no matter what you type into this field, the `render()` method
    will simply render what we have specified in the `return()` statement, which is
    an input field with empty `inputValue`. So, how do we change the value of the
    input field? By adding an `onChange` attribute to the input field. Let me show
    you how.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为无论你在这个字段中输入什么，`render()`方法都只会渲染我们在`return()`语句中指定的内容，即一个带有空`inputValue`的输入字段。那么，我们如何改变输入字段的值呢？通过向输入字段添加一个`onChange`属性。让我向你展示如何做。
- en: 'Inside the `App` class, add the following lines of code in the position, as
    I have specified in the following code block:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在`App`类中，在我指定的位置添加以下代码行：
- en: '[PRE18]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This `handleChange` method will receive our typing event and will update the
    state based on the value of the event's target, which should be the input field.
    Note that, in the constructor, I have binded the `this` object with the `handleChange`
    method. This saves us the trouble of having to use `this.handleChange.bind(this)`
    inside the JSX elements.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`handleChange`方法将接收我们的输入事件，并根据事件目标的值更新状态，事件目标应该是输入字段。请注意，在构造函数中，我已经将`this`对象与`handleChange`方法绑定。这样我们就不必在JSX元素内使用`this.handleChange.bind(this)`了。
- en: 'Now, we need to add the `handleChange` method to the `onChange` attribute of
    the input element. In your JSX, add the `onChange` attribute to the input element,
    as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要将`handleChange`方法添加到输入元素的`onChange`属性中。在您的JSX中，将`onChange`属性添加到输入元素，如下所示：
- en: '[PRE19]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Click Run and you should be able to type in the input field again. But this
    time, your `inputValue` state gets updated every time you are editing the input
    field. Your JSFiddle should now look like this: [https://jsfiddle.net/uhxvgcqe/2/](https://jsfiddle.net/uhxvgcqe/2/).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 点击运行，您应该能够再次在输入字段中输入。但是这次，每当您编辑输入字段时，您的`inputValue`状态都会得到更新。您的JSFiddle现在应该看起来像这样：[https://jsfiddle.net/uhxvgcqe/2/](https://jsfiddle.net/uhxvgcqe/2/)。
- en: This is the React's one-way data flow (or one-way data binding), where data
    only flows in one direction, from the state to the `render` method. Any events
    in the rendered components will have to trigger an update to the state to update
    the view. Also, the state should only be updated in an immutable way using the
    `this.setState()` method.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这是React的单向数据流（或单向数据绑定），其中数据只从状态流向`render`方法。渲染组件中的任何事件都必须触发对状态的更新以更新视图。此外，状态应该只以不可变的方式使用`this.setState()`方法进行更新。
- en: Managing the state for the tasks
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理任务的状态
- en: 'The second state that we need to maintain in our app is the `tasks` array.
    Currently, we have an unordered list of sample tasks. Add those tasks as strings
    inside the `tasks` array. Your `state` object inside the constructor should now
    look as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用中需要维护的第二个状态是`tasks`数组。目前，我们有一个示例任务的无序列表。将这些任务作为字符串添加到`tasks`数组中。您构造函数中的`state`对象现在应该如下所示：
- en: '[PRE20]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, let''s populate the tasks from the state. In your `render` method, inside
    the `<ul>` element, remove all the `<li>` elements and replace them with the following:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们从状态中填充任务。在您的`render`方法中，在`<ul>`元素内，删除所有`<li>`元素，并用以下内容替换它们：
- en: '[PRE21]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The curly braces `{}` in JSX only accept expressions that return a direct value
    just like `${}` in template literals. Hence, we can use the array's map method
    that returns an array of JSX elements. Whenever we return JSX elements as arrays,
    we should add a `key` attribute with a unique value, which is used by React for
    identifying that element in the array.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在JSX中的花括号`{}`只接受返回直接值的表达式，就像模板文字中的`${}`一样。因此，我们可以使用数组的map方法返回JSX元素的数组。每当我们将JSX元素作为数组返回时，我们应该添加一个带有唯一值的`key`属性，React用它来识别数组中的元素。
- en: 'So, in the preceding code, we need to perform the following steps:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在上述代码中，我们需要执行以下步骤：
- en: We iterate over the `tasks` array of the `state` and return the list items as
    an array of the JSX elements using the `map()` method of the array.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们遍历`state`的`tasks`数组，并使用数组的`map()`方法将列表项作为JSX元素的数组返回。
- en: For the unique value of the `key` attribute, we are using the `index` of each
    element in the array.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于`key`属性的唯一值，我们使用数组中每个元素的`index`。
- en: Click Run and your code should produce the same output as before, except that
    the tasks are now populated from the state. Your code should now look like this: [https://jsfiddle.net/uhxvgcqe/3/](https://jsfiddle.net/uhxvgcqe/3/).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 点击运行，您的代码应该产生与之前相同的输出，只是任务现在是从状态中填充的。您的代码现在应该看起来像这样：[https://jsfiddle.net/uhxvgcqe/3/](https://jsfiddle.net/uhxvgcqe/3/)。
- en: Adding new tasks
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加新任务
- en: 'Our final step in the app is to allow users to add a new task. Let''s make
    it simple by adding a new task on hitting *Enter* or *return* on the keyboard.
    To detect the *Enter* button, we need to use an attribute on the input field similar
    to `onChange`, but it should happen before the `onChange` event. `onKeyUp` is
    one such attribute that gets called when the key is pressed and released by the
    user on the keyboard. It also happens before the `onChange` event. First create
    the method that will handle the keyup process:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用的最后一步是允许用户添加一个新任务。通过在键盘上按*Enter*或*return*来简化。要检测*Enter*按钮，我们需要在输入字段上使用一个类似于`onChange`的属性，但它应该发生在`onChange`事件之前。`onKeyUp`就是这样一个属性，当用户在键盘上按下并释放键时会调用它。它也会在`onChange`事件之前发生。首先创建处理键盘按键过程的方法：
- en: '[PRE22]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Here''s how the `handleKeyUp` method will work:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`handleKeyUp`方法的工作原理如下：'
- en: First, it will check whether `keyCode` of the event is `13`, which is `keyCode`
    for *Enter *(for Windows) and *return* (for Mac) keys. Then, it will check whether
    `this.state.inputValue` is available. Otherwise, it will throw an alert saying
    `'Please add a Task'`.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，它将检查事件的`keyCode`是否为`13`，这是*Enter*的`keyCode`（对于Windows）和*return*（对于Mac）键。然后，它将检查`this.state.inputValue`是否可用。否则，它将抛出一个警报，显示'请添加一个任务'。
- en: The second and the most important part here is updating the array without mutating
    the state. Here, I have used the spread syntax to create a new tasks array and
    update the state.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二个也是最重要的部分是更新数组而不改变状态。在这里，我使用了扩展语法来创建一个新的任务数组并更新状态。
- en: 'In your `render` method, again modify the input JSX element into the following:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的`render`方法中，再次修改输入JSX元素为以下内容：
- en: '[PRE23]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now, click Run, type a new task, and hit *Enter*. You should see that a new
    task gets added to the ToDo list. Your code should now look like [https://jsfiddle.net/uhxvgcqe/4/](https://jsfiddle.net/uhxvgcqe/4/),
    which is the completed code for the ToDo list. Before we discuss the advantages
    of using React here, let's take a look into the spread syntax we used for adding
    a task.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，点击运行，输入一个新任务，然后按*Enter*。您会看到一个新任务被添加到待办事项列表中。您的代码现在应该看起来像[https://jsfiddle.net/uhxvgcqe/4/](https://jsfiddle.net/uhxvgcqe/4/)，这是待办事项列表的完成代码。在我们讨论在这里使用React的优势之前，让我们看一下我们用于添加任务的扩展语法。
- en: Preventing mutations using the spread syntax
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用扩展语法防止突变
- en: 'In JavaScript, arrays and objects are passed by reference during an assignment.
    For example, open a new JSFiddle window and try the following code:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，数组和对象在赋值过程中是按引用传递的。例如，打开一个新的JSFiddle窗口，尝试以下代码：
- en: '[PRE24]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We are creating a new array `b` from array `a`. We then push a new value `5`
    into array `b`. If you look at the console, your output will be as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从数组`a`创建一个新数组`b`。然后我们向数组`b`中推入一个新值`5`。如果您查看控制台，输出将如下所示：
- en: '![](../images/00039.jpeg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00039.jpeg)'
- en: Surprisingly, both arrays have been updated. This is what I meant by passing
    by a reference. Both `a` and `b` are holding the reference to the same array,
    which means updating either one of them will update both. This holds true for
    both arrays and objects. This means we will evidently *mutate the state* if we
    use a normal assignment.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 令人惊讶的是，两个数组都已更新。这就是我所说的按引用传递。`a`和`b`都持有对同一数组的引用，这意味着更新它们中的任何一个都会更新两者。这对数组和对象都成立。这意味着如果使用普通赋值，我们显然会*改变状态*。
- en: 'However, ES6 comes with a *spread syntax* for arrays and objects. I have used
    this in the `handleKeyUp` method, where I am creating a `newTask` array from `this.state.tasks
    array`. In the JSFiddle window where you tried the preceding code, change the
    code into the following:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，ES6提供了用于数组和对象的*扩展语法*。我在`handleKeyUp`方法中使用了这个语法，其中我从`this.state.tasks`数组创建了一个`newTask`数组。在您尝试了上述代码的JSFiddle窗口中，将代码更改为以下内容：
- en: '[PRE25]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: See how I have created a new array `b` this time. The three dots `...` (known
    as the spread operator) are used to expand all the elements in the array `a`.
    Along with it, a new element `5` is added, and a new array is created and is assigned
    to `b`. This syntax might be confusing at first but it is how we should update
    array values in React, since this will create a new array (in an immutable way).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 看看这次我是如何创建一个新数组`b`的。三个点`...`（称为扩展运算符）用于展开数组`a`中的所有元素。除此之外，还添加了一个新元素`5`，并创建了一个新数组并将其分配给`b`。这种语法起初可能会令人困惑，但这是我们在React中更新数组值的方式，因为这将以不可变的方式创建一个新数组。
- en: 'Likewise, for objects, you should do the following:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，对于对象，您应该执行以下操作：
- en: '[PRE26]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: I have created a fiddle with the spread operators in [https://jsfiddle.net/bLo4wpx1/](https://jsfiddle.net/bLo4wpx1/).
    Feel free to play with it to understand the working of the spread syntax, which
    we will be using very often in this chapter and in the next.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我在[https://jsfiddle.net/bLo4wpx1/](https://jsfiddle.net/bLo4wpx1/)中创建了一个带有扩展运算符的小玩意。随时玩玩它，以了解扩展语法的工作方式，我们将在本章和下一章中经常使用它。
- en: For more practical examples of using the spread syntax, visit the MDN page [https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Spread_operator](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Spread_operator).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多使用扩展语法的实际示例，请访问MDN页面[https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Spread_operator](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Spread_operator)。
- en: Advantages of using React
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用React的优势
- en: We have built a ToDo list app within 10 minutes using React. At the beginning
    of this chapter, we discussed why we need a JavaScript framework and the disadvantages
    of using plain JavaScript. In this section, let's look at how React overcomes
    those factors.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在10分钟内使用React构建了一个待办事项列表应用。在本章的开头，我们讨论了为什么需要JavaScript框架以及使用纯JavaScript的缺点。在本节中，让我们看看React是如何克服这些因素的。
- en: Performance
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能
- en: DOM updates are costly. Repaints and reflows are synchronous events and therefore,
    they need to be minimized as much as possible. React deals with this scenario
    by maintaining a virtual DOM, which makes React applications really fast.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: DOM更新是昂贵的。重绘和回流是同步事件，因此需要尽量减少。React通过维护虚拟DOM来处理这种情况，使得React应用程序非常快速。
- en: Whenever we make a modification to the JSX element in the `render` method, React
    will update the virtual DOM instead of the real DOM. Updating the virtual DOM
    is fast, efficient, and much less expensive than updating the real DOM and only
    the elements that are changed in the virtual DOM will be modified in the actual
    DOM. React does this by using a smart diffing algorithm, which we mostly won't
    have to worry about.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们对`render`方法中的JSX元素进行修改时，React将更新虚拟DOM而不是真实DOM。更新虚拟DOM是快速、高效的，比更新真实DOM要便宜得多，只有虚拟DOM中更改的元素才会在实际DOM中被修改。React通过使用智能差异算法来实现这一点，我们大多数时候不必担心。
- en: 'To understand how React works in detail and its performance, you can read the
    following articles from the React documentation:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 要详细了解React的工作原理和性能，您可以阅读React文档中的以下文章：
- en: '[https://facebook.github.io/react/docs/reconciliation.html](https://facebook.github.io/react/docs/reconciliation.html)'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://facebook.github.io/react/docs/reconciliation.html](https://facebook.github.io/react/docs/reconciliation.html)'
- en: '[https://facebook.github.io/react/docs/optimizing-performance.html](https://facebook.github.io/react/docs/optimizing-performance.html)'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://facebook.github.io/react/docs/optimizing-performance.html](https://facebook.github.io/react/docs/optimizing-performance.html)'
- en: Maintainability
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可维护性
- en: React shines great in this section, since it neatly organizes the application
    into states and corresponding JSX elements grouped as components. In the ToDo
    list app, we only used a single stateful component. But we can divide its JSX
    into smaller stateless child components too. This means any modification in the
    child components will not affect the parent. Therefore, the core functionality
    will not get affected even if we modify what the list looks like.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: React在这一部分表现出色，因为它将应用程序整齐地组织为状态和相应的JSX元素分组为组件。在待办事项列表应用中，我们只使用了一个有状态的组件。但是我们也可以将其JSX分成较小的无状态子组件。这意味着对子组件的任何修改都不会影响父组件。因此，即使我们修改列表的外观，核心功能也不会受到影响。
- en: Check out the JSFiddle at: [https://jsfiddle.net/7s28bdLe/](https://jsfiddle.net/7s28bdLe/),
    where I have organized the list items in a ToDo list as smaller child components.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 查看JSFiddle：[https://jsfiddle.net/7s28bdLe/](https://jsfiddle.net/7s28bdLe/)，在那里我将待办事项列表项组织为较小的子组件。
- en: This is really useful in a team environment, where everyone can create their
    own components and they can be easily reused by others, which will boost the developer's
    productivity.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这在团队环境中非常有用，每个人都可以创建自己的组件，并且可以很容易地被其他人重用，这将提高开发人员的生产力。
- en: Size
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 大小
- en: React is small. The entire React library is just around 23 KB when minified,
    while `react-dom` is around 130 KB. This means it does not cause any serious problems
    on page load times even on slow 2G/3G connections.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: React很小。整个React库在最小化时只有大约23 KB，而`react-dom`大约为130 KB。这意味着即使在2G/3G连接缓慢的情况下，它也不会对页面加载时间造成严重问题。
- en: Building a blog with React
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用React构建博客
- en: The objective of this section is to learn the basics of React and how it is
    being used in web applications by building a simple blog application. So far,
    we have been learning about React but now it's time to see how it is used in real
    web applications. React will work fine in our development environment, which we
    have been using in this book so far, except that we need to add an additional
    `react` preset to `babel-loader`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的目标是通过构建一个简单的博客应用程序来学习React的基础知识以及它在Web应用程序中的使用方式。到目前为止，我们一直在学习React，但现在是时候看看它在真实Web应用程序中的使用方式了。React将在我们迄今为止在本书中使用的开发环境中正常工作，只是我们需要向`babel-loader`添加一个额外的`react`预设。
- en: But `react-community` has come up with a better solution, which is the `create-react-app`
    command-line tool. Basically, this tool creates your project with all the necessary
    development tools, Babel compilers, and plugins so that you need to focus only
    on writing code without worrying about Webpack configurations.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 但`react-community`提出了一个更好的解决方案，即`create-react-app`命令行工具。基本上，这个工具会使用所有必要的开发工具、Babel编译器和插件为您创建项目，这样您就可以专注于编写代码，而不必担心Webpack配置。
- en: '`create-react-app` recommends using yarn instead of npm while working on React,
    but since we are very familiar with npm, we will not use yarn in this chapter.
    If you want to learn about yarn, visit: [https://yarnpkg.com/en/](https://yarnpkg.com/en/).'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`create-react-app`建议在使用React时使用yarn而不是npm，但由于我们对npm非常熟悉，所以在本章中我们不会使用yarn。如果您想了解有关yarn的信息，请访问：[https://yarnpkg.com/en/](https://yarnpkg.com/en/)。'
- en: 'To see how `create-react-app` works, first let''s install the tool globally
    using npm. Open up your Terminal and type the following command (Since this is
    a global install it will work from any directory):'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解`create-react-app`的工作原理，首先让我们使用npm全局安装该工具。打开终端并输入以下命令（由于这是全局安装，它将从任何目录中工作）：
- en: '[PRE27]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Linux users might have to add the `sudo` prefix. Once it is installed, you
    can create a boilerplate for your React project by running a simple command:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Linux用户可能需要添加`sudo`前缀。安装完成后，您可以通过运行简单的命令为您的React项目创建一个样板：
- en: '[PRE28]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This command will take a while, since it has to create a `my-react-project`
    directory and install all the npm dependencies for your React development environment.
    Once the command is complete, you can run the application using the following
    commands in the Terminal:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令会花一些时间，因为它必须创建一个`my-react-project`目录，并为您的React开发环境安装所有npm依赖项。命令完成后，您可以在终端中使用以下命令运行应用程序：
- en: '[PRE29]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This will start the React development server and will open the browser that
    will display a welcome page built with React, as shown in the following screenshot:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动React开发服务器，并打开浏览器显示一个用React构建的欢迎页面，如下面的屏幕截图所示：
- en: '![](../images/00040.jpeg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00040.jpeg)'
- en: 'Let''s see how the files are organized in the project. The project root folder
    will have files arranged in the following structure:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看项目中文件是如何组织的。项目根目录将按以下结构排列文件：
- en: '[PRE30]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The public folder will contain the `index.html` file, which contains the `div#root`
    element to which our React component will get rendered to. Also, it contains the
    `favicon` and `manifest.json` file, which provides information to the Android
    devices when the web page is added to the home screen (commonly used in progressive
    web apps).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 公共文件夹将包含`index.html`文件，其中包含我们的React组件将呈现到的`div#root`元素。此外，它还包含`favicon`和`manifest.json`文件，当网页添加到主屏幕时向Android设备提供信息（在渐进式Web应用程序中常用）。
- en: 'The `src` directory contains the source files of our React application. The
    file structure of the `src` directory will be as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`src`目录包含我们的React应用程序的源文件。`src`目录的文件结构将如下所示：'
- en: '[PRE31]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `index.js` file is the entry point of the application, where it simply renders
    the `App` component from the `App.js` file in the `index.html` file present in
    the public directory. We write our primary `App` component in the `App.js` file.
    All the other components in the application will be children of the `App` component.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`index.js`文件是应用程序的入口点，它简单地在公共目录中的`index.html`文件中呈现`App.js`文件中的`App`组件。我们在`App.js`文件中编写我们的主要`App`组件。应用程序中的所有其他组件都将是`App`组件的子组件。'
- en: So far, we have been building multipage applications using JavaScript. But now,
    we are going to build a single page application using React. A **Single Page Application**
    (**SPA**) is one in which all the assets of the application get loaded initially
    and then it will work like a normal app on the user's browser. SPAs are the trend
    now, since they provide a great user experience across various devices for the
    users.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用JavaScript构建多页面应用程序。但现在，我们将使用React构建单页面应用程序。**单页面应用程序**（**SPA**）是指应用程序的所有资产最初都会加载，然后在用户浏览器上像普通应用程序一样工作。SPA现在是趋势，因为它们为用户在各种设备上提供了良好的用户体验。
- en: For building a SPA in React, we need a library to manage navigation between
    pages (components) in the app. `react-router` is one such library that will help
    us manage navigation between the pages (routing) in the app.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 要在React中构建SPA，我们需要一个库来管理应用程序中页面（组件）之间的导航。`react-router`就是这样一个库，它将帮助我们管理应用程序中页面（路由）之间的导航。
- en: 'Just as in the other chapters, our blog will also be responsive on mobile devices.
    Let''s take a look at the blog application we are about to build:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 就像其他章节一样，我们的博客在移动设备上也是响应式的。让我们来看看我们即将构建的博客应用程序：
- en: '![](../images/00041.jpeg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00041.jpeg)'
- en: For this application, we are going to have to write a lot of code. Hence, I
    have already prepared the starter files for you to use. Instead of starting from
    the `create-react-app` tool, you should start from the starter files inside the
    `Chapter06` folder of the book codes.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: 'Along with React and `react-dom`, the starter files contain the following libraries:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: React Router: [https://reacttraining.com/react-router/](https://reacttraining.com/react-router/)
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reactstrap: [https://reactstrap.github.io/](https://reactstrap.github.io/)
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: uuid: [https://www.npmjs.com/package/uuid](https://www.npmjs.com/package/uuid)
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The server that provides the API for the blog is available in the book code
    `Chapter06\Server` directory. You should keep this server running while building
    the application. I highly recommend you to see the completed application before
    starting to build the blog.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '`create-react-app` supports reading environment variables from the `.env` file
    straight out of the box; however, with the condition that all environment variables
    should be prefixed with the `REACT_APP_` keyword. For more information, read: [https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/README.md#adding-custom-environment-variables](https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/README.md#adding-custom-environment-variables).'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: 'To run the completed application, perform the following steps:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: Start the server first by running `npm install`, followed by `npm start` inside
    the server's directory.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It will print the URL that should be added to the `.env` file of `Chapter 6\completedCode`
    files in the console.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside `Chapter 6\CompletedCode` files, create the `.env` file using the `.env.example`
    file and paste the URL printed in the first line of the console output as the
    value of `REACT_APP_SERVER_URL`.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate inside the book code `Chapter 6\CompletedCode` files directory in your
    Terminal and run the same `npm install` and `npm start` commands.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It should open the blog on your browser. If it didn't open the blog, then manually
    open `http://localhost:3000/` on your browser.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'I have also created an API documentation using swagger for the server. To access
    the API documentation, while your server is running, it will print the documentation
    URL in the second line of console output. Simply open the URL in your browser.
    In the documentation page, click on the default group and you should see a list
    of API endpoints, as shown in the following screenshot:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00042.jpeg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
- en: 'You can see all the information regarding the API endpoints and even try them
    out by clicking on the API and then clicking Try it out:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00043.jpeg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
- en: Take your time. Visit all the sections of the completed blog, try out all the
    APIs in the swagger document, and learn how it works. Once you are done with them,
    we'll move onto the next section, where we will start building the app.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: Creating the navigation bar
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Hope you tried the app. Currently, I have set the server to respond only after
    3 seconds; therefore, you should see a loading indicator while trying to navigate
    between the pages.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: 'The one thing common across all the pages in this application is the top navigation
    bar:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00044.jpeg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
- en: 'In the previous chapters, we created the navigation bar easily using Bootstrap.
    However, we can''t use Bootstrap here because, in React, all the DOM elements
    are rendered dynamically through components. Bootstrap, however, requires jQuery,
    which only works on a normal DOM so that it can display animations while clicking
    the hamburger menu when the navbar is viewed on mobiles, as shown in the following
    screenshot:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00045.gif)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
- en: However, several libraries are available which will let you use Bootstrap in
    React by providing the equivalent React components to each Bootstrap styled element.
    In this project, we are going to use one such library called the reactstrap. It
    requires Bootstrap 4 (alpha 6) to be installed with it; therefore, I have also
    installed Bootstrap 4 in the project's starter files.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: Now, navigate to the book code `Chapter06\Starter files` directory and create
    the `.env` file in the project root directory. The `.env` file should have the
    same value as the completed code files for `REACT_APP_SERVER_URL`, which is the
    URL printed by the server in the console.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: From the starter files directory in your Terminal, run `npm install`, followed
    by `npm start`. It should start the development server for the starter files.
    It will open the browser, which displays the message "The app goes here...". Open
    the folder in VSCode and see the `src/App.js` file. It should contain that message
    in the `render` method.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: The starter files will be compiled with a lot of warnings saying no-unused-vars.
    It is because I have already included the import statements in all the files but
    none of them are yet used. Therefore, it is telling you that there are a lot of
    unused variables. Just ignore the warnings.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top of your `App.js` file, you should see that I have imported some
    modules from the reactstrap library. They are all React components:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Explaining about each of the components here is not important, since this chapter
    focuses on learning React more than styling React components. Therefore, to learn
    about reactstrap, visit the project homepage at: [https://reactstrap.github.io/](https://reactstrap.github.io/).
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: 'In your `App` class, in the `App.js` file, replace the `return` statement of
    the `render` method with the following:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The preceding code will make use of the reactstrap components and will create
    a top navigation bar for the blog just like in the completed project. Check out
    the page in responsive design mode in Chrome to see how it looks on mobile devices.
    In the responsive design mode, the hamburger menu won't work.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: 'This is because we haven''t created any states and methods to manage expanding
    and collapsing the navigation bar. In your `App` class, add the following constructor
    and method:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This will add the state variable, `isOpen`, used for identifying the open/closed
    state of the hamburger menu, while the toggle method is used to expand or collapse
    the hamburger menu by changing the value of the `isOpen` state to `true` or `false`.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: 'To bind these in your navigation bar, in the `render` method, perform the following
    steps:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: 'Replace the `false` value of the `isOpen` attribue in the line with the `<Collapse
    isOpen={false} navbar>` component with `this.state.isOpen`. The line should now
    look as follows:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Replace the empty function `()=>{}` value of the `onClick` attribute in the
    line including `<NavbarToggler right onClick={()=>{}}` `/>` with `this.toggle`.
    The line should now look as follows:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Once you add these lines and save the file, the hamburger button in the navigation
    bar will work fine in your browser. However, clicking on the links in the navigation
    bar will only reload the page. We cannot do regular navigation using anchor tags
    in a single page application, since there is only a single page that the app is
    going to display. In the next section, we'll see how to implement navigation between
    pages using the React Router library.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: Implementing routing and navigation using React Router
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React Router implements routing by displaying the components based on the URL
    the user visits in your web application. React Router can be used in both React.js
    and React Native. However, since we are only focusing on React.js, we should use
    the specific React Router library, `react-router-dom`, that handles routing and
    navigation on the browser.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: The first step to implement React Router is to wrap the entire `App` component
    inside a `<BrowserRouter>` component from `react-router-dom`. To wrap the entire
    application, open the `src/index.js` file in your project directory in VSCode.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top of the `index.js` file, add the following import statement:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This will import the `BrowserRouter` component with the name router. Once you
    have added the import statement, replace the `ReactDOM.render()` line with the
    following code:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This simply wraps the `<App />` component inside the `<Router>` component, which
    will allow us to use React Router in the rest of the `App` component's child components.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: The routes file
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the starter files, I have included a `routes.js` file in the `src/routes.js`
    path. This file contains all the routes we are going to use on our blog in the
    form of JSON objects:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'See the home page of the completed blog app. The URL will be pointing to the
    `''/home''` route. Likewise, each page has its respective route. However, some
    routes have dynamic values. For example, if you click Read More in a blog post,
    it will take you to the page with the URL:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Here, the third part of the URL is the post's ID. To represent such URLs, I
    have used `'/post/:id'` in the routes file, where the ID means that React Router
    will understand that the ID will be a dynamic value.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: You don't really have to manage all your routes in a single routes file. I have
    created a routes file so that it will be easier for you to add the routes while
    building the application.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: Adding routes in the app component
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What React Router does is pretty much simple; it simply renders a component
    based on the URL in the address bar. It uses history and location Web APIs for
    this purpose, but gives us simple, easy to use, component-based APIs, so that
    we can quickly set up our routing logic.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: 'To add navigation between the components in the `App.js` file, add the following
    code in the `App.js` file''s `render` method after the `<Navbar></Navbar>` component:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Also, refer to the completed code files if you face any issues after adding
    the code files. I have already added all the import statements in the `App.js`
    file. Route component is imported from the `react-router-dom` package. Here''s
    what the preceding route component does:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: 'The route component will check the URL of the current page and render the component
    that matches with the given path. Take a look at the following Route:'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: React Router will render the `Home` component when your URL has the path `'/home'`
    (the value of `routes.home` from the routes file).
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s what each of its attributes means:'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`exact`: Only when the path is matched exactly. This is optional if it is not
    present in `''/home''`: It will hold true for `''/home/otherpaths''` too. We need
    the exact match; hence, I have included it.'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`path`: The path that must be matched with the URL. In our case, it is `''/home''`
    from the `routes.home` variable from the routes file.'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`component`: The component that must be rendered when the path matches with
    the URL.'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once you have added the route components, navigate back to the application in
    Chrome. If your application is running in `http://localhost:3000/`, you will only
    see a blank page. However, if you click on the menu items in the navigation bar,
    you should see the respective components being rendered on the page!
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: By adding the navigation bar outside the route components, we can easily reuse
    the same navigation bar across the entire application.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: However, we should have our application automatically navigate to the home page
    `'/home'` instead of displaying a blank page on the first load. To do that, we
    should programmatically replace the URL with the required `'/home'` path like
    we did in [Chapter 4](part0099.html#2UD7M0-f852807d0cb141b58fff8f992d32cbb7),
    *Real-Time Video Call App with WebRTC*, using the history object.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: But we have a problem here. React Router maintains its own history object for
    navigation. This means we need to modify the history object of the React Router.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: Managing history using withRouter
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'React Router has an `higher-order` component called `withRouter` with which
    we can pass in the React Router''s history, location, and match objects to our
    React components as props. To use `withRouter`, you should wrap your `App` component
    inside `withRouter()` as a parameter. Currently, here''s how we are exporting
    the `App` component at the last line of the `App.js` file:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'You should change this line to the following:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This will supply three props, `history`, `location`, and the `match` object
    to our `App` component. For our initial objective, displaying the home component
    by default, add the following `componentWillMount()` method to the `App` class:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Here''s what the preceding code does:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: Since it is written inside `componentWillMount`, it will get executed before
    the `App` component gets rendered.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It will check the path of the URL using the `location.pathname` property.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the path is `'/'`, that is, the default `http://localhost:3000/`, it will
    automatically replace the history and URL with `http://localhost:3000/home`.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This way, the `home` component will be automatically rendered whenever the user
    navigates to the root URL of the web page.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, open `http://localhost:3000/` on your browser and it will display the homepage.
    Still, we have another problem here. Every time we click a link in the navigation
    bar, it is causing the page to reload. Since our blog is a single page app, reloading
    should be avoided, as all the assets and components are already downloaded. Reloading the
    application on every click during navigation will only lead to unnecessarily downloading
    the entire app multiple times.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: Proptype validation
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whenever we are passing props to our React components, it is recommended to
    do proptype validation. A proptype validation is a simple type checking that happens
    in the development builds of React, which is used to check whether all the props
    are supplied properly to our React component. If not, it will display a warning
    message, which is very helpful for debugging.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: 'All types of props that can be passed to our React component are defined in
    the `''prop-types''` package, which gets installed along with `create-react-app`.
    You can see that I have included the following import statement at the top of
    the file:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'To do proptype validation for our `App` component, inside the `App` class,
    add the following static property before the constructor (having proptypes declared
    on top will make it easy to know what props the React component is dependent on):'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Refer the completed code files if you are confused about where to include the
    preceding code snippet. This is how the proptype validation works.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the second line of the preceding code `history: PropTypes.object.isRequired`. This
    means that:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '`history` should be a prop to the `App` component'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The type of `history` should be the object
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `history` prop is required (`isRequired` is optional and can be removed
    for props, that are optional)
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For detailed information on proptype validation, refer to the React documentation
    page at [https://facebook.github.io/react/docs/typechecking-with-proptypes.html](https://facebook.github.io/react/docs/typechecking-with-proptypes.html).
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: Seamless navigation with NavLink
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React Router has a perfect solution to fix the reloading problem during navigation.
    React Router provides `Link` and `NavLink` components, which you should use instead
    of the traditional anchor tags. `NavLink` has more features than the `link` component,
    such as specifying an active class name when the link is active. Therefore, we
    will use `NavLink` in our application.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider the following anchor tag we have used in the `App.js`
    file for navigating to the authors page:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We can replace this with React Router''s `NavLink` component as follows:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Here''s what the attributes of the `NavLink` JSX components do:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: '`className`: The class name given to the element when `NavLink` is rendered
    as an anchor tag in the DOM.'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`activeClassName`: The class name given to the element when the link is the
    currently active page.'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`to`: The path to which the link will navigate to.'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refer to the `App.js` file from the completed code files and replace all the
    anchor tags in the `App.js` file with `NavLink` components. Once you have done
    this change, whenever you click on the menu items in the navigation bar, your
    app will navigate seamlessly without any page reloads.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: Also, since the `.active` class gets added to the active links, Bootstrap styles
    will highlight the menu item in the navigation bar with slightly darker black
    color when the respective navbar menu item is active.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: We have successfully created the navigation bar for our application and implemented
    some basic routing. From our routes file, you can see that our blog has five pages.
    We'll build the home page in the next section.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: Blog home page
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You should already have an idea of how the blog's home page will look from exploring
    the app in the completed code files. Our blog has a simple home page that lists
    all the posts. You can click the Read More button in the posts to read the posts
    in detail. Since this blog is a project for learning purposes, this simple home
    page is enough for now.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: 'Ideally, you should create each React component from scratch. However, to speed
    up the development process, I have already created all the stateless components
    and boilerplates for the stateful parent components. All the components are available
    in the `src/Components` directory. Since the React component names should start
    with capital letters, I have created all the component directory names with initial
    capital letters to indicate that they contain React components. This is the folder
    structure of the `Components` directory:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The home page of our blog is the `Home` component present in the `src/Components/Home/Home.js`
    file. Currently, the `render` method of the `Home` component only renders a `Home` text.
    We need to display the list of posts in the home page. Here''s how we are going
    to achieve this:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: The server has the `/posts` endpoint, which returns all the posts in a `GET`
    request as an array. Therefore, we can use this API to retrieve the post's data.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since `Home` is a stateful component, we need to maintain states for every action
    in the `Home` component.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: While the `Home` component is retrieving data from the server, we should have
    a state--loading, which should be a Boolean value to show the loading indicator.
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the network request is a success, we should store the posts in a state--posts,
    which can then be used to render all the blog posts.
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the network request fails, we should simply use another state--`hasError`,
    which should be a Boolean value to display the error message.
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s get started! First, in your `Home` class, add the following constructor
    to define the state variables of the component:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Once you have defined the states, let's make the network request. Since the
    network request is asynchronous, we can have it in `componentWillMount`, but if
    you want to do a synchronous action, that will delay the render. It is better
    to add it in `componentDidMount`.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: 'For making the network request, I have added the `apiCall` service, which we
    used in the previous chapters in the `src/services/api/apiCall.js` file, and included
    the import statement in the `Home.js` file. Here''s the code for the `componentWillMount`
    method:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Here''s what the preceding function does:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: First, it will set the state variable loading to `true`.
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `apiCall` function is called to make the network request.
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since the network request is an asynchronous function, the `render` method will
    get executed and the component will get rendered.
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After the rendering has happened, the network request will get completed in
    3 seconds (I have set that much delay in the server).
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the `apiCall` is a success and the data is retrieved, it will update the
    post's state with the array of posts returned from the server and will set the
    loading state to `false`.
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Otherwise, it will set the `hasError` state to `true` and will set the loading
    state to `false`.
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To test the preceding code, let''s add the JSX needed to render the posts.
    Since the JSX part requires a lot of code, I have already created the stateless
    components needed for use on this page in the `src/Components/Common` directory
    and included the import statement at the top of the `Home.js` file. Replace the
    `return` statement of the `render` method with the following code:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Once you have added the preceding code snippet, keep your server running and
    visit the blog''s home page. It should list all the posts, as shown in the following
    screenshot:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00046.jpeg)'
  id: totrans-334
  prefs: []
  type: TYPE_IMG
- en: 'However, if you kill the server and reload the page, it will display the error
    message, as shown in the following screenshot:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00047.jpeg)'
  id: totrans-336
  prefs: []
  type: TYPE_IMG
- en: The implementation process is very simple once you get to know how the state
    and life cycle methods work with React. However, we still need to cover one important
    topic in this section, which is the child components that I have created previously
    for you to use.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: Using child components
  id: totrans-338
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s take a look at the `ErrorMessage` component, which I have created to
    show an error message when we are unable to retrieve posts from the server. This
    is how the `ErrorMessage` component is included in the `render` method:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'If the `ErrorMessage` is a stateful component created by extending the `Component`
    interface. The attributes of the `ErrorMessage` JSX element title and message
    will then become the props of the children `ErrorMessage` component. However,
    if you look at the implementation of the `ErrorMessage` element, you will see
    that it is a stateless functional component:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'So, here''s how the attributes work for functional components:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: 'Since functional components do not support state or props, the attributes become
    the parameters of the function call. Consider the following JSX element:'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'This will be equivalent to a function call with an object as its parameter:'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'By using the destructuring assignment you learned earlier, you can use the
    parameters in our function as follows:'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: We can use the `propType` validation for functional components too, but here,
    the `propTypes` are used to validate the function's arguments.
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whenever you are typing the JSX code in a functional component, make sure you
    have included the `import React from` `'react'` statement in the file. Otherwise,
    the Babel compiler will not know how to compile the JSX back to JavaScript.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: The `PostSummary` component comes with a Read More button with which you can
    see the entire post's details on a page. Currently, if you click this link, it
    will simply display the `'Post Details'` text. So, let's finish up our blog home
    page by creating the post details page.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: Displaying post details
  id: totrans-353
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Each post in the blog has a unique ID associated with it. We need to use this
    ID to retrieve the post details from the server. When you click on the Read More
    button, I have created the `PostSummary` component in such a way that it will
    take you to the route `''/post/:id''`, where `:id` contains the ID of the post.
    This is how the post URL will look:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Here, the third section is the post ID. Open the `Post.js` file from the `src/Components/Post/Post.js`
    path in VSCode. We need to access the ID that is present in the URL in our `Post`
    component. To access the URL parameter, we need to use the match object of the
    React Router. For this process, we will have to wrap our `Post` component inside
    `withRouter()` just as we did for the `App` component.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: 'In your `Post.js` file, change the export statement into the following:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Also, since this will provide the `history`, `location`, and `match` props
    to the `Post` component, we should also add the prototype validation to the `Post`
    class:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'We have to create the states for our `Post` component. The states are the same
    as that of the `Home` component; however, instead of the posts state (array),
    we will have the post state (object) here, since this page only requires a single
    post. In the `Post` class, add the following constructor:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'In the swagger document of the server, you should see an API endpoint, `GET
    /post/{id}`, which we are going to use in this chapter for retrieving `Post` from
    the server. The `componentWillMount` method we are going to use in this component
    will be extremely similar to that of the previous `Home` component, except that
    we will have to retrieve the `id` parameter from the URL. This can be done using
    the following line of code:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Here, `this.props.match` is a prop provided to the `Post` component by the
    `withRouter()` component of React Router. So, your `componentWillMount` method
    should be as follows:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Finally, in the `render` method, add the following code:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: This will create the post page. Now, you should be able to see the entire post
    by clicking the Read More button. This page will work in the same way the home
    page does. By using reusable components, you can see that we have minimized the
    code a lot.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: Adding a new blog post
  id: totrans-370
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have successfully built the home page for our blog. The next task is to build
    the author list page. However, I'll leave the construction of the author list
    to you. You can refer to the completed code files and build the author list page.
    This will be a good practice exercise for you.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: 'So, that leaves us with the last page, which is the new post page. The API
    we are going to use for adding a new blog post is POST /post, which you can see
    in the swagger document. The body of the post request will be in the following
    form:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Here, `id` is the unique ID for the blog post and `datetime` is the epoch timestamp
    as a string. Usually, these two properties are generated by the server but since
    we are only using the mock server for our project, we need to generate them on
    the clientside.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `NewPost.js` file from the `src/Components/NewPost/NewPost.js` path.
    This component requires three input fields:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: Author name
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Post title
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Post text
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need to maintain states for these three fields. The blog post will need `textarea`,
    which will dynamically increase its size (rows) as the blog post is typed. Thus,
    we need to maintain a state for the number of lines to manage the row count.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: Along with this, we will also need the states we used in the previous component's
    loading and `hasError` for network requests. We will also need a state success
    for indicating to the user that the post has been submitted successfully.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: 'In your `NewPost` class, create `constructor` with all the required state variables,
    as shown here:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Unlike the previous components, instead of just displaying the retrieved data
    from the server, we will have to send data from input fields to the server in
    this component. Whenever input fields are involved, it means we will need a lot
    of methods to edit the state of the input fields.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: 'Replace the `render` method of your `NewPost.js` file with the `render` method
    from the `NewPost.js` file of the completed code files. Since both the author
    name and title use the same input fields, I have created a simple `PostInputField`
    component for them. Here''s what the `PostInputField` component looks like for
    the author name input:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Here''s what the corresponding `PostInputField` function looks like:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: You can see that I basically made the `className`, `label`, `id`, `value`, and
    `onChange` properties dynamic in the returned JSX element. This will let me reuse
    the entire input field for multiple input elements in the same form. Since the
    final rendered DOM element will have different classes and IDs, but shares the
    same code, all you have to do is import and use it in your component. It will
    save many hours of long development work and, in many cases, it's more efficient
    than the custom elements you learned in the previous chapter.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how `textarea` works.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `render` method, you should see the following line where we are
    creating a `noOfLines` constant using the state variables:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '`this.state.noOfLines` will contain the number of lines present in the blog
    post. Using that, if the number of lines is less than `5`, then we will set the
    value of row attribute to `5`. Otherwise, we can increase the row attribute to
    the number of lines present in the blog post.'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what the JSX for text input looks like:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'You can see that the value of the rows attribute is the `noOfLines` constant
    created in the `render` method. After the textarea field, we have the following
    sections:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: The loading section, where we can either show `<LoadingIndicator />` or the
    Submit button based on the network request state (`this.state.loading`)
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `hasError` and success sections where we can show the success or error message
    depending on the response from the server
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s create the methods used by the input fields for updating their value.
    Inside your `NewPost` class, add the following methods:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Here, `editContent` is the method used by the `textinput` field. You can see
    that I have used a split(`''\n''`) to divide the lines into an array based on
    the newline characters. We can then use the length of the array to count the number
    of lines present in the post. Also, remember to add the `this` binding to all
    the methods in the constructor. Otherwise, the methods called from JSX will not
    be able to use the `this` variable of the class:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Submitting the post
  id: totrans-402
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The last part of the adding posts section is submitting the post. Here, we
    need to do two things: generate a UUID for the post and get the current date and
    time in the epoch timestamp format:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: For generating a UUID for using the ID of the post, I have included the `uuid`
    library. You just have to call `uuidv4()`, which will return the UUID for your
    use.
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For creating the date and time in the `epoch` timestamp format, you can use
    the following code:'
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The Submit button in the JSX is already set to call the `this.submit()` method
    when it is clicked. So, let''s create the `submit` method of the `AddPost` class
    with the following code:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Also, add the following code to your constructor for binding this with the
    Submit button:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'This is what the preceding submit method does:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: It constructs the body of the network request, which is the post we need to
    add, and then makes the request to the POST/post server endpoint.
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the request is a success, it will reset the input fields to an empty string
    using the state variables.
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the request fails, it will simply set the `hasError` state to true, which
    will show us an error message.
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If it works as expected, then click on Home and you should see your new post
    added to the blog. Congratulations! You just successfully built your own blog
    application using React!
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: Do try to build the author list page yourself and get help by referring to the
    completed files if you face any problems while building it.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: Generating production builds
  id: totrans-417
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The one thing that we have been doing in every chapter is to generate the production
    builds. We did this by setting the `NODE_ENV` variable in the `.env` file to `production`
    and then running `npm run webpack` in the Terminal. However, for this chapter,
    since we are using `create-react-app`, we don''t have to worry about setting the
    environment variables. We just need to run the following command in the Terminal
    from the project root folder:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Once you run this command, you will have your production build with all the
    optimizations done and ready for use in the build directory of the project. Generating
    builds with `create-react-app` is that simple!
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: Once the production build is generated, run `http-server` inside the build directory
    of your project and see how the application works by visiting the URL printed
    by `http-server` in the console on your browser.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: React has a browser extension, which will let you debug the component hierarchy,
    including the component's state and props. Since we are only working with a basic
    application in this chapter, we didn't use that tool. However, you can try it
    out yourself if you are building applications with React at [https://github.com/facebook/react-devtools](https://github.com/facebook/react-devtools).
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-423
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This book is designed to help you understand the basics of React. Since we only
    built a simple application in this chapter, we didn't get to explore many of React's
    cool features. In this chapter, you started off with a simple counter, then built
    a ToDo list in the React crash course, and finally, built a simple blog application
    using the `create-react-app` tool and some libraries, such as `react-router` and
    reactstrap.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: Being a simple view layer of the app, React does need a few libraries used together
    to make it work like a full fledged framework. React isn't the only JavaScript
    framework out there but React definitely is a one of a kind library that is revolutionizing
    modern UI development.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: Everything is really great about React and the blog application we just built,
    except that each of the pages in the blog takes an annoying 3 seconds to load.
    Well, we can work around this problem by storing the post details offline using
    the localStorage API of the browser and updating states using them. But then again,
    our application is making too many network requests to the server for retrieving
    data that has already been retrieved in the previous requests.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: Before you start thinking about some complex ways to reuse the data while storing
    it offline, there is one more thing we need to learn in this book, which is the
    new library that is taking the modern frontend development by storm-**Redux**.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
