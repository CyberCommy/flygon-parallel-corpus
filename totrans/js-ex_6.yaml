- en: Building a Blog with React
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Hey! Good work making it to the last section of the book, where you are going
    to learn Facebook''s React library. Before we start with this chapter, let''s
    take a look at your journey through the book:'
  prefs: []
  type: TYPE_NORMAL
- en: You first built a simple ToDo list app using the JavaScript's ES6 syntax and
    then created a build script to compile it down to ES5 so that it will be compatible
    with older browsers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, you built a Meme Creator while setting up your own automated development
    environment, learning lots of new concepts and tools along the way.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, you used the development environment and built an Event Registration app
    in which you built your first reusable JavaScript module for API calls and form
    validation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, you utilized the power of JavaScript WebAPIs to build a peer-to-peer video
    calling app with WebRTC.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lastly, you built your own HTML5 custom element that will display a weather
    widget and can be easily imported and used with other projects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From a beginner level, you built some really awesome applications and now you
    are familiar with many important concepts of modern JavaScript. Now, it's time
    for you to employ these skills to learn a JavaScript framework, which will turbocharge
    your development process. This chapter will focus on helping you get started with
    React.
  prefs: []
  type: TYPE_NORMAL
- en: Why use a framework?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Modern application development is all about speed, maintainability, and scalability.
    Given the web is the major platform for many applications, the same will be expected
    for any web applications. JavaScript may be a great language but writing plain
    JavaScript can be a tedious process at times when you are dealing with a large
    application in a team environment.
  prefs: []
  type: TYPE_NORMAL
- en: In such applications, you will have to manipulate a lot of DOM elements. Whenever
    you make changes to the CSS of a DOM element, it is called a repaint. It will
    affect how an element appears on the browser. Whenever you remove, change, or
    add an element in the DOM, then it is called a reflow. A reflow of a parent element
    causes all its child elements to reflow too. Repaints and reflows are expensive
    operations because they are synchronous. It means when a repaint or reflow happens,
    JavaScript will not be able to run at that time. This will lead to lagging or
    slow execution of web applications (especially on smaller devices, such as low-end
    smartphones). So far, we have been building very small applications; therefore,
    we haven't noticed any performance issues but for applications, such as Facebook,
    this is crucial (there are literally 1,000s of DOM elements).
  prefs: []
  type: TYPE_NORMAL
- en: Also, writing lot of JavaScript code means increasing the file size of your
    code. For mobile users who rely on 3G or lower connections, it means your application
    will take a longer time to load. This causes a bad user experience.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, frontend JavaScript code needs to deal with a lot of side effects (events
    such as click, scroll, hover, and network requests). When working in a team environment,
    every developer should know what kind of side effects your code deals with. When
    the web application grows, every side effect needs to be properly tracked. In
    plain JavaScript, writing maintainable code in such an environment is also difficult.
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, the JavaScript community is well aware of all these scenarios and,
    hence, there are lots of open source JavaScript libraries and frameworks created
    and actively maintained to address the preceding issues and improve developer
    productivity.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting a framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Choosing a JavaScript framework in 2017 is more difficult than learning JavaScript
    itself (yeah, it's true!) due to the release of a new framework almost every week.
    But unless your requirement is very specific, you won't need to worry about most
    of them. Currently, there are a few frameworks that are really popular among the
    developers, such as React, Vue.js, Angular, Ember, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: These frameworks are really popular because they get you up and running with
    your application in almost no time, followed by excellent support from the huge
    community of developers who use these frameworks. These frameworks also come with
    their own build tools, which will save you the trouble of setting up your own
    development environment.
  prefs: []
  type: TYPE_NORMAL
- en: React
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are going to learn the basics of building web applications
    with React. React is built and is widely used by Facebook. Many other famous applications,
    such as Instagram, Airbnb, Uber, Pinterest, Periscope, and so on, also use React
    in their web applications, which has helped to develop React into a mature and
    battle-tested JavaScript library. At the time of writing this book, React is the
    most popular frontend JavaScript framework in GitHub with an active community
    of over 70,000 developers.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike most of the other JavaScript frameworks, React does not consider itself
    a framework but as a library for building user interfaces. It perfectly handles
    the view layer of your application by composing each section of your app into
    smaller functional components.
  prefs: []
  type: TYPE_NORMAL
- en: 'Functions are simple JavaScript code that perform a task. We have been using
    functions since the very beginning of this book. React uses the concept of functions
    to build each component of the web app. For example, look at the following element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Say you want to replace the word `world` with a dynamic variable, for example,
    someone''s name. React achieves this by converting the element into a result of
    a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the function `hello` contains the required elements as its result. If
    you try, `hello(''Rahul'')`, you will get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: But wait! What is that `React.createElement()` method? Forgot to tell you. That
    is how React creates HTML elements. But applying that to building applications
    is impossible for us! Imagine how many of those you will have to type in order
    to create an application with lots of DOM elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this purpose, React introduced **JavaScript inside XML** (**JSX**). It
    is the process of writing an XML-styled markup inside JavaScript, which gets compiled
    to the `React.createElement()` method by React to cut a long story short, you
    can also write the `hello` function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This will make more sense because we are simply writing HTML inside the return
    statement of JavaScript. What''s cool about this is the content of the element
    depends directly on the parameter of the function. You need to note a few things
    while working with JSX:'
  prefs: []
  type: TYPE_NORMAL
- en: The attributes of JSX elements cannot contain JavaScript keywords. See that
    the class attribute is replaced with `className` because a class is a reserved
    keyword in JavaScript. Similarly, for attribute, it becomes `htmlFor`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To include variables or expressions inside JSX, you should wrap them inside
    curly braces `{}`. It is similar to `${}` we use in template strings.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JSX requires the Babel React preset to get compiled to JavaScript.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the HTML elements in JSX should only use small case letters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example: `<p></p>`, `<div></div>`, and `<a></a>`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Having capital letters for HTML is invalid.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example: `<Div></Div>` and `<Input></Input>` are all invalid.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The custom components we created should start with capital letters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example: consider the `hello` function that we created before, which is
    a stateless React component. To include it in JSX, you should name it as `Hello`
    and include it as `<Hello></Hello>`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The preceding function is a simple **stateless** React component. A stateless
    React component outputs elements directly depending on the variables supplied
    as parameters to the function. Its output does not depend on any other factors.
  prefs: []
  type: TYPE_NORMAL
- en: Detailed information on JSX can be found at: [https://facebook.github.io/react/docs/jsx-in-depth.html](https://facebook.github.io/react/docs/jsx-in-depth.html).
  prefs: []
  type: TYPE_NORMAL
- en: This representation is suitable for smaller elements but many DOM elements come
    with a variety of side effects, such as DOM events and AJAX calls that will cause
    modification of DOM elements from factors (or variables) outside the scope of
    the function. To address this, React came up with a concept of **stateful** components.
  prefs: []
  type: TYPE_NORMAL
- en: 'A stateful component has a special variable called `state`. The `state` variable
    contains a JavaScript object and it should be immutable. We''ll look at immutability
    in a moment. For now, look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This is a simple stateful React component. As you can see, we are extending
    a class from the `React.Component` interface similar to how we extended it from
    `HTMLElement` to create our custom elements in the previous chapter and, just
    like custom elements, React components also have life cycle methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'The react lifecycle methods are called at different stages of a component being
    inserted into the DOM or when it gets updated. The following life cycle methods
    are called (in the exact order) when a component is being inserted into the DOM:'
  prefs: []
  type: TYPE_NORMAL
- en: constructor()
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: componentWillMount()
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: render()
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: componentDidMount()
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The following lifecycle methods are called when an update is caused due to change
    of state or props of the component.
  prefs: []
  type: TYPE_NORMAL
- en: componentWillReceiveProps()
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: shouldComponentUpdate()
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: componentWillUpdate()
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: render()
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: componentDidUpdate()
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'There is also a lifecycle method which is called when the component is being
    removed from the DOM:'
  prefs: []
  type: TYPE_NORMAL
- en: componentWillUnmount()
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a detailed explanation of how each of the lifecycle method works in react,
    refer the following page in react documentation: [https://facebook.github.io/react/docs/react-component.html#the-component-lifecycle](https://facebook.github.io/react/docs/react-component.html#the-component-lifecycle)
  prefs: []
  type: TYPE_NORMAL
- en: The `render` method in the preceding `Counter` class is one of the lifecycle
    methods of a React component. As the name suggests, a `render()` method is used
    to render the elements in the DOM. The `render` method is called whenever a component
    is mounted and updated.
  prefs: []
  type: TYPE_NORMAL
- en: An update in a React component happens whenever a `state` or `props` of the
    component get changed. We haven't looked at props yet. To detect the change of
    the state variable, React requires the state to be an immutable object.
  prefs: []
  type: TYPE_NORMAL
- en: Immutable state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An immutable object is an object that cannot be changed once it is set! Yup,
    that's right. Once you create that object, there is no going back. That gets you
    wondering *"What if I need to modify a property of that object?"* Well, it's simple;
    you simply create a new object from the old object but with the new property this
    time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, that may seem like a lot of work, but trust me, it is actually better
    to create a new object. Because, most of the time, React simply needs to know
    if the object is changed to update the view. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This is a standard way of changing the property of a JavaScript object. Here,
    let's call it the mutable way. Great! You just modified the state. But how can
    React know that the state is modified and it should call its lifecycle methods
    to update the DOM elements? Now that's a problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'To overcome this, the React component has a special method called `setState()`,
    which can update the state in an immutable way and call the required life cycle
    methods (including `render`, which will update the DOM element). Let''s see how
    to update the state in an immutable way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This will update your state by creating a new state object instead of the older
    one. Now, the old state and new state are two different objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: React can now easily check whether the state is changed by a simple comparison
    of two objects, `oldState !== newState`, which will return true if the state is
    changed; therefore, giving a fast update in the view. Comparing objects this way
    is much faster and efficient than iterating over the properties of each object
    and checking whether any property is changed.
  prefs: []
  type: TYPE_NORMAL
- en: The goal of using `setState()` is to call the `render` method, which will update
    the view. Hence, `setState()` should not be used inside the `render` method, or
    else it will result in an infinite loop.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript data types are not immutable; however, working with immutable data
    types are very important and you'll learn more about them soon.
  prefs: []
  type: TYPE_NORMAL
- en: Props
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Props are data passed to a react component from a parent component. Props are
    similar to states except that props are read-only. You should not change props
    of a component from within the component itself. For example, consider the following
    component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here, the name attribute passed to `ChildrenComponent` element inside the render
    method of `ParentComponent` has become a prop for the `ChildrenComponent`. This
    prop should not be changed by the `ChildrenComponent`. However, if the value is
    changed from the `ParentComponent`, the `ChildrenComponent` will also get re-rendered
    with the new props.
  prefs: []
  type: TYPE_NORMAL
- en: To learn more about components and props, visit the following page in react
    documentation: [https://facebook.github.io/react/docs/components-and-props.html](https://facebook.github.io/react/docs/components-and-props.html)
  prefs: []
  type: TYPE_NORMAL
- en: Building the Counter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Take a look at the `Counter` class we created before. As the name suggests,
    it should render a counter that increases by 1 every second. For that, we need
    to use `setInterval` to increase the count property of the counter's state object.
    We can use either the `componentWillMount` or `componentDidMount` lifecycle methods
    to add `setInterval`. Since this process does not need any reference to DOM elements,
    we can use `componentWillMount`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `Counter` class, we need to add the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This will automatically perform the increment every second and the `render`
    method will update the required DOM element. To see the counter in action, visit
    the following JSFiddle page: [https://jsfiddle.net/reb5ohgk/](https://jsfiddle.net/reb5ohgk/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, on the JSFiddle page, look at the External Resources section in the top
    left corner. You should see three resources included in it, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00037.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Along with this, in the JavaScript code block, I have selected the language
    as Babel+JSX. If you click on the settings icon in the top right corner of the
    JavaScript section, you will be able to see a set of options as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00038.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here''s what the configurations are all about:'
  prefs: []
  type: TYPE_NORMAL
- en: The first JavaScript file I have included is the `react.js` library. The React
    library is the core that is responsible for creating the DOM elements as components.
    However, React renders the components in a *virtual DOM* instead of the real DOM.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The second library I have included is `ReactDOM`. It is used to provide a wrapper
    for React components so that they can be rendered in the DOM. Consider the following
    line:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This will render the `Counter` component into the `<app></app>` element in the
    DOM using the `ReactDOM.render()` method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third library is Bootstrap; I just added it for the styles. So, let's look
    into the next step of the configuration.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the JavaScript code block, I have selected the language as Babel + JSX. It
    is because the browsers only know JavaScript. They have no idea about JSX in the
    same way that older browsers didn't have any idea about ES6.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, I just instructed JSFiddle to use the in-browser Babel transformer to compile
    the ES6 and JSX code back to normal JavaScript so that it will work with all the
    browsers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the real applications, we will use the Webpack and Babel loaders with the
    React preset to compile JSX just as we did for ES6.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By now, you should have a good idea of React So, let's get started with building
    your first React application-a ToDo list-in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: The React crash course
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to spend 10 minutes building your first React
    application. For this section, you don't need any text editor because you will
    be building the app in JSFiddle!
  prefs: []
  type: TYPE_NORMAL
- en: Get started by visiting the JSFiddle page at: [https://jsfiddle.net/uhxvgcqe/](https://jsfiddle.net/uhxvgcqe/),
    where I have set up all the libraries and configurations needed for building a
    React application. You should write the code for the React crash course section
    in this page.
  prefs: []
  type: TYPE_NORMAL
- en: 'This page has React and `ReactDOM` available as the properties of a window
    object (global scope), since I have included these libraries in the external resources.
    We''ll also create a component object from the React object. In ES6, there is
    a trick to obtain properties or methods of an object into standalone variables.
    Look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This will now create two new constants, `fourWheeler` and `twoWheeler`, from
    the vehicle object''s respective properties. This is called a destructuring assignment
    and it works with both objects and arrays. Following the same principle, in the
    first line of your JSFiddle, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This will create the component object from the component property of the React
    object. Followed by that, I have included an `<app></app>` element in the HTML
    section, which is where we are going to render our React component. So, create
    a reference to the `<app>` element using the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create a stateful app component that will render our ToDo list. In the
    JSFiddle, type the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Outside the class, add the following code block that will render the React
    component in the DOM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Now, click Run in the top left corner of the JSFiddle page. Your app should
    now look like this: [https://jsfiddle.net/uhxvgcqe/1/](https://jsfiddle.net/uhxvgcqe/1/).
  prefs: []
  type: TYPE_NORMAL
- en: For more information and usage details regarding destructuring assignments,
    visit the following MDN page: [https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment).
  prefs: []
  type: TYPE_NORMAL
- en: Adding and managing states
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The most important part of a stateful React component is its state, which provides
    the required data to render the DOM elements. For our application, we need two
    state variables: one containing the array of tasks while another containing the
    input value of the text field. Being a fully functional representation, we always
    need to maintain a state for every view change, including the value of input fields.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In your `App` class, add the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This will add a constructor to the class, where we should make a call to `super()`
    first, since our class is an extended class. `super()` will call the constructor
    for the `Component` interface. In the next line, we have created the state variable's
    tasks and `inputValue`. `tasks` is an array, which will contain an array of strings
    with task names.
  prefs: []
  type: TYPE_NORMAL
- en: Managing the state for the input field
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we''ll attach the `inputValue` state with the input field. Inside your
    `render()` method, add the value attribute for the input JSX element, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We have explicitly binded the value of the input field with the state variable.
    Now, try clicking Run and editing the input field. You should not be able to edit
    it.
  prefs: []
  type: TYPE_NORMAL
- en: This is because no matter what you type into this field, the `render()` method
    will simply render what we have specified in the `return()` statement, which is
    an input field with empty `inputValue`. So, how do we change the value of the
    input field? By adding an `onChange` attribute to the input field. Let me show
    you how.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `App` class, add the following lines of code in the position, as
    I have specified in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This `handleChange` method will receive our typing event and will update the
    state based on the value of the event's target, which should be the input field.
    Note that, in the constructor, I have binded the `this` object with the `handleChange`
    method. This saves us the trouble of having to use `this.handleChange.bind(this)`
    inside the JSX elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to add the `handleChange` method to the `onChange` attribute of
    the input element. In your JSX, add the `onChange` attribute to the input element,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Click Run and you should be able to type in the input field again. But this
    time, your `inputValue` state gets updated every time you are editing the input
    field. Your JSFiddle should now look like this: [https://jsfiddle.net/uhxvgcqe/2/](https://jsfiddle.net/uhxvgcqe/2/).
  prefs: []
  type: TYPE_NORMAL
- en: This is the React's one-way data flow (or one-way data binding), where data
    only flows in one direction, from the state to the `render` method. Any events
    in the rendered components will have to trigger an update to the state to update
    the view. Also, the state should only be updated in an immutable way using the
    `this.setState()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Managing the state for the tasks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The second state that we need to maintain in our app is the `tasks` array.
    Currently, we have an unordered list of sample tasks. Add those tasks as strings
    inside the `tasks` array. Your `state` object inside the constructor should now
    look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s populate the tasks from the state. In your `render` method, inside
    the `<ul>` element, remove all the `<li>` elements and replace them with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The curly braces `{}` in JSX only accept expressions that return a direct value
    just like `${}` in template literals. Hence, we can use the array's map method
    that returns an array of JSX elements. Whenever we return JSX elements as arrays,
    we should add a `key` attribute with a unique value, which is used by React for
    identifying that element in the array.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in the preceding code, we need to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: We iterate over the `tasks` array of the `state` and return the list items as
    an array of the JSX elements using the `map()` method of the array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the unique value of the `key` attribute, we are using the `index` of each
    element in the array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click Run and your code should produce the same output as before, except that
    the tasks are now populated from the state. Your code should now look like this: [https://jsfiddle.net/uhxvgcqe/3/](https://jsfiddle.net/uhxvgcqe/3/).
  prefs: []
  type: TYPE_NORMAL
- en: Adding new tasks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our final step in the app is to allow users to add a new task. Let''s make
    it simple by adding a new task on hitting *Enter* or *return* on the keyboard.
    To detect the *Enter* button, we need to use an attribute on the input field similar
    to `onChange`, but it should happen before the `onChange` event. `onKeyUp` is
    one such attribute that gets called when the key is pressed and released by the
    user on the keyboard. It also happens before the `onChange` event. First create
    the method that will handle the keyup process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s how the `handleKeyUp` method will work:'
  prefs: []
  type: TYPE_NORMAL
- en: First, it will check whether `keyCode` of the event is `13`, which is `keyCode`
    for *Enter *(for Windows) and *return* (for Mac) keys. Then, it will check whether
    `this.state.inputValue` is available. Otherwise, it will throw an alert saying
    `'Please add a Task'`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The second and the most important part here is updating the array without mutating
    the state. Here, I have used the spread syntax to create a new tasks array and
    update the state.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In your `render` method, again modify the input JSX element into the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Now, click Run, type a new task, and hit *Enter*. You should see that a new
    task gets added to the ToDo list. Your code should now look like [https://jsfiddle.net/uhxvgcqe/4/](https://jsfiddle.net/uhxvgcqe/4/),
    which is the completed code for the ToDo list. Before we discuss the advantages
    of using React here, let's take a look into the spread syntax we used for adding
    a task.
  prefs: []
  type: TYPE_NORMAL
- en: Preventing mutations using the spread syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In JavaScript, arrays and objects are passed by reference during an assignment.
    For example, open a new JSFiddle window and try the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We are creating a new array `b` from array `a`. We then push a new value `5`
    into array `b`. If you look at the console, your output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00039.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Surprisingly, both arrays have been updated. This is what I meant by passing
    by a reference. Both `a` and `b` are holding the reference to the same array,
    which means updating either one of them will update both. This holds true for
    both arrays and objects. This means we will evidently *mutate the state* if we
    use a normal assignment.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, ES6 comes with a *spread syntax* for arrays and objects. I have used
    this in the `handleKeyUp` method, where I am creating a `newTask` array from `this.state.tasks
    array`. In the JSFiddle window where you tried the preceding code, change the
    code into the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: See how I have created a new array `b` this time. The three dots `...` (known
    as the spread operator) are used to expand all the elements in the array `a`.
    Along with it, a new element `5` is added, and a new array is created and is assigned
    to `b`. This syntax might be confusing at first but it is how we should update
    array values in React, since this will create a new array (in an immutable way).
  prefs: []
  type: TYPE_NORMAL
- en: 'Likewise, for objects, you should do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: I have created a fiddle with the spread operators in [https://jsfiddle.net/bLo4wpx1/](https://jsfiddle.net/bLo4wpx1/).
    Feel free to play with it to understand the working of the spread syntax, which
    we will be using very often in this chapter and in the next.
  prefs: []
  type: TYPE_NORMAL
- en: For more practical examples of using the spread syntax, visit the MDN page [https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Spread_operator](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Spread_operator).
  prefs: []
  type: TYPE_NORMAL
- en: Advantages of using React
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have built a ToDo list app within 10 minutes using React. At the beginning
    of this chapter, we discussed why we need a JavaScript framework and the disadvantages
    of using plain JavaScript. In this section, let's look at how React overcomes
    those factors.
  prefs: []
  type: TYPE_NORMAL
- en: Performance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: DOM updates are costly. Repaints and reflows are synchronous events and therefore,
    they need to be minimized as much as possible. React deals with this scenario
    by maintaining a virtual DOM, which makes React applications really fast.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever we make a modification to the JSX element in the `render` method, React
    will update the virtual DOM instead of the real DOM. Updating the virtual DOM
    is fast, efficient, and much less expensive than updating the real DOM and only
    the elements that are changed in the virtual DOM will be modified in the actual
    DOM. React does this by using a smart diffing algorithm, which we mostly won't
    have to worry about.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand how React works in detail and its performance, you can read the
    following articles from the React documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://facebook.github.io/react/docs/reconciliation.html](https://facebook.github.io/react/docs/reconciliation.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://facebook.github.io/react/docs/optimizing-performance.html](https://facebook.github.io/react/docs/optimizing-performance.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maintainability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React shines great in this section, since it neatly organizes the application
    into states and corresponding JSX elements grouped as components. In the ToDo
    list app, we only used a single stateful component. But we can divide its JSX
    into smaller stateless child components too. This means any modification in the
    child components will not affect the parent. Therefore, the core functionality
    will not get affected even if we modify what the list looks like.
  prefs: []
  type: TYPE_NORMAL
- en: Check out the JSFiddle at: [https://jsfiddle.net/7s28bdLe/](https://jsfiddle.net/7s28bdLe/),
    where I have organized the list items in a ToDo list as smaller child components.
  prefs: []
  type: TYPE_NORMAL
- en: This is really useful in a team environment, where everyone can create their
    own components and they can be easily reused by others, which will boost the developer's
    productivity.
  prefs: []
  type: TYPE_NORMAL
- en: Size
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React is small. The entire React library is just around 23 KB when minified,
    while `react-dom` is around 130 KB. This means it does not cause any serious problems
    on page load times even on slow 2G/3G connections.
  prefs: []
  type: TYPE_NORMAL
- en: Building a blog with React
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The objective of this section is to learn the basics of React and how it is
    being used in web applications by building a simple blog application. So far,
    we have been learning about React but now it's time to see how it is used in real
    web applications. React will work fine in our development environment, which we
    have been using in this book so far, except that we need to add an additional
    `react` preset to `babel-loader`.
  prefs: []
  type: TYPE_NORMAL
- en: But `react-community` has come up with a better solution, which is the `create-react-app`
    command-line tool. Basically, this tool creates your project with all the necessary
    development tools, Babel compilers, and plugins so that you need to focus only
    on writing code without worrying about Webpack configurations.
  prefs: []
  type: TYPE_NORMAL
- en: '`create-react-app` recommends using yarn instead of npm while working on React,
    but since we are very familiar with npm, we will not use yarn in this chapter.
    If you want to learn about yarn, visit: [https://yarnpkg.com/en/](https://yarnpkg.com/en/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To see how `create-react-app` works, first let''s install the tool globally
    using npm. Open up your Terminal and type the following command (Since this is
    a global install it will work from any directory):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Linux users might have to add the `sudo` prefix. Once it is installed, you
    can create a boilerplate for your React project by running a simple command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This command will take a while, since it has to create a `my-react-project`
    directory and install all the npm dependencies for your React development environment.
    Once the command is complete, you can run the application using the following
    commands in the Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This will start the React development server and will open the browser that
    will display a welcome page built with React, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00040.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s see how the files are organized in the project. The project root folder
    will have files arranged in the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The public folder will contain the `index.html` file, which contains the `div#root`
    element to which our React component will get rendered to. Also, it contains the
    `favicon` and `manifest.json` file, which provides information to the Android
    devices when the web page is added to the home screen (commonly used in progressive
    web apps).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `src` directory contains the source files of our React application. The
    file structure of the `src` directory will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The `index.js` file is the entry point of the application, where it simply renders
    the `App` component from the `App.js` file in the `index.html` file present in
    the public directory. We write our primary `App` component in the `App.js` file.
    All the other components in the application will be children of the `App` component.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have been building multipage applications using JavaScript. But now,
    we are going to build a single page application using React. A **Single Page Application**
    (**SPA**) is one in which all the assets of the application get loaded initially
    and then it will work like a normal app on the user's browser. SPAs are the trend
    now, since they provide a great user experience across various devices for the
    users.
  prefs: []
  type: TYPE_NORMAL
- en: For building a SPA in React, we need a library to manage navigation between
    pages (components) in the app. `react-router` is one such library that will help
    us manage navigation between the pages (routing) in the app.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just as in the other chapters, our blog will also be responsive on mobile devices.
    Let''s take a look at the blog application we are about to build:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00041.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: For this application, we are going to have to write a lot of code. Hence, I
    have already prepared the starter files for you to use. Instead of starting from
    the `create-react-app` tool, you should start from the starter files inside the
    `Chapter06` folder of the book codes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Along with React and `react-dom`, the starter files contain the following libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: React Router: [https://reacttraining.com/react-router/](https://reacttraining.com/react-router/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reactstrap: [https://reactstrap.github.io/](https://reactstrap.github.io/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: uuid: [https://www.npmjs.com/package/uuid](https://www.npmjs.com/package/uuid)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The server that provides the API for the blog is available in the book code
    `Chapter06\Server` directory. You should keep this server running while building
    the application. I highly recommend you to see the completed application before
    starting to build the blog.
  prefs: []
  type: TYPE_NORMAL
- en: '`create-react-app` supports reading environment variables from the `.env` file
    straight out of the box; however, with the condition that all environment variables
    should be prefixed with the `REACT_APP_` keyword. For more information, read: [https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/README.md#adding-custom-environment-variables](https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/README.md#adding-custom-environment-variables).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To run the completed application, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start the server first by running `npm install`, followed by `npm start` inside
    the server's directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It will print the URL that should be added to the `.env` file of `Chapter 6\completedCode`
    files in the console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside `Chapter 6\CompletedCode` files, create the `.env` file using the `.env.example`
    file and paste the URL printed in the first line of the console output as the
    value of `REACT_APP_SERVER_URL`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate inside the book code `Chapter 6\CompletedCode` files directory in your
    Terminal and run the same `npm install` and `npm start` commands.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It should open the blog on your browser. If it didn't open the blog, then manually
    open `http://localhost:3000/` on your browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'I have also created an API documentation using swagger for the server. To access
    the API documentation, while your server is running, it will print the documentation
    URL in the second line of console output. Simply open the URL in your browser.
    In the documentation page, click on the default group and you should see a list
    of API endpoints, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00042.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can see all the information regarding the API endpoints and even try them
    out by clicking on the API and then clicking Try it out:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00043.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Take your time. Visit all the sections of the completed blog, try out all the
    APIs in the swagger document, and learn how it works. Once you are done with them,
    we'll move onto the next section, where we will start building the app.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the navigation bar
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Hope you tried the app. Currently, I have set the server to respond only after
    3 seconds; therefore, you should see a loading indicator while trying to navigate
    between the pages.
  prefs: []
  type: TYPE_NORMAL
- en: 'The one thing common across all the pages in this application is the top navigation
    bar:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00044.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the previous chapters, we created the navigation bar easily using Bootstrap.
    However, we can''t use Bootstrap here because, in React, all the DOM elements
    are rendered dynamically through components. Bootstrap, however, requires jQuery,
    which only works on a normal DOM so that it can display animations while clicking
    the hamburger menu when the navbar is viewed on mobiles, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00045.gif)'
  prefs: []
  type: TYPE_IMG
- en: However, several libraries are available which will let you use Bootstrap in
    React by providing the equivalent React components to each Bootstrap styled element.
    In this project, we are going to use one such library called the reactstrap. It
    requires Bootstrap 4 (alpha 6) to be installed with it; therefore, I have also
    installed Bootstrap 4 in the project's starter files.
  prefs: []
  type: TYPE_NORMAL
- en: Now, navigate to the book code `Chapter06\Starter files` directory and create
    the `.env` file in the project root directory. The `.env` file should have the
    same value as the completed code files for `REACT_APP_SERVER_URL`, which is the
    URL printed by the server in the console.
  prefs: []
  type: TYPE_NORMAL
- en: From the starter files directory in your Terminal, run `npm install`, followed
    by `npm start`. It should start the development server for the starter files.
    It will open the browser, which displays the message "The app goes here...". Open
    the folder in VSCode and see the `src/App.js` file. It should contain that message
    in the `render` method.
  prefs: []
  type: TYPE_NORMAL
- en: The starter files will be compiled with a lot of warnings saying no-unused-vars.
    It is because I have already included the import statements in all the files but
    none of them are yet used. Therefore, it is telling you that there are a lot of
    unused variables. Just ignore the warnings.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top of your `App.js` file, you should see that I have imported some
    modules from the reactstrap library. They are all React components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Explaining about each of the components here is not important, since this chapter
    focuses on learning React more than styling React components. Therefore, to learn
    about reactstrap, visit the project homepage at: [https://reactstrap.github.io/](https://reactstrap.github.io/).
  prefs: []
  type: TYPE_NORMAL
- en: 'In your `App` class, in the `App.js` file, replace the `return` statement of
    the `render` method with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code will make use of the reactstrap components and will create
    a top navigation bar for the blog just like in the completed project. Check out
    the page in responsive design mode in Chrome to see how it looks on mobile devices.
    In the responsive design mode, the hamburger menu won't work.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is because we haven''t created any states and methods to manage expanding
    and collapsing the navigation bar. In your `App` class, add the following constructor
    and method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This will add the state variable, `isOpen`, used for identifying the open/closed
    state of the hamburger menu, while the toggle method is used to expand or collapse
    the hamburger menu by changing the value of the `isOpen` state to `true` or `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To bind these in your navigation bar, in the `render` method, perform the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Replace the `false` value of the `isOpen` attribue in the line with the `<Collapse
    isOpen={false} navbar>` component with `this.state.isOpen`. The line should now
    look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace the empty function `()=>{}` value of the `onClick` attribute in the
    line including `<NavbarToggler right onClick={()=>{}}` `/>` with `this.toggle`.
    The line should now look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Once you add these lines and save the file, the hamburger button in the navigation
    bar will work fine in your browser. However, clicking on the links in the navigation
    bar will only reload the page. We cannot do regular navigation using anchor tags
    in a single page application, since there is only a single page that the app is
    going to display. In the next section, we'll see how to implement navigation between
    pages using the React Router library.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing routing and navigation using React Router
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React Router implements routing by displaying the components based on the URL
    the user visits in your web application. React Router can be used in both React.js
    and React Native. However, since we are only focusing on React.js, we should use
    the specific React Router library, `react-router-dom`, that handles routing and
    navigation on the browser.
  prefs: []
  type: TYPE_NORMAL
- en: The first step to implement React Router is to wrap the entire `App` component
    inside a `<BrowserRouter>` component from `react-router-dom`. To wrap the entire
    application, open the `src/index.js` file in your project directory in VSCode.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top of the `index.js` file, add the following import statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'This will import the `BrowserRouter` component with the name router. Once you
    have added the import statement, replace the `ReactDOM.render()` line with the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This simply wraps the `<App />` component inside the `<Router>` component, which
    will allow us to use React Router in the rest of the `App` component's child components.
  prefs: []
  type: TYPE_NORMAL
- en: The routes file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the starter files, I have included a `routes.js` file in the `src/routes.js`
    path. This file contains all the routes we are going to use on our blog in the
    form of JSON objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'See the home page of the completed blog app. The URL will be pointing to the
    `''/home''` route. Likewise, each page has its respective route. However, some
    routes have dynamic values. For example, if you click Read More in a blog post,
    it will take you to the page with the URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Here, the third part of the URL is the post's ID. To represent such URLs, I
    have used `'/post/:id'` in the routes file, where the ID means that React Router
    will understand that the ID will be a dynamic value.
  prefs: []
  type: TYPE_NORMAL
- en: You don't really have to manage all your routes in a single routes file. I have
    created a routes file so that it will be easier for you to add the routes while
    building the application.
  prefs: []
  type: TYPE_NORMAL
- en: Adding routes in the app component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What React Router does is pretty much simple; it simply renders a component
    based on the URL in the address bar. It uses history and location Web APIs for
    this purpose, but gives us simple, easy to use, component-based APIs, so that
    we can quickly set up our routing logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add navigation between the components in the `App.js` file, add the following
    code in the `App.js` file''s `render` method after the `<Navbar></Navbar>` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, refer to the completed code files if you face any issues after adding
    the code files. I have already added all the import statements in the `App.js`
    file. Route component is imported from the `react-router-dom` package. Here''s
    what the preceding route component does:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The route component will check the URL of the current page and render the component
    that matches with the given path. Take a look at the following Route:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: React Router will render the `Home` component when your URL has the path `'/home'`
    (the value of `routes.home` from the routes file).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s what each of its attributes means:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`exact`: Only when the path is matched exactly. This is optional if it is not
    present in `''/home''`: It will hold true for `''/home/otherpaths''` too. We need
    the exact match; hence, I have included it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`path`: The path that must be matched with the URL. In our case, it is `''/home''`
    from the `routes.home` variable from the routes file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`component`: The component that must be rendered when the path matches with
    the URL.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once you have added the route components, navigate back to the application in
    Chrome. If your application is running in `http://localhost:3000/`, you will only
    see a blank page. However, if you click on the menu items in the navigation bar,
    you should see the respective components being rendered on the page!
  prefs: []
  type: TYPE_NORMAL
- en: By adding the navigation bar outside the route components, we can easily reuse
    the same navigation bar across the entire application.
  prefs: []
  type: TYPE_NORMAL
- en: However, we should have our application automatically navigate to the home page
    `'/home'` instead of displaying a blank page on the first load. To do that, we
    should programmatically replace the URL with the required `'/home'` path like
    we did in [Chapter 4](part0099.html#2UD7M0-f852807d0cb141b58fff8f992d32cbb7),
    *Real-Time Video Call App with WebRTC*, using the history object.
  prefs: []
  type: TYPE_NORMAL
- en: But we have a problem here. React Router maintains its own history object for
    navigation. This means we need to modify the history object of the React Router.
  prefs: []
  type: TYPE_NORMAL
- en: Managing history using withRouter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'React Router has an `higher-order` component called `withRouter` with which
    we can pass in the React Router''s history, location, and match objects to our
    React components as props. To use `withRouter`, you should wrap your `App` component
    inside `withRouter()` as a parameter. Currently, here''s how we are exporting
    the `App` component at the last line of the `App.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'You should change this line to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'This will supply three props, `history`, `location`, and the `match` object
    to our `App` component. For our initial objective, displaying the home component
    by default, add the following `componentWillMount()` method to the `App` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s what the preceding code does:'
  prefs: []
  type: TYPE_NORMAL
- en: Since it is written inside `componentWillMount`, it will get executed before
    the `App` component gets rendered.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It will check the path of the URL using the `location.pathname` property.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the path is `'/'`, that is, the default `http://localhost:3000/`, it will
    automatically replace the history and URL with `http://localhost:3000/home`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This way, the `home` component will be automatically rendered whenever the user
    navigates to the root URL of the web page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, open `http://localhost:3000/` on your browser and it will display the homepage.
    Still, we have another problem here. Every time we click a link in the navigation
    bar, it is causing the page to reload. Since our blog is a single page app, reloading
    should be avoided, as all the assets and components are already downloaded. Reloading the
    application on every click during navigation will only lead to unnecessarily downloading
    the entire app multiple times.
  prefs: []
  type: TYPE_NORMAL
- en: Proptype validation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whenever we are passing props to our React components, it is recommended to
    do proptype validation. A proptype validation is a simple type checking that happens
    in the development builds of React, which is used to check whether all the props
    are supplied properly to our React component. If not, it will display a warning
    message, which is very helpful for debugging.
  prefs: []
  type: TYPE_NORMAL
- en: 'All types of props that can be passed to our React component are defined in
    the `''prop-types''` package, which gets installed along with `create-react-app`.
    You can see that I have included the following import statement at the top of
    the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'To do proptype validation for our `App` component, inside the `App` class,
    add the following static property before the constructor (having proptypes declared
    on top will make it easy to know what props the React component is dependent on):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Refer the completed code files if you are confused about where to include the
    preceding code snippet. This is how the proptype validation works.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the second line of the preceding code `history: PropTypes.object.isRequired`. This
    means that:'
  prefs: []
  type: TYPE_NORMAL
- en: '`history` should be a prop to the `App` component'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The type of `history` should be the object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `history` prop is required (`isRequired` is optional and can be removed
    for props, that are optional)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For detailed information on proptype validation, refer to the React documentation
    page at [https://facebook.github.io/react/docs/typechecking-with-proptypes.html](https://facebook.github.io/react/docs/typechecking-with-proptypes.html).
  prefs: []
  type: TYPE_NORMAL
- en: Seamless navigation with NavLink
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React Router has a perfect solution to fix the reloading problem during navigation.
    React Router provides `Link` and `NavLink` components, which you should use instead
    of the traditional anchor tags. `NavLink` has more features than the `link` component,
    such as specifying an active class name when the link is active. Therefore, we
    will use `NavLink` in our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider the following anchor tag we have used in the `App.js`
    file for navigating to the authors page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'We can replace this with React Router''s `NavLink` component as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s what the attributes of the `NavLink` JSX components do:'
  prefs: []
  type: TYPE_NORMAL
- en: '`className`: The class name given to the element when `NavLink` is rendered
    as an anchor tag in the DOM.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`activeClassName`: The class name given to the element when the link is the
    currently active page.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`to`: The path to which the link will navigate to.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refer to the `App.js` file from the completed code files and replace all the
    anchor tags in the `App.js` file with `NavLink` components. Once you have done
    this change, whenever you click on the menu items in the navigation bar, your
    app will navigate seamlessly without any page reloads.
  prefs: []
  type: TYPE_NORMAL
- en: Also, since the `.active` class gets added to the active links, Bootstrap styles
    will highlight the menu item in the navigation bar with slightly darker black
    color when the respective navbar menu item is active.
  prefs: []
  type: TYPE_NORMAL
- en: We have successfully created the navigation bar for our application and implemented
    some basic routing. From our routes file, you can see that our blog has five pages.
    We'll build the home page in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Blog home page
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You should already have an idea of how the blog's home page will look from exploring
    the app in the completed code files. Our blog has a simple home page that lists
    all the posts. You can click the Read More button in the posts to read the posts
    in detail. Since this blog is a project for learning purposes, this simple home
    page is enough for now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ideally, you should create each React component from scratch. However, to speed
    up the development process, I have already created all the stateless components
    and boilerplates for the stateful parent components. All the components are available
    in the `src/Components` directory. Since the React component names should start
    with capital letters, I have created all the component directory names with initial
    capital letters to indicate that they contain React components. This is the folder
    structure of the `Components` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The home page of our blog is the `Home` component present in the `src/Components/Home/Home.js`
    file. Currently, the `render` method of the `Home` component only renders a `Home` text.
    We need to display the list of posts in the home page. Here''s how we are going
    to achieve this:'
  prefs: []
  type: TYPE_NORMAL
- en: The server has the `/posts` endpoint, which returns all the posts in a `GET`
    request as an array. Therefore, we can use this API to retrieve the post's data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since `Home` is a stateful component, we need to maintain states for every action
    in the `Home` component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: While the `Home` component is retrieving data from the server, we should have
    a state--loading, which should be a Boolean value to show the loading indicator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the network request is a success, we should store the posts in a state--posts,
    which can then be used to render all the blog posts.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the network request fails, we should simply use another state--`hasError`,
    which should be a Boolean value to display the error message.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s get started! First, in your `Home` class, add the following constructor
    to define the state variables of the component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Once you have defined the states, let's make the network request. Since the
    network request is asynchronous, we can have it in `componentWillMount`, but if
    you want to do a synchronous action, that will delay the render. It is better
    to add it in `componentDidMount`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For making the network request, I have added the `apiCall` service, which we
    used in the previous chapters in the `src/services/api/apiCall.js` file, and included
    the import statement in the `Home.js` file. Here''s the code for the `componentWillMount`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s what the preceding function does:'
  prefs: []
  type: TYPE_NORMAL
- en: First, it will set the state variable loading to `true`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `apiCall` function is called to make the network request.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since the network request is an asynchronous function, the `render` method will
    get executed and the component will get rendered.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After the rendering has happened, the network request will get completed in
    3 seconds (I have set that much delay in the server).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the `apiCall` is a success and the data is retrieved, it will update the
    post's state with the array of posts returned from the server and will set the
    loading state to `false`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Otherwise, it will set the `hasError` state to `true` and will set the loading
    state to `false`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To test the preceding code, let''s add the JSX needed to render the posts.
    Since the JSX part requires a lot of code, I have already created the stateless
    components needed for use on this page in the `src/Components/Common` directory
    and included the import statement at the top of the `Home.js` file. Replace the
    `return` statement of the `render` method with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have added the preceding code snippet, keep your server running and
    visit the blog''s home page. It should list all the posts, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00046.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'However, if you kill the server and reload the page, it will display the error
    message, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00047.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The implementation process is very simple once you get to know how the state
    and life cycle methods work with React. However, we still need to cover one important
    topic in this section, which is the child components that I have created previously
    for you to use.
  prefs: []
  type: TYPE_NORMAL
- en: Using child components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s take a look at the `ErrorMessage` component, which I have created to
    show an error message when we are unable to retrieve posts from the server. This
    is how the `ErrorMessage` component is included in the `render` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'If the `ErrorMessage` is a stateful component created by extending the `Component`
    interface. The attributes of the `ErrorMessage` JSX element title and message
    will then become the props of the children `ErrorMessage` component. However,
    if you look at the implementation of the `ErrorMessage` element, you will see
    that it is a stateless functional component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'So, here''s how the attributes work for functional components:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since functional components do not support state or props, the attributes become
    the parameters of the function call. Consider the following JSX element:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'This will be equivalent to a function call with an object as its parameter:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'By using the destructuring assignment you learned earlier, you can use the
    parameters in our function as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: We can use the `propType` validation for functional components too, but here,
    the `propTypes` are used to validate the function's arguments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whenever you are typing the JSX code in a functional component, make sure you
    have included the `import React from` `'react'` statement in the file. Otherwise,
    the Babel compiler will not know how to compile the JSX back to JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: The `PostSummary` component comes with a Read More button with which you can
    see the entire post's details on a page. Currently, if you click this link, it
    will simply display the `'Post Details'` text. So, let's finish up our blog home
    page by creating the post details page.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying post details
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Each post in the blog has a unique ID associated with it. We need to use this
    ID to retrieve the post details from the server. When you click on the Read More
    button, I have created the `PostSummary` component in such a way that it will
    take you to the route `''/post/:id''`, where `:id` contains the ID of the post.
    This is how the post URL will look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Here, the third section is the post ID. Open the `Post.js` file from the `src/Components/Post/Post.js`
    path in VSCode. We need to access the ID that is present in the URL in our `Post`
    component. To access the URL parameter, we need to use the match object of the
    React Router. For this process, we will have to wrap our `Post` component inside
    `withRouter()` just as we did for the `App` component.
  prefs: []
  type: TYPE_NORMAL
- en: 'In your `Post.js` file, change the export statement into the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, since this will provide the `history`, `location`, and `match` props
    to the `Post` component, we should also add the prototype validation to the `Post`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'We have to create the states for our `Post` component. The states are the same
    as that of the `Home` component; however, instead of the posts state (array),
    we will have the post state (object) here, since this page only requires a single
    post. In the `Post` class, add the following constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'In the swagger document of the server, you should see an API endpoint, `GET
    /post/{id}`, which we are going to use in this chapter for retrieving `Post` from
    the server. The `componentWillMount` method we are going to use in this component
    will be extremely similar to that of the previous `Home` component, except that
    we will have to retrieve the `id` parameter from the URL. This can be done using
    the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `this.props.match` is a prop provided to the `Post` component by the
    `withRouter()` component of React Router. So, your `componentWillMount` method
    should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, in the `render` method, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: This will create the post page. Now, you should be able to see the entire post
    by clicking the Read More button. This page will work in the same way the home
    page does. By using reusable components, you can see that we have minimized the
    code a lot.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a new blog post
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have successfully built the home page for our blog. The next task is to build
    the author list page. However, I'll leave the construction of the author list
    to you. You can refer to the completed code files and build the author list page.
    This will be a good practice exercise for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, that leaves us with the last page, which is the new post page. The API
    we are going to use for adding a new blog post is POST /post, which you can see
    in the swagger document. The body of the post request will be in the following
    form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Here, `id` is the unique ID for the blog post and `datetime` is the epoch timestamp
    as a string. Usually, these two properties are generated by the server but since
    we are only using the mock server for our project, we need to generate them on
    the clientside.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `NewPost.js` file from the `src/Components/NewPost/NewPost.js` path.
    This component requires three input fields:'
  prefs: []
  type: TYPE_NORMAL
- en: Author name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Post title
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Post text
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need to maintain states for these three fields. The blog post will need `textarea`,
    which will dynamically increase its size (rows) as the blog post is typed. Thus,
    we need to maintain a state for the number of lines to manage the row count.
  prefs: []
  type: TYPE_NORMAL
- en: Along with this, we will also need the states we used in the previous component's
    loading and `hasError` for network requests. We will also need a state success
    for indicating to the user that the post has been submitted successfully.
  prefs: []
  type: TYPE_NORMAL
- en: 'In your `NewPost` class, create `constructor` with all the required state variables,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Unlike the previous components, instead of just displaying the retrieved data
    from the server, we will have to send data from input fields to the server in
    this component. Whenever input fields are involved, it means we will need a lot
    of methods to edit the state of the input fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'Replace the `render` method of your `NewPost.js` file with the `render` method
    from the `NewPost.js` file of the completed code files. Since both the author
    name and title use the same input fields, I have created a simple `PostInputField`
    component for them. Here''s what the `PostInputField` component looks like for
    the author name input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s what the corresponding `PostInputField` function looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: You can see that I basically made the `className`, `label`, `id`, `value`, and
    `onChange` properties dynamic in the returned JSX element. This will let me reuse
    the entire input field for multiple input elements in the same form. Since the
    final rendered DOM element will have different classes and IDs, but shares the
    same code, all you have to do is import and use it in your component. It will
    save many hours of long development work and, in many cases, it's more efficient
    than the custom elements you learned in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how `textarea` works.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `render` method, you should see the following line where we are
    creating a `noOfLines` constant using the state variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '`this.state.noOfLines` will contain the number of lines present in the blog
    post. Using that, if the number of lines is less than `5`, then we will set the
    value of row attribute to `5`. Otherwise, we can increase the row attribute to
    the number of lines present in the blog post.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what the JSX for text input looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see that the value of the rows attribute is the `noOfLines` constant
    created in the `render` method. After the textarea field, we have the following
    sections:'
  prefs: []
  type: TYPE_NORMAL
- en: The loading section, where we can either show `<LoadingIndicator />` or the
    Submit button based on the network request state (`this.state.loading`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `hasError` and success sections where we can show the success or error message
    depending on the response from the server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s create the methods used by the input fields for updating their value.
    Inside your `NewPost` class, add the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `editContent` is the method used by the `textinput` field. You can see
    that I have used a split(`''\n''`) to divide the lines into an array based on
    the newline characters. We can then use the length of the array to count the number
    of lines present in the post. Also, remember to add the `this` binding to all
    the methods in the constructor. Otherwise, the methods called from JSX will not
    be able to use the `this` variable of the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Submitting the post
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The last part of the adding posts section is submitting the post. Here, we
    need to do two things: generate a UUID for the post and get the current date and
    time in the epoch timestamp format:'
  prefs: []
  type: TYPE_NORMAL
- en: For generating a UUID for using the ID of the post, I have included the `uuid`
    library. You just have to call `uuidv4()`, which will return the UUID for your
    use.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For creating the date and time in the `epoch` timestamp format, you can use
    the following code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'The Submit button in the JSX is already set to call the `this.submit()` method
    when it is clicked. So, let''s create the `submit` method of the `AddPost` class
    with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, add the following code to your constructor for binding this with the
    Submit button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'This is what the preceding submit method does:'
  prefs: []
  type: TYPE_NORMAL
- en: It constructs the body of the network request, which is the post we need to
    add, and then makes the request to the POST/post server endpoint.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the request is a success, it will reset the input fields to an empty string
    using the state variables.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the request fails, it will simply set the `hasError` state to true, which
    will show us an error message.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If it works as expected, then click on Home and you should see your new post
    added to the blog. Congratulations! You just successfully built your own blog
    application using React!
  prefs: []
  type: TYPE_NORMAL
- en: Do try to build the author list page yourself and get help by referring to the
    completed files if you face any problems while building it.
  prefs: []
  type: TYPE_NORMAL
- en: Generating production builds
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The one thing that we have been doing in every chapter is to generate the production
    builds. We did this by setting the `NODE_ENV` variable in the `.env` file to `production`
    and then running `npm run webpack` in the Terminal. However, for this chapter,
    since we are using `create-react-app`, we don''t have to worry about setting the
    environment variables. We just need to run the following command in the Terminal
    from the project root folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Once you run this command, you will have your production build with all the
    optimizations done and ready for use in the build directory of the project. Generating
    builds with `create-react-app` is that simple!
  prefs: []
  type: TYPE_NORMAL
- en: Once the production build is generated, run `http-server` inside the build directory
    of your project and see how the application works by visiting the URL printed
    by `http-server` in the console on your browser.
  prefs: []
  type: TYPE_NORMAL
- en: React has a browser extension, which will let you debug the component hierarchy,
    including the component's state and props. Since we are only working with a basic
    application in this chapter, we didn't use that tool. However, you can try it
    out yourself if you are building applications with React at [https://github.com/facebook/react-devtools](https://github.com/facebook/react-devtools).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This book is designed to help you understand the basics of React. Since we only
    built a simple application in this chapter, we didn't get to explore many of React's
    cool features. In this chapter, you started off with a simple counter, then built
    a ToDo list in the React crash course, and finally, built a simple blog application
    using the `create-react-app` tool and some libraries, such as `react-router` and
    reactstrap.
  prefs: []
  type: TYPE_NORMAL
- en: Being a simple view layer of the app, React does need a few libraries used together
    to make it work like a full fledged framework. React isn't the only JavaScript
    framework out there but React definitely is a one of a kind library that is revolutionizing
    modern UI development.
  prefs: []
  type: TYPE_NORMAL
- en: Everything is really great about React and the blog application we just built,
    except that each of the pages in the blog takes an annoying 3 seconds to load.
    Well, we can work around this problem by storing the post details offline using
    the localStorage API of the browser and updating states using them. But then again,
    our application is making too many network requests to the server for retrieving
    data that has already been retrieved in the previous requests.
  prefs: []
  type: TYPE_NORMAL
- en: Before you start thinking about some complex ways to reuse the data while storing
    it offline, there is one more thing we need to learn in this book, which is the
    new library that is taking the modern frontend development by storm-**Redux**.
  prefs: []
  type: TYPE_NORMAL
