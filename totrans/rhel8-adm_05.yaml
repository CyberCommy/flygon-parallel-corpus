- en: '*Chapter 4*: Tools for Regular Operations'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point in this book, we've installed a system, and we've covered some
    of the scripts we can create to automate tasks, so we've reached the point where
    we can focus on the system itself.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Having a system properly configured requires not only installing it but understanding
    how to run tasks at specific times, keeping all the services running appropriately,
    and configuring time synchronization, service management, boot targets (runlevels),
    and scheduled tasks, all of which we will be covering in this chapter.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn how to check the statuses of services, how to
    start, stop, and troubleshoot them, as well as how to keep the system clock in
    sync for your server or your whole network.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'The list of topics that will be covered is as follows:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Managing system services with systemd
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scheduling tasks with cron and systemd
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning about time synchronization with chrony and ntp
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking for free resources – memory and disk (free and df)
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding logs, using journald, and reading log files, including log preservation
    and rotation
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is possible for you to complete this chapter by using the virtual machine
    we created at the beginning of this book. Additionally, for testing the *NTP server*,
    it might be useful to create a second virtual machine that will connect to the
    first one as a client, following the same procedure we used for the first one.
    Additionally, required packages will be indicated within the text.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Managing system services with systemd
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you will learn how to manage **System Services**, runtime targets,
    and all about the service status with **systemd**. You will also learn how to
    manage system boot targets and services that should start at system boot.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '`systemd` (which you can learn a bit about at [https://www.freedesktop.org/wiki/Software/systemd/](https://www.freedesktop.org/wiki/Software/systemd/))
    is defined as a system daemon that''s used to manage the system. It came as a
    rework of how a system boots and starts, and it looks at the limitations related
    to the traditional way of doing it.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: 'When we think about system starting, we have the initial **kernel** and **ramdisk**
    load and execution, but right after that, services and scripts take control to
    make filesystems available. This helps prepare the services that provide the functionality
    we want from our system, such as the following:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Hardware detection
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additional filesystem activation
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Network initialization (wired, wireless, and so on)
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Network services (time sync, remote login, printers, network filesystems, and
    so on)
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User-space setup
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, most of the tools that existed before `systemd` came into play and
    worked on this in a sequential way, causing the whole boot process (from boot
    to user login) to become lengthy and be subject to delays.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Traditionally, this also meant we had to wait for the required service to be
    fully available before the next one that depended on it could be started, increasing
    the total boot time.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Some approaches were attempted, such as using *monit* or other tools that allow
    us to define dependencies, monitor processes, and even recover from failures,
    but in general, it was reusing an existing tool to perform other functions, trying
    to win the race regarding the fastest-booting system.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '`systemd` redesigned the process to focus on simplicity: start less processes
    and do more parallel execution. The idea itself sounds easy but requires redesigning
    a lot of what was taken for granted in the past, to focus on the needs of a new
    approach to improve OS performance.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: 'This redesign, which has provided lot of benefits, also came with a cost: it
    drastically changed the way systems used to boot, so there has been a lot of controversy
    on the adoption of `systemd` by different vendors, and even some efforts by the
    community to provide systemd-free variants.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: Rationalizing how services start so that only those that are required are started
    is a good way to accomplish efficiency, for example, there is no need to start
    Bluetooth, printer, or network services when the system is disconnected, there
    is no Bluetooth hardware, or no one is printing. With fewer services waiting to
    start, the system boot is not delayed by those waits and focuses on the ones that
    really need attention.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: On top of that, parallel execution allows us to have each service taking the
    time it needs to get ready but not make others wait, so in general, running services
    initialization in parallel allows us to maximize the usage of CPU, disk, and so
    on, and the wait times for each service are used by other services that are active.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '`systemd` also pre-creates the listening sockets before the actual daemon is
    started, so services that have requirements on other services can be started and
    be on a wait status until its dependencies are started. This is done without them
    losing any messages that are sent to them, so when the service is finally started,
    it will act on all the pending actions.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Let's learn a bit more about *systemd* as it will be required for several operations
    we're going to describe in this chapter.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '*Systemd* comes with the concept of units, which are nothing but configuration
    files. These units can be categorized as different types, based on their file
    extension:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Table_4.1.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
- en: Tip
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Don't feel overwhelmed by the different `systemd` unit types. In general, the
    most common ones are **Service**, **Timer**, **Socket**, and **Target**.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, these unit files are expected to be found in some specific folders:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Table_4.2.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
- en: As we mentioned earlier about the sockets, unit files for path, bus, and more
    are activated when a system's access to that path is performed, allowing services
    to be started when another one is requiring them. This adds more optimization
    for lowering system startup times.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: With that, we have learned about *systemd* unit types. Now, let's focus on the
    file structure of unit files.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Systemd unit file structure
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s get our hands dirty with an example: a system has been deployed with
    `sshd` enabled, and we need to get it running once the network has been initialized
    in the **runlevels**, which provide connectivity.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: 'As we mentioned previously, `systemd` uses unit files, and we can check the
    aforementioned folders or list them with `systemctl list-unit-files` . Remember
    that each file is a configuration file that defines what *systemd* should do;
    for example, `/usr/lib/systemd/system/chronyd.service`:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – chronyd.service contents'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_04_001.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.1 – chronyd.service contents
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: This file defines not only the traditional program to start and the PID file,
    but the dependencies, the conflicts, and soft dependencies, which provides enough
    information to `systemd` to decide on the right approach.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: If you're familiar with "*inifiles*," this file uses that approach, in that,
    it uses square brackets, `[` and `]`, for sections and then pairs of `key=value`
    for the settings in each section.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Section names are case-sensitive, so they will not be interpreted correctly
    if the proper naming convention is not used.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: 'Section directives are named like so:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '`[Unit]`'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[Install]`'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are additional entries for each of the different types:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '`[Service]`'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[Socket]`'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[Mount]`'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[Automount]`'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[Swap]`'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[Path]`'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[Timer]`'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[Slice]`'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As you can see, we have specific sections for each type. If we execute `man
    systemd.unit` it will give you examples, along with all the supported values,
    for the *systemd* version you''re using:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 – man page of systemd.unit'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_04_002.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.2 – man page of systemd.unit
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: With that, we have reviewed the file structure of unit files. Now, let's use
    *systemctl* to actually manage the service's status.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Managing services to be started and stopped at boot
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Services can be enabled or disabled; that is, the services will or won't be
    activated on system startup.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: If you're familiar with the previous tools available in RHEL, it was common
    to use `chkconfig` to define the status of the services based on their default
    `rc.d/` settings.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: 'A service, such as `sshd`, can be enabled via the following command:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'It can also be disabled via the following command:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This results in creating or removing `/etc/systemd/system/multi-user.target.wants/sshd.service`.
    Notice `multi-user.target` in the path, which is the equivalent of the runlevel
    we used to configure other approaches such as **initscripts**.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: Although traditional usage of `chkconfig sshd on/off` or `service start/stop/status/restart
    sshd` is valid, it is better to get used to the `systemctl` approach described
    in this chapter.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: The previous commands enable or disable the service at boot, but for executing
    an immediate action, we need to issue different commands.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: 'To start the `sshd` service, use the following command:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To stop it, use the following command:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Of course, we can also check the service''s status. The following is an example
    of looking at `systemd` via `systemctl status sshd`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3 – Status of sshd daemon'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_04_003.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.3 – Status of sshd daemon
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: This status information provides details about the unit file defining the service,
    its default status at boot, if it is running or not, its PID, some other details
    about its resource consumption, and some of the most recent log entries for the
    service, which are quite useful when you're debugging simple service start failures.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: One important thing to check is the output of `systemctl list-unit-files` as
    it reports the defined unit files in the system, as well as the current status
    and the vendor preset for each one.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have covered how to start/stop and status check services, let's
    work on managing the actual system boot status itself.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: Managing boot targets
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The default status we have defined at boot is important when it comes to talking
    about **runlevels**.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: A runlevel defines a predefined set of services based on usage; that is, they
    define which services will be started or stopped when we're using a specific functionality.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, there are runlevels that are used to define the following:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '**Halt mode**'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Single user mode**'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Multi-user mode**'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Networked multiuser**'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Graphical**'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reboot**'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Each of those runlevels allows a predefined set of services to be started/stopped
    when the runlevel is changed with `init $runlevel`. Of course, levels used to
    be based on each other, and were very simple:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: Halt stopped all the services and then halted or powered off the system.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Single user mode starts a shell for one user.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multi-user mode enables regular login daemons on the virtual terminals.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Networked is like multi-user but with the network started.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Graphical is like networked but with graphical login via display manager (`gdm`
    or others).
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reboot is like halt, but at the end of processing services, it issues a reboot
    instead of a halt.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These runlevels (and the default one when the system is booted) used to be
    defined in `/etc/inittab`, but the file placeholder reminds us of the following:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: So, by making this change to `systemd`, a new way to check the available boot
    targets and define them is in place.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: 'We can find the available system targets by listing this folder:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Or more, correctly, we can use `systemctl`, like so:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: When you examine the output on your system, you will find some compatibility
    aliases for runlevels 0 to 6 that provide compatibility with the traditional ones.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: For example, for regular server usage, the default target will be `multi-user.target`
    when you're running without graphical mode or `graphical.target` when you're using
    it.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: 'We can define, as instructed in the placeholder at `/etc/inittab`, the new
    runlevel to use by executing the following command:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We can verify the active one by using the following command:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This brings us to the next question: *What does a target definition look like*?
    Let''s examine the output in the following screenshot:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这就引出了下一个问题：*目标定义是什么样的*？让我们来看一下以下截图中的输出：
- en: '![Figure 4.4 – Contents of runlevel 5 from its target unit definition'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.4 - 从其目标单元定义的运行级别5的内容'
- en: '](img/B16799_04_004.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16799_04_004.jpg)'
- en: Figure 4.4 – Contents of runlevel 5 from its target unit definition
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4 - 从其目标单元定义的运行级别5的内容
- en: As you can see, it is set as a dependency of another target (**multi-user.target**)
    and has some requirements on other services, such as **display-manager.service**,
    and also other conflicts, and the target can only be reached when other targets
    have completed.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，它被设置为另一个目标（**multi-user.target**）的依赖项，并且对其他服务（如**display-manager.service**）有一些要求，还有其他冲突，只有在其他目标完成时才能达到该目标。
- en: In this way, `systemd` can select the proper order of services to start and
    the dependencies to reach the configured boot target.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，`systemd`可以选择适当的服务启动顺序和达到配置的引导目标的依赖关系。
- en: With that, we have covered the service's status, as well as how to start, stop,
    and enable it on boot, but there are other tasks we should execute in our system
    but in a periodic way. Let's get further into this topic.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们已经了解了服务的状态，以及如何在启动时启动、停止和启用它，但是还有其他任务我们应该以周期性的方式在系统中执行。让我们进一步探讨这个话题。
- en: Scheduling tasks with cron and systemd
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用cron和systemd进行任务调度
- en: The skills you will learn in this section will be concerned with scheduling
    periodic tasks in the system for business services and maintenance.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在本节中学习的技能将涉及为业务服务和维护安排周期性任务。
- en: For regular system usage, there are tasks that need to be executed periodically,
    ranging from temporary folder cleanup, updating the cache's refresh rate, and
    performing check-in with inventory systems, among other things.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 对于常规的系统使用，有一些需要定期执行的任务，范围从临时文件夹清理、更新缓存的刷新率，到与库存系统进行检查等等。
- en: The traditional way to set them up is via `c``ronie` package.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 设置它们的传统方式是通过`cronie`软件包。
- en: Cronie implements a daemon that's compatible with the traditional *vixie cron*
    and allows us to define both user and system crontabs.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Cronie实现了一个与传统的*vixie cron*兼容的守护程序，允许我们定义用户和系统crontab。
- en: A crontab defines several parameters for a task that must be executed. Let's
    see how it works.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Crontab定义了必须执行的任务的几个参数。让我们看看它是如何工作的。
- en: System-wide crontab
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 系统范围的crontab
- en: System-wide crontab can be defined in `/etc/crontab` or in individual files
    at `/etc/cron.d`. Other additional folders exist, such as `/etc/cron.hourly`,
    `/etc/cron.daily`, `/etc/cron.weekly`, and `/etc/cron.monthly`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 系统范围的crontab可以在`/etc/crontab`中定义，也可以在`/etc/cron.d`中的单独文件中定义。还存在其他附加文件夹，如`/etc/cron.hourly`、`/etc/cron.daily`、`/etc/cron.weekly`和`/etc/cron.monthly`。
- en: In the folders for *hourly*, *daily*, *weekly*, or *monthly*, you can find scripts
    or symbolic links to them. When the period since the preceding execution is met
    (one hour, one day, one week, one month), the script will be executed.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在*每小时*、*每天*、*每周*或*每月*的文件夹中，您可以找到脚本或符号链接。当满足自上次执行以来的时间段（一小时、一天、一周、一个月）时，将执行该脚本。
- en: In contrast, in `/etc/crontab` or `/etc/cron.d`, as well as in the user crontabs,
    the standard definition of jobs is used.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，在`/etc/crontab`或`/etc/cron.d`以及用户crontab中，使用标准的作业定义。
- en: 'Jobs are defined by specifying the parameters that are relevant to the execution
    period, the user that will be executing the job (except for user crontabs), and
    the command to execute:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 通过指定与执行周期相关的参数、将执行作业的用户（除了用户crontab外）和要执行的命令来定义作业：
- en: '[PRE9]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'By looking at the standard `/etc/crontab` file, we can check the meaning of
    each field:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看标准的`/etc/crontab`文件，我们可以检查每个字段的含义：
- en: '[PRE10]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Based on this, if we check the initial example, `01 * * * * root run-parts
    /etc/cron.hourly`, we can deduce the following:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 基于此，如果我们检查初始示例`01 * * * * root run-parts /etc/cron.hourly`，我们可以推断如下：
- en: Run at minute `01`.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每分钟运行`01`。
- en: Run every hour.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每小时运行。
- en: Run every day.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每天运行。
- en: Run every month.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每月运行。
- en: Run every day of the week.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每周的每一天运行。
- en: Run as `root`.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以`root`身份运行。
- en: Execute the `run-parts /etc/cron.hourly` command.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行`run-parts /etc/cron.hourly`命令。
- en: This, in brief, means that the job will run on the first minute of every hour
    as the `root` user.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，这意味着作业将以`root`用户身份在每小时的第一分钟运行。
- en: Sometimes, it is possible to see an indication, such as **/number*, which means
    that the job will be executed every multiple of that number. For example, **/3*
    will run every 3 minutes if it is on the first column, every 3 hours if it's on
    the second, and so on.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，可能会看到一个指示，比如**/number*，这意味着作业将在该数字的倍数上执行。例如，**/3*将在第一列上每3分钟运行一次，在第二列上每3小时运行一次，依此类推。
- en: Any command we might execute from the command line can be executed via cron,
    and the output will be, by default, mailed to the user running the job. It is
    a common practice to either define the user that will receive the email via the
    `MAILTO` variable in the crontab file, or to redirect them to the appropriate
    log files for the standard output and standard error (`stdout` and `stderr`).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过cron执行从命令行执行的任何命令，并且默认情况下，输出将通过邮件发送给运行作业的用户。通常的做法是在crontab文件中定义将接收电子邮件的用户的`MAILTO`变量，或者将它们重定向到适当的日志文件以获取标准输出和标准错误（`stdout`和`stderr`）。
- en: User crontab
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户crontab
- en: Like the system-wide **crontab**, users can define their own crontabs so that
    tasks are executed by the user. This is, for example, useful for running periodic
    scripts both for a human user or a system account for a service.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 与系统范围的**crontab**一样，用户可以定义自己的crontab，以便用户执行任务。例如，这对于为人类用户或服务的系统帐户运行周期性脚本非常有用。
- en: The syntax for user crontabs is the same as it is system-wide. However, the
    column for the username is not there, since it is always executed as the user
    is defining the crontab itself.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 用户crontab的语法与系统范围的语法相同。但是，用户名的列不在那里，因为它总是作为定义crontab本身的用户执行。
- en: 'A user can check its crontab via `crontab –l`:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以通过`crontab -l`检查其crontab：
- en: '[PRE11]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: A new one can be created by editing it via `crontab -e`, which will open a text
    editor so that a new entry can be created.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过编辑`crontab -e`来创建一个新的，这将打开一个文本编辑器，以便创建一个新的条目。
- en: 'Let''s work with an example by creating an entry, like this:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过创建一个条目来举例说明，就像这样：
- en: '[PRE12]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'When we exit the editor, it will reply with the following:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们退出编辑器时，它会回复以下内容：
- en: '[PRE13]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This will create a file in the `/var/spool/cron/` folder with the name of the
    user that created it. It is a text file, so you can check its contents directly.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在`/var/spool/cron/`文件夹中创建一个文件，文件名为创建它的用户。它是一个文本文件，因此您可以直接检查其内容。
- en: 'After some time (at least 2 minutes), we''ll have a file in our `$HOME` folder
    that contains the contents of each execution (because we''re using the *append*
    redirect; that is, `>>`):'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 一段时间后（至少2分钟），我们将在我们的`$HOME`文件夹中有一个包含每次执行内容的文件（因为我们使用*追加*重定向；即`>>`）：
- en: '[PRE14]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now that we've covered the traditional crontab, let's learn about the systemd
    way of doing things; that is, using timers.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了传统的crontab，让我们了解一下systemd的做事方式；也就是使用定时器。
- en: Systemd timers
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Systemd定时器
- en: Apart from the regular **Cron Daemon**, a cron-style systemd feature is to use
    **timers**. A timer allows us to define, via a unit file, a job that will be executed.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 除了常规的**Cron守护程序**，cron风格的systemd功能是使用**定时器**。定时器允许我们通过一个单元文件定义将要执行的作业。
- en: 'We can check the ones that are already available in our system with the following
    code:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下代码检查系统中已经可用的定时器：
- en: '[PRE15]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let''s see, for example, `fstrim.timer`, which is used on SSD drives to perform
    a trim at `/usr/lib/systemd/system/fstrim.timer`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们来看一下`fstrim.timer`，它用于SSD驱动器在`/usr/lib/systemd/system/fstrim.timer`执行修剪：
- en: '[PRE16]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The preceding timer sets a weekly execution for `fstrim.service`:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 上述定时器设置了每周执行`fstrim.service`：
- en: '[PRE17]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As the `fstrim -av` command shows, we are only executing this once.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 正如`fstrim -av`命令所示，我们只执行一次。
- en: One of the advantages of having the service timers as unit files, similar to
    the service itself, is that it can be deployed and updated via the `/etc/cron.d/`
    files with the regular *cron* daemon, which is handled by *systemd*.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 服务定时器与服务本身一样，作为单元文件的一个优点是，它可以通过`/etc/cron.d/`文件与常规的*cron*守护程序一起部署和更新，这由*systemd*处理。
- en: We now know a bit more about how to schedule tasks, but to get the whole picture,
    scheduling always requires proper timing, so we'll cover this next.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对如何安排任务有了更多了解，但要获得完整的图片，安排总是需要适当的时间，所以下面我们将介绍这一点。
- en: Learning about time synchronization with chrony and NTP
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习使用chrony和NTP进行时间同步
- en: In this section, you will understand the importance of **time synchronization**
    and how to configure the service.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将了解**时间同步**的重要性以及如何配置服务。
- en: With connected systems, it is important to keep a source of truth in regards
    to timing (think about bank accounts, incoming transfer wires, outgoing payments,
    and more that must be correctly timestamped and sorted). Also, consider tracing
    logs between users connecting, issues happening, and so on; they all need to be
    in sync so that we can diagnose and debug between all the different systems involved.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 对于连接的系统，保持与时间相关的真相是很重要的（考虑银行账户、收款转账、出款支付等，这些都必须被正确地时间戳和排序）。此外，考虑用户连接之间的日志跟踪、发生的问题等；它们都需要同步，以便我们可以在涉及到的所有不同系统之间进行诊断和调试。
- en: You might think that the system clock, which is defined when the system is provisioned,
    should be OK, but setting the system clock is not enough as the clocks tend to
    drift; internal batteries can cause the clock to drift or to even reset, and even
    intense CPU activity can affect it. To keep clocks accurate, they need to be regularly
    synced against a reference clock that fixes the drift and tries to anticipate
    future drifts before the local clock is compared against the remote reference.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会认为在系统配置时定义的系统时钟应该是正常的，但仅仅设置系统时钟是不够的，因为时钟往往会漂移；内部电池可能导致时钟漂移或甚至重置，甚至强烈的CPU活动也会影响它。为了保持时钟的准确性，它们需要定期与修正漂移并尝试预测未来漂移的参考时钟同步。
- en: The system clock can be synced against a *GPS* unit, for example, or more easily
    against other systems that have connections to more precise clocks (other GPS
    units, atomic clocks, and so on). The **Network Time Protocol** (**NTP**) is an
    internet protocol that's used over UDP to maintain communication between the clients
    and the servers.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 系统时钟可以与*GPS*设备同步，例如，或者更容易地与其他连接到更精确时钟的系统同步（其他GPS设备、原子钟等）。**网络时间协议**（**NTP**）是一种互联网协议，通过UDP用于维护客户端和服务器之间的通信。
- en: Tip
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: NTP organizes servers by stratum. A stratum 0 device is a GPS device or an atomic
    clock that directly sends the signal to a server, a stratum 1 server (primary
    server) is connected to a stratum 0 device, a stratum 2 server is connected to
    stratum 1 servers, and so on... This hierarchy allows us to reduce the usage of
    higher stratum servers but also keep a reliable time source for our systems.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: NTP通过层级来组织服务器。层级0设备是GPS设备或原子钟，直接向服务器发送信号，层级1服务器（主服务器）连接到层级0设备，层级2服务器连接到层级1服务器，依此类推...这种层级结构允许我们减少对更高层级服务器的使用，同时为我们的系统保持可靠的时间来源。
- en: Clients connect to servers and compare the times that are received to reduce
    the effects of network latency.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端连接到服务器，并比较接收到的时间以减少网络延迟的影响。
- en: Let's see how the NTP client works.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看NTP客户端是如何工作的。
- en: NTP client
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NTP客户端
- en: In RHEL8, *chrony* acts as both the server (when enabled) and the client (via
    the `chronyc` command), and it comes with some features that make it suitable
    for current hardware and user needs, such as fluctuating networks (laptop is suspend/resumed
    or flaky connections).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在RHEL8中，*chrony*在启用时充当服务器和客户端（通过`chronyc`命令），并且具有一些功能，使其适用于当前的硬件和用户需求，例如波动的网络（笔记本电脑挂起/恢复或不稳定的连接）。
- en: 'One interesting feature is that *chrony* does not **step** the clock after
    its initial sync, which means that the time doesn''t *jump*. Instead, the system
    clock runs faster or slower so that, after a period of time, it will be in sync
    with the reference clock it''s using. This makes the time to be a continuum from
    the operating system and application''s point of view: the seconds are going faster
    or slower than what they should be, if compared against a clock, until they match
    the reference clock.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: Chrony is configured via `/etc/chrony.conf` and acts as a client, so it connects
    to servers to check if they're eligible to be the time source. The main difference
    between the traditional **server** directive and the **pool** is that the latter
    can receive several entries while the former only uses one. It is possible to
    have several servers and pool because, in effect, the servers will be added to
    the list of possible sources once the duplicates have been removed.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: For *pool* or *server* directives, there are several options available (described
    in `man chrony.conf`), such as `iburst`, which enables faster checks so that they
    can quickly transition to a synchronized status.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: 'The actual sources for time can be checked with `chronyc sources`:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5 – chronyc sources output'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_04_005.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.5 – chronyc sources output
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: 'As we can see, we know which status is for each server based on the first column
    (**M**):'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '**^**: This is a server'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**=**: This is a peer'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the second column (S), we can see the different statuses for each entry:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '*****: This is our current synchronized server.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**+**: This is another acceptable time source.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**?**: This is used to indicate sources that has lost network connectivity.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**x**: This server is considered a false ticker (its time is considered inconsistent
    compared to other sources).'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**~**: A source that has a high variability (it also appears during daemon
    startup).'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, we can see that our system is connected to a server that is considering
    the reference at `ts1.sct.de`, which is a stratum 2 server.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: 'More detailed information can be checked via the `chronyc tracking` command:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.6 – Chronyc tracking output'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_04_006.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.6 – Chronyc tracking output
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: 'This provides more detailed information about our clock and our reference clock.
    Each field in the preceding screenshot has the following meaning:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '**Field**: Description.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reference ID**: ID and name/IP of the server that the system has synchronized.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stratum**: Our stratum level. In this example, our synchronized server is
    a stratum 3 clock.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ref time**: The last time the reference was processed.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**System time**: When running in normal mode (without time skip), this references
    how far away or behind the system is from the reference clock.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Last offset**: Estimated offset on the last clock update. If it''s positive,
    this indicates that our local time was ahead of our source.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**RMS offset**: Long-term average of the offset value.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Frequency**: It is the rate at which the system clock would be wrong if *chronyd*
    is not fixing it, expressed in parts per million.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Residual freq**: Reflects any difference between the measurements for the
    current reference clock.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Skew**: Estimated error on the frequency.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Root delay**: Total network delays to the stratum -1 synchronized server.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Root dispersion**: Total dispersion accumulated through all the computers
    connected to the stratum -1 server we''re synchronized to.'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Update interval**: Interval between the last two clock updates.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/usr/share/doc/program/`), and more. For example, more detailed information
    about each field listed here can be found via the `man chronyc` command.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To configure the client with additional options, other than the ones provided
    at install time or via the kickstart file, we can edit the `/etc/chrony.cnf` file.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: Let's learn how to convert our system into an NTP server for our network.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: NTP server
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we introduced earlier, *chrony* can also be configured as a server for your
    network. In this mode, our system will be providing accurate clock information
    to other hosts without consuming external bandwidth or resources from higher-stratum
    servers.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前介绍的，*chrony*也可以配置为您的网络的服务器。在这种模式下，我们的系统将向其他主机提供准确的时钟信息，而不消耗来自更高层级服务器的外部带宽或资源。
- en: 'This configuration is also performed via the `/etc/chrony.conf` file, which
    is where we will be adding a new directive; that is, `allow`:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配置也是通过`/etc/chrony.conf`文件进行的，我们将在这里添加一个新的指令；即`allow`：
- en: '[PRE18]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This change enables *chrony* to listen on all host requests. Alternatively,
    we can define a subnet or host to listen to, such as `allow 1.1.1.1`. More than
    one directive can be used to define the different subnets. Alternatively, you
    can use the *deny* directive to block specific hosts or subnets from reaching
    our NTP server.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 此更改使*chrony*能够监听所有主机请求。或者，我们可以定义一个子网或主机来监听，例如`allow 1.1.1.1`。可以使用多个指令来定义不同的子网。另外，您可以使用*deny*指令来阻止特定主机或子网访问我们的NTP服务器。
- en: The serving time starts from the base that our server is already synchronized
    with, as well as an external NTP server, but let's think about an environment
    without connectivity. In this case, our server will not be connected to an external
    source and it will not serve time.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 服务时间从我们的服务器已经与之同步的基础开始，以及一个外部NTP服务器，但让我们考虑一个没有连接性的环境。在这种情况下，我们的服务器将不连接到外部来源，也不会提供时间。
- en: '*chrony* allows us to define a fake stratum for our server. This is done via
    the `local` directive in the configuration file. This allows the daemon to get
    a higher local stratum so that it can serve the time to other hosts; for example:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '*chrony*允许我们为我们的服务器定义一个虚假的层级。这是通过配置文件中的`local`指令完成的。这允许守护程序获得更高的本地层级，以便它可以向其他主机提供时间；例如：'
- en: '[PRE19]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: With this directive, we're setting the local stratum to 3 and we're using the
    **orphan** option, which enables a special mode in which all the servers with
    an equal local stratum are ignored unless no other source can be selected, and
    its reference ID is smaller than the local one. This means that we can set several
    NTP servers in our disconnected network but only one of them will be the reference.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个指令，我们将本地层级设置为3，并使用**orphan**选项，这将启用一个特殊模式，在这个模式下，所有具有相同本地层级的服务器都会被忽略，除非没有其他来源可供选择，且其参考ID小于本地ID。这意味着我们可以在我们的断开网络中设置几个NTP服务器，但只有一个会成为参考。
- en: Now that we have covered time synchronization, we are going to dive into resource
    monitoring. Later, we'll look at logging. All of this is related to our time reference
    for the system.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经涵盖了时间同步，我们将深入资源监视。稍后，我们将研究日志记录。所有这些都与我们系统的时间参考有关。
- en: Checking for free resources – memory and disk (free and df)
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查空闲资源 - 内存和磁盘（free和df）
- en: In this section, you will check the availability of system **resources** such
    as **memory** and **disk**.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，您将检查系统**资源**的可用性，例如**内存**和**磁盘**。
- en: Keeping a system running smoothly means using monitoring so that we can check
    that the services are running and that the system provides the resources for them
    to do their tasks.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 保持系统平稳运行意味着使用监视，以便我们可以检查服务是否正在运行，以及系统是否为它们提供了资源来执行它们的任务。
- en: 'There are simple commands we can use to monitor the most basic use cases:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些简单的命令可以用来监视最基本的用例：
- en: Disk
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 磁盘
- en: CPU
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CPU
- en: Memory
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存
- en: Network
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络
- en: This includes several ways of monitoring, such as one-shot monitoring, continuously,
    or even for a period of time to diagnose performance better.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这包括几种监视方式，例如一次性监视、连续监视，或者甚至在一段时间内进行诊断性能更好。
- en: Memory
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内存
- en: Memory can be monitored via the `free` command. It provides details on how much
    *RAM* and *SWAP* are available and in use, which also indicates how much memory
    is used by shares, buffers, or caches.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 内存可以通过`free`命令进行监视。它提供了有关可用和正在使用多少*RAM*和*SWAP*的详细信息，这也表明了多少内存被共享、缓冲或缓存使用。
- en: 'Linux tends to use all available memory; any unused RAM is directed toward
    caches or buffers and memory pages that are not being used. These are swapped
    out to disk if available:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: Linux倾向于使用所有可用的内存；任何未使用的RAM都会被指向缓存或缓冲区，以及未被使用的内存页面。如果可用，这些将被交换到磁盘上：
- en: '[PRE20]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: For example, in the preceding output, we can see that the system has a total
    of 823 MB of RAM and that it's using some swap and some memory for buffers. This
    system is not swapping heavily as it's almost idle (we'll check the load average
    later in this chapter), so we should not be concerned about it.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在上面的输出中，我们可以看到系统总共有823 MB的RAM，并且它正在使用一些交换空间和一些内存用于缓冲。这个系统没有大量交换，因为它几乎处于空闲状态（我们将在本章后面检查负载平均值），所以我们不应该担心它。
- en: When RAM usage gets high and there's no more swap available, the kernel includes
    a protection mechanism called **OOM-Killer**. It determines, based on time in
    execution, resources usage, and more which processes in the system should be terminated
    to recover the system so that it's functional. This, however, comes at a cost,
    as the kernel knows about the processes that may have gone out of control. However,
    the killer may kill databases and web servers and leave the system in an unstable
    way. For production servers, it is sometimes typical to, instead of letting the
    OOM-Killer start killing processes in an uncontrolled way, to either tune the
    values for some critical process so that those are not killed or to cause a system
    crash.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 当RAM使用量很高且没有更多的交换空间可用时，内核会包括一种保护机制，称为**OOM-Killer**。它根据执行时间、资源使用情况等确定系统中应终止哪些进程以恢复系统，使其正常运行。然而，这是有代价的，因为内核知道可能已经失控的进程。然而，杀手可能会杀死数据库和Web服务器，并使系统处于不稳定状态。对于生产服务器，有时候典型的做法是，不是让OOM-Killer开始以不受控制的方式杀死进程，而是调整一些关键进程的值，使它们不被杀死，或者导致系统崩溃。
- en: A system crash is used to collect debug information that can later be analyzed
    via a dump containing information about what caused the crash, as well as a memory
    dump that can be diagnosed.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: We will come back to this topic in [*Chapter 16*](B16799_16_Final_SK_ePub.xhtml#_idTextAnchor200),
    *Kernel Tuning and Managing Performance Profiles with tuned*. Let's move on and
    check the disk space that's in use.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: Disk space
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Disk space can be checked via the `df` provides data as output for each filesystem.
    This indicates the filesystem and its size, available space, percent of utilization,
    and mount point.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s check this in our example system:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: By using this, it's easy to focus on filesystems with higher utilization and
    less free space to prevent issues.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: If a file is being written, such as by a process logging its output, removing
    the file will just unlink the file from the filesystem, but since the process
    still has the file handle open, the space is not reclaimed until the process is
    stopped. In case of critical situations where disk space must be made available
    as soon as possible, it's better to empty the file via a redirect, such as `echo
    "" > filename`. This will recover the disk space immediately while the process
    is still running. Doing this with `rm` command will require the process to be
    finalized.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: We'll check out CPU usage next.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: CPU
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When it comes to monitoring the CPU, we can make use of several tools, such
    as `ps`:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.7 – Output of the ps aux command (every process in the system)'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_04_007.jpg)'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.7 – Output of the ps aux command (every process in the system)
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: The `ps` command is the de facto standard for checking which process is running,
    as well as resource consumption usage.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: As for any other command, we could write a lot about all the different command
    arguments we could use (so, again, check the man page for details), but as a rule,
    try to learn about their basic usage or the ones that are more useful for you.
    For anything else, check the manual. For example, `ps aux` provides enough information
    for normal usage (every process in the system).
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: 'The `top` tool, as shown in the following screenshot, refreshes the screen
    regularly and can sort the output of running processes, such as CPU usage, memory
    usage, and more. In addition, `top` also shows a five-line summary of memory usage,
    `load average`, running processes, and so on:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.8 – top execution on our test system'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_04_008.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.8 – top execution on our test system
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: CPU usage is not the only thing that may keep our system sluggish. Now, let's
    learn a bit about load average indicators.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: Load average
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Load average is usually provided as a group of three numbers, such as `load
    average: 0.81, 1.00, 1.17`, which is the average that''s calculated for 1, 5,
    and 15 minutes, respectively. This indicates how busy a system is; the higher
    it is, the worse it will respond. The values that are compared for each time frame
    give us an idea of whether the system load is increasing (higher values in 1 or
    5 and lower on 15) or if it is going down (higher at 15 mins, lower at 5 and 1),
    so it becomes a quick way to find out if something happened or if it is ongoing.
    If a system usually has a high load average (over 1.00), it would be a good idea
    to dig a bit deeper into the possible causes (too much demand for its power, not
    many resources available, and so on).'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have covered the basics, let's move on and look at some extra checks
    we can perform on our system resource's usage.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: Other monitoring tools
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For `ifconfig`, for example, and match the values that are received for transmitted
    packages, received, errors, and so on.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: When the goal Is to perform more complete monitoring, we should ensure that
    the `/var/log/sa/`.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: The historical data that's recorded and stored per day (`##`) at `/var/log/sa/sa##`
    and `/var/log/sa/sar##` can be queried so that we can compare against other days.
    By running the data collector (which is executed by a *systemd* timer) with a
    higher frequency, we can increase the granularity for specific periods while an
    issue is being investigated.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: 'However, the appearance of the *sar* file is showing lots of data:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.9 – Contents of /var/log/sar02 on the example system'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_04_009.jpg)'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.9 – Contents of /var/log/sar02 on the example system
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we can see that the 8-0 device had 170.27 transactions per second and
    14.51% utilization. In this case, the device''s name is using the values for the
    major/minor, which we can check in the `/dev/` folder. We can see this by running
    `ls -l /dev/*|grep 8`, as shown in the following screenshot:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.10 – Directory listing for /dev/ for locating the device corresponding
    to major 8 and minor 0'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_04_010.jpg)'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.10 – Directory listing for /dev/ for locating the device corresponding
    to major 8 and minor 0
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: Here, we can see that this corresponds to the full hard drive statistics at
    `/dev/sda`.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: Processing the data via **sar** is a good way to get insights on what's going
    on with our system, but since the *sysstat* package has been around for a long
    time in Linux, there are tools such as [https://github.com/mbaldessari/sarstats](https://github.com/mbaldessari/sarstats)
    that help us process the data that's recorded and present it graphically as a
    PDF file.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following graph, we can see the system service times for the different
    drives, along with a label at the time the system crashes. This helps us identify
    the system''s activity at that point:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.11 – Sarstats graphics for the disk service''s time in their example
    PDF at https://acksyn.org/software/sarstats/sar01.pdf'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_04_011.jpg)'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.11 – Sarstats graphics for the disk service's time in their example
    PDF at [https://acksyn.org/software/sarstats/sar01.pdf](https://acksyn.org/software/sarstats/sar01.pdf
    )
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: Modern tooling for monitoring the system's resources has evolved, and **Performance
    Co-Pilot** (**pcp** and, optionally, the **pcp-gui** packages) can be set up for
    more powerful options. Just bear in mind that pcp requires us to also start the
    data collector on the system.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: RHEL8 also includes **cockpit**, which is installed by default when we do a
    server installation. This package provides a set of tools that enable web management
    for the system, and it can also be made part of other products via plugins that
    extend its functionality.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: The web service provided by cockpit can be reached at your host IP at port `9090`,
    so you should access `https://localhost:9090` to get a login screen so that we
    can use our system credentials to log in.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: Important Tip
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: If cockpit is not installed or available, make sure that you execute `dnf install
    cockpit` to install the package and use `systemctl enable --now cockpit.socket`
    to start the service. If you are accessing the server remotely, instead of using
    `localhost`, use the server hostname or IP address after allowing the firewall
    to connect via `firewall-cmd --add-service=cockpit`, if you haven't done so previously.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: 'After logging in, we will see a dashboard showing the relevant system information
    and links to other sections, as shown in the following screenshot:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.12 – Cockpit screen after logging in with a system dashboard'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_04_12.jpg)'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.12 – Cockpit screen after logging in with a system dashboard
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, *cockpit* includes several tabs that can be used to view the
    status of the system and even perform some administration tasks, such as **SELinux**,
    software updates, subscriptions, and more.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can check the system graphs on performance, as shown in the
    following screenshot:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.13 – Cockpit graphs in the dashboard for Usage Graphs'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_04_13.jpg)'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.13 – Cockpit graphs in the dashboard for Usage Graphs
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: Cockpit allows us to check a service's status, package upgrade status, plus
    other configuration settings from a graphical interface that can also connect
    remotely to other systems. These can be selected from the lateral menu on the
    left.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: There are better tools suited for large deployment monitoring and management,
    such as *Ansible* and *Satellite*, so it is important to get used to the tools
    we have for troubleshooting and simple scripts we can build. This allows us to
    combine what we've learned so far to quickly generate hints about things that
    require our attention.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: With that, we have covered some of the basics of checking resource usage. Now,
    let's check out how to find information about the running services and errors
    we can review.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: Finding logs, using journald, and reading log files, including log preservation
    and rotation
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you will learn how to review a system's status via logs.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: Previously in this chapter, we learned how to manage system services via *systemd*,
    check their status, and check their logs. Traditionally, the different daemons
    and system components used to create files under the `/var/log/` folder are based
    on the name of the daemon or service. If the service used to create several logs,
    it would do so inside a folder for the service (for example, **httpd** or **samba**).
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: The system log daemon, `rsyslogd`, has a new *systemd* partner, named `systemd-journald.service`,
    that also stores logs, but instead of using the traditional plain text format,
    it uses binary format, which can be queried via the `journalctl` command.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: It's really important to get used to reading the log files as it's the basis
    for troubleshooting, so let's learn about general logging and how to use it.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: 'Logs contain status information for the services that generate it. They might
    have some common formatting and can often be configured, but they tend to use
    several common elements, such as the following:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: Timestamp
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Module generating the entry
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Message
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is an example:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In this case, we can see that someone attempted to log into our system as the
    `admin` user from IP address `49.232.135.77`.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: We can correlate that event with additional logs, such as the ones for the login
    subsystem via `journalctl -u systemd-logind`. In this example, we cannot find
    any login for the `admin` user (this is expected as the `admin` user was not defined
    in this system).
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, we can see the name of the host, `el8-692807`, the service generating
    it, `sshd`, a `50197`, and the message that's been logged by that service.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to *journalctl*, there are additional logs that we can look at
    when we wish to check the system''s health. Let''s look at an example with `/var/log/messages`:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.14 – Excerpt of /var/log/messages'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_04_014.jpg)'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.14 – Excerpt of /var/log/messages
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we can see how the system ran some commands while following
    a similar output to the initial lines. For example, in the preceding example,
    we can see how `sysstat` has been executed every 10 minutes, as well as how the
    `dnf` cache has been updated.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at a list of important logs that are available in a standard system
    installation (note that the filenames are relative to `/var/log folder`):'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: '`boot.log`: Stores the messages that are emitted by the system during boot.
    It might contain escape codes that are used to provide colorized output.'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`audit/audit.log`: Contains the stored messages that have been generated by
    the Kernel audit subsystem.'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`secure`: Contains security-related messages, such as failed `sshd` login attempts.'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dnf.log`: Logs generated by the DNF package manager, such as cache refreshes.'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`firewalld`: Output generated by the *firewalld* daemon.'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lastlog`: This is a binary file that contains information about the last few
    users logging into the system (to be queried via the `last` command).'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`messages`: The default logging facility. This means that anything that is
    not a specific log will go here. Usually, this is the best place to start checking
    what happened with a system.'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`maillog`: The log for the mail subsystem. When enabled, it attempts to deliver
    messages. Any messages that are received will be stored here. It''s common practice
    to configure outgoing mail from servers so that system alerts or script outputs
    can be delivered.'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`btmp`: Binary log for failed access to the system.'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`wtmp`: Binary log for access to the system.'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sa/sar*`: Text logs for the *sysstat* utility (the binary ones, named *sa*,
    plus the day number, are converted via a *cron* job at night).'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additional log files might exist, depending on the services that have been installed,
    the installation method that was used, and so on. It is very important to get
    used to the available logs and, of course, review their contents to see how the
    messages are formatted, how many logs are created every day, and what kind of
    information they produce.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: Using the information that's been logged, we will get hints on how to configure
    each individual daemon. This allows us to adjust the log level between being showing
    just errors or being more verbose about debugging issues. This means we can configure
    the required log rotation to avoid risking system stability because all the space
    has been consumed by logs.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: Log rotation
  id: totrans-342
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: During regular system operation, lots of daemons are in use, and the system
    itself generates the logs that are used for troubleshooting and system checks.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: Some services might allow us to define the log file to write for based on the
    date, but usually, the standard is to log to a file named like the daemon in the
    `/var/log` directory; for example, `/var/log/cron`. Writing to the same file will
    cause the file to grow until the drive holding the logs is filled, which might
    not make sense as after a while (sometimes, under company-defined policies), logs
    are no longer useful.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: 'The `cron` entry that simplifies the log rotation process. It is configured
    via `/etc/logrotate.conf` and is executed on a daily basis, as shown here:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.15 – Example listing of logs and rotated logs (using date extension)'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_04_015.jpg)'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.15 – Example listing of logs and rotated logs (using date extension)
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: If we check the contents of the configuration file, we will see that it includes
    some file definitions either directly there or via drop-in files in the `/etc/logrotate.d/`
    folder, which allows each program to drop their own requirements without it affecting
    others when packages are installed, removed, or updated.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: Why is this important? Because, if you remember from of the tips earlier in
    this chapter (while speaking about disk space), if `logrotate` just deleted the
    files and created a new one, the actual disk space would not be freed, and the
    daemon writing to the log will continue to write to the file it was writing to
    (via the file handle). To overcome this, each definition file can define a post-rotation
    command. This signals the process of log rotation so that it can close and then
    reopen the files it uses for logging. Some programs might require a signal such
    as `kill –SIGHUP PID` or a special parameter on execution such as `chronyc cyclelogs`.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: With these definitions, `logrotate` will be able to apply the configuration
    for each service and, at the same time, keep the service working in a sane state.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: 'Configuration can also include special directives, such as the following:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: '`missingok`'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nocreate`'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nopytruncate`'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`notifempty`'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find out more about them (and others) on the `logrotate.conf` (yes,
    some packages also include a man page for the configuration files, so try checking
    `man logrotate.conf` to get the full details!).
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: The remaining general configuration in the main file allows us to define some
    common directives, such as how many days of logs to keep, if we want to use the
    date in the file extension for the rotated log files, if we want to use compression
    on the rotated logs, how frequently we want to have the rotation executed, and
    so on.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at some examples.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example will rotate on a `daily` basis, keep `30` rotated logs,
    `compress` them, and use an extension with `date` as part of its trailing filename:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In this example, it will keep `4` logs rotated on a `weekly` basis (so 4 weeks)
    and will `compress` the logs, but use a sequence number for each rotated log (this
    means that each time a rotation happens, the sequence number is increased for
    the previously rotated logs too):'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: One of the advantages of this approach (not using `dateext`) is that the log
    naming convention is predictable as we have `daemon.log` as the current one, `daemon.1.log`
    as the prior one, and so on. This makes it easier to script log parsing and processing.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-365
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about `systemd` and how it takes care of booting
    the required system services in an optimized way. We also learned how to check
    a service's status, how to enable, disable, start, and stop them, and how to make
    the system boot into the different targets that we boot our system into.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: Time synchronization was introduced as a must-have feature and it ensures our
    service functions properly. It also allows us to determine the status of our system
    clock and how to act as a clock server for our network.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: We also used system tools to monitor resource usage, learned how to check the
    logs that are created by our system to find about the functional status of the
    different tools, and how to can ensure that logs are maintained properly so that
    older entries are discarded when they are no longer relevant.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will dive into securing the system with different users,
    groups, and permissions.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
