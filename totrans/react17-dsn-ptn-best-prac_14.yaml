- en: Testing and Debugging
  prefs: []
  type: TYPE_NORMAL
- en: React, thanks to its components, makes it easy to test our applications. There
    are many different tools that we can use to create tests with React, and here
    we'll cover the most popular ones to understand the benefits they provide.
  prefs: []
  type: TYPE_NORMAL
- en: '**Jest**  is an *all-in-one* testing framework  solution, maintained by  Christopher
    Pojer  from Facebook and contributors within the community, and aims to give you
    the best developer experience.'
  prefs: []
  type: TYPE_NORMAL
- en: By the end of the chapter, you'll be able to create a test environment from
    scratch and write tests for your application's components.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will look at the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Why it is important to test our applications, and how they help developers move
    faster
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to set up a Jest environment to test components using Enzyme
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What React Testing Library is and why it is a *must-have* for testing React
    applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to test events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: React DevTools and some error-handling techniques
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To complete this chapter, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Node.js 12+
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visual Studio Code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can find the code for this chapter in the book''s GitHub Repository: [https://github.com/PacktPublishing/React-17-Design-Patterns-and-Best-Practices-Third-Edition/tree/main/Chapter11](https://github.com/PacktPublishing/React-17-Design-Patterns-and-Best-Practices-Third-Edition/tree/main/Chapter11).'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the benefits of testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing web UIs has always been a difficult job. From unit to *end-to-end* tests,
    the fact that the interfaces depend on browsers, user interactions, and many other
    variables makes it difficult to implement an effective testing strategy.
  prefs: []
  type: TYPE_NORMAL
- en: If you've ever tried to write end-to-end tests for the web, you'll know how
    complex it is to get consistent results and how the results are often affected
    by false negatives due to different factors, such as the network. Other than that,
    user interfaces are frequently updated to improve  the experience, maximize conversions,
    or simply add new features.
  prefs: []
  type: TYPE_NORMAL
- en: If tests are hard to write and maintain, developers are less prone to cover
    their applications. On the other hand, tests are pretty important because they
    make developers more confident with their code, which is reflected in speed and
    quality. If a piece of code is well tested (and the tests are well written), developers
    can be sure that it works and is ready to ship. Similarly, thanks to tests, it
    becomes easier to refactor the code because tests guarantee that the functionalities
    do not change during the rewrite.
  prefs: []
  type: TYPE_NORMAL
- en: Developers tend to focus on the feature they are currently implementing, and
    sometimes it is hard to know if other parts of the application are affected by
    those changes. Tests help to avoid regressions because they can tell if the new
    code breaks the old tests. Greater confidence in writing new features leads to
    faster releases.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the main functionalities of an application makes the code base more
    solid, and whenever a new bug is found, it can be reproduced, fixed, and covered
    by tests so that it does not happen again in the future.
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, React (and the component era) makes testing user interfaces easy and
    efficient. Testing components, or trees of components, is a less arduous job because
    every single part of the application has its responsibilities and boundaries.
    If components are built in the right way, if they are pure and aim for composability
    and reusability, they can be tested as simple functions.
  prefs: []
  type: TYPE_NORMAL
- en: Another great power that modern tools bring us is the ability to run tests using
    Node.js and the console. Spinning up a browser for every single test makes tests
    slower and less predictable, degrading the developer experience; instead, running
    the tests using the console is faster.
  prefs: []
  type: TYPE_NORMAL
- en: Testing components only in the console can sometimes give unexpected behaviors
    when they are rendered in a real browser, but in my experience this is rare. When
    we test React components, we want to make sure that they work properly and that,
    given different sets of props, their output is always correct.
  prefs: []
  type: TYPE_NORMAL
- en: We may also want to cover all the various states that a component can have.
    The state might change by clicking a button, so we write tests to check if all
    the event handlers are doing what they are supposed to do.
  prefs: []
  type: TYPE_NORMAL
- en: When all the functionalities of the component are covered, but we want to do
    more, we can write tests to verify the component's behavior on  **edge cases**.
    Edge cases are states that the component can assume when, for example, all the
    props are  `null`, or there is an error. Once the tests are written, we can be
    pretty confident that the component behaves as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Testing a single component is great, but it does not guarantee that multiple
    individually tested components will still work once they are put together. As
    we will see later, with React we can mount a tree of components and test the integration
    between them.
  prefs: []
  type: TYPE_NORMAL
- en: There are different techniques that we can use to write tests, and one of the
    most popular ones is  **test-driven development** (**TDD**). Applying TDD means
    writing the tests first and then writing the code to pass the tests.
  prefs: []
  type: TYPE_NORMAL
- en: Following this pattern helps us to write better code because we are forced to
    think more about the design before implementing the functionalities, which usually
    leads to higher quality.
  prefs: []
  type: TYPE_NORMAL
- en: Painless JavaScript testing with Jest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most important way to learn how to test React components in the right way
    is by writing some code, and that is what we are going to do in this section.
  prefs: []
  type: TYPE_NORMAL
- en: The React documentation says that at Facebook they use Jest to test their components.
    However, React does not force you to use a particular test framework, and you
    can use your favorite one without any problems. To see Jest in action, we are
    going to create a project from scratch, installing all the dependencies and writing
    a component with some tests. It'll be fun!
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing to do is to move into a new folder and run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Once `package.json` is created, we can start installing the dependencies, with
    the first one being the `jest` package itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'To tell `npm` that we want to use the `jest` command to run the tests, we have
    to add the following scripts to `package.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: To write components and tests using ES6 and JSX, we have to install all Babel-related
    packages so that Jest can use them to transpile and understand the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second set of dependencies is installed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As you may know, we now have to create a  `.babelrc`  file, which is used by
    Babel to know the presets and the plugins that we would like to use inside the
    project.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `.babelrc` file  looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, it is time to install React and `ReactDOM`, which we need to create and
    render components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The setup is ready, and we can run Jest against the ES6 code and render our
    components into the DOM, but there is one more thing to do.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to install `@testing-library/jest-dom` and `@testing-library/react`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'After you have installed these packages, you have to create the `jest.config.js`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, let''s create the `setUpTests.ts` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s imagine we have a `Hello` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to test this component, we need to create a file with the same name
    but add the `.test` (or `.spec`) suffix to the new file. This will be our test
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in order to run the `test`, you need to execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see this result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/bd39fedb-e1f8-4b12-bf54-84be4de6e301.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `PASS` label means that all tests have been passed successfully; if you
    failed at least one test, you would see the `FAIL` label. Let''s change one of
    our tests to make it fail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/12392022-1665-46d6-8972-36a2bb038acc.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the `FAIL` label is specified with an `X`. Also, the expected
    and received values provide useful information, and you can see which value is
    expected and which value is being received.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to see the coverage percentage of all your unit tests, you can
    execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/101fc17a-5565-4d30-a2ea-77dc069f6219.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The coverage also generates an HTML version of the result; it creates a directory
    called `coverage` and inside another called `Icov-report`. If you open the `index.html`
    file in your browser, you will see the HTML version as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/93b5b5e8-0c27-48db-a971-9a801f198362.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that you made your first tests and you know how to collect the coverage
    data, let's see how we can test events in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Testing events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The events are very common in any web application and we need to test them
    as well, so let''s learn how to test events. For this, let''s create a new `ShowInformation`
    component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s create the test file at `src/components/ShowInformation/index.test.tsx`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run the test and it works fine, you should see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/b2197c2a-99a7-4613-96c0-849c4db68bb5.png)'
  prefs: []
  type: TYPE_IMG
- en: Using React DevTools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When testing in the console is not enough, and we want to inspect our application
    while it is running inside the browser, we can use React DevTools.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can install this as a Chrome extension at the following URL: [https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi?hl=en](https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi?hl=en).'
  prefs: []
  type: TYPE_NORMAL
- en: The installation adds a tab to the Chrome DevTools called  **React**,  where
    you can inspect the rendered tree of components and check which properties they
    have received and what their state is at a particular point in time.
  prefs: []
  type: TYPE_NORMAL
- en: Props and states can be read, and they can be changed in real time to trigger
    updates in the UI and see the results straight away. This is a must-have tool,
    and in the most recent versions, it has a new feature that can be enabled by ticking
    the  Trace React Updates  checkbox.
  prefs: []
  type: TYPE_NORMAL
- en: When this functionality is enabled, we can use our application and visually
    see which components get updated when we perform a particular action. The updated
    components are highlighted with colored rectangles, and it becomes easy to spot
    possible optimizations.
  prefs: []
  type: TYPE_NORMAL
- en: Using Redux DevTools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you are using Redux in your application, you probably want to use Redux
    DevTools to be able to debug your Redux flow. You can install it at the following
    URL: [https://chrome.google.com/webstore/detail/redux-devtools/lmhkpmbekcpmknklioeibfkpmmfibljd?hl=es](https://chrome.google.com/webstore/detail/redux-devtools/lmhkpmbekcpmknklioeibfkpmmfibljd?hl=es).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, you need to install the `redux-devtools-extension` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Once you have installed React DevTools and Redux DevTools, you will need to
    configure them.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you try to use Redux DevTools directly, it won''t work; this is because
    we need to pass the `composeWithDevTools` method into the Redux store; this should
    be the `configureStore.ts` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This is the best tool to test our Redux applications.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about the benefits of testing, and the frameworks
    you can use to cover your React components with tests.
  prefs: []
  type: TYPE_NORMAL
- en: You learned how to implement and test components and events with React Testing
    Library, how to use the Jest coverage, and how to use React DevTools and Redux
    DevTools. It is important to bear in mind common solutions when it comes to testing
    complex components, such as higher-order components  or forms with multiple nested
    fields.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn how to implement routes in your application
    using React Router.
  prefs: []
  type: TYPE_NORMAL
