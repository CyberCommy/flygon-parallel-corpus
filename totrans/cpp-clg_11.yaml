- en: Cryptography
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 88\. Caesar cipher
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Write a program that can encrypt and decrypt messages using a Caesar cipher
    with a right rotation and any shift value. For simplicity, the program should
    consider only uppercase text messages and only encode letters, ignoring digits,
    symbols, and other types of characters.
  prefs: []
  type: TYPE_NORMAL
- en: 89\. Vigenère cipher
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Write a program that can encrypt and decrypt messages using the Vigenère cipher.
    For simplicity, the input plain-text messages for encryption should consist of
    only uppercase letters.
  prefs: []
  type: TYPE_NORMAL
- en: 90\. Base64 encoding and decoding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Write a program that can encode and decode binary data using the base64 encoding
    scheme. You must implement the encoding and decoding functions yourself and not
    use a 3^(rd) party library. The table used for encoding should be the one from
    the MIME specification.
  prefs: []
  type: TYPE_NORMAL
- en: 91\. Validating user credentials
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Write a program that simulates the way users authenticate to a secured system.
    In order to log in, a user must be already registered with the system. The user
    enters a username and a password and the program checks if it matches any of its
    registered users; if it does, the user is granted access, otherwise, the operation
    fails. For security reasons, the system must not record the password but use an
    SHA hash instead.
  prefs: []
  type: TYPE_NORMAL
- en: 92\. Computing file hashes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Write a program that, given a path to a file, computes and prints to the console
    the SHA1, SHA256, and MD5 hash values for the content of the file.
  prefs: []
  type: TYPE_NORMAL
- en: 93\. Encrypting and decrypting files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Write a program that can encrypt and decrypt files using the **Advanced Encryption
    Standard** (**AES** or **Rijndael**). It should be possible to specify both a
    source file and a destination file path, as well as a password.
  prefs: []
  type: TYPE_NORMAL
- en: 94\. File signing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Write a program that is able to sign files and verify that a signed file has
    not been tampered with, using RSA cryptography. When signing a file, the signature
    should be written to a separate file and used later for the verification process.
    The program should provide at least two functions: one that signs a file (taking
    as arguments the path to the file, the path to the RSA private key, and the path
    to the file where the signature will be written) and one that verifies a file
    (taking as arguments the path to the file, the path to the RSA public key, and
    the path to the signature file).'
  prefs: []
  type: TYPE_NORMAL
- en: Solutions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 88\. Caesar cipher
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A *Caesar cipher*, also known as *Caesar’s cipher*, *Caesar’s code*, *Caesar
    shift*, or *shift cipher*, is a very old, simple, and widely known encryption
    technique that substitutes each letter in the plain-text with a letter some fixed
    number of positions down the alphabet. This method was used by Julius Caesar to
    protect messages of military importance. He used a shift of three letters, therefore
    replacing A with D, B with E, and so on. In this encoding, the text CPPCHALLENGER
    becomes FSSFKDOOHQJHU. The cipher is described in detail on Wikipedia at [https://en.wikipedia.org/wiki/Caesar_cipher](https://en.wikipedia.org/wiki/Caesar_cipher).
  prefs: []
  type: TYPE_NORMAL
- en: Although the Caesar cipher has no place in modern cryptography since it is trivial
    to break, it is still used on online forums or newsgroups ...
  prefs: []
  type: TYPE_NORMAL
- en: 89\. Vigenère cipher
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Vigenère cipher is an encryption technique that uses a series of interwoven
    Caesar ciphers. Although described in 1553 by Giovan Battista Ballaso, it was
    misattributed in the 19th century to Blaise de Vigenère and ended up being named
    after him. The cipher is described in detail on Wikipedia at [https://en.wikipedia.org/wiki/Vigen%C3%A8re_cipher](https://en.wikipedia.org/wiki/Vigen%C3%A8re_cipher).
    Only a short summary is presented here.
  prefs: []
  type: TYPE_NORMAL
- en: Although the Vigenère cipher took three centuries to be broken, it is nowadays
    trivial to break, just as in the case of the Caesar cipher, on which it is based.
    Like the previous problem, this one is proposed only as a fun and simple exercise
    and not as an argument in favor of using this cipher for cryptographic purposes.
  prefs: []
  type: TYPE_NORMAL
- en: The technique ...
  prefs: []
  type: TYPE_NORMAL
- en: 90\. Base64 encoding and decoding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Base64 is an encoding scheme used for representing binary data in ASCII format
    using an alphabet of 64 characters. Although all implementations use the same
    first 62 characters (`A-Z`, `a-z`, and `0-9`), the last two values may differ.
    The symbols `+` and `/` are used in the MIME specification. A base64 digit represents
    6 bits of data, and four base64 digits encode exactly three bytes (8-bit) of binary
    data. When the number of digits is not divisible by three, extra bytes with a
    value of zero are added before converting to base64\. Padding the encoded text
    with `==` or `=` can be used to indicate that the final group of three bytes from
    the plain data actually contained only one or two bytes.
  prefs: []
  type: TYPE_NORMAL
- en: Here is an example of encoding ...
  prefs: []
  type: TYPE_NORMAL
- en: 91\. Validating user credentials
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A good choice for a free, cross-platform C++ library for cryptographic schemes
    is Crypto++. This library is widely used in both non-commercial and commercial
    projects, as well as academia, student projects, and others, for its industry-proven
    implementation of cryptographic functionalities. The library provides support
    for AES and AES candidates, as well as other block ciphers, message authentication
    codes, hash functions, public key cryptography, and many other features, including
    non-cryptographic functionalities such as pseudo-random number generators, prime
    number generation and verification, DEFLATE compression/decompression, encoding
    schemes, checksum functions, and more. The library is available at ...
  prefs: []
  type: TYPE_NORMAL
- en: 92\. Computing file hashes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: File hashes are often used to ensure the integrity of content, such as in the
    case of downloading a file from the web. Although implementations of the SHA1
    and MD5 hashing functions can be found in a variety of libraries, we will again
    use the Crypto++ library. If you did not follow the previous problem and its solution,
    *Validating user credentials*, you should do so before continuing with this one,
    because the general information about the Crypto++ library that was given there
    will not be repeated here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Computing a hash for a file is relatively simple using the Crypto++ library.
    The following code uses several components:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FileSource`, which allows reading data from a file using a `BufferedTransformation`.
    By default, ...'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 93\. Encrypting and decrypting files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to solve this problem with the Crypto++ library, we need to use several
    components:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FileSource`, which allows reading data from a file using a `BufferedTransformation`.
    By default, it pumps data in blocks or chunks of 4,096 bytes, although manual
    pumping is also possible.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FileSink`, which allows you to write data to a file using a `BufferedTransformation`.
    It is the companion sink object to a `FileSource` source object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DefaultEncryptorWithMAC` and `DefaultDecryptorWithMAC`, which encrypt and
    decrypt strings and files with an authentication tag to detect tampering. They
    use AES as the default block cipher and SHA256 as the default hash for the MAC.
    Each run through these two classes produces a different ...'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 94\. File signing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The process of signing and verifying is similar to encryption and decryption,
    although it differs in a fundamental way; encryption is done using the public
    key and decryption using the private key, while signing is done using the private
    key and verification is done using the public key. Signing helps a recipient that
    owns a public key to verify that a file is unmodified by using the signature and
    its public key. Having the public key, however, is not enough to change the file
    and sign it again. The Crypto++ library is used for solving this problem too.
  prefs: []
  type: TYPE_NORMAL
- en: Although you can use any pair of public-private RSA keys to perform the signing
    and verification, in the implementation provided here the keys are randomly generated
    when ...
  prefs: []
  type: TYPE_NORMAL
