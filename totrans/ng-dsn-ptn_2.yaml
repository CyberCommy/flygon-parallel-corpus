- en: Angular Bootstrapping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After [Chapter 1](9e3f2df1-9ef2-4c24-9c47-ceabcb13fdb8.xhtml), *Typescript Best
    Practices*, we can dive into Angular itself. One of the focuses of Angular was
    to drastically improve the performance and loading time of Angular applications
    compared to AngularJS. The performance improvements are outstanding. According
    to the Angular team and various benchmarks, Angular 2 is between five and eight
    times faster than Angular 1.
  prefs: []
  type: TYPE_NORMAL
- en: Now, to achieve this kind of improvement, Google engineers did not build upon
    AngularJS; instead, they created Angular from scratch. Consequently, having worked
    with Angular 1 for some time, this will not give you a sizable edge over newcomers
    to the Angular world when it comes to developing Angular applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: I will first present the major architectural concepts behind Angular.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, we will bootstrap an Angular application using the newly introduced Angular
    CLI tool that takes away most of the getting started pain. There are hundreds
    of Angular boilerplates on the web, and choosing one can be time-consuming, to
    say the least. You can enjoy any flavors on GitHub with tests, with libraries,
    for mobiles, with build and deployment scripts, and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While this diversity and enthusiasm from the community is a good thing, it means
    that no two Angular projects look the same. Indeed, the chances are that both
    projects were created with a different boilerplate or without any. To fix this
    problem, the Angular team is now proposing angular CLI. Angular CLI is a command-line
    node package that allows developers to create new applications based on an official
    boilerplate. This tool also provides some useful features, such as the creation
    of the different building blocks of an Angular application, building, testing,
    and minifying your application. It even supports the deployment of your application
    to GitHub pages with one short command.
  prefs: []
  type: TYPE_NORMAL
- en: It's still a new tool, and it has numerous drawbacks and unpolished behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: Architectural overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, I will present the main building blocks of Angular applications:
    Service, Component, Template, and Directive. We will also learn what problems
    are solved by dependency injection, decorators, and zones.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, if you picked this book off the (virtual) shelf, you likely have some experience
    with Angular and want to improve your applications with good practices and design
    patterns. Therefore, you should have some knowledge about the general architecture
    of Angular building blocks.
  prefs: []
  type: TYPE_NORMAL
- en: Nevertheless, a quick and pragmatic reminder should not hurt much, and we can
    be sure that we have a solid architectural basis to build our patterns upon.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an overview of how the main Angular 2 building blocks interact with
    each other:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/dbbe6f43-adec-4ebb-a6cf-590c1c876429.png)High-level architecture
    of an Angular 2 application'
  prefs: []
  type: TYPE_NORMAL
- en: 'In what follows, I will present an example of each Angular 2 building block
    by creating an application that manipulates the Floyd array. Here is an example
    of a letter-based Floyd array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: I agree that you are not very likely to build an application dealing with Floyd
    arrays in the near future. Nevertheless, Floyd arrays are a good programming exercise
    when learning a new language or framework, as it involves user input, displaying
    results, loops, and string manipulation.
  prefs: []
  type: TYPE_NORMAL
- en: Component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Components are the views of our Angular application in the sense that they
    control what, when, and how things should be displayed on the screen. They take
    the form of a simple class that defines the logic required by your views. Here''s
    an example of a simple component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the component class has a suffix: `Component`. I will discuss the
    reasons in the next chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This component named `FloydComponent` has two private members: `floydString`
    and `startOfAlphabet`. The `floydString` will contain the string representing
    an n^(th) Floyd triangle, while`startOfAlphabet` is constantly marking the position
    of the letter in the ASCII table.'
  prefs: []
  type: TYPE_NORMAL
- en: The `FloydComponent` also defines a constructor, which will be invoked when
    the user requests the patch of screen our component manages. For now, the constructor
    is empty.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `onClick` method accepting a number argument called `rows` will
    generate a Floyd triangle of `rows`. To sum up, we have a class managing the behavior
    of a view showcasing a Floyd triangle. Yes? Well, the view part is kind of missing!
    Where is my HTML for client-side rendering?
  prefs: []
  type: TYPE_NORMAL
- en: 'In Angular, the piece of HTML our component will have control over is known
    as a template, and we can link the template on the component using metadata:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: So, what's all that fuss about? If we look back at the original definition of
    the `FloydComponent`, there's nothing specifying that `FloydComponent` is a component.
    We don't have anything like `FloydComponent` extending/implementing components,
    so it's just a plain typescript class and nothing else. Even more surprisingly,
    there are no Angular references at all; this `FloydComponent` could totally be
    a typescript class outside of the Angular framework.
  prefs: []
  type: TYPE_NORMAL
- en: The metadata is decorating the `FloydComponent` class using the decorator pattern,
    so Angular knows how to interpret and process the `FloydComponent` class.
  prefs: []
  type: TYPE_NORMAL
- en: In any object-oriented languages, it is easy to extend the responsibilities
    of an object statically by using inheritance, however, doing so dynamically, at
    runtime, is a completely different matter. The purpose of the decorator pattern
    is to add additional responsibilities dynamically to an object.
  prefs: []
  type: TYPE_NORMAL
- en: We will implement our very own decorator in [Chapter 3](fac4936a-292a-4b12-ac60-394bacad0f16.xhtml), *Classical
    Patterns*.
  prefs: []
  type: TYPE_NORMAL
- en: The annotation itself is `@Component`, and makes our class an Angular component
    with some arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Note the `import { Component } from '@angular/core';` which imports the `Component`
    module from the `'@angular/core'` library.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first argument is a `selector` that describes which part of the view our
    `FloydComponent` should bind itself to. In the following HTML snippet, we have
    the `<floyd></floyd>` selector markup that the `FloydComponent` will bind to.
    The second argument is the template string. The template string defines what will
    be added to the DOM, at runtime, inside the `<floyd>` markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The backtick ` allows us to define multiline strings in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we have the `<input>` markup, which looks almost like pure HTML. The
    only particularity is the `#rows` attribute in the markup. This attribute is used
    to reference the markup as a variable named `rows`. Hence, we can access its value
    in the following markup: `<button (click)="onClick(rows.value)">CLICK</button>`.
    Here, we have an event binding between the template and the component. When the
    button is clicked, the `onClick` method of the component will be invoked, and
    the value of the input will be fed to the method.'
  prefs: []
  type: TYPE_NORMAL
- en: Further down the code, we have `{{floydString}}`, which is a property binding
    from the component to the template. In this particular case, we bind the `floydString`
    component property to the template. In other words, we display the content of
    the `floydString` component property in the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: I have to use the pre markup, so the `\n\r` are preserved in the output.
  prefs: []
  type: TYPE_NORMAL
- en: 'To sum this up, the component binds its property to the template and the template
    binds its events to the component. Here''s a screenshot of what to expect when
    running this application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/8f8cd7fc-91c8-4425-9003-c9d1123708e6.png)Floyd array with Angular
    2Is it not working on your side? Want to fork the code on GitHub? You can see
    the whole application, as of now, at [http://bit.ly/angular2-patterns-chap2](http://bit.ly/angular2-patterns-chap2).'
  prefs: []
  type: TYPE_NORMAL
- en: Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For now, we have reviewed two out of four of the building blocks of Angular
    2\. The remaining two are services and directives. The next block we are going
    to review services. Services are classes with a unique purpose that shall be,
    as much as possible, cohesive in the sense that they provide a narrow and well-defined
    service to other parts of the application. From a design point of view, what could
    be nice for our Floyd triangle application is to have the content of the `FloydComponent.onClick`
    method inside a service. Indeed, the computation of the `floydString` string does
    not have its place in a component managing the view.
  prefs: []
  type: TYPE_NORMAL
- en: 'A component should only be in charge of the user experience—binding properties
    to a template—and nothing else. Every other one should be delegated to services.
    What we can do is create a triangle service that will be in charge of *drum rolls*
    creating weird triangles such as Floyd triangle. We can also make this service
    in charge of generating Floyd triangles where the output would be looking like
    a tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Such a service would look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `TriangleService` is a simple class that offers two methods: `floydTriangle`
    and `evenFloydTriangle`. The `evenFloydTriangle` has an additional for loop to
    add the leading spaces at the different rows of the triangle. The business application
    now sits on a dedicated service that we can use on our `FloydComponent`. The right
    way to use our service in the `FloydComponent` is through dependency injection.
    Dependency injection is a process by which a requesting class gets a fully formed
    instance of a requested class dynamically. To apply this rather technical definition
    to our context, upon instantiation, the `FloydComponent` will be served an instance
    of the `TriangleService`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To use dependency injection with Angular, we need to define a provider for
    the `TriangleService`. We can do this at the application level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can do this at the component level by defining providers
    in the component annotations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: If the provider is created at the application level, then the same instance
    of the `TriangleService` will be served to anyone requesting it. At the component
    level, however, a new instance of the `TriangleService` will be created and served
    to the component each time said component is instantiated. Both cases can make
    sense. It depends on what your components and your services are doing. For example,
    the logging service we will implement in [Chapter 7](c337464a-e6d1-42f0-9a07-8ece3bcf7ae1.xhtml),
    *Operations Patterns*, does not have a state of its own and is used by every module
    of the application. Consequently, we can use an application-based provider. The
    counterexample would be the *Circuit breaker* pattern from [Chapter 5](d7f0be25-e37c-40f7-944c-d888d23c43eb.xhtml),
    *Stability Patterns*, which does have an inner state, and hence, a component level.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final touch is to modify our `FloydComponent` constructor so that it looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Here, we define a private member named `triangleService` for our `FloydComponent`,
    which will be used as a placeholder for the injected dependency.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, we add a checkbox in the template, which will be used to determine
    if we want an even or a normal Floyd array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also modify the `onClick` method to use our `TriangleService`. The final
    component looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The current state of the application can be seen here: [http://bit.ly/angular2-patterns-chap2-part2](http://bit.ly/angular2-patterns-chap2-part2).'
  prefs: []
  type: TYPE_NORMAL
- en: Directives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To conclude our quick architectural overview, we will create a directive to
    enhance our rather fade pre-markup. Directives are interacting with a template
    and with their parent component regarding property and event bindings. We will
    create a directive that adds style to our pre-markup. The style involves a 1 px
    border and changes the background color to red or yellow for an even or odd Floyd
    array, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need a way to ask the user which kind of array he/she wants. Let''s
    add another input in the template of the `FloydComponent` and modify the `onClick`
    method so it accepts a second argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can create the directive. It will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: A lot happens here. First, we have the directive annotation with a selector.
    The selector will be used to signify that a given HTML markup depends on the directive.
    In our case, I chose to name the directive `AngularPre` and to have the same name
    for the selector. They can be different; it is up to you. However, it does make
    sense to have the same name for the selector and the class so you know which file
    to open when your directive is going sideways.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we have the very interesting `@Input()` annotating the `highlightColor:string;`member.
    Here, we specify that the value of the `highlightColor` string is, in fact, bound
    to the variable from the parent component. In other words, the parent will have
    to specify the color in which it wants the pre-markup to be highlighted. In the
    constructor, the directive received an `ElementRef` object by injection. This
    `ElementRef` represents the DOM on which your directive acts. Finally, we define
    two `HostListener` on `mouseenter` and `mouseleave` that will start and stop the
    highlighting of the pre-markup, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use this directive, we have to insert its selector in the pre-markup of
    the `FloydComponent` template as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we specify that we want our pre-markup to be affected by the directive
    with the `AngularPre` selector, and we bind the `highlightColor` variable of the
    invoked directive with the color variable of the `FloydComponent`. Here''s the
    `FloydComponent` with the color variable and a slight modification of the `onClick`
    method, so it changes the value of the color variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This is what the application looks like with an odd array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/0cde42b3-4ba2-43e8-a027-5569c720fc65.png)Odd Floyd array result'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what it looks like with an even array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ad758f35-adca-4c72-80ce-70c536f880c6.png)Even Floyd array resultThe
    application is downloadable here: [http://bit.ly/angular2-patterns-chap2-part3](http://bit.ly/angular2-patterns-chap2-part3).'
  prefs: []
  type: TYPE_NORMAL
- en: Pipes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The last two building blocks that I want to explain here are pipes and routes.
    pipes are wonderful. They allow us to create a specialized class that will take
    and transform any input into the desired output. In Angular, pipes follow the
    Unix pipes programming paradigm, where information can be passed from one process
    to another. What we can do with our Floyd triangle-based application creates a
    Pipe that will transform any given Floyd string to include the ASCII character
    for a paragraph `¶` (`244, &para;`) every time it encounters the newline sequences
    (such as `\n\r`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Pipes are decorated using the `@Pipe` annotation very much like component and
    directive. Now, the difference with pipes, compared to component and directive,
    is that, as well as decorating the annotation, we have to implement an interface
    provided by the Angular framework. This interface is named `PipeTransform` and
    defines a single method that every class implementing it must have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The actual signature of this method is composed of any types, as pipes can
    be used for everything, not only strings. In our case, we want to manipulate a
    string input and have a string output. We can refine the signature of the transform
    method without breaking the interface contract, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Here, we expect only one string argument and produce a string output. The body
    of this method contains a global regex matching all the `\n\r` sequence and adds
    `¶`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the `ParagraphPipe` in the `FloydComponent`, we have to modify the template
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The `floydString` is piped to the `ParagraphPipe` using the `|` operator. Here''s
    what''s it looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/b4b0a918-007d-4c73-a98f-f0821f5042cc.png)Piping the floydString
    to have a paragraph marker'
  prefs: []
  type: TYPE_NORMAL
- en: 'The fact that the paragraph pipe hardcodes the paragraph symbol bugs me a little.
    What if I want to change it on a per-usage basis? Well, Angular is handling many
    additional parameters for your pipes. We can modify the `transform` method to
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Moreover, we can do so with the pipe call like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Here, the first argument of the `transform`method will be the `floydString`,
    while the second will be the paragraph symbol.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we think about it, we are currently implementing the `replaceAll` function
    for Typescript except for the target (`\n\r` is hardcoded). Let''s create a Pipe
    named `replaceAll` that has both the target to replace and its replacement as
    a parameter. The only problem is that the `PipeTransform` interface defines a
    transform method with two parameters, the second one being optional. Here, we
    need three parameters: the string to transform, the target to replace inside the
    string, and the replacement for the target. If you do try to have a transform
    method with three parameters, then you will break the `PipeTransform` contract,
    and your Typescript will not compile anymore. To circumvent this minor setback,
    we can define an inline type named `replace` that will contain two members, `from`
    and `to`, that are both strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are using `\\n\\r` for the strings pattern as we are not building a
    `RegExp` just yet. Consequently, the `\` of `\n` and `\r` need to be escaped.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the code of the `replaceAll` pipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Not so bad, huh? We have filled one of the shortcomings of JavaScript, the
    `replaceAll` functionality, in a modular and efficient way. This `replaceAll`
    pipe will be usable everywhere in your application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing to know about the pipes is that you can combine them just like
    in the Unix console. For example, we could totally do the following, where the
    paragraph pipe kicks in first and adds the `¶` to the end of all lines. Then,
    the `replaceAll` pipe intervenes and replaces all the `¶` by `¶` piped:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The current state of the application is downloadable here: [http://bit.ly/angular2-patterns-chap2-part5](http://bit.ly/angular2-patterns-chap2-part5).'
  prefs: []
  type: TYPE_NORMAL
- en: Routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Routes enable navigation between Angular views. In this recipe, we'll learn
    about them and see them in action within the framework of a small application.
  prefs: []
  type: TYPE_NORMAL
- en: Angular CLI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Angular CLI** is a very simple, yet extremely useful, node package that
    takes the form of a command-line tool. The purpose of this tool is to take away
    most of the pain of getting started with Angular 2\. The problem with any application
    based on a framework is to know how to bootstrap things for your code to communicate
    smoothly with the framework's features and libraries.
  prefs: []
  type: TYPE_NORMAL
- en: This tool, provided directly by the Angular team, provides working blueprints
    for ready-to-go applications. Indeed, by using one simple command we can generate
    a complete boilerplate for Angular that can be transpiled, run locally, tested,
    and even deployed to GitHub pages.
  prefs: []
  type: TYPE_NORMAL
- en: Installation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Installing the Angular CLI is dead simple as it''s a `node` package. The following
    command will work, regardless of your operating system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: If you are using a Unix-based system, a `sudo` might be required for global
    installations.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once the Angular CLI is installed, we can begin by generating a new Angular
    application with the `ng new` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This command will create an empty boilerplate for your application and fetch
    every required node module.
  prefs: []
  type: TYPE_NORMAL
- en: Note that, depending on your internet connection, this command can take a while
    to complete. Indeed, the node packages to fetch are many, which further justifies
    such a tool.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the root level of the newly created folder, you can find the following files
    and folders:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Angular-cli-build.js`: A config file to build your application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`config`: A config folder for the test environment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Node_modules`: The different node modules required. As I am writing these
    lines, the current version of the Angular CLI already has 60,886 files and folders
    in the node-modules directory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Public`: Contains what''s public for your app.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tslint.json`: Configuration for your linter. We will configure it in the next
    chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`typings.json`: Typings dependencies.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`angular-cli.json`: Some configuration for your app.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`e2e`: e2e configuration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`package.json`: Dependencies for your app.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`src`**:** Your source code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`typings`: Required typings.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Indisputably, the folder in which we will spend the most time is the `src`
    folder, as it contains the TypeScript source code. Here''s what''s inside it after
    creation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, there is an `app` folder that already contains a component
    named `my-app`and a shared folder that can be used to share resources between
    different apps. Then, we have the `index.html` containing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In this `index.html`, the `<app-root></app-root>` markup is inserted and the
    required files are loaded into the script.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another important point is the `main.ts` file, which contains the bootstrapping
    lines for your application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `MyAppAppComponent` component is imported and used as the top-level
    or root component for our application. This is the component that will be instantiated
    first.
  prefs: []
  type: TYPE_NORMAL
- en: Generating
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For now, our application is not exactly exciting; it will only display `my-app
    works!`in an `h1` markup.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to add components, directives, services, and pipes to this boilerplate,
    we have to use the `generate` command. Here''s an example to generate a new component
    named `Floyd`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'In response, the Angular CLI created a new folder named `Floyd` and the required
    files for our component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We can do the same operation using directive, service, or pipe instead of component.
  prefs: []
  type: TYPE_NORMAL
- en: Every keyword in the Angular CLI can be abbreviated by using only the first
    letter of the word. So, generating another component named `Pascal` would read
    `ng g c Pascal`.
  prefs: []
  type: TYPE_NORMAL
- en: Serving
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have a bunch of components, services, directives, and pipes in our application,
    and we are ready to see the result. Thankfully, Angular CLI can build your application
    and start up a web server using the command `ng serve`.
  prefs: []
  type: TYPE_NORMAL
- en: Then, you can see your application at `localhost:4200`.
  prefs: []
  type: TYPE_NORMAL
- en: Your files are watched by the Angular CLI. Every time you make a change to a
    file, the Angular CLI will recompile it and refresh your browser.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ready to make your application live? `ng build` is what you are looking for.
    This command will create a `dist` directory that you can push onto any server
    capable of serving HTML pages. It can even be on GitHub pages, which will not
    cost you a single cent.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have completed an overview of the Angular building blocks
    and seen how they interact with each other. We have also created a relatively
    simple application manipulating Floyd arrays. Finally, we learned how to use the
    Angular CLI to create new applications, components, services, directives, and
    pipes using the command line.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will focus on Angular good practices. We will discover
    the "do's and don'ts" recommended by Google engineers in a practical way.
  prefs: []
  type: TYPE_NORMAL
