- en: Chapter 9. Inventory Your Cloud
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I am very excited to dive into this chapter, as we will focus on a topic that
    is considered challenging when administering an OpenStack cloud. Gathering metrics
    around the system being consumed is a pretty high item on the daily priority list.
    The bad news is OpenStack does not necessarily make this an easy task. In OpenStack's
    defense, I will say that there has been great work done around the most recent
    releases to improve this. The new **OpenStackClient** (**OSC**) has done a better
    job, allowing the Cloud Operator to pull together various different metrics about
    the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: In the meantime, there are ways to collect these metrics in an ad hoc fashion
    and then put a very simple report together. As with most things related to OpenStack,
    there are a few ways to approach it. After attempting to do this using multiple
    methods, I found that it was easily accomplished by executing queries against
    the OpenStack databases. I know, I know...no one wants to touch the database.
    In my past life, I used to be a DBA, and one thing I learned from that experience
    is that simple clearly defined queries are harmless to any database. Combining
    that theory and using a tool such as Ansible to pull all the information collected
    together is a winning combo. In this chapter, we will review how you can dynamically
    inventory various pieces of your OpenStack cloud resources. We will learn what
    metrics are of value and how that information can be stored for later reference
    as well. This is an extremely powerful tool to have as a Cloud operator.
  prefs: []
  type: TYPE_NORMAL
- en: Collecting cloud metrics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User report
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Project report
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Network report
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Volume report
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cloud-at-a-Glance report
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coding the playbook and roles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Review playbook and role
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collecting cloud metrics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first step in this process is to determine what metrics are important to
    you. Keep in mind that the approach outlined here is just my very opinioned way
    of tackling this. As a Cloud operator, you may have a different way you wish to
    handle this. Use this as a springboard to get you started.
  prefs: []
  type: TYPE_NORMAL
- en: From my experience, it is best to pull together user, project, network, and
    volume metrics. Then, take all that data, combine it together, and output total
    cloud utilization metrics. This is very similar to what the Horizon dashboard
    does. While it is easy to log into Horizon and do a quick review, what if you
    wanted to provide a comprehensive report to your leadership? Or maybe you wanted
    to take a point-in-time snapshot to compare cloud utilization over a time period.
    There may be a possible requirement to audit your cloud one day. There exists
    no real easy way to do this in a report format without using a third-party tool.
    All these scenarios can be satisfied using the approach outlined next.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start at the beginning by taking a look at collecting user metrics first.
  prefs: []
  type: TYPE_NORMAL
- en: User report
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Capturing information about the users defined in your cloud is probably the
    simplest metric to record. When the day comes that you have to audit your cloud
    for compliance and security reasons, you will note that you list out the users
    and even list out the roles assigned to users, but not both together. Similarly,
    you can list out the users in a project but not the role assigned to that user
    for that project together. You can see where I am going with this. It would only
    make sense to have a complete list of the users with their IDs, what roles they
    are assigned, and to what project(s) they have access to in one report. Using
    the following simple database query you can very easily attain this information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This query will combine data from four different tables within the database
    named **keystone**. The keystone database is the owner of all the user-related
    data. Each table within the database has at least one primary key that can be
    used to link the data together. Here is a quick breakdown of the tables used here
    and their functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we will focus on only pulling back the necessary columns from
    the four tables. To make things a bit easier to read, we also renamed a few of
    the column labels. Finally, we will sort the data by the project name in an ascending
    order to give us a clean and easy output. I promise not to go much further into
    the weeds on this SQL query. This is a book on OpenStack and Ansible, not SQL
    commands, right?
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Always try to use the ID column of the table to link data from other tables
    when possible. The ID column will always be a unique value that will provide reliable
    data correlation every time. Using columns that contain item name values could
    eventually cause a conflict if a row exists in the table with duplicate values.
    Even OpenStack on the whole uses this approach, as you will note that anything
    created within OpenStack has an ID associated with it.
  prefs: []
  type: TYPE_NORMAL
- en: 'After executing this query, the output will look something similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![User report](graphics/image_09_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Project report
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Having a clear view of what project(s) exist within your cloud and the resources
    being used can be very valuable throughout the overall cloud lifecycle. Doing
    department or division chargebacks seems to be a very popular approach in recent days.
    Pulling these metrics as a point-in-time resources review can provide clarity
    around how many resources each project is using. To successfully accomplish this,
    the vCPU, memory, and disk metrics must be collected for each project. Using the
    following simple database query, you can very easily attain this information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This query will combine data from two different tables that live within two
    separate databases, `nova` and `keystone`. The `nova` database is the owner of
    all the instance-related data. The `keystone` database was reviewed in the earlier
    section. Just as in the previous example, each table has at least one primary
    key. Here is a quick breakdown of the tables used here and their functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to attain this data, we had to get a bit crafty and pull the resource
    metrics directly from the table containing the raw instance information. If we
    had Ceilometer installed, there would be a specific database where these metrics
    were recorded on a much more micro level. Since we do not have this functionality
    available at the present time, this method is the best thing available. In this
    query, we will again only return the necessary columns and rename column labels.
    In the end, we will narrow down the output to include only active instances and
    sort the data by the project name in ascending order. So, by pulling the resource
    information about each instance and correlating it to each project where the instance
    belongs, we are able to create simple output similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Project report](graphics/image_09_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Network report
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Having a snapshot of the Neutron networks created on your cloud may not seem
    critical to managing your overall OpenStack cloud. Trust me in the big picture
    it is. Unnecessary or incorrectly configured networks could add latency to overall
    cloud functionality. It is not the network directly that could cause this, but
    rather the security groups related to each project(s) network existing. This information
    can mainly aid in troubleshooting project-reported issues. It provides a quick
    reference as to what networks exist within what project and the network **Classless
    Inter-Domain Routing (CIDR)** aka network address space associated. Natively,
    the networking service (Neutron) within one command does not provide such a report.
    Just as earlier, we will pull this information directly from the database. Using
    the following simple database query, we will collect the network ID, name, subnet,
    CIDR assigned, status, and associated project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'For this query, we will combine data from three different tables that live
    within two separate databases, `neutron` and `keystone`. The `neutron` database
    is the owner of all the network-related data. Here is a quick breakdown of the
    tables used here and their functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Collecting these metrics was rather straightforward because most of the data
    existed within the networks table. All we had to do is pull in the matching CIDR
    taken from the subnet table and then bring in the project name associated with
    that network. While putting this query together, I noticed that there was an issue
    joining the `keystone` and `neutron` database tables. Apparently, the `neutron`
    database defined the schema for the ID column differently, and the following value
    had to be added to the inner join statement: `COLLATE utf8_unicode_ci`. In the
    end, the output will be sorted by the project names in ascending order. An example
    of the output will look similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Network report](graphics/image_09_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Volume report
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The capability to have detailed reports on the overall volume consumption within
    the cloud seems to be rather a big gap currently within OpenStack. The Block Storage
    service (Cinder) is responsible for maintaining and tracking the volumes within
    the cloud. To get accurate metrics, we would need to query Cinder directly. It
    would be nice to have a report to breakdown the number of volumes created per
    project. Then, be able to have a quick roll-up report to show how much volume
    storage each project is using. Now since Cinder supports multiple storage backends,
    you would be best to keep track of the volume type consumption as well. As Cinder
    matures, I am sure that this will become an easier task, but for now, we can again
    query the database directly to pull out the metrics we are seeking. The following
    are examples of the database queries used to collect these metrics:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'For this query, at least three separate tables were involved with two databases,
    `cinder` and `keystone`. As you can see, collecting this information was quite
    involved. It required us to issue three separate `SELECT` statements. The first
    `SELECT` statement will correlate the raw volume information from the volumes
    table with the project data from the keystone table. Also, within this same statement,
    we will include the name of the volume type. Since the volumes table contains
    both active and inactive volumes, there had to be an additional filter applied
    to return only the active volumes. The complete output will then be sorted by
    the project name in ascending order. The output for the first query will look
    similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Volume report](graphics/image_09_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The next `SELECT` statement will query the database to collect the metrics
    for the total volume consumption per project. It is very similar to the previous
    statement, but the main difference here is we are going to add the `volume_usage_GB`
    column together for each project to calculate the total consumption amounts. The
    output for the second query will look similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Volume report](graphics/image_09_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The final `SELECT` statement focuses on reporting the volume type consumption.
    Since the volume''s table only records the volume type ID, we had to inner join
    the `volume_types` table to pull in the actual volume name defined when created.
    This was something also done for the other previously mentioned statements. The
    output for the third query will look similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Volume report](graphics/image_09_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Cloud-at-a-Glance report
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This report is meant to be a very quick snapshot of the clouds overall consumption.
    It pulls back the total number of users, projects, volumes, and networks existing
    within your cloud. As well as, the total number of vCPU, memory, and ephemeral
    disk currently used. Here are the database queries used to collect this data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `SELECT` statements used basically add together the columns from the table
    being called. The column name is then renamed to a more descriptive label and
    finally filtered to ignore any rows not in an active state. Once executed, the
    output of the preceding queries will look similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Cloud-at-a-Glance report](graphics/image_09_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now that we know how to collect the metrics for our reports, let's go and learn
    how we can automate this task completely.
  prefs: []
  type: TYPE_NORMAL
- en: Coding the playbooks and roles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will now create the playbook and roles to generate a comprehensive
    *Cloud Report*. Once the playbook is executed, the output and end result will
    be two reports consisting of the information we learned how to collect in the
    previous section. These two reports will be saved into a directory determined
    by you for retrieval. At that point, you can literally send it to leadership and/or
    peers for review. In the next chapter, we will learn how you can take things further
    and directly e-mail out the report as an added bonus.
  prefs: []
  type: TYPE_NORMAL
- en: Very similar to the previous chapter, we will break up the multiple tasks into
    separate roles to keep things organized. We will next review the six roles used
    to automate creating our Cloud Report.
  prefs: []
  type: TYPE_NORMAL
- en: cloud-inventory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first role we will create will include those tasks needed to set up the
    foundation for the cloud report. The name of the file will be `main.yml` located
    within the role directory named `cloud-inventory/tasks`. The contents of this
    file will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The first three tasks are simply handling the prerequisite steps needed to create
    the report. This would include creating the directory where the report is saved,
    coping with the SQL script to be executed, and adding the header to the report.
    The overall idea is to create a visually appealing, accurate, and flexible report.
    This is accomplished by adding the report run time/date dynamically and naming
    the report accordingly. The final task will execute the `cloud_report.sql` file
    directly against the MySQL databases found in the Galera container of your cloud.
  prefs: []
  type: TYPE_NORMAL
- en: The `cloud_report.sql` file contains the SQL query described in the **Cloud-at-a-Glance**
    Report section earlier. This file can be found within the `cloud-inventory/files`
    directory of this role.
  prefs: []
  type: TYPE_NORMAL
- en: cloud-usage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The next role in the line-up will create the second report that will outline
    the current cloud utilization broken down per project. The file will be named
    `main.yml` located within the role directory named `cloud-usage/tasks`. The contents
    of this file will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'All the report pre-setup work is being handled in the first and third task
    shown earlier (creating the report directory and header). To gather the metrics
    we needed for this report, we can use native OpenStack CLI commands. The two commands
    used are: `openstack project list` and `usage show`. These commands are executed
    as part of the second and fourth tasks shown above. The last task in this role
    will retrieve the report from the remote location and move it locally to where
    the playbook/roles are executed.'
  prefs: []
  type: TYPE_NORMAL
- en: user-inventory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This role will be responsible for executing **User Report** described in the
    earlier section. The file will be named `main.yml` within the role directory name
    `user-inventory/tasks`. Here, you will find the contents of this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In an attempt to make the reports modular and not dependent on each other, I
    had each role create a report working directory and inserted report-specific headers.
    This way, you can include or exclude whichever roles/reports you wish.
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic principle used to create this role will be repeated for the remaining
    roles. It consists of the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create the report working directory; if the directory already exists, it will
    continue reporting no error
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copy the SQL script to the remote location
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add custom header information to the report
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Execute the SQL script to generate the specific subreport
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `user_report.sql` file contains the SQL query described in the earlier section
    covering the **User Report**. Now that we have the framework defined, we can move
    quickly through the remaining roles.
  prefs: []
  type: TYPE_NORMAL
- en: project-inventory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The purpose of this role is to execute the **Project Report** we reviewed in
    the earlier section. The file will be named `main.yml` within the role directory
    named `project-inventory/tasks`. Here, you will find the contents of this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Since this role will follow the same steps outlined for the user-inventory role,
    we will draw attention to the unique function executed. For this role, the `project_report.sql`
    file will contain the SQL query described in the **Project Report** section earlier.
  prefs: []
  type: TYPE_NORMAL
- en: network-inventory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The purpose of this role is to execute the **Network Report** we reviewed in
    the earlier section. The file will be named `main.yml` within the role directory
    named `network-inventory/tasks`. Here, you will find the contents of this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: volume-inventory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This last role will execute the final subreport, which is the **Volume Report**
    we covered earlier. The file will be named `main.yml` within the role directory
    named `volume-inventory/tasks`. Here, you will find the contents of this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: One special thing worth noting for this role is the last task uses the `fetch`
    Ansible module to retrieve the report created from the remote location where it
    was created. This is the same behavior used in the cloud-usage role. Personally,
    I thought this module was very convenient and kept us from having to handle a
    series of secure copy commands. That is never a good time for anyone.
  prefs: []
  type: TYPE_NORMAL
- en: To support these roles, we now need to create the variable files that will go
    along with it. Since we will use two separate hosts to execute the series of roles
    against, there will be two global variable files needed. The file names are `util_container`
    and `galera_container`, and they will be saved to the `group_vars/` directory
    of the playbook.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Keep in mind that the values defined in the variable file are intended to be
    changed before each execution for normal everyday use.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should note a few new variables that were defined for the new roles. Among
    the standard variables needed to authenticate into your OpenStack cloud, we have
    added some new variables related to the report creation and location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Word of caution:**'
  prefs: []
  type: TYPE_NORMAL
- en: Due to the contents of this file, it should be stored as a secure file within
    whatever code repository you may use to store your Ansible playbooks/roles. Gaining
    access to this information could compromise your OpenStack cloud security.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a moment to break down the new variables. The summary is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since there are two global variable files that share the same variable names,
    please make sure to keep the variable value in sync if you want both reports in
    the same directory. This is not a requirement, as each report (Cloud Report and
    Cloud Usage) can exist independently. Just felt like it was worth mentioning as
    to not to cause confusion.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the variable file completed, we can move on to creating the master playbook
    file. Since our goal is to create one report on the clouds resources (remember
    that we added the Cloud Usage report as a bonus), we will call all the roles from
    one playbook. The complete contents of the playbook file will end up looking similar
    to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As mentioned, all the roles we created to inventory the cloud will be executed
    in the order displayed in the playbook. All the roles use the same host with the
    exception of the cloud-usage role. The reason behind this is that we used OpenStack
    CLI commands in that role and that then required the use of the `util_container`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The playbook and role names can be anything you choose. Specific names have
    been provided here in order to allow you to easily follow along and reference
    the completed code found in the GitHub repository. The only warning is that whatever
    you decide to name the roles, it must remain uniform when referenced from within
    the playbook(s).
  prefs: []
  type: TYPE_NORMAL
- en: 'So since we now have one additional host involved in this playbook, we must
    add this host to your inventory file named `hosts`. With adding the new host placeholder,
    the host file will now look like this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: I am extremely excited to confirm that we are now ready to start running some
    cloud reports. In keeping with our tradition, we will finish up the chapter with
    a quick review of the playbook and role just created.
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing playbooks and roles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's jump right into examining the roles we created.
  prefs: []
  type: TYPE_NORMAL
- en: 'The completed role and file named `main.yml` located in the `cloud-inventory/tasks`
    directory looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The completed role and file named `main.yml` located in the `cloud-usage/tasks`
    directory looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The completed role and file named `main.yml` located in the `user-inventory/tasks`
    directory looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The completed role and file named `main.yml` located in the `project-inventory/tasks`
    directory looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The completed role and file named `main.yml` located in the `network-inventory/tasks`
    directory looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The completed role and file named `main.yml` located in the `volume-inventory/tasks`
    directory looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The corresponding global variable file is named `util_container` and is saved
    to the `group_vars/` directory of the complete playbook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The corresponding global variable file is named `galera_container`, and it
    is saved to the `group_vars/` directory of the complete playbook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the master playbook file has been created and will be located in the `root`
    directory of the `playbook` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '**inventory.yml**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we created the `hosts` file, which also is located in the `root` directory
    of the `playbook` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The complete set of code can again be found in the following GitHub repository:
    [https://github.com/os-admin-with-ansible/os-admin-with-ansible-v2/tree/master/cloud-inventory](https://github.com/os-admin-with-ansible/os-admin-with-ansible-v2/tree/master/cloud-inventory).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we finish up this topic, we of course need to test out our work. At
    the end of running this playbook and roles, you will have two reports to review.
    Assuming that you have cloned the GitHub repository earlier, the command to test
    out the playbook from the Deployment node is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Assuming that the playbook ran successfully and completed with no errors, you
    will find the two reports created in the directory you specified in the global
    variable file. The report should look similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Reviewing playbooks and roles](graphics/image_09_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: '![Reviewing playbooks and roles](graphics/image_09_009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Job well done yet again! Hoping that these cloud reports can really help in
    simplifying your day-to-day OpenStack administrative tasks!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our OpenStack administration toolbox is starting to look pretty full by this
    point in the book. Cannot stress enough how important it is to have a snapshot
    of your cloud state. These reports could be a good starting point to having that.
     Before concluding this chapter, let's take a moment to recap this chapter. Together
    we reviewed some gaps in OpenStack regarding reports on the clouds inventory and
    how you can overcome them. Then details were provided on how you can get access
    to the metrics and statistics we would need by querying the database.  Next, we
    examined the custom SQL queries used to pull out the data from the database in
    detail. Finally, we developed Ansible playbook and role to automate generating
    the cloud reports.
  prefs: []
  type: TYPE_NORMAL
- en: It saddens me a bit to say that the next chapter is our last chapter. With that
    said, it most certainly happens to probably be one of the most important chapters.
    Knowing the health of your cloud is tantamount to having a working OpenStack ecosystem.
    Due to the modular nature of OpenStack, you will have many services to keep track
    of. Having them all working properly is what creates the great harmony within
    OpenStack. While you can certainly do it manually, I am sure that you would agree
    automating such a task is much more ideal. Please read on to the next chapter
    to learn how you can monitor the health of your cloud automatically and even have
    a health report delivered right to your inbox.
  prefs: []
  type: TYPE_NORMAL
