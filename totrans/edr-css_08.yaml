- en: Chapter 8. The Ten Commandments of Sane Style Sheets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Thou shalt have a single source of truth for all key selectors
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Thou shalt not nest, unless thou art nesting media queries or overrides
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Thou shalt not use ID selectors, even if thou thinkest thou hast to
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Thou shalt not write vendor prefixes in the authoring style sheets
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Thou shalt use variables for sizing, colours and z-index
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Thou shalt always write rules mobile first (avoid max-width)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use mixins sparingly, and avoid @extend
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Thou shalt comment all magic numbers and browser hacks
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Thou shalt not inline images
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Thou shalt not write complicated CSS when simple CSS will work just as well
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Blessed are those that follow these rules for they shall inherit sane style
    sheets.
  prefs: []
  type: TYPE_NORMAL
- en: Amen.
  prefs: []
  type: TYPE_NORMAL
- en: Why the ten commandments?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following, highly opinionated, set of rules came about as a way to author
    predictable style sheets across teams of developers. Each rule can be enforced
    with tooling. When there is just one CSS developer on a project, spending time
    developing or integrating tooling may seem superfluous. However, beyond a couple
    of active developers the tooling will earn its time investment time and again.
    We will deal with the tooling to *police* the rules in the next chapter. For now,
    let's consider the syntax and the rules themselves.
  prefs: []
  type: TYPE_NORMAL
- en: Tooling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To achieve more maintainable style sheets we can lean upon PostCSS, a piece
    of CSS tooling that allows the manipulation of CSS with JavaScript. The curious
    can look here for more information: [https://github.com/postcss/postcss](https://github.com/postcss/postcss)'
  prefs: []
  type: TYPE_NORMAL
- en: PostCSS facilitates the use of an extended CSS syntax. For the purpose of authoring,
    the syntax used borrows heavily from *Sass* ([http://sass-lang.com/](http://sass-lang.com/)).
    This provides functionality to make our authoring style sheets easier to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using PostCSS we are able to make use of:'
  prefs: []
  type: TYPE_NORMAL
- en: Variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mixins (like macros for certain settings such as font-families)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Referencing a **key-selector** with an ampersand symbol (`&`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Practically, PostCSS can enable similar functionality to a CSS pre-processor
    such as Sass, LESS or Stylus.
  prefs: []
  type: TYPE_NORMAL
- en: Where it differs is in its modularity and extensibility. Rather than *swallow
    the whole pill* as is needed with the aforementioned pre-processors, using PostCSS
    allows us to be more selective about the feature set we employ. It also allows
    us to easily extend our feature set at will, either with any number of *off the
    peg* plugins, or, by writing our own plugins with JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: For example, where Sass allows loops to be written, we choose to prevent that
    capability. For instance where looping is needed to solve a specific problem (for
    example, 100 variants of different coloured headers) we can still achieve that
    buy as a PostCSS plugin written in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, thanks to the PostCSS ecosystem, we can perform static analysis
    of the authoring styles with linting; failing builds and code commits when undesirable
    code is authored.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In case the term *linting* is alien to you, it''s another term for static analysis.
    It looks at the authored code and makes suggestions based on any number of pre-defined
    rules. For example, it might issue a warning if you use floats, or don''t put
    white-space or a semi-colon where required. Generally speaking, you can use linters
    to enforce any kind of coding conventions you like and while more than useful
    when working alone, they can be priceless when working in teams: where many (careless)
    hands might touch the code.'
  prefs: []
  type: TYPE_NORMAL
- en: Rationale
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we are authoring ECSS, we want to avoid producing CSS that suffers from
    being overly specific, littered with unneeded prefixes, poorly commented and full
    of *magic* numbers.
  prefs: []
  type: TYPE_NORMAL
- en: The following 10 rules set-out what are considered to be the most important
    rules to achieve this goal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Definitions used throughout:'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Override**: A situation where the values of a key selector are purposely
    amended based upon inheritance'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Key selector**: The right most selector in any CSS rule'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Prefixes**: Vendor specific prefixes e.g. `-webkit-transform:`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Authoring style sheets**: The files we author the styling rules in'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CSS**: The resultant CSS file generated by the tooling and ultimately consumed
    by the browser'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's now consider each rule and the problem it aims to solve.
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Thou shalt have a single source of truth for all key selectors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the authoring style sheets, a key selector should only be written once.
  prefs: []
  type: TYPE_NORMAL
- en: This allows us to search for a key-selector in the code base and find a *single
    source of truth* for our selector. Thanks to the use of an extended CSS syntax,
    everything that happens to that key selector can be encapsulated in a single rule
    block.
  prefs: []
  type: TYPE_NORMAL
- en: Overrides to the key selector are handled by nesting and referencing the key
    selector with the *parent* selector. More of which shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'That would yield the following in the CSS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the authoring style sheets, the key selector (`.key-Selector`) is never repeated
    at a root level. Therefore, from a maintenance point of view, we only have to
    search for `.key-Selector` in the code base and we will find everything that could
    happen to that key selector described in a single location; a single source of
    truth.
  prefs: []
  type: TYPE_NORMAL
- en: What happens if we need it to display differently in a different viewport size?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What happens when it lives within containerX?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What happens when this or that class gets added to it via JavaScript?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In all these instances the eventualities for that key selector are nested within
    that single rule block. This means that any possible specificity issues are entirely
    isolated within a single set of curly braces.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at overrides in further detail next.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with overrides
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the prior example, there was a demonstration of how to deal with an override
    to a key selector. We nest the overriding selector inside the rule block of the
    key selector and reference the parent with the `&` symbol. The `&` symbol, as
    in the Sass language, is a parent selector. It might help you to think of it as
    being roughly equivalent to `this` in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To test rules using the parent selector I recommend [http://sassmeister.com](http://sassmeister.com)
  prefs: []
  type: TYPE_NORMAL
- en: Standard override
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This would yield the following CSS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This results in a `font-size` increase for the `ip-Carousel` when it is inside
    an element with a class of `ip-HomeCallouts`.
  prefs: []
  type: TYPE_NORMAL
- en: Override with additional class on same element
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s consider another example, what if we need to provide an override when
    this element gets an additional class? We should do that like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'That would yield this CSS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Again, the override is contained within the rule block for the key selector.
  prefs: []
  type: TYPE_NORMAL
- en: Override when inside another class and also has an additional class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Finally let''s consider the eventuality where we need to provide an override
    for a key selector inside another element that also has an additional class present:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'That would yield the following CSS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We have used the parent selector here to reference our key selector between
    an override above (`.home-Container`) and alongside another class (`.ip-ClassificationHeader`).
  prefs: []
  type: TYPE_NORMAL
- en: Override with media queries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Finally, let''s consider overrides with media queries. Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'That would yield this CSS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Again, all eventualities contained within the same rule. Note the use of a variable
    for the media query width? We will come to that shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Any and all media queries should be contained in the same manner. Here''s a
    more complex example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'That would yield this CSS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: With all the nesting of overrides we have just looked at, you may think it makes
    sense to nest child elements too? You are wrong. Very wrong. This would be a very,
    very bad thing to do. We'll look at why next.
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Thou shalt not nest, unless thou art nesting media queries or overrides
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The key selector in CSS is the rightmost selector in any rule. It is the selector
    upon which the enclosed property/values are applied.
  prefs: []
  type: TYPE_NORMAL
- en: We want our CSS rules to be as *flat* as possible. We **DO NOT** want other
    selectors before a key selector (or any DOM element) unless we absolutely need
    them to override the default key selector styles.
  prefs: []
  type: TYPE_NORMAL
- en: 'The reason being that adding additional selectors and using element types (for
    example `h1.yes-This_Selector`):'
  prefs: []
  type: TYPE_NORMAL
- en: Creates additional unneeded specificity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Makes it harder to maintain, as subsequent overrides need to be ever more specific
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adds unneeded bloat to the resultant CSS file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the case of element types, ties the rule to a specific element and/or markup
    structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, suppose we have a CSS rule like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![2\. Thou shalt not nest, unless thou art nesting media queries or overrides](img/Warning-image-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In that above example, `yes-This_Selector` is the key selector. If those property/values
    should be added to the key selector in all eventualities, we should make a simpler
    rule.
  prefs: []
  type: TYPE_NORMAL
- en: 'To simplify that prior example, if all we want to target is the key-selector
    we would want a rule like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Don't nest children within a rule
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Suppose we have a situation where we have a video play button inside a wrapping
    element. Consider this markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s set some basic styling for the wrapper:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we want to position the play element within that wrapping element. You
    might be tempted to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Don''t nest children within a rule](img/Warning-image-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'That would yield this CSS (vendor prefixes removed for brevity):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Don''t nest children within a rule](img/Warning-image-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Do you see the problem here? We have introduced additional specificity for our
    `.med-Video_Play` element when it is completely unneeded.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a subtle illustration. However, it is important to be aware of this,
    and avoid doing it, lest we end up with rules like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Don''t nest children within a rule](img/Warning-image-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead, remember that *each key selector gets its own rule block*. Overrides
    are nested, child elements are not. Here is that example rewritten correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'That would yield this CSS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Each key selector is only as specific as it needs to be and no more.
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Thou shalt not use ID selectors, even if thou thinkest thou hast to
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The limitations of IDs in a complex UI are well documented. In summary, they
    are far more specific than a class selector - therefore making overrides more
    difficult. Plus they can only be used once in the page anyway so their efficacy
    is limited.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember we dealt with specificity in detail back in [Chapter 2](ch02.html "Chapter 2. The
    Problems of CSS at Scale"), *The Problems of CSS at Scale*.
  prefs: []
  type: TYPE_NORMAL
- en: With ECSS we do not use ID selectors in the CSS. They present no advantages
    over class based selectors and introduce unwanted problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the almost unbelievable situation where you HAVE to use an ID to select
    an element, use it within an attribute selector instead to keep specificity lower:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 4\. Thou shalt not write vendor prefixes in the authoring style sheets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Thanks to PostCSS, we now have tooling that means it is unnecessary to write
    vendor prefixes for any W3C specified property/values in the authoring style sheets.
    The prefixes are handled auto-magically by the *Autoprefixer* ([https://github.com/postcss/autoprefixer](https://github.com/postcss/autoprefixer))
    tool that can be configured to provide vendor prefixes for the required level
    of platforms/browser support.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, don''t do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![4\. Thou shalt not write vendor prefixes in the authoring style sheets](img/Warning-image-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead you should just write this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Not only does this make the authoring style sheets easier to read and work with,
    it also means that when we want to change our level of support we can make a single
    change to the build tool and the vendor prefixes that get added will update automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'The only exception to this scenario is non-W3C property/values that might still
    be desirable. For example, for touch inertia scrolling panels in WebKit devices,
    it will still be necessary to add certain vendor prefixed properties in the authoring
    styles as they are non-W3C. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Or in the case of removing the scrollbar for WebKit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 5\. Thou shalt use variables for sizing, colours and z-index
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For any project of size, setting variables for sizing, colours, and z-index
    is essential.
  prefs: []
  type: TYPE_NORMAL
- en: 'UIs are typically based upon some form of grid or sizing ratio. Therefore sizing
    should be based upon set sizes, and sensible delineations of those sizes. For
    example here is `11px` based sizing and variants as variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: For a developer, the use of variables offers additional economies. For example,
    it saves colour picking values from composites. It also helps to normalise designs.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if a project uses only 13px, 15px and 22px font sizes and a change
    comes through requesting 14px font-sizing, the variables provide some normalisation
    reference. In this case, should the fonts be 13px or 15px as 14px is not used
    anywhere else? This allows developers to feedback possible design inconsistencies
    to the designers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same is true of colour values. For example, suppose we have a variable
    for the hex `#333`. We can write that as a variable like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: On the surface it seems ridiculous to write the variable name when the hex value
    is shorter. However, again, using variables prevents unwanted variants creeping
    in to the code base (e.g. `#323232`) and helps identify *red flags* in the code.
  prefs: []
  type: TYPE_NORMAL
- en: It's also important to still use the variables when making amendments to colours.
    Use colour functions on the variables to achieve your goal. For example, suppose
    we want a semi-opaque `#333` colour.
  prefs: []
  type: TYPE_NORMAL
- en: 'That should be achieved in the authoring style sheets like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'PostCSS can provide a polyfill for the W3C colour functions: [https://drafts.csswg.org/css-color/#modifying-colors](https://drafts.csswg.org/css-color/#modifying-colors) 
    and the example above yields this CSS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In this example we have used the alpha CSS colour function. We use the `color()`
    function, pass in the colour we want to manipulate and then the manipulation (alpha
    in this instance).
  prefs: []
  type: TYPE_NORMAL
- en: Using the variables can initially seem more complex but makes it easier for
    future authors to reason about what colour is being manipulated.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I'd also encourage you to look at *CSS Color Guard* ([https://github.com/SlexAxton/css-colorguard](https://github.com/SlexAxton/css-colorguard))
    which is a tool to warn of colours in your codebase that are visually indistinguishable
    from other colours in your codebase.
  prefs: []
  type: TYPE_NORMAL
- en: 'The use of variables for z-index is equally important. This enforces some sanity
    when it comes to stacking contexts. There should be no need for `z-index: 999`
    or similar. Instead, use one of only a few defaults (set as variables). Here are
    some relevant variables for z-index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 6\. Thou shalt always write rules mobile first (avoid max-width)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For any responsive work, we want to embrace a mobile-first mentality in our
    styles. Therefore, the properties and values within the root of a rule should
    be the properties that apply to the smallest viewports (e.g. mobile). We then
    use media queries to override or add to these styles as and when needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'That would yield this CSS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We only need to change the `font-size` and `line-height` at different viewports
    so that is all we are amending. By using `min-width` (and not `max-width`) in
    our media query, should the `font-size` and `line-height` need to stay the same
    at a larger size viewport we wouldn't need any extra media queries. We only need
    a media query when things change going up the viewport size range. To this ends,
    the use of `max-width` as the single argument of a media query is discouraged.
  prefs: []
  type: TYPE_NORMAL
- en: 'Bottom line: write media queries with `min-width` not `max-width`. The only
    exception here is if you want to isolate some style to a middle range. For example
    between medium and large viewports. Example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 7\. Use mixins sparingly (and avoid @extend)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Avoid the temptation of abstracting code into mixins. There are a few areas
    where mixins are perfect. The code for CSS text truncation (e.g. `@mixin Truncate`)
    or iOS style inertia scrolling panels, where there are number of pseudo selectors
    to get right for different browsers. Another good use case can be complex font
    stacks.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Font stacks are difficult to get right and tedious to author. The sanest way
    I've found to deal with fonts is to have the `body` use the most common font stack
    and then only override this with a different font-stack as and when needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: For simpler font-stacks, a variable can handle this need easily so may be preferable.
    However, mixins are great for more complex font stacks, where it's preferable
    to have certain font stacks apply in certain situations. For example, perhaps
    one font is required for LoDPI, and another for HiDPI. These situations can't
    be dealt with by using a variable alone so a mixin is used as needed.
  prefs: []
  type: TYPE_NORMAL
- en: Ultimately, aim for ten or less mixins in a project. Any more than that and
    it's probable mixins are being abused to needlessly abstract code.
  prefs: []
  type: TYPE_NORMAL
- en: Avoid @extends
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I first came across `@extend` when using Sass ([http://sass-lang.com/documentation/file.SASS_REFERENCE.html#extend](http://sass-lang.com/documentation/file.SASS_REFERENCE.html#extend)).
    The `@extend` directive makes one selector inherit the styles of another selector.
    While this can offer some file size benefits it can make debugging more difficult
    as rules are combined together in a manner that is not always possible to predict
    at the point of authoring.
  prefs: []
  type: TYPE_NORMAL
- en: To determine whether using `@extend` was worthwhile I did a short experiment
    on a Sass codebase I was working with at the time. There were 73 instances that
    would require a Headline font stack and 37 instances that would require a headline
    condensed font stack (so if going the mixin route, that's 73 `@include Headline`
    and 37 instances of `@include HeadlineCondensed`).
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at what the file size was with no font references at all, the font
    references defined as mixins/@includes and then the font references as @extends
  prefs: []
  type: TYPE_NORMAL
- en: With no font references
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With no font declarations at all:'
  prefs: []
  type: TYPE_NORMAL
- en: 105.5 KB (minified), 14.2 KB (Gzipped)
  prefs: []
  type: TYPE_NORMAL
- en: This is our *base* or control if you will. Let's look at the difference adding
    all our fonts in via mixins/@includes creates.
  prefs: []
  type: TYPE_NORMAL
- en: Using @includes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Using mixins (@includes in Sass) for the *Headline* and *Headline Condensed* the
    file size of the resultant CSS was:'
  prefs: []
  type: TYPE_NORMAL
- en: 146.9 KB (minified), 15.4 KB (Gzipped)
  prefs: []
  type: TYPE_NORMAL
- en: So, 1.2 KB added. How does `@extend` fare?
  prefs: []
  type: TYPE_NORMAL
- en: Using @extend
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'By using an `@extend` rather than an `@include`:'
  prefs: []
  type: TYPE_NORMAL
- en: 106.9 KB (minified), 14.5 (Gzipped); only a .3 KB file size increase.
  prefs: []
  type: TYPE_NORMAL
- en: What to conclude from this anecdotal data? For me, all other things being equal,
    if you absolutely want the smallest file size, perhaps `@extend` is the way to
    go. There is some saving, albeit minor.
  prefs: []
  type: TYPE_NORMAL
- en: However, being pragmatic, if there is any maintainability gain for you using
    `@include` instead of `@extend` I certainly wouldn't worry about the file size.
  prefs: []
  type: TYPE_NORMAL
- en: Personally, I don't allow `@extend` functionality in projects. It adds an additional
    layer of complexity to debugging for very little benefit.
  prefs: []
  type: TYPE_NORMAL
- en: 8\. Thou shalt comment all magic numbers and browser hacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A variables file should exist in each project that contains all variables relevant
    to the project.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: PostCSS facilitates variables and mixins defined in either CSS files or as JavaScript
    objects. You can read *more about the latter here* ([https://benfrain.com/creating-and-referencing-javascript-mixins-and-variables-with-postcss/](https://benfrain.com/creating-and-referencing-javascript-mixins-and-variables-with-postcss/)).
  prefs: []
  type: TYPE_NORMAL
- en: If a situation arises where a pixel based value needs entering into the authoring
    style sheets, that isn't already defined in the variables this should serve as
    a red flag to you. This scenario is also covered above. In the case where a *magic* number
    needs entering in the authoring style sheets, ensure a comment is added on the
    line above to explain its relevance. This may seem superfluous at the time but
    think of others and yourself in 3 months time. Why did you add a negative margin
    of 17 pixels to that element?
  prefs: []
  type: TYPE_NORMAL
- en: 'Example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The same goes for any device/browser hacks. You may have your own syntax but
    I use a comment above the start of the hack code with the prefix `/*HHHack:*/`
    when I have to add code purely to satisfy a particular situation. Consider this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: These kinds of overrides should be bottom-most in the rule if at all possible.
    However, make sure you add a comment. Otherwise, future authors may look at your
    code and presume the line(s) are superfluous and remove them.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you find you have a lot of code, purely to service a particular browser,
    you might consider extracting those rules (manually or with tooling) into a separate
    file that only gets served as needed.
  prefs: []
  type: TYPE_NORMAL
- en: 9\. Thou shalt not place inline images in the authoring style sheets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While we continue to support HTTP based users (as opposed to HTTP2) the practice
    of inlining assets provides some advantages; primarily it reduces the number of
    HTTP requests required to serve the page to the user. However, placing inline
    assets in the authoring style sheets is discouraged.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: How is a future author supposed to reason about what that asset is?
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you encounter an existing inline image in style sheets, to determine what
    the image is you can copy and paste the data into the browser address bar.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, let the tooling inline the image for you. This means the authoring
    style sheets can provide a clue as to what the image might be but also enables
    that image to be more easily swapped out. If employing the *postcss-assets* ([https://github.com/assetsjs/postcss-assets](https://github.com/assetsjs/postcss-assets))
    plugin, you can inline images with the inline command. Here''s that prior example
    re-written:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Not only is that easier to read, it also specifies the location of the existing
    asset. A better approach in every way.
  prefs: []
  type: TYPE_NORMAL
- en: 10\. Thou shalt not write complicated CSS when simple CSS will work just as
    well
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Try and write CSS code that is as simple as possible for others to reason about
    in future. Loops, mixins and functions should seldom be written. As a general
    rule, if there are less than 10 variations of a rule, write it *by-hand*. If on
    the other hand you need to create background positions for a sprite sheet of 30
    images, this is something that tooling should be used for.
  prefs: []
  type: TYPE_NORMAL
- en: This pursuit of simplicity should be extended in the manner layouts are achieved.
    If a better supported layout mechanism achieves the same goal with the same amount
    of DOM nodes as a less well supported one, use the former. However, if a different
    layout mechanism reduces the number of DOM nodes needed or presents additional
    benefits yet is simply unfamiliar (for example Flexbox), take the time to understand
    the benefits it might offer.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rules are nothing without enforcement. When many hands are touching the CSS
    codebase, no amount of education, strong words or documentation can prevent the
    quality of your codebase getting diluted. Offering *carrots* will only get you
    so far, it's usually necessary to use a little *stick* too!
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the *stick* will take the form of static analysis *linting* tools
    that can check and enforce code as authors write. This approach can prevent non-con-formant
    code ever making it further than the offending developers local machine. In the
    next chapter we will look at how to approach that, alongside tooling in general.
  prefs: []
  type: TYPE_NORMAL
- en: Here come the *Fun Police*!
  prefs: []
  type: TYPE_NORMAL
