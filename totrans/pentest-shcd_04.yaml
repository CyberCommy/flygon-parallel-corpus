- en: Reverse Engineering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are going to learn what reverse engineering is and how to
    use debuggers to make us really see what is going on behind the scenes. Also,
    we will look at the execution flow of one instruction at a time, and how we are
    going to use and get familiar with debuggers for both Microsoft Windows and Linux.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Debugging in Linux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging in Windows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The flow of execution of any code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detecting and confirming buffer overflow with reverse engineering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shall we begin?
  prefs: []
  type: TYPE_NORMAL
- en: Debugging in Linux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here, we are going to introduce you to one of the most adorable and powerful
    debuggers ever, GDB (GNU debugger). GDB is an open source command-line debugger
    that can work on many languages, such as C/C++, and it's installed on most of
    the Linux distributions by default.
  prefs: []
  type: TYPE_NORMAL
- en: So why are we using debuggers? We use them to see inside registers, memory,
    or stacks in each step. Also, there is a disassembly inside GDB to help us understand
    the functionality of each function in assembly language.
  prefs: []
  type: TYPE_NORMAL
- en: Some people feel that GDB is hard to use because it's a command-line interface,
    that it's hard to remember each command's arguments, and so on. Let's make GDB
    more tolerable for those people by installing PEDA, which is used to enhance GDB's
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: '**PEDA** stands for **Python Exploit Development Assistance**, which can make
    GDB easier to use and look nicer.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to download it first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, copy that file to `gdbinit` inside your `home` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, start GDB:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, it looks useless, but wait; let''s try to debug something easy, such as
    our assembly *hello world* example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s assemble and link it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now run `./hello` with GDB as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the output for the preceding command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00139.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We are going to set the disassembling mode to Intel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we are going to set a breakpoint where we want to start our debugging
    step by step because we are going to track all instructions, so let''s put our
    breakpoint at `_start`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The output for the preceding commands is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00140.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As we have set the breakpoint, now, let's run our application inside GDB using
    `run`, and it will continue until it hits the breakpoint.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will see three sections (registers, code, and stack):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00141.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following screenshot is the code section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00142.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the small arrow on the left is pointing to the next instruction,
    which is moving `0x1` to the `eax` register.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next screenshot is the stack section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00143.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Also, we can find a lot of command options using the command `peda`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00144.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'There are more too:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00145.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: All of these are PEDA commands; you can also use GDB commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s continue our work by typing `stepi`, or you can just use `s`, and
    this will begin to execute one instruction, which is `mov eax,0x1`:'
  prefs: []
  type: TYPE_NORMAL
- en: The `stepi` command will step into instructions such as `call`, which will cause
    the flow of debugging to be switched inside that call, whereas the `s` command
    or step will not do this, and will just get the return values from the `call`
    instruction by stepping into the `call` instruction.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00146.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'On the previous screen, there is `0x1` inside the `RAX` register and the next
    instruction is pointing at `mov edi,0x1`. Now let''s hit *Enter* to move to the
    next instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00147.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Also, as you can see, there is `1` inside the RDI register and the next instruction
    is `movabs rsi,0x6000d8`. Let''s try to see what is inside memory address `0x6000d8` 
    using `xprint 0x6000d8`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00148.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'It''s clear now that this is the location that holds the `hello there` string.
    We also can dump it in hex using `peda hexprint 0x6000d8` or `peda hexdump 0x6000d8`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00149.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s move forward using `stepi`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00150.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now the RSI register is holding a pointer to the `hello there` string.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next instruction is `mov edx,0xc`, which is moving `12` to the EDX register,
    which is the length of the `hello there` string. Now, let''s go further by hitting
    *Enter* one more time; the following is displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00151.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'By looking at the RDX register now, it holds `0xc`, and the next instruction
    is `syscall`.  Let''s move forward using `s`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00152.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now the `syscall` is done, and the `hello there` string is printed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we are going to execute the `exit` syscall, and the next instruction is
    `mov eax,0x3c`, which means move `60` to the RAX register. Let''s keep moving
    forward using `s`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00153.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Instruction, `mov edi,0xb` means move `11` to the RDI register:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00154.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'RDI is now holding `0xb`, and the next instruction is `syscall`, which will
    execute the `exit` syscall:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00155.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now the program exits normally.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see another example, which is hello world in C language:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s compile it and debug it using GDB:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s set the disassembling mode to Intel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Set our breakpoint at the `main` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now if we want to look at the assembly instruction of any function, then we
    should use the `disassemble` command followed by the name of the function. For
    example, we want to disassemble the `main` function, and therefore we can use
    `disassemble main`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00156.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The first two instructions are to save the content of the base pointer or the
    frame pointer by pushing RBP to the stack, then, at the end, RBP will be extracted
    back. Let''s run the application to see further using the `run` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00157.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'It stops at `lea rdi,[rip+0x9f]  # 0x5555555546e4`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s check what''s inside that location:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00158.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: It points to the location of the `hello world` string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s step forward by using `stepi` or `s`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00159.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the RDI register is now loaded with the address of the `hello
    world` string.
  prefs: []
  type: TYPE_NORMAL
- en: The next instruction, `call 0x555555554510 <puts@plt>`, which is calling the `printf`
    function, is to print the `hello world` string.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also check the contents of `0x555555554510`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00160.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'It''s the `jmp` instruction; let''s check that location too:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00161.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s step forward using the `stepi` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00162.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s step forward again:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00163.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The next instruction is `push 0x0`; let''s keep going using `stepi`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00164.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The next instruction is `jmp 0x555555554500`; let''s step forward by entering
    `s`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00165.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now we are inside the actual execution of the `printf` function; keep stepping
    forward for the next instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00166.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The next instruction, `call 0x7ffff7abc650 <strlen>`, means calling the `strlen`
    function to get the length of our string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Keep stepping forward until you hit the `ret` instruction, then you are back
    to our execution again inside `printf`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00167.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s make the program continue debugging until it hits an error using the `continue`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00168.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In the previous example, we didn't follow all instructions but just learned
    how to debug using GDB, and understand and investigate every instruction.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging in Windows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, let's try something more advanced and yet very simple without going into
    specifics. Here, we will see what is going to happen if we use a buffer overflow
    code in Windows. We are going to detect what will happen inside your CPU if we
    execute that code.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, open *Code::Block* in Windows 7, then go to File menu | New | Empty
    file. Then, write our buffer overflow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, go to File menu | Save file, then save it as `buffer.c`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00169.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Then, go to Build menu | Build.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, open *Immunity Debugger* as the administrator, and from File menu |Open,
    select the executable buffer file, then specify our input not to crash our code
    but just to see the difference, such as `aaaa`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00170.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, hit Open:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00171.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: To get the functionality of each button, just hover your mouse cursor over it
    and read the status bar.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if I hover my mouse cursor over the red play button ![](img/00172.jpeg), it
    will show in the status bar its functionality, which is Run program:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00173.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s hit the Run program button one time. The program starts and then stops
    at the program entry point, which is the `main` function. Let''s hit that button
    again and notice what happens in the status bar:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00174.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the program exited with status zero, which means no errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'OK, let''s now try to cause the program to crash to see the difference. Let''s
    close Immunity Debugger and run it again, then open the same program, but we need
    to cause the program to crash, so specify the Arguments, such as 40 of the `a`
    character:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00175.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Then hit Open:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00176.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s hit the Run program button twice and notice what happens in the status
    bar:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00177.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The program can't execute `61616161`; do you know why that is? It's our input
    and 61 is a character in hex.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at both the register and stack window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00178.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Notice that the stack has 16 of the `a` characters; the rest of our input filled
    the EAX register and it filled RIP, and that's why our application is complaining
    that it can't execute `61616161`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we went through debugging, and how to use debuggers in both
    Linux and Microsoft Windows. We also looked at how to follow the flow of execution
    and see what is going on behind the scenes. We only scratched the surface of this
    topic because we don''t want to get carried away from our main goal. Now let''s
    keep going to the next chapter, which will cover one of our main goals here: creating
    shellcodes. We will look at how we are going to apply everything we have learned
    so far to create our customized shellcode.'
  prefs: []
  type: TYPE_NORMAL
