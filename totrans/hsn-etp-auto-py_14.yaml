- en: Creating and Managing VMware Virtual Machines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For a long long time, virtualization has been an important technology in the
    IT industry as it provides an efficient way for hardware resources and allows
    us to easily manage application life cycle inside the **Virtual Machine** (**VM**).
    In 2001, VMware released the first version of the ESXi that could run directly
    over the **commodity off the shelf** (**COTS**) **server **while converting it
    to a resource that could be consumed by multiple separate virtual machines. In
    this chapter, we will explore many options available to automate the building
    of virtual machine thanks to Python and Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the lab environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating a VMX file using Jinja2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: VMware Python clients
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Ansible playbooks to manage instances
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this chapter, we will have VMware ESXi version 5.5 installed over a Cisco
    UCS server and host a few virtual machines. We need to enable a few things in
    our ESXi server in order to expose some external ports to the outside world:'
  prefs: []
  type: TYPE_NORMAL
- en: The first thing is to enable both Shell and SSH access to the ESXi console.
    Basically, ESXi allows you to manage it using the vSphere client (based on C#
    for the versions before 5.5.x and based on HTML for version 6 and up). Once we
    enable the Shell and SSH access, this will give us the ability to use the CLI
    to manage virtual infrastructure and to perform tasks such as creating, deleting,
    and customizing the virtual machine.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Access the ESXi vSphere client and go to Configuration, then choose Security
    Profiles from the left tab, and finally click on Properties:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00171.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'A pop-up window will be opened that contains a list of services, statuses,
    and various options that can be applied:'
  prefs: []
  type: TYPE_NORMAL
- en: Select SSH service and then click on Option. Another pop-up window will be opened.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose the first option that reads Start automatically if any ports are open,
    and stop when all ports are closed under the Startup Policy.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Also, click on Start under Service Commands and hit OK:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00172.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Repeat the same steps again for the ESXi Shell service. This will ensure that
    both services will be started once the ESXi server has started and will be opened
    and ready to accept the connection. You can test both services, SSH to the ESXi
    IP address and provide the root credentials as with SSH connection:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00173.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Generating a VMX file using Jinja2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The basic unit for a virtual machine (sometimes called a guest machine) is the
    VMX file. This file contains all the settings needed to build the virtual machine
    in terms of compute resources, allocated memory, HDD, and networking. Also, it
    defines the operating system that runs over the machine so the VMware can install
    some tools to manage the VM powering.
  prefs: []
  type: TYPE_NORMAL
- en: 'An additional file is needed: VMDK. This file stores the actual contents of
    the VM and acts as the hard disk for the VM partitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00174.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: These files (VMX and VMDK) should be stored under the `/vmfs/volumes/datastore1`
    directory in the ESXi Shell and should be inside a directory with the name of
    the virtual machine.
  prefs: []
  type: TYPE_NORMAL
- en: Building the VMX template
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are now going to create the template file that we will use to build our
    virtual machine in Python. Here''s an example of the final running VMX file that
    we need to generate with the help of Python and Jinja2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: I added some comments inside the file to illustrate the functionality of each
    block. However, in the actual file, you won't see these comments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s analyze the file and understand the meaning of some fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '`vhv.enable`: When set to `True`, the ESXi server will expose the CPU host
    flags to the guest CPU that allows the running of the VM inside the guest machine
    (called nested virtualization).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`displayName`: The name that will be registered in the ESXi and shown in the
    vSphere client.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`memsize`: This defines the allocated RAM to the VM and should be provided
    in megabytes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`numvcpus`: This defines the number of physical CPUs allocated to the VM. This
    flag is used with `cpuid.coresPerSocket` so it can define the total number of
    vCPU allocated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scsi0.virtualDev`: The type of SCSI controller for the virtual hard drive.
    It can be one of four values: BusLogic, LSI Logic parallel, LSI Logic SAS, or
    VMware paravirtual.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scsi0:0.fileName`: This defines the name of the `vmdk` (in the same directory)
    that will store the actual virtual machine settings.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ide1:0.fileName`: The image path that contains the installation binaries packaged
    in ISO format. This will make the ESXi connect the ISO image in the image CD-ROM
    (IDE device).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ethernet0.networkName`: This is the name of the virtual switch in ESXi that
    should connect to VM NIC. You can add additional instances of this parameter to
    reflect additional network interfaces.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now we will build the Jinja2 template; you can review [Chapter 6](part0102.html#318PC0-9cfcdc5beecd470bbeda046372f0337f),
    *Configuration Generator with Python and Jinja2,* for the basics of templating
    using the Jinja2 language:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we removed the static values for the relevant fields, such as `diplayName`,
    `memsize`, and so on, and replaced them with double curly braces with variable
    names inside them. During template rendering from Python, these fields will be
    replaced with actual values to construct a valid VMX file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s build the Python script that will render the file. Usually, we
    use the YAML data serialization in conjunction with Jinja2 to fill in the data
    of the template. But since we already explain the YAML concept in [Chapter 6](https://cdp.packtpub.com/hands_on_enterprise_automation_with_python/wp-admin/post.php?post=295&action=edit#post_33), *Configuration
    Generator with Python and Jinja2*, we will get our data from another data source,
    Microsoft Excel:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00175.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Handling Microsoft Excel data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python has some excellent libraries that can handle the data written in an Excel
    sheet. We already used the Excel sheet in [Chapter 4](part0062.html#1R42S0-9cfcdc5beecd470bbeda046372f0337f), *Using
    Python to Manage Network Devices*, when we needed to automate the `netmiko` configuration
    and read the data that described the infrastructure of the Excel file. Now, we
    will start by installing the Python `xlrd` library inside the Automation Server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following command to install `xlrd`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '![](../images/00176.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Follow the steps given below:'
  prefs: []
  type: TYPE_NORMAL
- en: The XLRD module can open the Microsoft workbook and parse the contents using
    the `open_workbook()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then you can select the sheet that contains your data either by providing the
    sheet index or the sheet name to the `sheet_by_index()` or `sheet_by_name()` methods
    respectively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, you can access the row data by providing the row number to the `row()`
    function which converts the row data into a Python list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00177.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Notice that  `nrows` and `ncols` are special variables which will be populated
    once you open the sheet that counts the number of rows and number of columns inside
    the sheet. You can iterate over with the `for` loop. The number always start from
  prefs: []
  type: TYPE_NORMAL
- en: 'Back to the virtual machine example. We will have the following data in the
    Excel sheet, which reflects the virtual machine settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00178.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'To read the data into Python, we will use the following script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous script, we did the following:'
  prefs: []
  type: TYPE_NORMAL
- en: We imported the `xlrd` module and provided the Excel file to the `open_workbook()`
    method to read the Excel sheet and save that to the `workbook` variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we accessed the first sheet using the `sheet_by_index()` method and saved
    the reference to the `sheet` variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we will iterate over the opened sheet and get each field using the `row()`
    method. This will allow us to convert the row to a Python list. Since we need
    only one value inside the row, we will use the list slice to access the index.
    Remember that the list index always starts with zero. We will store that value
    into the variable and we will use this variable to populate the Jinja2 template
    in the next section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generating VMX files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The last part is to generate the VMX files from the Jinja2 template. We will
    read the data from the Excel sheet and add it to the empty dictionary, `vmx_data`.
    This dictionary will be passed later to the `render()` function inside the Jinja2
    template. The Python dictionary key will be the template variable name while the
    value will be the substituted values that should be in the file. The final part
    in the script is to open a file in writing mode inside the `vmx_files` directory
    and write the data into it for each VMX file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The script output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00179.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The files are stored under `vmx_files` and each one contains specific information
    for the virtual machine as configured in the excel sheet:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00180.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, we will use both `paramiko` and `scp` libraries to connect to the ESXi
    Shell and upload these files under `/vmfs/volumes/datastore1`. To achieve that,
    we will first create a function named `upload_and_create_directory()` that accepts `vm
    name`, `hard disk size`, and VMX `source file`.  `paramiko` will connect to the
    ESXi server and execute the required commands which will create both the directory
    and VMDK under `/vmfs/volumes/datastore1`. Finally, we will use `SCPClient` from
    the `scp` module to upload the source files to the previously created directory
    and run the registry command to add the machine to the vSphere client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We need to define this function *before* we run theJinja2 template and generate
    the VMX and call the function *after* we save the file to the `vmx_files` directory
    and pass the required arguments to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final code should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The script output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00181.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you check the vSphere client after you run the script, you will find four
    machines have been created with the name provided in the Excel sheet:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00182.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Also, you will find the virtual machine customized with settings such as CPUs,
    Memory, and connected ISO room:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00183.jpeg)You can complete your automation workflow in VMware
    by connecting the created virtual machine to Cobbler. We covered it in [Chapter
    8](part0116.html#3EK180-9cfcdc5beecd470bbeda046372f0337f), *Preparing the System
    Lab Environment*. Cobbler will automate the operating system installation and
    customization either Windows, CentOS, or Ubuntu. After that, you can use Ansible,
    which we covered in [Chapter 13](part0168.html#506UG0-9cfcdc5beecd470bbeda046372f0337f)*,
    Ansible for System Administration*, to prepare the system in terms of security,
    configuration, and installed packages, then deploy your application after that.
    This is a full-stack automation that covers things such as virtual machine creation
    and getting your application up and running.'
  prefs: []
  type: TYPE_NORMAL
- en: VMware Python clients
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: VMware products (ESXi and vCenter, which used to manage ESXi) support receiving
    external API requests through the web service. You can execute the same administration
    tasks you do on the vSphere client, such as creating a new virtual machine, creating
    a new vSwitch, or even controlling the `vm` status, but this time through the
    supported API that has bindings for many languages, such as Python, Ruby, and
    Go.
  prefs: []
  type: TYPE_NORMAL
- en: vSphere has a special model for the inventory and everything inside it is an
    object with specific values. You can access this model and see the actual values
    for your infrastructure through the **Managed Object Browser** (**MoB**) which
    gives you access to all object details. We will use the official Python bindings
    from VMware (`pyvmomi`) to interact with this model and alter the values (or create
    them) inside the inventory.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s worth noting that the MoB can be accessed through the web browser by
    going to `http://<ESXi_server_ip_or_domain>/mob`,which will ask you to provide
    the root username and password:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00184.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can click on any of the hyperlinks to see more details and access each
    *leaf* inside each tree or context. For example, click on Content.about to see
    full details about your server such as the exact version, build, and full name:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00185.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Notice how the table is structured. The first column contains the property name,
    the second column is the data type of that property, and, finally, the third column
    is the actual running value.
  prefs: []
  type: TYPE_NORMAL
- en: Installing PyVmomi
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PyVmomi is available to download either though Python `pip` or as a system package
    from different repos.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Python installation, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '![](../images/00186.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Notice the version downloaded from `pip` is `6.5.2017.5-1`, which correlates
    with the vSphere release VMware vSphere 6.5, but this doesn't mean it won't work
    with older releases of ESXi. For example, I have VMware vSphere 5.5, which works
    flawlessly with the latest `pyvmomi` version.
  prefs: []
  type: TYPE_NORMAL
- en: 'For system installation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The Pyvmomi library uses dynamic types which means features such as Intelli-Sense
    and autocomplete features in IDE do not work with it. You have to rely on documentation
    and MoB to discover what classes or methods are needed to get the job done but,
    once you discover the way it works, it will be pretty easy to work with.
  prefs: []
  type: TYPE_NORMAL
- en: First steps with pyvmomi
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first thing is you need to do is connect to ESXi MoB by providing the username,
    password, and host IP, and start to navigate to the MoB to get the required data.
    This can be done by using the `SmartConnectNoSSL()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that there''s another method called `SmartConnect()` and you must provide
    the SSL context to it when establishing a connection, otherwise the connection
    will fail. However, you can use the following code snippet to request that the
    SSL does not verify the certificate and to pass this context to `SmartConnect()`
    in the `sslCContext` argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: For the sake of beverity and to keep our code short, we will use the built-in
    `SmartConnectNoSSL()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will start exploring the MoB and get the full name and version of
    our server in the `about` object. Remember, it''s located under the `content`
    object, so we need to access that too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**![](../images/00187.jpeg)**'
  prefs: []
  type: TYPE_NORMAL
- en: Great. Now we understand how the API works. Let's get into some serious scripts
    and retrieve some details about the deployed virtual machine in our ESXi.
  prefs: []
  type: TYPE_NORMAL
- en: 'The script is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous example, we did the following:'
  prefs: []
  type: TYPE_NORMAL
- en: We established the API connection again to MoB by providing the ESXi/vCenter
    credentials to the `SmartConnectNoSSL` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we accessed the data center object by accessing the `content` then `rootFolder`
    objects and finally `childEntity`. The returned object was an iterable so we accessed
    the first element (the first data center) since we had only one ESXi in the lab.
    You could iterate over all data centers to get a list of all virtual machines
    in all registered data centers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The virtual machines can be accessed via the `vmFolder` and the `childEntity`.
    Again, remember the returned output is iteratable and represents the virtual machine
    list stored inside the `virtual_machines` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00188.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We iterated over the `virtual_machines` object and we query the CPU, Memory,
    Full name, and IP address of each element (for each virtual machine). These elements
    are located under each virtual machine tree in the `summary` and `config` leafs.
    Here is an example of our `AutomationServer` settings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00189.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The script output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00190.jpeg)Note that the `python-vm` machines that we created
    early at the beginning of the chapter are printed in the last screenshot. You
    can use PyVmomi as a validation tool that integrates with your automation workflow
    to validate whether machines are up and running and to make decisions based on
    the returned output.'
  prefs: []
  type: TYPE_NORMAL
- en: Changing the virtual machine state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This time we will use the `pyvmomi` bindings to change the virtual machine state.
    This will be done by checking the virtual machine name as we did before; then,
    we will navigate to another tree in MoB and get the runtime status. Finally, we
    will apply either the `PowerOn()` or `PowerOff()` function on the machine depending
    on its current status. This will switch the machine state from `On` to `Off` and
    vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: 'The script is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The script output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00191.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Also, you can validate the virtual machine statue from the vSphere client and
    check the hosts that start with `python-vm*`, changing their power state from
    `poweredOff` to `poweredOn`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00192.gif)'
  prefs: []
  type: TYPE_IMG
- en: There's more
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find many useful scripts based on the `pyvmomi` bindings (in different
    languages) in the official VMware repository at GitHub ([https://github.com/vmware/pyvmomi-community-samples/tree/master/samples](https://github.com/vmware/pyvmomi-community-samples/tree/master/samples)).
    The scripts are provided by numerous contributors who use the tools and test them
    on a daily basis. Most of the scripts provide room to enter your configuration
    (such as ESXi IP address and credentials) without modifying the script source
    code by providing it as arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Using Ansible playbook to manage instances
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last part of VMware automation, we will utilize the Ansible tool to administrate
    the VMware infrastructure. Ansible ships with more than 20 VMware modules ([http://docs.ansible.com/ansible/latest/modules/list_of_cloud_modules.html#vmware](http://docs.ansible.com/ansible/latest/modules/list_of_cloud_modules.html#vmware)),
    which can execute many tasks such as managing data centers, clusters, and virtual
    machines. In older Ansible versions, Ansible used the `pysphere` module (which
    is not official; the author of the module has not maintained it since 2013) to
    automate the tasks. However, the newer version now supports the `pyvmomi` bindings.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible also supports the VMware SDN product (NSX). Ansible Tower can be accessed
    from **VMware vRealize Automation** (**vRA**), which allows for complete workflow
    integration between different tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the Ansible Playbook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous playbook, we can see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The first part of the playbook was to define the ESXi host IP and credentials
    in the `vars` section and to use them later in tasks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then we wrote a simple validation to fail the playbook if the username or password
    was not provided.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, we used the `vmware_guest` module provided by ansible ([https://docs.ansible.com/ansible/2.4/vmware_guest_module.html](https://docs.ansible.com/ansible/2.4/vmware_guest_module.html))
    to provision the virtual machine. Inside this task, we provided the required information,
    such as disk size and hardware in term of CPU and memory. Notice that we defined
    the state of the virtual machine as `poweredon` so ansible will power on the virtual
    machine after creating it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disks, networks, hardware, and CD-ROMs are all keys inside the `vmware_guest`
    module used to describe the virtualized hardware specs needed for spawning the
    new VM over the VMware ESXi.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Run the playbook using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the screenshot of the Playbook output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00193.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can validate the virtual machine creation and binding with the CentOS ISO
    file in the vSphere client:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00194.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: You can also change the state of the existing virtual machine and choose from
    `poweredon`, `poweredoff`, `restarted`, `absent`, `suspended`, `shutdownguest`,
    and `rebootguest` by changing the value in `state` inside the playbook.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: VMware products are used widely inside IT infrastructure to provide virtualized
    environments for running applications and workloads. At the same time, VMware
    also provides API bindings in many languages that can be used to automate administration
    tasks. In the next chapter, we will explore another virtualization framework called
    OpenStack that relies on the KVM hypervisor from Red Hat.
  prefs: []
  type: TYPE_NORMAL
