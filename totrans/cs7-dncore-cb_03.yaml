- en: Object-Oriented Programming in C#
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter will introduce you to the foundation of C# and **object-oriented
    programming** (**OOP**). In this chapter, you will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Using inheritance in C#
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using abstraction
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leveraging encapsulation
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing polymorphism
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Single responsibility principle
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Open/closed principle
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exception handling
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'During your career as a creator of software, you will hear the term OOP many
    times. This design philosophy allows for objects to exist independently and can
    be reused by different sections of code. This is all made possible by what we
    refer to as the four pillars of OOP: inheritance, encapsulation, abstraction,
    and polymorphism.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to grasp this, you need to start thinking of objects (which are basically
    instantiated classes) that perform a specific task. Classes need to adhere to
    the SOLID design principle. This principle is explained here:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Single responsibility principle (SRP)
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Open/closed principle
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Liskov substitution principle (LSP)
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interface segregation principle
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependency inversion principle
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start off with an explanation of the four pillars of OOP, after which
    we will take a look at the SOLID principle in more detail.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Using inheritance in C#
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In today's world, inheritance is usually associated with the end of things.
    In OOP, however, it is associated with the beginning of something new and better.
    When we create a new class, we can take an already existing class and inherit
    it on our new class. This means that our new object will have all the features
    of the inherited class as well as the additional features added to the new class.
    This is at the root of inheritance. We call a class that inherits from another
    a derived class.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To illustrate the concept of inheritance, we will create a few classes that
    inherit from another to form new, more feature-rich objects.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create a new console application and add a class called `SpaceShip` to your
    console application.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Our `SpaceShip` class will contain a few methods that describe the basics of
    a spaceship. Go ahead and add these methods to your `SpaceShip` class:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Because the `SpaceShip` class forms part of all other intergalactic vessels,
    it becomes the blueprint for every other vessel.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we want to create a `Destroyer` class. To accomplish this, we will create
    a `Destroyer` class and use a colon after the class name to indicate that we want
    to inherit from another class (the `SpaceShip` class). Therefore, the following
    needs to be added when creating the `Destroyer` class:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We can also say that the `Destroyer` class is derived from the `SpaceShip` class.
    The `SpaceShip` class is therefore the base class of all other intergalactic vessels.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add a few methods to the `Destroyer` class that are unique to a destroyer.
    These methods belong only to the `Destroyer` class and not to the `SpaceShip`
    class:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Finally, create a third class called `Annihilator`. This is the most powerful
    intergalactic vessel and is used to wage war on planets. Let the `Annihilator` class
    inherit from the `Destroyer` class by creating the class and marking it derived
    from the `Destroyer` class as follows:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Finally, add a few methods to the `Annihilator` class that only belong to this
    type of `SpaceShip` class:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'What we see now is that when we create a new instance of the `SpaceShip` class
    in our console application, only the methods defined in that class are available
    to us. This is because the `SpaceShip` class does not inherit from any other classes:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_03_04.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
- en: 'Go ahead and create the `SpaceShip` class with its methods in the console application:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You will see that these are the only methods available to us when instantiating
    a new instance of this class.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, create a new instance of the `Destroyer` class. You will notice that
    the `Destroyer` class contains more methods than what we defined when we created
    the class. This is because the `Destroyer` class is inheriting the `SpaceShip`
    class and therefore inherits the methods of the `SpaceShip` class:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_03_05.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
- en: 'Go ahead and create the `Destroyer` class with all its methods in the console
    application:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Finally, create a new instance of the `Annihilator` class. This class contains
    all the methods of the `Destroyer` class as well as the methods from the `SpaceShip`
    class. This is because `Annihilator` inherits from the `Destroyer`, which, in
    turn, inherits from `SpaceShip`:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_03_06.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
- en: 'Go ahead and create the `Annihilator` class with all its methods in the console
    application:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: How it works...
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can see that inheritance allows us to easily extend our classes by reusing
    functionality that already exists within another class created earlier. You also
    need to be aware though that any changes to the `SpaceShip` class will be inherited,
    all the way up to the top-most derived class.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance is a very powerful feature of C# that allows developers to write
    less code, and reuse working and tested methods.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Using abstraction
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With abstraction, we take from the object we want to create the basic functionality
    that all objects derived from the abstracted object must have. To explain this
    in simple terms, we abstract the common functionality and put it in a single class
    that will be used to provide this shared functionality to all classes that inherit
    from it.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To explain abstraction, we will use abstract classes. Imagine that you are dealing
    with trainee space astronauts who need to progress through the ranks as they get
    trained. The truth is that once you as trainee learn a new skill, that skill is
    learned and will remain with you even though you learn more advanced ways to do
    things. You must also implement all the previous skills learned in the new object
    you create. Abstract classes demonstrate this concept very nicely.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create an abstract class called `SpaceCadet`. This is the first type of astronaut
    you can get when starting with training. The abstract class and its members are
    defined using the `abstract` keyword. A thing to note is that abstract classes
    cannot be instantiated. The members represent the skills that `SpaceCadet` will
    have, such as negotiation and basic weapons training:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Next, create another abstract class called `SpacePrivate`. This abstract class
    inherits from the `SpaceCadet` abstract class. What we are basically saying is
    that when a space cadet is trained as a space private, they will still have all
    the skills learned as a space cadet:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To demonstrate this, create a class called `LabResearcher` and inherit the
    `SpaceCadet` abstract class. Inheriting from the abstract class is done by defining
    a colon and abstract class name after the newly created class name. This tells
    the compiler that the `LabResearcher` class inherits from the `SpaceCadet` class:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Because we are inheriting an abstract class, the compiler will underline the
    `LabResearcher` class name to warn us that the derived class does not implement
    any of the methods in the `SpaceCadet` abstract class.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: 'If you hover your mouse over the squiggly line, you will see that the lightbulb
    tip provides us with the issues discovered:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_03_09.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
- en: 'Visual Studio does a great job of providing a solution to the issues discovered.
    By typing *Ctrl* + *.* (control key and period), you can let Visual Studio show
    you some potential fixes (in this case, only one fix) for the issues identified:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_03_10.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
- en: 'After Visual Studio has added the required methods, you will see that these
    are the same methods defined in the `SpaceCadet` abstract class. Abstract classes,
    therefore, require the classes inheriting from the abstract class to implement
    the methods defined in the abstract class. You will also notice that the methods
    added to the `LabResearcher` class contain no implementation and will throw an
    exception if used as is:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Next, create a class called `PlanetExplorer` and make this class inherit from
    the `SpacePrivate` abstract class. You will remember that the `SpacePrivate` abstract
    class inherited from the `SpaceCadet` abstract class:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Visual Studio will once again warn you that your new class does not implement
    the methods of the abstract class that you are inheriting from. Here, however,
    you will notice that the lightbulb tip informs you that you are not implementing
    any of the methods in the `SpacePrivate` and `SpaceCadet` abstract classes. This
    is because the `SpacePrivate` abstract class is inheriting from the `SpaceCadet`
    abstract class:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_03_11.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
- en: As before, to fix the issues identified, type *Ctrl* + *.* (control key and
    period) and let Visual Studio show you some potential fixes (in this case, only
    one fix) for the issues identified.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After the fixes have been added to your code, you will see that the `PlanetExplorer`
    class contains all the methods in the `SpacePrivate` and `SpaceCadet` abstract
    classes:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: How it works...
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Abstraction has allowed us to define a common set of functionality that is to
    be shared among all the classes that derive from the abstract classes. The difference
    between inheriting from the abstract class and a normal class is that with an
    abstract class, you have to implement all the methods defined in that abstract
    class.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: This makes the class easy to version and change. If you need to add new functionality,
    you can do so by adding that functionality to the abstract class without breaking
    any of the existing code. Visual Studio will require that all inherited classes
    implement the new method defined in the abstract class.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: You can, therefore, be assured that the change applied will be implemented in
    all your classes that derive from the abstract classes in your code.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging encapsulation
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What is encapsulation? Simply put, it is hiding the inner workings of a class
    that aren''t necessary for the implementation of that class. Think of encapsulation
    as follows: most people who own a car know that it runs on gas- they don''t need
    to know the inner working of an internal combustion engine to be able to use a
    car. They only need to know that they need to fill it up with gas when it is close
    to empty and that they need to check the oil and tyre pressure. Even then, it
    is usually not done by the car owner. This is true for classes and encapsulation.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: The owner of the class is the one who uses it. The inner workings of that class
    need not be exposed to the developer using the class. The class is, therefore,
    like a black box. You know that the class will be consistent in its functionality,
    given the correct set of parameters. How exactly the class gets to the output
    is of no concern to the developer as long as the input is correct.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To illustrate the concept of encapsulation, we will create a class that is somewhat
    complex in its inner working. We need to calculate the **thrust-to-weight ratio **(**TWR**)
    of a space shuttle to determine whether it will be able to take off vertically.
    It needs to exert more thrust than its weight to counteract gravity and get into
    a stable orbit. This also depends on which planet the shuttle takes off, because
    different planets exert different gravitational forces on objects on their surface.
    In simple terms, the TWR must be greater than one.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new class called `LaunchSuttle`. Then, add the following private variables
    to the class for engine thrust, the mass of the shuttle, the local gravitational
    acceleration, the constant values for the gravity of the Earth, Moon, and Mars
    (these are constants because they will never change), the universal gravitational
    constant, and an enumerator for the planet we are dealing with:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: To our class, we will add three overloaded constructors that are essential to
    perform the calculation of the TWR based on the known facts at the time of instantiation
    (we assume that we will always know the engine thrust capability and mass of the
    shuttle). We will pass the gravitational acceleration for the first constructor.
    This is useful if we know beforehand what that value will be. For example, the
    gravitational acceleration of the Earth is 9.81 m/s².
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The second constructor will use the `Planet` enumerator to calculate the TWR
    that uses the constant variable values.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: 'The third constructor will use the radius and mass of the planet to calculate
    the gravitational acceleration, when those values are known, to return the TWR:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In order to use the second overloaded constructor that passes the `Planet`
    enumerator as a parameter to the class, we need to create another method that
    has been scoped as `private` to calculate the gravitational acceleration. We also
    need to set the `_LocalGravitationalAcceleration` variable to the specific constant
    that matches the enumerator value. This method is something that the user of the
    class does not need to see in order to use the class. It is, therefore, scoped
    as `private` in order to hide that functionality from the user:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Of the following methods, only one is defined as public and will, therefore,
    be visible to the user of the class. Create the private methods to set the universal
    gravitational constant and to calculate the TWR and the gravitational acceleration.
    These are all scoped as private, because the developer does not need to know what
    these methods do in order to use the class:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Finally, in your console application, create the following variables with their
    known values:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Create a new instance of the `LaunchShuttle` class and pass it the values needed
    to calculate the TWR:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'When you use the dot operator on the `NasaShuttle1` variable, you will notice
    that the IntelliSense only shows the `TWR` method. The class exposes nothing of
    the inner workings of how it gets to the calculated TWR value. The only thing
    that the developer knows is that the `LaunchShuttle` class will consistently return
    the correct TWR value, given the same input parameters:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_03_13.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
- en: 'To test this, create two more instances of the `LaunchShuttle` class and call
    a different constructor each time:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If you run your console application, you will see that the same value is returned
    for the TWR. The value indicates that a shuttle weighing 16.12 tons with a rocket
    that puts out 220 kilonewtons of thrust will be able to lift off the surface of
    the Earth (if only just):'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_03_14.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
- en: How it works...
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The class uses the scoping rules to hide certain functionality inside the class
    from the developer using the class. As mentioned earlier, the developer does not
    need to know how the calculations are done to return the value for the TWR. This
    all aids in making the class more useful and easy to implement. Here is a list
    of the various scopes available in C# along with their uses:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '`Public`: This is used with variables, properties, types, and methods and is
    visible anywhere.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Private`: This is used with variables, properties, types, and methods and
    is visible only in the block where they are defined.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Protected`: This is used with variables, properties, and methods. Don''t think
    of this in terms of public or private. The protected scope is only visible inside
    the class in which it is used as well as in any inherited classes.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Friend`: This is used with variables, properties, and methods and can only
    be used by code in the same project or assembly.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ProtectedFriend`: This is used with variables, properties, and methods and
    is a combination (as the name suggests) of the protected and friend scopes.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing polymorphism
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Polymorphism is a concept that is quite easy to grasp once you have looked at
    and understood the other pillars of OOP. Polymorphism literally means that something
    can have many forms. This means that from a single interface, you can create multiple
    implementations thereof.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: There are two subsections to this, namely, static and dynamic polymorphism.
    With **static polymorphism**, you are dealing with the overloading of methods
    and functions. You can use the same method, but perform many different tasks.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: With **dynamic polymorphism**, you are dealing with the creation and implementation
    of abstract classes. These abstract classes act as a blueprint that tells you
    what a derived class should implement. The following section looks at both.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will begin by illustrating the use of an abstract class, which is an example
    of dynamic polymorphism. We will then create overloaded constructors as an example
    of static polymorphism.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create an abstract class called `Shuttle` and give it a member called `TWR`,
    which is the calculation of the TWR of the shuttle:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next, create a class called `NasaShuttle` and have it inherit from the abstract
    class `Shuttle` by putting the abstract class name after a colon at the end of
    the `NasaShuttle` class declaration:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Visual Studio will underline the `NasaShuttle` class because you have told
    the compiler that the class inherits from an abstract class, but you have not
    yet implemented the members of that abstract class:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_03_15.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
- en: 'To fix the issues identified, type *Ctrl* + *.* (control key and period) and
    let Visual Studio show you some potential fixes (in this case, only one fix) for
    the issues identified:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_03_16.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
- en: 'Visual Studio then adds the missing implementation to your `NasaShuttle` class.
    By default, it will add it as not implemented, because you are required to provide
    implementation for the abstract member you overrode in the abstract class:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Create another class called `RoscosmosShuttle` and inherit from the same `Shuttle`
    abstract class:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As before, Visual Studio will underline the `RoscosmosShuttle` class because
    you have told the compiler that the class inherits from an abstract class, but
    you have not yet implemented the members of that abstract class.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To fix the issues identified, type *Ctrl* + *.* (control key and period) and
    let Visual Studio show you some potential fixes (in this case, only one fix) for
    the issues identified.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The overridden method is then added to the `RoscosmosShuttle` class as not
    implemented. You have just seen an example of dynamic polymorphism in action:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'To see an example of static polymorphism, create the following overloaded constructor
    for `NasaShuttle`. The constructor name stays the same, but the signature of the
    constructor changes, which makes it overloaded:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: How it works...
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Polymorphism is something you will easily be using already by simply applying
    good object-oriented principles to the design of your classes. With the abstract
    `Shuttle` class, we saw that the class took on the shape of the `NasaShuttle` class
    and the `RoscosmosShuttle` class when it was used to derive those new classes
    from its abstraction. The constructor of the `NasaShuttle` class was then overridden
    to provide the same method name, but implemented using different signatures.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: This is at the heart of polymorphism. Most likely, you have been using it without
    knowing about it.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Single responsibility principle
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When talking about SOLID principles, we will start off with the **single responsibility
    principle** (**SRP**). Here, we are actually saying that a class has a specific
    task that it needs to fulfill and it should not do anything else.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will create a new class and write code to log an error to the database when
    an exception is thrown on adding more troops to the star ship, causing it to be
    over capacity. For this recipe, ensure that you have added `using System.Data;`
    and `using System.Data.SqlClient;` namespaces to your application.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new class called `StarShip`:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'To your class, add a new method that will set the maximum troop capacity of
    the `StarShip` class:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Inside this method, add a `trycatch` clause that will attempt to set the maximum
    troop capacity, but for some reason, it will fail. Upon failure, it will write
    the error to the log table inside the database:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: How it works...
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have code that looks like the preceding one, you are in contravention
    of the SRP. The `StarShip` class is no longer responsible for just itself and
    things that have to do with star ships. It now has to fulfill the role of logging
    errors to the database too. You see the problem here is that the database-logging
    code does not belong in the `catch` clause of the `SetMaximumTroopCapacity` method.
    A better approach would be to create a separate `DatabaseLogging` class with methods
    to create connections and write exceptions to the appropriate log table. You will
    also find that you are going to have to write that logging code in multiple places
    (in every `catch` clause). If you are finding that you are repeating code (by
    copying and pasting from other areas), you probably need to put that code into
    a common class, and you have likely broken the SRP rule.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: Open/closed principle
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When creating classes, we need to ensure that the class prohibits any breaking
    modifications by needing to change internal code. We say that such a class is
    closed. If we need to change it somehow, we can do so by extending the class.
    This extensibility is where we say that the class is open for extensions.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will create a class that determines the skills of a trooper by looking at
    the class of trooper. We will show you the way many developers create such a class
    and the way it can be created using the open/closed principle.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a class called `StarTrooper`:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: To this class, add an enumerator called `TrooperClass` to identify the type
    of trooper we want to return the skills of. Also, create a `List<string>` variable
    to contain the skills of the specific trooper class. Finally, create a method
    called `GetSkills` that returns the specific set of skills for the given trooper
    class.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The class is quite straightforward, but the implementation of the code is something
    we see a lot. Sometimes, instead of a `switch` statement, you will see a whole
    lot of `if...else` statements. While the functionality of the code is clear, it
    is not easy to add another class of trooper to the `StarTrooper` class without
    changing code. Assume that you now have to add an additional `Engineer` class
    to the `StarTrooper` class. You would have to modify the `TrooperClass` enumeration
    and the code in the `switch` statement.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: 'This changing of code can cause you to introduce bugs into the code that was
    previously working fine. We now see that the `StarTrooper` class is not closed
    and can''t be extended easily to accommodate additional `TrooperClass` objects:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The solution to this problem is inheritance. Instead of having to change code,
    we extend it. Start off by rewriting the preceding `StarTrooper` class and create
    a `Trooper` class. The `GetSkills` method is declared as `virtual`:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now, we can easily create derived classes for the `Soldier`, `Medic`, and `Scientist`
    trooper classes available. Create the following derived classes that inherit from
    the `Trooper` class. You can see that the `override` keyword is used when creating
    the `GetSkills` method:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The code becomes extremely easy to implement when extending the class to add
    an additional class of `Trooper`. If we now want to add the `Engineer` class,
    we would simply override the `GetSkills` method after inheriting from the `Trooper`
    class created earlier:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: How it works...
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The classes derived from the `Trooper` class are extensions of the `Trooper`
    class. We can say that each class is closed, because modifying it does not necessitate
    changing the original code. The `Trooper` class is also extensible because we
    have been able to easily extend the class by creating derived classes from it.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: Another byproduct of this design is smaller, more manageable code that is easier
    to read and understand.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: Exception handling
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Exception handling is something that you as a developer need to be aware of,
    and you must also be very good at discerning what information to display to the
    end user and what information to log. Believe it or not, writing good error messages
    is harder than it looks. Too much information displayed to the user might instill
    a sense of distrust in the software. Too little information logged for debugging
    purposes is also not useful at all to the poor soul that needs to fix the error.
    This is why you need to have an **exception handling strategy**.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: A nice rule of thumb is to display a message to the user stating that something
    went wrong, but that a notification has been sent to support personnel. Think
    of Google, Dropbox, Twitter (remember the blue whale?), and other big companies.
    Humorous error pages with a little robot whose arm fell off, or a popular meme
    displayed to the user is far better than a threatening error page with a full
    stack trace and red text. It is something that momentarily takes the user's mind
    off a frustrating situation. Most importantly of all, it lets you save face.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: So let's start off by looking at exception filters. These have been around for
    some time. Visual Basic.NET (VB.NET) and F# devs have had this functionality for
    a while. It was introduced in C# 6.0 and does more than meets the eye. At first
    glance, it looks as if exception filters merely specify a condition when an exception
    needs to be caught. This is, after all, what the name *exception filter* implies.
    Upon closer inspection, however, we see that exception filters act as more than
    just syntactical sugar.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will create a new class called `Chapter3` and call a method that reads an
    XML file. The file read logic is determined by a Boolean flag being set to `true`.
    Imagine that there is some other database flag that when set, also sets our Boolean
    flag to `true`, and thus, our application knows to read the given XML file.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: 'Begin by ensuring that you have added the following `using` statement:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: How to do it...
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a class called `Chapter3` (if you have not done so already) that contains
    two methods. One method reads the XML file, and the second method logs any exception
    errors:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In the console application, add the following code to call the `ReadXMLFile`
    method, passing it the filename to read:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Running the application will generate an error (assuming that you actually
    don''t have a file called `XMLFile.xml` in your `temp` folder. Visual Studio will
    break on the `throw` statement:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_03_01.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
- en: The `Log(ex)` method has logged the exception, but have a look at the Watch1
    window. We have no idea what the value of `blnReadFileFlag` is. When an exception
    is caught, the stack is unwound (adding overhead to your code) to whatever the
    actual catch block is. Therefore, the state of the stack before the exception
    happened is lost.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_03_02.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
- en: 'Modify your `ReadXMLFile` and `Log` methods as follows to include an exception
    filter:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Running the console application again, Visual Studio will break on the actual
    line of code that caused the exception:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_03_03.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
- en: 'More importantly, the value of `blnReadFileFlag` is still in scope. This is
    because exception filters can see the state of the stack at the point where the
    exception occurred instead of where the exception was handled. Looking at the
    locals window in Visual Studio, you will see that the variables are still in scope
    at the point where the exception occurred:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更重要的是，`blnReadFileFlag`的值仍然在作用域内。这是因为异常过滤器可以看到异常发生的地点的堆栈状态，而不是异常处理的地点。在Visual
    Studio的本地窗口中查看，您会发现变量在异常发生的地点仍然在作用域内。
- en: '![](img/B06434_03_04.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_03_04.png)'
- en: How it works...
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Imagine being able to view the exception information in a log file with all
    the local variable values available. Another interesting point to note is the
    return `false` statement in the `Log(ex)` method. Using this method to log the
    error and return `false` will allow the application to continue and have the exception
    handled elsewhere. As you know, catching `Exception ex` will catch everything.
    By returning `false`, the exception filter doesn''t run into the `catch` statement,
    and more specific `catch` exceptions (for example, `catch (FileNotFoundException
    ex)` after our `catch (Exception ex)` statement) can be used to handle specific
    errors. Normally, when catching exceptions, `FileNotFoundException` will never
    be caught in the following code example:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下能够在日志文件中查看异常信息，并且所有局部变量值都可用。另一个有趣的地方要注意的是`Log(ex)`方法中的返回`false`语句。使用这种方法记录错误并返回`false`将允许应用程序继续并在其他地方处理异常。如您所知，捕获`Exception
    ex`将捕获一切。通过返回`false`，异常过滤器不会进入`catch`语句，并且可以使用更具体的`catch`异常（例如，在`catch (Exception
    ex)`语句之后的`catch (FileNotFoundException ex)`）来处理特定错误。通常，在捕获异常时，`FileNotFoundException`不会在以下代码示例中被捕获：
- en: '[PRE40]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This is because the order of the exceptions being caught is wrong. Traditionally,
    developers must catch exceptions in their order of specificity, which means that
    `FileNotFoundException` is more specific than `Exception` and must, therefore,
    be placed before `catch (Exception ex)`. With exception filters that call a `false`
    returning method, we can inspect and log an exception accurately:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为捕获异常的顺序是错误的。传统上，开发人员必须按照特异性的顺序捕获异常，这意味着`FileNotFoundException`比`Exception`更具体，因此必须在`catch
    (Exception ex)`之前放置。通过调用返回`false`的方法的异常过滤器，我们可以准确检查和记录异常：
- en: '[PRE41]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The preceding code will catch all exceptions, and in doing so, log the exception
    accurately but not step into the exception handler because the `Log(ex)` method
    returns `false`. Another implementation of exception filters is that they can
    allow developers to retry code in the event of a failure. You might not specifically
    want to catch the first exception, but implement a type of timeout element to
    your method. When the error counter has reached the maximum iterations, you can
    catch and handle the exception. You can see an example of catching an exception
    based on a `try` clauses'' count here:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将捕获所有异常，并在这样做时准确记录异常，但不会进入异常处理程序，因为`Log(ex)`方法返回`false`。异常过滤的另一个实现是，它们可以允许开发人员在发生故障时重试代码。您可能不希望特别捕获第一个异常，而是在方法中实现一种超时元素。当错误计数器达到最大迭代次数时，您可以捕获并处理异常。您可以在这里看到基于`try`子句计数捕获异常的示例：
- en: '[PRE42]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Exception filtering is a very useful and extremely powerful way to handle exceptions
    in your code. The behind-the-scenes workings of exception filters are not as immediately
    obvious as one might imagine, but here lies the actual power of exception filters.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 异常过滤是处理代码中异常的一种非常有用且非常强大的方式。异常过滤的幕后工作并不像人们想象的那样立即显而易见，但这就是异常过滤的实际力量所在。
