- en: React Component Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Developing Android and iOS has never been easier than it is now. React Native
    has changed how fast we develop new apps and deliver value to the end user. Knowing
    this technology will give you a great edge in the market. I'm Matt and I'm happy
    to show you the best practices I have learned while working in a React Native
    ecosystem. Through this book, we will explore design patterns by example. In just
    this first chapter, we will create over 10 small applications. Later on in this
    book, we will create more complex applications, using the patterns that I will
    gradually introduce to you.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will explore React patterns that also apply to the React
    Native world. The most crucial patterns you need to understand are stateless and
    stateful components. Understanding how to use these will make you a much better
    React Native developer and empower you with standard patterns in every React Native
    application.
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to components, it is crucial to make them as reusable as possible
    and follow the well-known programmer principle—**Don't Repeat Yourself** (**DRY**).
    Presentational components and container components are meant to do just that.
    We will dive into them with a couple of examples to learn how to split features
    into reusable pieces.
  prefs: []
  type: TYPE_NORMAL
- en: 'To be more precise, in this first chapter, we will look at the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Stateless and stateful components, using short and then more complex examples
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create reusable and easily configurable presentational components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Container components and their role in the encapsulation of features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When to compose components and how to create **Higher Order Components** (**HOCs**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's time to act on your side. **Prepare your environment for React Native development
    right now **if you want to follow along and play with the examples. Most of the
    code samples that you will see in this book can be run and displayed either on
    a simulator or on a real mobile device. Now, make sure that you can launch the
    `Hello World` example on your mobile or simulator.
  prefs: []
  type: TYPE_NORMAL
- en: Code examples are checked into a Git repository on GitHub, which can be found
    at [https://github.com/Ajdija/hands-on-design-patterns-with-react-native](https://github.com/Ajdija/hands-on-design-patterns-with-react-native).
  prefs: []
  type: TYPE_NORMAL
- en: Please follow the `readme.md` instructions to set up your machine and launch
    our first example. The `Hello World` example can be found in the following directory `src/Chapter_1_React_component_patterns/Example_1_Hello_World`.
  prefs: []
  type: TYPE_NORMAL
- en: Stateless and stateful components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First of all, let''s look at the first stateless component that has been created
    for us. It has been automatically generated by **Create React Native App** (**CRNA**)
    for our `Hello World` application. This component was created using the class
    syntax that was introduced in ECMAScript 2015 (ES6). Such components are usually
    called **class components**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Class components can be used to create stateful components.
  prefs: []
  type: TYPE_NORMAL
- en: The code samples provided in this book use ECMAScript 2018 syntax with Stage
    3 feature *class field declarations*. Babel is the transpiler that supports such
    code by relevant plugins that are pre-configured for us by the CRNA toolbox. If
    you decide not to use CRNA, then you may need to configure Babel yourself.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, in this case, the class component is unnecessary. We can safely use
    a stateless one, as it''s simpler. Let''s see how we can declare a **stateless
    component**. The most common approach is by using ES6 arrow syntax. Such components
    are called **functional components**. Check out the following code to see what
    our rewritten component looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are not a fan of arrow syntax, you can also use regular `function` syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The very first question that pop ups is: why is it stateless? The answer is
    simple: it doesn''t contain any inner state. This means that we are not storing
    any private data inside it. Everything the component needs to render itself is
    provided from the external world, which the component does not care about.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this little example, we actually never pass any external data to the component.
    Let''s do that now. To do so, we will create another component called `HelloText`
    that consumes one property: text to display. The usual convention to pass the
    text to such a component is to place the text between the opening and closing
    tag, for instance, `<HelloText> example text that is passed </HelloText>`. Hence,
    to retrieve such a prop within our functional component, we will need to use a
    special key called `children`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Using the `children` prop makes our `HelloText` component way more powerful.
    Props are a very flexible mechanism. Using props, you can send any valid JavaScript
    type. In this case, we have sent just text, but you can send other components,
    too.
  prefs: []
  type: TYPE_NORMAL
- en: It's time to add some vitality to our component. We will make it expand the
    third text block, but only after pressing the chapter or title text. For this
    functionality, we need to store a state that remembers if the component is expanded
    or collapsed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is what you need to do:'
  prefs: []
  type: TYPE_NORMAL
- en: Change the component to the class syntax.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Leverage the state object of the React library. We must initialize the state
    within the class constructor and make the text collapsed by default.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add conditional rendering to the component `render` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the press handler, which will change the state once we tap on the title
    or chapter text.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The solution is presented in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Congratulations—we have made our first stateless and stateful components!
  prefs: []
  type: TYPE_NORMAL
- en: Note the `&&` operator that displays the component. If a Boolean value on the
    left side of the operator is `true`, then the component on the right-hand side
    will be displayed. The whole expression needs to be wrapped into curly brackets.
    We will explore more of its capabilities in [Chapter 3](3045eaef-f5e9-4096-accb-c7d61fc5a9c0.xhtml),
    Style Patterns.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s time to create something more challenging: `Task list`. Please start
    over and prepare your code. Clean up `App.js` so that it only includes the `App`
    class component:'
  prefs: []
  type: TYPE_NORMAL
- en: The constructor should initialize the task list in its state. In my example,
    the task list will be an array of strings.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Iterate over the tasks to create the `Text` component for each task. This should
    happen in the `render` function of the `App` component. Please note that you can
    simplify iteration by using the `map` function instead of a regular `for` loop.
    Doing this should become second nature, since it's became a standard in almost
    every JS project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'My solution is presented in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Iterating using `map` is a nice feature, but the whole component doesn't look
    like a task list yet. Don't worry, you will learn how to style components in [Chapter
    3](3045eaef-f5e9-4096-accb-c7d61fc5a9c0.xhtml), *Style Patterns*.
  prefs: []
  type: TYPE_NORMAL
- en: What are the advantages of stateless components?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It may seem tempting to only use stateful class components and develop a whole
    application like that. Why would we even bother with stateless functional components?
    The answer is performance. Stateless functional components can be rendered faster.
    One of the reasons why this is the case is because stateless functional components
    do not require some of the life cycle hooks.
  prefs: []
  type: TYPE_NORMAL
- en: What are life cycle hooks? React components have life cycles. This means that
    they have different stages like mounting, unmounting, and updating. You can hook
    each stage and even sub stage. Please check the official React documentation to
    see the full list of available life cycle methods: [https://reactjs.org/docs/state-and-lifecycle.html](https://reactjs.org/docs/state-and-lifecycle.html).
    [](https://reactjs.org/docs/state-and-lifecycle.html) These are useful to trigger
    fetching data from the API or to update the view.
  prefs: []
  type: TYPE_NORMAL
- en: 'Please note that if you are using React v16 or later, it is not true that functional
    components are wrapped into class components internally within the React library:'
  prefs: []
  type: TYPE_NORMAL
- en: '"Functional components in React 16 don''t go through the same code path as
    class components, unlike in the previous version where they were converted to
    classes and would have the same code path. Class components have additional checks
    that are required and overhead in creating the instances that simple functions
    don''t have. These are micro-optimizations though and shouldn''t make a huge difference
    in real-world apps – unless your class component is overly complex." - Dominic
    Gannaway, engineer on the React core team at Facebook ([https://github.com/reactjs/reactjs.org/issues/639#issuecomment-367858928](https://github.com/reactjs/reactjs.org/issues/639#issuecomment-367858928))'
  prefs: []
  type: TYPE_NORMAL
- en: 'Functional components are faster, but in most cases are outperformed by class
    components extending `React.PureComponent`:'
  prefs: []
  type: TYPE_NORMAL
- en: '"Still, to be clear, they don''t bail out of rendering like PureComponent does
    when props are shallowly equal." - Dan Abramov, co-author of Redux and Create
    React App, engineer on the React core team at Facebook ([https://twitter.com/trueadm/status/916706152976707584](https://twitter.com/trueadm/status/916706152976707584))'
  prefs: []
  type: TYPE_NORMAL
- en: Functional components are not only more concise, but they usually are also pure
    functions. We will explore this concept further in [Chapter 9](0577761c-9fca-49f2-98ad-2d217e00e974.xhtml),
    *Elements of Functional Programming Patterns*. Pure functions provide a lot of
    benefits, such as a predictable UI and easy tracking of user behavior. The application
    can be implemented in a certain way to record user actions. Such data helps with
    debugging and reproducing errors in tests. We will dig into this topic later on
    in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Component composition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have learned any **Object-Oriented** (**OO**) language, you may have
    used inheritance extensively. In JavaScript, this concept is a little bit different.
    JavaScript inheritance is based on prototypes, and so we call it **prototypal
    inheritance**. Functionalities are not copied to the object itself—they are inherited
    from the prototype of the object and possibly even through other prototypes in
    the prototype tree. We call this a **prototype chain**.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, in React, using inheritance is not very common. Thanks to components,
    we can embrace another pattern called **component composition**. Instead of creating
    a new class and inheriting from the base class, we will create a new parent component
    that will use its child component to make itself more specific or more powerful.
    Let''s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `App` component is being built out of three components: `View`, `Text`,
    and `WarningText`. It is a perfect example of how one component, through composition,
    can reuse the capabilities of others.
  prefs: []
  type: TYPE_NORMAL
- en: The `WarningText` component uses composition to enforce the orange text color
    in the `Text` component. It makes the generic `Text` component more specific.
    Now, we can reuse `WarningText` in any place of the app where it is necessary.
    If our app designer decides to alter the warning text, we can quickly adapt to
    the new design in one place.
  prefs: []
  type: TYPE_NORMAL
- en: Note the implicit pass of a special prop called children. It represents the
    children of the component. In `Example 6_ Component composition *-* red text`,
    we first pass warning text as children to the `WarningText` component and then
    using the spread operator it is passed to the `Text` component, which `WarningText`
    encapsulates.
  prefs: []
  type: TYPE_NORMAL
- en: Composing the application layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's suppose we have to create a welcome screen for our application. It should
    be divided into three sections—header, main content, and footer. We would like
    to have consistent margins and styling for both logged and anonymous users. However,
    the header and footer content will differ. Our next task is to create a component
    that supports these requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Let's create a welcome screen that will use a generic component for encapsulating
    an app layout.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow this step-by-step guide to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `AppLayout` component that enforces some styling. It should accept
    three props: `header`, `MainContent`, and `Footer`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s now time to create placeholders for header, footer, and content. We have
    created three components: `WelcomeHeader`, `WelcomeContent`, and `WelcomeFooter`.
    If you wish, you can extend them to be more complex than a trivial piece of text:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We should connect `AppLayout` with our placeholder components. Create the `WelcomeScreen`
    component, which will pass placeholder components (from *step 2*) down to the `AppLayout`
    as props:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The last step is going to be creating the root component for our app and adding
    some styles:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Please note the use of `StyleSheet.create({...})`. This creates a style object
    that represents our app styles. In this case, we have created four different styles
    (`container`, `layoutHeader`, `layoutContent`, and `layoutFooter`) that will be
    available to use with the markup we defined. We previously customized styles using
    keys such as `width`, `height`, and `backgroundColor`, which are trivial. In this
    example, however, we also use `flex`, which comes from the term **flexbox pattern**.
    We will explain this approach in detail in [Chapter 3](3045eaef-f5e9-4096-accb-c7d61fc5a9c0.xhtml), *Style
    Patterns*,  where we focus primarily on `StyleSheet` patterns.
  prefs: []
  type: TYPE_NORMAL
- en: This is pretty good. We have made a trivial layout for our application and then
    created the welcome screen with it.
  prefs: []
  type: TYPE_NORMAL
- en: What about component inheritance?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"At Facebook, we use React in thousands of components, and we haven''t found
    any use cases where we would recommend creating component inheritance hierarchies."
    - React official documentation ([https://reactjs.org/docs/composition-vs-inheritance.html](https://reactjs.org/docs/composition-vs-inheritance.html))'
  prefs: []
  type: TYPE_NORMAL
- en: I have not come across a situation where I had to step away from component composition
    in favor of inheritance. Neither have developers at Facebook (as per the preceding
    quotation). Hence, I highly recommend you get used to composition.
  prefs: []
  type: TYPE_NORMAL
- en: Testing components on high-level patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Testing is something very important when it comes to creating reliable and
    stable applications. First of all, let''s look at the most common three types
    of tests you will need to write:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Trivial unit tests**: I don''t understand it, but is it working or not working
    at all? Usually, tests that check whether the component renders or whether the
    function runs with no errors are called trivial unit tests. If you do this manually,
    you call these tests smoke tests. Such tests are vital to have. Whether you like
    it or not, you should write trivial tests, at least to know if every feature is
    *somehow* working.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Unit tests**: Does the code work as I expect it to? Does it work in all of
    the code branches? By branch, we mean places in the code where it branches, for
    instance, if statements are branching code into different code paths, which is
    similar to switch-case statements. Unit testing refers to testing a single unit
    of code. In crucial features of an application, unit tests should cover whole
    function code (as a principle: 100% code coverage for crucial features).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Snapshot tests**: Testing if the previous and actual version produce the
    same result is called snapshot testing. Snapshot tests are just creating text
    output, but once the output is proven to be correct (through developer assessment
    and code review), it may work as a comparison tool. Try to use snapshot tests
    a lot. Such tests should be committed into your repository and undergo review
    process. This new feature in Jest saves a lot of time for developers:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Image snapshot tests:** In Jest, snapshot tests compare text (JSON to JSON),
    however, you may encounter references to snapshot tests on mobile devices, where
    this means comparing images to images. This is a more advanced topic, but is commonly
    used by big websites. Taking such a screenshot most likely requires building the
    whole app instead of a single component. Building the whole app is time-consuming,
    so some companies only run these type of tests when they plan for a release, for
    instance, on a release candidate build. This strategy can be automated to follow
    *continuous integration* and *continuous delivery* principles.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since we are using the CRNA toolbox in this book, the testing solution you want
    to check is Jest ([https://facebook.github.io/jest/](https://facebook.github.io/jest/)).
  prefs: []
  type: TYPE_NORMAL
- en: Watch out if you come from a React web development background. React Native,
    as the name suggests, operates in a native environment and hence has many components,
    such as react-native-video package, which may need special testing solutions.
    In many cases, you will need to mock (create placeholders/mimic behaviour) these
    packages.
  prefs: []
  type: TYPE_NORMAL
- en: Check out [https://facebook.github.io/jest/docs/en/tutorial-react-native.html#mock-native-modules-using-jestmock](https://facebook.github.io/jest/docs/en/tutorial-react-native.html#mock-native-modules-using-jestmock) for
    more information.
  prefs: []
  type: TYPE_NORMAL
- en: We will address some of these concerns in [Chapter 10](02308da0-7093-4573-97b0-30d147b28cc2.xhtml),
    *Managing Dependencies*.
  prefs: []
  type: TYPE_NORMAL
- en: There are usually some metrics to testing, such as code coverage (the number
    of lines covered by tests), the number of reported bugs, and the number of registered
    errors.
  prefs: []
  type: TYPE_NORMAL
- en: Although very valuable, these may create a false belief that the application
    is well-tested.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few utterly wrong practices that I need to mention when it comes
    to testing patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Relying only on unit tests**:Unit tests mean testing just a single piece
    of code in isolation, for instance, a function by passing arguments to it and
    checking the output. This is great and saves you from a lot of bugs, but no matter
    what code coverage you have, you may bump into problems with the integration of
    well-tested components. The real-life example I like to use is a video of two
    sliding doors that are placed too close to each other, which causes them to keep
    on opening and closing forever.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Relying on code coverage too much**:Stop stressing yourself or other developers
    to reach that 100% or 90% code coverage mark. If you can afford it, great, but
    usually it makes developers write less valuable tests. Sometimes, it is crucial
    to send different integer values to functions; for instance, when testing division,
    it is not enough to send two positive integers. You need to also check what happens
    when you divide by zero. Coverage won''t tell you that.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Not tracking how your testing metrics influence the number of bugs**: If
    you just rely on some metrics, whether it be code coverage or any other, please
    reassess if the metrics tell the truth, for instance, whether increase in the
    metric causes less bugs. To give you a nice example, I''ve heard developers from
    many different companies say that the code coverage increasing above 80% didn''t
    help them much.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are a product owner and have checked the point *Not tracking how your
    testing metrics influence the number of bugs* above, please also consult with
    the tech leader or senior developers of your project. There may be certain specifics
    that influence this process, for instance, development schedule shifting to more
    repeatable code. Please don't jump to conclusions too quickly.
  prefs: []
  type: TYPE_NORMAL
- en: Snapshot testing expandable components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This time, we will demonstrate a tricky part of snapshot testing.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by creating our first snapshot test. Go to `Chapter_1/Example 4_Stateful_expandable_component`and
    run `yarn test` in the command line. You should see that one test passes. What
    kind of test is it? It's a trivial unit test that's located in the `App.test.js` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s time to create our first snapshot test. Replace `expect(rendered).toBeTruthy();`
    with `expect(rendered).toMatchSnapshot();`. It should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Once you have this, rerun `yarn test`. A new directory called ` __snapshots__`
    should be created with the `App.test.js.snap` file inside it. Take a look at its
    contents. This is your first snapshot.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s time to test the app''s coverage. You can do this with the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'It yields something a little concerning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We have one component that has one branch (`if`), and after performing a snapshot
    test, the coverage is not even near 100%. What's wrong?
  prefs: []
  type: TYPE_NORMAL
- en: 'There is obviously a problem with the branch that relies on state, but would
    it account for over 30% of the lines? Let''s see the full report. Open the `./coverage/lcov-report/App.js.html` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/a30aada2-a239-4b49-be3f-6d5d3530d170.png)'
  prefs: []
  type: TYPE_IMG
- en: The coverage report file. You can see that the code has been uncovered with
    the tests marked in red.
  prefs: []
  type: TYPE_NORMAL
- en: Now, you see what is wrong. The answer is pretty simple—snapshot tests do not
    test prop functions. Why? First of all, this does not make much sense. Why would
    we convert a function to JSON, and how would it help? Secondly, tell me how to
    serialize the function. Shall I return function code as text or compute output
    in some other way?
  prefs: []
  type: TYPE_NORMAL
- en: Take this example as a lesson that **snapshot tests are not enough**.
  prefs: []
  type: TYPE_NORMAL
- en: Test-driven development approach
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You will often hear about the **test-driven development** (**TDD**) approach,
    which basically means writing tests first. To simplify this, let''s summarize
    this in the following three steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Write tests and watch them fail.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement functionality until you see your tests passing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Refactor to the best practices (optional).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: I must admit that I really love this approach. However, the truth is that most
    developers will glorify this approach and barely any will use it. This is usually
    because it's time-consuming and it is hard to predict what the thing you are about
    to test looks like.
  prefs: []
  type: TYPE_NORMAL
- en: Going further, you will find that one of the test types is against TDD. Snapshot
    tests can only be created if the component is implemented, as they rely on its
    structure. This is another reason why snapshot tests are more of an addition to
    your tests rather than a replacement.
  prefs: []
  type: TYPE_NORMAL
- en: This approach works best in huge applications that go on for years, where a
    team of tech architects plan the interfaces and patterns to be used. This is most
    likely in backend projects, and you will have a general idea of how all of the
    classes and patterns connect to each other. Then, you simply take the interface
    and write the tests. Next, you follow up with implementation. If you want to create
    interfaces in React Native, you will need to support TypeScript.
  prefs: []
  type: TYPE_NORMAL
- en: Some argue that TDD is great in small projects, and you may quickly find such
    threads on Stack Overflow. Don't get me wrong; I'm happy that some people are
    happy. However, small projects tend to be very unstable and are likely to change
    often. If you are building a **Minimum Viable Product (MVP)**, it doesn't work
    very well with TDD. You are better off relying on the fact that the libraries
    you use are well-tested and deliver the project on time, while quickly testing
    it with snapshots.
  prefs: []
  type: TYPE_NORMAL
- en: 'To summarize: abandoning TDD should not mean writing less tests.'
  prefs: []
  type: TYPE_NORMAL
- en: Presentational components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s time to learn how to make components reusable. For this goal, we will
    use the best tool in our hands: the **presentational component** pattern. It decouples
    components from logic and makes them flexible.'
  prefs: []
  type: TYPE_NORMAL
- en: The presentational component is a pattern name that you will hear very often,
    if, later on, you decide to use the Redux library. For instance, presentational
    components are heavily used in Dan Abramov's Redux course.
  prefs: []
  type: TYPE_NORMAL
- en: 'I like to explain that the presentational component pattern is a website''s
    world. For a long time now, there has been three leading blocks for every website:
    CSS, HTML, and JavaScript. React, however, introduced a bit of a different approach,
    that is, the automated generation of HTML based on JavaScript. HTML became virtual.
    Hence, you may have heard of the **Virtual Document Object Model** (**Virtual
    DOM**). This separation of concerns—HTML (view), CSS (styles), and JavaScript
    (logic, sometimes called the controller)—should remain untouched in our JavaScript-only
    world. Therefore, use presentational components to mimic HTML and container components
    for logic.'
  prefs: []
  type: TYPE_NORMAL
- en: Approach this problem in the same fashion in React Native applications. The
    markup you write should be separated from the logic it consumes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see this in action. Do you remember `Example 4_Stateful expandable component`?
    It has one presentational component already:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This component does not introduce any logic and contains only markup, which
    is very short in this case. Any logic that can be useful is hidden within props
    and passed along, as this component does not need to consume it. In more complex
    examples, you may need to destructure props to pass them to the right components;
    for example, when using the spread operator above, all props that are not destructured
    are being passed.
  prefs: []
  type: TYPE_NORMAL
- en: 'But, instead of focusing on this simple example, let''s start refactoring the
    `App` component. First of all, we will move the markup to the separate presentational
    component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to replace the `render` function in the `App` component with the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: However, if you run the code now, you will end up with an error on the `HelloText` press
    event. This is due to how JavaScript handles the `this` keyword. In this refactor,
    we pass the `expandOrCollapse` function to another object, and there, `this` refers
    to a completely different object. Therefore, it cannot access state.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few solutions to this problem, and one is by using the arrow function.
    I will stick to the best approach performance-wise. It comes down to adding the
    following line to your constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: There we go; the application is fully functional, just as before. We have refactored
    one component into two—one presentational and one responsible for logic. Sweet.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine that we had only shallow unit tests of two components.
  prefs: []
  type: TYPE_NORMAL
- en: Would we identify the problem with the `this` keyword?
  prefs: []
  type: TYPE_NORMAL
- en: Perhaps not. This simple gotcha may catch you in big projects, where you will
    be too busy to rethink every single component. Watch out and remember **integration
    tests**.
  prefs: []
  type: TYPE_NORMAL
- en: Decoupling styles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding examples, you may have noticed that styles are tightly coupled
    to presentational components. Why tightly? Because we explicitly include them
    by using `style={styles.container}`*, *but the `styles` object is not configurable.
    We cannot replace any style part with props, and that tightly couples us to the
    existing implementation. In some cases, this is a desired behavior, but in others,
    it is not.
  prefs: []
  type: TYPE_NORMAL
- en: If you are interested in how styles work, we will deep dive into patterns involving
    them in  [Chapter 3](3045eaef-f5e9-4096-accb-c7d61fc5a9c0.xhtml), *Styling Patterns*.
    You will also learn about the flexbox pattern from CSS and many other conventions.
  prefs: []
  type: TYPE_NORMAL
- en: You will bump into this problem if you have tried to split code into separate
    files. How can we fix this issue?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let the styles be the optional prop. If styles are not provided, then we can
    fall back to the default values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Notice the use of the `||` operator. In the preceding example (`expandedTextStyles
    || styles.text`), it first checks if `expandedTextStyles` is defined and if so
    returns that value. If `expandedTextStyles` is undefined, then it return `styles.text`,
    which is a default style object that was hard-coded by us.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if we wish, in some places, we can override our styles by passing respective
    props:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This is how we split markup, styles, and logic. Remember to use presentational
    components as often as possible to make your features truly reusable across many
    screens/views.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you come from a backend background, you may quickly jump into assumptions
    that it is just like the **MVC pattern**: **Model**, **View**, and **Controller**.
    It is not necessarily 1:1 relation, but in general, you may simplify it to the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**View**: This is a presentational component.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Model**: This is a data representation, which in our case is the state that
    is built either in a stateful component or using so-called store and reducers
    (check [Chapter 5](ede13e51-3070-4b51-998b-80a2628af2d4.xhtml), *Store Patterns*,
    to learn more details about what Redux is and how to use it).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Controller**: This is a container component that is responsible for application
    logic, including event handlers and services. It should be lean and import logic
    from the respective files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Container component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The container component pattern was introduced a long time ago and was popularized
    within the React community by Dan Abramov. So far, we have created one container
    component when we refactored the contents of the App component to become a *presentational
    component*. It turns out that the `App` component became a container component—it
    contains the `HelloBox` component and implements the necessary logic for it. What
    did we gain from this approach?  We gained the following:'
  prefs: []
  type: TYPE_NORMAL
- en: We can implement expanding and collapsing in a different way and reuse the markup
    of the `HelloBox` component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HelloBox` does not contain logic'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The container component encapsulates logic and hides it from the other components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I highly recommend reading Dan Abramov's medium post on this. Check out [https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0](https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0) for
    more information. Container components are very useful tools when it comes to
    dependency injection patterns. Have a look at [Chapter 10](02308da0-7093-4573-97b0-30d147b28cc2.xhtml),
    *Managing Dependencies*, to learn more.
  prefs: []
  type: TYPE_NORMAL
- en: HOC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The **HOC** is a pattern that exists to enhance components with additional
    props or functionality, for instance, if you want to make the component expandable.
    Instead of just creating a stateful container as we did previously, we could use
    the HOC pattern. Let''s refactor our stateful container component to a HOC and
    name it `makeExpandable`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The `makeExpandable` component accepts `ComponentToEnrich`. So, we can create
    a root component (`App`) like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Cool, isn''t it? Now, let''s create some other component and enrich it with
    our HOC. This will be a small button that displays the text hide or show. If the
    user presses the button, it should show or hide a small colored box. For this
    task, you can use the following styles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Place them within `StyleSheet.create({ ... })`. My solution is pretty straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the `SomeSection` component is wrapped by the `makeExpandable` HOC,
    and receives the `isExpanded` and `expandOrCollapse` props.
  prefs: []
  type: TYPE_NORMAL
- en: Great! We have just made a reusable HOC, and it is working flawlessly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, I will show you a rather unknown but sometimes useful technique to push
    your HOC to be even more flexible. Imagine that you are about to enhance a component
    that is strict about props naming, as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Unfortunately, our HOC, `makeExpandable`, is passing the wrong prop names.
    Let''s fix that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This is a tricky example. It provides a capability to rename props that are
    passed down by HOC. To rename it, we need to pass a configuration object called
    `propNames` to HOC. If such an object is passed, and it contains a certain key,
    then we override the name. If the key is not present, then we fall back to the
    default prop name, for instance, `isExpanded`.
  prefs: []
  type: TYPE_NORMAL
- en: Notice the use of `[]` inside of the object. It allows you to dynamically name
    keys in the object. In this example, the key was dynamically chosen based on the
    presence of `propNames`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make everything work, we also need to accept the optional argument `propNames`in
    the `makeExpandable` HOC:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Cool! Now our HOC is more flexible when it comes to prop names! We can use
    it with the aforementioned strict `SomeSection` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Beware of the performance implications when creating variables inside the `render`
    function. It will slow your application down. Sometimes, patterns can sacrifice
    performance a little and sometimes they cannot. Use them wisely. You could also
    the inline `propNames` variable as two props.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure to check the next section for a cleaner and decoupled approach.
  prefs: []
  type: TYPE_NORMAL
- en: HOC composition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The primary reason to create HOCs it to have the ability to compose the features
    they provide.
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at the problem from the previous section again. What if we could delegate
    work to another HOC? For instance, having a mapper HOC called `mapPropNames`,
    you can compose it with our previous HOC like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the implementation of `mapPropNames`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Nice and quick, isn't it? This is a common pattern and is also used when working
    with backend data sent as JSON. It may adapt the data format to our representation
    on the frontend layer. As you see, we can employ this great idea when working
    with HOCs as well!
  prefs: []
  type: TYPE_NORMAL
- en: If you come from an object-oriented background, please notice that the HOC pattern
    is very similar to the decorator pattern. The decorator, however, also relies
    on inheritance and needs to implement the interface that it decorates.
  prefs: []
  type: TYPE_NORMAL
- en: Please check [https://en.wikipedia.org/wiki/Decorator_pattern](https://en.wikipedia.org/wiki/Decorator_pattern)
    for examples.
  prefs: []
  type: TYPE_NORMAL
- en: You can also compose decorators. It works in a similar way.
  prefs: []
  type: TYPE_NORMAL
- en: Examples of useful HOCs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Do you need a quick logger that will show you how your app behaves? Or maybe
    you are preparing a live presentation and you want to show some dynamic information
    on a screen? Here we go:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Okay, good. Now, let''s suppose that you are waiting on some data to load.
    Here comes the spinner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'You might want to ask a user to five star your app. You need a modal to do
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Sometimes, modals should be intelligent enough to maintain their visibility,
    too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we enriched the component with `Modal`. `Modal` can be opened
    or closed using the props that are named `openModal` and `closeModal`. The information
    regarding whether the modal is opened or closed is stored within a private state
    of the HOC and, in this example, is not exposed to the original component. Nice
    separation, right? This HOC is also reusable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Time for your homework: how do we make `Modal` open along with the box show?
    You cannot change `SomeComponent`.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you have learned how to create basic components with React
    in the React Native environment. Now, you should be fairly comfortable with stateless
    and stateful components. In addition, you learned about presentational and container
    components. You know that these patterns serve to decouple markup and logic. You
    have also learned how to enhance component features by using HOCs. Hopefully,
    you have also played with the ready-to-run examples that I collected for you in
    the Git repository.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 2](89d7ff7d-4e5b-4f17-b8f7-8d9b3574d197.xhtml), *View Patterns*,
    we will focus more on the markup. You will also learn about a handful of tags
    that you can use.
  prefs: []
  type: TYPE_NORMAL
