- en: Day 06 - Deep Dive with Advanced Concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Today is day six of our seven-day learning series. On day five, we discussed
    important concepts of the C# language and went through reflection, collections,
    delegates, and events. We explored these concepts using a code snippet, where
    we discussed non-generic collections. Today, we will discuss the main power of
    collections using generic types, and then, we will cover preprocessor directives
    and attributes.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Playing with collections and generics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Beautifying code using attributes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leveraging Preprocessor Directives
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting started with LINQ
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing unsafe code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing asynchronous code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Revisiting Day 6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hands-on exercise
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Playing with collections and generics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Collections are not new for us, as we went through and discussed non-generic
    collections on day five. So, we also have generic collections. In this section,
    we will discuss all about collections and generics with the use of code examples.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding collection classes and their usage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As discussed on day five, collection classes are specialized classes and are
    meant for data interaction (storage and retrieval). We have already discussed
    various collection classes, namely
  prefs: []
  type: TYPE_NORMAL
- en: 'stacks, queues, lists, and hash tables, and we have written code using the
    `System.Collections.NonGeneric` namespace. The following table provides us an
    overview of the usage and meaning of non-generic collection classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Property** | **Description** | **Usage** |'
  prefs: []
  type: TYPE_TB
- en: '| `ArrayList` | The name itself describes that this contains a collection of
    ordered collection that can be accessed using index.We can declare `ArrayList`
    as follows: `ArrayList arrayList = new ArrayList();` | On day two, we discussed
    arrays and went through how to access the individual elements of an array. In
    the case of `ArrayList`, we can get the benefits of various methods to add or
    remove elements of collections, as discussed on day five. |'
  prefs: []
  type: TYPE_TB
- en: '| `HashTable` | `HashTable` is nothing but a representation of collections
    of a key-value-pair and are organized on the basis of a key, which is nothing
    more than a hash code. The use of `HashTable` is advisable when we need to access
    data on the basis of a key.We can declare `HashTable` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Hashtable hashtable = new Hashtable();` | `HashTable` is very useful when
    we need to access elements with the use of a key. In such scenarios, we have a
    key and need to find values in the collection on the basis of a key. |'
  prefs: []
  type: TYPE_NORMAL
- en: '| `SortedList` | The `SortedList` class is nothing but a representation of
    collections of a key-value-pair and are organized on the basis of a key and are
    sorted by key. `SortedList` classes are a combination of `ArrayList` and `HashTable`.
    So, we can access the elements using the key or the index.We can declare `SortedList`
    as follows: `SortedList sortedList = new SortedList();` | As stated, a sorted
    list is a combination of an array and a hash table.Items can be accessed using
    a key or an index. This is `ArrayList` when items are accessed using an index;
    on the other hand, it is `HashTable` when items are accessed using a hash key.
    The main thing in `SortedList` is that the collection of items is always sorted
    by the key value. |'
  prefs: []
  type: TYPE_TB
- en: '| `Stack` | Stack represents a collection of objects; the objects are accessible
    in the order of **Last In First Out** (**LIFO**).It contains two main operations:
    push and pop. Whenever we insert an item to the list, it is called pushing, and
    when we extract/remove an item from the list, it is called popping. When we get
    an object without removing the item from the list, it is called peeking.We can
    declare it as follows: `Stack stackList = new Stack();` | This is important to
    use when items that were inserted last need to be retrieved first. |'
  prefs: []
  type: TYPE_TB
- en: '| `Queue` | Queue represents a **First In First Out**(**FIFO**) collection
    of objects.There are two main actions in queue--adding an item is called enqueue
    and removing an item is called deque.We can declare a Queue as follows: `Queue
    queue = new Queue();` | This is important when items that were inserted first
    need to be retrieved first. |'
  prefs: []
  type: TYPE_TB
- en: '| `BitArray` | `BitArray` is nothing but an array that manages an array of
    bit values. These values are represented as Boolean. True means *ON* (1) and False
    means *OFF*(0).We can declare `BitArray` as follows: `BitArray bitArray = new
    BitArray(8);` | This non-generic collection class is important when we need to
    store the bits. |'
  prefs: []
  type: TYPE_TB
- en: The preceding table only shows non-generic collection classes. With the use
    of generics, we can also implement generic collection classes by taking the help
    of the `System.Collections` namespace. In the coming sections, we will discuss
    generic collection classes.
  prefs: []
  type: TYPE_NORMAL
- en: Performance - BitArray versus boolArray
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous table, we discussed that `BitArray` is just an array that manages
    true or false values (*0* or *1*). But internally, `BitArray` performed round
    eight per element for a Byte and undergoes in various logical operations and need
    more CPU cycles. On the other hand, a `boolArray` (`bool[]`) stores each element
    as 1-byte, so it takes more memory but requires fewer CPU cycles. `BitArray` over
    `bool[]` is memory optimizer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider the following performance test and see how `BitArray` performs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: On my machine, `BitArrayTest` took six seconds and `BoolArrayTest` took 15 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: From the preceding tests we can conclude that bool arrays consume eight times
    the size/space that could represent the values. In simpler words, bool arrays
    require 1 byte per element.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding generics and their usage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In simple words, with the help of generics, we can create or write code for
    a class that is meant to accept different data types for which it is written.
    Let''s say if a generic class is written in a way to accept a structure, then
    it will accept int, string, or custom structures. This class is also known as
    a generic class. This works more magically when it allows us to define the data
    type when we declare an instance of this generic class. Let''s study the following
    code snippet, where we define a generic class and provide data types on the creation
    of its instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We will get the following output after running the preceding code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00085.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can create a generic list to a strongly typed list, which can accept types
    other than `Person`. For this, we just need to create a list like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Collections and generics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: On day two, you learned about arrays of a fixed size. You can use fixed-size
    arrays for strongly typed list objects. But what if we want to use or organize
    these objects into other data structures, such as queue, list, stack, and so on?
    We can achieve all these with the use of collections (`System.Collections`).
  prefs: []
  type: TYPE_NORMAL
- en: '`System.Collections` ([https://www.nuget.org/packages/System.Collections/](https://www.nuget.org/packages/System.Collections/)
    ) is a NuGet package that provides all the generic types, and the following are
    the frequently used types:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Generic collection types** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `System.Collections.Generic.List<T>` | A strongly typed generic list |'
  prefs: []
  type: TYPE_TB
- en: '| `System.Collections.Generic.Dictionary<TKey, TValue>` | A strongly typed
    generic dictionary with a key-value pair |'
  prefs: []
  type: TYPE_TB
- en: '| `System.Collections.Generic.Queue<T>` | A generic `Queue` |'
  prefs: []
  type: TYPE_TB
- en: '| `System.Collections.Generic.Stack<T>` | A generic `Stack` |'
  prefs: []
  type: TYPE_TB
- en: '| `System.Collections.Generic.HashSet<T>` | A generic `HashSet` |'
  prefs: []
  type: TYPE_TB
- en: '| `System.Collections.Generic.LinkedList<T>` | A generic `LinkedList` |'
  prefs: []
  type: TYPE_TB
- en: '| `System.Collections.Generic.SortedDictionary<TKey, TValue>` | A generic `SortedDictionary`
    with a key-value pair collection and sorted on key. |'
  prefs: []
  type: TYPE_TB
- en: The preceding table is just an overview of generic classes of the `System.Collections.Generics`
    namespace. In the coming sections, we will discuss generic collections in detail
    with the help of code examples.
  prefs: []
  type: TYPE_NORMAL
- en: For a complete list of classes, structures, and interfaces of the `System.Collections.Generics`
    namespace, visit the official documentations link at [https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic?view=netcore-2.0](https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic?view=netcore-2.0).
  prefs: []
  type: TYPE_NORMAL
- en: Why should we use generics?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For non-generic lists, we use collections from the universal base of the object
    type [[https://docs.microsoft.com/en-us/dotnet/api/system.object](https://docs.microsoft.com/en-us/dotnet/api/system.object)],
    which is not type-safe at compile time. Let''s assume that we are using a non-generic
    collection of `ArrayList;` see the following code snippet for more details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have an `ArrayList` with string values. Here, we have the age as a
    string which actually should be int. Let''s take another ArrayList, which has
    the age as an int:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, our code compiles, but it will throw an exception of typecast
    at runtime. So, our `ArrayList` does not have compile-time type checking:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00086.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: After digging through the preceding code, we can easily understand why there
    is no error at compile time; this is because, `ArrayList` accepts any type (both
    value and reference) and then casts it to a universal base type of .NET, which
    is nothing but object. But when we run the code at that time, it requires the
    actual type, for example, if it is defined as string, then it should be of the
    string type at runtime and not of the object type. Hence, we get a runtime exception.
  prefs: []
  type: TYPE_NORMAL
- en: The activity of casting, boxing, and unboxing of an object in `ArrayList` hits
    the performance, and it depends upon the size of `ArrayList` and how large the
    data that you're iterating through is.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the help of the preceding code example, we came to know two drawbacks
    of a non-generic `ArrayList`:'
  prefs: []
  type: TYPE_NORMAL
- en: It is not compile-time type-safe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Impacts the performance while dealing with large data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`ArrayList` casts everything to object, so there is no way to stop adding any
    type of items at compile time. For example, in the preceding code snippet, we
    can enter int and/or string type items.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To overcome such issues/drawbacks, we have generic collections, which prevent
    us from supplying anything other than the expected type. Consider the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We have a `List`, which is defined to get only string type items. So, we can
    add only string type values here. Now consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we''re trying to supply an item of the int type (remember that we did
    the same thing in the case of `ArrayList`). Now, we get a compile-time error that
    is related to casting, so a generic list that is defined to accept only string
    type items has the capability to stop the client from entering items of any type
    other than string. If we hover the mouse on the `43`, it shows the complete error;
    refer to the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00087.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding code snippet, we resolved our one problem by declaring a list
    of string, which only allows us to enter string values, so in the case of authors,
    we can only enter author names but not author age. You may be thinking that if
    we need another list of type int that provides us a way to enter the author''s
    age, that is, if we need a separate list for a new type, then why should we use
    generic collections? At the moment, we need only two items--name and age--so we
    are creating two different lists of the string and int type on this node. If we
    need another item of a different type, then will we be going for another new list.
    This is the time when we have things of multiple types, such as string, int, decimal,
    and so on. We can create our own types. Consider the following declaration of
    a generic list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We have a `List` of type `Person`. This generic list will allow all types of
    items that are defined in this type. The following is our `Person` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `Person` class contains three properties, two of type string and one is
    of type int. Here, we have a complete solution for the problems we discussed in
    the previous section. With the help of this List, which is of the `Person` type,
    we can enter an item of the string and/or int type. The following code snippet
    shows this in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'After running this code, the following will be our output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00088.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Our `List` of the `Person` type will be more performant than `ArrayList`, as
    in our generic class, there is not implicit typecast to object; the items are
    rather of their expected types.
  prefs: []
  type: TYPE_NORMAL
- en: Discussing constraints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous section, we discussed how a `List` of the `Person` type accepts
    all the items of their defined types. In our example code, we only use the string
    and int data types, but in generics, you can use any data type, including int,
    float, double, and so on. On the other hand, there may be scenarios where we want
    to restrict our use to a few data types or only a specific data type in generics.
    To achieve this, there are generic constraints. Consider the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Here, our class is a generic class. GenericConstraint, of type `T`, which is
    nothing but a reference type; hence, we created this class to accept only the
    reference type. No value type will be accepted by this class. This class has an
    `ImplementIt` method, which accepts a parameter of type `T` and returns a value
    of type `T`.
  prefs: []
  type: TYPE_NORMAL
- en: Check [https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/generics/generic-type-parameters](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/generics/generic-type-parameters)
    to know more about Generic Type Parameter Guidelines.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following declarations are valid as these are of the reference types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is an invalid declaration, as this is of the value type, which
    is not meant for the current generic class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'On day two, we learned that int is a value type and not a reference type. The
    preceding declaration gives a compile-time error. In Visual Studio, you will see
    the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00089.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: So, with the help of generic constraints, we restrict our class to not accept
    any types other than reference types.
  prefs: []
  type: TYPE_NORMAL
- en: '**Constraints** are basically an act by which you safeguard your generic class
    to prevent the client from using any other type while the class is instantiated.
    It results in a compile-time error if the client code tries to provide a type
    that is not allowed. The contextual where keyword helps us in defining constraints.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the real world, you can define various type of constraints and these would
    restrict client code to create any unwanted situation. Let''s discuss these types
    with examples:'
  prefs: []
  type: TYPE_NORMAL
- en: The value type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This constraint is defined with the contextual keyword, `where T: struct`.
    With this constraint, the client''s code should contain an argument of the value
    type; here, any value except Nullable can be specified.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Example**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a code snippet declaring a generic class with a value type
    constraint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '**Usage**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a code snippet that describes the client code of a generic
    class declared with a value type constraint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The reference type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This constraint is defined with the contextual keyword, `where T:class`. Using
    this constraint, the client code is bound to not provide any types other than
    reference types. Valid types are class, interface, delegate, and array.
  prefs: []
  type: TYPE_NORMAL
- en: '**Example**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet declares a generic class with a reference type constraint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '**Usage**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet describes the client code of a generic class declared
    with a reference type constraint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The default constructor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This constraint is defined with the contextual keyword, `where T: new()`, and
    it restricts generic type parameters from defining default constructors. It is
    also compulsory that an argument of type `T` must have a public parameterless
    constructor. The `new()` constraint must be specified in the end, when used with
    other constraints.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Example**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet declares a generic class with a default constructor
    constraint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '**Usage**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet describes the client code of a generic class declared
    with a default constructor constraint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The base class constraint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This constraint is defined with the contextual keyword, `where T: <BaseClass>`.
    This constraint restricts all the client code where the supplied arguments are
    not of, or not derived from, the specified base class.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Example**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet declares a generic class with the base class constraint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '**Usage**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a code snippet describes the client code of a generic class
    declared with a base class constraint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The interface constraint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This constraint is defined with the contextual keyword, `where T:<interface
    name>`. The client code must supply a parameter of the type that implements the
    specified parameter. There may be multiple interfaces defined in this constraint.
  prefs: []
  type: TYPE_NORMAL
- en: '**Example**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet declares a generic class with an interface constraint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '**Usage**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet describes the client code of a generic class declared
    with the interface constraint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In this section, we discussed generics and collections, including the various
    types of generics, and we also mentioned why we should use generics.
  prefs: []
  type: TYPE_NORMAL
- en: For more details on generics, visit the official documentation at [https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/generics/](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/generics/).
  prefs: []
  type: TYPE_NORMAL
- en: Beautifying code using attributes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Attributes provide a way to associate information with code. This information
    could be as simple as a message/warning or can contain a complex operation or
    code itself. These are declared simply with the help of tags. These also help
    us to beautify our code by supplying inbuilt or custom attributes. Consider the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'In this method, we show an informational message to notify the peer. The preceding
    method will be decorated with the help of an attribute. Consider the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can see that we just decorated our method with the help of an attribute.
  prefs: []
  type: TYPE_NORMAL
- en: According to the official documentation [[https://docs.microsoft.com/en-us/dotnet/csharp/tutorials/attributes](https://docs.microsoft.com/en-us/dotnet/csharp/tutorials/attributes)],
    attributes provide a way of associating information with code in a declarative
    way. They can also provide a reusable element that can be applied to a variety
    of targets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Attributes can be used for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: To add meta data information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To add comments, description, compiler instructions, and so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the coming sections, we will discuss attributes in detail, with code examples.
  prefs: []
  type: TYPE_NORMAL
- en: Types of attributes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we discussed attributes, which help us to decorate
    and beautify our code. In this section, we will discuss the various types of attributes
    in detail.
  prefs: []
  type: TYPE_NORMAL
- en: AttributeUsage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is a pre-defined attribute in a framework. This restricts the usage of
    attributes; in other words, it tells the type of items on which an attribute can
    be used, also known as attribute targets. These can be all or one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Assembly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constructor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delegate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enum
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Event
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Field
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GenericParameter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parameter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Property
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ReturnValue
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Struct
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By default, attributes are of any type of targets, unless you specify explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: '**Example**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following attribute is created to be used only for a class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'In preceding code, we defined attributes for the only use with class. If you
    try to use this attribute to other than class, then it will give you a compile-time
    error. See the following image, which shows an error for an attribute on method
    that is actually written solely for a class:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00090.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Obsolete
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There may be circumstances when you want to raise a warning for a specific code
    so that it is conveyed on the client side. The `Obsolete` attribute is a predefined
    attribute that does the same and warns the calling user that a specific part is
    `obsolete`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Example**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The following image shows a warning message saying not to use the `Author`
    class, as it is `Obsolete`. But the client can still compile and run the code
    (we did not ask this attribute to throw error on usage):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00091.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following will throw an error message on usage along with the warning message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Consider the following image, where the user gets an exception after using
    the attribute, which is written to throw an error on usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00092.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Conditional
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The conditional attribute that is a predefined attribute, restricts the execution
    on the basis of condition applied to the code that is being processed.
  prefs: []
  type: TYPE_NORMAL
- en: '**Example**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code snippet, which restricts the conditional execution
    of a method for a defined debug preprocessor (we will discuss preprocessors in
    detail in the coming section):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Remember one thing while defining preprocessor symbols; you define it on the
    very first line of the file.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and implementing a custom attribute
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we discussed the available or predefined attributes
    and we noticed that these are very limited, and in a real-world application, our
    requirements will demand more complex attributes. In such a case, we can create
    our own custom attributes; these attributes are similar to predefined attributes
    but with our custom operational code and target types. All custom attributes should
    be inherited from the `System.Attribute` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will create a simple custom attribute as per the following
    requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an `ErrorLogger` attribute
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This attribute will handle all the available environments, that is, debug, development,
    production, and so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This method should be restricted only for methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It should show custom or supplied exception/exception messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By default, it should consider the environment as `DEBUG`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It should show and throw exceptions if decorated for the development and `DEBUG`
    environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prerequisites
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create and run custom attributes, we should have the following prerequisites:'
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio 2017 or later
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: .NET Core 1.1 or later
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here is the code snippet that creates our expected attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we simply write to console whatever exceptions are supplied
    from the client code. In the case of the `DEBUG` or `Dev` environment, the exception
    is thrown further.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet shows the simple usage of this attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have different methods that are marked for different
    environments. Out attributes will trigger and write the exceptions supplied for
    individual methods.
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging preprocessor directives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As is clear from the name, preprocessor directives are the processes undertaken
    before the actual compilation starts. In other words, these preprocessors give
    instructions to the compiler to preprocess the information, and this works before
    the compiler compiles the code.
  prefs: []
  type: TYPE_NORMAL
- en: Important points
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are the following points to note for preprocessors while you''re working
    with them:'
  prefs: []
  type: TYPE_NORMAL
- en: Preprocessor directives are actually conditions for the compiler
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preprocessor directives must start with the `#` symbol
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preprocessor directives should not be terminated with a semi colon (`;`) like
    a statement terminates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preprocessors are not used to create macros
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preprocessors should be declared line by line
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preprocessor directives in action
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Consider the following preprocessor directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This directive is a conditional directive, code executes whenever this directive
    is applied to the code, you can also use `#elseif` and/or `#else` directives.
    As this is a conditional directive and `#if` condition in C# is Boolean, these
    operators can be applied to check equality (`==`) and inequality (`!=`), and between
    multiple symbols, and (`&&`), or (`||`), and not (`!`) operators could also be
    applied to evaluate the condition.
  prefs: []
  type: TYPE_NORMAL
- en: You should define a symbol on the very first line of the file where it is being
    applied with the use of `#define`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code snippet, which lets us know the conditional compilation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00093.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '**#define and #undef**'
  prefs: []
  type: TYPE_NORMAL
- en: The `#define` directive basically defines a symbol for us that would be used
    in a conditional pre-processor directive.
  prefs: []
  type: TYPE_NORMAL
- en: '`#define` cannot be used to declare constant values.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following should be kept in mind while declaring a symbol with the use
    of `#define`:'
  prefs: []
  type: TYPE_NORMAL
- en: It cannot be used to declare constant
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can define a symbol but cannot assign a value to these symbols
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any instructions on the symbol should come after its definition of the symbol
    in the file that means `#define` directive always come before its usage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scope of the symbol defined or created with the help of `#define` directive
    is within the file where it is declared/defined
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Recall the code example we discussed in the `#if` directive where we defined
    two symbols. So, it''s very easy to define a symbol like: `#define DEBUG`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `#undef` directive lets us undefine the earlier defined symbol. This pre-processor
    should come before any non-directive statement. Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we are undefining the `DEBUG` symbol and the code will
    produce the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00094.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '**The #region and #endregion directives**'
  prefs: []
  type: TYPE_NORMAL
- en: 'These directives are very helpful while working with long code-based files.
    Sometimes, while we are working on a long code base, let''s say, an enterprise
    application, this kind of application will have 1000 lines of code and these lines
    will be part of different functions/methods or business logics. So, for better
    readability, we can manage these sections within the region. In a region, we can
    name and give short descriptions of the code that the region holds. Let''s consider
    the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00095.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding image, the left-hand side portion shows the expanded view of
    the `#region` ... `#endregion` directives, which tells us how we can apply these
    directives to our long code base files. The right-hand side of the image shows
    the collapsed view, and when you hover the mouse on the collapsed region text,
    you can see that a rectangular block appears in Visual Studio, which says what
    all these regions contain. So, you need not expand the region to check what code
    is written under this region.
  prefs: []
  type: TYPE_NORMAL
- en: '**The #line directive**'
  prefs: []
  type: TYPE_NORMAL
- en: The `#line` directive provides a way to modify the actual line number of compilers.
    You can also provide the output `FileName` for errors and warnings, which is optional.
    This directive may be useful in automated intermediate steps in the build process.
    In scenarios where the line numbers have been removed from the original source
    code, however you would require to generate the output based on the original file
    with numbering.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, the `#line` default directive returns the line numbering to its
    default value, and it counts a line where it was renumbered earlier.
  prefs: []
  type: TYPE_NORMAL
- en: The `#line` hidden directive does not affect the filename or line numbers in
    error reporting.
  prefs: []
  type: TYPE_NORMAL
- en: The `#line` filename directive profiles a way to name a file you want to appear
    in the compiler output. In this, the default value is the actual filename in use;
    you can provide a new name in double quotes, and this must be preceded by the
    line number.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '**The #warning directive**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `#warning` directive provides a way to generate a warning in any part of
    code and usually work within the conditional directives. Consider the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will warn at compile time, and the warning message will
    be what you provided with the `#warning` directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00096.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '**#error**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `#error` directive provides a way to generate an error in any part of code.
    Consider the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'This will throw an error, and due to this error your code will not be built
    properly; it fails the build with the error message that you provided with `#error`
    directive. Let''s have a look at the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00097.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In this section, we discussed all about preprocessor directives and their usage
    with code examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a complete reference of C# preprocessor directives, please refer to the
    official documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/preprocessor-directives/](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/preprocessor-directives/)'
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with LINQ
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: LINQ is nothing but an acronym of Language Integrated Query that is part of
    programming language. LINQ provides an easy way to write or query data with a
    specified syntax like we would use the where clause when trying to query data
    for some specific criteria. So, we can say that LINQ is a syntax that is used
    to query data.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will see a simple example to query data. We have `Person`
    list and the following code snippet provides us a various way to query data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00098.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Complete discussion of LINQ is beyond the scope of this book. For complete
    LINQ functionality refer to: [https://code.msdn.microsoft.com/101-LINQ-Samples-3fb9811b](https://code.msdn.microsoft.com/101-LINQ-Samples-3fb9811b)'
  prefs: []
  type: TYPE_NORMAL
- en: Writing unsafe code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will discuss introduction to how to write unsafe code using
    Visual Studio. Language C# provides a way to write code which compiles and creates
    the objects and these objects under the root are managed by the garbage collector
    [refer to [day 01](part0021.html#K0RQ0-cd07d0bec7404d1cb3fdb41e48e5618f) for more
    details on garbage collector]. In simple words, C# is not like C, C++ language
    which use concept of function pointer to access references. But there is a situation
    when it is necessary to use function-pointers in C# language similar to languages
    that support function-pointers like C or C++ but C# language does not support
    it. To overcome such situations, we have unsafe code in C# language. There is
    modifier unsafe which tells that this code is not controlled by Garbage collector
    and within that block we can use function pointers and other unsafe stuffs. To
    use unsafe code, we first inform compiler to set on unsafe compilation from Visual
    Studio 2017 or later just go to project properties and on Build tab, select the
    option Allow unsafe code, refer following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00099.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'You would not be able to continue with unsafe code if this option is not selected,
    please refer following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00100.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'After setting unsafe compilation, let''s write code to swap two numbers using
    pointers, consider the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Previous is a very simple swap function which is just swapping two numbers
    with the help of pointers. Let''s make a call to this function to see the actual
    results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code snippet, we are taking input of two numbers and then
    showing the results before and after swaps, this produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00101.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In this section, we have discussed how to deal with unsafe code.
  prefs: []
  type: TYPE_NORMAL
- en: 'For more details on unsafe code, refer to official documentations of language
    specifications: [https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/unsafe-code](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/unsafe-code)'
  prefs: []
  type: TYPE_NORMAL
- en: Writing asynchronous code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we discuss the code in async way, lets first discuss our normal code
    that is nothing but a synchronous code, let''s consider following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code snippet is short and sweet. It tells us it is polling to
    a specific file. Here system has to wait to complete the operation of poling a
    file before it start next. This is what synchronous code is. Now, consider a scenario
    where we need not wait to complete the operation of this function to start another
    operation or function. To meet such scenarios, we have asynchronous coding, this
    is possible with the keyword, async.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Just with the help of the `async` keyword our code is able to make asynchronous
    calls.
  prefs: []
  type: TYPE_NORMAL
- en: In the view of previous code we can say that asynchronous programming is one
    that let not wait client code to execute another function or operation during
    any async operation. In simple word, we can say that asynchronous code can't hold
    another operation that need to be called.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we discussed asynchronous coding. A complete discussion on
    this topic is beyond the scope of our book. For complete details refer to official
    documentation: [https://docs.microsoft.com/en-us/dotnet/csharp/async](https://docs.microsoft.com/en-us/dotnet/csharp/async)'
  prefs: []
  type: TYPE_NORMAL
- en: Hands-on exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Define generic classes by creating generic code of `StringCalculator`: [https://github.com/garora/TDD-Katas/tree/develop/Src/cs/StringCalculator](https://github.com/garora/TDD-Katas/tree/develop/Src/cs/StringCalculator)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a generic and non-generic collection and test which one is better as
    per performance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have discussed code snippets in the section-*Why one should use Generics?*
    that tells about run-time compilation exceptions. In this regard, why should we
    not use the same code in the following way?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: What is the use of the `default` keyword in generic code, elaborate with the
    help of a real-world example.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write simple code by using all 3-types of predefined attributes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the default restriction type for an attribute? Write a program to showcase
    all restriction types.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a custom attribute with name - *LogFailuresAttribute* that log all exceptions
    in a text file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why pre-processor directive `#define` cannot be used to declare constant values?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a program to create a `List` of `Authors` and apply LINQ functionality
    on it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a program to sort an array
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a complete program to write a sync and async methods to write a file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Revisiting Day 6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Today, we discussed advanced concepts such as generics, attributes, preprocessors,
    LINQ, unsafe code, and asynchronous programming.
  prefs: []
  type: TYPE_NORMAL
- en: Our day started with generics, where you learned about generic classes with
    the help of code snippets. Then, we dived into attributes and learned how to decorate
    our C# code with predefined attributes. We have created one custom attribute and
    used it in our code example. We discussed preprocessor directives with complete
    examples and learned the usage of these directives in our coding. Other concepts
    discussed are LINQ, unsafe code, and asynchronous programming.
  prefs: []
  type: TYPE_NORMAL
- en: Tomorrow, that is, day seven will be the concluding day of our seven-day learning
    series. We will cover OOP concepts and their implementation in the C# language.
  prefs: []
  type: TYPE_NORMAL
