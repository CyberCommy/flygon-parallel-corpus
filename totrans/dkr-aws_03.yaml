- en: Getting Started with AWS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we discussed the various options you have for deploying
    your container applications to AWS, and it's now time to start implementing practical
    solutions using the Elastic Container Service (ECS), Fargate, Elastic Kubernetes
    Service (EKS), Elastic Beanstalk, and Docker Swarm. Before we can cover all of
    this exciting material, you need to establish an AWS account, understand how to
    set up access for your account, and ensure you have a solid grasp of the various
    tools we will use throughout this book to interact with AWS.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with AWS is very easy—AWS offers a free tier suite of services
    that enable you to test and try out a number of AWS services at no cost for 12
    months, or, in some cases, indefinitely. Of course, there are limitations imposed
    that ensure you can't set up your own Bitcoin mining services for free, but for
    the most part, you can leverage these free tier services to test a wide number
    of scenarios, including almost all of the material we will work through in this
    book. So, this chapter will start off with establishing a new AWS account, which
    will require you to have a valid credit card, just in case you do follow through
    on that great new Bitcoin mining venture.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have an account in place, the next step is to set up administrative
    access to your account. By default, all AWS accounts are created with a root user
    that has the highest level of account privileges, however AWS do not recommend
    using the root account for day-to-day administrative use. Therefore, we will configure
    the AWS Identity Access and Management (IAM) service, creating IAM users and groups,
    and learning how to implement enhanced security using multi-factor authentication
    (MFA).
  prefs: []
  type: TYPE_NORMAL
- en: With access to your AWS account established, we will then focus on the various
    tools that you can use to interact with AWS, including the AWS console that provides
    a web-based management interface that you access with your web browser, and the
    AWS CLI tool for interacting with AWS via the command line.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we will introduce a management service and toolset called AWS CloudFormation,
    which provides an infrastructure as code approach for defining your AWS infrastructure
    and services. CloudFormation allows you to define templates that enable you to
    build complete environments with the single click of a button, and do so in a
    repeatable and consistent fashion. We will be using CloudFormation extensively
    throughout this book, as in practice, most organizations that are deploying Docker-based
    applications are adopting infrastructure as code tooling such as CloudFormation,
    Ansible, or Terraform to automate the deployment of their Docker applications
    and supporting infrastructure. You will learn how to create a simple CloudFormation
    template and then deploy that template using both the AWS console and AWS CLI.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, the following topics will be covered:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up an AWS account
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logging in as the root account
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating IAM users, groups, and roles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an EC2 key pair
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing the AWS CLI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring credentials and profiles in the AWS CLI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interacting with AWS using the AWS CLI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing AWS CloudFormation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining a simple AWS CloudFormation template
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying an AWS CloudFormation stack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deleting an AWS CloudFormation stack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The technical requirements for this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Prerequisite software installed as per the instructions in Chapter 1, *Container
    and Docker Fundamentals*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A valid credit card is required to create a free AWS account in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following GitHub URL contains the code samples that are used in this chapter: [https://github.com/docker-in-aws/docker-in-aws/tree/master/ch3](https://github.com/docker-in-aws/docker-in-aws/tree/master/ch14)[.](https://github.com/docker-in-aws/docker-in-aws/tree/master/ch3)
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the Code in Action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://bit.ly/2N1nzJc](http://bit.ly/2N1nzJc)'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up an AWS account
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first step on your AWS journey is to establish an AWS account, which is
    a foundational building block of AWS that defines a security and administrative
    context for managing your AWS services and resources that you consume. To encourage
    adoption of AWS and ensure that first time users have an opportunity to try out
    AWS for free, AWS offers a free tier that grants you free access to some AWS services
    (with some limitations around usage). You can find out more about the free tier
    and what services are offered at [https://aws.amazon.com/free/](https://aws.amazon.com/free/).
    Make sure you have a good understanding of what you can and can't use for free
    to avoid an unnecessary bill shock.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this book, we will make use of a number of free tier services with the following
    monthly usage limits:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Service** | **Limit** |'
  prefs: []
  type: TYPE_TB
- en: '| EC2 | 750 hours of Linux t2.micro (Single vCPU, 1 GB Memory) instance |'
  prefs: []
  type: TYPE_TB
- en: '| Elastic Block Storage | 30 GB block-level storage (SSD or traditional spinning
    disk) |'
  prefs: []
  type: TYPE_TB
- en: '| RDS | 750 hours of db.t2.micro (Single vCPU, 1 GB Memory) MySQL instance
    |'
  prefs: []
  type: TYPE_TB
- en: '| Elastic Container Registry | 500 MB of storage |'
  prefs: []
  type: TYPE_TB
- en: '| Elastic Load Balancing | 750 hours of classic or application load balancers
    |'
  prefs: []
  type: TYPE_TB
- en: '| S3 | 5 GB of S3 storage |'
  prefs: []
  type: TYPE_TB
- en: '| Lambda | 1,000,000 requests |'
  prefs: []
  type: TYPE_TB
- en: '| CloudWatch | 10 custom metrics |'
  prefs: []
  type: TYPE_TB
- en: '| SNS | 1,000,000 publications |'
  prefs: []
  type: TYPE_TB
- en: '| CodeBuild | 100 build minutes |'
  prefs: []
  type: TYPE_TB
- en: '| CodePipeline | 1 active pipeline |'
  prefs: []
  type: TYPE_TB
- en: '| X-Ray | 100,000 traces |'
  prefs: []
  type: TYPE_TB
- en: '| Key Management Service | 20,000 requests |'
  prefs: []
  type: TYPE_TB
- en: '| Secrets Manager | 30-day free trial period, then $0.40 per secret/month |'
  prefs: []
  type: TYPE_TB
- en: As you can see, we will be covering a number of AWS services in this book and
    almost all of them are free, assuming you honor the usage limits described in
    the preceding table. In fact, the only service that we will use in this book that
    is not free is the AWS Fargate service, so bear this in mind when you read through
    the Fargate chapter and try to minimize your usage if you are worried about the
    cost of this.
  prefs: []
  type: TYPE_NORMAL
- en: 'To sign up for free tier access, click on the **Create a Free Account** button
    at [https://aws.amazon.com/free/](https://aws.amazon.com/free/):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/de4a4e51-dad1-4756-ad13-ce2d6089757a.png)Creating a free account'
  prefs: []
  type: TYPE_NORMAL
- en: You will be prompted to enter an email address, password, and AWS account name.
    It's important to understand that the email address and password you enter here
    is referred to as the root account for your AWS account, which has the highest
    level of access to your account. For the AWS account name, you can enter any name
    you like, however it must be unique across all of the other AWS accounts, so at
    the very least you won't be able to use the account name I chose, which is `docker-in-aws`.
    This account name is used when you sign in and is much easier to remember than
    your AWS account number, which is a 12-digit number.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the sign-up process is self-explanatory, so I won't bore you with
    the details here, but understand that you will be required to provide credit card
    details and will be responsible for any charges over and above the free tier usage
    limits. You will also be required to verify the phone number you specify during
    signup, which involves an automated phone call to your number, so ensure you enter
    a valid phone number during registration.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Google Authenticator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The steps described in this section are completely optional, however, as a security
    best practice you should always enable multi-factor authentication (MFA) on your
    root account. In fact, you should enable this for all user-based access to your
    AWS accounts, regardless of the level of access required. Enabling MFA is increasingly
    becoming a mandatory requirement for many organizations using AWS, so getting
    used to working with AWS when MFA is involved is important. Consequently, we will
    actually use MFA throughout this book.
  prefs: []
  type: TYPE_NORMAL
- en: Before you can use MFA, you need to have an MFA device, which can be a hardware
    or virtual MFA device. A virtual MFA device is typically installed in the form
    of an application on your smart phone, completing the multi-factor paradigm of
    something you know (password) and something you have (your phone).
  prefs: []
  type: TYPE_NORMAL
- en: A popular MFA application available for both Android and iOS is the Google Authenticator
    app, which you can download from the Google Play or Apple App Stores. Once you
    have installed the application, you can proceed to logging into the root account
    and setting up MFA access.
  prefs: []
  type: TYPE_NORMAL
- en: Logging in as the root account
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After setting up and activating your account, you should be able to log in to
    the AWS console, which you can access at [https://console.aws.amazon.com/console/home](https://console.aws.amazon.com/console/home).
  prefs: []
  type: TYPE_NORMAL
- en: After logging in with your root credentials, the first thing you should do is
    immediately enable MFA access. This provides an extra level of security, ensuring
    that if your username and password are compromised, an attacker cannot access
    your account without possession of your MFA device (in our example, that means
    the Google Authenticator application on your smart phone).
  prefs: []
  type: TYPE_NORMAL
- en: 'To enable MFA for your root account, select the drop-down that specifies your
    account name (in my case, this is **docker-in-aws**) and select **My Security
    Credentials**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/bd93b230-35b0-4d24-b1dd-a148d744fe77.png)Accessing My Security Credentials'
  prefs: []
  type: TYPE_NORMAL
- en: 'On the next prompt, click the **Continue to Security Credentials** button,
    expand the **Multi-factor authentication (MFA)** option on the **Your Security
    Credentials** page, and click the **Activate MFA** button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/b554b605-ddd9-4bce-a62c-1c6a6a7be323.png)The Your Security Credentials
    screen'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Manage MFA device screen, click on the **A virtual MFA device** option
    and click **Next Step** twice, at which point you will be presented with a QR
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/56ca8281-9403-47b8-82c7-5c2b96e94fe3.png)Obtaining a QR code'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can scan this code using the Google Authenticator application on your smart
    phone by clicking the add button, selecting **Scan barcode**, and scanning the
    QR code in the AWS console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/6ab37fc0-9b86-4ee4-9c57-b186a02ddb6b.jpg)  ![](assets/0a255dd8-9ba8-4e15-b55d-2d7e10bfc436.png)![](assets/5c785b9d-3b72-40db-9f65-dcbb2a5b3343.png)Registering
    an MFA device'
  prefs: []
  type: TYPE_NORMAL
- en: Once scanned, you need to input the six-digit code presented in the **Authentication
    code 1** input in the **Manage MFA device** screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the code rotates, enter the next value of the code into the **Authentication
    code 2** input and click the **Activate virtual MFA** button to complete the registration
    of your MFA device:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/e399192a-aa4e-43d0-a977-2e8ba4107479.png)Your Security Credentials
    with the MFA device'
  prefs: []
  type: TYPE_NORMAL
- en: Creating IAM users, groups, and roles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After securing your root account using MFA, you should next immediately create
    identity access and management (IAM) users, groups, and roles in your account
    for day-to-day access. IAM is the recommended approach for day-to-day administration
    and access to your AWS account and you should restrict root account access for
    billing or emergency purposes only. Before you can continue, you will need to
    know your AWS account ID, which you can see in the previous screenshot, in the
    serial number of your MFA device (note that this will be a different number than
    that which is shown). Write this account number down, as it will be required as
    you configure various IAM resources.
  prefs: []
  type: TYPE_NORMAL
- en: Creating IAM roles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The standard practice for creating IAM resources is to create *roles* that
    a given user can assume, which grants the user elevated privileges for a limited
    period of time (typically up to 1 hour). At a minimum, you need to create one
    IAM role by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '**admin**: This role grants full administrative control of the account, except
    for billing information'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To create the admin role, select **Services** | **IAM** from the AWS console,
    select **Roles** from the left hand menu, and click on the **Create role** button.
    In the **Select type of trusted entity** screen, select the **Another AWS account**
    option and configure your account ID in the **Account ID** field:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/9ebc3797-e018-48e0-80a1-d81b577a1dc2.png)Selecting a trusted entity
    for admin role'
  prefs: []
  type: TYPE_NORMAL
- en: 'After clicking the **Next: Permissions** button, select the **AdministratorAccess**
    policy, which grants the role administrative access:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/5d5dadb4-76a0-43fe-b957-d3a0ed3250f0.png)Attaching a policy to an
    IAM role'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, specify a role name of **admin** and then click **Create role** to
    complete the creation of the admin role:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/75f3e14e-ff1a-42e4-8893-9f67a1fdfcec.png)Creating an IAM role'
  prefs: []
  type: TYPE_NORMAL
- en: 'This creates the admin IAM role. If you click on the newly created role, take
    note of the Role ARN (Amazon Resource Name) of the role, as you will need this
    value later on:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/945a886e-13aa-4153-894a-9e969d65f0e8.png)The admin role'
  prefs: []
  type: TYPE_NORMAL
- en: Creating an Administrators group
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With an administrative role in place, the next step is to assign your role to
    a user or group. Instead of assigning privileges directly to a user, it is strongly
    recommended to instead assign them to groups, as this provides a much more scalable
    way of managing permissions. Given we have created a role with administrative
    privileges, it now makes sense to create a group called Administrators, which
    will be granted permission to *assume* the admin role you just created. Note that
    I refer to assuming a role, which is analogous to Linux and Unix systems, where
    you log in as a regular user and then use the `sudo` command to temporarily assume
    root privileges.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will learn how to assume a role later on in this chapter, but for now you
    need to create the Administrators group by selecting **Groups** from the left
    hand menu in the IAM console and clicking the **Create New Group** button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/02d4df30-8fb3-4a62-af2f-7770c0acddb4.png)Creating an IAM group'
  prefs: []
  type: TYPE_NORMAL
- en: 'You first need to specify a **Group Name** of Administrators and then click
    **Next Step** twice to skip the **Attach Policy** screen and finally click **Create
    Group** to complete creation of the group:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/bd6acf11-5675-4b42-aeec-0a51e1c66515.png)The Administrators group'
  prefs: []
  type: TYPE_NORMAL
- en: 'This has created a group with no attached permissions, however if you click
    on the group and select **Permissions**, you now have the option to create an
    inline policy:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/b3727916-33e9-467c-9529-620aba3b7bbe.png)Creating an inline policy'
  prefs: []
  type: TYPE_NORMAL
- en: 'After selecting the click here link in the preceding screenshot, choose the
    **Custom Policy** option and click Select, which allows you to configure an IAM
    policy document that grants the ability to assume the `admin` role you created
    earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/1d451ff2-8214-462c-a2f8-21c0e64d41a4.png)Administrators group inline
    policy'
  prefs: []
  type: TYPE_NORMAL
- en: The policy includes a single statement that allows the action `sts:AssumeRole` –
    `sts` here refers to the Security Token Service, which is the service you interact
    with whenever you assume a role (the action of assuming a role grants you temporary
    session credentials linked to the role you have assumed). Notice that the resource
    is the ARN of the IAM role you created, so this policy grants anybody that is
    a member of the **Administrators** group to assume the **admin** role. After clicking
    the **Apply Policy** button, you will have successfully created and configured
    the **Administrators** group.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Users group
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The other group I typically recommend creating is a Users group, which every
    human user accessing your AWS account should belong to, including your administrators
    (who will also be members of the Administrators group).  The core function of
    the Users group is to ensure that with the exception of a very small set of permissions,
    all actions performed by any member of the users group must be MFA authenticated,
    regardless of the permissions that may be granted to that user via other groups.
    This is essentially a force MFA policy, which you can read more about at [https://www.trek10.com/blog/improving-the-aws-force-mfa-policy-for-IAM-users/](https://www.trek10.com/blog/improving-the-aws-force-mfa-policy-for-IAM-users/),
    and implementing this approach adds to the overall security protections you put
    in place for access to your AWS accounts. Note that the policy does allow the
    user to perform a minimal set of operations without requiring MFA, which includes
    logging in, changing the user's password, and most importantly allowing the user
    to register an MFA device. This allows new users to log in with a temporary password,
    change their password, and self-enroll their MFA device, and once the user has
    logged out and logged back in with MFA, the policy does permit the user to create
    an AWS access key for API and CLI access.
  prefs: []
  type: TYPE_NORMAL
- en: To implement the Users group, we first need to create a managed IAM policy,
    which is a more scalable and reusable mechanism for assigning policies to groups
    and roles when compared with the inline approach we took in the preceding screenshot.
    To create a new managed policy, select **Policies** from the right hand menu and
    click on the **Create policy** button, which opens the **Create policy** screen.
    The policy you need to create is quite extensive and is published in a GitHub
    gist at [https://bit.ly/2KfNfAz](https://bit.ly/2KfNfAz), which is based upon
    the policy discussed in the blog post referenced previously, adding a few additional
    security enhancements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the gist includes a placeholder called `PASTE_ACCOUNT_NUMBER` within
    the policy document, so you will need to replace this with your actual AWS account
    ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/f65c5220-257c-44e3-be1b-0aa1c9b60e26.png)Creating an IAM managed
    policy'
  prefs: []
  type: TYPE_NORMAL
- en: After clicking the **Review policy** button, you need to configure a name for
    the policy, which we will call `RequireMFAPolicy`, and, after clicking **Create
    policy** to create the policy, you need to create a Users group using the same
    instructions you followed earlier in this chapter when you created the Administrators
    group.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you get to the **Attach Policy** screen while you are creating the Users
    group, you can type in the first few letters of the RequireMFAPolicy managed policy
    you just created, which you need to attach to the group:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a9c05282-0d04-4a82-8e86-63463f523563.png)Attaching the RequireMFAPolicy
    to the Users group'
  prefs: []
  type: TYPE_NORMAL
- en: After completing the wizard for creating the **Users** group, you should now
    have an **Administrators** group and **Users** group in your IAM console.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an IAM user
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The final IAM setup task you need to perform is to create an IAM user to administer
    your account. As discussed earlier in this chapter, you should never use your
    root credentials for day-to-day administrative tasks, and instead create an administrative
    IAM user.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a user, select **Users** from the right-hand menu in the IAM console
    and click on the **Add user** button. In the **Add user** screen, specify a **User
    name** and only select **AWS Management Console access** for **Access type**,
    ensuring that the **Console password** is set to **Autogenerated password** and
    the **Require password reset** option is set:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/6e4cf11a-4fb8-4226-adcc-a0f4d9cb667b.png)Creating a new user'
  prefs: []
  type: TYPE_NORMAL
- en: 'After clicking the **Next: Permissions** button, add the user to the **Administrators**
    and **Users** groups you created earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/f9dab5ca-1eb6-4942-a07a-d8acd12828aa.png)Adding users to groups'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can now click on the **Next: review** and **Create user **buttons to create
    the user. The user will be created and, because you chose to create an autogenerated
    password, you can click the **Show** link in the **Password** field to reveal
    the initial password for the user. Take note of this value, as you will need it
    to test logging in as the IAM user you just created:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/8b50427a-f35e-4772-a692-8e0664aebdf8.png)Newly created user temporary
    password'
  prefs: []
  type: TYPE_NORMAL
- en: Logging in as an IAM user
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that you have created an IAM user, you can test the first time login experience
    for the user by clicking your account alias/ID in the menu and selecting **Sign
    Out**. If you now click on the **Sign In to the Consol**e button or browse to [https://console.aws.amazon.com/console/home](https://console.aws.amazon.com/console/home),
    select the **Sign in to a different account** option, enter your account alias
    or account ID, and click **Next**, and then enter the username and temporary password
    of the IAM user you just created:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/75e79bbf-c290-4a2d-a106-6f13f32561bb.png)Logging in for the first
    time as an IAM user'
  prefs: []
  type: TYPE_NORMAL
- en: 'You will then be prompted to enter a new password:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/7deaf251-e404-41d0-961d-de7d00b8e18e.png)Entering a new password'
  prefs: []
  type: TYPE_NORMAL
- en: After confirming the password change, you will have successfully logged in as
    the new user.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling MFA for an IAM user
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, you have logged in with an IAM user for the first time, and the
    next step you need to perform is to enroll your MFA device for the new user. To
    do this, select **Services** | **IAM** to open the IAM console, select **Users**
    from the left hand menu, and click on your IAM user.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the **Security credentials** tab, click on the pencil icon next to the **Assigned
    MFA device** field:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/aebab6f6-7c8a-4cd4-9671-dccd26b7dc3e.png)IAM user security credentials'
  prefs: []
  type: TYPE_NORMAL
- en: The Manage MFA Device dialog will pop up, which allows you to register a new
    MFA device. The process for this is identical to how you set up MFA for the root
    account earlier in this chapter, so I won't repeat the instructions for this,
    however once you have registered your MFA device, it is important for you to log
    out and log back in to the console to force MFA authentication.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have configured everything correctly, when you log back in to the console,
    you should be prompted for an MFA code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/48de9696-0af0-40f0-bded-e298bd27a327.png)MFA prompt'
  prefs: []
  type: TYPE_NORMAL
- en: Assuming an IAM role
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once you have completed registering an MFA device and have logged out and back
    in to the AWS console using MFA, you now meet the requirements that cause the
    following statement in the `RequireMFAPolicy` you created back previously to not
    be applied:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, it's important to note that the IAM effect of `Deny`
    is absolute—as soon as IAM encounters a `Deny` for a given permission or set of
    permissions, there is no way for that permission to be permitted. The `Condition`
    property however makes this broad reaching `Deny` conditional—it will only be
    applied in the event that the special condition `aws:MultiFactorAuthAge` is false,
    which is the case if you have logged in without MFA.
  prefs: []
  type: TYPE_NORMAL
- en: Given that the IAM user has logged in via MFA and is attached to the **Administrators**
    group that has permission to assume the **admin** role, there is nothing in the
    `RequireMFAPolicy` that is denying this action, so you should be able to now assume
    the **admin** role.
  prefs: []
  type: TYPE_NORMAL
- en: 'To assume the admin role using the AWS console, click on the drop down that
    reads `<username> @ <account-name-or-id>` and select **Switch Role**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/7579bba8-fdb1-4462-a458-03ea1392ffe7.png)Switching roles'
  prefs: []
  type: TYPE_NORMAL
- en: 'After clicking on the **Switch Role** button, you will be prompted to enter
    an account ID or name, and the role that you want to assume in the configure account:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/b934817f-04fb-44ab-8a4b-ba8ad803e9a3.png)Switching roles'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now notice that the header in the AWS console indicates that you
    have to assume the admin role, and you now have full administrative access to
    your AWS account:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/582a79e0-cc9d-45da-ab8f-8e273dcb2a0a.png)Assumed admin roleFor the
    remainder of this book, whenever you need to perform administrative tasks in your
    account, I will be assuming you have assumed the admin role as demonstrated in
    the previous screenshot.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating an EC2 Key Pair
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A key setup task that is required if you are going to running any EC2 instances
    in your AWS account is to establish one or more EC2 key pairs, which for Linux
    EC2 instances, can be used to define an SSH key pair that grants SSH access to
    your EC2 instances.
  prefs: []
  type: TYPE_NORMAL
- en: When you create an EC2 key pair, an SSH public/private key pair will be automatically
    generated, with the SSH public key being stored as a named EC2 key pair in AWS,
    and the corresponding SSH private key downloaded to your local client.  If you
    subsequently create any EC2 instances and reference a named EC2 key pair at instance
    creation, you will be able to automatically use the associated SSH private key
    to access your EC2 instances.
  prefs: []
  type: TYPE_NORMAL
- en: SSH access to Linux EC2 instances requires you to use the SSH private key associated
    with the configured EC2 key pair for the instance, and also requires appropriate
    network configuration and security groups to permit access to the EC2 instance
    SSH port from wherever your SSH client is located.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create an EC2 Key Pair, first navigate to **Services | EC2** in the AWS
    console, select **Key Pairs** from the **Network & Security** section within the
    left hand menu, and then click on the Create Key Pair button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/52541551-506e-42ce-9fdf-02cfa8b5a6f9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here you have configured an EC2 key pair name admin, and after clicking on
    the Create button, a new EC2 key pair will be created, with the SSH private key
    downloaded to your computer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/b793d0f0-fcb8-4f02-9283-228dcf9a540b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'At this point you need to move the SSH private key to an appropriate location
    on your computer, and modify the default permissions on the private key file as
    demonstrated below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that if you don''t modify the permissions using the chmod command, when
    you attempt to use the SSH key you will be presented with the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Using the AWS CLI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far in this chapter, you have only interacted with the AWS console, which
    is accessed from your web browser. Although having AWS console access is very
    useful, there are many situations where you may prefer to use command-line tools,
    especially where you need to automate key operational and deployment tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the AWS CLI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The AWS CLI is written in Python, and therefore you must have either Python
    2 or Python 3 installed, along with the PIP Python package manager.
  prefs: []
  type: TYPE_NORMAL
- en: The instructions and examples used throughout this book assume a MacOS or Linux
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: For instructions on how to set up the AWS CLI using Windows, refer to [https://docs.aws.amazon.com/cli/latest/userguide/awscli-install-windows.html](https://docs.aws.amazon.com/cli/latest/userguide/awscli-install-windows.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming you have met these prerequisites, you can install the AWS CLI in a
    terminal using the `pip` command, along with the `--upgrade` flag to upgrade to
    the latest AWS CLI version if already installed, and the `--user` flag to avoid
    modifying your system libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Depending on your environment, if you are using Python 3, you may need to replace
    the `pip install` command with `pip3 install`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you now attempt to run an AWS CLI command, the command will fail, indicating
    that you must configure your environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Creating an AWS access key
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you run the `aws configure` command as suggested in the preceding code,
    you will be prompted to enter an AWS Access Key ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'To use the AWS CLI and AWS SDKs, you must create an AWS access key, which is
    a credential that consists of an access key ID and secret access key value. To
    create an access key, open the IAM dashboard in the AWS console, select **Users**
    from the left hand menu, and then click on your username.  In the **Security credentials**
    tab, under the **Access keys** section, click on the **Create access key** button,
    which will open a dialog box that allows you to view both the access key ID and
    secret access key value:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/fcc8616b-3a14-43ac-8b78-b7449ca7fc29.png)Access key credentials'
  prefs: []
  type: TYPE_NORMAL
- en: Take a note of both the access key ID and secret access key values, as you will
    need these values to configure your local environment.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the AWS CLI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Back in your terminal, you can now complete the `aws configure` setup process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If you now attempt to run the `aws ec2 describe-vpcs` command attempted earlier,
    the command still fails; however, the error is different:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The problem now is that you are not authorized to execute this command, given
    the access key you just created is linked to your user account, and you must assume
    the admin role to obtain administrative privileges.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the AWS CLI to assume a role
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, the AWS CLI is running in the context of your user account and
    you need to configure the CLI to assume the admin role to be able to do anything
    useful.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you run the `aws configure` command, the AWS CLI creates two important
    files in a folder called `.aws` within your home directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `credentials` file holds your AWS credentials in one or more named profiles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, notice that the `aws configure` command created a profile
    called `default` and stored the access key ID and secret access key values in
    this file. As a best practice, particularly if you are working with multiple AWS
    accounts, I recommend avoiding the use of the default profile, as the AWS CLI
    will use this profile by default if you enter an AWS CLI command. You will soon
    learn how to work with multiple AWS accounts by using named profiles, and if you
    have a default profile, it is very easy to accidentally forget to specify the
    profile you want to work with and accidentally perform an unexpected operation
    in the account reference by your default profile. I prefer to name each profile
    based upon the name of the account you are working with—for example, here, I have
    renamed the default profile in the credentials file to `docker-in-aws`, given
    I named my AWS account `docker-in-aws`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The other file that is created by the AWS CLI is the `~/.aws/config` file,
    which is demonstrated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This file includes named configuration profiles, and because you specified
    a default region when you ran the `aws configure` command, a `region` variable
    has been added to the `default` profile. Configuration profiles support a number
    of variables that allow you to perform more advanced tasks like automatically
    assuming a role, so this is where we need to configure the CLI to assume the `admin`
    role we created earlier in this chapter. Given that we renamed the `default` profile
    in the `credentials` file, the following code demonstrates renaming the `default`
    profile to `docker-in-aws` and adding support for assuming the `admin` role:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that we add the `profile` keyword in front of the profile name, which
    is required when configuring named configuration profiles. We also configure a
    number of variables in the profile:'
  prefs: []
  type: TYPE_NORMAL
- en: '`source_profile`: This is the credential profile that should be used to obtain
    credentials. We specify `docker-in-aws`, given that we renamed the profile in
    the `credentials` file earlier to `docker-in-aws`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`role_arn`: This is the ARN of the IAM role to assume. Here, you specify the
    ARN of the `admin` role you created in the previous screenshot.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`role_session_name`: This is the name of the temporary session that is created
    when you assume the configured role. As a best practice, you should specify your
    IAM username, as this helps with auditing any actions that you perform using the
    role. When you use an assumed role to perform an action in AWS, your identity
    is actually `arn:aws:sts::<account-id>:assumed-role/<role-name>/<role-session-name>`,
    so setting a username as the role session name ensures the user that performed
    the operation can be easily determined.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mfa_serial`: This is the ARN of the MFA device that should be used to assume
    the role. Given your IAM user belongs to the Users group, MFA is required for
    all actions, including any API calls made via the AWS CLI or SDK. By configuring
    this variable, the AWS CLI will automatically prompt you for an MFA code before
    attempting to assume the configured role. You can obtain the ARN of your MFA device
    in the Security credentials tab of your IAM user account (see the Assigned MFA
    device field, however it will always follow a naming convention of `arn:aws:iam::<account-id>:mfa/<user-id>`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See [https://docs.aws.amazon.com/cli/latest/topic/config-vars.html](https://docs.aws.amazon.com/cli/latest/topic/config-vars.html)
    for a complete description of all variables supported in both credentials and
    configuration profiles.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the AWS CLI to use a named profile
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With the configuration in place, you no longer have a default profile in place,
    so running the AWS CLI will return the same output. To use a named profile, you
    have two options available:'
  prefs: []
  type: TYPE_NORMAL
- en: Specify the profile name using the `--profile` flag in the AWS CLI command.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specify the profile name in an environment variable called `AWS_PROFILE`. This
    is my preferred mechanism and I will assume that you are taking this approach
    throughout this book.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The preceding code demonstrates using both of these approaches:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, notice that when you run first run the `aws` command,
    you are prompted for your MFA token, however when you next run the command, you
    are not prompted. This is because, by default, the temporary session credentials
    obtained from assuming a role are valid for one hour, and the AWS CLI caches the
    credentials so that you reuse them without having to refresh the credentials on
    each command execution. Of course, after one hour, you will be prompted once again
    for your MFA token, given that the temporary session credentials will have expired.
  prefs: []
  type: TYPE_NORMAL
- en: One other interesting point to note in the preceding code is the use of the
    `--query` flag in the last command example. This allows you to specify a JMESPath
    query, which is a query language that can be used to query JSON data structures.
    The AWS CLI outputs JSON by default, so you can use queries to extract specific
    information from the AWS CLI output. Throughout this book, I will frequently use
    examples of these queries, and you can read more about the JMESPath query language
    at [http://jmespath.org/tutorial.html](http://jmespath.org/tutorial.html).
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to AWS CloudFormation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**AWS CloudFormation** is a managed AWS service that allows you to define AWS
    services and resources using infrastructure as code, and is an alternative to
    using the AWS console, CLI, or various SDKs for deploying your AWS infrastructure.
    Although there is bit of a learning curve to master CloudFormation, once you have
    the basics of using CloudFormation under your belt, it represents an extremely
    powerful approach to deploying your AWS infrastructure, particularly once you
    start deploying complex environments.'
  prefs: []
  type: TYPE_NORMAL
- en: When using CloudFormation, you define one or more resources in a CloudFormation
    template, which is a convenient mechanism to group related resources in a single
    place. When you deploy your template, CloudFormation will create a *stack* that
    comprises the physical resources defined in your template. CloudFormation will
    deploy each resource, automatically determining any dependencies between each
    resource, and optimise the deployment so that resources can be deployed in parallel
    where applicable, or in the correct sequence when there are dependencies between
    resources. The best news is that all of this powerful capability comes for free
    – you only pay for the resources you consume when you deploy your stacks via CloudFormation.
  prefs: []
  type: TYPE_NORMAL
- en: It's also important to note that there are many third-party alternatives to
    CloudFormation – for example, Terraform is very popular, and traditional configuration
    management tools such as Ansible and Puppet also include support for deploying
    AWS resources. My personal favorite is CloudFormation given it is natively supported
    by AWS, has good support for a wide variety of AWS services and resources, and
    natively integrates with the AWS CLI and services such as CodePipeline (we will
    leverage this integration later on in this book in Chapter 13 - *Continuous Delivering
    ECS Applications*).
  prefs: []
  type: TYPE_NORMAL
- en: Defining a CloudFormation template
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The easiest way to get started with CloudFormation is to create a CloudFormation
    template. This template is defined in either a JSON or YAML format, with the latter
    being the format I recommend given YAML is much easier for humans to work with
    than JSON.
  prefs: []
  type: TYPE_NORMAL
- en: 'The [CloudFormation user guide](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/Welcome.html)
    describes the [template structure in great detail](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/template-anatomy.html),
    however for the purposes of this book, we only need to worry about a basic template
    structure which is best demonstrated with a real example, which you can save in
    a file called `stack.yml` in a convenient location on your computer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the CloudFormation defines a Cloud9 management station
    – Cloud9 provides a cloud-based IDE and terminal, which under the hood runs on
    an EC2 instance in AWS. Let's walk through this example to discuss the structure
    and features of the template.
  prefs: []
  type: TYPE_NORMAL
- en: The `AWSTemplateFormatVersion` property is required, which specifies the CloudFormation
    template format version that is always expressed in date terms. The `Parameters`
    property defines a set of input parameters that you can supply to your template,
    which is a good way to deal with multiple environments where you may have different
    input values between each environment. For example, the `EC2InstanceType` parameter
    specifies the EC2 instance type for the management station, while the `SubnetId`
    parameter specifies the subnet the EC2 instance should be attached to. Both of
    these values could be different between a non-production environment and production
    environment, so having them as input parameters makes it easier to change depending
    on the target environment. Notice that the `SubnetId` parameter specifies a type
    of `AWS::EC2::Subnet::Id`, which means CloudFormation can use this to lookup or
    validate the input value. For a list of supported parameter types, see [https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/parameters-section-structure.html](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/parameters-section-structure.html).
    You can also see that the `EC2InstanceType` parameter defines a default value
    for the parameter, which will be used if no input is provided for this parameter.
  prefs: []
  type: TYPE_NORMAL
- en: The `Resources` property defines all of the resources in your stack – this truly
    is the meat or body of the template, and may contain up to two hundred resources.
    In the preceding code, we only define a single resource which we call `ManagementStation`,
    and this creates Cloud9 EC2 Environment, as expressed via a `Type` value of `AWS::Cloud9::EnvironmentEC2`.
    All resources must specify a `Type` property, which defines the type of resource
    and determines the various configuration properties available for each type. The
    CloudFormation user guide includes a section that defines all supported resource
    types, and at last count there were 300 different types of resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every resource also includes a Properties property, which holds all of the
    various configuration properties available for the resource. In the preceding
    code, you can see that we have defined five different properties—the properties
    available will vary depending on the resource type and are fully documented in
    the CloudFormation user guide:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Name`: This specifies the name of the Cloud9 EC2 environment. The value of
    properties can be simple scalar values like a string or number, however the value
    can also reference other parameters or resources in the template. Notice that
    the value of the `Name` property includes what is referred to as an [intrinsic
    function](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/intrinsic-function-reference.html)
    called `Sub`, and can be identified by the preceding exclamation mark (`!Sub`).
    The `!Sub` syntax is actually a shorthand for `Fn::Sub`, an example of which you
    can see with the `Description` property. The `Fn::Sub` intrinsic function allows
    you to define an expression that includes interpolated references to other resources
    or parameters in your stack. For example, the value of the `Name` property is
    `${AWS::StackName}-station`, where the `${AWS::StackName}` is an interpolated
    reference known as a [pseudo parameter](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/pseudo-parameter-reference.html)
    that will be replaced with the name of the CloudFormation stack you deploy from
    the template. If the name of your stack is `cloud9-management`, then the value
    of `${AWS::StackName}-station` will be expanded to `cloud9-management-station` when
    your stack is deployed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Description`: This provides a description for the Cloud9 EC2 environment.
    This includes an example of the long hand version of the `Fn::Sub` intrinsic function,
    which requires you to indent a new line, whereas the shorthand `!Sub` format allows
    you to specify the value on the same line as the property.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AutomaticStopTime`: This defines the amount of idle time in minutes to wait
    before stopping the Cloud9 EC2 instance. This saves on costs, but only when running
    the EC2 instance when you are using it (Cloud9 will automatically start your instance
    and resume your session from where you previously were). In the preceding code,
    the value is a simple scalar value of 15.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`InstanceType`: This is the type of EC2 instance. This references the `EC2InstanceType`
    parameter using the Ref intrinsic function (`!Ref` is the shorthand form), which
    allows you to reference other parameters or resources in the stack. This means
    that whatever value is provided for this parameter when you deploy the stack will
    be applied for the `InstanceType` property.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SubnetId`: This is the target subnet ID where the EC2 instance will be deployed.
    This property references the SubnetID parameter using the long hand version of
    the `Ref` intrinsic function, which requires to you express this reference on
    an indented new line.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying a CloudFormation stack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you have defined a CloudFormation template, you can deploy the resources
    in your template in the form of a CloudFormation stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can deploy a stack using the AWS console by choosing **Services** | **CloudFormation**,
    which will open the CloudFormation dashboard. Before you continue, ensure that
    you have assumed the admin role in your account and have also selected US East
    N. Virginia (us-east-1) as the region:'
  prefs: []
  type: TYPE_NORMAL
- en: For all examples in this book, we will be using the us-east-1 (N. Virginia)
    region.![](assets/6aec5bab-afe5-4795-ac18-1c6681e28289.png)CloudFormation dashboard
  prefs: []
  type: TYPE_NORMAL
- en: 'If you click on the **Create new stack** button, you will be prompted to select
    a template, where you can either select a sample template, upload a template,
    or specify an S3 template URL. Because we defined our stack in a file called `stack.yml`,
    select the option to upload a template and click the **Choose file** button to
    select the file on your computer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/38367206-84db-4a54-8043-fe8aa6613cef.png)Selecting a CloudFormation
    template'
  prefs: []
  type: TYPE_NORMAL
- en: 'After uploading the template, the CloudFormation service will parse the template
    and ask you to specify a name for the stack and also provide values for any parameters
    in the stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/65e6ca0f-052d-4840-96b2-503e43d49863.png)Specifying template details'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding screenshot, the value `t2.micro` is set by default for the
    `EC2InstanceType` parameter, given you set this as a default value in your template.
    Because you specified `AWS::EC2::Subnet::Id` as the type of the `SubnetId` parameter,
    the **Create stack** wizard automatically finds all of the subnets in your account
    and region and presents them in a dropdown. Here, I have selected the subnet from
    the default VPC that is created with every new AWS account that is located in
    the **us-east-1a** availability zone.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can determine which availability zone each of the subnets belongs to by
    either selecting **Services** | **VPC** | **Subnets** in the AWS console, or by
    running the `aws ec2 describe-subnets` AWS CLI command with a JMESPath query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, you can click **Next** and then **Create** in the **Create stack**
    wizard to commence deployment of your new stack. In the CloudFormation dashboard,
    you will see that a new stack called **cloud9-management** is created, which initially
    has a status of `CREATE_IN_PROGRESS`. An interesting behavior associated with
    deploying Cloud9 environments via CloudFormation is that a separate child CloudFormation
    stack is automatically created via the `AWS::Cloud9::Environment` resource—this
    is somewhat unusual as for every other type of CloudFormation resource you will
    create, you will not see this type of behavior. Once deployment is complete, the
    status of the stack will change to `CREATE_COMPLETE`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/de0f7e1f-35bc-47aa-8df0-7bebfa06bb1f.png)Deploying a CloudFormation
    stack'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding screenshot, you can click on the **Events** tab to display
    events associated with stack deployment. This will show you the progress of each
    resource as it is deployed, and will indicate if there are any failures.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you have successfully deployed your first CloudFormation stack, you
    should have a brand new Cloud9 IDE environment available for you to use. If you
    select **Services** | **Cloud9** from the AWS console menu bar, you should see
    a single environment called `cloud9-management-station`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/bf94b2a5-6146-44ae-a0ed-3de38549d0ea.png)Cloud9 environments'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you click on the **Open IDE** button, this will open a new IDE session which
    includes an integrated terminal with AWS CLI installed. Note that the session
    has all of the permissions associated with the user that created the Cloud9 environment—in
    this case, this is the assumed **admin** role, hence you can perform any administrative
    task from the terminal. The Cloud9 environment is also running within your VPC,
    so if you deploy other resources such as EC2 instances, you can manage them locally
    from this environment, even if your other resources are deployed in private subnets
    without internet connectivity:'
  prefs: []
  type: TYPE_NORMAL
- en: Make sure you understand the implications of creating a Cloud9 environment that
    has full administrative privileges. Although this is very convenient, it does
    represent a potential security backdoor that could be used to compromise your
    environment and account. Cloud9 also allows you to share your IDE with other users,
    which could allow other users to masquerade as you and perform any action that
    you are allowed to perform. ![](assets/47bf21c4-dc4c-45a7-800a-25ed9098cff3.png)Cloud9
    IDE
  prefs: []
  type: TYPE_NORMAL
- en: Updating a CloudFormation Stack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After you have created a CloudFormation stack, you may want to make changes
    to the stack, such as adding additional resources, or changing the configuration
    of existing resources. CloudFormation defines three key life cycle events related
    to stacks – CREATE, UPDATE, and DELETE – and these can apply to individual resources
    within the stack, or to the stack as a whole.
  prefs: []
  type: TYPE_NORMAL
- en: To update a stack, you simply make any required changes to your CloudFormation
    template and submit the modified template—the CloudFormation service will calculate
    the required changes for each resource, which may result in the creation of new
    resources, updating or replacement of existing resources, or deletion of existing
    resources. CloudFormation will also make any new changes first, and only if these
    changes are successful will it then clean up any resources that should be removed.
    This provides a higher chance of recovery in the event that a CloudFormation stack
    update fails, in which case CloudFormation will attempt to roll back the changes
    to restore the stack to its original state.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test updating your CloudFormation stack, let''s make a small change to the
    `stack.yml` template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'To apply this change, instead of using the AWS console, we will use the AWS
    CLI, which supports deploying your CloudFormation templates via the `aws cloudformation
    deploy` command. We will be using this command extensively throughout the remainder
    of this book, so now is a good time to introduce the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we first ensure that the correct profile is configured,
    and then run the `aws cloudformation deploy` command, specifying the stack name
    using the `--stack-name` flag and template file with the `--template-file` flag.
    The `--parameter-overrides` flag allows you to supply input parameter values in
    the format `<parameter>=<value>` – note that in an update scenario like this one,
    if you don't specify any parameter overrides, the previous parameter values provided
    (when you created the stack, in this case) will be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that the update actually fails, and if you view the stack events via
    the CloudFormation console, you can find out why the stack update failed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/74b208ac-b2b6-4b7d-8dd4-d59eaaa6da1c.png)CloudFormation stack update
    failure'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding screenshot, you can see that the stack update failed because
    the change required CloudFormation to create and replace the existing resource
    (in this case, the Cloud9 environment) with a new resource. As CloudFormation
    always attempts to create new resources before destroying any old resources that
    have been replaced, because the resource is configured with a name, CloudFormation
    cannot create a new resource with the same name, causing a failure. This highlights
    one of the important gotchas of CloudFormation—be very careful when defining your
    resources with static names—if CloudFormation ever needs to replace the resource
    in an update scenario like this one, the update will fail as generally, resource
    names must be unique.
  prefs: []
  type: TYPE_NORMAL
- en: For guidance on when CloudFormation will choose to replace a resource if you
    are updating the resource, refer to the resource properties defined for each resource
    type in the [AWS Resource Types Reference](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-template-resource-type-ref.html)
    document.
  prefs: []
  type: TYPE_NORMAL
- en: You can see that CloudFormation automatically rolls back the change after the
    failure, reversing any changes that were made leading up to the failure. The status
    of the stack eventually changes to `UPDATE_ROLLBACK_COMPLETE`, indicating that
    a failure and rollback took place.
  prefs: []
  type: TYPE_NORMAL
- en: One fix for resolving the stack failure would be to remove the `Name` property
    on the `ManagementStation` resource in your stack – in this instance, CloudFormation
    will ensure it generates a unique name (typically based from the CloudFormation
    stack name with some random alphanumeric characters appended), meaning any time
    you update the resource so that it requires a replacement, CloudFormation will
    simply generate a new unique name and avoid the failure scenario we encountered.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting a CloudFormation stack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that you understand how to create and update a stack, let''s discuss how
    to delete a stack. You can delete a stack very easily using the CloudFormation
    dashboard by simply selecting the stack, selecting **Actions**, and then clicking
    **Delete Stack**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/88161ae0-ec81-4a0a-b229-45e1c8ee18ac.png)Deleting a CloudFormation
    stack'
  prefs: []
  type: TYPE_NORMAL
- en: After clicking **Yes, Delete** to confirm deletion of your stack, CloudFormation
    will proceed to delete each resource defined in your stack. Once complete, the
    stack will disappear from the CloudFormation dashboard, although you change the
    **Filter** dropdown that is located below the **Create Stack** button to click **Deleted**
    to view any previously deleted stacks.
  prefs: []
  type: TYPE_NORMAL
- en: Some might argue it is a little *too* easy to delete your stacks. If you are
    worried about accidental deletion of your stacks, you can select the **Change
    termination protection** option in the preceding screenshot to enable termination
    protection, which will prevent your stacks from being accidentally deleted.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to get started with AWS by creating a free
    account and establishing a root user for your account. You learned how to secure
    root access using multi-factor authentication, and then created a number of IAM
    resources that are required to administer your account. You first created an administrative
    IAM role called **admin**, and then created an Administrators group which you
    assigned the single permission of being permitted to assume your administrative
    IAM role. This approach of assuming roles is the recommend and best practice method
    of administering AWS, and supports more complex multi-account topologies where
    you can host all of your IAM users in one account and assume administrative roles
    in other accounts.
  prefs: []
  type: TYPE_NORMAL
- en: You then created a Users group and assigned a managed policy that forces a requirement
    for multi-factor authentication (MFA) for any user belonging to that group. MFA
    should be considered a mandatory security requirement these days for any organization
    that uses AWS, and the approach of simply assigning your users to a Users group
    that enforces an MFA requirement is a very simple and scalable mechanism to achieve
    this. After creating a user and assigning it to both the Administrators and Users
    group, you learned what is required for a first time user to set up their access,
    which involves logging in with a one-time password, establishing a new password,
    and then setting up an MFA device. Once a user has logged in using MFA, the user
    is then able to perform whatever permissions have been assigned to them – for
    example, the user you created in this chapter was assigned to the Administrators
    group, and so was able to assume the administrative IAM role, which you were able
    to perform in the AWS console by using the Switch Role functionality that is built
    into the console.
  prefs: []
  type: TYPE_NORMAL
- en: With your IAM setup complete and the ability to assume the admin role via the
    console, we next turned our attention to the command line, installing the AWS
    CLI, generating an access key via the console, and then configuring your access
    key credentials in the local `~/.aws` folder that is used by the AWS CLI to store
    credentials and configuration profiles. You learned how to configure a named configuration
    profile in the `~/.aws/configuration` file, which automatically assumes the admin
    role and prompts for an MFA code whenever the CLI detects that new temporary session
    credentials are required.  You also created an EC2 key pair so that you will be
    able to access EC2 instances using SSH.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you were introduced to AWS CloudFormation, and learned how to define
    a CloudFormation template and deploy a CloudFormation stack, which is a collection
    of resources based upon your CloudFormation template definition. You learned about
    the basic structure of a CloudFormation template, how to create a stack using
    the AWS console, and how to deploy a stack using the AWS CLI.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will be introduced to the Elastic Container Service,
    where you will put your new AWS account to good use and learn how to create ECS
    clusters and deploy Docker applications to ECS.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'True/false: A valid credit card is required to establish a free AWS account.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True/false: You should always perform administrative actions using the root
    account.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True/false: You should allocate IAM permissions directly to your IAM users
    and/or groups.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which IAM managed policy would you use to assign administrative permissions?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What command do you run to install the AWS CLI?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True/false: When you configure the AWS CLI, you must store your IAM username
    and password locally.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Where do you store credentials for the AWS CLI?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You set up an IAM user that requires MFA to perform administrative actions.
    The IAM user sets up their AWS CLI but complains about unauthorized errors when
    attempt to run AWS CLI commands. The named profile includes the `source_profile`, `role_arn`,
    and `role_session_name` parameters, and you confirm that these are configured
    correctly. How would you fix this issue?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True/false: CloudFormation templates can be written using JSON or YAML.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True/false: You can use the `!Ref` keyword to refer to another resource or
    parameter in a CloudFormation template.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You define a resource in a CloudFormation template that includes an optional `Name` property
    that you configure as `my-resource`. You create a new stack from the template
    successfully, and then make a change to the resource that the documentation states
    will require replacement of the entire resource. Will you be able to deploy this
    change successfully?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can check the following links for more information about the topics covered
    in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a Free Tier account: [https://aws.amazon.com/free](https://aws.amazon.com/free)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IAM best practices: [https://docs.aws.amazon.com/IAM/latest/UserGuide/best-practices.html](https://docs.aws.amazon.com/IAM/latest/UserGuide/best-practices.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your AWS Account ID and alias: [https://docs.aws.amazon.com/IAM/latest/UserGuide/console_account-alias.html](https://docs.aws.amazon.com/IAM/latest/UserGuide/console_account-alias.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improving the AWS Force MFA policy: [https://www.trek10.com/blog/improving-the-aws-force-mfa-policy-for-IAM-users/](https://www.trek10.com/blog/improving-the-aws-force-mfa-policy-for-IAM-users/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing the AWS CLI: [https://docs.aws.amazon.com/cli/latest/userguide/installing.html](https://docs.aws.amazon.com/cli/latest/userguide/installing.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AWS CLI reference: [https://docs.aws.amazon.com/cli/latest/reference/](https://docs.aws.amazon.com/cli/latest/reference/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AWS CLI configuration variables: [https://docs.aws.amazon.com/cli/latest/topic/config-vars.html](https://docs.aws.amazon.com/cli/latest/topic/config-vars.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AWS shell: [https://github.com/awslabs/aws-shell](https://github.com/awslabs/aws-shell)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AWS CloudFormation user guide: [https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/Welcome.html](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/Welcome.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AWS CloudFormation template anatomy: [https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/template-anatomy.html](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/template-anatomy.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AWS CloudFormation resource types reference: [https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-template-resource-type-ref.html](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-template-resource-type-ref.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AWS CloudFormation intrinsic functions: [https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/intrinsic-function-reference.html](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/intrinsic-function-reference.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AWS CloudFormation pseudo parameters: [https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/pseudo-parameter-reference.html](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/pseudo-parameter-reference.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
