- en: Chapter 4. Choosing Good Names
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Most of the standard library was built keeping usability in mind. For instance,
    working with built-in types is done naturally and was designed to be easy to use.
    Python, in this case, can be compared to the pseudocode you might think about
    when working on a program. Most of the code can be read out loud. For instance,
    this snippet should be understandable by anyone:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This is one of the reasons why writing Python is so easy when compared to other
    languages. When you are writing a program, the flow of your thoughts is quickly
    translated into lines of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter focuses on the best practices for writing code that is easy to
    understand and use, through:'
  prefs: []
  type: TYPE_NORMAL
- en: The usage of naming conventions, described in **PEP 8**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The set of naming best practices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The short summary of popular tools that allow you to check for compliance with
    styling guides
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PEP 8 and naming best practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PEP 8 ([http://www.python.org/dev/peps/pep-0008](http://www.python.org/dev/peps/pep-0008))
    provides a style guide for writing Python code. Besides some basic rules such
    as space indentation, maximum line length, and other details concerning the code
    layout, PEP 8 also provides a section on naming conventions that most of the codebases
    follow.
  prefs: []
  type: TYPE_NORMAL
- en: This section provides a quick summary of this PEP, and adds to it a naming best-practice
    guide for each kind of element. You should still consider reading of PEP 8 document
    as mandatory.
  prefs: []
  type: TYPE_NORMAL
- en: Why and when to follow PEP 8?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you are creating a new software package that is intended to be open-sourced,
    then the answer is simple: always. PEP 8 is de facto the standard code style for
    most of the open source software in Python. If you want to accept any collaboration
    from other programmers, then you should definitely stick to PEP 8, even if you
    have different views on the best code style guidelines. Doing so has the benefit
    of making it a lot easier for other developers to jump straight into your project.
    Code will be easier to read for newcomers because it will be consistent in style
    with most of the other Python open source packages.'
  prefs: []
  type: TYPE_NORMAL
- en: Also, starting with full PEP 8 compliance saves you time and trouble in the
    future. If you want to release your code to the public, you will eventually face
    suggestions from fellow programmers to switch to PEP 8\. Arguments as to whether
    it is really necessary to do so for a particular project tend to be never-ending
    flame wars that are impossible to win. This is the sad truth, but you may eventually
    be forced to be consistent with this style guide in order to not lose contributors.
  prefs: []
  type: TYPE_NORMAL
- en: Also, restyling of the whole project's codebase, if it is in a mature state
    of development, might require a tremendous amount of work. In some cases, such
    restyling might require changing almost every line of code. While most of the
    changes can be automated (indentation, newlines, and trailing whitespaces), such
    massive code overhaul usually introduces a lot of conflicts in every version control
    workflow that is based on branching. It is also very hard to review so many changes
    at once. These are the reasons why many open source projects have a rule that
    style fixing changes should always be included in separate pull/merge requests
    or patches that do not affect any feature or bug.
  prefs: []
  type: TYPE_NORMAL
- en: Beyond PEP 8 – team-specific style guidelines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Despite providing a comprehensive set of style guidelines, PEP 8 still leaves
    some freedom for the developers. Especially in terms of nested data literals and
    multiline function calls that require long lists of arguments. Some teams may
    decide that they require additional styling rules and the best option is to formalize
    them in some kind of document that is available for every team member.
  prefs: []
  type: TYPE_NORMAL
- en: Also, in some situations, it may be impossible, or economically infeasible,
    to be strictly consistent with PEP 8 in some old projects that had no style guide
    defined. Such projects will still benefit from formalization of the actual coding
    conventions even if they do not reflect the official set of PEP 8 rules. Remember,
    what is more important than consistency with PEP 8 is consistency within the project.
    If rules are formalized and available as a reference for every programmer, then
    it is way easier to keep consistency within a project and organization.
  prefs: []
  type: TYPE_NORMAL
- en: Naming styles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The different naming styles used in Python are:'
  prefs: []
  type: TYPE_NORMAL
- en: CamelCase
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: mixedCase
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: UPPERCASE, and UPPER_CASE_WITH_UNDERSCORES
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: lowercase and lower_case_with_underscores
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: _leading and trailing_ underscores, and sometimes __doubled__ underscores
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lowercase and uppercase elements are often a single word, and sometimes a few
    words concatenated. With underscores, they are usually abbreviated phrases. Using
    a single word is better. The leading and trailing underscores are used to mark
    the privacy and special elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'These styles are applied to:'
  prefs: []
  type: TYPE_NORMAL
- en: Variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions and methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two kinds of variables in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: Constants
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Public and private variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constants
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For constant global variables, an uppercase with an underscore is used. It informs
    the developer that the given variable represents a constant value.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are no real constants in Python like those in C++, where `const` can be
    used. You can change the value of any variable. That's why Python uses a naming
    convention to mark a variable as a constant.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the `doctest` module provides a list of option flags and directives
    ([https://docs.python.org/2/library/doctest.html](https://docs.python.org/2/library/doctest.html))
    that are small sentences, clearly defining what each option is intended for:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: These variable names seem rather long, but it is important to clearly describe
    them. Their usage is mostly located in initialization code rather than in the
    body of the code itself, so this verbosity is not annoying.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Abbreviated names obfuscate the code most of the time. Don't be afraid of using
    complete words when an abbreviation seems unclear.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some constants'' names are also driven by the underlying technology. For instance,
    the `os` module uses some constants that are defined on C side, such as the `EX_XXX`
    series, that defines Unix exit code numbers. The same name code can be found,
    for example, in the system''s `sysexits.h` C headers file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Another good practice when using constants is to gather them at the top of
    a module that uses them and combine them under new variables when they are intended
    for such operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Naming and usage
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Constants are used to define a set of values the program relies on, such as
    the default configuration filename.
  prefs: []
  type: TYPE_NORMAL
- en: 'A good practice is to gather all the constants in a single file in the package.
    That is how Django works, for instance. A module named `settings.py` provides
    all the constants:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Another approach is to use a configuration file that can be parsed with the
    `ConfigParser` module, or an advanced tool such as `ZConfig`, which is the parser
    used in Zope to describe its configuration files. But some people argue that it
    is rather an overkill to use another file format in a language such as Python,
    where a file can be edited and changed as easily as a text file.
  prefs: []
  type: TYPE_NORMAL
- en: 'For options that act like flags, a common practice is to combine them with
    Boolean operations, as the `doctest` and `re` modules do. The pattern taken from
    `doctest` is quite simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'You will get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: When such a new set of constants is created, avoid using a common prefix for
    them, unless the module has several sets. The module name itself is a common prefix.
    Another solution would be to use the `Enum` class from the built-in `enum` module
    and simply rely on the `set` collection instead of the binary operators. Unfortunately,
    the `Enum` class has limited applications in code that targets old Python releases
    because the `enum` module was provided in Python 3.4 version.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using binary bit-wise operations to combine options is common in Python. The
    inclusive OR (`|`) operator will let you combine several options in a single integer,
    and the AND (`&`) operator will let you check that the option is present in the
    integer (refer to the `has_option` function).
  prefs: []
  type: TYPE_NORMAL
- en: Public and private variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For global variables that are mutable and freely available through imports,
    a lowercase letter with an underscore should be used when they need to be protected.
    But these kinds of variables are not used frequently, since the module usually
    provides getters and setters to work with them when they need to be protected.
    A leading underscore, in that case, can mark the variable as a private element
    of the package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Variables that are located in functions and methods follow the same rules, and
    are never marked as private, since they are local to the context.
  prefs: []
  type: TYPE_NORMAL
- en: For class or instance variables, using the private marker (the leading underscore)
    has to be done only if making the variable a part of the public signature does
    not bring any useful information, or is redundant.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, if the variable is used internally in the method to provide
    a public feature, and is dedicated to this role, it is better to make it private.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, the attributes that are powering a property are good private
    citizens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Another example would be a variable that keeps an internal state. This value
    is not useful for the rest of the code, but participates in the behavior of the
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is what you will see in interactive session:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Functions and methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Functions and methods should be in lowercase with underscores. This rule was
    not always true in the old standard library modules. Python 3 did a lot of reorganizations
    to the standard library, so most of its functions and methods have a consistent
    case. Still, for some modules like `threading`, you can access the old function
    names that used *mixedCase* (for example, `currentThread`). This was left to allow
    easier backwards compatibility, but if you don't need to run your code in older
    versions of Python, then you should avoid using these old names.
  prefs: []
  type: TYPE_NORMAL
- en: This way of writing methods was common before the lowercase norm became the
    standard, and some frameworks, such as Zope and Twisted, are also using *mixedCase*
    for methods. The community of developers working with them is still quite large.
    So the choice between *mixedCase* and lowercase with an underscore is definitely
    driven by the library you are using.
  prefs: []
  type: TYPE_NORMAL
- en: As a Zope developer, it is not easy to stay consistent because building an application
    that mixes pure Python modules and modules that import Zope code is difficult.
    In Zope, some classes mix both conventions because the code base is still evolving
    and Zope developers try to adopt the common conventions accepted by so many.
  prefs: []
  type: TYPE_NORMAL
- en: A decent practice in this kind of library environment is to use *mixedCase*
    only for elements that are exposed in the framework, and to keep the rest of the
    code in PEP 8 style.
  prefs: []
  type: TYPE_NORMAL
- en: It is also worth noting that developers of the Twisted project took a completely
    different approach to this problem. The Twisted project, same as Zope, predates
    the PEP 8 document. It was started when there were no official guidelines for
    code style, so it had its own. Stylistic rules about the indentation, docstrings,
    line lengths, and so on could be easily adopted. On the other hand, updating all
    the code to match naming conventions from PEP 8 would result in completely broken
    backwards compatibility. And doing that for such a large project as Twisted is
    infeasible. So Twisted adopted as much of PEP 8 as possible and left things like
    *mixedCase* for variables, functions, and methods as part of its own coding standard.
    And this is completely compatible with the PEP 8 suggestion because it specifically
    says that consistency within a project is more important than consistency with
    PEP 8 style guide.
  prefs: []
  type: TYPE_NORMAL
- en: The private controversy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For private methods and functions, a leading underscore is conventionally added.
    This rule was quite controversial because of the name-mangling feature in Python.
    When a method has two leading underscores, it is renamed on the fly by the interpreter
    to prevent a name collision with a method from any subclass.
  prefs: []
  type: TYPE_NORMAL
- en: 'So some people tend to use a double leading underscore for their private attributes
    to avoid name collision in the subclasses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The original motivation for name mangling in Python was not to provide a private
    gimmick, like in C++, but to make sure that some base classes implicitly avoid
    collisions in subclasses, especially in multiple inheritance contexts. But using
    it for every attribute obfuscates the code in private, which is not Pythonic at
    all.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, some people opined that the explicit name mangling should always
    be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This duplicates the class name all over the code and so `__` should be preferred.
  prefs: []
  type: TYPE_NORMAL
- en: But the best practice, as the **BDFL** (Guido, the **Benevolent Dictator For
    Life**, see [http://en.wikipedia.org/wiki/BDFL](http://en.wikipedia.org/wiki/BDFL))
    said, is to avoid using name mangling by looking at the `__mro__` (method resolution
    order) value of a class before writing a method in a subclass. Changing the base
    class private methods has to be done carefully.
  prefs: []
  type: TYPE_NORMAL
- en: For more information on this topic, an interesting thread occurred in the Python-Dev
    mailing list many years ago, where people argued on the utility of name mangling
    and its fate in the language. It can be found at [http://mail.python.org/pipermail/python-dev/2005-December/058555.html](http://mail.python.org/pipermail/python-dev/2005-December/058555.html).
  prefs: []
  type: TYPE_NORMAL
- en: Special methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Special methods ([https://docs.python.org/3/reference/datamodel.html#special-method-names](https://docs.python.org/3/reference/datamodel.html#special-method-names))
    start and end with a double underscore, and no normal method should use this convention.
    Some developers used to call them *dunder* methods as a portmanteau of double-underscore.
    They are used for operator overloading, container definitions, and so on. For
    the sake of readability, they should be gathered at the beginning of class definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'For a normal method, you should never use these kinds of names. So don''t invent
    a name for a method such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Arguments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Arguments are in lowercase, with underscores if needed. They follow the same
    naming rules as variables.
  prefs: []
  type: TYPE_NORMAL
- en: Properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The names of properties are in lowercase, or in lowercase with underscores.
    Most of the time, they represent an object''s state, which can be a noun or an
    adjective, or a small phrase when needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'When run on interactive session:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Classes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The names of classes are always in CamelCase, and may have a leading underscore
    when they are private to a module.
  prefs: []
  type: TYPE_NORMAL
- en: 'The class and instance variables are often noun phrases, and form a usage logic
    with the method names that are verb phrases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an example usage in interactive session:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Modules and packages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Besides the special module `__init__`, the module names are in lowercase with
    no underscores.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are some examples from the standard library:'
  prefs: []
  type: TYPE_NORMAL
- en: '`os`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sys`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`shutil`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the module is private to the package, a leading underscore is added. Compiled
    C or C++ modules are usually named with an underscore and imported in pure Python
    modules.
  prefs: []
  type: TYPE_NORMAL
- en: Package names follow the same rules, since they act like more structured modules.
  prefs: []
  type: TYPE_NORMAL
- en: The naming guide
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A common set of naming rules can be applied on variables, methods, functions,
    and properties. The names of classes and modules also play an important role in
    namespace construction, and in turn in code readability. This mini-guide provides
    common patterns and antipatterns for picking their names.
  prefs: []
  type: TYPE_NORMAL
- en: Using the has or is prefix for Boolean elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When an element holds a Boolean value, the `is` and `has` prefixes provide
    a natural way to make it more readable in its namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Using plurals for variables that are collections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When an element is holding a collection, it is a good idea to use a plural
    form. Some mappings can also benefit from this when they are exposed like sequences:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Using explicit names for dictionaries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When a variable holds a mapping, you should use an explicit name when possible.
    For example, if a `dict` holds a person''s address, it can be named `persons_addresses`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Avoiding generic names
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using terms such as `list`, `dict`, `sequence`, or `elements`, even for local
    variables, is evil if your code is not building a new abstract datatype. It makes
    the code hard to read, understand, and use. Using a built-in name has to be avoided
    as well, to avoid shadowing it in the current namespace. Generic verbs should
    also be avoided, unless they have a meaning in the namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, domain-specific terms should be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'There is also a list of prefixes and suffixes that despite being very common
    in programming should be, in fact, avoided in function and class names:'
  prefs: []
  type: TYPE_NORMAL
- en: Manager
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do, handle, or perform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The reason for this is that they are vague, ambiguous, and do not add any value
    to the actual name. Jeff Atwood, the co-founder of Discourse and Stack Overflow,
    has a very good article on this topic, which can be found on his blog at [http://blog.codinghorror.com/i-shall-call-it-somethingmanager/](http://blog.codinghorror.com/i-shall-call-it-somethingmanager/).
  prefs: []
  type: TYPE_NORMAL
- en: There is also a list of package names that should be avoided. Everything that
    does not give any clue about its content can do a lot of harm to the project in
    the long term. Names such as `misc`, `tools`, `utils`, `common`, or `core` have
    a very strong tendency to become endless bags of various unrelated code pieces
    of very poor quality that seem to grow in size exponentially. In most cases, the
    existence of such a module is a sign of laziness or lack of enough design efforts.
    Enthusiasts of such module names can simply forestall the future and rename them
    to `trash` or `dumpster` because this is exactly how their teammates will eventually
    treat such modules.
  prefs: []
  type: TYPE_NORMAL
- en: In most cases, it is almost always better to have more small modules, even with
    very little content, but with names that well reflect what is inside. To be honest,
    there is nothing inherently wrong with names such as `utils` and `common` and
    it is possible to use them responsibly. But the reality shows that in many cases
    they instead become a stub for dangerous structural antipatterns that proliferate
    very fast. And if you don't act fast enough, you may not ever be able get rid
    of them. So the best approach is simply to avoid such risky organizational patterns
    and nip them in the bud if introduced by other people working on a project.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding existing names
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is bad practice to use names that already exist in the context because it
    makes reading and, more specifically, debugging very confusing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `os` name was shadowed by the code. Both built-ins and
    module names from the standard library should be avoided.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try to create original names, even if they are local to the context. For keywords,
    a trailing underscore is a way to avoid a collision:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that `class` is often replaced by `klass` or `cls`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Best practices for arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The signatures of functions and methods are the guardians of code integrity.
    They drive its usage and build its API. Besides the naming rules that we have
    seen previously, special care has to be taken for arguments. This can be done
    through three simple rules:'
  prefs: []
  type: TYPE_NORMAL
- en: Build arguments by iterative design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Trust the arguments and your tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `*args` and `**kwargs` magic arguments carefully
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building arguments by iterative design
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Having a fixed and well-defined list of arguments for each function makes the
    code more robust. But this can't be done in the first version, so arguments have
    to be built by iterative design. They should reflect the precise use cases the
    element was created for, and evolve accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, when some arguments are appended, they should have default values
    wherever possible, to avoid any regression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: When the argument of a public element has to be changed, a deprecation process
    is to be used, which is presented later in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Trust the arguments and your tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Given the dynamic typing nature of Python, some developers use assertions at
    the top of their functions and methods to make sure the arguments have proper
    content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This is often done by developers who are used to static typing and feel that
    something is missing in Python.
  prefs: []
  type: TYPE_NORMAL
- en: This way of checking arguments is a part of the **Design by Contract** (**DbC**,
    see [http://en.wikipedia.org/wiki/Design_By_Contract](http://en.wikipedia.org/wiki/Design_By_Contract))
    programming style, where preconditions are checked before the code is actually
    run.
  prefs: []
  type: TYPE_NORMAL
- en: 'The two main problems with this approach are:'
  prefs: []
  type: TYPE_NORMAL
- en: DbC's code explains how it should be used, making it less readable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This can make it slower, since the assertions are made on each call
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The latter can be avoided with the `"-O"` option of the interpreter. In that
    case, all assertions are removed from the code before the byte code is created,
    so that the checking is lost.
  prefs: []
  type: TYPE_NORMAL
- en: In any case, assertions have to be done carefully, and should not be used to
    bend Python to a statically typed language. The only use case for this is to protect
    the code from being called nonsensically.
  prefs: []
  type: TYPE_NORMAL
- en: A healthy Test-Driven Development style provides a robust base code in most
    cases. Here, the functional and unit tests validate all the use cases the code
    is created for.
  prefs: []
  type: TYPE_NORMAL
- en: When code in a library is used by external elements, making assertions can be
    useful, as the incoming data might break things up or even create damage. This
    happens for code that deals with databases or the filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: Another approach to this is **fuzz testing** (`http://en.wikipedia.org/wiki/Fuzz_testing`),
    where random pieces of data are sent to the program to detect its weaknesses.
    When a new defect is found, the code can be fixed to take care of that, together
    with a new test.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take care that a code base, which follows the TDD approach, evolves in
    the right direction, and gets increasingly robust, since it is tuned every time
    a new failure occurs. When it is done in the right way, the list of assertions
    in the tests becomes similar in some way to the list of pre-conditions.
  prefs: []
  type: TYPE_NORMAL
- en: Using *args and **kwargs magic arguments carefully
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `*args` and `**kwargs` arguments can break the robustness of a function
    or method. They make the signature fuzzy, and the code often starts to build a
    small argument parser where it should not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: If the argument list gets long and complex, it is tempting to add magic arguments.
    But this is more a sign of a weak function or method that should be broken into
    pieces or refactored.
  prefs: []
  type: TYPE_NORMAL
- en: 'When `*args` is used to deal with a sequence of elements that are treated the
    same way in the function, asking for a unique container argument, such as an `iterator`,
    is better:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'For `**kwargs`, the same rule applies. It is better to fix the named arguments
    to make the method''s signature meaningful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Another interesting approach is to create a container class that groups several
    related arguments to provide an execution context. This structure differs from
    `*args` or `**kwargs` because it can provide internals that work over the values
    and can evolve independently. The code that uses it as an argument will not have
    to deal with its internals.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, a web request passed on to a function is often represented by
    an instance of a class. This class is in charge of holding the data passed by
    the web server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Magic arguments cannot be avoided sometimes, especially in meta-programming.
    For instance, they are indispensable in the creation of decorators that work on
    functions with any kind of signature. More globally, anywhere where working with
    unknown data that just traverses the function, the magic arguments are great:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Class names
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The name of a class has to be concise, precise, so that it is sufficient to
    understand from it what the class does. A common practice is to use a suffix that
    informs about its type or nature, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '**SQL**Engine'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mime**Types'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**String**Widget'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Test**Case'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For base or abstract classes, a **Base** or **Abstract** prefix can be used
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Base**Cookie'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Abstract**Formatter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The most important thing is to be consistent with the class attributes. For
    example, try to avoid redundancy between the class and its attributes'' names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Module and package names
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The module and package names inform about the purpose of their content. The
    names are short, in lowercase, and without underscores:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sqlite`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`postgres`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sha1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'They are often suffixed with `lib` if they are implementing a protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'They also need to be consistent within the namespace, so their usage is easier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Again, always avoid using the same name as that of one of the modules from the
    standard library.
  prefs: []
  type: TYPE_NORMAL
- en: When a module is getting complex, and contains a lot of classes, it is good
    practice to create a package and split the module's elements in other modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `__init__` module can also be used to put back some APIs at the top level
    as it will not impact its usage, but will help with re-organizing the code into
    smaller parts. For example, consider the `__init__` module in a `foo` package
    with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'This will allow users to import features directly, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: But beware that this can increase your chances to get circular dependencies,
    and that the code added in the `__init__` module will be instantiated. So use
    it with care.
  prefs: []
  type: TYPE_NORMAL
- en: Useful tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Part of the previous conventions and practices can be controlled and worked
    out with the following tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Pylint**: This is a very flexible source code analyzer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**pep8** and **flake8**: These are a small code style checker, and a wrapper
    that adds to it some more useful features, like static analysis and complexity
    measurement'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pylint
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Besides some quality assurance metrics, Pylint allows you to check whether a
    given source code is following a naming convention. Its default settings correspond
    to PEP 8, and a Pylint script provides a shell report output.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install Pylint, you can use `pip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'After this step, the command is available and can be run against a module,
    or several modules, using wildcards. Let''s try it on Buildout''s `bootstrap.py`
    script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Real Pylint's output is a bit longer and has been truncated here.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that Pylint can give you bad rates or complaints. For instance, an import
    statement that is not used by the code of the module itself is perfectly fine
    in some cases (having it available in the namespace).
  prefs: []
  type: TYPE_NORMAL
- en: Making calls to libraries that are using mixedCase for methods can also lower
    your rating. In any case, the global evaluation is not as important. Pylint is
    just a tool that points the possible improvements.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing to do to fine-tune Pylint is to create a `.pylinrc` configuration
    file in your projects directory, with the `–generate-rcfile` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This configuration file is self-documenting (every possible option is described
    with comment) and should already contain every available configuration option.
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides checking for compliance with some arbitrary coding standards, Pylint
    can also give additional information about the overall code quality, like:'
  prefs: []
  type: TYPE_NORMAL
- en: Code duplication metrics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unused variables and imports
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Missing function, method, or class docstrings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Too long function signatures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The list of available checks that are enabled by default is very long. It is
    important to know that some of the rules are arbitrary and will not easily apply
    to every codebase. Remember that consistency is always more valuable than compliance
    with some arbitrary standards. Fortunately, Pylint is very tunable, so if your
    team uses some naming and coding conventions that are different than assumed by
    default, you can easily configure it to check for consistency with these conventions.
  prefs: []
  type: TYPE_NORMAL
- en: pep8 and flake8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`pep8` is a tool that has only one purpose: it provides only a stylecheck against
    code conventions from PEP 8\. This is the main difference from Pylint, which has
    many additional features. This is the best option for programmers that are interested
    in automated code style checking only for PEP 8 standard, without any additional
    tool configuration, like in Pylint''s case.'
  prefs: []
  type: TYPE_NORMAL
- en: '`pep8` can be installed with `pip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'When run on the Buildout''s `bootstrap.py` script, it will give a short list
    of code style violations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The main difference from Pylint's output is its length. `pep8` concentrates
    only on style, so it does not provide any other warning, like unused variables,
    too long function names, or missing docstrings. It also does not give any rating.
    And it really makes sense because there is no such thing as partial consistency.
    Any, even the slightest, violation of style guidelines makes the code immediately
    inconsistent.
  prefs: []
  type: TYPE_NORMAL
- en: 'Output of `pep8` is simpler than Pylint''s and easier to parse, so it may be
    a better choice if you want to integrate it with some continuous integration solutions,
    like Jenkins. If you are missing some static analysis features, there is the `flake8`
    package that is a wrapper on `pep8` and few other tools that is easily extendable
    and provides a more extensive suite of features:'
  prefs: []
  type: TYPE_NORMAL
- en: McCabe complexity measurement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Static analysis via `pyflakes`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disabling whole files or single lines using comments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter explained the most accepted coding conventions by pointing to the
    official Python style guide (the PEP 8 document). The official style guide was
    complemented by some naming suggestions that will make your future code more explicit,
    and also a few useful tools that are indispensable in keeping the code style consistent.
  prefs: []
  type: TYPE_NORMAL
- en: All of this prepares us for the first practical topic of the book—writing and
    distributing packages. In the next chapter we will learn how to publish our very
    own package on a public PyPI repository, and also how to leverage the power of
    the packaging ecosystem in your private organization.
  prefs: []
  type: TYPE_NORMAL
