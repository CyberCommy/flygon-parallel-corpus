- en: 7\. Graph Algorithms II
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Learning Objectives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you will be able to:'
  prefs: []
  type: TYPE_NORMAL
- en: Describe the inherent problems of Dijkstra's algorithm and demonstrate how it
    can be modified and/or combined with other algorithms to circumvent those issues
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Find the shortest path in a graph using the Bellman-Ford and Johnson's algorithms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Describe the significance of strongly connected components in a garaph
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use Kosaraju's algorithm to find strongly connected components in a graph
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Describe the difference between connectivity in directed and undirected graphs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement depth-first search for complicated problems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Evaluate negative weight cycles in a graph
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter builds upon the previous chapter by introducing some more advanced
    algorithms for graphs. You will also learn how to deal with negative weights and
    handle the exceptions of negative weight cycles.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we have explored a variety of common programming structures and paradigms.
    Now, we are going to delve into several techniques that expand on the topics we
    discussed previously, beginning with an assortment of advanced graph problems,
    and then shifting focus toward the expansive subject of dynamic programming.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will discuss three well-known algorithms, namely the Bellman-Ford
    algorithm, Johnson's algorithm, and Kosaraju's algorithm. All of these algorithms
    share clear similarities with ones we have already covered in this book but extend
    and combine them in various ways to solve potentially complex problems with much
    greater efficiency than suboptimal implementations would allow. In addition to
    learning these specific techniques, this chapter should also increase your general
    familiarity with the use of fundamental graph-related techniques and provide greater
    insight into how those fundamentals can be applied to a diverse range of different
    problems.
  prefs: []
  type: TYPE_NORMAL
- en: Revisiting the Shortest Path Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We previously discussed several ways to find the shortest path between two nodes
    in a graph. We began by exploring the most standard forms of graph traversal,
    namely depth-first search and breadth-first search, and eventually discussed how
    to approach the more problematic case of graphs containing weighted edges. We
    demonstrated how Dijkstra's algorithm could be used to efficiently find the shortest
    distances in weighted graphs by greedily prioritizing each step in the traversal
    according to the best option immediately available. However, despite the improvement
    in performance that Dijkstra's algorithm provides, it is not applicable to every
    situation.
  prefs: []
  type: TYPE_NORMAL
- en: Consider a Wi-Fi signal that is being broadcast through a network; as it travels
    beyond the point at which it is originally transmitted, its strength is likely
    to be affected by numerous factors, such as the distance it travels and the number
    of walls and other obstacles it must pass through. If you wanted to determine
    the path that the signal will take to each destination that will minimize its
    deterioration, you could create a weighted graph with each point in the network
    represented by a node and the degree of signal loss between any two points represented
    by weighted edges. You could then calculate the shortest distances in the graph
    using Dijkstra's algorithm to determine the least costly paths in the network.
  prefs: []
  type: TYPE_NORMAL
- en: Now, suppose that a repeater/booster is installed in the network to increase
    the strength of the signal at a particular point – how might this addition be
    represented in your graph? The most obvious approach would be to set the outgoing
    edge weights from the booster's node to negative values (equivalent to the degree
    by which it increases the signal strength), which would decrease the total distance/deterioration
    of any path passing through it. How might this affect our results if we used Dijkstra's
    algorithm on the network's graph?
  prefs: []
  type: TYPE_NORMAL
- en: As we discussed in the previous chapter, Dijkstra's algorithm takes a greedy
    approach in terms of how it selects each vertex in the traversal. At every step,
    it finds the closest unvisited vertex and adds it to the visited set, excluding
    it from further consideration. The assumption that's being made by Dijkstra's
    algorithm is that the shortest path to every vertex that's been considered so
    far has already been found, so searching for better alternatives would be pointless.
    However, in graphs containing negative edge weights, this approach would not explore
    the possibilities that lead to the optimal solution if they produced a higher
    sum in the early stages of the traversal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider a graph with a negative edge weight, as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1: Applying Dijkstra''s algorithm to a graph with a negative weight'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14498_07_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.1: Applying Dijkstra''s algorithm to a graph with a negative weight'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'In the preceding figure, the path that''s traversed by Dijkstra''s algorithm
    is indicated in red. Assuming we start at vertex A, there will be two potential
    options after the first move from node *A* to node *B*: *B —> C*, which has an
    edge weight of *5*, and *B —> D*, which has an edge weight of *10*. Because of
    Dijkstra''s greedy approach, *C* will be chosen as the next node in the shortest
    path, but we can clearly see that the other option (*B —> D —> C = 10 + –7 = 3*)
    is actually the optimal choice.'
  prefs: []
  type: TYPE_NORMAL
- en: When faced with negative edge weights, the inherent optimizations in Dijkstra's
    algorithm that enable its high level of efficiency ultimately lead to its downfall.
    Thankfully, for such graphs, we can employ an alternative approach that is quite
    similar to Dijkstra's algorithm and arguably simpler to implement.
  prefs: []
  type: TYPE_NORMAL
- en: The Bellman-Ford Algorithm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can use the **Bellman-Ford algorithm** to handle graphs with negative weights.
    It replaces Dijkstra's method of greedy selection with an alternative approach
    of iterating across every edge in the graph *V – 1* times (where *V* is equal
    to the total number of vertices) and finding progressively optimal distance values
    from the source node across each iteration. Naturally, this gives it a higher
    asymptotic complexity than Dijkstra's algorithm, but it also allows it to produce
    correct results for graphs that Dijkstra's algorithm would misinterpret. The following
    exercise shows how to implement the Bellman-Ford algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 32: Implementing the Bellman-Ford Algorithm (Part I)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we will work with the basic Bellman-Ford algorithm to find
    the shortest distance in a graph with negative weights. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, set up your code by including the necessary libraries (as well as the
    `namespace std` for convenience):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s begin by defining a representation of the edges in our graph, which
    will require three variables: the source node''s index, the destination node''s
    index, and the cost of traversing between them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'To implement the Bellman-Ford algorithm, we will need to have some representation
    of our graph. For the sake of simplicity, let''s assume that our graph can be
    represented by an integer, `V`, the total number of vertices in the graph, and
    a vector, `edges` (a collection of pointers to ''edge'' objects that define the
    graph''s adjacencies). Let''s also define an integer constant, `UNKNOWN`, which
    we can set to some arbitrary high value that will always be greater than the sum
    of any subset of edge weights in the graph (the `INT_MAX` constant defined in
    `climits` works well for this purpose):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s also write some code for collecting the graph''s data as user input:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can start implementing the Bellman-Ford algorithm itself. For our purposes,
    let''s create a function called `BellmanFord()` that takes one argument – `start`
    (the starting node from which we want to find the shortest paths in the graph)
    – and returns `void`. Then, we will define a distance array of size `V`, with
    every element initialized to `UNKNOWN` except for the starting node, whose index
    is initialized to `0`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The bulk of the work is done in the next step, where we define a loop that
    lasts for `V – 1` iterations and iterates through the entire set of edges on every
    repetition. For each edge, we check to see whether its source node''s current
    distance value is not equal to `UNKNOWN` (which, in the first iteration, only
    applies to the starting node). Assuming this is true, we then compare the current
    distance value of its destination node to the sum of the source node''s distance
    with the weight of the edge. If the result of adding the edge weight to the current
    node''s distance is less than the stored distance of the destination node, we
    replace its value in the distance array with the new sum:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'At the end of our function, we can now iterate through the `distance` array
    and output the shortest distances from the source to every other node in the graph:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can return to our `main()` method and make a call to our newly implemented
    `BellmanFord()` function. Let''s test our implementation on the example graph
    from *figure 7.1*. To do so, we should run our code and enter the following input:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Our program should output the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, Bellman-Ford avoids the trap that would lead Dijkstra's algorithm
    to evaluate the shortest paths incorrectly. However, there is still another significant
    problem to contend with, which we will discuss in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: The Bellman-Ford Algorithm (Part II) – Negative Weight Cycles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Consider the graph shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/C14498_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.2: Graph with a negative weight cycle'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The edges highlighted in red indicate a negative weight cycle or a cycle in
    the graph where the combined edge weights produce a negative sum. In such a situation,
    this cycle would be considered repeatedly, and the final results would be skewed.
  prefs: []
  type: TYPE_NORMAL
- en: For the sake of comparison, consider a graph with only positive edge weights.
    A cycle in such a graph would never be considered in the solution because the
    shortest distance to the first node in the cycle would have been found already.
    To demonstrate this, imagine that the edge weight between nodes *B* and *D* in
    the preceding figure is positive. Starting from node *A*, the first iteration
    through the edges would determine that the shortest distance to node *B* is equal
    to *3*. After two more iterations, we would also know the shortest distance from
    *A* to *C* (*A —> B —> D —> C*), which is equal to *14* (*3 + 8 + 3*).
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, no positive number can be added to 14 that will produce a sum of
    less than 3\. As there can be at most *| V – 1 |* steps in any graph traversal
    where each node is visited only once, we can be certain that *| V – 1 |* iterations
    through the graph's edges are sufficient to determine every possible shortest
    distance. By extension, we can conclude that the only way an even shorter path
    can exist after *| V – 1 |* iterations is if a node is revisited and the edge
    weight leading to it is negative. Thus, the final step of the Bellman-Ford algorithm
    consists of performing one more iteration through the edges to check for the existence
    of such cycles.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can accomplish this with the same logic we used to find the shortest paths:
    by checking whether the sum of each edge''s weight with the distance value of
    its source node is less than the currently stored distance to its destination
    node. If a shorter path is found during this step, we terminate the algorithm
    and report the existence of a negative cycle.'
  prefs: []
  type: TYPE_NORMAL
- en: We will explore this implementation of the algorithm in the following exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 33: Implementing the Bellman-Ford Algorithm (Part II)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we will modify the implementation in *Exercise 32*, *Implementing
    the Bellman-Ford Algorithm (Part I)*, to deal with a graph with negative weight
    cycles. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can essentially copy our code from the previous step verbatim. However,
    this time, we will replace the code under the condition that determines whether
    a shorter path has been found with some sort of output indicating that the graph
    contains a negative cycle, thus rendering it invalid:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If we can still find a path shorter than the one we have already found, the
    graph must contain a negative cycle. Let''s check for a negative weight cycle
    with the following `if` statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s insert this block of code in-between the end of the first `for`
    loop and the first output line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'To test the logic we''ve added, let''s run the algorithm on the following input:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Our program should output the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Activity 15: Greedy Robot'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You are developing a pathfinding robot that must find the most efficient path
    through an obstacle course. For testing purposes, you have designed several courses,
    each in the shape of a square grid. Your robot is able to traverse any obstacle
    it encounters, but this also requires a greater expenditure of power. Assuming
    your robot starts in the top-left corner of the grid and can move in any of the
    four cardinal directions (north, south, east, and west), you must implement an
    algorithm that determines the maximum amount of energy your robot can finish the
    course with.
  prefs: []
  type: TYPE_NORMAL
- en: Since the amount of energy that's required to perform this traversal can be
    high, you have interspersed power stations throughout the grid, which your robot
    has the capability of using to recharge itself. Unfortunately, it appears that
    your robot is quite greedy in terms of energy consumption – if it can reach an
    energy station multiple times without having to backtrack, it will continually
    return to the same location until it inevitably overcharges and explodes! Because
    of this, you will need to predict whether your robot will end up revisiting a
    power station and abort the traversal attempt before disaster ensues.
  prefs: []
  type: TYPE_NORMAL
- en: '**Input**'
  prefs: []
  type: TYPE_NORMAL
- en: The first line contains a single integer, `N`, which is the height and width
    of the course.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next `N``2` `- 1` lines each contain the `directions` string and an integer
    called `power`. Each set of `N` lines corresponds to a single row, beginning from
    the top of the grid, where each cell's data is defined from left to right (for
    example, in a *3 x 3* grid, *0 —> [0, 0], 1 —> [0, 1], 2 —> [0, 2], 3 —> [1, 0],
    4 —> [1, 1]*, and so on).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`directions` contains 0-3 characters from the set { ''`N`'', ''`S`'', ''`E`'',
    ''`W`'' }, which represent the cells that your robot can visit from each point.
    Thus, if the `directions` string is `SW`, then the robot can move south or west
    from that point. `power` represents the energy expenditure required to cross the
    cell. Positive values for `power` indicate that a charging station is located
    within the cell.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Output**'
  prefs: []
  type: TYPE_NORMAL
- en: If traversing the course causes the robot to explode, print a single line –
    `TRAVERSAL ABORTED`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Otherwise, print the maximum amount of energy your robot can have upon reaching
    the bottom-right cell of the course, relative to the amount of energy it started
    with. For example, if the robot can finish the maze with 10 more units of energy
    than it started with, print `10`; if it finishes the maze with 10 fewer units
    of energy than it started with, print `-10`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Example**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say we had the following input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The grid''s layout would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3: Grid for the robot''s traversal'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14498_07_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.3: Grid for the robot''s traversal'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The path that reaches the bottom-right cell with the most energy is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Therefore, your program should output `11`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Test Cases**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following test cases should help you understand this problem better:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.4: Test case 1 for Activity 15'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14498_07_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.4: Test case 1 for Activity 15'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '![Figure 7.5: Test case 2 for Activity 15'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14498_07_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.5: Test case 2 for Activity 15'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '![Figure 7.6: Test case 3 for Activity 15'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14498_07_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.6: Test case 3 for Activity 15'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '![Figure 7.7: Test case 4 for Activity 15'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14498_07_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.7: Test case 4 for Activity 15'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '![Figure 7.8: Test case 5 for Activity 15'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14498_07_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.8: Test case 5 for Activity 15'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '**Activity Guidelines**'
  prefs: []
  type: TYPE_NORMAL
- en: No algorithms beyond what was covered in *Exercise 33*, *Implementing the Bellman-Ford
    Algorithm (Part II)*, are required.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You may need to reinterpret some of the input so that it corresponds to the
    actual problem you are trying to solve.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is no need to represent the grid as two-dimensional.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The solution to this activity can be found on page 537.
  prefs: []
  type: TYPE_NORMAL
- en: We have now established that Bellman-Ford is more versatile than Dijkstra's
    algorithm since it possesses the capability to produce correct solutions in cases
    where Dijkstra's algorithm would yield incorrect results. However, if the graph
    we are considering does not contain any negative edge weights, Dijkstra's algorithm
    is the obvious choice between the two due to the potentially significant efficiency
    advantages afforded by its greedy approach. Now, we will explore how Bellman-Ford
    can be used in conjunction with Dijkstra's algorithm so that it can be used for
    graphs with negative weights.
  prefs: []
  type: TYPE_NORMAL
- en: Johnson's Algorithm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Having compared the relative merits and disadvantages of the Bellman-Ford algorithm
    and Dijkstra's algorithm, we will now discuss an algorithm that combines both
    of them to retrieve the shortest paths between every pair of vertices in a graph.
    **Johnson's algorithm** provides us with the advantage of being able to utilize
    the efficiency of Dijkstra's algorithm while still producing correct results for
    graphs with negative edge weights.
  prefs: []
  type: TYPE_NORMAL
- en: The concept behind Johnson's algorithm is quite novel – to contend with Dijkstra's
    limitations when dealing with negative weights, Johnson's algorithm simply reweights
    the edges in the graph so they are uniformly non-negative. This is accomplished
    with the rather creative use of Bellman-Ford combined with some particularly elegant
    mathematical logic.
  prefs: []
  type: TYPE_NORMAL
- en: The first step in Johnson's algorithm is to add a new 'dummy' vertex to the
    graph, which is subsequently connected to every other vertex by zero-weighted
    edges. Bellman-Ford is then used to find the shortest paths between the new vertex
    and the rest, and the distances are stored for later use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the implications of the addition of this new vertex: because it has
    a 0-weighted edge connecting it to every other node in the graph, none of its
    shortest path distances will ever be positive. Furthermore, its connectivity to
    every node in the graph ensures that its distance values maintain a constant relation
    across all the potential traversal paths, which causes the sum that''s formed
    by these values and their corresponding edge weights to ''telescope'', in other
    words, subsequent terms in the sequence cancel each other out, making the summation
    equivalent to the difference of the first and last terms. Take a look at the following
    figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.9: Applying Johnson''s algorithm on a graph with negative weights'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14498_07_09.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.9: Applying Johnson''s algorithm on a graph with negative weights'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the preceding graph, the diamond-shaped node labeled `S` represents the dummy
    vertex, the black parenthesized numbers represent edge weights, the red text represents
    the shortest paths from `S` to each node, the orange arrows represent the optimal
    paths traversed from `S`, and the blue arrows represent 0-weighted edges branching
    from `S` that are not included in any of `S`'s shortest paths.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take the new distance values and arrange them in a sequence according
    to their appearance in this traversal of the graph – `A --> B --> C --> A -->
    D --> E`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.10: Distance for traversing at each node'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14498_07_10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.10: Distance for traversing at each node'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'If we insert the original edge weights in-between the distance values of the
    nodes they connect to, the sequence will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.11: Calculating the distance that''s been traversed'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14498_07_11.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.11: Calculating the distance that''s been traversed'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Now, let''s apply the following formula to the edge values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `w(uv)` represents the original edge weight between nodes `u` and `v`,
    `d[s, u]` and `d[s, v]` represent the shortest path distances between `S` and
    `u/v`, and `W(uv)` represents the transformed edge weight values. Applying this
    formula yields the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice how the third term in the expression is always canceled out by the middle
    term in subsequent iterations; this demonstrates the "telescoping" property of
    the formula. Because of this property, the following two expressions representing
    the distance between node A and E are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This implies that the amount of weight being added to any path in the graph
    is equal to the amount of weight being added to its subpaths. We know that the
    results of adding these values will always be non-negative because the distance
    array that's returned by Bellman-Ford ensures that we have `d[s, u] + weight(u,
    v) >= d[s, v]` for any pair, `u,v`. Thus, the value of `w(u, v) + d[s, u] - d[s,
    v]` can never be less than 0.
  prefs: []
  type: TYPE_NORMAL
- en: As a result of the applied transformation, each edge that will be traversed
    in any shortest path in the graph will be reweighted to zero, which leaves us
    with non-negative weight values that, quite remarkably, have still retained their
    original shortest path orderings! We can now perform Dijkstra's algorithm on the
    graph using these new weight values to efficiently retrieve the shortest paths
    for every pair of nodes.
  prefs: []
  type: TYPE_NORMAL
- en: We will explore the implementation of Johnson's algorithm in the following exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 34: Implementing Johnson''s Algorithm'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we will implement Johnson''s algorithm to find the shortest
    distance from each node to every other node in a graph with negative weights.
    Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can reuse most of our code from the previous exercise, including our `Edge`
    structure, `UNKNOWN` constant, and graph data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We should modify our function declaration for Bellman-Ford so that it accepts
    two arguments (an integer, `V`, and a vector or `Edge` pointers, `edges`) and
    returns an integer vector. We can also remove the `start` parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We will begin by adding the dummy vertex, `S`, to the graph. Because `S` essentially
    has no influence on the rest of the graph, this is as simple as increasing the
    distance array''s size to *| V + 1 |* and adding an edge between `S` and every
    other node:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We proceed to apply the standard implementation of Bellman-Ford to the modified
    graph, using `S` as the source node:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, let''s move the final check for negative cycles into its own function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can call it at the end of the original function and return an empty
    array if a negative cycle is found:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'After ensuring that the graph has no negative cycles, we can return the resultant
    set of distance values to the calling function and apply the reweighting formula
    to every edge in the graph. But first, let''s implement Dijkstra''s algorithm:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s declare an integer vector, `distance`, and a Boolean vector, `visited`.
    As usual, every index of `distance` will be initialized to `UNKNOWN` (except for
    the starting vertex), and every index of `visited` will be initialized to false:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Our implementation of Dijkstra''s algorithm will utilize a simple iterative
    approach using a `for` loop. As you may recall from earlier chapters, Dijkstra''s
    algorithm needs to find the node with the minimum distance value at each step
    in the traversal. While this is often done via a priority queue, we will accomplish
    this by coding another short function, `GetMinDistance()`, which will take the
    distance and visited arrays as arguments and return the index of the node with
    the shortest path value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now finish implementing Dijkstra''s algorithm:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We now have everything we need to perform Johnson''s algorithm. Let''s declare
    a new function, `Johnson()`, which also takes `V` and `edges` as arguments:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We start by creating an integer vector, `h`, and setting it to the output of
    `BellmanFord()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We check whether `h` is empty. If it is, we terminate the function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Otherwise, we apply the reweighting formula:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'To store the shortest path distances for every pair of nodes, we initialize
    a matrix with `V` rows (so that each pair of two-dimensional indices, `[i, j]`,
    represents the shortest path between vertex `i` and vertex `j`). We then perform
    `V` calls to Dijkstra''s algorithm, which returns the `distance` array for each
    starting node:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Unsurprisingly, the results we have accumulated in this step are quite inaccurate.
    Every distance value is now positive as a result of our reweighting operation.
    However, this can be rectified quite simply by applying the same formula to each
    result in reverse:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s return to our `main()` function and implement the code for handling
    input. After we have collected the edges of the input graph, we simply need to
    perform a single call to `Johnson()` and our work is done:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s test our algorithm using the following input:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should be as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the preceding output, we have successfully printed the shortest
    distance from each node to every other node.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 16: Randomized Graph Statistics'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You are a developer at a well-known software company that receives a high volume
    of new job applicants every year. As such, it is a requirement for every employee
    to participate in the process of conducting technical interviews. Before every
    interview, you are given a set of three programming problems, each containing
    a short description, and two to three test cases of increasing difficulty.
  prefs: []
  type: TYPE_NORMAL
- en: It was recently brought to your attention that a number of interviewees managed
    to acquire the test cases for certain interview questions in advance. As a result,
    the powers that be have called on you to create new sets of test cases every couple
    of weeks. Producing decent test cases for most problems is not particularly challenging,
    except for questions concerning graph theory. You have noticed that the process
    of designing a graph that is both valid and relevant to the problem can be a bit
    time-consuming, so you have become determined to automate the process.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most common graph-related interview question your company uses is the all-pairs
    shortest path problem, which requires the interviewee to find the shortest distances
    between every pair of vertices in a directed graph with weighted edges. Because
    of the nature of this problem, you want the graphs that are produced by your generator
    utility to be useful in assessing the interviewees'' understanding of the problem.
    You''ve decided that a graph will be useful for technical interviews if it meets
    the following criteria:'
  prefs: []
  type: TYPE_NORMAL
- en: It is a directed graph that can contain both positive and negative edge weights.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There should only be one edge between any pair of nodes, and no node should
    have an edge to itself.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every node should have at least one incoming or outgoing edge.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The absolute value of any edge weight should be less than 100.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The utility should take the following inputs:'
  prefs: []
  type: TYPE_NORMAL
- en: '`seed`: A seed value for random number generation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`iterations`: The number of graphs to generate'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`V`: The number of vertices'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`E`: The number of edges'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The utility should handle the generation of every edge using calls to `std::rand()`.
    In the event that it attempts to create a second edge between the same pair of
    nodes, it should stop generating new edges until a valid pair is found.
  prefs: []
  type: TYPE_NORMAL
- en: 'Graph generation should be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 1.  Receive input (`seed`, `iterations`, `V`, and `E`)
  prefs: []
  type: TYPE_NORMAL
- en: 2.  Set the random number generator's seed value
  prefs: []
  type: TYPE_NORMAL
- en: '3  For each iteration, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Set `i = 0`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: - Attempt to create an edge by performing three calls to `rand()` in order to
    generate the values for the source node, destination node, and edge weight (in
    that order).
  prefs: []
  type: TYPE_NORMAL
- en: - Check whether the next value that's generated by `rand()` is evenly divisible
    by `3;` if so, make the edge weight negative.
  prefs: []
  type: TYPE_NORMAL
- en: 'If an edge between the source and destination nodes already exists, try again:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: - Add `edge(source, destination, weight)` to the set of edges and increment
    `i`.
  prefs: []
  type: TYPE_NORMAL
- en: - If after `E` edges have been created there is a node that is not part of an
    edge, the graph is considered invalid.
  prefs: []
  type: TYPE_NORMAL
- en: If the generated graph is valid, you should find the shortest paths between
    every pair of nodes in the graph, as we would be expected to do during an interview.
    For each node in the graph, you want to find the average shortest distance across
    all of its paths (that is, the sum of distance values divided by the number of
    reachable nodes). The average distance of the graph will be defined as the average
    of these values.
  prefs: []
  type: TYPE_NORMAL
- en: You are also interested in which sets of values tend to produce the greatest
    number of "interesting" graphs. You consider graphs to be interesting when the
    average distance of the graph is less than half of that of the highest-valued
    edge weight. Your algorithm should, therefore, output the ratio of interesting
    graphs to the total number of valid graphs as a percentage (rounded to two decimal
    places). Note that for this particular purpose, you consider a connected graph
    with negative weight cycles to be valid but not interesting.
  prefs: []
  type: TYPE_NORMAL
- en: '**Input Format**'
  prefs: []
  type: TYPE_NORMAL
- en: One line containing four integers; that is, `seed`, `iterations`, `V`, and `E`,
    respectively.
  prefs: []
  type: TYPE_NORMAL
- en: '**Output Format**'
  prefs: []
  type: TYPE_NORMAL
- en: Two lines, the first containing the `INVALID:` string, followed by the number
    of invalid graphs, and the second containing the `PERCENT INTERESTING:` string,
    followed by the ratio of interesting to valid graphs, displayed as a percentage
    rounded to two decimal places.
  prefs: []
  type: TYPE_NORMAL
- en: '**Activity Guidelines**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Calls to `std::rand()` will not necessarily produce the same value in every
    environment. To ensure consistency, you can copy/paste the following code into
    your program (taken from the C standard):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: When implementing the graph generation utility, make sure that the steps are
    followed in the exact order described in the problem description.
  prefs: []
  type: TYPE_NORMAL
- en: '**Test Cases**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some sample inputs and outputs that should help you understand the
    problem better:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.12: Test cases for Activity 16'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14498_07_12.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.12: Test cases for Activity 16'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The solution to this activity can be found on page 541.
  prefs: []
  type: TYPE_NORMAL
- en: Strongly Connected Components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous chapters, we discussed several classifications of graphs. Among
    the most common ways of describing the characteristics of a graph is stating whether
    it is directed or undirected. The latter defines graphs in which the edges are
    bidirectional by default (if node A has an edge connecting to node B, then node
    B has an edge connecting to node A), while the former describes graphs with edges
    oriented toward specific 'directions'.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine you are an employee for a video hosting website and are tasked with
    producing statistics about commonalities between subscribers to various channels.
    Your company is particularly interested in discovering patterns between the individuals
    who subscribe to certain channels and the subscriptions of the channels' respective
    owners, hoping to gain greater insight into how their targeted advertising service
    should be directed. The service your company provides has become rather expansive
    recently, so you need a method of organizing the relevant data in a way that is
    clear enough to produce useful statistical information.
  prefs: []
  type: TYPE_NORMAL
- en: Let's visualize the channels of every user of the site as nodes in a directed
    graph, with the adjacencies between them representing the other channel's respective
    owner that they're subscribed to. We would likely notice that even among large
    groups of users that share subscriptions to the same channels, the amount of diversity
    in all of their individual sets of subscriptions would greatly complicate our
    ability to find any distinguishing similarities between them. Ideally, we would
    want to untangle the massive jumble of connections in our graph and place the
    data into distinct groups in which every user's subscriptions are somehow related
    to the other users'.
  prefs: []
  type: TYPE_NORMAL
- en: We can unravel the complexity of this particular problem by observing certain
    characteristics that are common to directed graphs. Because the edges of a directed
    graph are not guaranteed to be bidirectional, we can logically conclude that access
    to certain parts of the graph could potentially be restricted depending on which
    node you start traversing from. If you were to divide a graph into distinct sets
    so that any pair of vertices in the same set has a connective path between them,
    the resulting groups would represent the graph's strongly connected components.
  prefs: []
  type: TYPE_NORMAL
- en: Connectivity in Directed and Undirected Graphs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An undirected graph's connected components can be described as the set of maximum-sized
    subgraphs comprising the primary graph in which every node within the same group
    is 'connected' to the others (that is, access between any two nodes in a single
    component is unrestricted). In a connected graph, every node can be reached, regardless
    of where a traversal begins, so we can deduce that such graphs consist of a single
    connected component (the entire graph). Conversely, any graph that has restricted
    access from one point to another is described as disconnected.
  prefs: []
  type: TYPE_NORMAL
- en: 'So-called ''strong'' connectivity, on the other hand, is a characteristic that''s
    exclusive to directed graphs. To comparatively understand the difference in terms
    of how ''strong connectivity'' is defined, observe the following example of an
    undirected graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/C14498_07_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.13: Graph with different connected components'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The three colored subgraphs each represent a separate connected component. As
    we stated previously, their connectivity is defined by the fact that every vertex
    has a path connecting it to the others within the same group. Furthermore, no
    vertex from one component has a path that connects it to a different component.
    From the preceding figure, we can see that the connected components of an undirected
    graph are divided into distinctly separate groups, where the sets of nodes and
    edges of any component are cut off completely from the others.
  prefs: []
  type: TYPE_NORMAL
- en: 'Strongly connected components, by contrast, don''t need to be completely isolated
    from the other components in the graph – that is to say, paths can exist that
    overlap between components:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.14: Graph with different strongly connected components'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14498_07_14.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.14: Graph with different strongly connected components'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'In the preceding figure, we can see that there are four strongly connected
    components: *A*, *B*, *CEFG*, and *DHI*. Notice that nodes *A* and *B* are the
    only members in their respective sets. By investigating node *A* further, we can
    see that though *A* has a path to every node in the *DHI* set, none of the nodes
    in set *DHI* have any path leading to node *A*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Returning to our video hosting website example, we could define the network
    graph''s strongly connected components as groups in which every channel can be
    found by navigating through the ''path'' of subscriptions associated with other
    users'' channels within the same group. Breaking apart the potentially vast amount
    of data in this way could potentially help in isolating relevant sets of graph
    relations from those that have no distinguishing similarities:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.15: Example dataset represented as a graph with different strongly
    connected components'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14498_07_15.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.15: Example dataset represented as a graph with different strongly
    connected components'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Kosaraju's Algorithm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the most common and conceptually easy to grasp methods of finding the
    strongly connected components of a graph is Kosaraju's algorithm. Kosaraju's algorithm
    works by performing two independent sets of DFS traversals, first exploring the
    graph in its original form, and then doing the same with its transpose.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Though DFS is the type of traversal typically used in Kosaraju's algorithm,
    BFS is also a viable option. For the explanations and exercises included in this
    chapter, however, we will stick with the traditional DFS-based approach.
  prefs: []
  type: TYPE_NORMAL
- en: 'The transpose of a graph is essentially identical to the original graph, except
    that the source/destination vertices in each of its edges are swapped (that is,
    if there is an edge from node *A* to node *B* in the original graph, the transposed
    graph will have an edge from node *B* to node *A*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.16: Transpose of a graph'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14498_07_16.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.16: Transpose of a graph'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The first step of the algorithm (after initialization) is to iterate through
    the vertices of the graph and perform a DFS traversal, starting from each node
    that has not yet been visited in a previous traversal. At the beginning of each
    point in the DFS, the current node is marked as visited, and then all of its unvisited
    neighbors are explored. After each current node's adjacencies have been investigated,
    it is added to the top of a stack before the current recursive subtree is terminated.
  prefs: []
  type: TYPE_NORMAL
- en: After exploring every vertex in the original graph, the same is done with its
    transpose, starting from each unvisited node, which is popped from the top of
    the stack. At this point, the set of nodes that are encountered during each subsequent
    DFS traversal with a unique starting point represents a strongly connected component
    of the graph.
  prefs: []
  type: TYPE_NORMAL
- en: Kosaraju's algorithm is quite effective in terms of how it intuitively simplifies
    a potentially complex problem, reducing it into something rather straightforward
    to implement. Additionally, assuming that the input graph has an adjacency list
    representation, it is also quite efficient since it has a linear asymptotic complexity
    of *O(V + E)*.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The use of adjacency matrices with this algorithm is not recommended due to
    the significant amount of additional iterations required to find the neighbors
    of each vertex in the traversal.
  prefs: []
  type: TYPE_NORMAL
- en: We will take a look at the implementation of Kosarju's algorithm in the following
    exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 35: Implementing Kosaraju''s Algorithm'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we will find the strongly connected components in a graph
    using Kosaraju''s algorithm. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For our implementation of Kosaraju''s algorithm, we will need to include the
    following headers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s define a function called `Kosaraju()` that takes two arguments – an
    integer, `V`, (the number of vertices) and a vector of integer vectors, `adj`
    (an adjacency list representation of the graph) – and returns a vector of integer
    vectors representing the set of node indices in each strongly connected component
    of the input graph:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Our first step is to declare our stack container and visited array (with every
    index initialized to `false`). We then iterate through each node of the graph,
    beginning our DFS traversals at every index that has not yet been marked as `visited`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Our first DFS function, `FillStack()`, takes four arguments: an integer node
    (the index of the vertex at the current point in the traversal), a Boolean vector
    called `visited` (the set of nodes that were previously traversed), and two integer
    vectors, `adj` (the graph''s adjacency list) and `stack` (a list of visited node
    indices, ordered according to when they were explored). The last three arguments
    will be passed by reference from the calling function. The DFS is implemented
    in the standard way, except with an additional step in which the current node''s
    index is pushed to the stack at the end of each function call:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s define another function, `Transpose()`, which takes the parameters
    of the original graph as arguments and returns an adjacency list of its transpose:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'In preparation for the next set of traversals, we declare the adjacency list
    transpose (initialized to the output of our `Transpose()` function) and reinitialize
    our visited array to `false`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'For the second half of our algorithm, we will need to define our second DFS
    function, `CollectConnectedComponents()`, which takes the same arguments as `FillStack()`,
    except the fourth parameter is now replaced with a reference to an integer vector
    component. This vector component is where we will store the node indices of each
    strongly connected component in the graph. The implementation of the traversal
    is also almost identical to the `FillStack()` function, except we remove the line
    that pushes nodes to the stack. Instead, we include a line at the beginning of
    the function that collects the traversed nodes in the component vector:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Returning to our `Kosaraju()` function, we define a vector of integer vectors
    called `connectedComponents`, which is where we will store the result of each
    traversal we perform on the transpose. We then iteratively pop elements from the
    stack in a `while` loop, once again beginning each DFS traversal exclusively from
    unvisited nodes. Before each call to the DFS function, we declare the component
    vector that is referenced by `CollectConnectedComponents()` and then push it to
    `connectedComponents` upon completion of the traversal. The algorithm is complete
    when the stack is empty, after which we return `connectedComponents`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'From our `main()` function, we can now output the results of each strongly
    connected component by printing the values of each vector on a separate line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'To test the functionality of our newly implemented algorithm, let''s create
    an adjacency list representation based on the following graph:![Figure 7.17: Graphical
    representation of sample input data'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14498_07_17.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.17: Graphical representation of sample input data'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'In `main()`, `V` and `adj` would be defined as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Upon executing our program, the following output should be displayed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Activity 17: Maze-Teleportation Game'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You are designing a game where multiple players are placed randomly in a maze
    of rooms. Each room contains one or more teleportation devices that the players
    can use to travel between different parts of the maze. Every teleporter has a
    value associated with it, which is added to any player's score who uses it. Players
    alternately take turns traversing the maze until every room has been visited at
    least once, at which point the round ends and the player with the lowest score
    is the winner.
  prefs: []
  type: TYPE_NORMAL
- en: You have implemented a system that procedurally generates a new maze at the
    beginning of every game. Unfortunately, you recently discovered that some of the
    generated mazes contained loops that a player could use to endlessly reduce their
    score. You also noticed that players frequently had an unfair advantage, depending
    on the room they started in. Worst of all, the teleporters are often dispersed
    in such a way that a player can end up being cut off from the rest of the maze
    for the duration of the round.
  prefs: []
  type: TYPE_NORMAL
- en: You want to implement a testing procedure to make sure that the generated maze
    is fair and properly balanced. Your test should first determine whether the maze
    contains a path that can be used to endlessly lower a player's score. If so, it
    should output `INVALID MAZE`. If the maze is valid, you should find the lowest
    scores that can be achieved from each starting point and report them (or `DEAD
    END`, in the case of a room that has no teleporter).
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, you would like to prevent the possibility of getting stuck in
    a particular section of the maze, and so your test should also output any groups
    of rooms from which players are unable to access other portions of the maze.
  prefs: []
  type: TYPE_NORMAL
- en: '**Expected Input**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Each test should receive the following input:'
  prefs: []
  type: TYPE_NORMAL
- en: The number of rooms in the maze
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The number of teleporters in the maze
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The source room, destination room, and the number of points associated with
    each teleporter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Expected Output**'
  prefs: []
  type: TYPE_NORMAL
- en: 'For each test, the program should first determine whether there are any paths
    in the maze that can be used to infinitely reduce a player''s score. If so, it
    should print a single line: `INVALID MAZE`.'
  prefs: []
  type: TYPE_NORMAL
- en: If the maze is valid, your program should output the lowest score that can be
    achieved, starting from each room (or `DEAD END`, if the room does not have a
    teleporter), assuming that at least one move is made and that the entire maze
    can only be traversed once. Finally, your program should list any groups of rooms
    in which players can get 'stuck' (that is, they are completely restricted from
    accessing other parts of the maze); for every such group, your program should
    print the indices of all the rooms within each one on a separate line.
  prefs: []
  type: TYPE_NORMAL
- en: '**Sample Input and Output**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few sample inputs that should help you understand this problem better:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.18: Test case 1 for Activity 17'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14498_07_18.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.18: Test case 1 for Activity 17'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '![Figure 7.19: Test case 2 for Activity 17'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14498_07_19.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.19: Test case 2 for Activity 17'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '![Figure 7.20: Test case 3 for Activity 17'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14498_07_20.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.20: Test case 3 for Activity 17'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '![Figure 7.21: Test case 4 for Activity 17'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14498_07_21.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.21: Test case 4 for Activity 17'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '![Figure 7.22: Test case 5 for Activity 17'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14498_07_22.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.22: Test case 5 for Activity 17'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '![Figure 7.23: Test case 6 for Activity 3'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14498_07_23a.jpg)![Figure 7.23: Test case 6 for Activity 17'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14498_07_23b.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.23: Test case 6 for Activity 17'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '![Figure 7.24: Test case 7 for Activity 17'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14498_07_24.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.24: Test case 7 for Activity 17'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '**Activity Guidelines**'
  prefs: []
  type: TYPE_NORMAL
- en: Do not get distracted by irrelevant information. Ask yourself what specifically
    needs to be accomplished.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The first condition of the problem (determining whether or not the maze contains
    a path that can infinitely reduce our score) can also be expressed as follows:
    if the maze is represented as a weighted graph, does a cycle exist on any path
    that produces a negative sum? Clearly, this is a problem we are well-equipped
    to handle! You probably also recognize that the second condition (finding the
    minimum scores that can be acquired by a player starting at a given point) is
    closely related to the first.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last condition is a bit more challenging. Consider how you might redefine
    being "stuck" in a section of the maze according to the graph terminology we have
    discussed in this chapter. What might a maze with this property look like?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consider drawing one or several of the input graphs on paper. What characterizes
    the groups of rooms in which a player can get stuck?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The solution to this activity can be found on page 550.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing the Right Approach
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By now, it is probably apparent that there is rarely a single 'perfect' approach
    to implementing graph structures. The characteristics of the data we are representing,
    combined with the details of the problem we are trying to solve, can make certain
    approaches unreasonably inefficient, despite the fact that they may be perfectly
    acceptable under different sets of conditions.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever you are trying to determine whether to use adjacency lists versus matrices,
    classes/structs versus simple arrays, Bellman-Ford versus Johnson's algorithm,
    BFS versus DFS, and so on, the final decision should be primarily dependent upon
    the specifics of the data and how you intend to use it. For example, if you want
    to find the shortest distances between every pair of nodes in a graph, Johnson's
    algorithm would be an excellent choice. However, if you only need to sporadically
    find the shortest distances for a single starting node, Johnson's algorithm would
    perform quite a bit of unnecessary work, whereas a single call to Bellman-Ford
    would be sufficient.
  prefs: []
  type: TYPE_NORMAL
- en: It is a beneficial exercise to try writing each of the algorithms we've discussed
    in this chapter using different forms of graph representations. For example, Bellman-Ford
    can be just as easily implemented by replacing the vector of `Edge` pointers that
    we used in the first exercise with an adjacency list and a two-dimensional matrix
    of edge weights. In some cases, the efficiency potential that's offered by one
    implementation may only be marginally better than another; at other times, the
    difference can be quite significant. And then, sometimes, the value of a certain
    approach has more to do with simplicity and readability than any measurable performance
    benchmark. Comparing how the performance of various algorithms scales across different
    data sets and scenarios can be very informative and is often an essential practice
    in real-world development.
  prefs: []
  type: TYPE_NORMAL
- en: 'In your endeavors to develop a better understanding of graph theory and implementation,
    we offer the following recommendations:'
  prefs: []
  type: TYPE_NORMAL
- en: Resist the urge to use the 'copy-paste' approach to implementing a new algorithm.
    If you do not understand the underlying principles behind why an algorithm works,
    you will have a very high likelihood of using it incorrectly. Furthermore, even
    if it functions the way you want it to, it is important to remember that graph
    implementations are highly specific to the context. Blindly using any algorithm
    means you will lack the understanding that's necessary to extend the functionality
    of the solution across different sets of parameters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When putting new concepts into practice, avoid relying entirely on abstract,
    non-contextual implementations. After using a certain algorithm on purely theoretical
    data, try to modify it to fit some sort of actual data model (even if that data
    itself is hypothetical). Imagining real scenarios in which you can use your newly
    acquired algorithmic knowledge will increase the probability that you will know
    when and how to use it on the job.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Avoid implementing your graph before you have really considered the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Its fundamental purpose(s) and the essential functionality required to accomplish
    that purpose (that is, the data it describes, the types of queries it needs to
    perform, how dynamic it needs to be, and so on)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The most basic components it needs to represent the relevant information about
    the problem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Failure to evaluate these key ideas could lead to cluttered and overly verbose
    code, packed with unnecessary data and functions that essentially contribute nothing
    of value to the actual solution. Planning out the necessary components of your
    graph prior to writing any code will potentially save you quite a bit of confusion
    and tedious refactoring.
  prefs: []
  type: TYPE_NORMAL
- en: Ultimately, developing a comprehensive understanding of graph programming is
    a skill that extends far beyond the scope of simply learning all the right algorithms.
    A simple web search related to any non-trivial graphing problem will lead to a
    plethora of deeply analytical research articles, a comparative evaluation of different
    approaches, and conjectured solutions for which a reasonable implementation has
    yet to be discovered. As always, consistent practice is the best method for mastering
    any programming skillset; and graph theory, being a vast and dynamic subject of
    study, is certainly no exception!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we have covered graphs in fairly comprehensive detail. You should now
    have a solid understanding of some of the basic uses of graph theory in software
    development, as well as an appreciation for how graph-based solutions can be used
    to encapsulate complex data in a way that allows us to query and manipulate it
    with relative ease. Having learned the fundamentals of graph structures and traversals
    in *Chapter 6*, *Graph Algorithms I*, and then extended them to solve more advanced
    problems in this chapter, you should now be well-equipped to explore much deeper
    graph implementations in the future since these basic concepts are at the core
    of all of them.
  prefs: []
  type: TYPE_NORMAL
- en: Though this chapter does not completely conclude our discussion of graph algorithms
    for this book, we will now take a break from graphs to explore one of the most
    powerful and challenging programming techniques in the modern developer's repertoire.
    Like graph algorithms, the subject we will cover next is so expansive and conceptually
    abstract that it will span two separate chapters. However, because of its usefulness
    (and its difficulty), it is a favorite of many software companies during technical
    interviews.
  prefs: []
  type: TYPE_NORMAL
