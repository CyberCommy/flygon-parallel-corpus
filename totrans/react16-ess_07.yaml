- en: Chapter 7. Updating Your React Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, you learned that a React component can go through
    three phases:'
  prefs: []
  type: TYPE_NORMAL
- en: Mounting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unmounting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We've already discussed the mounting and unmounting phases. In this chapter,
    we'll focus on the updating phase. During this phase, a React component is already
    inserted into the DOM. This DOM represents a component's current state, and when
    that state changes, React needs to evaluate how a new state is going to mutate
    the previously rendered DOM.
  prefs: []
  type: TYPE_NORMAL
- en: React provides us with methods to influence what is going to be rendered during
    an update as well as to be aware of when an update happens. These methods allow
    us to control the transition from the current component's state to the next component's
    state. Let's learn more about the powerful nature of the React component's updating
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding component lifecycle updating methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A React component has five lifecycle methods that belong to a component''s
    *updating* phase:'
  prefs: []
  type: TYPE_NORMAL
- en: '`componentWillReceiveProps()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`shouldComponentUpdate()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`componentWillUpdate()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`render()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`componentDidUpdate()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'See the following figure for a better view:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding component lifecycle updating methods](graphics/B05915_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You're already familiar with the `render()` method. Now let's discuss the other
    four methods.
  prefs: []
  type: TYPE_NORMAL
- en: The componentWillReceiveProps method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ll start with the `componentWillReceiveProps()` method in the `StreamTweet`
    component. Add the following code after the `componentDidMount()` method in the
    `StreamTweet.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This method is invoked first in the component lifecycle's updating phase. It
    is called when a component receives new properties from its parent component.
  prefs: []
  type: TYPE_NORMAL
- en: This method is an opportunity for us to compare the current component's properties,
    using the `this.props` object, with the next component's properties, using the
    `nextProps` object. Based on this comparison, we can choose to update the component's
    state using the `this.setState()` function, which will not trigger an additional
    render in this scenario.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see that in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We first get the lengths of the current tweet and the next tweet. The current
    one is available via `this.props.tweet` and the next one via `nextProps.tweet`.
    We then compare their lengths by checking whether the next tweet is longer than
    the current one. The result of the comparison is stored in the `isNumberOfCharactersIncreasing`
    variable. Finally, we update the component's state by setting the `numberOfCharactersIsIncreasing`
    property to the value of our `isNumberOfCharactersIncreasing` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then set our header text as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: If the next tweet is longer, we set the header text to `'Number of characters
    is increasing'`, or else, we set it to `'Latest public photo from Twitter'`. We
    then update our component's state once more by setting the `headerText` property
    to the value of our `headerText` variable.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we call the `this.setState()` function twice in our `componentWillReceiveProps()`
    method. This is to illustrate the point that no matter how many times you call
    `this.setState()` in the `componentWillReceiveProps()` method, it won't trigger
    any additional renders of that component. React does an internal optimization,
    where it batches the state updates together.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the `componentWillReceiveProps()` method will be called once for each
    new tweet that our `StreamTweet` component will receive, it makes it a good place
    to count the total number of received tweets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now we know how to check whether the next tweet is longer than the tweet we're
    currently displaying, but how can we choose not to render the next tweet at all?
  prefs: []
  type: TYPE_NORMAL
- en: The shouldComponentUpdate method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `shouldComponentUpdate()` method allows us to decide whether the next component''s
    state should trigger the component''s re-rendering or not. This method returns
    a Boolean value, which by default is `true`, but you can return `false`, and the
    following component methods won''t be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '`componentWillUpdate()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`render()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`componentDidUpdate()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Skipping a call to the component's `render()` method will prevent that component
    from re-rendering, which in turn will improve your application's performance,
    since no additional DOM mutations will be made.
  prefs: []
  type: TYPE_NORMAL
- en: This method is invoked second in the component lifecycle's updating phase.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is a great place for us to prevent the next tweet with one or less
    characters from being displayed. Add this code to the `StreamTweet` component
    after the `componentWillReceiveProps()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: If the next tweet's length is greater than 1, then `shouldComponentUpdate()`
    returns `true`, and the `StreamTweet` component renders the next tweet. Or else,
    it returns `false`, and the `StreamTweet` component doesn't render the next state.
  prefs: []
  type: TYPE_NORMAL
- en: The componentWillUpdate method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `componentWillUpdate()` method is called *immediately before* React updates
    the DOM. It gets the following two arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '`nextProps`: The next properties object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nextState`: The next state object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use these arguments to prepare for the DOM update. However, you cannot
    use `this.setState()` in the `componentWillUpdate()` method. If you want to update
    the component's state in response to its properties changing, then do that in
    the `componentWillReceiveProps()` method, which will be called by React when the
    properties change.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate when the `componentWillUpdate()` method is called, we need to
    log it in the `StreamTweet` component. Add this code after the `shouldComponentUpdate()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: After calling the `componentWillUpdate()` method, React invokes the `render()`
    method that performs the DOM update. Then, the `componentDidUpdate()` method is
    called.
  prefs: []
  type: TYPE_NORMAL
- en: The componentDidUpdate method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `componentDidUpdate()` method is called *immediately after* React updates
    the DOM. It gets these two arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '`prevProps`: The previous properties object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`prevState`: The previous state object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will use this method to interact with the updated DOM or perform any post-render
    operations. In our `StreamTweet` component, we''ll use `componentDidUpdate()`
    to increment the number of displayed tweets in our global object. Add this code
    after the `componentWillUpdate()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: After `componentDidUpdate()` is called, the updating cycle ends. A new cycle
    is started when a component's state is updated or a parent component passes new
    properties. Or when you call the `forceUpdate()` method, it triggers a new updating
    cycle, but skips the `shouldComponentUpdate()` method on a component that triggered
    the update. However, `shouldComponentUpdate()` is called on all child components
    as per the usual updating phase. Try to avoid using the `forceUpdate()` method
    as much as possible; this will promote your application's maintainability.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes our discussion of React component lifecycle methods.
  prefs: []
  type: TYPE_NORMAL
- en: Setting default React component properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As you know from the previous chapter, our `StreamTweet` component renders
    two child components: `Header` and `Tweet`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create these components. To do this, navigate to `~/snapterest/source/components/`
    and create the `Header.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, our `Header` component is a stateless component that renders
    the `h2` element. The header text is passed from a parent component as a `this.props.text`
    property, which makes this component flexible, that allows us to reuse it anywhere
    where we need a header. We'll reuse this component again later in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the `h2` element has a `style` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'In React, we can define the CSS rules in a JavaScript object, and then pass
    that object as a value to the React element''s `style` property. For example,
    in this component, we define the `headerStyle` variable that references an object
    where:'
  prefs: []
  type: TYPE_NORMAL
- en: Each object key is a CSS property
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each object value is a CSS value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The CSS properties that contain a hyphen in their names should be converted
    to the **camelCase** style; for example, `font-size` becomes `fontSize` and `font-weight`
    becomes `fontWeight`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The advantages of defining your CSS rules inside a React component are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Portability**: You can easily share a component together with its styling,
    all in one JavaScript file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Encapsulation**: Making styles inline allows you to limit the scope of what
    they affect'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flexibility**: The CSS rules can be calculated using the power of JavaScript'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The significant disadvantage of using this technique is the fact that **Content
    Security Policies** (**CSP**) can block inline styling from having any effect.
    You can learn more about CSP at [https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP](https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP).
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `Header` component has one property that we haven''t discussed yet, that
    is, `defaultProps`. What if you forget to pass a property that a React component
    depends on? In that case, a component can set the default properties using the
    `defaultProps` property; consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we're setting a default value of `'Default header'` to our
    `text` property. If a parent component passes the `this.props.text` property,
    then it will overwrite the default one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s create our `Tweet` component. To do this, navigate to `~/snapterest/source/components/`
    and create the `Tweet.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This component renders a `<div>` element with a child `<img>` element. Both
    the elements have inline styles, and the `<img>` element has a click event handler,
    that is, `this.handleImageClick`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: When a user clicks on a tweet's image, the `Tweet` component checks whether
    a parent component has passed a `this.props.onImageClick` callback function as
    a property and calls that function. The `this.props.onImageClick` property is
    an optional `Tweet` component's property, so we need to check whether it was passed
    before we can use it. On the other hand, `tweet` is a required property.
  prefs: []
  type: TYPE_NORMAL
- en: How can we ensure that a component receives all the required properties?
  prefs: []
  type: TYPE_NORMAL
- en: Validating React component properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In React, there is a way to validate the component properties using the component''s
    `propTypes` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In this object, you need to specify a property name and a validator function
    that will determine whether a property is valid or not. React provides some predefined
    validators for you to reuse. They are all available in the `PropTypes` object
    from the `prop-types` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '`PropTypes.number`: This will validate whether a property is a number or not'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PropTypes.string`: This will validate whether a property is a string or not'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PropTypes.bool`: This will validate whether a property is a Boolean or not'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PropTypes.object`: This will validate whether a property is an object or not'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PropTypes.element`: This will validate whether a property is a React element
    or not'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a complete list of the `PropTypes` validators, you can check the docs at
    [https://facebook.github.io/react/docs/typechecking-with-proptypes.html](https://facebook.github.io/react/docs/typechecking-with-proptypes.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, all the properties that you validate with the `PropTypes` validators
    are optional. You can chain any of them with `isRequired` to make sure that a
    warning message is displayed on a JavaScript console when a property is missing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also specify your own custom validator function that should return
    an `Error` object if the validation fails:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a look at the `propTypes` object in our `Tweet` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we''re validating two `Tweet` component properties: `tweet`
    and `onImageClick`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We use the custom validator function to validate the `tweet` property. React
    passes three parameters to this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '`properties`: This is the component properties object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`propertyName`: This is the name of the property that we''re validating'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`componentName`: This is the name of the component'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We first check whether our `Tweet` component received the `tweet` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we assume that the `tweet` property is an object, and check whether that
    object has no `media` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Both of these checks return an `Error` object that will be logged in a JavaScript
    console.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another `Tweet` component''s property that we will validate is `onImageClick`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We validate that the value of the `onImageClick` property is a function. In
    this case, we reuse a validator function provided by the `PropTypes` object. As
    you can see, `onImageClick` is an optional property because we didn't add `isRequired`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, for performance reasons, `propTypes` is only checked in the development
    version of React.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Collection component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You might recall that our topmost hierarchy `Application` component has two
    child components: `Stream` and `Collection`.'
  prefs: []
  type: TYPE_NORMAL
- en: So far, we've discussed and implemented our `Stream` component and its child
    components. Next, we're going to focus on our `Collection` component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `~/snapterest/source/components/Collection.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `Collection` component is responsible for rendering two things:'
  prefs: []
  type: TYPE_NORMAL
- en: Tweets that the user has collected
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User interface control elements for manipulating that collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s take a look at the component''s `render()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We first get a number of tweets in the collection using the `this.getNumberOfTweetsInCollection()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This method, in turn, uses another method to get a list of tweet IDs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `this.getListOfTweetIds()` function call returns an array of tweet IDs,
    and then `this.getNumberOfTweetsInCollection()` returns a length of that array.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our `render()` method, once we know the number of tweets in our collection,
    we have to make a choice:'
  prefs: []
  type: TYPE_NORMAL
- en: If the collection is *not* empty, then render the `CollectionControls` and `TweetList`
    components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Otherwise, render the `Header` component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What do all these components render?
  prefs: []
  type: TYPE_NORMAL
- en: The `CollectionControls` component renders a header with a collection name and
    a set of buttons that allow users to rename, empty, and export a collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `TweetList` component renders a list of tweets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Header` component simply renders a header with a message that the collection
    is empty
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The idea is to only show a collection when it''s not empty. In that case, we''re
    creating four variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `tweets` variable references our `tweets` property that is passed from a
    parent component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `htmlMarkup` variable references a string that is returned by the component's
    `this.createHtmlMarkupStringOfTweetList()` function call
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `onRemoveAllTweetsFromCollection` and `onRemoveTweetFromCollection` variables
    reference functions that are passed from a parent component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As the name suggests, the `this.createHtmlMarkupStringOfTweetList()` method
    creates a string that represents the HTML markup created by rendering the `TweetList`
    component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The `createHtmlMarkupStringOfTweetList()` method uses the `ReactDOMServer.renderToStaticMarkup()`
    function that we discussed in [Chapter 3](ch03.html "Chapter 3. Creating Your
    First React Element"), *Creating Your First React Element*. We pass the `TweetList`
    component as its argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This `TweetList` component has a `tweets` property that references the `tweets`
    property passed by a parent component.
  prefs: []
  type: TYPE_NORMAL
- en: The resulting HTML string produced by the `ReactDOMServer.renderToStaticMarkup()`
    function is stored in the `htmlString` variable. Then, we create a new `htmlMarkup`
    object with the `html` property that references our `htmlString` variable. Finally,
    we use the `JSON.stringify()` function to convert our `htmlMarkup` JavaScript
    object to a JSON string. The result of the `JSON.stringify(htmlMarkup)` function
    call is what our `createHtmlMarkupStringOfTweetList()` method returns.
  prefs: []
  type: TYPE_NORMAL
- en: This method demonstrates how flexible React components are; you can use the
    same React components to render the DOM elements as well as produce a string of
    HTML markup that can be passed to a third-party API.
  prefs: []
  type: TYPE_NORMAL
- en: Another interesting observation that one can make is the use of JSX syntax outside
    a `render()` method. In fact, you can use JSX anywhere in your source file, even
    outside of component class declarations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a closer look at what the `Collection` component returns when our
    collection is *not* empty:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We wrap the `CollectionControls` and `TweetList` components in the `<div>` element
    because React allows only one root element. Let's take a look at each component
    and discuss its properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'We pass the following three properties to the `CollectionControls` component:'
  prefs: []
  type: TYPE_NORMAL
- en: The `numberOfTweetsInCollection` property references the current number of tweets
    in our collection.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `htmlMarkup` property references a string of HTML markup that we produce
    in this component using the `createHtmlMarkupStringOfTweetList()` method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `onRemoveAllTweetsFromCollection` property references a function that removes
    all the tweets from our collection. This function is implemented in the `Application`
    component and discussed in [Chapter 5](ch05.html "Chapter 5. Making Your React
    Components Reactive"), *Making Your React Components Reactive*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We pass these two properties to the `TweetList` component:'
  prefs: []
  type: TYPE_NORMAL
- en: The `tweets` property references tweets passed from a parent `Application` component.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `onRemoveTweetFromCollection` property references a function that removes
    a tweet from a collection of tweets that we store in the `Application` component's
    state. We have already discussed this function in [Chapter 5](ch05.html "Chapter 5. Making
    Your React Components Reactive"), *Making Your React Components Reactive*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And that's our `Collection` component.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about the updating methods of the lifecycle of
    a component. We also discussed how to validate the component properties and set
    default property values. We also made good progress with our Snapterest application;
    we created and discussed the `Header`, `Tweet`, and `Collection` components.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll focus on building more complex React components and
    finish building our Snapterest application!
  prefs: []
  type: TYPE_NORMAL
