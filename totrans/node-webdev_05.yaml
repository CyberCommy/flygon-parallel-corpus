- en: HTTP Servers and Clients
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP服务器和客户端
- en: Now that you've learned about Node.js modules, it's time to put this knowledge
    to use by building a simple Node.js web application. The goal of this book is
    to learn about web application development with Node.js. The next step in that
    journey is getting a basic understanding of the `HTTPServer` and `HTTPClient`
    objects. To do that, we'll create a simple application that will enable us to
    explore a popular application framework for Node.js—Express. In later chapters,
    we'll do more complex work on the application, but before we can walk, we must
    learn to crawl.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了Node.js模块，是时候将这些知识应用到构建一个简单的Node.js web应用程序中了。本书的目标是学习使用Node.js进行web应用程序开发。在这个过程中的下一步是对`HTTPServer`和`HTTPClient`对象有一个基本的了解。为了做到这一点，我们将创建一个简单的应用程序，使我们能够探索Node.js中一个流行的应用程序框架——Express。在后面的章节中，我们将在应用程序上做更复杂的工作，但在我们能够行走之前，我们必须学会爬行。
- en: The goal of this chapter is to start to understand how to create applications
    on the Node.js platform. We'll create a handful of small applications, which means
    we'll be writing code and talking about what it does. Beyond learning about some
    specific technologies, we want to get comfortable with the process of initializing
    a work directory, creating the Node.js code for an application, installing dependencies
    required by the application, and running/testing the application.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标是开始了解如何在Node.js平台上创建应用程序。我们将创建一些小型的应用程序，这意味着我们将编写代码并讨论它的作用。除了学习一些具体的技术之外，我们还希望熟悉初始化工作目录、创建应用程序的Node.js代码、安装应用程序所需的依赖项以及运行/测试应用程序的过程。
- en: The Node.js runtime includes objects such as `EventEmitter`, `HTTPServer`, and
    `HTTPClient`, which provide a foundation on which we can build applications. Even
    if we rarely use these objects directly, it is useful to understand how they work,
    and in this chapter, we will cover a couple of exercises using these specific
    objects.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js运行时包括诸如`EventEmitter`、`HTTPServer`和`HTTPClient`等对象，它们为我们构建应用程序提供了基础。即使我们很少直接使用这些对象，了解它们的工作原理也是有用的，在本章中，我们将涵盖使用这些特定对象的一些练习。
- en: We'll first build a simple application directly using the `HTTPServer` object.
    Then, we'll move on to using Express to create an application for computing Fibonacci
    numbers. Because this can be computationally expensive, we'll use this to explore
    why it's important to not block the event queue in Node.js and what happens to
    applications that do. This will give us an excuse to develop a simple background
    **Representational State Transfer** (**REST**) server, an HTTP client for making
    requests on that server, and the implementation of a multi-tier web application.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先直接使用`HTTPServer`对象构建一个简单的应用程序。然后，我们将使用Express来创建一个计算斐波那契数的应用程序。因为这可能是计算密集型的，我们将利用这一点来探讨为什么在Node.js中不阻塞事件队列是重要的，以及对这样做的应用程序会发生什么。这将给我们一个借口来开发一个简单的后台REST服务器，一个用于在服务器上发出请求的HTTP客户端，以及一个多层web应用程序的实现。
- en: In today's world, the microservice application architecture implements background
    REST servers, which is what we'll do in this chapter.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在今天的世界中，微服务应用架构实现了后台REST服务器，这就是我们在本章中要做的事情。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Sending and receiving events using the `EventEmitter` pattern
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`EventEmitter`模式发送和接收事件
- en: Understanding an HTTP server application by building a simple application
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过构建一个简单的应用程序来理解HTTP服务器应用程序
- en: Web application frameworks
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web应用程序框架
- en: Using the Express framework to build a simple application
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Express框架构建一个简单的应用程序
- en: Handling computationally intensive calculations in an Express application and
    the Node.js event loop
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Express应用程序中处理计算密集型计算和Node.js事件循环。
- en: Making HTTP Client requests
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发出HTTP客户端请求
- en: Creating a simple REST service with Express
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Express创建一个简单的REST服务
- en: By going through these topics, you'll gain an understanding of several aspects
    of designing HTTP-based web services. The goal is for you to understand how to
    create or consume an HTTP service and to get an introduction to the Express framework.
    By the end of this chapter, you'll have a basic understanding of these two tools.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 通过学习这些主题，你将了解设计基于HTTP的web服务的几个方面。目标是让你了解如何创建或消费一个HTTP服务，并对Express框架有一个介绍。在本章结束时，你将对这两个工具有一个基本的了解。
- en: That's a lot to cover, and it will give us a good foundation for the rest of
    this book.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这是很多内容，但这将为本书的其余部分奠定一个良好的基础。
- en: Sending and receiving events with EventEmitter
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用EventEmitter发送和接收事件
- en: '`EventEmitter` is one of the core idioms of Node.js. If Node.js''s core idea
    is an event-driven architecture, emitting events from an object is one of the
    primary mechanisms of that architecture. `EventEmitter` is an object that gives
    notifications (events) at different points in its life cycle. For example, an
    `HTTPServer` object emits events concerning each stage of the startup/shutdown
    of the Server object and at each stage of processing HTTP requests from HTTP clients.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`EventEmitter`是Node.js的核心习语之一。如果Node.js的核心思想是事件驱动的架构，那么从对象中发出事件是该架构的主要机制之一。`EventEmitter`是一个在其生命周期的不同阶段提供通知（事件）的对象。例如，一个`HTTPServer`对象会发出与服务器对象的启动/关闭以及处理来自HTTP客户端的HTTP请求的每个阶段相关的事件。'
- en: Many core Node.js modules are `EventEmitter` objects, and `EventEmitter` objects
    are an excellent skeleton on which to implement asynchronous programming. `EventEmitter`
    objects are so much a part of the Node.js woodwork that you may skip over their
    existence. However, because they're used everywhere, we need some understanding
    of what they are and how to use them when necessary.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 许多核心的Node.js模块都是`EventEmitter`对象，而`EventEmitter`对象是实现异步编程的一个很好的基础。`EventEmitter`对象在Node.js中非常常见，以至于你可能会忽略它们的存在。然而，因为它们随处可见，我们需要了解它们是什么，以及在必要时如何使用它们。
- en: In this chapter, we'll work with the `HTTPServer` and `HTTPClient` objects.
    Both are subclasses of the `EventEmitter` class and rely on it to send events
    for each step of the HTTP protocol. In this section, we'll first learn about using
    JavaScript classes, and then we will create an `EventEmitter` subclass so that
    we can learn about `EventEmitter`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript classes and class inheritance
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before getting started on the `EventEmitter` class, we need to take a look
    at another one of the ES2015 features: classes. JavaScript has always had objects
    and the concept of a class hierarchy, but nothing as formal as in other languages.
    The ES2015 class object builds on the existing prototype-based inheritance model,
    but with a syntax that looks a lot like class definitions in other languages.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider the following class, which we''ll be using later in this
    book:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]js\1'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: 'Functions marked with the `get` or `set` keywords are getters and setters,
    used as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]js\1'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you declare a subclass using the `extends` operator, similar to how
    you would in other languages:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]js\1'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: This is an ES6 module that defines a class named `Pulser`. The class inherits
    from `EventEmitter` and provides a few methods of its own.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: Another thing to examine is how `this.emit` in the callback function refers
    to the `Pulser` object instance. This implementation relies on the ES2015 arrow
    function. Before arrow functions, our callbacks used a regular function, and `this`
    would not have referred to the `Pulser` object instance. Instead, `this` would
    have referred to some other object related to the `setInterval` function. One
    of the attributes of arrow functions is that `this` inside the arrow function
    has the same value as `this` in the surrounding context. This means, in this case,
    that `this` does refer to the `Pulser` object instance.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: 'Back when we had to use `function`, rather than an arrow function, we had to
    assign `this` to another variable, as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]js\1'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of the `Pulser` class is to send a timed event once a second to
    any listeners. The `start` method uses `setInterval` to kick off a repeated callback
    execution that is scheduled for every second and calls `emit` to send the `pulse`
    events to any listeners.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s see how we can use the `Pulser` object. Create a new file called
    `pulsed.mjs`, containing the following code:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]js\1'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: For each `pulse` event received, a `pulse received` message is printed.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: That gives you a little practical knowledge of the `EventEmitter` class. Let's
    now look at its operational theory.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: The EventEmitter theory
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the `EventEmitter` class, your code emits events that other code can receive.
    This is a way of connecting two separated sections of your program, kind of like
    how quantum entanglement means two electrons can communicate with each other from
    any distance. It seems simple enough.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: The event name can be anything that makes sense to you, and you can define as
    many event names as you like. Event names are defined simply by calling `.emit`
    with the event name. There's nothing formal to do and no registry of event names
    is required. Simply making a call to `.emit` is enough to define an event name.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: By convention, the `error` event name indicates an error.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: An object sends events using the `.emit` function. Events are sent to any listeners
    that have registered to receive events from the object. The program registers
    to receive an event by calling that object's `.on` method, giving the event name
    and an event handler function.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: There is no central distribution point for all events. Instead, each instance
    of an `EventEmitter` object manages its own set of listeners and distributes its
    events to those listeners.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: 'Often, it is required to send data along with an event. To do so, simply add
    the data as arguments to the `.emit` call, as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]js\1'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: There is no handshaking between event receivers and the event sender. That is,
    the event sender simply goes on with its business and it gets no notifications
    about any events that were received, any action taken, or any errors that occurred.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we used another one of the ES2015 features—the `rest` operator—used
    here in the form of `...theArgs.` The `rest` operator catches any number of remaining
    function parameters into an array. Since `EventEmitter` can pass along any number
    of parameters and the `rest` operator can automatically receive any number of
    parameters, it's a match made in heaven—or at least in the TC-39 committee.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: We've now learned how to use JavaScript classes and how to use the `EventEmitter`
    class. What's next is examining how the `HTTPServer` object uses `EventEmitter`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Understanding HTTP server applications
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `HTTPServer` object is the foundation of all Node.js web applications. The
    object itself is very close to the HTTP protocol, and its use requires knowledge
    of this protocol. Fortunately, in most cases, you'll be able to use an application
    framework, such as Express, to hide the HTTP protocol details. As application
    developers, we want to focus on business logic.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: 'We already saw a simple HTTP server application in [Chapter 2](bd2253cb-6a41-4fc5-ae86-cc9632d44da4.xhtml),
    *Setting Up Node.js. *Because `HTTPServer` is an `EventEmitter` object, the example
    can be written in another way to make this fact explicit by separately adding
    the event listener:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]js\1'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: 'The `request` event is emitted by `HTTPServer` every time a request arrives
    from a web browser. In this case, we want to respond differently based on the
    request URL, which arrives as `req.url`. This value is a string containing the
    URL from the HTTP request. Since there are many attributes to a URL, we need to
    parse the URL so that we can correctly match the pathname for one of two paths:
    `/` and `/osinfo`.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Parsing a URL with the URL class requires a **base URL**, which we've supplied
    in the `listenOn` variable. Notice how we're reusing this same variable in a couple
    of other places, using one string to configure multiple parts of the application.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the path, either the `homePage` or `osInfo` functions are called.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: This is called **request routing**, where we look at attributes of the incoming
    request, such as the request path, and route the request to handler functions.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: In the handler functions, the `req` and `res` parameters correspond to the `request` and `response` objects.
    Where `req` contains data about the incoming request, we send the response using
    `res`. The `writeHead` function sets up the return status (`200` means success,
    while `404` means the page is not found) and the `end` function sends the response.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: If the request URL is not recognized, the server sends back an error page using
    a `404` result code. The result code informs the browser about the status of the
    request, where a `200` code means everything is fine and a `404` code means the
    requested page doesn't exist. There are, of course, many other HTTP response codes,
    each with their own meaning.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: There are plenty more functions attached to both objects, but that's enough
    to get us started.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: 'To run it, type the following command:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]js\1'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: 'Before ES2015, one way to implement a multiline string was to use the following
    construct:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]js\1'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: This is more succinct and straightforward. The opening quote is on the first
    line, the closing quote is on the last line, and everything in between is part
    of our string.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: The real purpose of the template strings feature is to support easily substituting
    values directly into strings. Many other programming languages support this ability,
    and now JavaScript does, too.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: 'Pre-ES2015, a programmer would have written their code like this:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]js\1'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: Within a template string, the part within the `${ .. }` brackets is interpreted
    as an expression. This can be a simple mathematical expression, a variable reference,
    or, as in this case, a function call.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在模板字符串中，`${..}`括号中的部分被解释为表达式。这可以是一个简单的数学表达式、一个变量引用，或者在这种情况下，一个函数调用。
- en: Using template strings to insert data carries a security risk. Have you verified
    that the data is safe? Will it form the basis of a security attack? As always,
    data coming from an untrusted source, such as user input, must be properly encoded
    for the target context where the data is being inserted. In the example here,
    we should have used a function to encode this data as HTML, perhaps. But for this
    case, the data is in the form of simple strings and numbers and comes from a known,
    safe data source—the built-in `os` module—and so we know that this application
    is safe.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模板字符串插入数据存在安全风险。您是否验证了数据的安全性？它会成为安全攻击的基础吗？与始终如一的数据来自不受信任的来源，如用户输入，必须为数据要插入的目标上下文正确编码。在这个例子中，我们应该使用一个函数来将这些数据编码为HTML，也许。但是对于这种情况，数据是简单的字符串和数字形式，并来自已知的安全数据源——内置的`os`模块，因此我们知道这个应用程序是安全的。
- en: For this and many other reasons, it is often safer to use an external template
    engine. Applications such as Express make it easy to do so.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 出于这个原因和许多其他原因，通常更安全使用外部模板引擎。诸如Express之类的应用程序可以轻松实现这一点。
- en: We now have a simple HTTP-based web application. To gain more experience with
    HTTP events, let's add to one to a module for listening to all HTTP events.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个简单的基于HTTP的Web应用程序。为了更多地了解HTTP事件，让我们为监听所有HTTP事件的模块添加一个。
- en: HTTP Sniffer – listening to the HTTP conversation
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP Sniffer - 监听HTTP对话
- en: The events emitted by the `HTTPServer` object can be used for additional purposes
    beyond the immediate task of delivering a web application. The following code
    demonstrates a useful module that listens to all of the `HTTPServer` events. It
    could be a useful debugging tool, which also demonstrates how `HTTPServer` objects
    operate.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`HTTPServer`对象发出的事件可以用于除了传递Web应用程序的直接任务之外的其他目的。以下代码演示了一个有用的模块，它监听所有`HTTPServer`事件。这可能是一个有用的调试工具，还演示了`HTTPServer`对象的操作方式。'
- en: Node.js's `HTTPServer` object is an `EventEmitter` object, and HTTP Sniffer
    simply listens to every server event, printing out information pertinent to each
    event.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js的`HTTPServer`对象是一个`EventEmitter`对象，而HTTP Sniffer只是监听每个服务器事件，打印出与每个事件相关的信息。
- en: 'Create a file named `httpsniffer.mjs`, containing the following code:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`httpsniffer.mjs`的文件，其中包含以下代码：
- en: '[PRE10]js\1'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE10]js\1'
- en: 'Then, change the server setup, as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，按照以下方式更改服务器设置：
- en: '[PRE11]js\1'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE11]js\1'
- en: You now have a tool for snooping on `HTTPServer` events. This simple technique
    prints a detailed log of event data. This pattern can be used for any `EventEmitter`
    objects. You can use this technique as a way to inspect the actual behavior of
    `EventEmitter` objects in your program.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您有一个用于窥探`HTTPServer`事件的工具。这种简单的技术打印出事件数据的详细日志。这种模式可以用于任何`EventEmitter`对象。您可以使用这种技术来检查程序中`EventEmitter`对象的实际行为。
- en: Before we move on to using Express, we need to discuss why we use application
    frameworks at all.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续使用Express之前，我们需要讨论为什么要使用应用程序框架。
- en: Web application frameworks
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Web应用程序框架
- en: The `HTTPServer` object is very close to the HTTP protocol. While this is powerful
    in the same way that driving a stick shift car gives you low-level control over
    the driving experience, typical web application programming is better done at
    a higher level. Does anyone use assembly language to write web applications? It's
    better to abstract away the HTTP details and concentrate on your application.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`HTTPServer`对象与HTTP协议非常接近。虽然这在某种程度上很强大，就像驾驶手动挡汽车可以让您对驾驶体验进行低级控制一样，但典型的Web应用程序编程最好在更高的级别上完成。有人使用汇编语言来编写Web应用程序吗？最好将HTTP细节抽象出来，集中精力放在应用程序上。'
- en: The Node.js developer community has developed quite a few application frameworks
    to help with different aspects of abstracting away HTTP protocol details. Of these
    frameworks, Express is the most popular, and Koa ([http://koajs.com/](http://koajs.com/))
    should be considered because it has fully integrated support for async functions.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js开发者社区已经开发了相当多的应用程序框架，以帮助抽象HTTP协议细节的不同方面。在这些框架中，Express是最受欢迎的，而Koa（[http://koajs.com/](http://koajs.com/)）应该被考虑，因为它完全集成了对异步函数的支持。
- en: The Express.js wiki has a list of frameworks built on top of Express.js or tools
    that work with it. This includes template engines, middleware modules, and more.
    The Express.js wiki is located at [https://github.com/expressjs/express/wiki](https://github.com/expressjs/express/wiki).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Express.js维基上列出了建立在Express.js之上或与其一起使用的框架和工具。这包括模板引擎、中间件模块等。Express.js维基位于[https://github.com/expressjs/express/wiki](https://github.com/expressjs/express/wiki)。
- en: 'One reason to use a web framework is that they often have well-tested implementations
    of the best practices used in web application development for over 20 years. The
    usual best practices include the following:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Web框架的一个原因是它们通常具有在Web应用程序开发中使用了20多年的最佳实践的经过充分测试的实现。通常的最佳实践包括以下内容：
- en: Providing a page for bad URLs (the `404` page)
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供一个用于错误URL的页面（`404`页面）
- en: Screening URLs and forms for any injected scripting attacks
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 筛选URL和表单以防注入脚本攻击
- en: Supporting the use of cookies to maintain sessions
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持使用cookie来维护会话
- en: Logging requests for both usage tracking and debugging
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录请求以进行使用跟踪和调试
- en: Authentication
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 认证
- en: Handling static files, such as images, CSS, JavaScript, or HTML
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理静态文件，如图像、CSS、JavaScript或HTML
- en: Providing cache-control headers to caching proxies
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供缓存控制头以供缓存代理使用
- en: Limiting things such as the page size or execution time
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制页面大小或执行时间等事项
- en: Web frameworks help you invest your time in a task without getting lost in the
    details of implementing the HTTP protocol. Abstracting away details is a time-honored
    way for programmers to be more efficient. This is especially true when using a
    library or framework that provides prepackaged functions that take care of the
    details.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Web框架帮助您将时间投入到任务中，而不会迷失在实现HTTP协议的细节中。抽象化细节是程序员提高效率的一种历史悠久的方式。当使用提供预打包函数来处理细节的库或框架时，这一点尤其正确。
- en: With that in mind, let's turn to a simple application implemented with Express.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，让我们转向使用Express实现的一个简单应用程序。
- en: Getting started with Express
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用Express
- en: Express is perhaps the most popular Node.js web app framework. Express is described
    as being Sinatra-like, which refers to a popular Ruby application framework. It
    is also regarded as not being an opinionated framework, meaning the framework
    authors don't impose their opinions about structuring an application. This means
    Express is not at all strict about how your code is structured; you just write
    it the way you think is best.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Express可能是最受欢迎的Node.js Web应用程序框架。Express被描述为类似于Sinatra，这是一个流行的Ruby应用程序框架。它也被认为不是一种武断的框架，这意味着框架作者不会对应用程序的结构施加自己的意见。这意味着Express对代码的结构并不严格；您只需按照您认为最好的方式编写即可。
- en: You can visit the home page for Express at [http://expressjs.com/](http://expressjs.com/).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以访问Express的主页[http://expressjs.com/](http://expressjs.com/)。
- en: As of the time of writing this book, Express 4.17 is the current version, and
    Express 5 is in alpha testing. According to the Express.js website, there are
    very few differences between Express 4 and Express 5.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 截至撰写本书时，Express 4.17是当前版本，Express 5正在进行alpha测试。根据Express.js网站，Express 4和Express
    5之间几乎没有什么区别。
- en: Let's start by installing `express-generator`. While we can just start with
    writing some code, `express-generator` provides a blank starting application,
    which we'll take and modify.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先安装`express-generator`。虽然我们可以直接开始编写一些代码，但`express-generator`提供了一个空白的起始应用程序，我们将使用它并进行修改。
- en: 'Install `express-generator` using the following commands:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令安装`express-generator`：
- en: '[PRE12]js\1'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE12]js\1'
- en: 'Run the `express` command, as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`express`命令，如下所示：
- en: '[PRE13]js\1'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE13]js\1'
- en: This executes exactly the same, without having to install `express-generator`
    and (as we'll see in a moment) remembering to uninstall it when you're done using
    the command.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这样执行完全相同，无需安装`express-generator`，并且（我们马上会看到）在使用命令结束时记得卸载它。
- en: 'Now that you''ve installed `express-generator` in the `fibonacci` directory,
    use it to set up the blank framework application:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已经在`fibonacci`目录中安装了`express-generator`，使用它来设置空白框架应用程序：
- en: '[PRE14]js\1'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE14]js\1'
- en: 'This uninstalls the `express-generator` tool. The next thing to do is to run
    the blank application in the way that we''re told. The `npm start` command relies
    on a section of the supplied `package.json` file:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这将卸载`express-generator`工具。接下来要做的是按照我们被告知的方式运行空白应用程序。`npm start`命令依赖于提供的`package.json`文件的一个部分：
- en: '[PRE15]js\1'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE15]js\1'
- en: Setting the `DEBUG` variable this way turns on the debugging output, which includes
    a message about listening on port `3000`. Otherwise, we aren't told this information.
    This syntax is what's used in the Bash shell to run a command with an environment
    variable. If you get an error when running `npm start`, then refer to the next
    section.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式设置`DEBUG`变量会打开调试输出，其中包括有关监听端口`3000`的消息。否则，我们不会得到这些信息。这种语法是在Bash shell中使用环境变量运行命令的方式。如果在运行`npm
    start`时出错，请参考下一节。
- en: 'We can modify the supplied `npm start` script to always run the app with debugging
    enabled. Change the `scripts` section to the following:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以修改提供的`npm start`脚本，始终使用启用调试的应用程序。将`scripts`部分更改为以下内容：
- en: '[PRE16]js\1'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE16]js\1'
- en: 'Then, the command is executed, as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，执行以下命令：
- en: '[PRE17]js\1'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE17]js\1'
- en: This means that `app.js` is a CommonJS module that exports the application object
    generated by the `express` module. Our task in `app.js` is to configure that application
    object. This task does not include starting the `HTTPServer` object, however.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着`app.js`是一个CommonJS模块，它导出了由`express`模块生成的应用程序对象。我们在`app.js`中的任务是配置该应用程序对象。但是，这个任务不包括启动`HTTPServer`对象。
- en: 'Now, let''s turn to the `bin/www` script. It is in this script where the HTTP
    server is started. The first thing to notice is that it starts with the following
    line:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们转向`bin/www`脚本。在这个脚本中启动了HTTP服务器。首先要注意的是它以以下行开始：
- en: '[PRE18]js\1'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE18]js\1'
- en: We can also see that the script was made executable by `express-generator`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以看到该脚本是通过`express-generator`可执行的。
- en: 'It calls the `app.js` module, as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 它调用`app.js`模块，如下所示：
- en: '[PRE19]js\1'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE19]js\1'
- en: By specifying an environment variable for `PORT`, we can tell the application
    to listen in on port `4242`, where you can ponder the meaning of life.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 通过为`PORT`指定环境变量，我们可以告诉应用程序监听端口`4242`，您可以在那里思考生活的意义。
- en: The `app` object is next passed to `http.createServer()`. A look at the Node.js
    documentation tells us that this function takes `requestListener`, which is simply
    a function that takes the `request` and `response` objects that we saw previously.
    Therefore, the `app` object is the same kind of function.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来将`app`对象传递给`http.createServer()`。查看Node.js文档告诉我们，这个函数接受`requestListener`，它只是一个接受我们之前看到的`request`和`response`对象的函数。因此，`app`对象是相同类型的函数。
- en: Finally, the `bin/www` script starts the server listening process on the port
    we specified.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`bin/www`脚本启动了服务器监听进程，监听我们指定的端口。
- en: 'Let''s now go through `app.js` in more detail:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们更详细地了解`app.js`：
- en: '[PRE20]js\1'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE20]js\1'
- en: 'The `app.use` function mounts middleware functions. This is an important piece
    of Express jargon, which we will discuss shortly. At the moment, let''s say that
    middleware functions are executed during the processing of requests. This means
    all the features named here are enabled in `app.js`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: Logging is enabled using the `morgan` request logger. Refer to [https://www.npmjs.com/package/morgan](https://www.npmjs.com/package/morgan)
    for its documentation.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `body-parser` module handles parsing HTTP request bodies. Refer to [https://www.npmjs.com/package/body-parser](https://www.npmjs.com/package/body-parser)
    for its documentation.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `cookie-parser` module is used to parse HTTP cookies. Refer to [https://www.npmjs.com/package/cookie-parser](https://www.npmjs.com/package/cookie-parser)
    for its documentation.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A static file web server is configured to serve the asset files in the `public`
    directory. Refer to [http://expressjs.com/en/starter/static-files.html](http://expressjs.com/en/starter/static-files.html) for
    its documentation.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two router modules—`routes` and `users`—to set up which functions handle which
    URLs.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The static file web server arranges to serve, via HTTP requests, the files in
    the named directory. With the configuration shown here, the `public/stylesheets/style.css` file is
    available at `http://HOST/stylesheets/style.css`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: We shouldn't feel limited to setting up an Express application this way. This
    is the recommendation of the Express team, but there is nothing constraining us
    from setting it up another way. For example, later in this book, we'll rewrite
    this entirely as ES6 modules, rather than sticking to CommonJS modules. One glaring
    omission is handlers for uncaught exceptions and unhandled Promise rejections.
    We'll go over both of these later in this book.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will discuss Express **middleware** functions.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Express middleware
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's round out our walkthrough of `app.js` by discussing what Express middleware
    functions do for our application. Middleware functions are involved in processing
    requests and sending results to HTTP clients. They have access to the `request`
    and `response` objects and are expected to process their data and perhaps add
    data to these objects. For example, the cookie parser middleware parses HTTP cookie
    headers to record in the `request` object the cookies sent by the browser.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: 'We have an example of this at the end of our script:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]js\1'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: This does not call `next` but instead calls `res.send`. The HTTP response is
    sent for certain functions on the `response` object, such as `res.send` or `res.render`. This
    is the correct method for ending the request-response cycle, by sending a response
    (`res.send`) to the request. If neither `next` nor `res.send` are called, the
    request never gets a response and the requesting client will hang.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: 'So, a middleware function does one of the following four things:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: Executes its own business logic. The request logger middleware shown earlier
    is an example of this.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modifies the `request` or `response` objects. Both `body-parser` and
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cookie-parser` do this, looking for data to add to the `request` object.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Calls `next` to proceed to the next middleware function or otherwise signals
    an error.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sends a response, ending the cycle.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ordering of middleware execution depends on the order that they're added
    to the `app` object. The first function added is executed first, and so on.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: The next thing to understand is request handlers and how they differ from middleware
    functions.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: Contrasting middleware and request handlers
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We've seen two kinds of middleware functions so far. In one, the first argument
    is the handler function. In the other, the first argument is a string containing
    a URL snippet and the second argument is the handler function.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: 'What''s actually going on is `app.use` has an optional first argument: the
    path that the middleware is mounted on. The path is a pattern match against the
    request URL, and the given function is triggered if the URL matches the pattern.
    There''s even a method to supply named parameters in the URL:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，`app.use`有一个可选的第一个参数：中间件挂载的路径。该路径是对请求URL的模式匹配，并且如果URL匹配模式，则触发给定的函数。甚至有一种方法可以在URL中提供命名参数：
- en: '[PRE22]js\1'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE22]js\1'
- en: The required behavior of `GET` is to retrieve data, while the behavior of `PUT`
    is to store data. However, as the example was written above, it would match either
    of the HTTP methods when the handler function is only correct for the `GET` verb.
    However, using `app.get`, as is the case here, ensures that the application correctly
    matches the desired HTTP method.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`GET`的所需行为是检索数据，而`PUT`的行为是存储数据。然而，如上所述的示例，当处理程序函数仅对`GET`动词正确时，它将匹配任一HTTP方法。但是，使用`app.get`，如本例中的情况，确保应用程序正确匹配所需的HTTP方法。'
- en: 'Finally, we get to the `Router` object. This is the kind of middleware used
    explicitly for routing requests based on their URL. Take a look at `routes/users.js`:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们来到了`Router`对象。这是一种专门用于根据其URL路由请求的中间件。看一下`routes/users.js`：
- en: '[PRE23]js\1'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE23]js\1'
- en: This takes the `router` object, with its zero-or-more router functions, and
    mounts it on the `/users` URL. As Express looks for a matching routing function,
    it first scans the functions attached to the `app` object, and for any router
    object, it scans its functions as well. It then invokes any routing functions
    that match the request.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这将`router`对象及其零个或多个路由函数挂载到`/users` URL上。当Express寻找匹配的路由函数时，首先扫描附加到`app`对象的函数，对于任何路由器对象，它也会扫描其函数。然后调用与请求匹配的任何路由函数。
- en: Going back to the issue of the `/` URL, the fact that the router is *mounted
    on* the `/users` URL is important. That's because the actual URL it considers
    matching is the mount point (`/users`) concatenated with the URL in the `router`
    function.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`/` URL的问题，`router`实际上*挂载在*`/users` URL上是很重要的。这是因为它考虑匹配的实际URL是挂载点(`/users`)与`router`函数中的URL连接起来的。
- en: The effect is that the mount prefix is stripped from the request URL for the
    purpose of matching against the `router` functions attached to the `router` object.
    So, with that mount point, an incoming URL of `/users/login` would be stripped
    to just `/login` in order to find a matching `router` function.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 效果是为了匹配附加到`router`对象的`router`函数，请求URL的挂载前缀被剥离。因此，使用该挂载点，`/users/login`的传入URL将被剥离为`/login`，以便找到匹配的`router`函数。
- en: Since not everything goes according to plan, our applications must be capable
    of handling error indications and showing error messages to users.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 由于并非一切都按计划进行，我们的应用程序必须能够处理错误指示并向用户显示错误消息。
- en: Error handling
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 错误处理
- en: Now, we can finally get back to the generated `app.js` file, the `404 Error
    page not found` error, and any other errors that the application might show to
    the user.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们终于可以回到生成的`app.js`文件，`404 Error page not found`错误，以及应用程序可能向用户显示的任何其他错误。
- en: A middleware function indicates an error by passing a value to the `next` function
    call, namely by calling `next(err)`. Once Express sees the error, it skips over
    any remaining non-error routings and only passes the error to error handlers instead.
    An error handler function has a different signature than what we saw earlier.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件函数通过将值传递给`next`函数调用来指示错误，即通过调用`next(err)`。一旦Express看到错误，它将跳过任何剩余的非错误路由，并仅将错误传递给错误处理程序。错误处理程序函数的签名与我们之前看到的不同。
- en: 'In `app.js`, which we''re examining, the following is our error handler, provided
    by `express-generator`:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们正在检查的`app.js`中，以下是我们的错误处理程序，由`express-generator`提供：
- en: '[PRE24]js\1'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE24]js\1'
- en: In a Handlebars template, the `{{value}}` markup means to substitute into the
    template the value of the expression or variable. The values referenced by this
    template—`message` and `error`—are provided by setting `res.locals` as shown here.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在Handlebars模板中，`{{value}}`标记意味着将表达式或变量的值替换到模板中。此模板引用的`message`和`error`是通过设置`res.locals`提供的，如下所示。
- en: 'To see the error handler in action, let''s add the following to `routes/index.js`:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看错误处理程序的操作，请将以下内容添加到`routes/index.js`：
- en: '[PRE25]js\1'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE25]js\1'
- en: Most of this is what `express-generator` gave us. The `var` statements have
    been changed to `const` for that little teensy bit of extra comfort. We explicitly
    imported the `hbs` module so that we could do some configuration. We also imported
    a router module for `Fibonacci`, which we'll see in a minute.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这大部分是`express-generator`给我们的。`var`语句已更改为`const`，以获得更多的舒适度。我们明确导入了`hbs`模块，以便进行一些配置。我们还导入了一个`Fibonacci`的路由模块，我们马上就会看到。
- en: For the `Fibonacci` application, we don't need to support users and so we have
    deleted the routing module. The `routes/fibonacci.js` module, which we'll show
    next, serves to query a number for which we'll calculate the Fibonacci number.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`Fibonacci`应用程序，我们不需要支持用户，因此已删除了路由模块。我们将在接下来展示的`routes/fibonacci.js`模块用于查询我们将计算斐波那契数的数字。
- en: 'In the top-level directory, create a file, `math.js`, containing the following
    extremely simplistic Fibonacci implementation:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在顶级目录中，创建一个名为`math.js`的文件，其中包含以下极其简单的斐波那契实现：
- en: '[PRE26]js\1'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE26]js\1'
- en: This file contains the structure that we'll use for the HTML pages. Going by
    the Handlebars syntax, we can see that `{{title}}` appears within the HTML `title`
    tag. This means that when we call `res.render`, we should supply a `title` attribute.
    The `{{{body}}}` tag is where the `view` template content lands.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件包含我们将用于HTML页面的结构。根据Handlebars语法，我们可以看到`{{title}}`出现在HTML`title`标记中。这意味着当我们调用`res.render`时，我们应该提供一个`title`属性。`{{{body}}}`标记是`view`模板内容的落脚点。
- en: 'Change `views/index.hbs` to just contain the following:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 将`views/index.hbs`更改为只包含以下内容：
- en: '[PRE27]js\1'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE27]js\1'
- en: This will serve as a navigation bar that's included on every page.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这将作为包含在每个页面上的导航栏。
- en: 'Create a file, `views/fibonacci.hbs`, containing the following code:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`views/fibonacci.hbs`的文件，其中包含以下代码：
- en: '[PRE28]js\1'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE28]js\1'
- en: The anonymous object passed to `res.render` contains the data values we provide
    to the layout and view templates. We're now passing a new welcome message.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给`res.render`的匿名对象包含我们提供给布局和视图模板的数据值。我们现在传递了一个新的欢迎消息。
- en: 'Then, finally, in the `routes` directory, create a file named `fibonacci.js`,
    containing the following code:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`routes`目录中，创建一个名为`fibonacci.js`的文件，其中包含以下代码：
- en: '[PRE29]js\1'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE29]js\1'
- en: 'As this suggests, you can visit `http://localhost:3000/` and see what we have:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 正如这个示例所暗示的，您可以访问`http://localhost:3000/`，看看我们有什么：
- en: '![](img/1be8113c-faf7-4ee3-b759-0c221f0bc703.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1be8113c-faf7-4ee3-b759-0c221f0bc703.png)'
- en: 'This page is rendered from the `views/index.hbs` template. Simply click on
    the Fibonacci''s link to go to the next page, which is, of course, rendered from
    the `views/fibonacci.hbs` template. On that page, you''ll be able to enter a number,
    click on the Submit button, and get an answer (hint—pick a number below `40` if
    you want your answer in a reasonable amount of time):'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这个页面是从`views/index.hbs`模板中渲染出来的。只需点击斐波那契的链接，就可以进入下一个页面，当然，这个页面是从`views/fibonacci.hbs`模板中渲染出来的。在那个页面上，您可以输入一个数字，点击提交按钮，然后得到一个答案（提示-如果您希望在合理的时间内得到答案，请选择一个小于`40`的数字）：
- en: '![](img/55b25999-812a-4621-aa47-3f9cf3dcda98.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![](img/55b25999-812a-4621-aa47-3f9cf3dcda98.png)'
- en: We asked you to enter a number less than `40`. Go ahead and enter a larger number,
    such as `50`, but go take a coffee break because this is going to take a while to
    calculate. Or, proceed on to reading the next section, where we will start to
    discuss the use of computationally intensive code.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要求您输入一个小于`40`的数字。继续输入一个更大的数字，比如`50`，但是请喝杯咖啡，因为这将需要一段时间来计算。或者，继续阅读下一节，我们将开始讨论使用计算密集型代码。
- en: Computationally intensive code and the Node.js event loop
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算密集型代码和Node.js事件循环
- en: This Fibonacci example is purposely inefficient to demonstrate an important
    consideration for your applications. What happens to the Node.js event loop when
    long computations are run? To see the effect, open two browser windows, each viewing
    the Fibonacci page. In one, enter the number `55` or greater, and in the other,
    enter `10`. Note how the second window freezes, and if you leave it running long
    enough, the answer will eventually pop up in both windows. What's happening in
    the Node.js event loop is blocked from processing events because the Fibonacci
    algorithm is running and does not ever yield to the event loop.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这个斐波那契的例子故意效率低下，以演示应用程序的一个重要考虑因素。当长时间计算运行时，Node.js事件循环会发生什么？为了看到效果，打开两个浏览器窗口，每个窗口查看斐波那契页面。在一个窗口中，输入数字`55`或更大，而在另一个窗口中，输入`10`。注意第二个窗口会冻结，如果您让它运行足够长的时间，答案最终会在两个窗口中弹出。Node.js事件循环中发生的情况是，由于斐波那契算法正在运行并且从不让出事件循环，事件循环被阻塞无法处理事件。
- en: Since Node.js has a single execution thread, processing requests depends on
    request handlers quickly returning to the event loop. Normally, the asynchronous
    coding style ensures that the event loop executes regularly.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Node.js具有单个执行线程，处理请求取决于请求处理程序快速返回到事件循环。通常，异步编码风格确保事件循环定期执行。
- en: This is true even for requests that load data from a server halfway around the
    globe because the asynchronous request is non-blocking and control is quickly
    returned to the event loop. The naïve Fibonacci function we chose doesn't fit
    into this model because it's a long-running blocking operation. This type of event
    handler prevents the system from processing requests and stops Node.js from doing
    what it's meant to do—namely, to be a blisteringly fast web server.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是从地球的另一端加载数据的请求，也是如此，因为异步请求是非阻塞的，并且控制很快返回到事件循环。我们选择的天真的斐波那契函数不符合这个模型，因为它是一个长时间运行的阻塞操作。这种类型的事件处理程序会阻止系统处理请求，并阻止Node.js做它应该做的事情-即成为一个速度极快的Web服务器。
- en: In this case, the long-response-time problem is obvious. The response time to
    calculate a Fibonacci number quickly escalates to the point where you can take
    a vacation to Tibet, become a Lama, and perhaps get reincarnated as a llama in
    Peru in the time it takes to respond! However, it's also possible to create a
    long-response-time problem without it being as obvious as this one. Of the zillion-and-one
    asynchronous operations in a large web service, which one is both blocking and
    takes a long time to compute the result? Any blocking operations like this will
    cause a negative effect on the server throughput.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，长响应时间的问题是显而易见的。计算斐波那契数的响应时间迅速上升到您可以去西藏度假，成为喇嘛，也许在这段时间内转世为秘鲁的羊驼！然而，也有可能创建一个长响应时间的问题，而不像这个问题那么明显。在大型Web服务中的无数异步操作中，哪一个既是阻塞的又需要很长时间来计算结果？像这样的任何阻塞操作都会对服务器吞吐量产生负面影响。
- en: 'To see this more clearly, create a file named `fibotimes.js`, containing the
    following code:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更清楚地看到这一点，创建一个名为`fibotimes.js`的文件，其中包含以下代码：
- en: '[PRE30]js\1'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE30]js\1'
- en: This quickly calculates the first 40 or so members of the Fibonacci sequence,
    but after the 40^(th) member, it starts taking a couple of seconds per result
    and quickly degrades from there. It is untenable to execute code of this sort
    on a single-threaded system that relies on a quick return to the event loop. A
    web service containing code like this would give a poor performance to the users.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法可以快速计算斐波那契数列的前40个成员，但是在第40个成员之后，每个结果开始花费几秒钟的时间，并且很快就会变得更糟。在依赖快速返回到事件循环的单线程系统上执行这种代码是不可行的。包含这种代码的Web服务会给用户带来糟糕的性能。
- en: 'There are two general ways to solve this problem in Node.js:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在Node.js中有两种一般的方法来解决这个问题：
- en: '**Algorithmic refactoring**: Perhaps, like the Fibonacci function we chose,
    one of your algorithms is suboptimal and can be rewritten to be faster. Or, if
    it is not faster, it can be split into callbacks dispatched through the event
    loop. We''ll look at one method for this in a moment.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Creating a backend service**: Can you imagine a backend server that is dedicated
    to calculating Fibonacci numbers? Okay, maybe not, but it''s quite common to implement
    backend servers to offload work from frontend servers, and we will implement a
    backend Fibonacci server at the end of this chapter.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With that in mind, let's examine these possibilities.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Algorithmic refactoring
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To prove that we have an artificial problem on our hands, here is a much more
    efficient Fibonacci function:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]js\1'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, your performance problems will be this easy to optimize, but other
    times, they won't.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: The discussion here isn't about optimizing mathematics libraries but about dealing
    with inefficient algorithms that affect event throughput in a Node.js server.
    For that reason, we will stick with the inefficient Fibonacci implementation.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: 'It is possible to divide the calculation into chunks and then dispatch the
    computation of those chunks through the event loop. Add the following code to
    `math.js`:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]js\1'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: We're back to an inefficient algorithm, but one where calculations are distributed
    through the event loop. Running this version of `fibotimes.js` demonstrates its
    inefficiency. To demonstrate it in the server, we need to make a few changes.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: 'Because it''s an asynchronous function, we will need to change our router code.
    Create a new file, named `routes/fibonacci-async1.js`, containing the following
    code:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]js\1'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: With this change, the server no longer freezes when calculating a large Fibonacci
    number. The calculation, of course, still takes a long time, but at least other
    users of the application aren't blocked.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: 'You can verify this by again opening two browser windows in the application.
    Enter `60` in one window, and in the other, start requesting smaller Fibonacci
    numbers. Unlike with the original `fibonacci` function, using `fibonacciAsync`
    allows both windows to give answers, although if you really did enter `60` in
    the first window, you might as well take that three-month vacation to Tibet:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/08f9d3d1-d06b-4c79-8b9b-944cd2928f9d.png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
- en: It's up to you and your specific algorithms to choose how best to optimize your
    code and handle any long-running computations you may have.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: We've created a simple Express application and demonstrated that there is a
    flaw that affects performance. We've also discussed algorithmic refactoring, which
    just leaves us to discuss how to implement a backend service. But first, we need
    to learn how to create and access a REST service.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: Making HTTPClient requests
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another way to mitigate computationally intensive code is to push the calculation
    to a backend process. To explore that strategy, we'll request computations from
    a backend Fibonacci server, using the `HTTPClient` object to do so. However, before we
    look at that, let's first talk in general about using the `HTTPClient` object.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: Node.js includes an `HTTPClient` object, which is useful for making HTTP requests.
    It has the capability to issue any kind of HTTP request. In this section, we'll
    use the `HTTPClient` object to make HTTP requests similar to calling a REST web
    service.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with some code inspired by the `wget` or `curl` commands to make
    HTTP requests and show the results. Create a file named `wget.js`, containing
    the following code:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]js\1'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Yes, `example.com` is a real website—visit it someday. There's more in the printout,
    namely the HTML of the page at `http://example.com/`. What we've done is demonstrated
    how to invoke an HTTP request using the `http.request` function.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: 'The `options` object is fairly straightforward, with the `host`, `port`, and
    `path` fields specifying the URL that is requested. The `method` field must be
    one of the HTTP verbs (`GET`, `PUT`, `POST`, and so on). You can also provide
    a `headers` array for the headers in the HTTP request. For example, you might
    need to provide a cookie:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]js\1'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: This is a stripped-down Express application that gets right to the point of
    providing a Fibonacci calculation service. The one route it supports handles the
    Fibonacci computation using the same functions that we've already worked with.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: This is the first time we've seen `res.send` used. It's a flexible way to send
    responses that can take an array of header values (for the HTTP response header)
    and an HTTP status code. As used here, it automatically detects the object, formats
    it as JSON text, and sends it with the correct `Content-Type` parameter.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: 'In `package.json`, add the following to the `scripts` section:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]js\1'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, in a separate command window, we can use the `curl` program to make some
    requests against this service:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]js\1'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s easy—using `curl`, we can make HTTP `GET` requests. Now, let''s create
    a simple client program, `fiboclient.js`, to programmatically call the Fibonacci
    service:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]js\1'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, run the `client` app:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]js\1'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: This is a new variant of the Fibonacci route handler, this time calling the
    REST backend service. We've transplanted the `http.request` call from `fiboclient.js` and
    integrated the events coming from the `client` object with the Express route handler.
    In the normal path of execution, the `HTTPClient` issues a `response` event, containing
    a `response` object. When that object issues a `data` event, we have our result.
    The result is JSON text, which we can parse and then return to the browser as
    the response to its request.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: 'In `app.js`, make the following change:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]js\1'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: How can we have the same value for `SERVERPORT` for all three `scripts` entries?
    The answer is that the variable is used differently in different places. In `startrest`,
    this variable is used in `routes/fibonacci-rest.js` to know at which port the
    REST service is running. Likewise, in `client`, `fiboclient.js` uses this variable
    for the same purpose. Finally, in `server`, the `fiboserver.js` script uses the
    `SERVERPORT` variable to know which port to listen on.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: In `start` and `startrest`, no value is given for `PORT`. In both cases, `bin/www`
    defaults to `PORT=3000` if a value is not specified.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: 'In a command window, start the backend server, and in another, start the application.
    Open a browser window, as before, and make a few requests. You should see an output
    similar to the following:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]js\1'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: Because we haven't changed the templates, the screen will look exactly as it
    did earlier.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: 'We may run into another problem with this solution. The asynchronous implementation
    of our inefficient Fibonacci algorithm may cause the Fibonacci service process
    to run out of memory. In the Node.js FAQs, [https://github.com/nodejs/node/wiki/FAQ](https://github.com/nodejs/node/wiki/FAQ),
    it''s suggested to use the `--max_old_space_size` flag. You''d add this to `package.json`,
    as follows:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '```js\1'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: However, the FAQs also say that if you're running into maximum memory space
    problems, your application should probably be refactored. This goes back to the
    point we made earlier that there are several approaches to addressing performance
    problems, one of which is the algorithmic refactoring of your application.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: Why go through the trouble of developing this REST server when we could just
    directly use `fibonacciAsync`?
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: The main advantage is the ability to push the CPU load for this heavyweight
    calculation to a separate server. Doing so preserves the CPU capacity on the frontend
    server so that it can attend to the web browsers. GPU coprocessors are now widely
    used for numerical computing and can be accessed via a simple network API. The
    heavy computation can be kept separate, and you can even deploy a cluster of backend
    servers sitting behind a load balancer, evenly distributing requests. Decisions
    such as this are made all the time to create multi-tier systems.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: What we've demonstrated is that it's possible to implement simple multi-tier
    REST services in a few lines of Node.js and Express. This whole exercise gave
    us a chance to think about computationally intensive code in Node.js and the value
    of splitting a larger service into multiple services.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: Of course, Express isn't the only framework that can help us create REST services.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: Some RESTful modules and frameworks
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are a few available packages and frameworks to assist your REST-based
    projects:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '**Restify** ([>http://restify.com/](http://restify.com/)): This offers both
    client-side and server-side frameworks for both ends of REST transactions. The
    server-side API is similar to Express.'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Loopback** ([http://loopback.io/](http://loopback.io/)): This is an offering
    from StrongLoop. It offers a lot of features and is, of course, built on top of
    Express.'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we've done a big thing in creating a backend REST service.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You learned a lot in this chapter about Node.js's `EventEmitter` pattern, `HTTPClient`,
    and server objects, at least two ways to create an HTTP service, how to implement
    web applications, and even how to create a REST client and REST service integrated
    into a customer-facing web application. Along the way, we again explored the risks
    of blocking operations, the importance of keeping the event loop running, and
    a couple of ways to distribute work across multiple services.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can move on to implementing a more complete application: one for taking
    notes. We will use the `Notes` application in several upcoming chapters as a vehicle
    to explore the Express application framework, database access, deployment to cloud
    services or on your own server, user authentication, semi-real-time communication
    between users, and even hardening an application against several kinds of attacks.
    We''ll end up with an application that can be deployed to cloud infrastructure.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: There's still a lot to cover in this book, and it starts in the next chapter
    with creating a basic Express application.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
