- en: Networking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will introduce a variety of topics related to performing network
    operations. Simple low-level examples, such as performing DNS lookups using the
    low-level socket libraries, will be presented. HTTP client and server implementations
    will also be presented. We will then show you how to create an application that
    lets you control the LEDs on board the microcontroller using a web browser.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will help you create a MicroPython project that needs to fetch
    information from the internet. This can help you whenever you want to provide
    a way for people to use their web browsers on their phones and computers to directly
    connect and interact with your MicroPython boards.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Performing a DNS lookup
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a function to wait for internet connectivity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing an HTTP request using raw sockets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing an HTTP request using the urequests library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fetching JSON data from a RESTful web service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an HTTP server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a web handler module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling LEDs through the web server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing a RESTful API to control the LEDs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code files for this chapter can be found in the `Chapter12` folder in this
    book's GitHub repository, available at [https://github.com/PacktPublishing/MicroPython-Cookbook](https://github.com/PacktPublishing/MicroPython-Cookbook).
  prefs: []
  type: TYPE_NORMAL
- en: This chapter uses the Adafruit Feather HUZZAH ESP8266\. CircuitPython 3.1.2
    was used for all the recipes in this chapter. You should apply the configuration
    we described in the *Connecting to an existing Wi-Fi network* recipe from [Chapter
    10](d2b921f5-f861-412c-819d-46a68c0ddf18.xhtml), *Controlling the ESP8266*. This
    recipe will let you run all the recipes in this chapter that connect to the internet,
    as well as the recipes that involve you connecting to your board from your computer.
  prefs: []
  type: TYPE_NORMAL
- en: Performing a DNS lookup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will show you how to write code that will run on MicroPython to
    perform a DNS lookup. Whenever our applications try and connect to the host, one
    of the first steps is to look up the hostname using the DNS protocol and get the
    host's IP address so that you can open a connection to that IP address.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe shows you how to perform that DNS lookup, and then takes those lines
    of code and packages them into a function that you can call whenever you want
    to get the IP address of a specific host. This recipe can be useful in your projects
    whenever you want to keep track of a hostname and its related IP address, or when
    you face networking issues on your devices or network and want some simple tests
    to troubleshoot what's going on.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need access to the REPL on the ESP8266 to run the code presented in
    this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to learn how to perform a DNS lookup:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following lines of code in the REPL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve used the `getaddrinfo` function to perform a DNS lookup on `python.org`
    and get its IP address. The following block of code will access the specified
    string in the returned data structure that contains the IP address:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now wrap this code up in a function that returns the IP address for
    a given hostname:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We will call this function with a number of different hostnames to verify that
    it is working correctly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code should be put into the `main.py` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: When this script is executed, it will perform DNS lookups on three hostnames
    and print out the results of each lookup.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `get_ip` function that is defined will receive the hostname as its the first
    argument and will perform a DNS lookup on the hostname, before returning the IP
    address at the end of each function call. There is one optional argument that
    specifies the TCP port to use when connecting to the host. The TCP port default
    value is set to port `80`. This is the port number for the HTTP protocol. This
    means that this function will work for hosts that are hosting a web server.
  prefs: []
  type: TYPE_NORMAL
- en: The `main` function sleeps for five seconds to allow the board to establish
    a connection to the Wi-Fi network on boot-up before performing the DNS lookups.
    Then, the `main` function loops through three hostnames and performs a DNS lookup
    on each one, printing out the hostname and returned IP of each entry through the
    `for` loop.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This script performs its task well enough, but there is room for improvement.
    The five-second delay is sufficient on most Wi-Fi networks. There are, however,
    networks that will take longer, so this value should be increased. But if we set
    this value very high and the network is fast to connect, then we are unnecessarily
    waiting too long. In the next recipe, we will introduce a way to wait for internet
    connectivity that will address both limitations in a much more effective fashion.
    Any time you use hardcoded sleep values in your code, you should dig deep and
    try to find better solutions.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are a few references regarding this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Documentation on the `getaddrinfo` function can be found at [https://docs.python.org/3/library/socket.html#socket.getaddrinfo](https://docs.python.org/3/library/socket.html#socket.getaddrinfo).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An example of using `getaddrinfo` on MicroPython can be found at [https://docs.micropython.org/en/latest/esp8266/tutorial/network_tcp.html#star-wars-asciimation](https://docs.micropython.org/en/latest/esp8266/tutorial/network_tcp.html#star-wars-asciimation).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a function to wait for internet connectivity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will show you how to write a function that polls the status of your
    Wi-Fi connection on boot-up. We will name this function `wait_for_networking`.
    Once it has detected that a connection has been successfully established and that
    an IP address has been assigned over DHCP, then the `wait_for_networking` function
    will return.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever you have a project that requires internet connectivity, you will face
    this issue at boot-up. If your script starts immediately, connecting to the internet
    before the network connection has come up, it will raise exceptions and fail to
    continue. Using the method in this recipe will let you start the rest of your
    program's execution once the network connection is properly established.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need access to the REPL on the ESP8266 to run the code presented in
    this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to learn how to create a function that waits for internet
    connectivity:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the following block of code in the REPL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'When the code is run early enough, it will return a `False` value. Calling
    `isconnected` again, but at a later stage, will result in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The following block of code can be used to retrieve the assigned IP address
    once the network is connected:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The following function brings all this code together into one function that
    will wait until a network connection is established and an IP address is allocated
    to the device. It then returns the IP address:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code should be put into the `netcheck.py` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The following block of code should be put into the `main.py` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: When this script is executed, it will wait for a network connection to be established
    and then print out the IP address assigned to the device.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we created a Python module called `netcheck`. The `wait_for_networking`
    function in that module will create a WLAN object called `station`. The `station`
    object will be used to poll the network at 1-second intervals until a network
    connection is established. Then, it will get the assigned IP from the `station`
    object using the `ifconfig` method. This IP address is then returned to the calling
    function. The main script in this recipe simply imports the `wait_for_networking`
    function from the `netcheck` module and calls it at the start of its execution,
    before printing out the returned IP address.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So many network connected projects should only start their main block of code
    once the network is connected. When you run Python on a typical computer, the
    operating system takes care of the process of ensuring all network connections
    are up before starting other services for you. In the case of MicroPython, there
    is no operating system—it's just your script running on bare metal. You have to
    take these things into account so that your code can run correctly.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are a few references regarding this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Documentation on the **Dynamic Host Configuration Protocol** (**DHCP**) can
    be found at [https://tools.ietf.org/html/rfc2131](https://tools.ietf.org/html/rfc2131).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documentation on how `systemd` on Linux handles detecting network connectivity
    can be found at [https://www.freedesktop.org/wiki/Software/systemd/NetworkTarget/](https://www.freedesktop.org/wiki/Software/systemd/NetworkTarget/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing an HTTP request using raw sockets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will use the `socket` library that comes with both MicroPython and
    Python to perform an HTTP request. We will create a function that receives a URL
    as its input and returns the response from the requested web server after performing
    the HTTP request. We will also create a function that can parse a URL and return
    the hostname and path components of the URL. These pieces will be needed to perform
    the HTTP request.
  prefs: []
  type: TYPE_NORMAL
- en: There's a whole class of MicroPython projects that will want to connect to web
    servers on the internet and fetch different results. You will see one way to do
    this using the `socket` library, which gives you direct access to TCP sockets
    to read and write bytes of data from them.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need access to the REPL on the ESP8266 to run the code presented in
    this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to learn how to perform an HTTP request using raw sockets:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the REPL to run the following lines of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We have successfully created the `parse_url` function, which takes a URL and
    returns the `host` and `path` components:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '`parse_url` is then called with an example URL to demonstrate its functionality.
    In the following block of code, we define and call a function to look up the IP
    address for a specific hostname:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now define the `fetch` function, which receives a URL as its input and
    retrieves its content from a web server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now call this function and inspect the results that it returns:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code should be put into the `main.py` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: When this script gets executed, it will fetch the content of a specific URL
    and output the returned results.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `parse_url` function will return the two main parts of the URL that we are
    interested in. This is done by removing the initial part of the URL and performing
    a single string split using the `/` character. Once these operations are performed,
    we will be left with the hostname and path part of the URL, which we can then
    return. The `fetch` function first calls `parse_url` and `get_ip` to get the hostname,
    path, and IP address information for a given URL. Once this is done, a socket
    connection is created to the web server.
  prefs: []
  type: TYPE_NORMAL
- en: The HTTP request is created by filling in the template called `HTTP_REQUEST`.
    This request is then transmitted over the network to the web server. The results
    are continually read as a series of chunks until the end of the response is reached.
    These chunks of data are concatenated together into a variable called response.
  prefs: []
  type: TYPE_NORMAL
- en: The response has both the HTTP headers and body in the response. We are only
    interested in the body portion, so we use the `split` method to extract it. Once
    extracted, it is converted from a `bytes` object into a string and returned. The
    `main` function, when called, will wait for network connectivity and then call
    the `fetch` function to get the HTML content of the URL. This content is then
    printed out.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A lot is going on in this recipe. In a way, this is a great way to learn about
    TCP sockets, HTTP, HTML, and URLs, because all the low-level details are exposed
    to you. MicroPython doesn't ship with the higher-level HTTP request libraries
    that come with the Python standard library.
  prefs: []
  type: TYPE_NORMAL
- en: So, when you want to write code from scratch that fetches content from a web
    server, you have to use the `socket` library in the same way that was presented
    in this recipe. In the next recipe, we will see that there is a Python module
    that works with MicroPython that we can add to our projects to make performing
    these HTTP requests much simpler.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are a few references regarding this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Documentation on the `send` method on MicroPython socket objects can be found
    at [https://docs.micropython.org/en/latest/library/usocket.html#usocket.socket.send](https://docs.micropython.org/en/latest/library/usocket.html#usocket.socket.send).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documentation on the `recv` method on MicroPython socket objects can be found
    at [https://docs.micropython.org/en/latest/library/usocket.html#usocket.socket.recv](https://docs.micropython.org/en/latest/library/usocket.html#usocket.socket.recv).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing an HTTP request using the urequests library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will use the `urequests` library, which was specially written to
    work with MicroPython. It provides a convenient way to connect to web servers
    and perform HTTP requests. This library provides an object that you can use to
    perform all your HTTP interactions. After the request is completed, you can access
    different attributes of this object to get a variety of information on the completed
    request.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will explore using this library and the different attributes that
    you might want to access on its objects. When you start creating MicroPython projects
    that need to make HTTP requests, this library will take care of a lot of the low-level
    details of making these requests. This will keep your code simpler and more readable,
    and lets you focus on the task at hand instead of getting bogged down with low-level
    TCP socket details.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need access to the REPL on the ESP8266 to run the code presented in
    this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to learn how to perform an HTTP request using `urequests`:'
  prefs: []
  type: TYPE_NORMAL
- en: Download `urequests.py` from [https://github.com/micropython/micropython-lib/blob/master/urequests/urequests.py](https://github.com/micropython/micropython-lib/blob/master/urequests/urequests.py).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save this Python module on your board's top-level directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the following lines of code in the REPL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We now have a completed HTTP request, and its results are stored in the `req`
    variable. The following block of code will output the HTML response we received
    from the web server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also access the raw content in its binary form, as shown in the following
    block of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The `status_code` attribute provides us with the HTTP status code of the response:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The following block of code will attempt to access a page that doesn''t exist:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now inspect the values of the status code and the explanatory text:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code should be put into the `main.py` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: When this script is executed, it will use the `urequests` library to fetch the
    content of a specific URL and output the page's HTML content.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `urequests` library provides a function called `get` that lets you perform
    HTTP `GET` requests on web servers. Once you call this function, it will return
    an object that has a number of useful properties that you can then access to retrieve
    the results of this request.
  prefs: []
  type: TYPE_NORMAL
- en: You can get the raw response as a bytes object by accessing the content attribute,
    or you can get the value as a string by accessing the `text` attribute. Finally,
    you can use the `status_code` and `reason` attributes to check whether a request
    was successful or failed, and what the reason for its failure was. This code is
    then wrapped up and put into the `main` function. When the main function is called,
    it will connect to the web server and output the contents of the returned HTML
    document.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe shows a nice way of getting productive in MicroPython HTTP requests
    without having to go to a very low level of detail. It’s a great example of how
    a well-designed library can make your code more readable and maintainable.
  prefs: []
  type: TYPE_NORMAL
- en: This library provides a number of HTTP methods, beyond a basic HTTP `GET` request.
    The `HEAD`, `POST`, `PUT`, `PATCH`, and `DELETE` methods are all made available
    too. They can all be accessed using function names that match the request method.
    This can be very useful at times when you're interacting with web services that
    need the correct HTTP method to be specified for them to work correctly. If you
    are getting warning messages each time you make HTTP calls using the `urequests`
    library, you can try and use the `fix_urequests_warnings.py` file to fix this
    issue. You can find this script in the `Chapter12` folder of this book's GitHub
    repository.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are a few references regarding this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Documentation on the list of HTTP response status codes can be found at [https://developer.mozilla.org/en-US/docs/Web/HTTP/Status](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The popular requests library is what the design of `urequests` is based on,
    and can be found at [http://docs.python-requests.org/en/master/](http://docs.python-requests.org/en/master/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fetching JSON data from a RESTful web service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will show you an example of connecting to a server on the internet
    in order to consume its RESTful web service. The web service will provide data
    in JSON format, which will then be parsed so that we can access different parts
    of the returned dataset.
  prefs: []
  type: TYPE_NORMAL
- en: We will consume a web service that provides the current location of the **International
    Space Station** (**ISS**). Since the ISS moves at an incredible speed of 28,000
    km/h, we can watch its position, which is expressed in terms of longitude and
    latitude, change as we repeatedly call this web service. Whenever you want to
    create a MicroPython project that connects to the rich world of internet-based
    web services, you can use the techniques covered in this recipe as a starting
    point to build these connections.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need access to the REPL on the ESP8266 to run the code presented in
    this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to learn how to fetch JSON data from a RESTful web service:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the following block of code in the REPL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We have successfully connected to the web service and retrieved the space station''s
    position. The following block of code will inspect the data that has been returned
    to us:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The data is provided in JSON format. We can use the following block of code
    to parse the text data and generate a set of nested dictionaries:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The following block of code shows how we can access the latitude and longitude
    data from the returned data structure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will create and call the `track_space_station` function, which will
    track the space station''s position every second over a period of `10` seconds:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code should be put into the `main.py` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: When this script is executed, it will track the position of the ISS and display
    the changes in the latitude and longitude each second for a fixed period of time.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We defined a constant called `ISS_API_URL` that has the URL that we can use
    to retrieve information on where the ISS is currently located. When we call this
    API by performing an HTTP `GET` request, the server returns its output in JSON
    format. We can then use the `json` method on the returned request object to parse
    this response into Python data structures. We can access the `iss_position` key
    and the latitude and longitude information within that dictionary. The rest of
    the `track_space_station` function just loops for `10` iterations, with a 1-second
    sleep between each loop, before calling the API and printing its parsed results.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe is a great example of how rich and varied the world of web services
    can be. You can connect these tiny low-powered microcontrollers to all sorts of
    rich information sources. JSON is the most popular serialization format for these
    web services, so it's a very powerful feature to have built-in support for parsing
    this format with MicroPython.
  prefs: []
  type: TYPE_NORMAL
- en: MicroPython also fully supports creating JSON output so that you can equally
    submit data to web services from your MicroPython project. You could connect some
    sensors to your boards and continually upload sensor data in JSON format to a
    remote server using web services.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are a few references regarding this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Documentation on the ISS Current Location API can be found at [http://open-notify.org/Open-Notify-API/ISS-Location-Now/](http://open-notify.org/Open-Notify-API/ISS-Location-Now/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documentation on the JSON format can be found at [https://www.json.org/](https://www.json.org/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an HTTP server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will show you how we can create a web server in MicroPython that
    will serve web pages with dynamic content on the ESP8266\. Each time a browser
    visits the web server, it will display the current uptime of the board in seconds.
  prefs: []
  type: TYPE_NORMAL
- en: We'll ensure that the web page that's generated will render well on computer
    web browsers, as well as phone browsers. It can be a very powerful tool for the
    projects you create, as that you have the ability to interact with them from any
    phone or computer on your network using a web browser.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe shows you how to create projects like this, where you can submit
    any live sensor data or information straight to people's browsers, regardless
    of whether they connect from their phone or desktop computer.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need access to the REPL on the ESP8266 to run the code presented in
    this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to learn how to create an HTTP server:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the REPL to run the following lines of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'At this stage, we have all the necessary Python modules imported and constants
    defined. The following block of code will define an HTML template that we will
    use to generate pages before submitting them to the connecting browsers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The following function is defined and called, and will bind and listen to the
    default HTTP port:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The following block of code defines and calls the `serve_requests` function,
    which will be in charge of serving any requests that are made to the web server.
    The function is called, and then the web server is visited by a browser three
    separate times. Each time a request is served, its details are printed out:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code should be put into the `main.py` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: When this script is executed, it will kick off a web server each time the board
    boots up, which will display a message with the server's uptime each time it is
    visited by a browser.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the first things that are defined in the script is the HTML template.
    This template will generate valid HTML5 web pages, which will render correctly
    on both mobiles and desktops.
  prefs: []
  type: TYPE_NORMAL
- en: The `icon` link tag is present to prevent web browsers from unnecessarily asking
    for `favicon.ico` files. The `socket_listen` function is called to bind and listen
    to the default HTTP port. The `serve_requests` function is then called and will
    endlessly serve all incoming HTTP requests. The start time of the web server is
    recorded in a variable called `start`. We will use this to calculate the server
    uptime for each request.
  prefs: []
  type: TYPE_NORMAL
- en: We call the `accept` method, which will block the code until a new request comes
    to the web server. Once we receive this new request, we consume all the HTTP request
    headers by repeatedly calling the `readline` method until we have detected the
    end of the request headers. We can now generate our HTML response and send it
    to the HTTP client using the `send` method. After transmitting the response, we
    close the connection with the client.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can take this recipe and extend it in many ways. You could read data from
    different sensors and buttons connected to the board and send this data back to
    the browser. You can also easily change and add more content to the template.
  prefs: []
  type: TYPE_NORMAL
- en: 'Currently, it only has HTML content, but there is nothing preventing you from
    adding CSS, JavaScript, and image content to your responses. The board comes with
    4 MB of flash memory, so there is a good amount of room on the board to add all
    of this content. The following screenshot shows the page that was generated from
    this recipe shown on a desktop browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/8cda4654-5660-4151-80e3-da43da40165f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following screenshot is taken from the browser on an Android smartphone:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/895000ce-dd00-4fff-90e5-b8ed76ed427c.png)'
  prefs: []
  type: TYPE_IMG
- en: The way the HTML is designed in this recipe is to make it easy to have one code
    base serve both categories of devices.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are a few references regarding this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Documentation on the `bind` method can be found at [https://docs.micropython.org/en/latest/library/usocket.html#usocket.socket.bind](https://docs.micropython.org/en/latest/library/usocket.html#usocket.socket.bind).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documentation on the `listen` method can be found at [https://docs.micropython.org/en/latest/library/usocket.html#usocket.socket.listen](https://docs.micropython.org/en/latest/library/usocket.html#usocket.socket.listen).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a web handler module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will show you how we can take a lot of the code and logic involved
    in handling sockets, parsing HTTP request headers, and generating HTML, and bundle
    it all into a single Python module. Once we have it in one module, we can import
    this module and pass it our web handler, which will do all the heavy lifting for
    us.
  prefs: []
  type: TYPE_NORMAL
- en: You will find this recipe useful when you are creating projects that create
    a web-based application on your microcontroller and you want to get productive
    fast, without getting bogged down in all the low-level details of sockets and
    parsing HTTP headers.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need access to the REPL on the ESP8266 to run the code presented in
    this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to learn how to create a web handler module:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following lines of code in the REPL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We have created a variable called `BASE_TEMPLATE` that will act as a generic
    template. Now, we can fill its `body` tag with any content we desire. The following
    block of code defines `socket_listen`, which does the initial socket configuration
    for the server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The following block of code has a function that receives the web handler as
    an argument. When called, it will handle incoming requests so that it can collect
    their request headers, and then parse the HTTP method and requested path. This
    information is then passed to the handler, which will return the HTML content
    to be sent to the HTTP client:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The `run_server` function is then defined in the following block of code. It
    is provided with a handler, and will create the sockets and call `serve_requests`
    to start serving all incoming requests:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The following block of code shows an example handler that creates a web application
    that generates random numbers each time anyone visits it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code should be put into the `web.py` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, put the following code in the `main.py` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: When this script is executed, it will start a web server at boot-up that generates
    random numbers whenever people visit it.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The bulk of this recipe is the code in the `web` Python module. This code provides
    the `BASE_TEMPLATE` variable, which can be filled with any content in its `body`
    tag. Then, three functions are defined in the module.
  prefs: []
  type: TYPE_NORMAL
- en: The `socket_listen` function has logic that we are familiar with; that is, setting
    up the socket, binding it, and making it listen to port `80`. The `serve_requests`
    function now receives a handler and will collect the HTTP request headers in a
    variable called `request`. This `request` is then parsed to extract the HTTP method
    in use and the requested path. These three variables are then passed to the provided
    handler, which returns an HTML response to be transmitted to the HTTP client.
    The `run_server` function is the main point of entry into this module. You can
    call it and provide it with your handler, and it will set up the server and start
    processing requests.
  prefs: []
  type: TYPE_NORMAL
- en: The code in the `main.py` file imports the `web` module and passes the handler
    it has defined. Its handler simply generates a random number for each HTTP request
    and sends this number back to the web browser.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe lends itself to being extended. The bulk of the code related to
    socket handling and dealing with byte conversion is all done by the `web` module.
    You can import this module and start creating web applications on your MicroPython
    board in a relatively short amount of time.
  prefs: []
  type: TYPE_NORMAL
- en: You can also extend the `web` module to add more features. You could create
    more built-in templates or parse the HTTP headers further to get access to more
    request information automatically.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are a few references regarding this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Documentation on the `accept` method can be found at [https://docs.micropython.org/en/latest/library/usocket.html#usocket.socket.accept](https://docs.micropython.org/en/latest/library/usocket.html#usocket.socket.accept).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documentation on the `close` method can be found at [https://docs.micropython.org/en/latest/library/usocket.html#usocket.socket.close](https://docs.micropython.org/en/latest/library/usocket.html#usocket.socket.close).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling LEDs through the web server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will show you how to create a web-based application that will let
    people see the status of the red and blue LED lights, as well as turn each of
    them on and off. This recipe will help you whenever you want to create projects
    that control the output of different hardware components, such as LEDs, screens,
    or speakers through a web-based application that can be accessed from computers
    and phones alike.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need access to the REPL on the ESP8266 to run the code presented in
    this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to learn how to control LEDs through the web server:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the following block of code in the REPL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The `pins` and `state` variables have been created so that we can keep track
    of the status of the red and blue LEDs, as well as access their `Pin` objects.
    The following block of code will define the HTML `BODY` template and will show
    the current state of the LEDs, as well as provide buttons to toggle them on and
    off:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The following block of code has a function that will format Boolean values
    into the `On` and `Off` labels for the HTML content we will generate:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The `gen_body` function generates the body portion of the HTML content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The `toggle_color` function will switch the LED on and off. The first call
    will switch the red LED off, while then the second call will switch it back on:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The `handler` function will toggle colors for `POST` requests, and for all
    requests, it will return the generated HTML body, which shows the LEDs'' statuses
    and provides toggle buttons:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code should be put into the `main.py` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: When this script is executed, it will start a web application that shows the
    current status of the LEDs and provides buttons that can be used to toggle the
    LEDs on and off.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `format` function takes Boolean values and returns values to indicate the
    light status of `On` or `Off`. The `gen_body` function will then loop through
    all the LED state values and format them so that they can fill the HTML template.
    This template is then filled and returned. The `toggle_color` function receives
    the name of the LED to toggle and then updates the state data structure before
    accessing the `Pin` object in order to apply the change to the LEDs. The `handler`
    function will take incoming requests and toggle the LEDs if the request is a `POST`
    request. Then, it will always return the generated body to show the latest values
    of the LEDs and provide the buttons to toggle them on and off. The `main` function
    initializes the LED `Pin` objects, and then calls the `run_server` function with
    the defined handler so that it can start processing incoming requests.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe provides all the controls we need to inspect the current settings
    of the LEDs and switch them on and off. We can, however, extend and improve it
    in many ways. We could add some CSS to improve the look and feel of the application.
    We could also use some rich JavaScript controls that can create animations when
    someone interacts with the UI controls so that they act more like toggle buttons.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are a few references regarding this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Documentation on a toggle control for web browsers can be found at [http://www.bootstraptoggle.com/](http://www.bootstraptoggle.com/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documentation on the HTTP `POST` method can be found at [https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/POST](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/POST).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing a RESTful API to control the LEDs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will show you how to create a RESTful API hosted on the ESP8266
    that will let API clients inquire about the status of the LEDs, as well as toggle
    them on and off. In previous recipes, we've seen how you can use MicroPython as
    a client to access RESTful web services.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will flip this around, and provide RESTful web services so that other
    devices and computers on the network can connect to the board and control its
    hardware. You will find this recipe very useful whenever you need to have other
    computers and devices on the network remotely connect to your projects and control
    components on them.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need access to the REPL on the ESP8266 to run the code presented in
    this recipe. You will also need the `curl` command-line tool, which can be downloaded
    from [https://curl.haxx.se/download.html](https://curl.haxx.se/download.html).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to learn how to develop a RESTful API to control the LEDs:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the REPL to run the following lines of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'We have imported the `json` library and set up the `pins` and `state` variables.
    The following block of code will define the `JSON_HEADERS` template, which we
    will use to provide the HTTP response headers for our JSON responses:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The following block of code will perform the LED toggling for the RESTful API
    calls:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The `handler` function in the following code will toggle LEDs when a request
    uses the `POST` method. In all cases, it will return the values of the state variable
    in JSON serialized form:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code should be put into the `main.py` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Execute the `main.py` script so that we can start accessing the RESTful APIs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Download and install the `curl` command line on your computer ([https://curl.haxx.se/download.html](https://curl.haxx.se/download.html)).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the following command in the Terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'This will retrieve the status of the LEDs. Execute the following command to
    switch the red LED off:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run the following command, the red LED will be switched back on:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The `curl` command line is an excellent way to test and interact with most RESTful
    APIs.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The structure of the code is very similar to the previous recipe. Some of the
    main differences are that the `JSON_HEADERS` template provides the necessary HTTP
    response headers to indicate that the content type of the response will be JSON.
    The `dumps` function in the `json` module is also used to generate the JSON data
    from the state data structure. The server needs to be started before we can test
    and interact with the APIs through `curl`. The first `curl` command simply performs
    a `GET` request, which returns the status of the LEDs. We then use the `-X` option
    in `curl` to specify that we want to use the POST method so that we can toggle
    the LEDs on and off.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe offers a basic set of APIs so that we can control the lights on
    the board. We could extend it to respond to requests on how long the server has
    been running or its disk usage. You could create an API that lets you remotely
    list and delete files. RESTful APIs are very powerful tools that you can use to
    glue many different scripts and computers together across the network. The approach
    that we used in this recipe can be extended to provide more services and features
    with relative ease.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are a few references regarding this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Documentation on using the `curl` command for HTTP `POST` requests can be found
    at [https://ec.haxx.se/http-post.html](https://ec.haxx.se/http-post.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A tutorial on RESTful APIs can be found at [https://www.restapitutorial.com/](https://www.restapitutorial.com/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
