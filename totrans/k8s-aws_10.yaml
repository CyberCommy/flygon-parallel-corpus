- en: Managing Container Images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A container orchestration platform needs a solid foundation to run our containers.
    One vital piece of infrastructure is the location where we store our container
    images, which will allow us to reliably fetch them when creating our pods.
  prefs: []
  type: TYPE_NORMAL
- en: From a developer's point of view, it should be very easy and fast to push new
    images whilst developing the software we wish to deploy to Kubernetes. We'll also
    want to have mechanisms that help us with versioning, cataloging, and describing
    how to use our images, in order to facilitate deployments and reduce the risk
    of delivering the wrong version or configuration of our software.
  prefs: []
  type: TYPE_NORMAL
- en: Container images can often contain intellectual property, proprietary source
    code, infrastructure configuration secrets, and even business secrets. Therefore,
    we need to have proper authentication and authorization mechanisms to protect
    them from unwanted access.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we're going to learn how to leverage the AWS **Elastic Container
    Registry** (**ECR**) service to store our container images in a manner that tackles
    all these needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Pushing Docker images to ECR
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tagging images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Labeling images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pushing Docker images to ECR
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Currently, the most commonly adopted way to store and deliver Docker images
    is through Docker Registry, an open source application by Docker that hosts Docker
    repositories. This application can be deployed on-premises, as well as used as
    a service from multiple providers, such as **Docker Hub**, **Quay.io**, and **AWS
    ECR**.
  prefs: []
  type: TYPE_NORMAL
- en: The application is a simple, stateless service, where most of the maintenance
    work involves making sure that storage is available, safe, and secure. As any
    seasoned system administrator knows, that is far from an easy ordeal, especially,
    if there is a large data store. For that reason, and especially if you're just
    starting out, it is highly recommended to use a hosted solution and let someone
    else deal with keeping your images safe and readily available.
  prefs: []
  type: TYPE_NORMAL
- en: ECR is AWS's approach to a hosted Docker registry, where there's one registry
    per account, uses AWS IAM to authenticate and authorize users to push and pull
    images. By default, the limits for both repositories and images are set to 1,000\.
    As we'll see, the setup flow feels very similar to other AWS services, whilst
    also being familiar for Docker Registry users.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create a repository, it''s as simple as executing the following `aws ecr`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This will create a repository for storing our `randserver` application. Its
    output should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'A nice addition to your repositories is a life cycle policy that cleans up
    older versions of your images, so that you don''t eventually get blocked from
    pushing a newer version. This can be achieved as follows, using the same `aws
    ecr` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This particular policy will start cleaning up once have more than 800 images
    on the same repository. You could also clean up based on the images, age, or both,
    as well as consider only some tags in your cleanup.
  prefs: []
  type: TYPE_NORMAL
- en: For more information and examples, refer to [https://docs.aws.amazon.com/AmazonECR/latest/userguide/lifecycle_policy_examples.html](https://docs.aws.amazon.com/AmazonECR/latest/userguide/lifecycle_policy_examples.html).
  prefs: []
  type: TYPE_NORMAL
- en: Pushing and pulling images from your workstation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order use your newly-created ECR repository, first we''re going to need
    to authenticate your local Docker daemon against the ECR registry. Once again,
    `aws ecr` will help you achieve just that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This will output a `docker login` command that will add a new user-password
    pair for your Docker configuration. You can copy-paste that command, or you can
    just run it as follows; the results will be the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, pushing and pulling images is just like using any other Docker registry,
    using the outputted repository URI that we got when creating the repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Setting up privileges for pushing images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'IAM users'' permissions should allow your users to perform strictly only the
    operations they actually need to, in order to avoid any possible mistakes that
    might have a larger area of impact. This is also true for ECR management, and
    to that effect, there are three AWS IAM managed policies that greatly simplify
    achieving it:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AmazonEC2ContainerRegistryFullAccess`: This allows a user to perform any operation
    on your ECR repositories, including deleting them, and should therefore be left
    for system administrators and owners.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AmazonEC2ContainerRegistryPowerUser`: This allows a user to push and pull
    images on any repositories, which is very handy for developers that are actively
    building and deploying your software.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AmazonEC2ContainerRegistryReadOnly`: This allows a user to pull images on
    any repository, which is useful for scenarios where developers are not pushing
    their software from their workstation, and are instead just pulling internal dependencies
    to work on their projects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All of these policies can be attached to an IAM user as follows, by replacing
    the policy name at the end of the ARN with a suitable policy (as described previously)
    and pointing `--user-name` to the user you are managing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: All these AWS managed policies do have an important characteristic—all of them
    add permissions for all repositories on your registry. You'll probably find several
    use cases where this is far from ideal—maybe your organization has several teams
    that do not need access over each other's repositories; maybe you would like to
    have a user with the power to delete some repositories, but not all; or maybe
    you just need access to a single repository for **Continuous Integration** (**CI**)
    setup.
  prefs: []
  type: TYPE_NORMAL
- en: If your needs match any of these described situations, you should create your
    own policies with as granular permissions as required.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will create an IAM group for the developers of our `randserver` application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we''ll add the `johndoe` user to the group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we''ll need to create our policy so that we can attach it to the group.
    Copy this JSON document to a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'To create the policy, execute the following, passing the appropriate path for
    the JSON document file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The final step is then to attach the policy to the group, so that `johndoe`
    and all future developers of this application can use the repository from their
    workstation, just like we did previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Use images stored on ECR in Kubernetes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may recall, in [Chapter 7](a873e36a-237e-471d-ae10-d15d29fe47f6.xhtml), *A
    Production-Ready Cluster* that we attached the IAM policy, `AmazonEC2ContainerRegistryReadOnly`,
    to the instance profile used by our cluster nodes. This allows our nodes to fetch
    any images in any repository in the AWS account where the cluster resides.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to use an ECR repository in this manner, you should set the `image`
    field of the pod template on your manifest to point to it, such as in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Tagging images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Whenever a Docker image is pushed to a registry, we need to identify the image
    with a tag. A tag can be any alphanumeric string: `latest stable v1.7.3` and even
    `c31b1656da70a0b0b683b060187b889c4fd1d958` are both perfectly valid examples of
    tags that you might use to identify an image that you push to ECR.'
  prefs: []
  type: TYPE_NORMAL
- en: Depending on how your software is developed and versioned, what you put in this
    tag might be different. There are three main strategies that might be adopted
    depending on different types of applications and development processes that that
    we might need to generate images for.
  prefs: []
  type: TYPE_NORMAL
- en: Version Control System (VCS) references
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you build images from software where the source is managed in a version
    control system, such as Git, the simplest way of tagging your images in this case
    is to utilize the commit ID (often referred to as a SHA when using Git) from your
    VCS. This gives you a very simple way to check exactly which version of your code
    is currently running at any one time.
  prefs: []
  type: TYPE_NORMAL
- en: This first strategy is often adopted for applications where small changes are
    delivered in an incremental fashion. New versions of your images might be pushed
    multiple times a day and automatically deployed to testing and production-like
    environments. Good examples of these kinds of applications that are web applications
    and other software delivered as a service.
  prefs: []
  type: TYPE_NORMAL
- en: By pushing a commit ID through an automated testing and release pipeline, you
    can easily generate deployment manifests for an exact revision of your software.
  prefs: []
  type: TYPE_NORMAL
- en: Semantic versions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: However, this strategy becomes more cumbersome and harder to deal with if you
    are building container images that are intended to be used by many users, whether
    that be multiple users within your organisation or even when you publish images
    publicly for third parties to use. With applications like these, it can be helpful
    to use a semantic version number that has some meaning, helping those that depend
    on you image decide if it safe to move to a newer version.
  prefs: []
  type: TYPE_NORMAL
- en: A common scheme for these sorts of images is called **Semantic Versioning**
    (**SemVer**). This is a version number made up of three individual numbers separated
    by dots. These numbers are known as the **MAJOR**, **MINOR**, and **PATCH** version.
    A semantic version number lays out these numbers in the form `MAJOR.MINOR.PATCH`.
    When a number is incremented, the less significant numbers to the right are reset
    to `0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'These version numbers give downstream users useful information about how a
    new version might affect compatibility:'
  prefs: []
  type: TYPE_NORMAL
- en: The `PATCH` version is incremented whenever a bug or security fix is implemented
    that maintains backwards compatibility
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `MINOR` version is incremented whenever a new feature is added that maintains
    backwards compatibility
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any changes that break backwards compatibility should increment the `MAJOR`
    version number
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is useful because users of your images know that `MINOR` or `PATCH` level
    changes are unlikely to break anything, so only basic testing should be required
    when upgrading to a new version. But if upgrading to a new `MAJOR` version, they
    ought to check and test the impact on the changes, which might require changes
    to configuration or integration code.
  prefs: []
  type: TYPE_NORMAL
- en: You can read more about SemVer at [https://semver.org/](https://semver.org/).
  prefs: []
  type: TYPE_NORMAL
- en: Upstream version numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Often, when we when build container images that repackage existing software,
    it is desirable to use the original version number of the packaged software itself.
    Sometimes, it can help to add a suffix to version the configuration that you're
    using to package that software with.
  prefs: []
  type: TYPE_NORMAL
- en: In larger organisations, it can be common to package software tools with configuration
    files with organisation-specific default settings. You might find it useful to
    version the configuration files as well as the software tool.
  prefs: []
  type: TYPE_NORMAL
- en: If I were packaging the MySQL database for use in my organisation, an image
    tag might look like `8.0.12-c15`, where `8.0.12` refers to the upstream MySQL
    version and `c15` is a version number I have created for the MySQL configuration
    files included in my container image.
  prefs: []
  type: TYPE_NORMAL
- en: Labelling images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have an even moderately complex workflow for developing and releasing
    your software, you might quickly find yourself wanting to add even more semantic
    information about your images into its tag than just a simple version number.
    This can quickly become unwieldy, as you will need to modify your build and deployment
    tooling whenever you want to add some extra information.
  prefs: []
  type: TYPE_NORMAL
- en: Thankfully, Docker images carry around labels that can be used to store whatever
    metadata is relevant to your image.
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding a label to your image is done at build time, using the `LABEL` instruction
    in your Dockerfile. The `LABEL` instruction accepts multiple key value pairs in
    this format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Using this instruction, we can store any arbitrary metadata that we find useful
    on our images. And because the metadata is stored inside the image, unlike tags,
    it can't be changed. By using appropriate image labels, we can discover the exact
    revision from our VCS, even if an image has been given an opaque tag, such as `latest`
    or `stable`.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to set these labels dynamically at build time, you can also make
    use of the `ARG` instruction in your Dockerfile.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example of using build arg''s to set labels. Here is an example
    Dockerfile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'When we build the container, we can pass values for our labels using the `--build-arg`
    flag. This is useful when we want to pass dynamic values such as a Git commit
    reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As with the labels that Kubernetes allows you to attach to the objects in your
    cluster, you are free to label your images with whatever scheme you choose, and
    save whatever metadata makes sense for your organisation.
  prefs: []
  type: TYPE_NORMAL
- en: The **Open Container Initiative** (**OCI**), an organization that promotes standards
    for container runtimes and their image formats, has proposed a standard set of
    labels that can be used to provide useful metadata that can then be used by other
    tools that understand them. If you decide to add labels to your container images,
    choosing to use part or all of this set of labels might be a good place to start.
  prefs: []
  type: TYPE_NORMAL
- en: 'These labels are all prefixed with `org.opencontainers.image` so that they
    don''t collide with any ad hoc labels that you may already be using:'
  prefs: []
  type: TYPE_NORMAL
- en: '`* org.opencontainers.image.title`: This should be a human-readable title for
    the image. For example, `Redis`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`org.opencontainers.image.description`: This should be a human -readable description
    of the image. For example, `Redis is an open source key-value store`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`org.opencontainers.image.created`: This should contain the date and time that
    the image was created. It should be formatted as per RFC 3339\. For example, `2018-11-25T22:14:00Z`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`org.opencontainers.image.authors`: This should contain contact information
    about the people or organisations responsible for this image. Typically, this
    might be an email address, or other relevant contact information. For example,
    `Edward Robinson <ed@errm.co.uk>`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`org.opencontainers.image.url`: This should be a URL where more information
    about the image can be found. For example, [https://github.com/errm/kubegratulations](https://github.com/errm/kubegratulations).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`org.opencontainers.image.documentation`: This should be a URL where documentation
    about the image can be found. For example, [https://github.com/errm/kubegratulations/wiki](https://github.com/errm/kubegratulations/wiki).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`org.opencontainers.image.source`: This should be a URL where the source code
    used to build an image can be found. You might use it to link to a project page
    on a version control repository, such as GitHub, GitLab, or Bitbucket. For example,
    [https://github.com/errm/kubegratulations](https://github.com/errm/kubegratulations).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`org.opencontainers.image.version`: This could be a semantic version for the
    software packaged in this image, or it could be a label or tag used in your VCS.
    For example, `1.4.7`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`org.opencontainers.image.revision`: This should be a reference to a revision
    in your VCS, such as a Git commit SHA. For example, `e2f3bbdf80acd3c96a68ace41a4ac699c203a6a4`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`org.opencontainers.image.vendor`: This should be the name of an organisation
    or individual distributing the image. For example, **Apache Software Foundation**
    (**ASF**).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`org.opencontainers.image.licenses`: If your image contains software covered
    by a specific licence, you can list them here. You should use SPDX identifiers
    to refer to the licences. You can find the full list at [https://spdx.org/licenses/](https://spdx.org/licenses/).
    For example, `Apache-2.0`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we've learned how easy it is to provision a Docker registry
    to store images for our applications on AWS in a reproducible and foolproof fashion
    using ECR.
  prefs: []
  type: TYPE_NORMAL
- en: We discovered how to push images from our own workstations, how to use IAM permissions
    to restrict access to our images, and how to allow Kubernetes to pull container
    images directly from ECR.
  prefs: []
  type: TYPE_NORMAL
- en: You should now be aware of several strategies for tagging your images and know
    how to add additional labels to your images to store metadata about their contents,
    and you have learned about the standard labels recommended by the Open Container
    Initiative image specification.
  prefs: []
  type: TYPE_NORMAL
