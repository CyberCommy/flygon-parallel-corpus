- en: Preface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This book is a hands-on guide to start writing microservices using Node.js
    and the most modern frameworks, especially Seneca and PM2\. In the chapters, we
    will discuss how to design, build, test, and deploy microservices using the best
    practices. We will also discuss a valuable lesson: how to make the right level
    of compromise in order to avoid over-designing and get the business requirements
    aligned with the technical solutions.'
  prefs: []
  type: TYPE_NORMAL
- en: What this book covers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Chapter 1](ch01.html "Chapter 1. Microservices Architecture"), *Microservices
    Architecture*, discusses the pros and cons of microservices-oriented architectures.
    It will be the foundation for the rest of the book.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 2](ch02.html "Chapter 2. Microservices in Node.js – Seneca and PM2
    Alternatives"), *Microservices in Node.js – Seneca and PM2 Alternatives*, introduces
    Node.js, Seneca, and PM2\. In it, we will discuss the structure of a Node.js application
    and how to run it using PM2\. We will also dive into a few alternatives to Seneca
    and PM2.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 3](ch03.html "Chapter 3. From the Monolith to Microservices"), *From
    the Monolith to Microservices*, covers how to tackle the organic growth (unplanned
    software changes) using microservices. We will also talk about how to split a
    monolithic application into microservices.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 4](ch04.html "Chapter 4. Writing Your First Microservice in Node.js"),
    *Writing Your First Microservice in Node.js*, explains how to write our first
    microservice.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 5](ch05.html "Chapter 5. Security and Traceability"), *Security and
    Traceability*, covers how security and traceability are two important characteristics
    of modern systems. We need to keep the information secure and the actions traceable.
    In this chapter, we will discuss how to do it using Seneca.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 6](ch06.html "Chapter 6. Testing and Documenting Node.js Microservices"),
    *Testing and Documenting Node.js Microservices*, introduces using the main frameworks
    for testing on Node.js: Mocha and Chai. We will also make use of Sinon (another
    framework) to mock services. Swagger will be our choice for documenting microservices.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 7](ch07.html "Chapter 7. Monitoring Microservices"), *Monitoring Microservices*,
    covers using PM2 to monitor our microservices. We will use it along with Keymetrics
    to get the maximum benefit of such an advanced tool.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 8](ch08.html "Chapter 8. Deploying Microservices"), *Deploying Microservices*,
    explains how, using PM2, we are going to learn to deploy microservices in our
    different environments, managing our ecosystem of applications with a single command
    and reducing the overhead introduced by the microservices architecture. We will
    also discuss Docker, one of the most advanced systems to deploy applications not
    only in Node.js, but also in general applications.'
  prefs: []
  type: TYPE_NORMAL
- en: What you need for this book
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to follow the book, we are going to need to install Node.js, PM2 (it
    is a package that is installed through npm), and MongoDB.
  prefs: []
  type: TYPE_NORMAL
- en: We will also need an editor. Personally, I use Atom, but any general purpose
    editor should be enough.
  prefs: []
  type: TYPE_NORMAL
- en: Who this book is for
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This book is for developers that have some experience with Node.js but want
    to learn about Seneca and microservices. It is 70% practice-oriented (as we will
    be writing a lot of code), but it also is 30% theory, based on the code created
    that will help the reader to apply the exposed patterns to new software.
  prefs: []
  type: TYPE_NORMAL
- en: Conventions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this book, you will find a number of text styles that distinguish between
    different kinds of information. Here are some examples of these styles and an
    explanation of their meaning.
  prefs: []
  type: TYPE_NORMAL
- en: 'Code words in text, database table names, folder names, filenames, file extensions,
    pathnames, dummy URLs, user input, and Twitter handles are shown as follows: "We
    know that the input parameter is a `PaymentRequest` instance."'
  prefs: []
  type: TYPE_NORMAL
- en: 'A block of code is set as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'When we wish to draw your attention to a particular part of a code block, the
    relevant lines or items are set in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Any command-line input or output is written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '**New terms** and **important words** are shown in bold. Words that you see
    on the screen, for example, in menus or dialog boxes, appear in the text like
    this: "In this case, I have used Chrome and the console shows an **Uncaught TypeError:
    Cannot set property ''innerText'' of null** error in line 7."'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Warnings or important notes appear in a box like this.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Tips and tricks appear like this.
  prefs: []
  type: TYPE_NORMAL
