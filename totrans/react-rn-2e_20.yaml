- en: Alerts, Notifications, and Confirmation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The goal of this chapter is to show you how to present information to the user
    in ways that don't disrupt the current page. Pages use a `View` component, and
    render it directly on the screen. There are times, however, when there's important
    information that the user needs to see, but you don't necessarily want to kick
    them off of the current page.
  prefs: []
  type: TYPE_NORMAL
- en: You'll start by learning how to display important information. Knowing what
    important information is and when to use it, you'll see how to get user acknowledgement—both
    for error and success scenarios. Then, you'll implement passive notifications
    that show the user that something has happened. Finally, you'll implement modal
    views that show the user that something is happening in the background.
  prefs: []
  type: TYPE_NORMAL
- en: Important information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before you dive into implementing alerts, notifications, and confirmations,
    let''s take a few minutes and think about what each of these items mean. I think
    this is important, because if you end up passively notifying the user about an
    error, it can easily get missed. Here are my definitions of the types of information
    that you''ll want to display:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Alert**: Something important just happened and you need to ensure that the
    user sees what''s going on. Possibly, the user needs to acknowledge the alert.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Notification**: Something happened but it''s not important enough to completely
    block what the user is doing. These typically go away on their own.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Confirmation is actually part of an alert. For example, if the user has just
    performed an action, and then wants to make sure that it was successful before
    carrying on, they would have to confirm that they've seen the information in order
    to close the modal. A confirmation could also exist within an alert, warning the
    user about an action that they're about to perform.
  prefs: []
  type: TYPE_NORMAL
- en: The trick is to try to use notifications where the information is good to know,
    but not critical. Use confirmations only when the workflow of the feature cannot
    continue without the user acknowledging what's going on. In the following sections,
    you'll see examples of alerts and notifications used for different purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Getting user confirmation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you'll learn how to show modal views in order to get confirmation
    from the user. First, you'll learn how to implement the successful scenario, where
    an action generates a successful outcome that you want the user to be aware of.
    Then, you'll learn how to implement the error scenario, where something went wrong
    and you don't want the user to move forward without acknowledging the issue.
  prefs: []
  type: TYPE_NORMAL
- en: Success confirmation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start by implementing a modal view that''s displayed as the result of
    the user successfully performing an action. Here''s the `Modal` component, which
    is used to show the user a success confirmation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The properties that are passed to `ConfirmationModal` are forwarded to the
    React Native `Modal` component. You''ll see why in a moment. First, let''s see
    what this confirmation modal looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/f808d094-c51e-475a-a818-84690e98995c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The modal that''s displayed once the user completes an action has our own styling
    and confirmation message. It also has two actions, but it might only need one,
    depending on whether this confirmation is pre- or post-action. Here are the styles
    used for this modal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: With the React Native `Modal` component, it's pretty much up to you how you
    want your confirmation modal view to look. Think of them as regular views, with
    the only difference being that they're rendered on top of other views.
  prefs: []
  type: TYPE_NORMAL
- en: A lot of the time, you might not care to style your own modal views. For example,
    in web browsers, you can simply call the `alert()` function, which shows text
    in a window that's styled by the browser. React Native has something similar: `Alert.alert()`.
    The tricky part here is that this is an imperative API, and you don't necessarily
    want to expose it directly in your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, let''s implement an alert confirmation component that hides the details
    of this particular React Native API so that your app can just treat this like
    any other component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: There are two important aspects to this component. First, take a look at the
    `actions` map. Its keys—`true` and `false`—correspond to the `visible` state value.
    The values correspond to the imperative `alert()` API and a `noop` function. This
    is the key to translating the declarative React component interface we know and
    love into something that's hidden from view.
  prefs: []
  type: TYPE_NORMAL
- en: Second, note that the `render()` method doesn't need to render anything, since
    this component deals exclusively with imperative React Native calls. But, it feels
    like something is being rendered to the person that's using `ConfirmationAlert`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s what the alert looks like on iOS:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/f69d9dd3-e933-4cf8-ab2e-727fb3fd8a94.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In terms of functionality, there''s nothing really different here. There''s
    a title and text beneath it, but that''s something that could easily be added
    to a modal view if you wanted. The real difference is that this modal looks like
    an iOS modal, instead of something that''s styled by the app. Let''s see how this
    alert appears on Android:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/c197f225-866f-4310-91f0-066850b67a75.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This modal looks like an Android modal, and you didn''t have to style it. I
    think using alerts over modals is a better choice most of the time. It makes sense
    to have something styled to look like it''s part of iOS or part of Android. However,
    there are times when you need more control over how the modal looks, such as when
    displaying error confirmations. Here''s the code that''s used to display both
    the modal and the alert confirmation dialogs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The approach to rendering modals is different to the approach to rendering alerts.
    However, they're both still declarative components that change based on changing
    property values.
  prefs: []
  type: TYPE_NORMAL
- en: Error confirmation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All of the principles you learned about in the preceding section are applicable
    when you need the user to acknowledge an error. If you need more control of the
    display, use a modal. For example, you might want the modal to be red and scary
    looking:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/603ecf14-5931-4273-b97e-5f3121260cd3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here are the styles used to create this look. Maybe you want something a little
    more subtle, but the point is that you can make this look however you want:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The same modal styles that you used for the success confirmations are still
    here. That''s because the error confirmation modal needs many of the same styles.
    Here''s how you apply both to the `Modal` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The styles are combined as arrays before they're passed to the `style` property.
    The error styles always come last since conflicting style properties, such as
    `backgroundColor`, will be overridden by whatever comes later in the array.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to styles in error confirmations, you can include whatever advanced
    controls you want. It really depends on how your application lets users cope with
    errors; for example, maybe there are several courses of action that can be taken.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, the more common case is that something went wrong and there''s nothing
    you can do about it, besides making sure that the user is aware of the situation.
    In these cases, you can probably get away with just displaying an alert:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/7f627ed7-5e3c-4786-9d7d-99bad334d539.png)'
  prefs: []
  type: TYPE_IMG
- en: Passive notifications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The notifications you've examined so far in this chapter all have required input
    from the user. This is by design because it's important information that you're
    forcing the user to look at. You don't want to over-do this, however. For notifications
    that are important but not life-altering if ignored, you can use passive notifications.
    These are displayed in a less obtrusive way than modals, and don't require any
    user action to dismiss.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, you''ll create a `Notification` component, which uses the
    Toast API for Android, and creates a custom modal for iOS. It''s called the Toast
    API because the information that''s displayed looks like a piece of toast popping
    up. Here''s what the Android component looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Once again, you''re dealing with an imperative React Native API that you don''t
    want to expose to the rest of your app. Instead, this component hides the imperative
    `ToastAndroid.show()` function behind a declarative React component. No matter
    what, this component returns `null`, because it doesn''t actually render anything.
    Here''s what the `ToastAndroid` notification looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/c0351dbf-71f6-4b1a-a9ed-cfe831306c88.png)'
  prefs: []
  type: TYPE_IMG
- en: The notification that something has happened is displayed at the bottom of the
    screen and is removed after a short delay. The key is that the notification is
    unobtrusive.
  prefs: []
  type: TYPE_NORMAL
- en: 'The iOS notification component is a little more involved, because it needs
    state and lifecycle events to make a modal view behave like a transient notification.
    Here''s the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You have to style the modal to display the notification text, as well as the
    state that''s used to hide the notification after a delay. Here''s what the end
    result looks like for iOS:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/48be01c3-93cb-46f1-a098-2aac63f8b625.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The same principle with the `ToastAndroid` API applies here. You might have
    noticed that there''s another button in addition to the Show Notification button.
    This is a simple counter that re-renders the view. There''s actually a reason
    for demonstrating this seemingly obtuse feature, as you''ll see momentarily. Here''s
    the code for the main application view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The whole point of the press counter is to demonstrate that, even though the
    `Notification` component is declarative and accepts new property values when the
    state changes, you still have to set the message state to null when changing other
    state values. The reason for this is that if you re-render the component and the
    message state still has a string in it, it will display the same notification,
    over and over.
  prefs: []
  type: TYPE_NORMAL
- en: Activity modals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this final section of the chapter, you''ll implement a modal that shows
    a progress indicator. The idea is to display the modal, and then hide it when
    the promise resolves. Here''s the code for the generic `Activity` component that
    shows a modal with an activity indicator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'You might be tempted to pass the promise to the component so that it automatically
    hides itself when the promise resolves. I don''t think this is a good idea, because
    then you would have to introduce the state into this component. Furthermore, it
    would depend on a promise in order to function. With the way you''ve implemented
    this component, you can show or hide the modal based on the `visible` property
    alone. Here''s what the activity modal looks like on iOS:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/7331738d-0be0-4f4a-bc12-393db27a661e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'There''s a semi-transparent background on the modal that''s placed over the
    main view with the Fetch Stuff... link. Here''s how this effect is created in
    `styles.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of setting the actual `Modal` component to be transparent, you set
    the transparency in `backgroundColor`, which gives the look of an overlay. Now,
    let''s take a look at the code that controls this component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: When the fetch link is pressed, a new promise is created that simulates async
    network activity. Then, when the promise resolves, you change the `fetching` state
    back to false so that the activity dialog is hidden.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about the need to show mobile users important information.
    This sometimes involves explicit feedback from the user, even if that just means
    acknowledgement of the message. In other cases, passive notifications work better,
    since they're less obtrusive than the confirmation modals.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two tools that you can use to display messages to users: modals and
    alerts. Modals are more flexible, because they''re just like regular views. Alerts
    are good for displaying plain text and they take care of styling concerns for
    you. On Android, you have the additional `ToastAndroid` interface. You saw that
    it''s also possible to do this on iOS, but it just requires more work.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll dig deeper into the gesture response system inside
    React Native, which makes for a better mobile experience than browsers are able
    to provide.
  prefs: []
  type: TYPE_NORMAL
- en: Test your knowledge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What's the difference between an alert and a modal?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Alerts are used for unimportant information, whereas modals are used for less
    important information.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: They serve the same purpose and it doesn't matter which one you use.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Alerts are good at inheriting the look and feel of the mobile environment whereas
    modals are regular React Native views that you have total stylistic control over.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which React Native component can be used to create a modal view that overlays
    other components on the screen?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There is no way to do this.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Modal` component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Modal.open()` function is used for this.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What's the best way to display passive notifications on Android systems?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: React Native has a notification API for this purpose.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can use the `ToastAndroid` React Native API. There's no good alternative
    on iOS that doesn't involve rolling your own code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: React Native only supports passive notifications on iOS.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The React Native Alert API is only available on iOS.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'False'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Check out the following links for more information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://facebook.github.io/react-native/docs/modal](https://facebook.github.io/react-native/docs/modal)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://facebook.github.io/react-native/docs/alert](https://facebook.github.io/react-native/docs/alert)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://facebook.github.io/react-native/docs/toastandroid](https://facebook.github.io/react-native/docs/toastandroid)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
