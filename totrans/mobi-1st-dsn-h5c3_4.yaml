- en: Chapter 4. Building the Contact Form
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 3](ch03.html "Chapter 3. Building the Gallery Page"), *Building
    the Gallery Page*, we built pages to show off our work. Hopefully, the quality
    of the work you show off on these pages is so compelling that site visitors will
    want to contact you to hire you for your amazing work.
  prefs: []
  type: TYPE_NORMAL
- en: Let's make the ability to do that easy and attractive!
  prefs: []
  type: TYPE_NORMAL
- en: Making a form plan
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I know forms aren't exactly exciting, but we must get user info somehow, so
    we might as well make them look nice and not stodgy and cold. A clean and friendly
    form will be easy and minimal, gathering only the info we need. We also need to
    make the process of filling out a form as clear and free of frustration as possible.
    The 320 and Up framework is built to facilitate quite a bit of this, but we will
    still need to do the requisite planning to make sure it is just so.
  prefs: []
  type: TYPE_NORMAL
- en: 'Luckily, this isn''t going to be too tough for our rather simple needs. Let''s
    think about the bare minimum we need to collect in order to follow up with a potential
    client. Here are the things we need:'
  prefs: []
  type: TYPE_NORMAL
- en: The prospect's name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The company
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The e-mail address
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The phone number
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A message
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A few important things to keep in mind are to make sure that the labels for
    all fields let users know what to put in which field. I think that the most compelling
    argument for a usable form goes like this:'
  prefs: []
  type: TYPE_NORMAL
- en: People read from left-to-right and top-to-bottom. Therefore, the label should
    appear above the input that it is describing, as the user will read the label
    first and then see the input. This of course is an assumption that our users understand
    the visual cues that define an input in a form. If we have users that don't know
    what form fields are, we are probably out of luck. That said, it's probably worth
    thinking about the fact that our user interfaces heavily rely on people understanding
    conventions!
  prefs: []
  type: TYPE_NORMAL
- en: There are other conventions we can use for our purpose on this form. A common
    one is the use of placeholders to show users examples of the kind of content that
    is expected in each input. Again, this convention is well-known to anyone who
    has been using the Internet for any significant amount of time. Hopefully, it
    could be a useful cue to someone less familiar with these conventions too.
  prefs: []
  type: TYPE_NORMAL
- en: Handling mandatory fields
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The last things we need to let users know are the required fields that we want
    them to enter input into. There are two schools of thought on this; I will introduce
    both, mostly because I see the merit in both and it really depends on what you
    are doing.
  prefs: []
  type: TYPE_NORMAL
- en: One convention is to place the required `*` next to all the fields that are
    required. This convention again works for most visitors but the problem with this
    approach is that it might prevent gathering some information if we essentially
    annotate a few fields that we have as being optional. This argument basically
    claims that if we don't require a message and don't mark it as required, there
    is an increased likelihood of users skipping over this. Our form should absolutely
    require the user to submit a name and an e-mail; otherwise, we cannot respond
    at all. It's customary to not require a phone number or a message. Leaving the
    **Phone** field as optional is a courtesy in most cases for those who prefer not
    to be contacted via the phone. Leaving the **Message** field as optional is a
    courtesy to users. We don't want to make it mandatory as we can always respond
    once we have a name and e-mail, although our response will have to be really generic.
    It is helpful for our prospective clients to get a context for our next conversation.
    It saves everyone the time and energy.
  prefs: []
  type: TYPE_NORMAL
- en: 'With that in mind, I want to introduce the argument against following the convention
    of marking fields as required. Here is how the argument goes:'
  prefs: []
  type: TYPE_NORMAL
- en: If we, as creators of the site, put on the form only the input fields that we
    absolutely need to follow up, then the form should be simple enough to not discourage
    a user. In our case, we have five fields, which is quite parsimonious. Then, by
    not marking any fields as required, we suggest that we want all the information
    we are asking for, but we don't actually require it. We can use form validation
    to then make sure we get the bare minimum, which in our case will be the name
    and e-mail.
  prefs: []
  type: TYPE_NORMAL
- en: Ultimately, these decisions take a lot of other things into account. Since our
    portfolio site is most likely to be for digital media work, our audience should
    be familiar with web conventions, and we can use that to everyone's advantage
    and present them with a clean, simple form. On other projects, you will certainly
    have to cater to different audiences or gather more data. Hopefully, walking you
    through my planning on this form will be of some help in the future decisions
    you make.
  prefs: []
  type: TYPE_NORMAL
- en: The form's layout
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ok, now let's move on to how we want this form to look at our breakpoints. This
    one will be easy because all our focus on this page is on getting some information
    from the prospective client. For this reason, we can get away with nearly having
    the exact layout from the mobile to the desktop.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the mobile''s layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The form''s layout](img/6463_04_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And here''s an example of a layout wider than 992 px:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The form''s layout](img/6463_04_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It's pretty hard to tell them apart! I know, the input fields are going to get
    unnecessarily wide if someone has this form open at full width on his/her brand
    new Thunderbolt. But really, we don't need or want any other content on this page
    to interfere, so we will make a small effort to still make the page look pleasing.
  prefs: []
  type: TYPE_NORMAL
- en: Ok, enough of talk! Let's write some code.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s put one of those small hero areas just above the form. I always
    like the opportunity to add a human touch to things that I create on the Web,
    so just under the header, let''s place this markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You should probably put your own message in there, but you get the idea.
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, let''s put the markup we''ll need for the form. The markup we''ll
    be using here goes after the hero:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This markup is mostly straightforward, but I have used markup that is slightly
    opinionated and is good practices. First, you will notice that I have not supplied
    a value for the `action` parameter for the form that is used to post form data
    to a server. I will leave that to you, as we will not be making a backend to handle
    this data (alternatively, you can use one of the many nifty services out there
    that will handle contact and e-mail forms for you).
  prefs: []
  type: TYPE_NORMAL
- en: Moving down the code, you will notice that I have wrapped every label and input
    pairing in `<p>` `</p>` tags. This isn't uncommon but it is an opinionated way
    to handle the laying out of the form. I prefer not to style inputs and form controls
    if I can avoid it. For sites that grow, these can lead to a lot of work that isn't
    reusable. You can eliminate or reduce this by relying on styling some elements
    that wrap the form controls. As always, keep these elements semantically appropriate.
    I would argue that a label and an input form something of a paragraph, as they
    share the same subject and are a break in the subject of the content that follows.
  prefs: []
  type: TYPE_NORMAL
- en: Input label magic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Also, especially for mobiles, always take advantage of the `for` attribute in
    the label that works only if you set the value of that parameter to mirror the
    value of the ID of the input you want to associate with it. In other words, if
    your label is the **E-mail** input, give that input an ID of `email` (`id=email`)
    and set the label to `email` as well (`name=email`). This practice is not just
    semantic, otherwise, I probably wouldn't bother. Once you have paired an input
    and a label in this way, some magic happens. The label now gets magical powers—when
    a user clicks or touches the label, the input it is paired with will get focus.
    This standard has been around long before the practice of browsing the web with
    touch interfaces was common, but what an awesome feature for touch! Now, users
    with fat fingers, shaky hands, or imprecise movements will be more likely to hit
    their mark. If you never knew this, test it out. If you knew about it already,
    I hope you skipped this paragraph; time is precious.
  prefs: []
  type: TYPE_NORMAL
- en: 'I still have a few more things to point out. I have placed the `required` attribute
    on all fields that I want to be mandatory. This attribute is new to the HTML 5
    spec and does some nice magic under the hood. We will need to make a fallback
    for browsers that don''t support this feature, but you can temporarily enjoy the
    fantasy that HTML 5 will make your work as a web developer easier than it was
    before (don''t worry, you still need to write some JavaScript to help validate
    this form). Still, this feature will be a time saver once you get to the point
    where nearly all your potential users are using modern browsers (the question
    is, when will that be?). Anyway, go ahead and try it out. Start up a simple server,
    such as the Python Simple HTTP server, and visit your contact form in its current
    state. Don''t bother filling out the form, then hit **Send It**. If you are using
    Chrome, you will get a nice validation error message, **Please fill out this field**,
    in a tooltip:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Input label magic](img/6463_04_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Modern versions of other browsers (Firefox, Safari, and Internet Explorer) will
    do something similar. Try it on your mobile too; it's pretty nice!
  prefs: []
  type: TYPE_NORMAL
- en: Okay, the fun will be over soon enough, as we will need to make fallbacks for
    browsers that don't support this feature. But we still have a few fun enhancements
    to add, thanks to the HTML 5 spec. Next, I'd like to point out the absolutely
    painless enhancements you get with some HTML 5 form field attributes. You will
    notice that the input for an e-mail is set to `type="email"`. That attribute gets
    you two kinds of special sauces. On both the desktop and mobile (in browsers that
    support it, of course), you get the kind of validation for e-mail addresses that
    we've been writing in JavaScript for years. It looks for an `@` and all that.
    On a mobile, it should open a soft keyboard that features a prominent `@` as well.
  prefs: []
  type: TYPE_NORMAL
- en: The other field we use with a nifty attribute introduced in HTML 5 is the `type="tel"`
    attribute. The only benefit to this is that on mobiles, it will pull up a numeric
    keyboard rather than an alpha keyboard.
  prefs: []
  type: TYPE_NORMAL
- en: '![Input label magic](img/6463_04_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is just a really nice thing to do for those poor souls filling out a form
    on a small screen. Your users will thank you.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's add the minimal styling that we will need to get this to look consistent
    with the rest of our apps. Everything looks pretty great; the only exception is
    that the borders on the inputs are orange. If you are using SASS, and your compiler
    writes the line numbers of the styles, this is really easy to debug. I've been
    encouraging you to use SASS all along, but one thing I really like is the ability
    to print the line numbers of all the style selectors while you are in development.
    You really need to compile the compressed CSS for production, but for development,
    always switch over to code that is friendly for debugging. I use CodeKit for this
    and for a handful of other reasons. I should add that I generally use open source,
    Command-Line Tools. For example, I use `tmux` and `vim` to write code, not a standalone
    text editor. But Codekit has so many useful features that are effortless to configure
    and I am really addicted to it. I only wish it had a command-line version.
  prefs: []
  type: TYPE_NORMAL
- en: CodeKit makes my whole day easier when I have to solve problems in CSS.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is what I see in Chrome development tools when I look at what is going
    on with these wacky orange borders:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Input label magic](img/6463_04_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: I see that the border properties are defined at line 79 in _`forms.scss`. Super
    helpful, yes?
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, that is not the end of the story. When I get to that line of
    code, here is what I see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Right off I notice two things. The border color is defined with the variable
    `$inputborder` and the hover color for that border is defined with `$inputhover`.
    In my opinion, these are poorly named variables as they are not semantically accurate,
    but to be fair, I've done worse in the past. At any rate, if I could pick an improvement
    here, it would be to name these variables something in order to point out the
    fact that they are actually variables for color—something such as `$inputbordercolor`
    and `$inputborderhovercolor`. Sure, those are long names, but they are precise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, moving on. We need to go to the `_variables.scss` partial to see what
    is going on. Why are these borders orange, for goodness sake? Don''t panic, help
    is on the way. Going into the `_variables.scss` file, I do a quick search for
    `$inputborder` and here is what I see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Let's think about what is going on in the code. For many designs, using the
    base color for input borders can create a harmonious design. But, in my example,
    I have chosen a yellowish orange color, which makes for pretty low-contrast borders.
    To be honest, they look annoying to me; I can't imagine what they look like to
    someone who has visual challenges. But, furthermore, I would guess that 90 percent
    of the time, I want my input borders to be some shade of grey. Why? Well, with
    something as critical as creating a form, I want to make sure that the fields
    are well defined with a high-contrast color, and with a white background, the
    greatest contrast comes with black. If `#000` black looks too stark, we can always
    choose a darker shade of gray that is near to black. At this point, I think it's
    best for this design (and perhaps others in the future) to go ahead and redefine
    this variable as some shade of gray.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'I actually experimented with all the greys defined in this variable file, and
    I prefer the lighter grey. It helps the rows look more organized. Another thing
    you may have noticed by now is that the border still changes to an orange color
    when you hover over the input. Let''s make that a darker grey instead. Similar
    to what we followed previously, you will notice that the `input:hover` style is
    defined in the `_forms.scss` file. It looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: So now we go to the `_variables.scss` file to redefine `$inputhover`!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s make it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Looks good!
  prefs: []
  type: TYPE_NORMAL
- en: We just need a few more things to tune up the styles on this page. Let's make
    the inputs look nicer and more consistent in terms of how inputs are rendered
    in a mobile browser. You will notice in the previous screenshot on the form of
    an iPhone (or on your own mobile, if you are checking your work there) that the
    inputs automatically get rounded corners on the mobile. Let's set a style to do
    that in our forms page.
  prefs: []
  type: TYPE_NORMAL
- en: I want to change all inputs across the site, so I am going to go and edit the
    `_forms.scss` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update this style:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'While using `rounded mixin`, I like 6 px, but feel free to round it to your
    taste. One more thing that I''d like to change with these inputs is the padding.
    Having a big target is nice, but they could also do with a little breathing room
    between the words and the border of the input. Just below that `rounded mixin`,
    let''s add some padding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Looking much better!
  prefs: []
  type: TYPE_NORMAL
- en: The last styling task we have on this page is to contain the width of the form.
    Let's keep the form from getting any wider than 992 px and keep it centered.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do that without having to use any `@` media queries actually. Let''s
    go back to the `site.scss` file and add a style that will work the same if we
    want to reuse it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This does exactly what I described previously. This is actually a great example
    of how to think about being responsive without necessarily relying on newer standards.
  prefs: []
  type: TYPE_NORMAL
- en: Okay, now the last thing we need to do is go hook up the validation that will
    work for browsers that don't yet support the HTML 5 `required` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: JS validation fallbacks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Well, we could write all our fallbacks. Knowing how to write fallbacks is super
    useful but that is beyond the scope of this book. Also, there is a really awesome
    way to make fallbacks that have been made already. It is called **webshims** and
    you can find it here: [http://afarkas.github.io/webshim/demos/index.html](http://afarkas.github.io/webshim/demos/index.html).'
  prefs: []
  type: TYPE_NORMAL
- en: This library makes it super easy to take advantage of a lot of HTML 5 features
    without writing a ton of support for older browsers. In our case, we will have
    to do very little to support the HTML 5 validation in our form.
  prefs: []
  type: TYPE_NORMAL
- en: Download the lib from the site I listed previously. Once you do that, copy the
    `js-webshim` folder to your project. I've already done that in the `after` folder
    for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we need to do two more things and we will be good to go.
  prefs: []
  type: TYPE_NORMAL
- en: 'Include the `polyfiller` script from the `webshims` lib at the bottom of the
    `contact.html` page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: You must put this after jQuery but before the scripts you write.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now in `script.js`, add this line to instantiate the `polyfiller` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: I have put this inside the `ready` function to make sure that all the form elements
    are present in the **Document Object Model** (**DOM**) before it fires.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we're done polyfilling our form validation and it should work in browsers
    that don't support HTML 5 validation. Enjoy!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, in this chapter, we planned our way to a much simpler layout than any of
    our other pages, but for good reason. No one likes filling out forms much, but
    if we can keep the noise down on pages with forms, we can encourage users to give
    us the information to better facilitate communication. Or at the very least, we
    won't discourage people from filling out our form.
  prefs: []
  type: TYPE_NORMAL
- en: Probably, the biggest challenge here is the cross-browser support for client-side
    validation. Until it is known that the majority of users use modern browsers,
    we still need to shim and polyfill, but as we saw, well-written code makes that
    fairly easy too, unless our requirements are complex.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's move on to the **About Me** page.
  prefs: []
  type: TYPE_NORMAL
