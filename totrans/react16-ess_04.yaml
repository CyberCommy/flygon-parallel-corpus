- en: Chapter 4. Creating Your First React Component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, you learned how to create React elements and how to
    use them to render the HTML markup. You saw how easy it is to produce React elements
    using JSX. At this point, you know enough about React to create static web pages,
    which we discussed in [Chapter 3](ch03.html "Chapter 3. Creating Your First React
    Element"), *Creating Your First React Element*. However, I bet that's not the
    reason why you've decided to learn React. You don't want to just build websites
    made of static HTML elements. You want to build interactive user interfaces that
    react to user and server events. What does it mean to react to an event? How can
    a static HTML element **react**? How can a React element react? In this chapter,
    we'll answer these questions and many other questions while introducing ourselves
    to React components.
  prefs: []
  type: TYPE_NORMAL
- en: Stateless versus stateful
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To react means to switch from one state to another. This means that you need
    to have a state in the first place and the ability to change that state. Have
    we mentioned a state or the ability to change that state in React elements? No.
    They are stateless. Their sole purpose is to construct and render virtual DOM
    elements. In fact, we want them to render in the exact same way, given that we
    provide them with exactly the same set of parameters. We want them to be consistent
    because it makes it easy for us to reason about them. This is one of the key benefits
    of using React—the ease of reasoning about how our web application works.
  prefs: []
  type: TYPE_NORMAL
- en: How can we add state to our stateless React elements? If we can't encapsulate
    state in React elements, then we should encapsulate React elements in something
    that already has state. Think of a simple state machine that represents a user
    interface. Every user action triggers a change of a state in that state machine.
    Every state is represented by a different React element. In React, this state
    machine is called a **React component**.
  prefs: []
  type: TYPE_NORMAL
- en: Creating your first stateless React component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following example of how to create a React component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Some of the preceding code should already look familiar to you, and the rest
    can be broken down into two simple steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a React component class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating a React component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s take a closer look at how we can create a React component:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `ReactClass` class as a subclass of the `Component` class. In this
    chapter, we'll focus on learning how to create React component classes in more
    detail.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create `reactComponent` by calling the `ReactDOM.render()` function and providing
    our `ReactClass` element as its element parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'I strongly recommend that you read this blog post by Dan Abramov that explains
    in greater details the differences between React components, elements and instances:
    [https://facebook.github.io/react/blog/2015/12/18/react-components-elements-and-instances.html](https://facebook.github.io/react/blog/2015/12/18/react-components-elements-and-instances.html)'
  prefs: []
  type: TYPE_NORMAL
- en: The look and feel of our React component is declared in `ReactClass`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Component` class encapsulates a component''s state and describes how a
    component is rendered. At the very minimum, the React component class needs to
    have a `render()` method so that it returns `null` or `false`. Here is an example
    of a `render()` method in its simplest form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can guess, the `render()` method is responsible for telling React what
    this component should render. It can return `null`, as in the preceding example,
    and nothing will be rendered on the screen. Or, it can return JSX elements that
    we learned how to create in [Chapter 3](ch03.html "Chapter 3. Creating Your First
    React Element"), *Creating Your First React Element*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This example shows how we can encapsulate our React element inside our React
    component. We create an `h1` element with a `className` property and some text
    as its children. Then, we return it when the `render()` method is called. The
    fact that we encapsulated our React element inside a React component doesn''t
    affect how it will be rendered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the produced HTML markup is identical to the one we created
    in [Chapter 3](ch03.html "Chapter 3. Creating Your First React Element"), *Creating
    Your First React Element*, without using the React component. In this case, you
    might be wondering, what's the benefit of having a `render()` method if we can
    render the exact same markup without it?
  prefs: []
  type: TYPE_NORMAL
- en: 'The advantage of having a `render()` method is that, like with any other function,
    before it returns a value, it can choose what value to return. So far, you''ve
    seen two examples of a `render()` method: one that returns `null` and the other
    one that returns a React element. We can merge the two and add a condition that
    decides what to render:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we created the `componentState` constant that references to
    an object with a single `isHidden` property. This object acts as a state for our
    React component. If we want to hide our React component, then we need to set the
    value of `componentState.isHidden` to `true`, and our `render` function will return
    `null`. In this case, React will render nothing. Logically, setting `componentState.isHidden`
    to `false`, will return our React element and render the expected HTML markup.
    The question you might ask is how do we set the value of `componentState.isHidden`
    to `false`? Or to `true`? Or how do we change it in general?
  prefs: []
  type: TYPE_NORMAL
- en: Let's think of scenarios in which we might want to change that state. One of
    them is when a user interacts with our user interface. Another one is when a server
    sends data. Or, when a certain amount of time passes, and now, we want to render
    something else. Our `render()` method is not aware of all these events, and it
    shouldn't be because its sole purpose is to return a React element based on the
    data that we pass to it. How do we pass data to it?
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to pass data to a `render()` method using the React API:'
  prefs: []
  type: TYPE_NORMAL
- en: '`this.props`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`this.state`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here, `this.props` should look familiar to you. In [Chapter 3](ch03.html "Chapter 3. Creating
    Your First React Element"), *Creating* *Your First React Element*, you learned
    that the `React.createElement()` function accepts the `props` parameter. We used
    it to pass attributes to our HTML elements, but we didn't discuss what happens
    behind the scene and why attributes passed to the `props` object get rendered.
  prefs: []
  type: TYPE_NORMAL
- en: 'Any data that you put in the `props` object and pass to JSX elements can be
    accessed inside the `render()` method via `this.props`. Once you access data from
    `this.props`, you can render it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we're using `this.props` inside of our `render()` method to
    access the `header` property. We're then passing `this.props.header` directly
    to the `h1 element` as a child.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding example, we can pass the value of `isHidden` as another property
    of the `this.props` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that in this example we''re repeating `this.props` twice. It''s quite
    common for a `this.props` object to have properties that we want to access multiple
    times in our `render` method. For this reason, I recommend that you destructure
    `this.props` first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Have you noticed how in the previous example instead of storing `isHidden` in
    a `render()` method we're passing it via `this.props`? We removed our `componentState`
    object because we don't need to worry about the component's state in our `render()`
    method. The `render()` method shouldn't mutate the component's state or access
    the real DOM or otherwise interact with a web browser. We might want to render
    our React component on a server, where we have no web browser, and we should expect
    the `render()` method to produce the same result regardless of the environment.
  prefs: []
  type: TYPE_NORMAL
- en: If our `render()` method doesn't manage the state, then how do we manage it?
    How do we set the state, and how do we update it while handling user or browser
    events in React?
  prefs: []
  type: TYPE_NORMAL
- en: 'Earlier in this chapter, you learned that in React, we can represent a user
    interface with React components. There are two types of React components:'
  prefs: []
  type: TYPE_NORMAL
- en: With a state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Without a state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hold on! Didn't we say that React components are state machines? Surely, every
    state machine needs to have a state. You're correct, however, it's a good practice
    to keep as many React components stateless as possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'React components are composable. As a result, we can have a hierarchy of React
    components. Imagine that we have a parent React component that has two child components,
    and each of them in turn has another two child components. All the components
    are stateful and they can manage their own state:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating your first stateless React component](graphics/B05915_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'How easy will it be to figure out what the last child component in the hierarchy
    will render, if the top component in the hierarchy updates its state? Not easy.
    There is a design pattern that removes this unnecessary complexity. The idea is
    to separate your components by two concerns: how to handle the user interface
    interaction logic and how to render data.'
  prefs: []
  type: TYPE_NORMAL
- en: The minority of your React components are stateful. They should be at the top
    of your components' hierarchy. They encapsulate all of the interaction logic,
    manage the user interface state, and pass that state down the hierarchy to stateless
    components using `props`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The majority of your React components are stateless. They receive their parent
    components' state data via `this.props` and render that data accordingly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In our previous example, we received the `isHidden` state data via `this.props`,
    and then we rendered that data. Our component was stateless.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's create our first stateful component.
  prefs: []
  type: TYPE_NORMAL
- en: Creating your first stateful React component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Stateful components are the most appropriate place for your application to handle
    the interaction logic and manage states. They make it easier for you to reason
    about how your application works. This reasoning plays a key role in building
    maintainable web applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'React stores the component''s state in a `this.state` object. We assign the
    initial value of `this.state` as a public class field of the `Component` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, `{ isHidden: false }` is the initial state of our React component and
    our user interface. Notice that in our `render()` method, we''re now destructuring
    the `isHidden` property from `this.state` instead of `this.props`.'
  prefs: []
  type: TYPE_NORMAL
- en: Earlier in this chapter, you learned that we can pass data to the component's
    `render()` function via `this.props` or `this.state`. What is the difference between
    the two?
  prefs: []
  type: TYPE_NORMAL
- en: '`this.props`: This stores read-only data that is passed from the parent. It
    belongs to the parent and cannot be changed by its children. This data should
    be considered immutable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`this.state`: This stores data that is private to the component. It can be
    changed by the component. The compoent will re-render itself when the state is
    updated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'How do we update a component''s state? You can inform React of a state change
    using `setState(nextState, callback)`. This function takes two parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `nextState` object that represents the next state. It could also be a function
    with a signature of `function(prevState, props) => newState`. This function takes
    two parameters: previous state and properties, and returns an object that represents
    a new state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `callback` function, which you will rarely need to use because React keeps
    your user interface up to date for you.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How does React keep your user interface up to date? It calls the component's
    `render()` function every time you update the component's state, including any
    child components, which are re-rendered as well. In fact, it re-renders the entire
    virtual DOM every time our `render()` function is called.
  prefs: []
  type: TYPE_NORMAL
- en: When you call the `this.setState()` function and pass it a data object that
    represents the next state, React will merge that next state with the current state.
    During the merge, React will overwrite the current state with the next state.
    The current state that is not overwritten by the next state will become part of
    the next state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine that this is our current state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We call `this.setState(nextState)`, where `nextState` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'React will merge the two states into a new one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `isHidden` property was updated and the `title` property was not deleted
    or updated in any way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we know how to update our component''s state, let''s create a stateful
    component that reacts to a user event:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we''re creating a toggle button that shows and hides a header.
    The first thing we do is that we set our initial state object. Our initial state
    has two properties: `isHeaderHidden` that is set to `false`, and the title set
    to `Stateful React Component`. Now, we can access this state object in our `render()`
    method via `this.state`. Inside our `render()` method, we create three React elements:
    `h1`, `button`, and `div`. Our `div` element acts as a parent element for our
    `h1` and `button` elements. However, in one case, we create our `div` element
    with two children, the `header` and `button` elements, and in another case, we
    create it with only one child, the `button`. The case we choose depends on the
    value of `this.state.isHeaderHidden`. The current state of our component directly
    affects what the `render()` function will render. While this should look familiar
    to you, there is something new in this example that we haven''t seen before.'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we've added a new method called `handleClick()` to our component
    class. The `handleClick()` method has no special meaning to React. It's part of
    our application logic, and we use it to handle the `onClick` events. You can add
    your own custom methods to a React component class as well because it's just a
    JavaScript class. All of these methods will be available via a `this` reference,
    which you can access in any method in your component class. For example, we are
    accessing a state object via `this.state` in both the `render()` and `handleClick()`
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'What does our `handleClick()` method do? It updates our component''s state
    by toggling the `isHeaderHidden` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `handleClick()` method reacts to a user''s interaction with our user interface.
    Our user interface is a `button` element that a user can click on, and we can
    attach an event handler to it. In React, you can attach event handlers to components
    by passing them to JSX properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: React uses the **camelCase** naming convention for event handlers, for example,
    `onClick`. You can find a list of all the supported events at [http://facebook.github.io/react/docs/events.html#supported-events](http://facebook.github.io/react/docs/events.html#supported-events).
  prefs: []
  type: TYPE_NORMAL
- en: By default, React triggers the event handlers in the bubble phase, but you can
    tell React to trigger them in the capture phase by appending `Capture` to the
    event name, for example, `onClickCapture`.
  prefs: []
  type: TYPE_NORMAL
- en: React wraps a browser's native events into the `SyntheticEvent` object to ensure
    that all the supported events behave identically in Internet Explorer 8 and above.
  prefs: []
  type: TYPE_NORMAL
- en: The `SyntheticEvent` object provides the same API as the native browser's event,
    which means that you can use the `stopPropagation()` and `preventDefault()` methods
    as usual. If for some reason, you need to access that native browser's event,
    then you can do this via the `nativeEvent` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that passing the `onClick` property to our `createElement()` function
    in the previous example does not create an inline event handler in the rendered
    HTML markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This is because React doesn't actually attach event handlers to the DOM nodes
    themselves. Instead, React listens for all the events at the top level using a
    single event listener and delegates them to their appropriate event handlers.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous example, you learned how to create a stateful React component
    that a user can interact with and change its state. We created and attached an
    event handler to the `click` event that updates the value of the `isHeaderHidden`
    property. But have you noticed that the user interaction does not update the value
    of another property that we store in our state, `title`. Does that seem odd to
    you? We have data in our state that doesn't ever get changed. This observation
    raises an important question; what should we *not* put in our state?
  prefs: []
  type: TYPE_NORMAL
- en: Ask yourself, "What data can I remove from a component's state and still keep
    its user interface always up to date?" Keep asking and keep removing that data
    until you're absolutely certain that there is nothing left to remove, without
    breaking your user interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example, we have the `title` property in our state object that we can
    move to our `render()` method, without breaking the interactivity of our toggle
    button. The component will still work as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, if we move the `isHeaderHidden` property out of our state
    object, then we''ll break the interactivity of our component, because our `render()`
    method will not be triggered automatically by React every time that a user clicks
    on our button anymore. This is an example of broken interactivity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Note**: For better results in the output, please refer to the code files.'
  prefs: []
  type: TYPE_NORMAL
- en: This is an antipattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember this rule of thumb: a component''s state should store data that a
    component''s event handlers may change over time in order to re-render a component''s
    user interface and keep it up to date. Keep the minimal possible representation
    of a component''s state in a `state` object, and compute the rest of the data
    based on what''s in `state` and `props` inside a component''s `render()` method.
    Take advantage of the fact that React will re-render your component when its state
    is changed.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you reached an important milestone: you learned how to encapsulate
    a state and create interactive user interfaces by creating React components. We
    discussed stateless and stateful React components and the difference, between
    them. We talked about browser events and how to handle them in React.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you'll learn what's new in React 16.
  prefs: []
  type: TYPE_NORMAL
