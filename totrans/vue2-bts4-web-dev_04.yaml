- en: Chapter 5. Configuring Your Pomodoro
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we implemented the main feature of our ProFitOro application
    – the Pomodoro timer. We even added a hardcoded workout, so we can exercise during
    our breaks. Actually, I already started using ProFitOro. While I'm writing these
    words, the Pomodoro clock counts down – *tick tick tick tick*.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we are going to explore the *Firebase Realtime Database's*
    possibilities and its API. We are going to manage storing, retrieving, and updating
    usage statistics and configuration of our application. We will use the Vuex store
    to bring the application's data from the database to the frontend application.
  prefs: []
  type: TYPE_NORMAL
- en: 'To bring this possibility to the UI, we will use Vue''s reactivity combined
    with the power of Bootstrap. Thus, in this chapter we are going to implement the
    statistics and settings ProFitOro components using:'
  prefs: []
  type: TYPE_NORMAL
- en: Firebase Realtime Database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vue.js reactive data bindings and Vuex state management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The power of Bootstrap to make things responsive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up a Vuex store
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before starting with real data from the database, let's set up the Vuex store
    for our ProFitOro. We will use it to manage the Pomodoro timer configuration,
    user settings, such as the username, and a profile picture URL. We will also use
    it to store and retrieve the application's usage statistics.
  prefs: []
  type: TYPE_NORMAL
- en: From [Chapter 2](part0024_split_000.html#MSDG2-449ee41b57ea4c048225480b41c8dbe3
    "Chapter 2. Under the Hood – Tutorial Explained"), *Hello User Explained*, you
    already know how the Vuex store works. We must define data that will represent
    the application's state and then we must provide all the needed getters to get
    the data and all the needed mutations to update the data. Once all this is set,
    we will be able to access this data from the components.
  prefs: []
  type: TYPE_NORMAL
- en: After the application's store is ready and set up, we can connect it to the
    real-time database and slightly adjust the getters and mutations to operate the
    real data.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we need to tell our application that it will use the Vuex store.
    To do that, let''s add the `npm` dependency for `vuex`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to define a basic structure of our store. Our Vuex store will
    contain the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**State**: The initial state of the application''s data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Getters**: Methods that retrieve the state''s attributes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mutations**: Methods that provide a way to change the state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Actions**: Methods that can be dispatched to invoke mutations. The only difference
    between actions and mutations is that actions can be asynchronous and we might
    need them for our application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Sounds pretty easy, right? Just create a folder called `store` and create JavaScript
    files for all the things that we have just indicated. Also create the `index.js`
    file that will instantiate a Vuex store with all these things. Here is your structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up a Vuex store](../images/00088.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The structure of the store folder
  prefs: []
  type: TYPE_NORMAL
- en: 'When we first mentioned the Vuex store in [Chapter 2](part0024_split_000.html#MSDG2-449ee41b57ea4c048225480b41c8dbe3
    "Chapter 2. Under the Hood – Tutorial Explained"), *Hello User Explained*, we
    simplified the structure and introduced all the store''s components in the same
    file. Now, we will follow the nice modular structure and let everything reside
    in its own place. We could even go further and separate the state into the modules
    (one for configuration, another one for settings, and so on) but it would probably
    be overkill for the complexity level of ProFitOro. However, if you want to check
    how to separate your store into logical modules, check the section about modules
    in this great documentation about Vuex: [https://vuex.vuejs.org/en/](https://vuex.vuejs.org/en/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Nevertheless, let''s continue with our store. After having created the structure,
    import all of the store''s components into `index.js` and create a Vuex instance,
    passing all of them as parameters. Do not forget to import Vuex and to tell Vue
    to use it! Thus, the entry point of our store will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The only thing that matters now, so our setup is totally complete, is to get
    our application to know that it is now using this store. In this way, the store
    will become available in all the components. The only thing that you need to do
    to make it possible is to import our store in the application''s entry point (`main.js`)
    and to pass it to the Vue instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we are totally ready to start our magic with the store. Have you been missing
    coding? Well, here you go! Let''s start by replacing the `config` file that we''ve
    created as a container for the Pomodoro timing properties with the state and the
    getters of our store. Just copy all the configuration elements of the `config`
    file to our state and create a getter for it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now move to getters. Getters are not just regular functions. Behind
    the scenes, they receive the state as a parameter, so you can access the data
    of the application''s state, without any effort of dependency injections, because
    it has already been managed for you by Vuex. So, just create a function that receives
    the state as a parameter and returns any of the state''s data! If needed, inside
    the getter, you can perform any operations on the data. So, the getter for the
    `config` file could look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we are using ES6, it can be rewritten in a more succinct and elegant
    way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, it can be exported:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can simply use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The whole thing can actually be written as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: How amazingly simple is that? At the time I started working with JavaScript
    (don't ask me when, I don't like to feel old myself), I could barely imagine that
    such syntax would ever be possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can now use your new getter inside any application''s component. How? Do
    you remember how easy it was to access the state using the `this.$store.state`
    attribute? In the same way, inside the computed data function, you can access
    your `getters`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'From now on, `this.config` can be used in all the component''s computed values
    and methods. Let''s imagine now, that inside the same component, we need to use
    more than one getter. Imagine, for example, that we create getters for each of
    the config''s values. So, for every value you would have to repeat this tedious
    code: `this.$store.getters.bla-bla-bla`. Argh! There must an easier way... and
    there is. Vuex is kind enough to provide us with a helper object which is called
    `mapGetters`. If you simply import this object into your component, you can invoke
    your getters using `mapGetters` with the ES6 spread operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, if you want to map your getters methods to some other names,
    just use an object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'So, this is what we are going to do. We are going to use the `mapGetters` helper
    inside the `PomodoroTimer` component and we will remove the reference to the imported
    `config` file (also, do not forget to remove the file itself; we don''t want dead
    code in our code base). We will replace all the references to `config` with `this.config`.
    So, our `PomodoroTimer` script''s section will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Check your page, everything should work the same way it has been working before.
    What is the advantage of this new approach?—someone might ask,—we've been here
    for half a chapter setting up this store and its methods, getters, actions, whatever…
    In the end, we have the exact same behavior. What for? Well, do you remember that
    the whole aim of this chapter is to be able to configure and reconfigure the Pomodoro
    timing settings and to store them in the database? If we had to introduce the
    database reference and all the operations of retrieving and storing data inside
    our components, our life would be harder. Imagine that at some point Firebase
    does not suit your needs and you wish to switch to another data source, or even
    a different technology, let's say *Elasticsearch* or even *MongoDB*. You would
    have to change your component and its methods, as well as its computed values.
    Doesn't it sound like hell to maintain all that?
  prefs: []
  type: TYPE_NORMAL
- en: Having your data to reside inside the store and with your getters being responsible
    for retrieving them will enable you to only have to change your getters if you
    decide to change the underlying data source. Your components will always be left
    untouched! It's an abstraction of the data and logic layers of your application.
    Abstractions are a very cool thing in the software engineering field.
  prefs: []
  type: TYPE_NORMAL
- en: Let's define a basic markup for the `Settings.vue` component. Check our mockups.
  prefs: []
  type: TYPE_NORMAL
- en: 'This component will contain two main areas:'
  prefs: []
  type: TYPE_NORMAL
- en: Personal settings configuration area
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pomodoro timer settings configuration area
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Again, I will use Bootstrap grid classes to help me build a nice, responsive
    layout. I want it to make two stack columns on small devices, two equal-size columns
    on medium sized devices, and two different sized columns on large devices. Thus,
    I will use the `row` class for the wrapping `div` and corresponding `col-*-*`
    classes for the two main areas of our `Settings` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s concentrate for now only on the Pomodoro timing settings configuration.
    I created a component called `SetTimer.vue`. This component just contains a number-type
    input and emits a method whenever its value changes. Within the Pomodoro settings
    container, I will render this component three times using different values from
    the imported `mapGetters` helper:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'With some CSS magic for the `SetTimer` component, I am able to render three
    input circles like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up a Vuex store](../images/00089.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Input balls that allow us to set timers for different Pomodoro interval
  prefs: []
  type: TYPE_NORMAL
- en: You can find the corresponding code in the `chapter5/1/profitoro` folder. In
    particular, check the `SetTimer.vue` component inside the `components/main/sections/timer`
    folder and how it's being called with the corresponding values inside the `Settings.vue`
    component.
  prefs: []
  type: TYPE_NORMAL
- en: Defining actions and mutations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's great that our components can now get data from the store, but it would
    be probably even more interesting if our components were also able to change the
    data in the store. On the other hand, we all know that we cannot modify the store's
    state directly.
  prefs: []
  type: TYPE_NORMAL
- en: The state should not be touched by any of the components. However, you also
    remember from our chapter about the Vuex store that there are special functions
    that can mutate the store. They are even called `mutations`. These functions can
    do whatever they/you want with the Vuex store data. These mutations can be called
    using the `commit` method applied to the store. Under the hood, they essentially
    receive two parameters – the state and the value.
  prefs: []
  type: TYPE_NORMAL
- en: 'I will define three mutations – one for each of the timer''s definitions. These
    mutations will update the corresponding attribute of the `config` object with
    a new value. Thus, my mutations look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can define actions. Actions will basically call our mutations, so it
    can be considered as duplicate work. However, keep in mind that the difference
    between actions and mutations is that actions can actually be asynchronous, so
    it might come in handy when we connect our actions to the database. For now, let''s
    just tell the actions to verify the received values before committing them. The
    `actions` method receives the store and a new value. Since the store provides
    us with the essential method called `commit,` which is called with the name of
    the needed mutation, we can define each action as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can write `{commit}` as a parameter and use the `commit` function right away,
    because we are using ES6 and object destructing just works perfectly for us ([https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, my actions look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s go back to the `Settings.vue` component. This component should
    import actions and call them when needed, right? How do we import actions? Do
    you remember the `mapGetters` helper? There is a similar helper for actions called
    `mapActions`. So, we can just import it along with the `mapGetters` helper and
    use it with a spread operator (`…`) inside the `methods` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have to invoke the needed actions whenever the values of the `set-timer`
    inputs change. In the previous paragraph, we discussed that the `SetTimer` component
    emits the `changeValue` event. So, the only thing we have to do now is to bind
    this event to all three `set-timer` components and call the corresponding methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Open the page and try to change the values of each timer setting.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are using the Chrome browser and still haven''t installed Vue developer
    tools, please do it. You will see how handy and lovely it is! Just follow this
    link: [https://goo.gl/22khXD](https://goo.gl/22khXD).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Having installed the Vue devtools extension, you will immediately see how the
    values are being changed in the Vuex store:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Defining actions and mutations](../images/00090.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Once the values are changed in the input boxes, they are immediately changed
    in the Vuex store
  prefs: []
  type: TYPE_NORMAL
- en: Check the final code for this section in the `chapter5/2/profitoro` folder.
    Pay attention to the `actions.js` and `mutations.js` files inside the store folder
    and to the `Settings.vue` component.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a Firebase project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I hope that you still remember how to set up Firebase projects from the first
    chapters of this book. Open your Firebase console at [https://console.firebase.google.com](https://console.firebase.google.com),
    click on the **Add project** button, name it, and choose your country. The Firebase
    project is ready. Wasn''t that easy? Let''s now prepare our database. The following
    data will be stored in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Configuration**: The configuration of our Pomodoro timer values'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Statistics**: Statistical data of the Pomodoro usage'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of these objects will be accessible via a special key that will correspond
    to a user's ID; this is because, in the next chapter, we are going to implement
    an authentication mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: The configuration object will contain values – `workingPomodoro`, `longBreak`
    and `shortBreak` – that are already familiar to us.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add a configuration object to our database with some fake data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'You can even create this as a simple JSON file and import it to your database:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up a Firebase project](../images/00091.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Import JSON file to your real-time Firebase database
  prefs: []
  type: TYPE_NORMAL
- en: 'Congratulations, your real-time database is ready! Keep in mind that, by default,
    the security rules will not allow you to access your data from the exterior unless
    you are authenticated. Let''s, for now, remove these rules. We will add them later,
    once we have implemented our authentication mechanism. Click on the **RULES**
    tab and replace the existing ones with this object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Now we are ready to access our real-time database from our Vue application.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting the Vuex store to the Firebase database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So, now we have to connect our Vuex store to the Firebase database. We could
    use the native Firebase API for binding the state data to the database data, but
    why would we deal with promises and stuff if someone already did that for us?
    This someone is called Eduardo and he has created Vuexfire – Firebase bindings
    for Vuex ([https://github.com/posva/vuexfire](https://github.com/posva/vuexfire)).
    If you were at the *vueconf2017 conference* in *Wroclaw*, you probably remember
    this guy:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Connecting the Vuex store to the Firebase database](../images/00092.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Eduardo talking about Vue and Firebase during the Vue conference
  prefs: []
  type: TYPE_NORMAL
- en: 'Vuexfire comes with Firebase mutations and actions that will do all the behind
    the scenes jobs for you, while you just export them within your mutations and
    actions objects. So, to start with, install both `firebase` and `vuexfire`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Import `firebase` and `firebaseMutations` in your store''s `index.js` entry
    point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to obtain the reference to the Firebase application. Firebase
    comes with an initialization method, `initializeApp,` which receives an object
    composed of lots of application settings data – app ID, authentication domain,
    and so on. For now, we have to at least provide the database URL. In order to
    get your database URL, just go to your Firebase project settings and click on
    the **Add Firebase to your web app** button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Connecting the Vuex store to the Firebase database](../images/00093.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Click on the Add Firebase to your web app button
  prefs: []
  type: TYPE_NORMAL
- en: 'Copy the database URL, or even the whole configuration object, and paste it
    to your store''s `index.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'You are now ready to obtain the reference to the configuration object. Once
    we implement the authentication mechanism, we will use the authenticated user''s
    ID to get the current user''s configuration from the database. For now, let''s
    use our hardcoded ID `test`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'I will export the `configRef` reference using the spread operator in the state
    object. So, this reference becomes accessible by the actions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to make the whole Vuexfire magic work, we have to also export `firebaseMutations`
    within the `mutations` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'So, our whole `store/index.js` now looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Let's go to our actions now. It is very important that before doing anything
    else, we bind our database reference to the corresponding state's attribute. In
    our case, we must bind the state's `config` object to its corresponding reference
    `configRef`. For that, our friend Eduardo provides us with the actions enhancer
    called `firebaseAction` that implements the `bindFirebaseRef` method. Just call
    this method and you don't have to worry about promises and their callbacks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `action.js` and import `firebaseAction` enhancer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now create an action called `bindConfig`, where we will actually bind
    two things together using the `bindFirebaseRef` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'When should this action be dispatched? Probably on the `Settings.vue` component
    creation, since this component is responsible for rendering the `config` state.
    Thus, inside the `Settings.vue` we bind the state of the `created` component and
    inside of it, we just call the `bindConfig` action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: If you open the page now, you will see that everything remains the same. The
    only difference is that, now, we are using the data coming from our real-time
    database and not from the hardcoded `config` object. You can check it by completely
    deleting the content of the `config` object inside the state store's object and
    ensuring that everything is still be working.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you try to change the input values and then refresh the page, you will see
    that the applied changes are not saved. This happens because we did not update
    the database reference. So let''s update it! The good thing about it is that we
    don''t need to change *anything* inside our components; we just have to slightly
    change our *actions*. We will use the `update` method called on the reference.
    Please check the Firebase real-time database documentation on reading and writing
    data: [https://firebase.google.com/docs/database/web/read-and-write](https://firebase.google.com/docs/database/web/read-and-write).'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we will pass the `state` object to each of the actions and call the `update`
    method on `state.configRef`, passing to it the corresponding changed attribute.
    So, it might look as simple as the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Do not forget to perform the needed checks, parse the updated attribute to an
    integer, and also check if `configRef` is available. If it's not available, just
    call the `commit` method with the corresponding mutation's name. Check the final
    code for this section in the `chapter5/3/profitoro` folder. Pay special attention
    to the `store/index.js` and `store/actions.js` files and to the `Settings.vue`
    component.
  prefs: []
  type: TYPE_NORMAL
- en: If you open your page and change the Pomodoro timer values and keep looking
    at your Firebase console database tab you will see the differences immediately!
  prefs: []
  type: TYPE_NORMAL
- en: '![Connecting the Vuex store to the Firebase database](../images/00094.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The changes applied to the Pomodoro timer configuration boxes are propagated
    immediately to the real-time database
  prefs: []
  type: TYPE_NORMAL
- en: If you change values directly in the database, you will also see that the changes
    are immediately propagated to your view.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You have learned how to connect the real-time Firebase database to your Vue
    application and used this knowledge to update the configurations for Pomodoro
    timers. Now, apply your knowledge to the statistics area. For the sake of simplicity,
    just display the total amount of Pomodoros executed since the user started using
    the application. For that you will need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Add another object called `statistics` containing the `totalPomodoros` attribute
    that initially equals `0` in your Firebase database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an entry in the store's `state` to hold the statistics data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Map `totalPomodoros` of the statistics state's object to the Firebase reference
    using the `firebaseAction` enhancer and the `bindFirebaseRef` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an action that will update the `totalPomodoros` reference.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call this action whenever it has to be called inside the `PomodoroTimer` component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Display this value inside the `Statistics.vue` component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try to do it yourself. It shouldn't be difficult. Follow the same logic we applied
    in the `Settings.vue` component. If in doubt, check the `chapter5/4/profitoro`
    folder, particularly the store's files – `index.js`, `state.js` and `actions.js`.
    Then check how the corresponding actions have been used inside the `PomodoroTimer`
    component and how it is rendered in the `Statistics` component. Good luck!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use the real-time Firebase database with
    the Vue application. You learned how to use Vuexfire and its methods to correctly
    bind our Vuex store state to the database reference. We were not only able to
    read and render the data from the database but we were also able to update it.
    So, in this chapter, we saw Vuex, Firebase, and Vuexfire in action. I guess we
    should be proud of ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: However, let's not forget that we have used a hardcoded user ID in order to
    get the user's data. Also, we had to expose our database to the world by changing
    the security rules, which doesn't seem right either. It seems that it's time to
    enable the authentication mechanism!
  prefs: []
  type: TYPE_NORMAL
- en: 'And we will do it in the next chapter! In the next chapter, we are going to
    learn how to set up the authentication mechanism using the Firebase authentication
    framework. We will learn how to use it in our application using Vuefire (Firebase
    bindings for Vue: [https://github.com/vuejs/vuefire](https://github.com/vuejs/vuefire)).
    We will also implement the very initial view of our application responsible for
    providing a way of registering and performing the login. We will use Bootstrap
    form elements in order to make this screen responsive and adaptive to all screen
    sizes. So, let''s move on to the next chapter! Do not forget to do some pushups
    first!'
  prefs: []
  type: TYPE_NORMAL
