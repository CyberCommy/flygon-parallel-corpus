- en: Tips and Tricks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Logging customization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing the code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Benchmarking the code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating subtests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing the HTTP handler
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing tags via reflection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sorting slices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Breaking HTTP handlers into groups
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utilizing HTTP/2 server push
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This last chapter adds some additional recipes related to testing, designing
    your application interface, and leveraging the packages, `sort` and `reflect`.
  prefs: []
  type: TYPE_NORMAL
- en: Check if Go is properly installed. The *Getting ready* section in the *Retrieving
    Golang version* recipe of  *[Chapter 1](acf67248-0aa9-4150-a43b-d13eb9de89f2.xhtml)*, *Interacting
    with the Environment* will help you.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure the port `8080`  is not used by another application.
  prefs: []
  type: TYPE_NORMAL
- en: Logging customization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Besides the logging with the default logger from the `log` package, the standard
    library also provides a way to create the custom logger, according to the needs
    of the application or package. This recipe will give a brief insight on how to
    create one.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the console and create the folder `chapter11/recipe01`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the file `logging.go` with the following  content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Execute the code by `go run logging.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'See the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/44cc10f1-f0cf-420c-a81f-be95d1ba11db.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `log` package provides the `New` function which simplifies the creation
    of a customized logger. The `New` function consumes the `Writer`, which could
    be any object implementing the `Writer` interface, the prefix in the form of the
    string, and the form of the logged message that is composed of flags. The last
    argument is the most interesting because with it, you are able to enhance the
    log message with dynamic fields, such as date and filename.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the preceding example uses, for the first logger, the `custLogger`, the
    flags configuring the message to display the date and time in front of the log
    message. The second one, named the `custLoggerEnh`, uses the flag, `Ldate` and
    `Lshortfile`, to show the filename and date.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing and benchmarking naturally belong to software development. Go, as a
    modern language with its built-in libraries, supports these from scratch. In this recipe,
    the basics of testing will be described.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the console and create the folder `chapter11/recipe02`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the file `sample_test.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Execute the test by `go test -v`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'See the output in the Terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ae338ff0-8ef9-4a6e-9f42-b92be7c20285.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `testing` package of the standard library provides support for the code
    testing needs. The `test` function needs to fulfill the name pattern, `TestXXX`.
    By default, the test tool looks for the file named `xxx_test.go`. Note that each
    test function takes the `T` pointer argument, which provides the useful methods
    for test control. By the `T` struct pointer, the status of the test could be set.
    For instance, the methods `Fail` and `FailNow`, cause the test to fail. With the
    help of the `T` struct pointer, the test could be skipped by calling `Skip`, `Skipf`,
    or `SkipNow`.
  prefs: []
  type: TYPE_NORMAL
- en: The interesting method of the `T` pointer is the method `Helper`. By calling
    the method `Helper`, the current function is marked as the helper function, and
    if the `FailNow` (`Fatal`) is called within this function, then the test output
    points to the code line where the function is called within the test, as can be
    seen in the preceding sample code.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the `Log` method, (and its variants), are not visible if the test
    tool is not run in verbose mode (with `-v` flag), or if the particular test failed
    (this applies only for the `T` tests). Try to run this sample code without the
    `-v` flag.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following recipe covers the basics of benchmarking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a more detailed description of the testing package, see the rich documentation
    of the testing package at [https://golang.org/pkg/testing](https://golang.org/pkg/testing)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Benchmarking the code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous recipe walks through the testing part of the testing package, and
    in this recipe, the basics of the benchmarking will be covered.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the console and create the folder `chapter11/recipe03`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the file `sample_test.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Execute the benchmark by `go test -bench=`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'See the output in the Terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ca1e566d-420b-4c88-ae9b-f76989b3ff5c.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Besides the pure test support, the testing package also provides the mechanisms
    for measuring the code performance. For this purpose, the `B` struct pointer as
    the argument is used, and the benchmarking functions in the test file are named
    as `BenchmarkXXXX`.
  prefs: []
  type: TYPE_NORMAL
- en: The essential part of the benchmark function is the manipulation with the timer
    and usage of the loop iteration counter `N`.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the timer is manipulated with the methods, `Reset`/`Start`/`StopTimer`.
    By these, the result of the benchmark is influenced. Note that the timer starts
    running with the beginning of the benchmark function and the `ResetTimer` function
    just restarts it.
  prefs: []
  type: TYPE_NORMAL
- en: The `N` field of `B` is the iteration count within the measurement loop. The
    `N` value is set to a value high enough to reliably measure the result of the
    benchmark. The result in the benchmark log then displays the value of iterations
    and measured time per one iteration.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The subsequent recipe shows how the subtests within the tests can be created
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more options and information on benchmarking, take a look into the package
    documentation here: [https://golang.org/pkg/testing](https://golang.org/pkg/testing)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating subtests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In some cases, it is useful to create a set of tests that could have a similar
    setup or clean-up code. This could be done without having a separate function
    for each test.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the console and create the folder `chapter11/recipe04`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the file `sample_test.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Execute the tests by `go test -v`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'See the output in the Terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/2a644849-82e9-4c74-996f-b54f90f154da.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `T` struct of the `testing` package also provides the `Run` method that
    could be used to run the nested tests. The `Run` method requires the name of the
    subtest and the test function that will be executed. This approach could be beneficial
    while using, for example, the table driven tests. The code sample just uses a
    simple slice of `int` values as an input.
  prefs: []
  type: TYPE_NORMAL
- en: The benchmarking struct `B`, also contains the same method, `Run`, which can
    provide a way of creating the subsequent steps of complex benchmarking.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is still much more to find out in the package documentation, [https://golang.org/pkg/testing](https://golang.org/pkg/testing).
  prefs: []
  type: TYPE_NORMAL
- en: Testing the HTTP handler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The testing of the `HTTP` server could be complicated. The Go standard library
    simplifies this with a handy package, `net/http/httptest`. This recipe describes
    how to utilize this package to test the `HTTP` handlers.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the console and create the folder `chapter11/recipe05`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the file `sample_test.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Execute the test by `go test`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'See the output in the Terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/64b6004e-183e-4200-98d7-91730c66c763.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the testing of the `Handler` or `HandlerFunc`, the `net/http/httptest` could
    be leveraged. This package provides the struct `ResponseRecorder` that is able
    to record the content of the response and provide it back for asserting the values.
    For assembling the request, the `NewRequest` function of the `net/http` package
    is used.
  prefs: []
  type: TYPE_NORMAL
- en: The `net/http/httptest` package also contains the version of the HTTP server
    which starts listening on the systems chosen port on the localhost. This implementation
    is intended to be used for end-to-end testing.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing tags via reflection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Go language allows the tagging of structured fields with additional information.
    This information is usually used as additional information for encoders, or any
    kind of additional processing of struct. This recipe will show you how to access
    these.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the console and create the folder `chapter11/recipe06`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the file `structtags.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Execute the code by `go run structtags.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'See the output in the Terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/3a755cf6-bb6e-4580-b8d4-883f0275db9f.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `struct` tags could be extracted with the use of the `reflect` package.
    By calling the `TypeOf`, we get the pointer `Type` for `Person`, subsequently,
    by calling the `Elem` we get the `Type` of the value which the pointer points
    to.
  prefs: []
  type: TYPE_NORMAL
- en: The resulting `Type` gives us access to the `struct` type `Person` and its fields.
    By iterating over the fields and retrieving the fields, by calling the `Field`
    method, we obtain the `StructField`. The `StructField` type contains the `Tag`
    field which provides access to the `struct` tags. The `Get` method on the `StructTag`
    field then returns the specific tag.
  prefs: []
  type: TYPE_NORMAL
- en: Sorting slices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The sorting of data is a very common task. The Go standard library simplifies
    the sorting by the sort package. This recipe gives a brief look at how to use
    it.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the console and create the folder `chapter11/recipe07`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the file `sort.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Execute the code by `go run sort.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'See the output in the Terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/410f5f55-aca0-4785-a7e3-0f9aedde9643.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The sample code shows both ways of how to comfortably sort a slice with the
    help of the `sort` package. The first approach is more ad hoc and it uses the
    `Slice` function of the `sort` package. The `Slice` function consumes the slice
    to be sorted and the so-called less function, which defines whether the element
    `i` should be sorted before element `j`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second approach requires more code and planning ahead. It leverages the
    `Interface` interface of the `sort` package. The interface acts as a representative
    of the data and requires it to implement essential methods on sorted data: `Len` (defines
    the amount of data), `Less` (less function), `Swap` (method called to swap the
    elements). If the data value implements this interface, then the `Sort` function
    of the `sort` package could be used.'
  prefs: []
  type: TYPE_NORMAL
- en: The primitive type slices `float64`, `int`, and `string` are covered in the
    `sort` package. So, the existing implementation could be used. For example, to
    sort a slice of strings, the `Strings` function could be called.
  prefs: []
  type: TYPE_NORMAL
- en: Breaking HTTP handlers into groups
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe gives advice on how the HTTP handlers could be separated into modules.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the console and create the folder `chapter11/recipe08`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the file `handlegroups.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Execute the code by `go run handlegroups.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'See the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/de4c1c5b-e888-4abc-b479-00cbfe6f1e05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Access the browser URL `http://localhost:8080/api/users`, the output should
    look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9a9f2678-99d7-46e6-a522-bfd7c59a1404.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the same way, you can test `http://localhost:8080/ui/users`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/110cb8f2-3bf7-4a57-b911-c8bfb2aa5ec9.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For separating the handlers into modules, the code uses the `ServeMux` for each
    module, (`rest` and `ui`). The handling of URLs for the given module is defined
    relatively. This means if the final URL for the `Handler` should be `/api/users`,
    then the defined path within the module would be `/users`. The module itself would
    be set to `/api/` URL.
  prefs: []
  type: TYPE_NORMAL
- en: The module is plugged into the main `ServeMux` pointer named `mainMux` by leveraging
    the `StripPrefix` function, which removes the module prefix. For instance, the
    REST module created by the `restModule` function, is plugged into the main `ServeMux`
    by `StripPrefix("/api",restModule())`. The handled URL within the module will
    then be `/users`, instead of `/api/users`.
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing HTTP/2 server push
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The HTTP/2 specification provides the server with the ability to push the resources,
    prior to being requested. This recipe shows you how to implement the server push.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Prepare the private key and self-signed X-509 certificate. For this purpose,
    the `openssl` utility could be used. By executing the command `openssl genrsa -out server.key
    2048`, the private key derived with the use of the RSA algorithm is generated
    to file, `server.key`. Based on this private key, the X-509 certificate could
    be generated by calling `openssl req -new -x509 -sha256 -key server.key -out server.crt -days
    365`. The `server.crt` file is created.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the console and create the folder `chapter11/recipe09`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the file `push.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Start the server by `go run push.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the browser and open the developer''s tool in URL `https://localhost:8080`
    (see the `Push` as initiator for `app.css`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a9f38361-8c38-4b77-9ebc-26cc4e533d2e.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, note that the HTTP/2 requires the secured connection. The server push
    is very simple to implement. Since Go 1.8, the HTTP package provides the `Pusher`
    interface, which could be used to `Push` the assets before they are required.
    If the client, usually browser, supports the HTTP/2 protocol and the handshake
    with the server is successful, the `ResponseWriter` in `Handler` or `HandlerFunc`
    could be cast to `Pusher`. The `Pusher` provides only the  `Push` method. The
    `Push` method consumes the target (which could be the absolute path or absolute
    URL) to resource and `PushOptions`, which can provide the additional options (by
    default the nil could be used).
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, look at the output of the developer's tool in the
    browser. The pushed resource has the Initiator column with the value, `Push`.
  prefs: []
  type: TYPE_NORMAL
