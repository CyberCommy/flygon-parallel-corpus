- en: 3\. No Leaks Allowed - Exceptions and Resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Learning Objectives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you will be able to:'
  prefs: []
  type: TYPE_NORMAL
- en: Develop classes to manage resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Develop exception-robust code so that the resources do not leak through RAII
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement classes that can transfer resource ownership through move semantics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement classes that control implicit conversion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, you will learn how to use a class to manage resources, protect
    against leaks, and prevent copying a large amount of data.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *Chapter 2A*, *No Ducks Allowed – Types, and Deduction*, we briefly touched
    on some concepts, such as smart pointers and move semantics. In this chapter,
    we'll be exploring them further. It turns out that these topics are very closely
    related to resource management and writing robust code (code that will run often
    and for long periods without problems).
  prefs: []
  type: TYPE_NORMAL
- en: To understand what happens, we are going to explore where variables get placed
    in memory, as well as when and what happens when they go out of scope.
  prefs: []
  type: TYPE_NORMAL
- en: We will look at what the compiler generates as assembler code for what we enter,
    and we will explore how all of this is affected when an exception occurs.
  prefs: []
  type: TYPE_NORMAL
- en: Variable Scope and Lifetime
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In *Chapter 2B*, *No Ducks Allowed – Templates, and Deduction*, we discussed
    variable scope and lifetimes. Let''s quickly go through their different types:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Scope**:'
  prefs: []
  type: TYPE_NORMAL
- en: '`{}`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Global / file scope**: This applies to variables declared outside a normal
    function or a class, and also to the normal functions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lifetime**:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Automatic lifetime**: Here, the local variables are created when they are
    declared, and destroyed when they exit the scope that they are in. These are managed
    by the stack.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Permanent lifetime**: Here, the global and static local variables have a
    permanent lifetime.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`new` and `delete operators`). These variables have their memory allocated
    from the heap.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We are going to use the following program to get a clarity on the behavior
    of `local variables` – those that have an `automatic lifetime` and those that
    have a `dynamic lifetime`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/C14583_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.1: Test program for variable scope and lifetime'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'When we run the preceding program, the following output is generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2: Output from Lifetime test program](img/C14583_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.2: Output from Lifetime test program'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The hexadecimal numbers (`0xNNNNNNNN`) in the preceding output are the addresses
    of the Int objects that are being constructed or destructed. Our program starts
    by entering at `line 46` with the `main()` function. At this point, the program
    has already done a lot of initialization so that everything is readily available
    for us to use. The figures below that refer to two stacks – **PC Stack** and **Data
    Stack**.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the abstract concepts that help us explain what happens behind the
    scenes. The `PC Stack` (`Program Counter Stack`) is used to remember the values
    of the program counter (a register pointing to the next instruction that needs
    to be run), while the `Data Stack holds` the values or addresses that we are manipulating.
    Although these are two separate stacks, on the real CPU, it will most likely be
    implemented as one stack. Let''s look at the following tables wherein we''ve used
    the abbreviation `OLn` to refer to a line number from the output of the preceding
    program:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3: Detailed analysis of the test program’s execution (part 1)](img/C14583_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.3: Detailed analysis of the test program''s execution (part 1)'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Below is the second part of the detailed analysis of the test program''s execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4:  Detailed analysis of the test program’s execution (part 2)](img/C14583_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.4: Detailed analysis of the test program''s execution (part 2)'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Below is the third part of the detailed analysis of the test program''s execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.5: Detailed analysis of the test program’s execution (part 3)](img/C14583_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.5: Detailed analysis of the test program''s execution (part 3)'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'From this simple program, we learned some important facts:'
  prefs: []
  type: TYPE_NORMAL
- en: Copy constructors are called when we pass by value (as we did in this case).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returning a type causes only one constructor to be called (not two constructors
    – one to create the return object and one for the variable to store the returned
    data) – C++ calls this **copy elision** and it is now mandatory in the standard.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On termination of scope (the closing curly bracket '`}`'), any variable that
    goes out of scope has its destructor called. If that is true, then why was the
    address `0x6000004d0` not shown with a destructor call (`~Int()`)? This leads
    us to the next fact.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The destructor for a `calculate()` method, we leaked some memory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last two facts are important in understanding and solving the problem of
    resource leaks when we forget to free the resources. We will look at resource
    management after we deal with exceptions in C++.
  prefs: []
  type: TYPE_NORMAL
- en: Exceptions in C++
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have seen how C++ manages the local scope variables with automatic and dynamic
    lifetime. It calls the destructors of variables with an automatic lifetime when
    they go out of scope. We've also seen how raw pointers get destroyed when they
    go out of scope. As it does not clean up the dynamic lifetime variables, we lose
    them. This is a part of the story that builds us towards **Resource Acquisition
    Is Initialization** (**RAII**) later. But, first, we need to understand how exceptions
    change the flow of the program.
  prefs: []
  type: TYPE_NORMAL
- en: The Need for Exceptions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In *Chapter 2A*, *No Ducks Allowed – Types and Deduction*, we were introduced
    to enumerations as a way of dealing with magic numbers for the `check_file()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The preceding function uses a technique known as **status** or **error codes**
    to report the outcome of the operation. This is the approach that's used for C-style
    programming, wherein errors related to the **POSIX API** and **Windows API** are
    handled.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`POSIX` stands for `Potable Operating System Interface`. It is an IEEE standard
    for software compatibility between variants of Unix and other operating systems.'
  prefs: []
  type: TYPE_NORMAL
- en: This means that, the caller of the method must check the return value and take
    the appropriate action for each error type. This approach works well when you
    can reason about the types of errors that the code will generate. This is not
    always true. For example, there may be a problem with the data that is fed to
    the program. This leads to an abnormal state in the program that cannot be handled.
    The part of the code that has the logic to deal with the error is removed from
    the section of code that detects the problem.
  prefs: []
  type: TYPE_NORMAL
- en: While it is possible to write code that deals with such a problem, it increases
    the complications of dealing with all error conditions, thereby making the program
    hard to read, hard to reason about what the function is supposed to do, and thus
    very hard to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: 'For error handling, exceptions provide the following benefits over error codes:'
  prefs: []
  type: TYPE_NORMAL
- en: Error codes can be ignored – exceptions force the error to be dealt with (or
    the program terminates).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exceptions can flow up the stack to the best method to respond to the error.
    Error codes would require propagation out of each intermediate method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exceptions separate the handling of errors from the main program flow, leading
    to easy readability and maintainability of the software.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exceptions separate the code that detects the error, from the code that handles
    the error.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provided you follow the best practices and use exceptions for abnormal conditions,
    there is no (time) overhead in using exceptions. This is because a well-implemented
    compiler will deliver the C++ mantra – you do not pay for what you don't use.
    It may cost some memory and your code may be a little larger, but the running
    time should be unaffected.
  prefs: []
  type: TYPE_NORMAL
- en: 'C++ uses exceptions to deal with runtime anomalies. By using exceptions, we
    can detect an error, throw an exception, and the error propagates back to the
    location where it can be handled. Let''s modify the previous program to introduce
    the `divide()` function and change the calculate() function to call it. We''ll
    also add logging to the `main()` function so that we can explore how the exceptions
    behave:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.6: Modified test program for investigating exceptions](img/C14583_03_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.6: Modified test program for investigating exceptions'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'When we compile and run the preceding program, the following output is generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.7: Output from the test program](img/C14583_03_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.7: Output from the test program'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'In the preceding code, you can see that the annotations are added to the right.
    Now, we remove the comment from the `result2` line in the program, recompile the
    program, and rerun it. The new output that''s generated is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.8: Output from the test program – result2](img/C14583_03_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.8: Output from the test program – result2'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: By comparing the outputs, we can see that the first eight lines of each are
    the same. The next two lines of the preceding output are added because the `divide()`
    function is called twice. The last line indicates that an exception was thrown
    and that the program was terminated.
  prefs: []
  type: TYPE_NORMAL
- en: The second call to the `divide()` function attempted to divide by zero – an
    abnormal operation. This leads to an exception. If an integer is divided by zero,
    then it leads to a floating-point exception. This has to do with the way exceptions
    are generated in a `POSIX` system – it uses something called a signal (we won't
    go into the details of signals here). When an integer is divided by zero, the
    `POSIX` system maps it to the signal called `floating-point error` but is now
    the more generic `arithmetic error`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: According to the C++ standard, if a zero appears as the divisor for either the
    '`/`' operator (divide) or the '`%`' operator (modulus), then the behavior is
    undefined. Most systems will choose to throw an exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we have learned one important fact from the preceding explanation: that
    an unhandled exception will terminate the program (internally, it calls `std::terminate()`).
    We will fix the `undefined behavior`, catch the exception, and see the changes
    in the output.To fix the `undefined behavior`, we need to add `#include <stdexcept>`
    at the top of the file and modify the `divide()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'When we re-compile and run the program, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.9: Output when we throw an exception](img/C14583_03_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.9: Output when we throw an exception'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As we can see from the preceding output, not much has changed. It's just that
    we don't get a `floating-point exception` (core dumped) – the program still terminates
    but doesn't dump the core. We then added a `try/catch` block into the `main()`
    function to ensure that the exception was no longer unhandled.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.10: Catching the Exception ](img/C14583_03_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.10: Catching the Exception'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Recompile the program and run it to get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.11: Output from the program that catches the exception](img/C14583_03_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.11: Output from the program that catches the exception'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the preceding output, an exception is thrown on the second line that is annotated
    as "**copy a for call to divide**". Everything that is output after that is a
    result of the exception being handled.
  prefs: []
  type: TYPE_NORMAL
- en: Our code has transferred program control to the `catch()` statement in the `main()`
    function and has executed the destructors for all the variables that had been
    constructed on the stack (from the time the call was made in the `try` clause).
  prefs: []
  type: TYPE_NORMAL
- en: Stack Unwinding
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The process of destroying all local function variables, as guaranteed by the
    C++ language is known as **Stack Unwinding**. As the stack unwinds in the presence
    of an exception, C++ uses its well-defined rules to destroy all the objects in
    the scope.
  prefs: []
  type: TYPE_NORMAL
- en: When an exception occurs, the function call stack starts searching linearly
    from the current function back to the function that called it, to the one that
    called that, and so on, until an exception handler (expressed by a `catch` block)
    that matches the exception is found.
  prefs: []
  type: TYPE_NORMAL
- en: If an exception handler is found, then the stack unwinding occurs, destroying
    all the local variables for all the functions in the stack. The objects are destroyed
    in the reverse order that they were created. If no handler is found to deal with
    the thrown exception, then the program terminates (usually without warning the
    user).
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 1: Implementing exceptions in Fraction and Stack'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we will return to two classes that we worked on in *Chapter
    2A*, *No Ducks Allowed – Types and Deduction* and *Chapter 2B*, *No Ducks Allowed
    – Templates and Deduction* – `Fraction` and `Stack`, both of which can experience
    runtime anomalies. We are going to update their code so that they can raise exceptions
    whenever any problem is detected. Follow these steps to implement this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Eclipse and create a new project named **Lesson3** using the files found
    in the **Lesson3** examples folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As this is a **CMake-based project**, change the current builder to be **CMake
    Build (portable)**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to the **Project** | **Build All** menu to build all the exercises. By default,
    the console at the bottom of the screen will display the **CMake Console [Lesson3]**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure a new **Launch Configuration**, **L3Exercise1** to run with the name
    **Exercise1**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Also, configure a new C/C++ Unit Run Configuration, **L3Ex1Tests**, to run **L3Ex1tests**.
    Set the **Google Tests Runner**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on the **Run** option for the existing **18** tests to run and pass.![Figure
    3.12: Existing tests all pass (Runs: 18)](img/C14583_03_12.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 3.12: Existing tests all pass (Runs: 18)'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Open **Fraction.hpp** in the editor and change the line at the top of the file
    to read like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Click on the `Fraction` with a zero denominator. The test expects that an exception
    has been thrown:![Figure 3.13: New failing test ThrowsDomainErrorForZeroDenominator](img/C14583_03_13.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 3.13: New failing test ThrowsDomainErrorForZeroDenominator'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Click on the failing test name – the `Expected … throws an exception of type
    std::domain_error`" and the next line states "`Actual: it throws nothing`".'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Double-click on the message and it will take you to the following test:![Figure
    3.14: The failing test](img/C14583_03_14.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 3.14: The failing test'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The `ASSERT_THROW()` macro requires two arguments. Since the `Fraction initializer`
    has a comma in it, it is necessary to wrap the whole first argument in an extra
    set of parentheses. The second argument is expected to get a `std::domain_error`
    from this constructor. The internal `try/catch` structure is present to confirm
    that the expected string is captured inside the exception object. If we do not
    want to check this, then we could simply write the test like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the file **Fraction.cpp** in the editor. Insert the following line near
    the top of the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Modify the constructor to throw an exception if it''s been created with a zero
    denominator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Click on the **Run** button to re-run the tests. **19** tests now pass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open **Fraction.hpp** in the editor and change the line near the top of the
    file to read like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Click on the `ThrowsRunTimeErrorForZeroDenominator` fails.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on the failing test name – the `Expected… throws an exception of type
    std::runtime_error`" and the next line states "`Actual: it throws a different
    type`".'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Double-click on the message again to open the failing test:![Figure 3.15: Another
    failing test](img/C14583_03_15.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 3.15: Another failing test'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This test is verifying that the division assignment operator will throw an exception
    for a divide by zero.
  prefs: []
  type: TYPE_NORMAL
- en: Open `operator/=()` function. You'll see that, inside this function, it actually
    uses the constructor for `std::domain_error`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now modify `operator/=()` to detect this problem before the constructor is called
    so that it throws a `std::runtime_error` with the expected message.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Modify **Fraction.cpp** by adding a domain error that will detect the division
    operator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Click on the **Run** button to re-run the tests. All **20** tests pass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open **Stack.hpp** in the editor and change the line near the top of the file
    to read like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Click on the `FractionTest` to collapse the lists of tests and show the `StackTest`:![Figure
    3.16: pop Stack test fails](img/C14583_03_16.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 3.16: pop Stack test fails'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Use the `#include <stdexcept>` to the top of the file and then update the `pop()`
    function so that it looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Click on the **Run** button to re-run the tests. **21** tests now pass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open **Stack.hpp** in the editor and change the line at the top of the file
    to read like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Click on the `TopEmptyStackThrowsUnderFlowException`, fails.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use the `top()` method so that it looks as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Click on the **Run** button to re-run the tests. **22** tests pass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open **Stack.hpp** in the editor and change the line at the top of the file
    to read like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Click on the `TopEmptyConstStackThrowsUnderFlowException`, fails.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use the `top()` method so that it looks as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Click on the **Run** button to re-run the tests. All **23** tests now pass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this exercise, we have added run time checking for pre-conditions that are
    part of the normal operation of using our `Fraction` and `Stack` classes. This
    code will only execute to throw an exception when one of the pre-conditions is
    violated, indicating that there's a problem with the data or how our program was
    executed.
  prefs: []
  type: TYPE_NORMAL
- en: What Happens When an Exception is Thrown?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'At some point, our program executes the following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: By executing this, we are signaling that an erroneous condition has occurred,
    and that we want it handled. The next thing that happens is a **temporary** object,
    known as the **exception object**, is constructed in an unspecified storage and
    copy-initialized from the expression (which may call the move constructor and
    may be subject to copy elision). The type of the exception object is statically
    determined from the expression with the const and volatile qualifiers removed.
    Array types decay to pointers, while function types are converted into a pointer
    of a function. If the type of expression is malformed or abstract, then a compiler
    error will occur.
  prefs: []
  type: TYPE_NORMAL
- en: After the construction of the exception object, the control, along with the
    exception object, is transferred to the exception handler. The exception handler
    that's chosen is the one that has the closest matching type to the exception object
    as the stack unwinds. The exception object exists until the last catch clause
    exits, unless it is rethrown. The type of the expression must have an accessible
    `copy constructor` and a `destructor`.
  prefs: []
  type: TYPE_NORMAL
- en: Throw-by-Value or Throw-by-Pointer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Knowing that a temporary exception object is created, passed around, and then
    destroyed, what type should the throw expression use? A `value` or a `pointer`?
  prefs: []
  type: TYPE_NORMAL
- en: We haven't talked much about specifying the types in the catch statements yet.
    We will do that shortly. But for now, note that to catch a pointer type (which
    was thrown), the catch pattern also needs to be of a pointer type.
  prefs: []
  type: TYPE_NORMAL
- en: If a pointer to an object is thrown, then the throwing party must ensure that
    what the exception object will point at (as it will be a copy of a pointer) will
    be kept alive until the exception has been handled, even through the `stack unwinding`.
  prefs: []
  type: TYPE_NORMAL
- en: The pointer could be to a static variable, a global variable, or memory that's
    been allocated from the heap to ensure that the object being pointed to still
    exists when the exception is handled. Now, we have solved the problem of keeping
    the exception object alive. But when the handler has finished with it, what does
    the catcher do with it?
  prefs: []
  type: TYPE_NORMAL
- en: The catcher of the exception isn't aware about the creation of the exception
    object (`global`, `static`, or `heap`) and so it doesn't know whether it should
    delete the received pointer or not. Thus, throwing-by-pointer is not the recommended
    approach of throwing exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: An object that is thrown will be copied to the created temporary exception object
    and handed off to the handler. When the exception has been handled, the temporary
    object will simply be destroyed, and the program will continue. There is no ambiguity
    as to what to do with it. Therefore, the best practice is to throw the `exception
    by value`.
  prefs: []
  type: TYPE_NORMAL
- en: Standard Library Exceptions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The C++ Standard Library defines `std::exception` as the base class for all
    the Standard Library exceptions. The standard defines the following first-level
    hierarchy of `exceptions`/`errors` (the number in brackets indicates how many
    exceptions derive from that class):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.17: Standard Library exception Hierarchy (two levels)](img/C14583_03_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.17: Standard Library exception hierarchy (two levels)'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: These exceptions are used through the C++ Standard Library including the STL.
    The best practice when creating your own exception class is deriving it from one
    of the standard exceptions. As we will see next, your special exception can be
    caught by a handler for one of the standard exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: Catching Exceptions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'While discussing the need for exceptions, we introduced the idea of throwing
    the exceptions but did not really look at how C++ supports catching the exception.
    The process of exception handling starts with a section of code being wrapped
    in a `try` block to place it under **exception inspection**. The try block is
    followed by one or more catch blocks, which are the exception handlers. When an
    exceptional circumstance occurs while executing the code inside the try block,
    an exception is thrown, and control is transferred to the exception handlers.
    If no exceptions are thrown, then all the exception handlers are skipped, the
    code in the try block completes, and normal execution continues. Let''s express
    these concepts in a code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding snippet shows the necessary keywords – `try`, and `catch` and
    introduces the three different types of catch pattern (excluding the default handler):'
  prefs: []
  type: TYPE_NORMAL
- en: '**Catch exception by value**: This is a costly mechanism as the exception handler
    is processed like any other function. Catch-by-value means that a copy of the
    exception object must be created and then passed to the handler. The creation
    of the second copy slows down the exception handling process. This type can also
    suffer from object slicing where a subclass is thrown, and the catch clause is
    a super class. The catch clause will then only receive a copy of the super-class
    object that loses the attributes of the original exception object. Therefore,
    we should avoid catch-by-value exception handlers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Catch exception by pointer**: As discussed when looking at throw-by-value,
    with throw-by-pointer, this style of exception handler can only catch exceptions
    thrown by the pointer. As we only want to throw by value, we should avoid catch-by-pointer
    exception handlers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`throw-by-value` and `catch-by-reference`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When there are multiple catch blocks, the exception object type is used to match
    the handlers in the order that they are specified. Once a handler is found to
    match, it is executed, and the remaining exception handlers are ignored. This
    is different to function resolution, where the compiler will find the best match
    to the arguments. Thus, the exception handlers (catch blocks) should be defined
    from the more specific to the more general. For example, the default handler (`catch(...)`)
    should always come last in the definition.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 2: Implementing Exception Handlers'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we will implement a hierarchy of exception handlers to manage
    how exceptions are processed. Follow these steps to implement this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `e`. The scope for that variable is only the catch block that it is
    declared in.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Launch Configuration** drop down menu and select **New Launch
    Configuration…**. Configure the **L3Exercise2** application from the **Search
    Project** menu to run it with the name **L3Exercise2**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When that is complete, it will be the currently selected **Launch Configuration**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on the **Run** button. Exercise 2 will run and produce the following
    output:![Figure 3.18: Exercise 2 output – default handler caught the exception](img/C14583_03_18.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 3.18: Exercise 2 output – default handler caught the exception'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the Console window, click on the `CMake` file sets the `-fpermissive` flag
    when it compiles this target.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the editor, move the default exception handler, `catch(...)`, to just after
    the `std::domain_error` handler. Click on the **Run** button. Exercise 2 will
    run and produce the following output:![Figure 3.19: std::exception handler has
    been used](img/C14583_03_19.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 3.19: std::exception handler has been used'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the editor, move the `std::exception` handler to just after the `std::domain_error`
    handler. Click on the `std::logic_error` handler was executed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the editor, move the `std:: logic_error` handler to just after the `std::domain_error`
    handler. Click on the `std:: domain_error` handler was executed which is actually
    what we would expect.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now change the `throw` line to be a `std::logic_error` exception. Click on the
    `std::logic_error` handler was executed as expected.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now change the `throw` line to be a `std::underflow_error` exception. Click
    on the `std::exception` handler as expected. `std::exception` is the base class
    for all Standard Library exceptions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this exercise, we implemented a series of exception handlers and observed
    how the order of exception handlers affects the way an exception is caught and
    how the exception hierarchy can be used.
  prefs: []
  type: TYPE_NORMAL
- en: CMake Generator Expressions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When working with `CMake`, it is sometimes necessary to adjust the value of
    a variable. `CMake` is a build generator system that can generate build files
    for many build tools and compiler tool chains. Because of this flexibility, if
    you want to turn on some feature in the compiler, you only need to apply to it
    to one particular type. This is because the command-line options are different
    between vendors. For example, the command line option for the g++ compiler to
    enable C++17 support is `-std=c++17`, but for `msvc` it is `/std:c++17`. If you
    open the `add_excutable`, then the following line will be after it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This uses the `$<CXX_COMPILER_ID:GNU>` variable query to check whether it is
    a GCC compiler. If yes, then it generates a 1 (true), otherwise 0 (false). It
    also uses the `$<condition:true_string>` condition expression to add `-fpermissive`
    to the compiler options for the `target_compile_options` or via one call.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'For more information on generator expressions, please take a look at the following
    link: [https://cmake.org/cmake/help/v3.15/manual/cmake-generator-expressions.7.html](https://cmake.org/cmake/help/v3.15/manual/cmake-generator-expressions.7.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Exception Usage Guidelines
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When using exceptions in your C++ code, remember the following points:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Chant: **Throw by value and catch by reference**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Do not use exceptions for normal program flow**. If a function meets an abnormal
    condition and is not able meet its (functional) obligations, then and only then
    do you throw an exception. If the function can resolve the abnormal condition
    and fulfil its obligations, then it is not an exception. They are named exceptions
    for a reason and you will not incur any processing overhead if you do not use
    them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Do not throw an exception from within a destructor**. Remember that because
    of stack unwinding, local variable destructors will be executed. If a destructor
    is called during the stack unwinding process and throws an exception, then the
    program will terminate.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Do not swallow exceptions**. Do not use the default catch handler and do
    nothing about the exception. The exception has been thrown to indicate that there
    is a problem and you should do something about it. Ignoring an exception can lead
    to a failure later that will be hard to troubleshoot. This is because any useful
    information is truly lost with the swallowed exception.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The exception object is copied from the throw**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resource Management (in an Exceptional World)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far, we have looked at local variable scope, and how `automatic` and `dynamic
    lifetime variables` are dealt with when the variable goes out of scope – automatic
    lifetime variables (those placed on the stack) are fully destructed while `dynamic
    lifetime variables` (those allocated to the heap by the programmer) are not destructed:
    we just lose any access to them. We have also seen that, when an exception is
    thrown, the nearest matching handler is found and all the local variables between
    the throw point and the handler will be destructed through the stack unwinding
    process.'
  prefs: []
  type: TYPE_NORMAL
- en: We can use this knowledge to write robust resource management classes that will
    relieve us from the need to keep track of resources (dynamic lifetime variables,
    file handles, system handles, and so on) to ensure that they are released (back
    into the wild) when we are done with them. The technique that's utilized to manage
    resources, both under normal operating and under exceptions, is known as **Resource
    Acquisition is Initialization** (**RAII**).
  prefs: []
  type: TYPE_NORMAL
- en: Resource Acquisition Is Initialization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: RAII is another good example of a badly named concept (the other is `SFINAE`).
    `RAII`, or `Resource Acquisition is Initialization` describes the behavior of
    a class that's used to manage resources. It may be better if it were named `File`
    class and show how RAII also improves the readability and our ability to reason
    about what a function does.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This code shows two potential problems with the management of resources:'
  prefs: []
  type: TYPE_NORMAL
- en: Most importantly, the occurrence of an exception between the opening and closing
    of a file results in the resource leaking. If this is a system resource, many
    of these can lead to system instability or application performance being adversely
    affected, since it starves for resources.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition, the management of multiple resources within one method can lead
    to deeply nested clauses because of error handling. This is detrimental to the
    readability of the code and hence its understanding and maintainability. It is
    easy to forget to release a resource, especially when there are multiple exit
    points.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, how can we manage the resource so that we have exception-safe and simpler
    code? This problem is not unique to C++ and different languages manage it differently.
    `Java`, `C#`, and `Python` use a garbage collection approach that sweeps through
    created objects and cleans them up when they are no longer referenced. But C++
    does not have garbage collection, so what is the solution?
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This class implements the following characteristics:'
  prefs: []
  type: TYPE_NORMAL
- en: The constructor acquires the resource.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the resource is not acquired in the constructor, then an exception is thrown.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the class is destroyed, the resource is released.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we use this class in the `do_something()` method, it then looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: If an exception occurs while doing this, then C++ guarantees that all stack-based
    objects will have their destructors called (`stack unwinding`), thus ensuring
    that the files are closed. This solves the problem of resources leaking with the
    occurrence of an exception as the resources are now automatically cleaned up.
    In addition, this method is extremely easy to read so that we can understand the
    logic flow without having to worry about error handling.
  prefs: []
  type: TYPE_NORMAL
- en: This technique uses the lifetime of the `File` objects to acquire and release
    the resource, ensuring that the resources do not leak. The resource is acquired
    during the construction (initialization) of the management class and released
    during the destruction of the management class. It is this behavior of scope-bound
    resources that gives rise to the name `Resource Acquisition Is Initialization`.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding example deals with managing file handles that are system resources.
    It applies to any resources that are required to be acquired before use, and then
    relinquished when finished. The RAII technique can be applied to a wide range
    of resources – open files, open pipes, allocated heap memory, open sockets, threads
    of execution, database connections, locking of mutexes/critical sections – basically
    any resource that is in short supply in the host system and needs to be managed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 3: Implementing RAII for Memory and File Handles'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we will implement two different classes that will manage
    memory or files using the RAII technique. Follow these steps to implement this
    exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the **Lesson3** project in Eclipse. Then in the **Project Explorer**, expand
    **Lesson3**, then **Exercise03**, and double click on **Exercise3.cpp** to open
    the file for this exercise into the editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Launch Configuration** drop down menu and select **New Launch
    Configuration…**. Configure the **L3Exercise3** application from the Search Project
    menu to run it with the name **L3Exercise3**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the `main()` function when the `monitor` is destructed, it dumps a
    report of memory that was allocated and released, as well as the files that were
    opened but never closed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the editor, type the following into the `File` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Click on the **Run** button to run Exercise 3 – it still leaks files and memory,
    but the code is correct.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Locate the `LeakFiles()` function and modify it so that it uses the new `File`
    class (like in the preceding code) to prevent file leaks:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Click on the `LeakFiles()` correctly, then the output will be as follows:![Figure
    3.21: No file leaks](img/C14583_03_21.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 3.21: No file leaks'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Now in `CharPointer` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Modify `LeakPointers()` to read like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Click on the **Run** button to run Exercise 3 – it still has memory leaks, but
    the code is correct.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, add the following destructor to `CharPointer`. Note that the `delete`
    operator uses the array `[]` syntax:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Click on the **Run** button again to run Exercise 3 – this time, you should
    see that the monitor reports no leaks:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.22: No leaks – memory or files](img/C14583_03_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.22: No leaks – memory or files'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The implementation of `File` and `CharPointer` deliver on the `RAII` design
    approach, but there are other considerations when designing these. For example,
    do we want the copy constructor or copy assignment functions? In both cases, it
    could be a problem to just copy the resource from one object to another as this
    could result in two attempts to close a file handle or delete the memory. Typically,
    this would lead to undefined behavior. Next, we will re-visit the special member
    functions in light of implementing a resource management object such as `File`
    or `CharPointer`.
  prefs: []
  type: TYPE_NORMAL
- en: Special Coding Techniques
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The code for *Exercise 3*, *Implementing RAII for Memory and File Handles*,
    has been specially written so that we can monitor the usage of the memory and
    the file handles and report any leaks on exit. Visit the **monitor.h** and **monitor.cpp**
    files and examine the two techniques that were used to make the monitor possible:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SendMessage` if you include `SendMessageA` or `SendMessageW` respectively.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Defining our own new handler**: This is an advanced technique and unless
    you write embedded code, it''s unlikely you will need it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: C++ doesn't Need finally
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Other languages (`C#`, `Java`, and `Visual Basic.NET`) that support an exception
    throwing mechanism have a `try/catch/finally` paradigm where the code in the `finally`
    block is called on exit from the try block – either normally or by exception.
    C++ has no `finally` block because it has access to a better mechanism that ensures
    that we cannot forget to release a resource – RAII. Since the resource is represented
    by a local object, the local object's destructor will free the resource.
  prefs: []
  type: TYPE_NORMAL
- en: The added advantage of this design pattern is that if a lot of resources are
    being managed, then the `finally` block is proportionally large. RAII removes
    the need for finally and leads to code that is easier to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: RAII and the STL
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Standard Template Library (STL) utilizes RAII in many of its templates and
    classes. For example, the smart pointers that were introduced in C++11, that is
    `std::unique_ptr` and `std::shared_ptr`, help avoid many problems by ensuring
    that memory is deallocated when it has been finished with, or by ensuring that
    the memory is not deallocated if it is used elsewhere. Other examples in the STL
    include `std::string` (memory), `std::vector` (memory), and `std::fstream` (file
    handles).
  prefs: []
  type: TYPE_NORMAL
- en: Who Owns This Object?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With the preceding implementations of `File` and `CharPointer`, we have tested
    Resource Management with RAII. Let''s explore it further. Firstly, we will define
    a class that has more than just one resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The class is used for buffering the writing to the file.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This is not usually necessary when using iostream derived classes as they already
    provide buffering.
  prefs: []
  type: TYPE_NORMAL
- en: Each call to the `write()` function will add data into the allocated buffer
    until it reaches the `BufferSize` at which point the data is actually written
    to the file and the buffer is reset.
  prefs: []
  type: TYPE_NORMAL
- en: But what if we wanted to assign this instance of `BufferedWriter` to another
    instance or copy it? What is the right behavior?
  prefs: []
  type: TYPE_NORMAL
- en: If we just let the default copy constructor/copy assignment do its their thing
    we get a member-wise copy of the items. This would mean that we have two instances
    of `BufferedWriter` that hold the same handle to the file and the pointer to the
    buffer. When the first instance of the object is destroyed, being the good programmers
    that we are, we will clean up the file by closing it and the memory by deleting
    it. The second instance now has a file handle that is defunct and a pointer to
    memory that we have told the operating system to recover for the next user. Any
    attempt to use these resources, including destroying them, will result in undefined
    behavior and mostly likely a program crash. The default copy constructor/copy-assignment
    operators execute what is known as a shallow copy – that is, it copies all the
    members as they are, bit by bit (but not what they refer to).
  prefs: []
  type: TYPE_NORMAL
- en: 'The two resources that we have can be treated differently. Firstly, there should
    only be one class that owns the `m_buffer`. There are two options in dealing with
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: Prevent the copy of the class and hence the memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Perform a `deep copy` where the buffer in the second instance has been allocated
    by the constructor and the contents of the first buffer is copied
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Secondly, there should only be one class that owns the file handle (`m_file`).
    There are two options in dealing with this:'
  prefs: []
  type: TYPE_NORMAL
- en: Prevent the copy of the class and hence the file handle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transfer the `ownership` from the original instance to the second instance and
    mark the original as invalid or empty (whatever that means)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is easy enough to implement a deep copy, but how do we transfer ownership
    of a resource? To answer this question, we need to look at temporary objects and
    value categories again.
  prefs: []
  type: TYPE_NORMAL
- en: Temporary Objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A temporary object is created to store the intermediate results of an expression
    before the result is deposited into a variable (or just forgotten). An expression
    is any code that returns a value, including passing by value to a function, returning
    a value from a function, implicit conversion, literals, and binary operators.
    Temporary objects are `rvalue expressions` and they have memory, temporarily allocated
    for them as a location, to place the expression result. It is this creation of
    temporaries and copying data between them that caused some performance issues
    prior to C++11\. To address this issue, C++11 introduced `rvalue references` to
    enable what is known as move semantics.
  prefs: []
  type: TYPE_NORMAL
- en: Move Semantics
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An `rvalue reference` (denoted by a double ampersand, '`&&`') is a reference
    that is only assigned an `rvalue` that will extend the rvalue's lifetime until
    the `rvalue reference` is done with it. So, `rvalues` can live beyond the expression
    that defined it. With `rvalue references`, we can now implement move semantics
    through the move constructor and move assignment operators. The purpose of move
    semantics is to steal resources from the referenced object and thus avoid the
    expensive copy operations. When the move is complete, the referenced object must
    be left in a stable state. In other words, the object that was moved from must
    be left in a state that will not cause any undefined behavior or a program crash
    when it is destroyed, nor should it affect the resources that were stolen from
    it.
  prefs: []
  type: TYPE_NORMAL
- en: C++11 also introduced a casting operator `std::move()`, that casts an `lvalue`
    to an `rvalue` so that the move constructor or move assignment operator gets called
    to 'move' the resources. The `std::move()` method does not actually move the data.
  prefs: []
  type: TYPE_NORMAL
- en: One unexpected thing to note is that, inside the move constructor and move assignment
    operator, the `rvalue` reference is actually an `lvalue`. This means that if you
    want to ensure move semantics happen within the method then you may need to use
    `std::move()` again on the member variables.
  prefs: []
  type: TYPE_NORMAL
- en: As C++11 introduced move semantics, it also updated the Standard Library to
    take advantage of this new capability. For example, `std::string` and `std::vector`
    have been updated to include move semantics. To get the benefits of move semantics;
    you just need to re-compile your code with the latest C++ compiler.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a Smart Pointer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A smart pointer is a resource management class that holds a pointer to a resource
    and releases it when it goes out of scope. In this section, we will implement
    a smart pointer, observe its behavior as a copy supporting class, evolve it to
    support move semantics and finally remove its support for copy operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run this program, the following output generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.23: Smart Pointer Program output](img/C14583_03_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.23: Smart Pointer Program output'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'For such a simple program, there is a lot of acquiring and releasing of the
    resource. Let''s pull this apart:'
  prefs: []
  type: TYPE_NORMAL
- en: The local variable, res, inside `createResource()` is created and initialized
    on the heap (dynamic lifetime), causing the first "`Resource acquired`" message.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is possible for the compiler to create another temporary to return the value.
    However, the compiler has executed `copy elision` to remove the copy (that is,
    it is able to build the object directly onto a position in the stack allocated
    by the calling function). The compiler has `Return-Value-Optimization` (`RVO`)
    and `Named- Return-Value-Optimization` (`NRVO`) optimizations that it can apply
    and, under C++17 these have been made mandatory in certain circumstances.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The temporary object is assigned to the `the_res` variable in the `main()` function
    by copy assignment. Since copy assignment is doing a deep copy, another copy of
    the resource is acquired.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the assignment completes, the temporary object goes out of scope and we
    get the first "Resource released" message.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the `main()` function returns, `the_res` goes out of scope, which releases
    the second Resource.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So, if the resource is large, we have a very inefficient method of creating
    the `the_res` local variable in `main()` as we are creating and copying around
    large chunks of memory because of the deep copy in the copy assignment. However,
    we know that when the temporary variable created by `createResource()` is no longer
    needed, then we are going to throw it away and release its resource. It would
    be more efficient in these scenarios to transfer (or move) the resource from the
    temporary to the other instance of the type. Move semantics makes it possible
    to rewrite our `smart_ptr` template to not do the deep copy but transfer the resource.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add move semantics to our `smart_ptr` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'After re-running our program, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.24: Smart pointer program output using move semantics](img/C14583_03_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.24: Smart pointer program output using move semantics'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Now, because move assignment is now available, the compiler uses it on this
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '`Step 3` is now replaced with move assignment, meaning the deep copy has now
    been removed.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Step 4` no longer frees the resource because the line with the comment "//"
    puts into a safe state – it no longer has a resource to free because its ownership
    was transferred.'
  prefs: []
  type: TYPE_NORMAL
- en: Another point to note with the `move constructor` and `move assignment` is that
    where the arguments were const for their copy versions, they were `non-const`
    for their move versions. This is called the `transfer of ownership`, which means
    that we need to modify the parameter that is passed in.
  prefs: []
  type: TYPE_NORMAL
- en: 'An alternative implementation of the move constructor may look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Essentially, we are swapping the resource, and the C++ STL has support for swap
    as a template with many specializations. This works because we used member initialization
    to set `m_ptr` to `nullptr`. So, we are swapping a `nullptr` with the value stored
    in `a`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have fixed the unnecessary deep copy problem, we can actually remove
    the copy operations from `smart_ptr()` as the transfer of ownership is actually
    what we want. If we were to copy an instance of a non-temporary `smart_ptr` to
    another instance of a non-temporary instance of `smart_ptr`, then we would have
    two objects that would delete the resource when they go out of scope, and this
    is not the desired behavior. To remove the (deep) copy operations we change the
    definition of our member functions, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The postfix of `= delete` which we looked at in *Chapter 2A*, *No Ducks Allowed
    – Types and Deduction*, tells the compiler that an attempt to access a function
    with that prototype is now not valid code and causes an error.
  prefs: []
  type: TYPE_NORMAL
- en: STL Smart Pointers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Instead of having to write our own `smart_ptr`, the STL provides classes that
    we can use to implement RAII on our objects. The original was `std::auto_ptr()`,
    which was deprecated in C++ 11 and removed in C++ 17\. It was created before `rvalue`
    reference support and caused problems because it implemented move semantics using
    copy. C++ 11 introduced three new templates to manage lifetime and ownership of
    resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '`single object` via a pointer and destroys that object when `unique_ptr` goes
    out of scope. It has two versions: for single objects (created using `new`) and
    for array of objects (created using `new[]`). `unique_ptr` is as efficient as
    using the underlying pointer directly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**std::shared_ptr**: Retains shared ownership of an object through a pointer.
    It manages the resource through the use of a reference counter. Every copy of
    shared_ptr that''s assigned to shared_ptr updates the reference count. When the
    reference count goes to zero, this means that there are no owners left and the
    resource is released/destroyed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`shared_ptr`, but does not modify the counter. It can be checked to see if
    the resource still exists, but it will not prevent the resource from being destroyed.
    If you determine that the resource still exists, then it can be used to obtain
    a `shared_ptr` to the resource. One use case for it is a scenario where multiple
    `shared_ptrs` end in cyclic references. A cyclic reference would prevent the auto
    releasing of resources. `weak_ptr` is used to break the loop and allow the resources
    to be freed when they should be.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: std::unique_ptr
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`std::unique_ptr()` was introduced in C++ 11 to replace `std::auto_ptr()` and
    gives us everything that `smart_ptr` does (and more). We can re-write our `smart_ptr`
    program as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We can go one step further than this, because C++ 14 introduced a helper method
    to ensure exception safety when dealing with `unique_ptrs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '*Why is this necessary?* Consider the following function call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The problem with this is that the compiler is free to order the sequence of
    operations in the argument list in any order it likes. It could call `new T`,
    then `new U`, then `std::unique_ptr<T>()`, and finally `std::unique_ptr<U>()`.
    The problem with this sequence is that if `new U` were to throw an exception,
    then the resource allocated by the call to `new T` has not been placed in a `unique_ptr`
    and will not be cleaned up automatically. The use of `std::make_unique<>()` guarantees
    the order of calls so that the construction of the resource and the construction
    of `unique_ptr` will occur together and not leak resources. The need for `make_unique`
    has been removed in C++17 where the rules around the order of evaluation in these
    circumstances have been tightened. However, it is still probably a good idea to
    use the `make_unique<T>()` approach as any future conversion to a shared_ptr will
    be easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'The name `unique_ptr` makes the intent of the template clear, that is, it is
    the only owner of the object that it points to. This was not obvious from `auto_ptr`.
    Likewise, `shared_ptr` is clear in that it intends to share the resource. The
    `unique_ptr` template provides access to the following operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '**T* get()**: Returns the pointer to the hosted resource.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`true` if the instance manages a resource. (`get() != nullptr`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lvalue` reference to the hosted resource. Same as `*get()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`get()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unique_ptr(new [])`, it provides access to the hosted array as if it were
    natively an array. Returns an `lvalue` reference so that the value can be set
    and get.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: std::shared_ptr
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A shared pointer is used when you want to share the ownership of a resource.
    Why would you do this? Several scenarios would lend themselves well to the sharing
    of resources, such as in the case of a GUI program, where you would probably want
    to share the font objects, bitmap objects, and so on. The **GoF flyweight design
    pattern** would be another example.
  prefs: []
  type: TYPE_NORMAL
- en: '`std::shared_ptr` provides all of the same facilities as `std::unique_ptr`,
    but with more overhead because it now has to track a reference count for the object.
    All of the operators described for `std::unique_ptr` are available for use on
    `std::shared_ptr`. One difference is that the recommended method to create a `std::shared_ptr`
    is to call `std::make_shared<>()`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When writing libraries or factories, the author of the library will not always
    know how a user will want to use the objects that have been created, so the recommendation
    is to return `unique_ptr<T>` from your factory methods. The reason for this is
    that the user can easily convert a `std::unique_ptr` into a `std::shared_ptr`
    by assignment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This will transfer ownership and leave `unique_obj` empty.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Once a resource has been made a shared resource, it cannot be reverted into
    a unique object.
  prefs: []
  type: TYPE_NORMAL
- en: std::weak_ptr
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A weak pointer is a variant of a shared pointer, but it doesn''t hold a reference
    count to the resource. So, it does not prevent it from being released when the
    count goes to zero. Consider the following program structure, which may occur
    within a normal graphical user interface (GUI):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'When executed, it outputs the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.25: Weak pointer program output](img/C14583_03_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.25: Weak pointer program output'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'This shows that the panel and the `textwindow` were not destroyed when the
    app exited. This is because they both held a `shared_ptr` to each other and so
    the reference count for both would not go to zero and trigger the destruction.
    If we depict the structure diagrammatically, then we can see that it has a `shared_ptr`
    cycle:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.26: weak_ptr and shared_ptr cycles](img/C14583_03_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.26: weak_ptr and shared_ptr cycles'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Smart Pointers and Calling Functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that we can manage our resources, how do we use them? Do we pass around
    the smart pointers? When we have a smart pointer (`unique_ptr` or `shared_ptr`),
    we have four options when calling a function:'
  prefs: []
  type: TYPE_NORMAL
- en: Pass the smart pointer by value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pass the smart pointer by reference
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pass the managed resource by pointer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pass the managed resource by reference
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is not an exhaustive list but are the main ones to consider. The answer
    to how we pass the smart pointer, or its resource, depends on our intent with
    the call to the function:'
  prefs: []
  type: TYPE_NORMAL
- en: Is the intend of the function to just use the resource?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does the function take ownership of the resource?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does the function replace the managed object?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If the function is just going to `use the resource`, then it does not even
    need to know that it is being handed a managed resource. It simply needs to use
    it and should be called using the resource by pointer, or resource by reference
    (or even resource by value):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to `pass the ownership` of the resource to the function, then the
    function should be called by smart pointer by value and called using `std::move()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: When `do_something()` returns, the `res` variable will be empty, and the resource
    is now owned by `do_something()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to `replace the managed object` (a process known as **reseating**),
    then you pass the smart pointer by reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The following program puts all of this together to demonstrate each scenario
    and how to call the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run this program, we receive the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/C14583_03_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.27: Ownership passing Program output'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The *C++ Core Guidelines* has a whole section on *resource management*, smart
    pointers, and how to use them here: [http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#S-resource](http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#S-resource).
    We have only touched on the most important that are aspects covered by the guidelines.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 4: Implementing RAII with STL Smart Pointers'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we will implement a sensor factory method that returns the
    sensor resource via a `unique_ptr`. We will implement a `unique_ptr` to hold an
    array, and then develop code that converts a `unique_ptr` into a shared pointer
    and then shares it some more. Follow these steps to implement this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the **Lesson3** project in Eclipse. Then in the **Project Explorer**, expand
    **Lesson3**, then **Exercise04**, and double-click on **Exercise4.cpp** to open
    the file for this exercise into the editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Launch Configuration** drop-down menu and select **New Launch
    Configuration…**. Configure the **L3Exercise4** application from the **Search
    Project** menu so that it runs with the name **L3Exercise4**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on the **Run** button to run Exercise 4\. This will produce the following
    output:![Figure 3.28: Exercise 4 output](img/C14583_03_28.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 3.28: Exercise 4 output'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the editor, examine the code, particularly the factory method, that is, `createSensor(type)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This creates an empty unique pointer named sensor, and then resets the contained
    pointer with the desired sensor according to the passed in `type`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open Exercise4.cpp in the editor and change the line near the top of the file
    to read like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Click on the `unique_ptr` to a `shared_ptr` and that is not allowed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Locate the line reporting the error and change it to read like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Click on the `light` (a `unique_ptr`) to `light2` (a `shared_ptr`). The problem
    is actually the template method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The first argument is passed by value, which means that a new copy of the `shared_ptr`
    will be created and passed to the method for printing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s fix that now by changing the template to pass-by-reference. Click on
    the **Run** button to compile and run the program. The following output is generated:![Figure
    3.31: Corrected printSharedPointer output](img/C14583_03_31.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 3.31: Corrected printSharedPointer output'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Open **Exercise4.cpp** in the editor and change the line near the top of the
    file to read like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Click on the **Run** button to compile and run the program. The following output
    is generated:![](img/C14583_03_32.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 3.32: Annotated Step 12 output for Exercise 4'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Compare the output with the code in the `testSensors()` method. We'll find that
    we can easily assign to an empty `unique_ptr` (`light`) and that we can assign
    from one `shared_ptr` to another (`light3 = light2`) without the need for `std::move()`
    in either case.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open **Exercise4.cpp** in the editor and change the line near the top of the
    file to read like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Click on the **Run** button to compile and run the program. The output switches
    to the following:![Figure 3.33: Managing arrays in unique_ptr](img/C14583_03_33.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 3.33: Managing arrays in unique_ptr'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Open the editor and find the `testArrays()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: There are several things to note in this snippet of code. Firstly, the type
    is declared as `int[]`. We have chosen `int` for this exercise, but it could be
    just about any type. Secondly, when `unique_ptr` (and `shared_ptr` since C++ 17)
    is used to manage an array, `operator[]` is defined. So, we simulate a two-dimensional
    array by calculating a one-dimensional index from the two-dimensional indices'
    `board[i*8+j]`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the first line of the method and declare the `auto` type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Click on the `make_unique()` call.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this exercise, we implemented a factory function that served up manufactured
    sensors using `unique_ptr` to manage the lifetime of the sensor. We then implemented
    code to change it from a `unique_ptr` and share it to several objects. Finally,
    we developed a `unique_ptr` technique to manage a multi-dimensional array using
    a single-dimensional array.
  prefs: []
  type: TYPE_NORMAL
- en: Rule of Zero/Five – A Different Perspective
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When we introduced `BufferedWriter`, it had two resources being managed: memory
    and a file. We then discussed how the default compiler generated copy operations
    that are what are known as shallow copies. We talked about how we could manage
    the resources differently – stop the copy, perform a deep copy, or transfer ownership.
    What we decide to do in these circumstances is known as resource management policy.
    The policy that you choose, impacts how you execute the `Rule of Zero/Five`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In terms of resource management, a class can manage no resources, manage a
    resource that can be copied but not moved, manage a resource that can be moved
    but not copied, or manage a resource that should be neither copied nor moved.
    The following classes show how these may be expressed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Because of the complexity of managing resources in all contexts and under exceptions,
    the best practice is that if a class is responsible for managing a resource, then
    that class is only responsible for managing that resource.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 1: Implementing Graphics Processing with RAII and Move'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In *Chapter 2A*, *No Ducks Allowed – Types and Deduction*, your team worked
    hard and got the implementation of `Point3d` and `Matrix3d`. Now, your company
    wants to market the library and it needs two major improvements before they can
    do that:'
  prefs: []
  type: TYPE_NORMAL
- en: The classes must be in a namespace for our company, that is, Advanced C Plus
    Plus Inc. So, the namespace for the graphics will be `accp::gfx`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The storage for the matrices in `Point3d` and `Matrix3d` is an intrinsic part
    of the class and so it is allocated from the stack and not the heap. As an evolution
    in the library matrix support, we need to allocate the memory from the heap. As
    we are working toward implementing larger matrices in a future release, we also
    want to introduce move semantics into our classes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Follow these steps to achieve this:'
  prefs: []
  type: TYPE_NORMAL
- en: Starting with our current version of the library (this can be found in the `acpp::gfx`
    namespace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fix all the failing tests because of the change. (Fail could mean a failure
    to compile, not just running the test.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `Matrix3d`, switch from declaring the matrix directly in the class to heap
    allocated memory for storage.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fix the failing tests by implementing a deep copy implementation of the copy
    constructor and copy assignment operators. Make any other changes necessary to
    adjust to the new internal representations. Note that you should not need to modify
    any tests to get them to pass they only access the public interface which means
    we can change the internal structure without affecting the client.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Trigger another failure by forcing a move constructor to be called in `CreateTranslationMatrix()`
    by using `std::move` in the return statement. Introduce the required move operations
    in the `Matrix3d` class to get the tests to compile and pass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat steps 3 to 4 for `Point3d`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After implementing the preceding steps, the expected output would look unchanged
    from the start:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.34: Activity 1 output after successful conversion to use RAII](img/C14583_03_34.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.34: Activity 1 output after successful conversion to use RAII'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The solution to this activity can be found on page: 657.'
  prefs: []
  type: TYPE_NORMAL
- en: When is a Function Called?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All the operations that are performed by a C++ program are essentially function
    calls (although the compiler may optimize these into inline sequences of operations).
    However, it may not be obvious that you are making a function call due to `a =
    2 + 5`, you are essentially calling `operator=(&a, operator+(2, 5))`. It is just
    that the language allows us to write the first form, but the second form allows
    us to overload operators and extend these capabilities to user-defined types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following mechanisms result in calls to a function:'
  prefs: []
  type: TYPE_NORMAL
- en: Explicit call to a function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All operators such as +, -, *, /, %, and so on along with new/delete.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Declaration of variables – will result in a call to the constructors with arguments
    if the initialization values are present.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User-defined literals – We have not dealt with these, but essentially, we define
    an overload for the `type operator "" name(argument)`. We can then write things
    such as 10_km, which make our code easier to understand as it carries semantic
    information.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Casting from one value to another (`static_cast<>`, `const_cast<>`, `reinterpret_cast<>`,
    and `dynamic_cast<>`). Again, we have another operator overload which allows us
    to convert from one type into another.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: During function overload, it may be necessary to convert one type into another
    so that it matches the function prototype. It can do this by either calling a
    constructor with the right argument type to create a temporary or through a cast
    operator that's called implicitly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each and every one of these results in the compiler determine that a function
    must be called. Having determined that a function needs to be called, it must
    find the function that matches the name and arguments. This is what we'll be discussing
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Which Function to Call
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In *Chapter 2A*, *No Ducks Allowed – Types and Deduction*, we saw that function
    overload resolution was performed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.35: Function overload resolution](img/C14583_03_35.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.35: Function overload resolution'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'What we really did not dig into was the concept of name lookup. At some point
    the compiler will encounter the following call to the `func` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: When this happens, it must associate its name with the declaration that introduced
    it. This process is called **name lookup**. This name lookup is true for all the
    items in the program (variables, namespaces, classes, functions, function templates,
    and templates). For the program to compile, the name lookup process for variables,
    namespaces and classes must produce a single declaration. However, for functions
    and function templates the compiler may associate multiple declarations with the
    same name – mainly through function overloads which may be extended to consider
    additional functions due to **Argument-dependent Lookup** (**ADL**).
  prefs: []
  type: TYPE_NORMAL
- en: Identifiers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As defined in the C++ standard, an **identifier** is a sequence of uppercase
    and lowercase Latin letters, digits, underscores, and most Unicode characters.
    A valid identifier must begin with a non-digit character and is arbitrarily long
    and case-sensitive. Every character is significant.
  prefs: []
  type: TYPE_NORMAL
- en: Names
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A **name** is used to refer to an entity or to a label. A name is of one of
    the following forms:'
  prefs: []
  type: TYPE_NORMAL
- en: An identifier
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An overloaded operator name in function notation (e.g. operator-, operator delete)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A template name followed by its argument list (vector<int>)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A user-defined conversion function name (operator float)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A user-defined literal operator name (operator ""_ms)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every entity and its name is introduced by a declaration while a name for a
    label is introduced by either a **goto** statement or by a labeled statement.
    A name can be used multiple times in one file (or translation unit) to refer to
    different entities depending on the scope. A name may also be used to refer to
    the same entity across multiple files (translation units), or different entities,
    depending upon the linkage. The compiler uses name lookup to associate a declaration
    that introduces a name with an unknown name in the program through **name lookup**.
  prefs: []
  type: TYPE_NORMAL
- en: Name lookup
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The name lookup process is one of two and is – selected based on the context:'
  prefs: []
  type: TYPE_NORMAL
- en: '`::`, or possibly after `::`, followed by the `template` keyword. A qualified
    name may refer to a namespace member, class member or enumerator. The name to
    the left of the `::` operator defines the scope to lookup the name from. If there
    is no name, then the global namespace is used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Unqualified name lookup**: Everything else. In this case, name lookup examines
    the current scope and all enclosing scopes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the unqualified name is left of the function-call operator, '`()`' then it
    uses Argument-Dependent Lookup.
  prefs: []
  type: TYPE_NORMAL
- en: Argument-Dependent Lookup
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The set of rules for looking up unqualified function names is called `Argument-dependent
    lookup` (known as ADL), or `Koenig lookup` (named after Andrew Koenig, who defined
    it and is a longtime member of the C++ standards committee). Unqualified function
    names can appear as either a function-call expression or as part of an implicit
    function call to an overloaded operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'ADL basically says that in addition to the scopes and namespaces considered
    during unqualified name lookup, the "associated namespaces" of all the arguments
    and template parameters are also considered. Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'When we compile this code and run it, the output is as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'This is an unusual way to write the program. Typically, it would be written
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: We are using the strange method of calling `endl()` to show ADL. But there are
    two ADL lookups occurring here.
  prefs: []
  type: TYPE_NORMAL
- en: The first function call that undergoes ADL is `std::cout << welcome`, which
    the compiler considers to be `operator<<(std::cout, welcome)`. The name operator,
    <<, is now looked up in the available scopes and the namespace of its arguments
    – `std`. This additional namespace resolves the name to the free method, that
    is, `std::operator<<(ostream& os, string& s)`, that's declared in the string header.
  prefs: []
  type: TYPE_NORMAL
- en: The second call is more obvious `endl(std::cout)`. Again, the compiler can access
    the std namespace to resolve this name lookup and finds the `std::endl` template
    in the header `ostream` (included in `iostream`).
  prefs: []
  type: TYPE_NORMAL
- en: Without ADL, the compiler has no way to find either of these functions, because
    they are free functions that are made known to us by the iostream and string packages.
    The magic of the insertion operator (<<) would be lost and it would be tedious
    for the programmer, if we were forced to write `std::operator<<(std::cout, welcome)`.
    It would be even worse if you consider chained insertions. Alternatively, you
    could write "`using namespace std;`". Neither of those options is ideal, and that
    is why we need ADL (Koenig lookup).
  prefs: []
  type: TYPE_NORMAL
- en: Caveat Emptor
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We have seen how ADL makes life easier for the programmer by including namespaces
    related to the function argument types. However, this lookup capability does not
    come without risk which, for the most part we can minimize. Consider the following
    sample code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'When we compile and run the preceding program, we get the expected output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.36: ADL Sample program output](img/C14583_03_36.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.36: ADL Sample program output'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The C++ standards committee then decides that it should introduce an `is_substring()`
    function that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'If we add this to the top of our file, compile it and re-run it, we now get
    the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.37: ADL issue program output](img/C14583_03_37.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.37: ADL issue program output'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Thanks to ADL, the (next C++ standard) compiler has picked up a different implementation
    as a better fit for the unqualified function call of `is_substring()`. And because
    of implicit conversion of arguments it does not clash which would cause an ambiguity
    and a compiler error. It just silently adopts to the new method which could lead
    to subtle and hard to find bugs if the argument order is different. The compiler
    can only detect type and syntactic differences, not semantic ones.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For the purposes of demonstrating how ADL works, we have added our function
    to the std namespace. Namespaces serve a purpose of separating concerns, and to
    add into someone else's namespace, in particular, the `Standard Library namespace`
    (`std`) is not good practice.
  prefs: []
  type: TYPE_NORMAL
- en: So, why caveat emptor (buyer beware)? If you use third-party libraries for your
    development (and that includes the C++ Standard Library), then when you upgrade
    the library, you need to ensure that changes to the interface are not going to
    cause you problems because of ADL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 5: Implementing Templates to Prevent ADL Issues'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we will demonstrate a breaking change in C++17 STL that can
    potentially cause an issue in the wild. C++11 introduced templates for `std::begin(type)`
    and friends. As a developer, this is an appealing expression of the general interface
    and you may have written you own versions for size(type) and empty(type) already.
    Follow these steps to implement this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the **Lesson3** project in Eclipse. Then in the **Project Explorer**, expand
    **Lesson3**, then **Exercise05**, and double-click on **Exercise5.cpp** to open
    the file for this exercise into the editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Launch Configuration** drop down menu and select **New Launch
    Configuration…**. Configure the **L3Exercise5** application from the Search Project
    menu so that it runs with the name **L3Exercise5**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on the **Run** button to run Exercise 5\. This will produce the following
    output:![Figure 3:38: Successful execution of Exercise 5](img/C14583_03_38.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 3:38: Successful execution of Exercise 5'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'An examination of the code reveals two helper templates:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Unlike all the other exercises, this exercise has been configured to build
    under C++ 14\. Open the **CMakeLists.txt** file under **Lesson3** and locate the
    following line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Change `14` to a `17`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on the **Run** button to compile the exercise which now fails:![Figure
    3.39: Compilation fails under C++ 17 – ambiguous function call](img/C14583_03_39.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 3.39: Compilation fails under C++ 17 – ambiguous function call'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Because the argument to the `empty()` and `size()` templates was a std::vector,
    the ADL pulled in the newly included STL versions of these templates and broke
    our code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `empty()` and two occurrences of `size()` that are generating the errors
    and insert two colons, "`::`", before them (scope specifier).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the `empty()` and `size()` function are now qualified. We could have
    equally specified `std::` scope instead.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this exercise, we implemented two template functions in the global namespace
    that worked fine if we compiled the program under the C++ 14 standard. However,
    our implementation broke when we compiled under C++17 because the STL library
    changed and we had to change our implementation to ensure that the compiler located
    and used the templates that we wrote.
  prefs: []
  type: TYPE_NORMAL
- en: Implicit Conversion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In determining the Candidate Set of Function in *Figure 3.36*, *Function overload
    resolution*, the compiler has to look at all of the available functions that have
    been found during the name lookup and determine whether the argument number and
    types match the call point. In determining whether the type matches, it will also
    examine all the available conversions to determine whether there is a mechanism
    to convert from the type T1 type (the type of the argument passed) to the T2 type
    (the type specified for the function parameter). If it can convert from T1 to
    T2 for all arguments, then it will add the function to the set of candidates.
  prefs: []
  type: TYPE_NORMAL
- en: 'This transformation from type T1 to type T2 is known as **implicit conversion**
    and occurs when some type, T1, is used in an expression or context that does not
    accept that type but accepts some other type, T2\. This occurs in the following
    contexts:'
  prefs: []
  type: TYPE_NORMAL
- en: T1 is passed as an argument when calling a function declared with T2 as the
    parameter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: T1 is used as an operand to an operator that expects T2.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: T1 is used to initialize a new object of T2 (including return statements).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: T1 is used in a `switch` statement (in which case, T2 is an int).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: T1 is used in an `if` statement or `do-while` or `while` loop (where T2 is bool).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If an unambiguous conversion sequence from T1 to 2 exists, then the program
    will compile. The conversions between built-in types are usually determined by
    the usual arithmetic conversions.
  prefs: []
  type: TYPE_NORMAL
- en: Explicit – Preventing Implicit Conversion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Implicit conversion is a great feature that, make it possible for a programmer
    to express their intent, and it just works most of the time. However, the compiler''s
    ability to convert one type into another without the programmer providing a hint,
    is not always desirable. Consider the following small program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'When we compile it and run the preceding program, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.40: Implicit conversion sample program output](img/C14583_03_40.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.40: Implicit conversion sample program output'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Well, it may be a little unexpected that this compiled and actually produced
    an output. The `real` variable is of the `Real` type which has a conversion operator
    to float – `operator float()`. The `test()` function takes a `bool` as an argument
    and the `if` condition must result in a `bool` as well. The compiler will convert
    any numeric type into a `boolean` type with a value of false if the value is zero
    or true if the value is not zero. But if this is not the behavior that we want
    we can prevent it by prefixing the declaration of the function with the explicit
    keyword. Let''s say we change the line so that it reads like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'If we now attempt to compile it, we get two errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.41: Compile errors because implicit conversion was removed.](img/C14583_03_41.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.41: Compile errors because implicit conversion was removed.'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Both are related to not being able to convert the Real type into a bool – first,
    at the call site to `test()` and then in the if condition.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's introduce a bool conversion operator to fix this problem.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now build the program again. We will receive the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.42: Introducing the bool operator replaces implicit conversion](img/C14583_03_42.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.42: Introducing the bool operator replaces implicit conversion'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The `boolean` value is now false, whereas it was true before. This is because
    the implicit conversion of the value that was returned by the float conversion
    was not zero and was then converted into true.
  prefs: []
  type: TYPE_NORMAL
- en: Since C++ 11, all constructors (except copy and move constructors) have been
    considered to be conversion constructors. This means that if they are not declared
    with explicit, then they are available for implicit conversion. Likewise, any
    casting operator that is not declared explicit is available for implicit conversion.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `C++ Core Guidelines` has two rules related to implicit conversion:'
  prefs: []
  type: TYPE_NORMAL
- en: '**C.46**: By default, declare single-argument constructors as explicit'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**C.164**: Avoid implicit conversion operators'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Contextual Conversion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If we now make one further change to our little program, we can get into what
    is known as contextual conversion. Let''s make the bool operator explicit and
    attempt to compile the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'We will receive the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.43: Compile errors with explicit bool operator](img/C14583_03_43.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.43: Compile errors with explicit bool operator'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This time we only have one error at the call site to `test()`, but not for the
    if condition. We can fix this error by using a C-style case (bool) or a C++ `static_cast<bool>(real)`
    (this is the preferred method). When we add the cast, the program compiles and
    runs once more.
  prefs: []
  type: TYPE_NORMAL
- en: So, if the bool cast is explicit, then why does the condition for the if expression
    not need a cast?
  prefs: []
  type: TYPE_NORMAL
- en: 'The C++ standard allows in certain contexts where the `bool` type is expected
    and the declaration for a bool conversion exists (whether marked explicit or not).
    If this happens, then an implicit conversion is allowed. This is known as **contextually
    converting into bool** and can occur in the following contexts:'
  prefs: []
  type: TYPE_NORMAL
- en: The condition (or controlling expression) of `if`, `while`, `for`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The operands of the built-in logical operators: `!`(not), `&&` (and) and `||`
    (or)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first operand of the ternary (or conditional) operator `?:`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Exercise 6: Implicit and Explicit Conversions'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise we will experiment with calling functions, implicit conversions,
    preventing them, and enabling them. Follow these steps to implement this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the **Lesson3** project in Eclipse. Then in the **Project Explorer**, expand
    **Lesson3** then **Exercise06** and double click on **Exercise6.cpp** to open
    the file for this exercise into the editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Launch Configuration** drop down menu and select **New Launch
    Configuration…**. Configure the **L3Exercise6** application from the **Search
    Project** menu so that it runs with the name **L3Exercise6**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on the **Run** button to run Exercise 6\. This will produce the following
    output:![Figure 3.44: Default output from Exercise 6](img/C14583_03_44.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 3.44: Default output from Exercise 6'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'In the text editor, change the constructor of `Voltage` to be `explicit`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Click on the **Run** button to recompile the code – now we get the following
    error:![Figure 3.45: Failed conversion of int to Voltage](img/C14583_03_45.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 3.45: Failed conversion of int to Voltage'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Remove the explicit from the constructor and change the `calculate` function
    to take a reference:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Click on the **Run** button to recompile the code – now, we get the following
    error:![](img/C14583_03_46.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 3.46: Failed conversion of int to Voltage&'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The same line has the problem that we ran previously, but for a different reason.
    So, *implicit conversion only works with value types*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Comment out the line generating the error, and then, after the call to `use_float(42)`,
    add the following line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Click on the **Run** button to recompile the code – now we get the following
    error:![Figure 3.47: Failed conversion of Voltage to float](img/C14583_03_47.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 3.47: Failed conversion of Voltage to float'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Now, add the following casting operator to the `Voltage` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Click on the **Run** button to recompile the code and run it:![Figure 3.48:
    Successfully converted Voltage to float](img/C14583_03_48.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 3.48: Successfully converted Voltage to float'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Now, place the `explicit` keyword in front of the cast that we just added and
    click on the **Run** button to recompile the code. Again, we get an error:![Figure
    3.49: Failure to convert Voltage to float](img/C14583_03_49.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 3.49: Failure to convert Voltage to float'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'By adding the explicit declaration to the cast, we are preventing the compiler
    from using the conversion operator. Change the line with the error to cast the
    volts variable to a float:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Click on the **Run** button to recompile the code and run it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.50: Conversion of Voltage into float with cast works again](img/C14583_03_50.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.50: Conversion of Voltage into float with cast works again'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In this exercise, we have seen that implicit conversions can occur between types
    (not references), and that we can control when they happen. Now we know how to
    control these conversions, we can strive to meet the guidelines previously quoted
    `C.46` and `C.164`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 2: Implementing classes for Date Calculations'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Your team is in charge of developing a library to help with calculations that
    are related to dates. In particular, we want to be able to determine the number
    of days between two dates and given a date, add (or subtract from it) a number
    of days to get a new date. This activity will develop two new types and enhance
    them to ensure that the programmer cannot accidentally have them interact with
    built-in types. Follow these steps to achieve this:'
  prefs: []
  type: TYPE_NORMAL
- en: Design and implement a `Date` class that stores the `day`, `month`, and `year`
    as integers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add methods to access the internal day, month, and year values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define a type, `date_t` to represent the number of days since the `epoch date`
    of 1-Jan-1970.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a method to the `Date` class to convert this into `date_t`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a method to set the `Date` class from a `date_t` value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `Days` class that stores the days value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `addition` operator to `Date` that takes `Days` as an argument.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use `explicit` to prevent the addition of numbers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `subtraction` operator to return a `Days` value from the `difference`
    of two `Dates`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After following these steps, you should receive the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.51: Output of a successful Date sample application](img/C14583_03_51.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.51: Output of a successful Date sample application'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 664.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we explored the lifetime of variables - both automatic and
    dynamic, where they are stored, and when they are destructed. We then used this
    information to develop `RAII` techniques that allow us to almost ignore resource
    management because the automatic variables will clean them up when they are destructed
    even in the presence of an exception. Then, we looked at throwing exceptions and
    catching them so that we can deal with abnormal conditions at the right level.
    From `RAII`, we went into a discussion on the ownership of resources and how `STL`
    smart pointers help us in this area. We discovered that just about everything
    is treated as a function call, thus allowing operator overloading and implicit
    conversions. We discovered the wonderful (or is it awful?) world of `argument-dependent
    lookup` (`ADL`) and how it can potentially trip us up in the future. We now have
    a good understanding of the fundamental features of C++. In the next chapter we
    will start to explore function objects and how they are realized and implemented
    using lambda functions. We will delve further into the offerings of STL and explore
    PIMPLs as we re-visit encapsulation.
  prefs: []
  type: TYPE_NORMAL
