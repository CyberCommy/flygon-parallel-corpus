- en: Securing Microservices on Kubernetes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will examine how to secure your microservices on Kubernetes
    in depth. This is a broad topic and we will focus on the aspects that are most
    relevant to developers who are building and deploying microservices in a Kubernetes
    cluster. You must be very rigorous with security because your adversaries will
    actively try to find cracks, infiltrate your system, access sensitive information,
    run botnets, steal your data, corrupt your data, destroy your data, and make your
    system unavailable. Security should be designed into the system and not sprinkled
    on top as an afterthought. We will address this by covering general security principles
    and best practices before delving into the security mechanisms that Kubernetes
    puts at your disposal.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Applying sound security principles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Differentiating between user accounts and service accounts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing secrets with Kubernetes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing permissions with RBAC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling access with authentication, authorization, and admission
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hardening Kubernetes by using security best practices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will look at a lot of Kubernetes manifests, and make Delinkcious
    more secure. There is no need to install anything new.
  prefs: []
  type: TYPE_NORMAL
- en: The code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code is split between two Git repositories:'
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code samples here: [https://github.com/PacktPublishing/Hands-On-Microservices-with-Kubernetes/tree/master/Chapter06](https://github.com/PacktPublishing/Hands-On-Microservices-with-Kubernetes/tree/master/Chapter06)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find the updated Delinkcious application here: [https://github.com/the-gigi/delinkcious/releases/tag/v0.4](https://github.com/the-gigi/delinkcious/releases/tag/v0.4)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying sound security principles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are many universal principles. Let''s review the most important principles
    and understand how they assist in preventing attacks and making attacks more difficult,
    thus minimizing the damage caused by any attack and assisting in recovering from
    these attacks:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Defense in depth**: Defense in depth means multiple and redundant layers
    of security. The purpose is to make it difficult for an attacker to compromise
    your system. Multi-factor authentication is a great example. You have a username
    and password, but you must also type in a one-time code that''s sent to your phone.
    If an attacker discovers your credentials, but doesn''t have access to your phone,
    they won''t be able to log in to the system and wreak havoc. There are multiple
    benefits to defense in depth, such as the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make your system more secure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make the cost of breaking your security too high for an attacker to even try
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Better protection from non-malicious mistakes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Principle of least privilege**: The principle of least privilege is similar
    to the famous *need to know basis* from the spy world. You can''t divulge what
    you don''t know. You can''t compromise what you have no access to. Any agent can
    be compromised. Limiting privileges just to the necessary ones will minimize damage
    if a breach occurs and will help in the auditing, mitigation, and analysis of
    incidents.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Minimize the attack surface**: This principle is very clear. The smaller
    your attack surface is, the easier it is to protect it. Please keep the following
    things in mind:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don't expose APIs that you don't need
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don't keep data that you don't use
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don't provide different ways to perform the same task
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The most secure code is code that's not written. It's also the most efficient
    and bug-free code. Consider the business value of each new feature you want to
    add very carefully. When migrating to some new technology or system, make sure
    not to leave legacy items behind. In addition to preventing many attack vectors,
    when a breach does occur the smaller attack surface will help a lot in terms of
    focusing the investigation and finding the root cause.
  prefs: []
  type: TYPE_NORMAL
- en: '**Minimize the blast radius**: Take it as a given that your system will be
    compromised or may have already been compromised. However, there are different
    levels of threat. Minimizing the blast radius means that compromised components
    can''t easily reach out to other components and spread throughout our system.
    It also means that the resources that are available to those compromised components
    don''t exceed the needs of the legitimate workload that is supposed to run there.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Trust no one**: Here is a partial list of entities you shouldn''t trust:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your partners
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vendors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your cloud provider
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Open source developers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your developers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your admins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Yourself
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we say *don't trust*, we don't mean that necessarily in a malicious way.
    Everyone is fallible and honest mistakes can be just as detrimental as targeted
    attacks. The great thing about the *Trust no one* principle is that you don't
    have to make a judgement call. The same approach of minimal trust will help you
    prevent and mitigate mistakes and attacks.
  prefs: []
  type: TYPE_NORMAL
- en: '**Be conservative**: The Lindy effect says that for some non-perishable things,
    the longer they exist, the longer you can expect them to exist. For example, if
    a restaurant exists for 20 years, you can expect it to exist for many more years,
    whereas a brand new restaurant that has just opened is much more likely to shut
    down within a short period of time. This is very true for software and technology.
    The latest JavaScript framework may have the lifetime expectancy of a fruit fly,
    but something like jQuery will be around for a while. From a security standpoint,
    there are other benefits from using more mature and battle-hardened software whose
    security has undergone a baptism of fire. It''s often better to learn from other
    people''s experiences. Take the following things into account:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don't upgrade to the latest and greatest (unless explicitly fixing a security
    vulnerability).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prefer stability over ability.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prefer simplicity over power.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This goes hand in hand with the *trust no one* principle. Don't trust new shiny
    stuff and don't trust newer versions of your current dependencies. Of course,
    microservices and Kubernetes are relatively new technologies and the ecosystem
    is evolving fast. In this case, I assume that you've made a decision that the
    overall benefits of these innovations and their current status are mature enough
    to build on.
  prefs: []
  type: TYPE_NORMAL
- en: '**Be vigilant**: Security is not a one-shot thing. You have to actively keep
    working on it. The following are globally some ongoing activities you should perform
    and processes you should follow:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Patch your systems regularly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rotate your secrets.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use short-lived keys, tokens, and certificates.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Follow up on CVEs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Audit everything.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test the security of your systems.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Be ready**: When the inevitable breach happens, be ready and ensure you do
    or have done the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set up an incident management protocol.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Follow your protocol.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Plug the holes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Restore system security.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Perform post-mortem for security incidents.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Evaluate and learn.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update your process, tools, and security to improve your security posture.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Do not write your own crypto**: A lot of people are excited about crypto
    and/or are disappointed when a strong crypto impacts performance. Contain your
    excitement and/or disappointment. Let the experts do crypto. It''s much harder
    than it seems and the stakes are too high.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we're clear about the general principles of good security, let's look
    at what Kubernetes offers in terms of security.
  prefs: []
  type: TYPE_NORMAL
- en: Differentiating between user accounts and service accounts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Accounts are a central concept in Kubernetes. Every request to the Kubernetes
    API server must originate from a particular account that the API server will authenticate,
    authorize, and admit before going through with it. There are two types of account:'
  prefs: []
  type: TYPE_NORMAL
- en: User accounts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Service accounts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's examine both account types and understand the differences and when it's
    appropriate to use each one.
  prefs: []
  type: TYPE_NORMAL
- en: User accounts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: User accounts are for humans (cluster administrators or developers) who typically
    operate Kubernetes from the outside via kubectl or programmatically. End users
    shouldn't have Kubernetes user accounts, only application-level user accounts.
    This is unrelated to Kubernetes. Remember, Kubernetes manages your containers
    for you – it has no idea what's going on inside and what your application is actually
    doing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your user credentials are stored in the `~/.kube/config` file. If you are working
    with multiple clusters, then you may have multiple clusters, users, and contexts
    in your `~/.kube/config` file. Some people prefer to have a separate config file
    for each cluster and switch between them using the `KUBECONFIG` environment variable.
    This is up to you. The following is my config file for a local Minikube cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the preceding code block, this is a YAML file that follows
    the conventions of typical Kubernetes resources, although it''s not an object
    you can create in your cluster. Note that everything is plural: clusters, contexts,
    users. In this case, there is just one cluster and one user. However, you can
    create multiple contexts that are a combination of clusters and users so that
    you have multiple users with different privileges in the same cluster, or even
    multiple clusters in the same Minikube configuration file. `current-context` determines
    the target of each operation of `kubectl` (which cluster to access with what user
    credentials). User accounts have cluster-scope, which means that we can access
    resources in any namespace.'
  prefs: []
  type: TYPE_NORMAL
- en: Service accounts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Service accounts are a different story. Each pod has a service account associated
    with it, and all the workloads running in this pod use that service account as
    their identity. Service accounts are scoped to a namespace. When you create a
    pod (directly or via a deployment), you may specify a service account. If you
    create a pod without specifying a service account, then the namespace's default
    service account is used. Each service account has a secret associated with it
    for talking to the API server.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following block shows the default service account in the default namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The service account can have more than one secret. We will talk about secrets
    very soon. The service account allows the code running in the pod to talk to the
    API server.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can fetch a token and CA certificate from: `/var/run/secrets/kubernetes.io/serviceaccount`
    and then construct a `REST HTTP` request by passing these credentials via an authorization
    header. For example, the following code block shows a request to list pods in
    the default namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The result is 403 forbidden. The default service account is not allowed to list
    the pods, and actually it's not allowed to do anything. In the `Authorization`
    section, we will see how to grant privileges to service accounts.
  prefs: []
  type: TYPE_NORMAL
- en: If you don't feel comfortable with manually constructing curl requests, you
    can also do it programmatically via the client library. I created a Python-based
    Docker image that includes the official Python client ([https://github.com/kubernetes-client/python](https://github.com/kubernetes-client/python))
    library for Kubernetes and a few other goodies, such as vim, IPython, and HTTPie.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the Dockerfile that builds the image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'I uploaded it to DockerHub as `g1g1/py-kube:0.2`. Now, we can run it as a pod
    in the cluster and have a nice troubleshooting or interactive exploration session:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Executing the preceding command will drop you into a command-line prompt where
    you can do whatever you want with Python, IPython, HTTPie, and of course the Kubernetes
    Python client package that''s available. Here is how we can list the pods in the
    default namespace from Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The result will be similar – a Python exception – because the default account
    is forbidden to list pods. Note that, if your pod doesn''t need to access the
    API server (very common), you can make it explicit by setting `automountServiceAccountToken:
    false`.'
  prefs: []
  type: TYPE_NORMAL
- en: This can be done at the service account level or in the pod spec. This way,
    even if something or someone outside your control adds permissions to the service
    account at a later date, since there is no token mounted, the pod will fail to
    authenticate to the API server and will not get unintended access. Delinkcious
    services currently have no need to access the API server, so by following the
    principle of least privilege, we can add this to their spec in the deployment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how you can create a service account for the LinkManager (without access
    to the API server)  and add it to the deployment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Before granting our service account super powers using RBAC, let's review how
    Kubernetes manages secrets. Kubernetes stores secrets in etcd by default. It is
    possible to integrate etcd with third-party solutions, but in this section we
    will focus on vanilla Kubernetes. Secrets should be encrypted at rest and in transit,
    and etcd has supported this since version 3.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand how accounts work in Kubernetes, let's see how to manage
    secrets.
  prefs: []
  type: TYPE_NORMAL
- en: Managing secrets with Kubernetes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before granting our service account super powers using RBAC, let's review how
    Kubernetes manages secrets. Kubernetes stores secrets in etcd ([https://coreos.com/etcd/](https://coreos.com/etcd/))
    by default. There are different types of secret Kubernetes can manage. Let's look
    at the various secret types and then create our own secrets and pass them to containers.
    Finally, we'll build a secure pod together.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the three types of Kubernetes secret
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are three distinct types of secret:'
  prefs: []
  type: TYPE_NORMAL
- en: Service account API token (credentials for talking to the API server)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Registry secret (credentials for pulling images from private registries)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Opaque secret (your secrets that Kubernetes knows nothing about)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The service account API token is built-in for each service account (unless
    you specified `automountServiceAccountToken: false` ). Here is the secret for
    the service account API token for the `link-manager`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `pull secrets` image is a little more complicated. Different private registries
    behave differently and require different secrets. Also, some private registries
    require that you refresh your tokens often. Let''s look at an example with DockerHub.
    DockerHub lets you have a single private repository by default. I converted `py-kube` into
    a private repository, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/bf7fadd6-8d83-4238-9652-66c89f6bd039.png)'
  prefs: []
  type: TYPE_IMG
- en: 'I deleted the local Docker image. To pull it, I need to create a registry secret:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The last type of secret is `Opaque` and is the most interesting type of secret.
    You store your sensitive information in opaque secrets that Kubernetes doesn''t
    touch. It just provides you with a robust and secure store for your secrets and
    an API for creating, reading, and updating those secrets. You can create opaque
    secrets in many ways, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: From literal values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From a file or directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From an `env` file (key-value pairs in separate lines)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a YAML manifest with `kind`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is very similar to ConfigMaps. Now, let's create some secrets.
  prefs: []
  type: TYPE_NORMAL
- en: Creating your own secrets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the simplest and most useful ways to create secrets is via a simple
    `env` file that contains key-value pairs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We can create a secret by using the `-o yaml` flag (YAML output format) to
    see what was created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The type is `Opaque` and the returned values are base64-encoded. To fetch the
    values and decode them, you can use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `jsonpath` output format lets you drill-down into specific parts of the
    object. You can also use `jq` ([https://stedolan.github.io/jq/](https://stedolan.github.io/jq/))
    if you prefer.
  prefs: []
  type: TYPE_NORMAL
- en: Note that secrets are not stored or transmitted; they are just encrypted or
    encoded in base-64, which anyone can decode. When you create a secret using your
    user account (or get secrets), you get back the base-64 encoded representation
    of the decrypted secret. However, it is encrypted at rest on disk and also encrypted
    in transit since you communicate with the Kubernetes API server over HTTPS.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have understood how to create secrets, we will make them available
    to workloads that are running in containers.
  prefs: []
  type: TYPE_NORMAL
- en: Passing secrets to containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are many ways to pass secrets to containers, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: You can bake secrets into the container image.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can pass them into environment variables.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can mount them as files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The most secure way is to mount your secrets as files. When you bake your secret
    into the image, anyone with access to the image can retrieve your secrets. When
    you pass your secrets as environment variables, they can be viewed via `docker
    inspect`, `kubectl describe pod`, and by child processes if you don't clean up
    the environment. In addition, it is common to log your entire environment when
    reporting an error, which takes discipline from all your developers to sanitize
    and redact secrets. Mounted files don't suffer from these weaknesses, but note
    that anyone who can `kubectl exec` into your container can examine any mounted
    files, including secrets, if you don't manage permissions carefully.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a secret from a YAML manifest. When choosing this method, it''s
    your responsibility to base64-encode the values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create the new secrets and verify that they were created successfully
    by getting them using `kubectl get secret`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now that we know how to create opaque/generic secrets and pass them to containers,
    let's connect all the dots and build a secure pod.
  prefs: []
  type: TYPE_NORMAL
- en: Building a secure pod
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The pod has a custom service that doesn't need to talk to the API server (so
    there's no need to auto-mount a service account token); instead, the pod offers `imagePullSecret`
    to pull our private repository and also has some generic secrets mounted as a
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s get started and learn how to build a secure pod:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is the custom service account. Here is the YAML manifest:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we''ll attach it to our pod and also set the `imagePullSecret` we created
    earlier. There''s a lot going on here. I attached a custom service account, created
    a secret volume that references the `generic-secrets2` secret, then a volume mount
    that mounts it into `/etc/generic-secrets2`; finally, I set `imagePullSecrets`
    to the `private-dockerhub` secret:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we can create our pod and start playing around:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Kubernetes was able to pull the image from the private repository. We expect
    no API server token (there shouldn''t be `/var/run/secrets/kubernetes.io/serviceaccount/`),
    and our secrets should be mounted as files in `/etc/generic-secrets2`. Let''s
    verify this by starting an interactive shell using `kubectl exec -it` and check
    that the service account file doesn''t exist, but that the generic secrets `c`
    and `d` do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Yay, it works!
  prefs: []
  type: TYPE_NORMAL
- en: Here, we focused a lot on managing custom secrets and built a secure pod that
    can't access the Kubernetes API server, but often you need to carefully manage
    the access of different entities have to the Kubernetes API server. Kubernetes
    has a well-defined **role-based access control model** (also known as **RBAC**).
    Let's see it in action.
  prefs: []
  type: TYPE_NORMAL
- en: Managing permissions with RBAC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'RBAC is a mechanism that''s used to manage access to Kubernetes resources.
    With effect from Kubernetes 1.8, RBAC is considered stable. Start the API server
    with `--authorization-mode=RBAC` to enable it. RBAC works as follows when a request
    to the API server comes in:'
  prefs: []
  type: TYPE_NORMAL
- en: First, it authenticates the request via the user credentials or service account
    credentials of the caller (returns 401 unauthorized if it fails).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, it checks the RBAC policies to verify whether the requester is authorized
    to perform the operation on the target resource (returns 403 forbidden if it fails).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, it runs through an admission controller that may reject or modify the
    request for various reasons.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The RBAC model consists of identities (user and service accounts), resources
    (Kubernetes objects), verbs (standard actions such as `get`, `list`, and `create`),
    roles, and role bindings. Delinkcious services don't need to access the API server,
    so they don't need access. However, Argo CD, the continuous delivery solution,
    definitely needs access as it deploys our services and all related objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the following snippet from a role and understand it in detail.
    You can find the source here: [https://github.com/argoproj/argo-cd/blob/master/manifests/install.yaml#L116](https://github.com/argoproj/argo-cd/blob/master/manifests/install.yaml#L116):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'A role has rules. Each rule assigns a list of allowed verbs to each API group
    and resources within that API group. For example, for the empty API group (indicates
    the core API group) and the `configmaps` and `secrets` resources, the Argo CD
    server can apply all of these verbs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The `argoproj.io` API group and the `applications` and `appprojects` resources
    (both are CRDs defined by Argo CD) have another list of verbs. Finally, for the
    `events` resource of the core group, it can only use the `create` or `list` verb:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: An RBAC role applies only to the namespace it was created in. This means that
    the fact that Argo CD can do anything with `configmaps` and `secrets` is not too
    scary if it's created in a dedicated namespace. As you may recall, I installed
    Argo CD on the cluster in a namespace called `argocd`.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, similar to a role, RBAC also has a `ClusterRole` where the permissions
    that are listed are allowed across the cluster. Argo CD has cluster roles too.
    For example, `argocd-application-controller` has the following cluster role:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This pretty much gives access to anything on the cluster. It is equivalent to
    not having RBAC at all. I'm not sure why the Argo CD application controller needs
    such global access. My guess is that it's just easier to get access to anything
    than explicitly list everything if it's a big list. However, this is not the best
    practice from a security standpoint.
  prefs: []
  type: TYPE_NORMAL
- en: 'Roles and cluster roles are just a list of permissions. To make it all work,
    you need to bind a role to a set of accounts. That''s where role bindings and
    cluster role bindings come into play. Role bindings only work in their namespace.
    You can role-bind both a role and a cluster role (in which case the cluster role
    will be active in the target namespace only). Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: A cluster role binding applies across the cluster and can bind a cluster role
    only (because a role is restricted to its namespace).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand how to control access to Kubernetes resources using RBAC,
    let's move on to controlling access to our own microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling access with authentication, authorization, and admission
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kubernetes has an interesting access control model that goes above and beyond
    standard access control. For your microservices, it provides the troika of authentication,
    authorization, and admission. You're probably familiar with authentication (who
    is calling?) and authorization (what is the caller allowed to do?). Admission
    is not as common. It can be used for a more dynamic situation where a request
    may be rejected, even if the caller is properly authenticated and authorized.
  prefs: []
  type: TYPE_NORMAL
- en: Authenticating microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Service accounts and RBAC are a good solution to manage identity and access
    for Kubernetes objects. However, in a microservice architecture, there will be
    a lot of communication between microservices. This communication happens inside
    the cluster and may be considered less prone to attacks. But the defense in depth
    principle guides us to encrypt, authenticate, and manage this communication as
    well. There are several approaches here. The most robust approach requires your
    own **private key infrastructure** (**PKI**) and **certificate authority** (**CA**)
    that can deal with issuing, revoking, and updating certificates as service instances
    come and go. This is pretty complicated (if you use a cloud provider, they may
    provide it for you). A somewhat simpler approach is to utilize Kubernetes secrets
    and create shared secrets between each of the two services that can talk to each
    other. Then, when a request comes in, we can check whether the calling service
    passed the correct secret, which authenticates it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a mutual secret for `link-manager` and `graph-manager` (remember
    that it must be base64-encoded):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we will create a secret for `link-manager`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Never commit secrets to source control. I have done it here for educational
    purposes only.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see the value of the secret using `kubectl` and the `jsonpath` format, you
    need to escape the dot in `mutual-auth.yaml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll repeat the process for `social-graph-manager`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we will create a secret for `social-graph-manager`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, `link-manager` and `social-graph-manager` have a shared secret
    that we can mount to the respective pods. Here is the pod spec in the `link-manager`
    deployment that mounts the secret from a volume into `/etc/delinkcious`. The secret
    will show up as the `mutual-auth.yaml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We can apply the same convention to all services. The result is that each pod
    will have a file called `/etc/delinkcious/mutual-auth.yaml` with the tokens of
    all the services it needs to talk to. Based on this convention, we created a little
    package called `auth_util` that reads the file, populates a couple of maps, and
    exposes a couple of functions for mapping and matching callers and tokens. The
    `auth_util` package expects the file itself to be a YAML file with key-value pairs
    in the format of  `<caller>: <token>`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the declarations and maps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The `init()` function reads the file (unless the `env` variable, `DELINKCIOUS_MUTUAL_AUTH`,
    is set to `false`), unmarshals it into the `callersByName` map, and then iterates
    over it and populates the reverse `callersByToken` map, where the tokens are the
    keys and the callers are the values (with possible duplicates):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the `GetToken()` and `HasCaller()` functions provide the external
    interface to the package that''s used by services and clients that communicate
    with each other:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see how the link service calls the `GetFollowers()` method of the social
    graph service. The `GetFollowers()` method extracts the authentication token from
    the environment and compares it to the token that''s provided in the headers (this
    is only known to the link service) to verify that the caller is really the link
    service. As usual, the core logic doesn''t change. The entire authentication scheme
    is isolated to the transport and client layers. Since the social graph service
    uses the HTTP transport, the client stores the token in a header called `Delinkcious-Caller-Service`.
    It gets the token from the `auth_util` package via the `GetToken()` function without
    knowing anything about where the secret is coming from (in our case, the Kubernetes
    secret is mounted as a file):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'On the service side, the social graph service transport layer ensures that
    `Delinkcious-Caller-Token` exists and that it contains the token of a valid caller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The beauty of this mechanism is that we keep all the gnarly plumbing stuff of
    parsing files and extracting headers from HTTP requests in the transport layer
    and keep the core logic pristine.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 13](b39834c8-859c-42a5-846a-e48b76dfd6cc.xhtml), *Service Mesh –
    Working with Istio*, we will look at another solution for authenticating microservices
    using a service mesh. Now, let's move on to authorizing microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Authorizing microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Authorizing microservices can be very simple or very complicated. In the simplest
    case, if a calling microservice is authenticated, then it is authorized to perform
    any operation. However, sometimes, this is not enough and you need very sophisticated
    and fine-grained authorization, depending on other request parameters. For example,
    in a company I used to work at, I developed an authorization scheme for a sensor
    network with both spatial and temporal dimensions. Users could query the data,
    but they might be limited to certain cities, buildings, floors, or rooms.
  prefs: []
  type: TYPE_NORMAL
- en: If they requested data from a location they were not authorized to query, their
    request was rejected. They were also limited by time range and couldn't query
    outside their designated time range.
  prefs: []
  type: TYPE_NORMAL
- en: For Delinkcious, you can imagine that users may be limited to viewing their
    own links and the links of users they follow (if approved).
  prefs: []
  type: TYPE_NORMAL
- en: Admitting microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Authentication and authorization are very well-known and familiar mechanisms
    for access control (although not easy to implement robustly). Admission is yet
    another step that follows authorization. Even if a request is authenticated and
    authorized, it may not be possible to satisfy the request at the moment. This
    could be due to a rate limit or some other intermittent issue on the server side.
    Kubernetes implements additional capabilities, such as mutating requests as part
    of admission. For your own microservices, it may not be needed.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have discussed accounts, secrets, and access control. However, there's
    still a lot of work to be done in order to get closer to a secure and hardened
    cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Hardening your Kubernetes cluster using security best practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will cover various best practices and we'll see how close
    Delinkcious gets to getting it right.
  prefs: []
  type: TYPE_NORMAL
- en: Securing your images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the top priorities is making sure that the images that you deploy to
    the cluster are secure. There are several good guidelines to follow here.
  prefs: []
  type: TYPE_NORMAL
- en: Always pull images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the container spec, there is an optional key called `ImagePullPolicy`. The
    default is `IfNotPresent`. There are a few problems with this default, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: If you use tags such as *latest* (you shouldn't), then you will not pick up
    updated images.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You may have conflicts with other tenants on the same node.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other tenants on the same node can run your images.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kubernetes has an admission controller called `AlwaysPullImages` that sets the
    `ImagePullPolicy` of every pod to `AlwaysPullImages`. This prevents all the issues
    at the expense of pulling images, even if they are present and you had the right
    to use them. You turn on this admission controller by adding it to the list of
    enabled admission controllers that are passed to `kube-apiserver` via the `--enable-admission-controllers` flag.
  prefs: []
  type: TYPE_NORMAL
- en: Scan for vulnerabilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Vulnerabilities in your code or dependencies allow attackers to get access to
    your system. The national vulnerability database ([https://nvd.nist.gov/](https://nvd.nist.gov/))
    is a good place to learn about new vulnerabilities and processes for managing
    them, such as the **Security Content Automation Protocol** (**SCAP**).
  prefs: []
  type: TYPE_NORMAL
- en: Open-source solutions such as Claire ([https://github.com/coreos/clair](https://github.com/coreos/clair))
    and Anchore ([https://anchore.com/kubernetes/](https://anchore.com/kubernetes/))
    are available, as well as commercial solutions. Many image registries provide
    scanning services too.
  prefs: []
  type: TYPE_NORMAL
- en: Update your dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Keep your dependencies up-to-date, especially if they fix known vulnerabilities.
    This is where you need to find the right balance between being vigilant and being
    conservative.
  prefs: []
  type: TYPE_NORMAL
- en: Pinning the versions of your base images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pinning versions of base images is critical for ensuring repeatable builds.
    If your base image version is not specified, you will pick up the latest version,
    which may or may not be what you want.
  prefs: []
  type: TYPE_NORMAL
- en: Using minimal base images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The principle of minimizing the attack surface exhorts you to use as many minimal
    base images as possible; the smaller and more restricted, the better. In addition
    to these security benefits, you also enjoy faster pulling and pushing (although
    layers should make it relevant only when upgrading your base image). Alpine is
    a very popular base image. Delinkcious services take this approach to the extreme
    and use the `SCRATCH` image as a base image.
  prefs: []
  type: TYPE_NORMAL
- en: Pretty much the entire service is just the Go executable, and that's it. It's
    small, fast, and secure, but you pay for it when you need to troubleshoot issues
    and there are no tools to help you.
  prefs: []
  type: TYPE_NORMAL
- en: If we follow all of these guidelines, our images will be secure, but we should
    still apply the basic principles of least privilege and zero trust, and minimize
    the blast radius at the network level. If a container, pod, or node somehow gets
    compromised, they shouldn't be allowed to reach another part of the network except
    what's needed by the workloads running on these components. This is where namespaces
    and network policies come into the picture.
  prefs: []
  type: TYPE_NORMAL
- en: Dividing and conquering your network
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to authentication as part of defense in depth, you can ensure that
    services talk to each other only if they're supposed to by utilizing namespaces
    and network policies.
  prefs: []
  type: TYPE_NORMAL
- en: Namespaces are a very intuitive yet powerful concept. However, on their own,
    they don't prevent pods in the same cluster from communicating with each other.
    In Kubernetes, all the pods in a cluster share the same flat networking address
    space. This is one of the great simplifications of the Kubernetes networking module.
    Your pods can be on the same nodes or a different node – it doesn't matter.
  prefs: []
  type: TYPE_NORMAL
- en: Each pod will have its own IP address (even if multiple pods run on the same
    physical node or VM with a single IP address). This is where network policies
    come into the picture. A network policy is basically a set of rules that specify
    both intra-cluster communication between pods (east-west traffic), as well as
    communication between services in the cluster and the outside world (north-south
    traffic). If no network policy is specified, all incoming traffic (ingress) is
    allowed by default on all the ports of every pod. From a security perspective,
    this is unacceptable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by blocking all ingress and later open up selectively as needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Note that network policies work at the pod level. You specify pods with labels,
    which is one of the primary reasons why you should properly group your pods using
    meaningful labels.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before applying this policy, it''s good to know that it works from the troubleshooting
    pod, as shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'However, after applying the `deny-all` policy, we get a timeout error, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that all the pods are isolated, let''s allow `social-graph-manager` to
    talk to its database. Here is a network policy that allows only `social-graph-manager`
    to access `social-graph-db` on port `5432`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'And the following additional policy allows ingress to `social-graph-manager`
    on port `9090` from the `link-manager`, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: In addition to the security benefits, the network policies serve as live documentation
    to the flow of information across the system. You can tell exactly which services
    talk to which other services, as well as external services.
  prefs: []
  type: TYPE_NORMAL
- en: We have gotten our network under control. Now, it's time to turn our attention
    to our image registry. After all, this is where we get our images, which we give
    a lot of permissions to.
  prefs: []
  type: TYPE_NORMAL
- en: Safeguarding your image registry
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is highly recommended to use private image registries. If you have proprietary
    code, then you must not publish your containers with public access because reverse-engineering
    your images will grant attackers access. However, there are other reasons for
    this too. You get better control over (and auditing of) pulling and pushing images
    from the registry.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two options here:'
  prefs: []
  type: TYPE_NORMAL
- en: Use a private registry managed by a third party like AWS, Google, Microsoft,
    or Quay.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use your own private registry.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first option makes sense if you deploy your system on a cloud platform that
    has good integration with its own image registry or if you don't manage your own
    registry in the sprint of cloud-native computing and you prefer to let a third
    party such as Quay do it for you.
  prefs: []
  type: TYPE_NORMAL
- en: The second option (running your own container registry) may be best if you need
    extra control over all the images, including base images and dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Granting access to Kubernetes resources as needed
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The principle of least privilege directs you to grant access to Kubernetes
    resources only to services that actually need it (for example, Argo CD). RBAC
    is a great option here since everything is locked down by default and you can
    explicitly add privileges. However, beware of falling into the trap of giving
    wildcard access to everything just to get over difficulties with RBAC configuration.
    For example, let''s take a look at a cluster role with the following rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This is worse than disabling RBAC because it gives you a false sense of security.
    Another option for a more dynamic situation is dynamic authentication, authorization,
    and admission control via webhooks and external servers. Those give you the ultimate
    flexibility.
  prefs: []
  type: TYPE_NORMAL
- en: Using quotas to minimize the blast radius
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Limits and quotas are a Kubernetes mechanism where you can control various
    limited resources such as CPU and memory which are allocated to clusters, pods,
    and containers. They are very useful for multiple reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: Performance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Capacity planning.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cost management.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They help Kubernetes schedule pods based on resource utilization.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When your workloads operate within a budget, everything becomes more predictable
    and easier to reason about, although you have to do the leg work of figuring out
    how many resources are actually needed and adjust this as time goes by. This is
    not as bad as it sounds since, with horizontal pod autoscaling, you can let Kubernetes
    dynamically adjust the number of pods for a service, even if each pod has a very
    strict quota.
  prefs: []
  type: TYPE_NORMAL
- en: From a security perspective, if an attacker gains access to a workload running
    on your cluster, it limits the amount of physical resources it can use. One of
    the most common attacks these days is just saturating targets with crypto currency
    mining. Similar types of attacks are fork bombs, which just consume all the available
    resources by having a rogue process replicate itself uncontrollably. Network policies
    limit the blast radius of compromised workloads by limiting access to other pods
    on the network. Resource quotas minimize the blast radius from utilizing the resources
    on the hosting node of the compromised pod.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several types of quota, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Compute quota (CPU and memory)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storage quota (disks and external storage)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Objects (Kubernetes object)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extended resources (non-Kubernetes resources like GPUs)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Resource quotas are quite nuanced. There are several concepts you need to understand,
    such as units and scopes, as well as the difference between requests and limits.
    I''ll explain the basics and demonstrate them by adding resource quotas for the
    Delinkcious user service. A resource quota is allocated for container, so you
    add it to the container spec as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two sections under resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Requests**: Requests are what the container requests in order to start. If
    Kubernetes can''t satisfy a request for a particular resource, it will not start
    the pod. Your workload can be sure that it will have that much CPU and memory
    allocated to it throughout its life, and you can take it to the bank.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the preceding block, I specified a request of `64Mi` of memory and `250m`
    units of CPU (see the following section for an explanation of these units).
  prefs: []
  type: TYPE_NORMAL
- en: '**Limits**: Limits are the ceiling for resources a workload may have access
    to. A container that exceeds its memory limits might be killed and the entire
    pod may be evicted from the node. Kubernetes will restart the container if killed
    and reschedule the pod if evicted, like it does with any type of failure. If a
    container exceeds its CPU limits, it will not be killed and may even get away
    with it for a while but, since the CPU is much easier to control, it will probably
    just not get all the CPU it requests and will sleep a lot to remain within its
    limits.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is often the best approach to specify requests as limits, like I did for
    the user manager. The workload knows that it already has all the resources it
    will ever need and doesn't have to worry about trying to get closer to the limit
    in the presence of other hungry neighbors on the same node who may all compete
    for the same resource pool.
  prefs: []
  type: TYPE_NORMAL
- en: While resources are specified per container, when pods have multiple containers,
    it's important to consider the total resource requests of the entire pod (the
    sum of all the container requests). The reason for this is that pods are always
    scheduled as one unit. If you have a pod that has 10 containers, with each one
    asking for 2 Gib of memory, then it means that your pod requires a node with 20
    Gib of free memory.
  prefs: []
  type: TYPE_NORMAL
- en: Units for requests and limits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can use the following suffixes for memory requests and limits: E, P, T,
    G, M, and K. You can also use the power of two suffixes (which are always a little
    larger), that is, Ei, Pi, Ti, Gi, Mi, and Ki. You can also just use integers,
    including the exponent notation for bytes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are approximately the same: 257,988,979, 258e6, 258M, and 246Mi. CPU
    units are relative to the hosting environment, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 1 AWS vCPU
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 GCP Core
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 Azure vCore
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 IBM vCPU
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 hyperthread on a bare-metal Intel processor with hyperthreading
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can request CPU in fractions of resolutions of 0.001\. A more convenient
    method is to use milliCPU and just integers with the `m` suffix; for example,
    100 m is 0.1 CPU.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing security contexts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, pods and containers need escalated privileges or access to the node.
    This will be very rare for your application workloads. However, when necessary,
    Kubernetes has the concept of a security context that encapsulates and allows
    you to configure multiple Linux security concepts and mechanisms. This is critical
    from a security perspective because you open up a tunnel out of the container
    world into the host machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a list of some mechanisms that are covered by security contexts:'
  prefs: []
  type: TYPE_NORMAL
- en: Allowing (or forbidding) privilege escalation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Access control via user IDs and group IDs (`runAsUser`, `runAsGroup`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Capabilities as opposed to unrestricted root access
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using AppArmor and seccomp profiles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SELinux configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are many details and interactions that are beyond the scope of this book.
    I''ll just share an example of `SecurityContext`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The security policy does different things, such as setting the user ID inside
    the container to `2000` and not allowing privilege escalation (getting root),
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Security contexts are a very good way to centralize the security aspects of
    a pod or container, but in a large cluster where you potentially install third-party
    packages such as helm charts, it's difficult to ensure that every pod and container
    gets the right security context. That's where pod security policies come into
    the picture.
  prefs: []
  type: TYPE_NORMAL
- en: Hardening your pods with security policies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A pod security policy allows you set a global policy that applies to all newly
    created pods. It is enforced as part of the admission stage of access control.
    The pod security policy can create a security context for pods with no security
    context or reject pod creation and updating if they have a security context that
    doesn''t match the policy. Here is a security policy that will prevent pods from
    getting a privileged status that allows access to host devices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are some good policies to enforce (if you don''t need the capabilities):'
  prefs: []
  type: TYPE_NORMAL
- en: Read-only root filesystem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Control mounting host volumes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prevent privileged access and escalation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Last but not least, let's make sure that the tools we will use to work with
    our Kubernetes cluster are secure as well.
  prefs: []
  type: TYPE_NORMAL
- en: Hardening your toolchain
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Delinkcious is pretty well-contained. The main tool it uses is Argo CD. Argo
    CD, which can potentially cause a lot of damage, is running inside the cluster
    and pulls from GitHub. However, it has a lot of permissions. Before I decided
    to use Argo CD as the continuous delivery solution for Delinkcious, I reviewed
    it seriously from a security perspective. The Argo CD developers did a great job
    of thinking how to make Argo CD secure. They made sensible choices, implemented
    them, and documented how to run Argo CD securely. Here are the security features
    that Argo CD provides:'
  prefs: []
  type: TYPE_NORMAL
- en: Authentication of the admin user via JWT tokens
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authorization via RBAC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Secure communication over HTTPS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Secret and credential management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Audits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cluster RBAC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's take a look at them briefly.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication of admin user via JWT tokens
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Argo CD has a built-in admin user. All other users must use **Single-Sign on**
    (**SSO**). Authentication to the Argo CD server always uses **JSON Web Token**
    (**JWT**). Admin user credentials are converted into JWT too.
  prefs: []
  type: TYPE_NORMAL
- en: It also supports automation via the `/api/v1/projects/{project}/roles/{role}/token`
    endpoint, which generates automation tokens that are issued and signed by Argo
    CD itself. These tokens are limited in scope and expire pretty fast.
  prefs: []
  type: TYPE_NORMAL
- en: Authorization via RBAC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Argo CD authorizes requests by mapping the user's JWT group claims to RBAC roles.
    This is a very nice combination of industry-standard authentication with the Kubernetes
    authorization model via RBAC.
  prefs: []
  type: TYPE_NORMAL
- en: Secure communication over HTTPS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All communication to/from Argo CD, as well as between its own components, is
    done over HTTPS/TLS.
  prefs: []
  type: TYPE_NORMAL
- en: Secret and credentials management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Argo CD needs to manage a lot of sensitive information, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes secrets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Git credentials
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OAuth2 client credentials
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Credentials to external clusters (when not installed in the cluster)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Argo CD makes sure to keep all of these secrets to itself. It never leaks them
    by returning them in responses or logging them. All API responses and logs are
    scrubbed and redacted.
  prefs: []
  type: TYPE_NORMAL
- en: Audits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can audit most of the activity just by looking at git commit logs, which
    triggers everything in Argo CD. However, Argo CD also sends various events to
    capture in-cluster activity for additional visibility. This combination is powerful.
  prefs: []
  type: TYPE_NORMAL
- en: Cluster RBAC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By default, Argo CD uses a cluster-wide admin role. This isn't necessary. The recommendation is
    to restrict its write privileges only to the namespaces it needs to manage.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we took a serious look at a serious topic: security. Microservice-based
    architectures and Kubernetes make the most sense to large-scale enterprise-distributed
    systems that support mission-critical objectives and often manage sensitive information.
    On top of the challenges of developing and evolving such complex systems, we must
    be aware that such systems present very enticing targets to attackers.
  prefs: []
  type: TYPE_NORMAL
- en: We must use a rigorous process and best practices to protect the system, the
    users, and the data. From here, we covered security principles and best practices,
    and we also saw how they support each other and how Kubernetes dedicates a lot
    of effort to allowing them to develop and operate our system securely.
  prefs: []
  type: TYPE_NORMAL
- en: We also discussed the pillars that act as the foundation of microservice security
    on Kubernetes: the triple A of authentication/authorization/admission, secure
    communication inside and outside the cluster, strong secret management (encrypted
    at rest and in transit), and layered security policies.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you should have a clear understanding of the security mechanisms
    that are at your disposal and enough information to decide how to integrate them
    into your system. Security is never complete, but utilizing best practices will
    allow you to find the right balance between security and the other requirements
    of your system at each point in time.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will finally open Delinkcious to the World! We will
    look at public APIs, load balancers, and the important considerations for performance
    and security that we need to be aware of.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are many good resources for Kubernetes security. I''ve collected some
    very good external resources that will aid you in your journey:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Kubernetes security**: [https://kubernetes-security.info/](https://kubernetes-security.info/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Microsoft SDL practices**: [https://www.microsoft.com/en-us/securityengineering/sdl/practices](https://www.microsoft.com/en-us/securityengineering/sdl/practices)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following Kubernetes documentation pages expand on a lot of the topics
    we have covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Network Policies**: [https://kubernetes.io/docs/concepts/services-networking/network-policies/](https://kubernetes.io/docs/concepts/services-networking/network-policies/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resource Quotas**: [https://kubernetes.io/docs/concepts/policy/resource-quotas/](https://kubernetes.io/docs/concepts/policy/resource-quotas/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Configure a Security Context for a Pod or Container**: [https://kubernetes.io/docs/tasks/configure-pod-container/security-context/](https://kubernetes.io/docs/tasks/configure-pod-container/security-context/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
