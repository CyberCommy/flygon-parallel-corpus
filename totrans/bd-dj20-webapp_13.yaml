- en: Deploying Mail Ape
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will deploy Mail Ape onto a virtual machine in the **Amazon
    Web Services** (**AWS**) cloud. AWS is composed of many different services. We've
    already discussed using S3 and launching a container into AWS. In this chapter,
    we will use a lot more AWS services. We will use the **Relational Database Service
    (RDS)** for a PostgreSQL database server. We will use the **Simple Queue Service
    (SQS)** for our Celery message queue. We will use **Elastic Computing Cloud (EC2)** to
    run virtual machines in the cloud. Finally, we will use CloudFormation to define
    our infrastructure as code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will do the following things:'
  prefs: []
  type: TYPE_NORMAL
- en: Separate production and development settings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use Packer to create an Amazon Machine Image of our release
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use CloudFormation to define the infrastructure as code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Launch Mail Ape into AWS using the command line
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start by separating our production development settings.
  prefs: []
  type: TYPE_NORMAL
- en: Separating development and production
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we've kept a single requirements file and a single `settings.py` file.
    This has made development convenient. However, we can't use our development settings
    in production.
  prefs: []
  type: TYPE_NORMAL
- en: The current best practice is to have a separate file per environment. Each environment's
    file then imports a common file with shared values. We'll use this pattern for
    our requirements and settings files.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by splitting up our requirements files.
  prefs: []
  type: TYPE_NORMAL
- en: Separating our requirements files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To separate our requirements, we''ll delete the existing `requirements.txt` file
    and replace it with common, development, and production requirements files. After
    we delete `requirements.txt`, let''s create `requirements.common.txt` at the root
    of our project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s create a requirements file for `requirements.development.txt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Since we only use Redis in our development setup, we'll keep the package in
    our development requirements file.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll put our production requirements in `requirements.production.txt` at
    the root of the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In order for Celery to work with SQS (the AWS message queue service), we will
    need to install the Celery SQS library (`celery[sqs]`). We will also install `boto3`,
    the Python AWS library, and `pycurl`, a Python `curl` implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's separate our Django settings files.
  prefs: []
  type: TYPE_NORMAL
- en: Creating common, development, and production settings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As in our previous chapters, before we sort our settings into three files, we'll
    create `common_settings.py` by renaming our current `settings.py` then making
    some changes.
  prefs: []
  type: TYPE_NORMAL
- en: Let's change `DEBUG = False` so that no new settings file can *accidentally*
    be in debug mode. Then, let's change the secret key to be obtained from an environment
    variable by updating `SECRET_KEY = os.getenv('DJANGO_SECRET_KEY')`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the database config, we can remove all the credentials but keep the `ENGINE`
    (to make it clear that we intend to use Postgres everywhere):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s create a development settings file in `django/config/development_settings.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Remember that you need to change your `MAILING_LIST_FROM_EMAIL`, `EMAIL_HOST` and
    `EMAIL_HOST_USER` to your correct development values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s put our production settings in `django/config/production_settings.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Our production settings file gets most of its values from environment variables
    so that we don''t check production values into our server. There are three settings
    we need to review, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`MAILING_LIST_LINK_DOMAIN`: This is the domain that links in our emails will
    point to. In our case, in the preceding code snippet, we used the same domain
    that we added to our `ALLOWED_HOSTS` list, ensuring that we''re serving the domain
    that the links point to.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CELERY_BROKER_TRANSPORT_OPTIONS`: This is a dictionary of options that configure
    Celery to use the correct SQS queue. We will need to set the region to `us-west-2`
    because our entire production deployment will be in that region. By default, Celery
    will want to use a queue called `celery`. However, we don''t want that name to
    collide with other Celery projects we might deploy. To prevent name collisions,
    we will configure Celery to use the `mailape-` prefix.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CELERY_BROKER_URL`: This tells Celery which broker to use. In our case, we''re
    using SQS. We will give our virtual machine access to SQS using AWS''s role-based
    authorization so that we don''t have to provide any credentials.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have our production settings created, let's make our infrastructure
    in the AWS Cloud.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an infrastructure stack in AWS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to host an app on AWS, we will need to ensure that we have some infrastructure
    set up. We''ll need to the following things:'
  prefs: []
  type: TYPE_NORMAL
- en: A PostgreSQL server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security Groups to open network ports so that we can access our database and
    web server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An InstanceProfile to give our deployed VM access to SQS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We could create all that using the AWS web console or using the command-line
    interface. However, over time, it can be hard to track how our infrastructure
    is configured if we rely on runtime tweaks. It would be much nicer if we could
    describe our required infrastructure in files that we could track in version control,
    much like we track our code.
  prefs: []
  type: TYPE_NORMAL
- en: AWS provides a service called CloudFormation, which lets us treat infrastructure
    as code. We will define our infrastructure in a CloudFormation template using
    YAML (JSON is also available, but we'll use YAML). We'll then execute our CloudFormation
    template to create a CloudFormation stack. The CloudFormation stack will be associated
    with actual resources in the AWS Cloud. If we delete the CloudFormation stack,
    the related resources will also be deleted. This gives us simple control over
    our use of AWS resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create our CloudFormation template in `cloudformation/infrastructure.yaml`.
    Every CloudFormation template begins with a `Description` and the template format
    version information. Let''s start our file with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Our CloudFormation template will have the following three parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Parameters`: This is where we will describe values that we’ll pass in at runtime.
    This block is optional but useful. In our case, we''ll pass in the master database
    password rather than hardcoding it in our template.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Resources`: This is where we will describe the specific resources that our
    stack will contain. This will describe our database server, SQS queue, security
    groups, and InstanceProfile.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Outputs`: This is where we will describe the values to output to make referencing
    the resources we created easier. This block is optional but useful. We will provide
    the address of our database server and the ID of the InstanceProfile we created.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start by creating the `Parameters` block of our CloudFormation template.
  prefs: []
  type: TYPE_NORMAL
- en: Accepting parameters in a CloudFormation template
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To avoid hardcoding values in a CloudFormation template, we can accept parameters.
    This helps us avoid hardcoding sensitive values (such as passwords) in a template.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add a parameter to accept the password of our database server''s master
    user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This adds a `MasterDBPassword` parameter to our template. We will be able to
    reference this value later on. CloudFormation templates let us add two pieces
    of information for parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Description`: This is not used by CloudFormation but is useful for the people
    who have to maintain our infrastructure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Type`: CloudFormation uses this to check whether the value we provide is valid
    *before* executing our template. In our case, the password is a `String`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next let's add a `Resources` block to define the AWS resources we'll need in
    our infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: Listing resources in our infrastructure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next, we will add a `Resources` block to our CloudFormation template in `cloudformation/infrastructure.yaml`.
    Our infrastructure template will define five resources:'
  prefs: []
  type: TYPE_NORMAL
- en: Security Groups, which will open network ports, permitting us to access our
    database and web servers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our database server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our SQS queue
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Role that allows access to SQS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An InstanceProfile, which lets our web servers assume the above Role
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start by creating the Security Groups, which will open the network ports
    by which we'll access our database and web servers.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Security Groups
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In AWS, a SecurityGroup defines a set of network access rules much like a network
    firewall. By default, virtual machines launched can *send* data out on any network
    port but not *accept* connections on any network port. That means that we can't
    connect using SSH or HTTP; let's fix that.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s update our CloudFormation template in `cloudformation/infrastructure.yaml`
    with three new Security Groups:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code block, we defined three new SecurityGroups to open ports
    `22` (SSH), `80` (HTTP), and `5432` (default Postgres port).
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a closer look at the syntax of a CloudFormation resource. Each resource
    block must have a `Type` and `Properties` attributes. The `Type` attribute tells
    CloudFormation what this resource describes. The `Properties` attribute describe
    settings for this particular resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our SecurityGroups used the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GroupName`: This gives human-friendly names. This is optional but recommended.
    CloudFormation can generate the names for us instead. SecurityGroup names must
    be unique for a given account (for example, I can''t have two `db-access` groups,
    but you and I can each have a `db-access` group).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GroupDescription`: This is a human-friendly description of the group''s purpose.
    It''s required to be present.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SecurityGroupIngress`: This is a list of ports on which to accept incoming
    connection for VMs in this group.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FromPort`/`ToPort`: Often, these two settings will have the same value, the
    network port you want to be to be able to connect to. `FromPort` is the port on
    which we will connect. `ToPort` is the VM port on which a service is listening.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CidrIp`: This is an IPv4 range to accept connections from. `0.0.0.0/0` means
    accept all connections.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, let's add a database server to our list of resources.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a Database Server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: AWS offers relational databases servers as a service called **Relational Database
    Service** (**RDS**). To create a database server on AWS, we will create a new
    RDS VM (called an *instance*). One important thing to note is that when we launch
    an RDS instance, we can connect to the PostgreSQL database on the server but we
    do not have shell access. We must run Django on a different VM.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add an RDS instance to our CloudFormation template in `cloudformation/infrastructure.yaml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Our new RDS instance entry is of the `AWS::RDS::DBInstance` type. Let''s review
    the properties we set:'
  prefs: []
  type: TYPE_NORMAL
- en: '`DBName`: This is the name of the *server*, not the name of any databases running
    on it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DBInstanceClass`: This defines the memory and processing power of the virtual
    machine of the server. At the time of writing this book, `db.t2.micro` is part
    of a free tier for accounts in their first year.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MasterUsername`: This is the username of the privileged administrator account
    on the server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MasterUserPassword`: This is the password for the privileged administrator
    account'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`!Ref MasterDBPassword`: This is the shortcut syntax to reference the `MasterDBPassword`
    parameter. This lets us avoid hardcoding the database server''s administrator
    password.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Engine`: This is the type of Database server we want; in our case, `postgres`
    will give us a PostgreSQL server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AllocatedStorage`: This indicates how much storage space the server should
    have, in gigabyte (GB).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PubliclyAccessible`: This indicates whether the server can be accessed from
    outside the AWS Cloud.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VPCSecurityGroups`: This is a list of SecurityGroups, indicating which ports
    are open and accessible.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`!GetAtt DatabaseSecurityGroup.GroupId`: This returns the `GroupID` attribute
    of the `DatabaseSecurityGroup` security group.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This block also introduces us to CloudFormation's `Ref` and `GetAtt` functions.
    Both these functions let us reference other parts of our CloudFormation stack
    which is very important. `Ref` lets us use our `MasterDBPassword` parameter as
    the value of our database server's `MasterUserPassword`. `GetAtt` lets us reference
    our AWS generated `GroupId` attribute of `DatabaseSecurityGroup` in our database
    server's list of `VPCSercurityGroups`.
  prefs: []
  type: TYPE_NORMAL
- en: AWS CloudFormation offers a variety of different functions to make building
    templates easier. They are documented in the AWS documentation online ([https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/intrinsic-function-reference.html](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/intrinsic-function-reference.html)).
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's create the SQS Queue that Celery will use.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a Queue for Celery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SQS is the AWS message queue service. Using SQS, we can create a Celery-compatible
    message queue that we don't have to maintain. SQS can quickly scale to handle
    any number of requests we send it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To define our queue, add it to our `Resources` block in `cloudformation/infrastructure.yaml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Our new resource is of the `AWS::SQS::Queue` type and has a single property,
    `QueueName`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's create a role and InstanceProfile to let our production servers
    access our SQS queue.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Role for Queue access
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Earlier, in the *Adding Security Groups* section, we discussed creating SecurityGroups
    to open network ports so that we could make a network connection. To manage access
    among AWS resources, we will need to use role-based authorization. In a role-based
    authorization, we define a role, who can be assigned that role (assume that role),
    and what actions that role can perform. In order for our web servers to use that
    role, we will need to create an EC2 instance profile that is associated with that
    role.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by adding a role to `cloudformation/infrastructure.yaml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Our new block is of the `AWS::IAM::Role` type. IAM is short for AWS Identity
    and Access Management services. Our role is composed of the following two properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AssumeRolePolicyDocument`: This defines who may be assigned this role. In
    our case, we''re saying that this role may be assumed by any object in Amazon''s
    EC2 service. Later, we''ll use it in our EC2 instances.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Policies`: This is a list of allowed (or denied) actions for this role. In
    our case, we''re permitting all SQS operations (`sqs:*`) on our previously defined
    SQS Queue. We reference our queue by getting its `Arn`, **Amazon Resource Name**
    (**ARN**), with the `GetAtt` function. ARNs are Amazon''s way of providing each
    resource on the Amazon cloud with a globally unique ID.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that we have our role, we can associate it with an `InstanceProfile` resource,
    which can be associated with our web servers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Our new InstanceProfile is of the `AWS::IAM::InstanceProfile` type and needs
    a list of associated roles. In our case, we simply reference our previously created
    `SQSAccessRole` using the `Ref` function.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've created our infrastructure resources, let's output the address
    of our database and our ARN of `InstanceProfile` resource.
  prefs: []
  type: TYPE_NORMAL
- en: Outputting our resource information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CloudFormation templates can have an output block to make it easier to reference
    the created resources. In our case, we will output the address of our database
    server and the ARN of `InstanceProfile.`
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s update our CloudFormation template in `cloudformation/infrastructure.yaml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we're using the `GetAtt` function to return the address
    of our `DatabaseServer` resource and the ARN of our `SQSClientInstance` `InstanceProfile` resource.
  prefs: []
  type: TYPE_NORMAL
- en: Executing our template to create our resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we've created our `CloudFormation` template, we can create a `CloudFormation`
    stack. When we tell AWS to create our `CloudFormation` stack, it will create all
    the related resources in our template.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create our template, we will need the following two things:'
  prefs: []
  type: TYPE_NORMAL
- en: The AWS **command-line interface** (**CLI**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An AWS access key/secret key pair
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can install the AWS CLI using `pip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: To get (or create) your access key/secret key pair, you will need access to
    the Security Credential ([https://console.aws.amazon.com/iam/home?region=us-west-2#/security_credential](https://console.aws.amazon.com/iam/home?region=us-west-2#/security_credential))
    section of your AWS Console.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we need to configure the AWS command line tool with our key and region.
    The `aws` command offers an interactive `configure` subcommand to do this. Let’s
    run it on the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `aws configure` command stores the values you entered in a `.aws` directory
    in your home directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'With those setups, we can now create our stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Creating a stack can take some time, so the command returns without waiting
    for success. Let''s take a closer look at our `create-stack` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '`--stack-name`: This is the name of stack we''re creating. Stack names must
    be unique per account.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--template-body`: This is either the template itself, or, in our case, a `file://`
    URL to the template file. Remember that `file://` URLs require the absolute path
    to the file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--capabilities CAPABILITY_NAMED_IAM`: This is required for templates that
    create or affect **Identity and Access Management** (**IAM**) services. This prevents
    accidentally affecting access management services.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--parameters`: This lets us pass in values for a template''s parameters. In
    our case, we set the master password for our database as `password`, which is
    not a safe value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--region`: The AWS Cloud is organized as a collection of regions across the
    world. In our case, we''re using `us-west-2`, which is located in a series of
    data centers around the US state of Oregon.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remember that you need to set a secure master password for your database.
  prefs: []
  type: TYPE_NORMAL
- en: 'To take a look at how stack creation is doing, we can check it using AWS Web
    Console ([https://us-west-2.console.aws.amazon.com/cloudformation/home?region=us-west-2](https://us-west-2.console.aws.amazon.com/cloudformation/home?region=us-west-2))
    or using the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'When the stack is done creating the related resources, it will return a result
    similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Two things to pay particular attention to in the `describe-stack` result are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The object under the `Parameters` key, which will show our master database password
    in plain text
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The object `Outputs` key, which shows the ARN of our `InstanceProfile` resource
    and the address of our database server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In all the previous code, I've replaced values specific to my account with XXX.
    Your output will differ.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to remove the resources associated with your stack, you can just
    delete the stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Next, we'll build an Amazon Machine Image, which we'll use to run Mail Ape in
    AWS.
  prefs: []
  type: TYPE_NORMAL
- en: Building an Amazon Machine Image with Packer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have our infrastructure running in AWS, let's build our Mail Ape
    server. In AWS, we could launch an official Ubuntu VM, follow the steps in [Chapter
    9](2c6bf064-57ff-41bc-89d0-21fac1308186.xhtml), *Deploying Answerly*, and have
    our Mail Ape running. However, AWS treats EC2 instances as *ephemeral*. If an
    EC2 instance gets terminated, then we will have to launch a new instance and configure
    it all over again. There are a few ways to mitigate this problem. We'll solve
    the problem of ephemeral EC2 instances by building a new **Amazon Machine Image**
    (**AMI**) for our release. Then any time we launch an EC2 instance using that
    AMI, it will be already perfectly configured.
  prefs: []
  type: TYPE_NORMAL
- en: We will automate building our AMIs using a HashiCorp's Packer tool. Packer gives
    us a way of creating an AMI from a Packer template. A Packer template is a JSON
    file that defines the steps needed to configure our EC2 instance into our desired
    state and save the AMI. For our Packer template to run, we’ll also write a collection
    of shell scripts to configure our AMI. Using a tool like Packer, we can automate
    building a new release AMI.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by installing Packer on our machines.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Packer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Get Packer from the [https://www.packer.io](https://www.packer.io) download
    page. Packer is available for all major platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll create a script to make the directories we’ll rely on in production.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a script to create our directory structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first script we will write will create directories for all our code. Let’s
    add the following script to our project in `scripts/make_aws_directories.sh`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we’re using `mkdir` to make the directories. Next, we
    want to make the `ubuntu` user can write to the `/mailape` directories so that
    we recursively `chown` the `/mailape` directory.
  prefs: []
  type: TYPE_NORMAL
- en: So, let's create a script to install the Ubuntu packages we require.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a script to install all our packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In our production environment, we will have to install Ubuntu packages as well
    as the Python packages we’ve already listed. First, let’s list all our Ubuntu
    packages in `ubuntu/packages.txt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s create a script to install all the packages in `scripts/install_all_packages`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding script, we will install the Ubuntu packages that we listed
    above, then create a `virtualenv` to isolate our Mail Ape Python environment and
    packages. Finally, we give Apache (the `www-data` user) the ownership of some
    directories so that it can write to them. We couldn’t give the `www-data` user
    the ownership because they probably didn’t exist until we installed the `apache2`
    package.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s configure to run Apache2 to run Mail Ape using mod_wsgi.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Apache
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we'll add Apache mod_wsgi configuration just like we did in [Chapter 9](2c6bf064-57ff-41bc-89d0-21fac1308186.xhtml),
    *Deploying Answerly*. The mod_wsgi configuration isn't the focus of this chapter,
    so refer to [Chap](2c6bf064-57ff-41bc-89d0-21fac1308186.xhtml)ter 9, *Deploying
    Answerly*, for details of how this configuration works.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a virtual host configuration file for Mail Ape in `apache/mailape.apache.conf`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: As we discussed in [Chapter 9](2c6bf064-57ff-41bc-89d0-21fac1308186.xhtml),
    *Deploying Answerly*, there isn't a way to pass environment variables to our mod_wsgi
    Python processes, so we will need to update our project's `wsgi.py` just like
    we did in [Chapter 9](2c6bf064-57ff-41bc-89d0-21fac1308186.xhtml), *Deploying
    Answerly*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s our new `django/config/wsgi.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We discussed the preceding script in Chapter 9, *Deploying Answerly*. The only
    difference here is the file we parse, that is, `/etc/mailape/mailape.ini`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will need to add our virtual host configuration to the Apache `sites-enabled`
    directory. Let''s create a script to do that in `scripts/configure_apache.sh`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have a script to configure Apache in a production environment, let's
    configure our Celery workers to start.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Celery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have Apache running Mail Ape, we will need to configure Celery to
    start and process our SQS queue. To start our Celery workers, we will use Ubuntu's
    systemd process management facility.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s create a Celery service file to tell SystemD how to start Celery.
    We''ll create the service file in `ubuntu/celery.service`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a closer look at some of the options in this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '`After=network.target`: This means that SystemD should not start this until
    our server has connected to a network.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Type=forking`: This means that the `ExecStart` command will eventually start
    a new process that continues to run under its own process ID (PID).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`User`: This indicates the user that will own the Celery processes. In our
    case, we''re just going to reuse Apache''s `www-data` user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EnvironmentFile`: This lists a file that will be read for environment variables
    and values that will be set for all the `Exec` commands. We list one with our
    Celery configuration (`/mailape/ubuntu/celery.systemd.conf`) and one with our
    Mail Ape configuration (`/etc/mailape/celery.env`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ExecStart`: This is the command that will be executed to start Celery. In
    our case, we start multiple Celery workers. All our Celery commands will operate
    on our workers based on the process ID files they create. Celery will replace
    `%n` with the worker''s ID.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ExecStop`: This is the command that will be executed to stop our Celery workers,
    based on their PID files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ExecReload`: This is the command that will be executed to restart our Celery
    workers. Celery supports a `restart` command, so we will use that to perform the
    restart. However, this command must receive the same options as our `ExecStart`
    command.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We''ll be placing our PID files in `/var/run/celery`, but we will need to make
    sure that the directory is created. `/var/run` is a special directory, which doesn''t
    use a regular filesystem. We''ll need to create a configuration file to tell Ubuntu
    to create `/var/run/celery`. Let''s create this file in `ubuntu/tmpfiles-celery.conf`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This tells Ubuntu to create a directory, `/run/celery`, owned by the Apache
    user (`www-data`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s create a script to put all these files in the right places
    on our server. We''ll name this script `scripts/configure_celery.sh`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Now that Celery and Apache are configured, let's make sure that they have the
    correct environment configuration to run Mail Ape
  prefs: []
  type: TYPE_NORMAL
- en: Creating the environment configuration files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Both our Celery and mod_wsgi Python processes will need to pull configuration
    information out of the environment to connect to the right database, SQS Queue,
    and many other services. These are settings and values we don''t want to check
    into our version control system (for example, passwords). However, we still need
    them to be set in a production environment. To create the files that define the
    environment that our processes will run in, we''ll make the script in `scripts/make_mailape_environment_ini.sh`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Our `make_mailape_environment_ini.sh` script has some values hardcoded but references
    others (for example, passwords) as environment variables. We'll pass the values
    for these variables into Packer at runtime. Packer will then pass these values
    to our script.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's make our Packer template to build our AMI.
  prefs: []
  type: TYPE_NORMAL
- en: Making a Packer template
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Packer creates an AMI based on the instructions listed in a Packer template
    file. A Packer template is a JSON file made up of three top-level keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '`variables`: This will let us set values (such as passwords) at runtime'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`builders`: This specifies the cloud platform-specific details, such as AWS
    credentials'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`provisioners`: This are the instructions Packer will execute to make our image'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s create our Packer template in `packer/web_worker.json`, starting with
    the `variables` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Under the `variables` key, we will list all the variables we want our template
    to take as the keys of JSON object. If the variable has a default value, then
    we can provide it as the value for that variable's key.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s add a `builders section` to configure Packer to use AWS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'A `builders` is an array because we could use the same template to build a
    machine image on multiple platforms (for example, AWS and Google Cloud). Let''s
    take a look at each option in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '`"type": "amazon-ebs"`: Tells Packer we''re creating an Amazon Machine Image
    with Elastic Block Storage. This is the preferred configuration due to the flexibility
    it offers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"access_key": "{{user aws_access_key }}"`: This is the access key Packer should
    use to authenticate itself with AWS. Packer includes its own template language
    so that values can be generated at runtime. Any value between `{{ }}` is generated
    by the Packer template engine. The template engine offers a `user` function, which
    takes the name of the user-provided variable and returns its value. For example,
    `{{user aws_access_key }}` will be replaced by the value the user provided to
    `aws_access_key` when running Packer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"secret_key": "{{user aws_secret_key }}"`: This is the same for the AWS Secret
    Key.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"region": "us-west-2"`: This specifies the AWS region. All our work will be
    done in `us-west-2`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"source_ami": "ami-78b82400"`: This is the image that we''re going to customize
    to make our image. In our case, we''re using an official Ubuntu AMI. Ubuntu offers
    an EC2 AMI locator ([http://cloud-images.ubuntu.com/locator/ec2/](http://cloud-images.ubuntu.com/locator/ec2/))
    to help find their office AMIs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"instance_type": "t2.micro"`: This is a small inexpensive instance that, at
    the time of writing this book, falls under the AWS free tier.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"ssh_username": "ubuntu"`: Packer performs all its operations on the virtual
    machine over SSH. This is the username it should use for authentication. Packer
    will generate its own key pair for authentication, so we don''t have to worry
    about specifying a password or key.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"ami_name": "mailape-{{timestamp}}"`: The name of the resulting AMI. `{{timestamp}}`
    is a function that returns the UTC time in seconds since the Unix epoch.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"tags": {...}`: Tagging resources makes it easier to identify resources in
    AWS. This is optional but recommended.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we've specified our AWS builder, we will need to specify our provisioners.
  prefs: []
  type: TYPE_NORMAL
- en: 'Packer provisioners are the instructions that customize the server. In our
    case, we will use the following two types of provisioners:'
  prefs: []
  type: TYPE_NORMAL
- en: '`file` provisioners to upload our code to the server'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`shell` provisioners to execute our scripts and commands'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'First, let''s add our `make_aws_directories.sh` script, as we''ll need it to
    run first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: A `shell` provisioner with a `script` property will upload, execute, and remove
    the script. Packer provides the `{{template_dir}}` function, which returns the
    directory of template directory. This lets us avoid hardcoding absolute paths.
    The first provisioner we execute will execute the `make_aws_directories.sh` script
    we created earlier in this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that our directories exist, let''s copy our code and files over using `file`
    provisioners:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '`file` provisioners upload local files or directories defined by `source` to
    the server at `destination`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we uploaded our Python code from our working directory, we need to be
    careful of old `.pyc` files hanging around. Let''s make sure that we delete those
    on our production server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: A `shell` provisioner can receive an `inline` attribute. The provisioner will
    then execute the `inline` command on the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s execute the rest of the scripts we created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the `shell` provisioner has received `scripts` and `environment_vars`.
    `scripts` is an array of paths to shell scripts. Each item in the array will be
    uploaded and executed. When executing each script, this `shell` provisioner will
    add the environment variables listed in `environment_vars`. The `environment_vars` parameter is
    optionally available to all `shell` provisioners to provide extra environment
    variables.
  prefs: []
  type: TYPE_NORMAL
- en: With our final provisioner added to our file, we've now finished our Packer
    template. Let's use Packer to execute the template and build our Mail Ape production
    server.
  prefs: []
  type: TYPE_NORMAL
- en: Running Packer to build an Amazon Machine Image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With Packer installed and a Mail Ape production server Packer template created,
    we're ready to build our **Amazon Machine Image** (**AMI**).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run Packer to build our AMI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Packer will output the AMI ID of our new AMI image. We'll be able to use this
    AMI to launch an EC2 instance in the AWS Cloud.
  prefs: []
  type: TYPE_NORMAL
- en: If your template fails due to a missing Ubuntu package, retry the build. At
    the time of writing this book, the Ubuntu package repositories do not always update
    successfully.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our AMI, we can deploy it.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying a scalable self-healing web app on AWS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have our infrastructure and a deployable AMI, we can deploy Mail
    Ape on AWS. Rather than launching a single EC2 instance from our AMI, we will
    deploy our app using CloudFormation. We''ll define a set of resources that will
    let us scale our app up and down as needed. We''ll define the following three
    resources:'
  prefs: []
  type: TYPE_NORMAL
- en: An Elastic Load Balancer to distribute requests among our EC2 instances
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An AutoScaling Group to launch and terminate EC2 instances
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A LaunchConfig to describe what kind of EC2 instances to launch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First, let's make sure that we have an SSH key if we need to access any of our
    EC2 instances to troubleshoot any problems after we deploy.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an SSH key pair
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create an SSH key pair in AWS, we can use the following AWS command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Ensure that you copy the `KeyMaterial` value to your SSH client's configuration
    directory (typically, `~/.ssh`)—remember to replace `\n` with actual new lines.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's start our Mail Ape deployment CloudFormation template.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the web servers CloudFormation template
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next, let''s create a CloudFormation template to deploy Mail Ape servers to
    the cloud. We''ll use CloudFormation to tell AWS how to scale our servers and
    relaunch them, should a disaster strike. We''ll tell CloudFormation to create
    the following three resources:'
  prefs: []
  type: TYPE_NORMAL
- en: An **Elastic Load Balancer** (**ELB**), which will be able to distribute requests
    among our servers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A LaunchConfig, which will describe the AMI, instance type, and other details
    of the EC2 instances we want to use.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An AutoScaling Group, which will monitor to ensure that we have the right number
    of healthy EC2 instances.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These three resources are the core of building any kind of scaling self-healing
    AWS application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start building our CloudFormation template in `cloudformation/web_worker.yaml`.
    Our new template will have the same three sections as `cloudformation/infrastracture.yaml`:
    `Parameters`, `Resources`, and `Outputs`.'
  prefs: []
  type: TYPE_NORMAL
- en: Lets's start by adding the `Parameters` section.
  prefs: []
  type: TYPE_NORMAL
- en: Accepting parameters in the web worker CloudFormation template
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our web worker CloudFormation template will accept the AMI to launch and the
    InstanceProfile to be used as parameters. This means that we won't have to hardcode
    the names of the resources we created with Packer and our infrastructure stack,
    respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create our template in `cloudformation/web_worker.yaml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have the AMI and the InstanceProfile for our EC2 instances, let's
    create our CloudFormation stack's resources.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Resources in our web worker CloudFormation template
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Next, we'll definite the **Elastic Load Balancer** (**ELB**), Launch Config,
    and AutoScaling Group. These three resources are the core of most scalable AWS
    web applications. We'll take a look at how they interact as we build up our template.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s add our Load Balancer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we're adding a new resource called `LoadBalancer` of
    the `AWS::ElasticLoadBalancing::LoadBalancer`  type. An ELB needs a name (`MailApeLB`)
    and a list of `Listeners`. Each `Listeners` entry should define the port our ELB
    is listening on (`LoadBalancerPort`, the instance port the request will be forwarded
    to (`InstancePort`), and the protocol the port will use (in our case, `HTTP`).
  prefs: []
  type: TYPE_NORMAL
- en: An ELB will be responsible for distributing HTTP requests across however many
    EC2 instances we launch to handle our load.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we''ll create a LaunchConfig to tell AWS how to launch a new Mail Ape
    web worker:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'A Launch Config is of the `AWS::AutoScaling::LaunchConfiguration` type and
    describes the configuration of a new EC2 instance that an Auto Scaling Group should
    launch. Let''s go through all the `Properties` to ensure that we understand what
    they mean:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ImageId`: This is the ID of the AMI we want the instances to run. In our case,
    we''re using the `Ref` function to get the AMI ID from the `WorkerAMI` parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`KeyName`: This is the name of the SSH key that will be added to this machine.
    This is useful if we ever need to troubleshoot something live. In our case, we''re
    using the name of the SSH key pair we created earlier in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SecurityGroups`: This is a list of Security Group names that define what ports
    AWS is to open. In our case, we''re listing the names of the web and SSH groups
    we created in our infrastructure stack.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`InstanceType`: This indicates the instance type of our EC2 instances. An instance
    type defines the computing and memory resources available to our EC2 instance.
    In our case, we''re using a very small affordable instance that is (at the time
    of writing this book) covered by the AWS Free Tier during the first year.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IamInstanceProfile`: This indicates the `InstanceProfile` for our EC2 instances.
    Here, we''re using the `Ref` function to reference the `InstanceProfile` parameter.
    When we create our stack, we''ll use the ARN of the InstanceProfile we created
    earlier that gives our EC2 instances access to SQS.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, we''ll define the AutoScaling Group that launches the EC2 instances that
    the Launch Config describes to serve requests forwarded by the ELB:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Our new **Auto Scaling Group** (**ASG**) is of the `AWS::AutoScaling::AutoScalingGroup`
     type. Let''s go through its properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`LaunchConfigurationName`: This is the name of the `LaunchConfiguration` this
    ASG should use when launching new instances. In our case, we use the `Ref` function
    to reference `LaunchConfig`, the Launch Configuration we created above.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MinSize`/`MaxSize`: These are the attributes required that set the maximum
    and minimum number of instances this group may contain. These values protect us
    from accidentally deploying too many instances that may negatively affect either
    our system or our monthly bill. In our case, we make sure that there is at least
    one (`1`) instance but no more than three (`3`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DesiredCapacity`: This tells our system how many ASG and how many healthy
    EC2 instances should be running this ASG. If an instance fails and brings the
    number of healthy instances below the `DesiredCapacity` value, then ASG will use
    its Launch Configuration to launch more instances.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LoadBalancerNames`: This is a list of ELBs that can route requests to the
    instances launched by this ASG. When a new EC2 instance becomes a part of this
    ASG, it will also be added to the list of instances the named ELBs route requests
    to. In our case, we use the `Ref` function to reference the ELB we defined earlier
    in this template.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These three tools work together to help us make our Django app scale quickly
    and smoothly. The ASG gives us a way of saying how many Mail Ape EC2 instances
    we want running. The Launch Config describes how to launch a new Mail Ape EC2
    instance. The ELB will then distribute the requests to all the instances that
    the ASG launched.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our resources, let's output some of the most relevant data
    to make the rest of our deployment easy.
  prefs: []
  type: TYPE_NORMAL
- en: Outputting resource names
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The final section we'll add to our CloudFormation template is `Outputs` to make
    it easier to note the address of our ELB and the name of our ASG. We'll need the
    address of our ELB to add a CNAME record to `mailape.example.com`. We'll need
    the name of our ASG if we need to access our instances (for example, to run our
    migrations).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s update `cloudformation/web_worker.yaml` with an `Outputs` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The value of `LoadBalancerDNS` will be the DNS name of the ELB we created above.
    The value of `AutoScalingGroupName` will be our ASG, which returns the name of
    the ASG.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's create a stack for our Mail Ape 1.0 release.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Mail Ape 1.0 release stack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have our Mail Ape web worker CloudFormation template, we can create
    a CloudFormation stack. When we create the stack, the stack will create its related
    resources such as the ELB, ASG, and Launch Config. We''ll use the AWS CLI to create
    our stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command looks very similar to the one we executed to create our
    infrastructure stack, but there are a couple of differences:'
  prefs: []
  type: TYPE_NORMAL
- en: '`--stack-name`: This is the name of the stack we''re creating.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--template-body "file:///path/..."`: This is a `file://` URL with an absolute
    path to our CloudFormation template. Since the path prefix ends with two `/` and
    a Unix path starts with a `/`, we get a weird looking triple `/` here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--parameters`: This template takes two parameters. We can provide them in
    any order, but we must provide both.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"ParameterKey=WorkerAMI, ParameterValue=`: For `WorkerAMI`, we must provide
    the AMI ID that Packer gave us.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"ParameterKey=InstanceProfile,ParameterValue`: For InstanceProfile, we must
    provide the Instance Profile ARN that our infrastructure stack output.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--region us-west-2`: We''re doing all our work in the `us-west-2` region.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To take a look at our stack''s outputs, we can use the `describe-stack` command
    from the AWS CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is a large JSON object; here is a slightly truncated example version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Our resources (for example, EC2 instances) won't be ready until `StackStatus`
    is `CREATE_COMPLETE`. It can take a few minutes to create all the relevant resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re particularly interested in the objects in the `Outputs` array:'
  prefs: []
  type: TYPE_NORMAL
- en: The first value gives us the name of our ASG. With the name of our ASG, we'll
    be able to find the EC2 instances in that ASG in case we need to SSH into one.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second value gives us the DNS name of our ELB. We'll use our ELB's DNS to
    create CNAME record for our production DNS record so that we redirect our traffic
    here (for example, creating a CNAME record for `mailape.example.com` to redirect
    traffic to our ELB).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's look at how to SSH into the EC2 instances that our ASG launched.
  prefs: []
  type: TYPE_NORMAL
- en: SSHing into a Mail Ape EC2 Instance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The AWS CLI gives us many ways of getting information about our EC2 Instances.
    Let''s find the address of our launched EC2 instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The `aws ec2 describe-instances` command will return a lot of information about
    all our EC2 instances. We can use the `--filters` command to restrict the EC2
    instances returned. When we create a stack, many of the related resources are
    tagged with the stack name. This lets us filter for only those EC2 instances in
    our `mail_ape_1_0` stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a (much) shortened version of the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding output, note the `PublicDnsName` and the `KeyName`. Since
    we created that key earlier in this chapter, we can SSH into this instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Remember that the `XXX` you see in the preceding output will be replaced by
    real values in your system.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we can SSH into the system, we can create and migrate our database.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and migrating our database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For our first release we first need to create our database. To create our database
    we''re going to create a script in `database/make_database.sh`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'This script uses three variables from its environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$USER`: The Postgres master user username. We defined this as `master` in
    our `cloudformation/infrastructure.yaml`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$PASSWORD`: The Postgres master user''s password. We provided this as a parameter
    for when we created the `infrastructure` stack.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$DJANGO_DB_PASSWORD`: This is the password for the Django database. We provided
    this as a parameter to Packer when creating our AMI.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, we''ll execute this script locally by providing the values as variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Our Mail Ape database is now created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s SSH into our new EC2 instance and run our database migrations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Our `manage.py migrate` command is very similar to what we've used in previous
    chapters. The main difference here is that we needed to SSH into our production
    EC2 instance first.
  prefs: []
  type: TYPE_NORMAL
- en: When `migrate` returns success, our database is ready and we're good to release
    our app.
  prefs: []
  type: TYPE_NORMAL
- en: Releasing Mail Ape 1.0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we've migrated our database, we're ready to update the DNS records
    of `mailape.example.com` to point to our ELB's DNS records. Once the DNS records
    propagate, Mail Ape will be live.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations!
  prefs: []
  type: TYPE_NORMAL
- en: Scaling up and down with update-stack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the great things about using CloudFormation and Auto Scaling Groups is
    that it's easy to scale our system up and down. In this section, let's update
    our system to use two EC2 instances running Mail Ape.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can update our CloudFormation template in `cloudformation/web_worker.yaml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve updated our `DesiredCapacity` from 1 to 2\. Now, instead of creating
    a new stack, let''s update our existing stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command looks much like our `create-stack` command. One convenient
    difference is that we don't need to provide the parameter values again—we can
    simply inform `UsePreviousValue=true` to tell AWS to reuse the same values as
    before.
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, `describe-stack` will tell us when our update is complete:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is a large JSON object—here is a truncated example version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Once our `StackStatus` is `UPDATE_COMPLETE`, our ASG will be updated with a
    new setting. It can take a couple minutes for the ASG to launch the new EC2 instance,
    but we can use our previously created `describe-instances` command to look for
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Eventually, it will return two instances. Here''s a highly truncated version
    of what that output will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: To scale down to one instance, just update your `web_worker.yaml` template and
    run `update-stack` again.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You now know how to scale Mail Ape up to handle a higher load
    and then scale back down during off peak periods.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that Amazon charges are based on usage. If you scaled up as part of
    working through this book, remember to scale back down or you may be charged more
    than you expect. Ensure that you read up on the limits of the AWS free tier on
    [https://aws.amazon.com/free/](https://aws.amazon.com/free/).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we've taken our Mail Ape app and launched it into a production
    environment in the AWS Cloud. We've used AWS CloudFormation to declare our AWS
    resources as code, making it as easy to track what we need and what changed as
    in the rest of our code base. We've built the image of our Mail Ape servers run
    using Packer, again giving us the ability to track our server configuration as
    code. Finally, we launched Mail Ape into the cloud and learned how to scale it
    up and down.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've come to the end of our journey learning to build Django web applications,
    let's review some of what we've learned. Over three projects we've seen how Django
    organizes code into models, views, and templates. We've learned how to do input
    validation with Django's form class and with Django Rest Framework's Serializer
    classes. We've examined security best practices, caching, and how to send emails.
    We've seen how to take our code and deploy into Linux servers, Docker containers,
    and the AWS Cloud.
  prefs: []
  type: TYPE_NORMAL
- en: You're ready to take your idea and launch it with Django! Go for it!
  prefs: []
  type: TYPE_NORMAL
