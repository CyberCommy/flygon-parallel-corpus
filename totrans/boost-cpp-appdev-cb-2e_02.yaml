- en: Managing Resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Managing local pointers to classes that do not leave scope
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reference counting of pointers to classes used across functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing local pointers to arrays that do not leave scope
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reference counting of pointers to arrays used across functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing any functional objects in a variable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing function pointer in a variable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing C++11 lambda functions in a variable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Containers of pointers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do it at scope exit!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initializing the base class by the member of the derived class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we'll continue to deal with datatypes, introduced by the Boost
    libraries, mostly focusing on working with the pointers. We'll see how to easily
    manage resources, how to use a datatype capable of storing any functional objects,
    functions, and lambda expressions. After reading this chapter, your code will
    become more reliable and memory leaks will become history.
  prefs: []
  type: TYPE_NORMAL
- en: Managing local pointers to classes that do not leave scope
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, we are required to dynamically allocate memory and construct a class
    in that memory. That''s where the troubles start. Take a look at the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This code looks correct at first glance. But, what if `some_function1()` or
    `some_function2()` throws an exception? In that case, `p` won''t be deleted. Let''s
    fix it in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now the code is correct, but ugly and hard to read. Can we do better than this?
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Basic knowledge of C++ and code behavior during exceptions is required.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Just take a look at the `Boost.SmartPtr` library. There is a `boost::scoped_ptr`
    class that may help you out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now, there is no chance that the resource will leak and the source code is much
    clearer.
  prefs: []
  type: TYPE_NORMAL
- en: If you have control over `some_function2(foo_class*)`, you may wish to rewrite
    it to take a reference to `foo_class` instead of a pointer. An interface with
    references is more intuitive than an interface with pointers unless you have a
    special agreement in your company that output parameters are taken only by pointer.
  prefs: []
  type: TYPE_NORMAL
- en: 'By the way, `Boost.Move` also has a `boost::movelib::unique_ptr` that you may
    use instead of `boost::scoped_ptr`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`boost::scoped_ptr<T>` and `boost::movelib::unique_ptr` are typical **RAII**
    classes. When an exception is thrown or a variable goes out of scope, the stack
    is unwound and the destructor is called. In the destructor, `scoped_ptr<T>` and
    `unique_ptr<T>` call `delete` for a pointer that they store. Because both of these
    classes by default call `delete`, it is safe to hold a `derived` class by a pointer
    to the `base` class if destructor of the base class is virtual:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the `base_and_derived()` function will produce the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In C++, destructors for objects are called in the reverse construction order.
    That's why the destructor of `scoped_ptr` was called before the destructor of
    `unique_ptr`.
  prefs: []
  type: TYPE_NORMAL
- en: The `boost::scoped_ptr<T>` class template is neither copyable nor movable. The
    `boost::movelib::unique_ptr` class is a move-only class, and it uses move emulation
    on pre-C++11 compilers. Both classes store a pointer to the resource they own
    and do not require `T` to be a complete type (`T` can be forward declared).
  prefs: []
  type: TYPE_NORMAL
- en: 'Some compilers do not warn when an incomplete type is deleted, which may lead
    to errors that are hard to detect. Fortunately, that''s not the case for Boost
    classes that have specific compile-time asserts for such cases. That makes `scoped_ptr`
    and `unique_ptr` perfect for implementing the **Pimpl** idiom:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Those classes are extremely fast. Compiler optimizes the code that uses `scoped_ptr`
    and `unique_ptr` to the machine code, which involve no additional overhead compared
    to the handwritten manual memory management code.
  prefs: []
  type: TYPE_NORMAL
- en: C++11 has a `std::unique_ptr<T, D>` class that uniquely owns the resource and
    behaves exactly like `boost::movelib::unique_ptr<T, D>`.
  prefs: []
  type: TYPE_NORMAL
- en: The C++ standard library has no `boost::scoped_ptr<T>`, but you could use `const
    std::unique_ptr<T>` instead. The only difference is that `boost::scoped_ptr<T>`
    still can call `reset()` unlike `const std::unique_ptr<T>`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The documentation of the `Boost.SmartPtr` library contains lots of examples
    and other useful information about all the smart pointers' classes. You can read
    about them at [http://boost.org/libs/smart_ptr.](http://boost.org/libs/smart_ptr)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Boost.Move` docs may help you out if you use move emulation with `boost::movelib::unique_ptr`
    [http://boost.org/libs/move.](http://boost.org/libs/move)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reference counting of pointers to classes used across functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Imagine that you have some dynamically allocated structure containing data,
    and you want to process it in different threads of execution. The code to do this
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We cannot deallocate `p` at the end of the `while` loop because it still can
    be used by threads that run `process` functions. These `process` functions cannot
    delete `p`, because they do not know that other threads are not using it anymore.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe uses the `Boost.Thread` library, which is not a header-only library.
    Your program has to link against the `boost_thread`, `boost_chrono`, and `boost_system`
    libraries. Make sure that you do understand the concept of threads before reading
    further. Refer to the *See also* section for references on recipes that describe
    threads.
  prefs: []
  type: TYPE_NORMAL
- en: You also need some basic knowledge on `boost::bind` or `std::bind`, which are
    almost the same.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As you may have guessed, there is a class in Boost (and C++11) that may help
    you to deal with the problem. It is called `boost::shared_ptr`. It can be used
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Another example of this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `shared_ptr` class has an atomic reference counter inside. When you copy
    it, the reference counter is incremented, and when its `destructor` is called,
    the reference counter is decremented. When the count of references equals to zero,
    `delete` is called for the object pointed by `shred_ptr`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's find out what's happening in the case of `boost::thread (boost::bind(&process_sp1,
    p))`. The function `process_sp1` takes a parameter as a reference, so why is it
    not deallocated when we do get out of the `while` loop? The answer is simple.
    The functional object returned by `bind()` contains a copy of the `shared` pointer,
    and that means the data pointed by `p` won't be deallocated until the functional
    object is destroyed. The functional object is copied into the thread and is kept
    alive until the threads executes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Getting back to `boost::make_shared`, let''s take a look at `shared_ptr<std::string>
    ps(new int(0))`. In this case, we have two calls to `new`:'
  prefs: []
  type: TYPE_NORMAL
- en: While constructing a pointer to an integer via `new int(0)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While constructing a `shared_ptr` class internal reference counter that is allocated
    on the heap
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `make_shared<T>` to have only one call to `new`. A `make_shared<T>` allocates
    a single chunk of memory and constructs an atomic counter and the `T` object in
    that chunk.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The atomic reference counter guarantees correct behavior of `shared_ptr` across
    the threads, but you must remember that atomic operations are not as fast as non-atomic.
    `shared_ptr` touches the atomic variable on assignments, copy constructions, and
    on destruction of a non moved away `shared_ptr`. It means that on C++11 compatible
    compilers, you may reduce atomic operation''s count using move constructions and
    move assignments where possible. Just use `shared_ptr<T> p1(std::move(p))` if
    you are not going to use the `p` variable any more. If you are not going to modify
    the pointed value, it is recommended to make it `const`. Just add `const` to the
    template parameter of the smart pointer, and the compiler will make sure that
    you do not modify memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Confused with `const`? Here''s a mapping of smart pointer constness to simple
    pointer constness:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `shared_ptr<T>` | `T*`  |'
  prefs: []
  type: TYPE_TB
- en: '| `shared_ptr<const T>` | `const T*`  |'
  prefs: []
  type: TYPE_TB
- en: '| `const shared_ptr<T>` | `T* const` |'
  prefs: []
  type: TYPE_TB
- en: '| `const shared_ptr<const T>` | `const T* const` |'
  prefs: []
  type: TYPE_TB
- en: The `shared_ptr` calls and the `make_shared` function are a part of C++11, and
    they are declared in the header `<memory>` in the `std::` namespace. They have
    almost the same characteristics as Boost versions.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Refer to [Chapter 5](part0262.html#7PRJC0-712b4ba1126a4c7c89e1d44de61b4bdd)*,*
    *Multithreading,* for more information about `Boost.Thread` and atomic operations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refer to the *Binding and reordering function parameters* recipe in [Chapter
    1](part0029.html#RL0A0-712b4ba1126a4c7c89e1d44de61b4bdd), *Starting to Write Your
    Application*, for more information about `Boost.Bind`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refer to the [Chapter 3](part0169.html#515F20-712b4ba1126a4c7c89e1d44de61b4bdd),
    recipe *Converting smart pointers* for some information on how to convert `shared_ptr<U>`
    to `shared_ptr<T>`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The documentation of the `Boost.SmartPtr` library contains lots of examples
    and other useful information about all the smart pointer's classes. Refer to the
    link [http://boost.org/libs/smart_ptr](http://boost.org/libs/smart_ptr) to read
    about them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing pointers to arrays that do not leave scope
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We already saw how to manage pointers to a resource in the *Managing pointers
    to classes that do not leave scope* recipe. But, when we deal with arrays, we
    need to call `delete[]` instead of a simple `delete`. Otherwise, there will be
    a memory leak. Take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The knowledge of C++ exceptions and templates are required for this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Boost.SmartPointer` library has not only the `scoped_ptr<>` class, but
    also a `scoped_array<>` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Boost.Move` library''s `boost::movelib::unique_ptr<>` class can work with
    arrays too. You just need to indicate that it is storing an array by providing
    `[]` at the end of the template parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`scoped_array<>` works exactly like a `scoped_ptr<>` class, but calls `delete[]`
    in the destructor instead of `delete`. The `unique_ptr<T[]>` does the same thing.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `scoped_array<>` class has same guarantees and design as `scoped_ptr<>`.
    It has neither additional memory allocations nor virtual function's call. It cannot
    be copied and also is not a part of C++11\. `std::unique_ptr<T[]>` is part of
    the C++11 and has the same guarantees and performance as the `boost::movelib::unique_ptr<T[]>`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: Actually, `make_unique<char[]>(1024)` is not the same as `new char[1024]`, because
    the first one does value initialization and the second one does the default initialization.
    The equivalent function for default-initialization is `boost::movelib::make_unique_definit`.
  prefs: []
  type: TYPE_NORMAL
- en: Note that Boost version could also work on pre-C++11 compilers and even emulates
    rvalues on them, making `boost::movelib::unique_ptr` a move only type. If your
    standard library does not provide `std::make_unique` then `Boost.SmartPtr` may
    help you out. It provides `boost::make_unique` that returns a `std::unique_ptr`
    in header `boost/smart_ptr/make_unique.hpp`. It also provides `boost::make_unique_noinit`
    for default-initialization in the same header. C++17 does not have a `make_unique_noinit`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Using `new` for memory allocation and manual memory management in C++ is a bad
    habit. Use `make_unique` and `make_shared` functions wherever possible.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The documentation of the `Boost.SmartPtr` library contains lots of examples
    and other useful information about all the smart pointer's classes, you can read
    about them at [http://boost.org/libs/smart_ptr.](http://boost.org/libs/smart_ptr)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: "The `Boost.Move` docs may help you out if you wish to use move emulation with\
    \ `boost::movelib::unique_ptr`, read about them at [http://boost.org/libs/move.](http://boost.org/libs/move)\
    \ [\uFEFF](http://boost.org/libs/move)"
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reference counting of pointers to arrays used across functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We continue coping with pointers, and our next task is to reference count an
    array. Let''s take a look at the program that gets some data from the stream and
    processes it in different threads. The code to do this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Just the same problem that occurred in the *Reference counting of pointers to
    classes used across functions* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe uses the `Boost.Thread` library, which is not a header-only library,
    so your program will need to link against the `boost_thread`, `boost_chrono`,
    and `boost_system` libraries. Make sure that you do understand the concept of
    threads before reading further.
  prefs: []
  type: TYPE_NORMAL
- en: You'll also need some basic knowledge on `boost::bind` or `std::bind`, which
    is almost the same.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are four solutions. The main difference between them is of type and construction
    of the `data_cpy` variable. All those solutions do exactly the same things that
    are described in the beginning of this recipe, but without memory leaks. The solutions
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first solution works well for cases when array size is known at compile
    time:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Since Boost 1.53, `shared_ptr` itself can take care of arrays of unknown bound.
    The second solution:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The third solution:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The last solution is deprecated since Boost 1.65, but may be of use in case
    of antique Boost versions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In all examples, **smart pointer** classes count references and call `delete[]`
    for a pointer when the count of references becomes equal to zero. The first and
    second examples are simple. In the third example, we provide a custom `deleter`
    object for a `shared` pointer. The `deleter` object of a smart pointer is called
    when the smart pointer decides to free resources. When smart pointer is constructed
    without explicit `deleter`, the default `deleter` is constructed that calls `delete`
    or `delete[]` depending on the template type of the smart pointer.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The fourth solution is the most conservative, because prior to Boost 1.53 the
    functionality of the second solution was not implemented in `shared_ptr`. The
    first and second solutions are the fastest ones as they use only one memory allocation
    call. The third solution can be used with older versions of Boost and with C++11
    standard library's `std::shared_ptr<>` (just don't forget to change `boost::checked_array_deleter<T>()`
    to `std::default_delete<T[]>()`).
  prefs: []
  type: TYPE_NORMAL
- en: Actually, `boost::make_shared<char[]>(size)` is not the same as `new char[size]`,
    because it involves value-initialization of all elements. The equivalent function
    for default-initialization is `boost::make_shared_noinit`.
  prefs: []
  type: TYPE_NORMAL
- en: Beware! C++11 and C++14 versions of `std::shared_ptr` cannot work with arrays!
    Only since C++17 `std::shared_ptr<T[]>` must work properly. If you are planning
    to write portable code, consider using `boost::shared_ptr`, `boost::shared_array`,
    or explicitly pass a `deleter` to `std::shared_ptr`.
  prefs: []
  type: TYPE_NORMAL
- en: '`boost::shared_ptr<T[]>`, `boost::shared_array`, and C++17 `std::shared_ptr<T[]>`
    have `operator[](std::size_t index)` that allows you to access elements of shared
    array by index. `boost::shared_ptr<T>` and `std::shared_ptr<T>` with custom `deleter`
    have no `operator[]`, which makes them less useful.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The documentation of the `Boost.SmartPtr` library contains lots of examples
    and other useful information about all the smart pointers classes. You can read
    about it at [http://boost.org/libs/smart_ptr](http://boost.org/libs/smart_ptr).
  prefs: []
  type: TYPE_NORMAL
- en: Storing any functional objects in a variable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Consider the situation when you are developing a library that has its API declared
    in the header files and implementation in the source files. This library shall
    have a function that accepts any functional objects. Take a look at the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: How do you change the `process_integers` function to accept any functional objects?
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reading the *Storing any value in container/variable* recipe in [Chapter 1](part0029.html#RL0A0-712b4ba1126a4c7c89e1d44de61b4bdd),
    *Starting to Write Your Application*, is recommended before starting off with
    this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is a solution and it is called a `Boost.Function` library. It allows
    you to store any function, a member function, or a functional object if its signature
    is a match to the one described in the template argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `fobject_t` object stores in itself functional objects and erases their
    exact type. It is safe to use the `boost::function` for stateful objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Does `boost::function` recall the `boost::any` class? That's because it uses
    the same technique **type erasure** for storing any function objects.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `boost::function` class has a default constructor and has an empty state.
    Checking for an empty/default constructed state can be done like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `Boost.Function` library has an insane amount of optimizations. It may store
    small functional objects without additional memory allocations and has optimized
    move assignment operators. It is accepted as a part of C++11 standard library
    and is defined in the `<functional>` header in the `std::` namespace.
  prefs: []
  type: TYPE_NORMAL
- en: '`boost::function` uses an RTTI for objects stored inside it. If you disable
    RTTI, the library will continue to work, but will dramatically increase the size
    of a compiled binary.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The official documentation of `Boost.Function` contains more examples, performance
    measures, and class reference documentation. Refer to the link [http://boost.org/libs/function](http://boost.org/libs/function)
    to read about it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Passing function pointer in a variable* recipe.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Passing C++11 lambda functions in a variable* recipe.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing function pointer in a variable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are continuing with the previous example, and now we want to pass a pointer
    to a function in our `process_integers()` method. Shall we add an overload for
    just function pointers, or is there a more elegant way?
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe is continuing the previous one. You must read the previous recipe
    first.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Nothing needs to be done as `boost::function<>` is also constructible from
    the function pointers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A pointer to `my_ints_function` will be stored inside the `boost::function`
    class, and calls to `boost::function` will be forwarded to the stored pointer.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Boost.Function` library provides a good performance for pointers to functions,
    and it will not allocate memory on heap. Standard library `std::function` is also
    effective in storing function pointers. Since Boost 1.58, the `Boost.Function`
    library can store functions and functional objects that have call signature with
    rvalue references:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The official documentation of `Boost.Function` contains more examples, performance
    measures, and class reference documentation. Follow [http://boost.org/libs/function](http://boost.org/libs/function)
    to read about it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Passing C++11 lambda functions in a variable* recipe.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing C++11 lambda functions in a variable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are continuing with the previous example, and now we want to use a lambda
    function with our `process_integers()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe is continuing the series of the previous two. You must read them
    first. You will also need a C++11 compatible compiler or at least a compiler with
    C++11 lambda support.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Nothing needs to be done as `boost::function<>` is also usable with lambda
    functions of any difficulty:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Performance of the lambda function storage in `Boost.Functional` is the same
    as in other cases. While a functional object produced by the lambda expression
    is small enough to fit in an instance of `boost::function`, no dynamic memory
    allocation is performed. Calling an object stored in `boost::function` is close
    to the speed of calling a function by a pointer. Copying `boost::function` allocates
    heap memory only if initial `boost::function` has a stored object that does not
    fit in it without allocation. Moving instances does not allocate and deallocate
    memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember that `boost::function` implies an optimization barrier for the compiler.
    It means that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Is usually better optimized by the compiler than:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This is why you should try to avoid using `Boost.Function` when its usage is
    not really required. In some cases, the C++11 `auto` keyword can be handy instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Additional information about performance and `Boost.Function` can be found on
    the official documentation page at [http://www.boost.org/libs/function](http://www.boost.org/libs/function).
  prefs: []
  type: TYPE_NORMAL
- en: Containers of pointers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are such cases when we need to store pointers in the container. The examples
    are: storing polymorphic data in containers, forcing fast copy of data in containers,
    and strict exception requirements for operations with data in containers. In such
    cases, C++ programmer has the following choices:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Store pointers in containers and take care of their destructions using `delete`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Such an approach is error prone and requires a lot of writing
  prefs: []
  type: TYPE_NORMAL
- en: 'Store C++11 smart pointers in containers:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This solution is a good one, but it cannot be used in C++03, and you still need
    to write a comparator functional object.
  prefs: []
  type: TYPE_NORMAL
- en: C++14 has a `std::make_unique` function for construction of `std::uniue_ptr`s.
    Using it instead of `new` is a good coding style!
  prefs: []
  type: TYPE_NORMAL
- en: 'Use `Boost.SmartPtr` in the container:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This solution is portable, but it adds performance penalties (atomic counter
    requires additional memory, and its increments/decrements are not as fast as non-atomic
    operations) and you still need to write comparators.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Knowledge of standard library containers is required for better understanding
    of this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Boost.PointerContainer` library provides a good and portable solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Boost.PointerContainer` library has classes `ptr_array`, `ptr_vector`,
    `ptr_set`, `ptr_multimap`, and others. Those classes deallocate pointers as required
    and simplify access to data pointed by the pointer (no need for additional dereference
    in `assert(*s.begin() == 0);`).
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we want to clone some data, we need to define a freestanding function
    `T*new_clone(const T& r)` in the namespace of the object to be cloned. Moreover,
    you may use the default `T* new_clone(const T& r)` implementation if you include
    the header file `<boost/ptr_container/clone_allocator.hpp>`, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'C++ standard library has no pointer containers, but you can achieve the same
    functionality using a container of `std::unique_ptr`. By the way, since Boost
    1.58, there is a `boost::movelib::unique_ptr` class that is usable in C++03\.
    You can mix it with containers from the `Boost.Container` library to have C++11
    functionality for storing pointers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Not all the developers know the Boost libraries well. It is more developer-friendly
    to use functions and classes that have C++ standard library alternatives, as the
    developers usually are more aware of the standard library features. So if there's
    no big difference for you, use `Boost.Container` with `boost::movelib::unique_ptr`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The official documentation contains detailed reference for each class, follow
    the link [http://boost.org/libs/ptr_container](http://boost.org/libs/ptr_container)
    to read about it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first four recipes of this chapter give you some examples about smart pointers'
    usage.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiple recipes in [Chapter 9](part0475.html#E4VR60-712b4ba1126a4c7c89e1d44de61b4bdd)*,
    Containers* describe the `Boost.Container` library features. Take a look at that
    chapter for cool, useful, and fast containers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do it at scope exit!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you were dealing with languages, such as Java, C#, or Delphi, you obviously
    were using the `try {} finally{}` construction. Let me briefly describe to you
    what do these language constructions do.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a program leaves the current scope via return or exception, code in the
    `finally` block is executed. This mechanism is used as a replacement for the RAII
    pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Is there a way to do such a thing in C++?
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Basic C++ knowledge is required for this recipe. Knowledge of code behavior
    during thrown exception will be appreciated.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'C++ uses the RAII pattern instead of `try {} finally{}` construction. The `Boost.ScopeExit`
    library was designed to allow user definition of RAII wrappers right in the function
    body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `f` is passed by the value via `BOOST_SCOPE_EXIT(f)`. When the program leaves
    the scope of execution, the code between `BOOST_SCOPE_EXIT(f) {` and `} BOOST_SCOPE_EXIT_END`
    is be executed. If we wish to pass the value by reference, use the `&` symbol
    in the `BOOST_SCOPE_EXIT` macro. If we wish to pass multiple values, just separate
    them by commas.
  prefs: []
  type: TYPE_NORMAL
- en: Passing references to a pointer does not work well on some compilers. The `BOOST_SCOPE_EXIT(&f)`
    macro cannot be compiled there, which is why we do not capture it by reference
    in the example.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To capture this inside a member function, we shall use a special symbol `this_`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Boost.ScopeExit` library allocates no additional memory on heap and does
    not use virtual functions. Use the default syntax and do not define `BOOST_SCOPE_EXIT_CONFIG_USE_LAMBDAS`
    because otherwise scope exit will be implemented using `boost::function`, which
    may allocate additional memory and imply an optimization barrier. You may achieve
    close to the `BOOST_SCOPE_EXIT` results using `boost::movelib::unique_ptr` or
    `std::unique_ptr` by specifying a custom `deleter`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: If you write two or more similar bodies for `BOOST_SCOPE_EXIT`, then it's time
    to think about some refactoring and moving the code to a fully functional RAII
    class.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The official documentation contains more examples and use cases. You can read
    about it at [http://boost.org/libs/scope_exit.](http://boost.org/libs/scope_exit)
  prefs: []
  type: TYPE_NORMAL
- en: Initializing the base class by the member of the derived class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following example. We have some base class that has
    virtual functions and must be initialized with reference to the `std::ostream`
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We also have a derived class that has a `std::ostream` object and implements
    the `do_process()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'This is not a very common case in programming, but when such mistakes happen,
    it is not always simple to get the idea of bypassing it. Some people try to bypass
    it by changing the order of `logger_` and the base type initialization:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: It won't work as per expectations because direct base classes are initialized
    before non-static data members, regardless of the order of the member initializers.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Basic knowledge of C++ is required for this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Boost.Utility` library provides a quick solution for such cases. Solution
    is called the `boost::base_from_member` template. To use it, you need to carry
    out the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Include the `base_from_member.hpp` header:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Derive your class from `boost::base_from_member<T>` where `T` is a type that
    must be initialized before the base (take care about the order of the base classes;
    `boost::base_from_member<T>` must be placed before the class that uses `T`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Correctly, write the constructor as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Direct base classes are initialized before non-static data members and in declaration
    order as they appear in the base-specifier list. If we need to initialize base
    class `B` with *something*, we need to make that *something* a part of a base
    class `A` that is declared before `B`. In other words, `boost::base_from_member`
    is just a simple class that holds its template parameter as a non-static data
    member:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As you may see, `base_from_member` has an integer as a second template argument.
    This is done for cases when we need multiple `base_from_member` classes of the
    same type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The `boost::base_from_member` class neither applies additional dynamic memory
    allocations nor has virtual functions. The current implementation does support
    **perfect forwarding** and **variadic templates** if your compiler supports them.
  prefs: []
  type: TYPE_NORMAL
- en: C++ standard library has no `base_from_member`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Boost.Utility` library contains many helpful classes and functions; documentation
    for getting more information about it is at [http://boost.org/libs/utility](http://boost.org/libs/utility)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Making a noncopyable class* recipe in [Chapter 1](part0029.html#RL0A0-712b4ba1126a4c7c89e1d44de61b4bdd),
    *Starting to Write Your Application*, contains more examples of classes from `Boost.Utility`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also, the *Using C++11 move emulation* recipe in [Chapter 1](part0029.html#RL0A0-712b4ba1126a4c7c89e1d44de61b4bdd),
    *Starting to Write Your Application*, contains more examples of classes from `Boost.Utility`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
