- en: Documenting Your Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Documentation has a bad reputation. It is hard to find the motivation to write
    it, it's a nuisance to maintain, and our exposure to it over the years has convinced
    us that it is one of the driest and dullest methods of knowledge transfer. It
    doesn't have to be this way, though!
  prefs: []
  type: TYPE_NORMAL
- en: 'If we choose to focus entirely on the users, then our documentation can be
    simple and pleasant. To do this, we must first consider who the users of our documentation
    are. What do they want? Every user, whether a GUI end user or a fellow programmer,
    begins the journey of using our software with a task in mind. It''s our duty,
    both within the software and through its documentation, to enable them to perform
    their task with as little pain and confusion as possible. With this in mind, in
    this chapter we''ll explore what it might mean for us to construct such pain-free documentation.
    We''ll specifically be covering the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Aspects of clean documentation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documentation is everywhere
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing for non-technical audiences
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Aspects of clean documentation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The purpose of documentation is to communicate **what a piece of software does**
    and **how to use it**. We can split the characteristics of clean documentation
    into four aspects: a clean piece of documentation communicates the **concept**
    of the software, provides a **specification** of its behaviors, and contains **instructions**
    for how to perform specific actions. And it does all of this with a focus on **usability**.
    By the end of this section, we will hopefully understand the vital importance
    of *the user* in the craft of building *clean* documentation.'
  prefs: []
  type: TYPE_NORMAL
- en: Documentation is something most people don't think about a lot. It's usually
    an afterthought. My task in this chapter is to convince you that it can be, and
    should be, so much more than this. As we step into these *aspects,* forget what
    you know about documentation – start with a fresh canvas and see if you come away
    with revelations of your own.
  prefs: []
  type: TYPE_NORMAL
- en: Concept
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A clean piece of documentation will communicate the underlying *concept* of
    the software. It''ll do this by explaining what the software''s purpose is in
    a way that allows potential users to see how they might make use of it. This can
    be considered the educational part of documentation: setting out the terminology
    and paradigms that will allow the reader to easily comprehend the other parts
    of the documentation and the software it describes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To properly express the concepts of a piece of software, it''s necessary to
    step inside the shoes of your users, seeing things from their perspective and
    communicating with them on their terms:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Determine your audience**: Who are they and what''s their general technical
    proficiency?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Determine their understanding of the problem domain**: How much do they already
    know about this specific software project, API, or code base?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Determine the right the level of abstraction and best analogies**: How can
    you communicate in a way that makes sense to them and integrates well with their
    current knowledge?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Writing good documentation is a process of considering the user and then crafting
    the appropriate abstractions for them. You''ll hopefully notice how incredibly
    similar this is to the process of crafting clean code. There are, in fact, very
    few differences. When building documentation, we are crafting a tool that the
    user can use to accomplish a specific set of tasks. It is our responsibility to
    craft it in such a way that users can easily accomplish their end goals without
    being overwhelmed by the sheer volume and complexity of the software:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/31c38081-6e7f-44bc-80e4-5343f122755d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Consider a project that has taken several weeks to complete. It is a **JavaScript**
    (**JS**) library called `SuperCoolTypeAnimator` that other programmers can use
    to create typeface transitions. It allows them to display to the user a block
    of text that is animated from one typeface to another (for example, from Helvetica
    to Times New Roman). It''s a rather complex code base that calculates these transitions
    manually. The depth of its complexity has meant that you, the programmer, have
    discovered far more about ligatures, serifs, and path interpolation than you ever
    thought possible. After months of being immersed in this increasingly deep problem
    domain, it is understandably challenging for you to share the perspective of a
    user who has not had your level of exposure. Thus the first draft of your documentation
    might start in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '*SuperCoolTypeAnimator is an SVG glyph animation utility that allows the creation
    and frame-by-frame manipulation of transitions between source glyphs and their
    respective target glyphs, calculating appropriate transitional anchors on the
    fly.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s compare that to the following alternative intro:'
  prefs: []
  type: TYPE_NORMAL
- en: '*SuperCoolTypeAnimator is a JS library that allows you to animate small pieces
    of text from one typeface to another typeface with ease.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'As introductions, the latter is far more widely understandable and will allow
    even non-expert users to immediately understand what the library does. The former
    introduction, while informative, may result in current and potential users feeling
    confused or alienated. The entire purpose of the software we build is to abstract
    away complexity, wrapping it up in a neat and simplified way. Belaboring our users
    with complexity should be done with regret and consideration: it is usually the
    *last* resort.'
  prefs: []
  type: TYPE_NORMAL
- en: The *concept* that we are attempting to communicate in our documentation concerns,
    above all, how our software can *help* the user. For them to understand how it
    can help them, we need to describe it in a way that meshes with their current
    understanding.
  prefs: []
  type: TYPE_NORMAL
- en: Another factor highlighted by the two introductions is their usage of special
    terminology (such as *glyph* and *anchor*). The usage of such domain-specific
    terminology is a balancing act. If your users have a good understanding of the
    *typeface/font* problem domain, terms such as *glyph* and *typeface* may be appropriate.
    There is, arguably, a high likelihood that users interested in your library are
    also aware of such concepts. But the use of more nuanced terms such as *transitional
    anchors* may be a step too far. This is likely a term that you have used within
    your abstraction to describe a highly complex area of implementation. It is a
    useful term to you, and perhaps to anyone wishing to make changes to the library,
    but it is perhaps less useful to users of the library. Therefore, it would be
    wise to avoid it in our documentation's introduction.
  prefs: []
  type: TYPE_NORMAL
- en: Specification
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As well as providing a concept for the software, good documentation will also
    provide a *specification*, detailing the specific characteristics and behaviors
    of the interfaces provided by your software. This part of the documentation details
    the contract that the user or programmer can expect to have when using the software.
  prefs: []
  type: TYPE_NORMAL
- en: 'The *specification* should ideally be the simplest part of the documentation
    to write, for the following reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: '**It''s literally in the code**: The specification of behavior is contained
    within the code and its tests, usually making it quite simple to manually write
    up this information as documentation. However, if it is difficult to write, then
    that indicates an underlying complexity in your code and its interfaces that perhaps
    should be fixed as a priority.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**It''s possible to automatically generate**: There exist many documentation
    generators that either rely on static-typing annotations or comment annotations
    (for example, *JSDoc*). These allow you to generate documentation for entire interfaces
    via a CLI or build tool.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**It follows a fixed format**: A specification will follow a straightforward
    format that is simple to author. It usually contains headings for individual endpoints
    or method signatures, and a sentence explaining each argument.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The overriding purpose of providing a specification is to answer specific questions
    that a user might have about the operation of your code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/30afe4c1-743d-4d49-809a-599c0003e424.png)'
  prefs: []
  type: TYPE_IMG
- en: The following is an example of a specification for a function called `removeWords`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This function will remove the specified words from the specified subject string,
    returning a new string to you. A word here is defined as a string of characters
    bound by word boundaries (`\b`). For example, specifying an `"I like apple juice"`
    subjectString  and `["app", "juice"]` for `wordsToRemove` would remove only `"juice"`,
    as `"app"` exists in the subject but is not bound by a word boundary. The following
    are the arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '`subjectString` (`String`): This is the string that the specified words will
    be removed from.  If you do not pass a `String` type, then the value you pass
    will be cast to a `String`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`wordsToRemove` (`Array`): This is an array containing words that you wish
    to remove. A null or empty array will cause no words to be removed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As you can hopefully tell, this specification is a purely technical explanation
    of a function''s behavior. It tells the user exactly what arguments they must
    provide and what output they''ll receive. When writing the specification portion
    of your documentation, the most important qualities to abide by are clarity and
    correctness. Be wary of the following traps:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Not enough information to allow usage**: It''s important to provide enough
    information about your implementation so that another programmer, with no knowledge
    of your software, can begin to make use of it. It''s insufficient to only specify
    types of arguments, for example. Provide extra information if the knowledge domain
    is especially obscure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Incorrect or out-of-date information**: Documentation can easily fall out
    of date or be incorrect. This is why it''s quite common to generate documentation
    automatically from annotated code. That way, the chances of information being
    incorrect or out of date are lessened considerably.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lack of examples**: It''s common to only list modules, methods, and argument
    signatures, without providing any examples. If doing this, the chance of confusion
    and pain is far higher, so it''s always worth providing sensible examples or linking
    readers to more tutorial-like documentation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The specification is arguably the most important part of your documentation,
    as it explains, in clear terms, the behavior of every part of your software's
    relevant APIs. Ensure that you take the same care and diligence when documenting
    your code as you would when writing it.
  prefs: []
  type: TYPE_NORMAL
- en: Instruction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to *concept* and *specification*, a clean piece of documentation
    will *instruct* a user in how to accomplish common tasks. These are commonly termed
    *walkthroughs*, *tutorials,* *how-tos*, or *recipes. *
  prefs: []
  type: TYPE_NORMAL
- en: 'Primarily, a user, regardless of whether they are a programmer or end user,
    is concerned with how to get from where they are to where they want to be. They
    are interested in knowing what steps to take. Without instructions for common
    use cases, they''ll be left desperately piecing together what they know about
    your software from intuitions or other pieces of documentation. Consider a book
    about cookery that only details the ingredients and their behaviors when cooked,
    but doesn''t contain any specific recipes that combine ingredients in a specific
    order. That''d be a challenging cooking book to make use of. While it may provide
    a highly detailed set of culinary information, it doesn''t help users answer their
    actual questions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ab3aba5c-f0ae-4878-b52f-21e9efbb2823.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When composing instructions, whether they''re in the form or video tutorials
    or written walk-throughs, it is important to consider what use cases are most
    prevalent or challenging for your users. As with many things in life, you can
    only reasonably cater for the bulk of prospects, not all of them. It is unreasonable
    to create tutorials for every single possible use case. And likewise, it is unreasonable,
    from a user''s perspective, for you to only provide a singular tutorial for the
    most common use case. It is wise to strike a compromise and have a small collection
    of tutorials that each express:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Upfront expectations and prerequisites**: A set of instructions should specify
    what expectations the author has about the reader''s hardware, software environment,
    and capabilities. It should also say if there is anything the reader should prepare
    before beginning the following steps.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Specific steps that a reader can emulate**: Instructions should have a number
    of specific steps that users can follow to reach their desired goal. The user
    should not have to use too much (or any) initiative when following these steps;
    the steps should clearly and exhaustively outline exactly what the user needs
    to do, with code examples if possible. It should also be obvious to the user that
    they have successfully completed each step (for example, *you should now receive
    X output*).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**An achievable and observable goal**: Instructions should work toward a goal
    that can be observed by the user. It would be upsetting for the last step of a
    tutorial to say *this won''t currently work, due to X or Y, but you would usually
    expect to see Z.* Ensure that your software is operating in such a way that the
    tutorial can be completed to its very end and the user can come away having gotten
    closer to whatever their overarching goal is.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Don''t just tell a user what to do**. Tell them what they''re accomplishing
    at each stage, and why it matters. That is, don''t just tell me to put salt in
    the dish, tell me why it needs salt!'
  prefs: []
  type: TYPE_NORMAL
- en: 'The instructional part of documentation is probably the most challenging. It
    requires us to take on the role of teacher and see things from another person''s
    position of relative ignorance. Maintaining focus on the person we''re teaching,
    the user, is absolutely vital. This feeds quite nicely into our final aspect of
    clean documentation: usability.'
  prefs: []
  type: TYPE_NORMAL
- en: Usability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Usability is the final component in clean documentation. Just like our software,
    our documentation must be concerned with users and their specific needs. The previous
    three aspects (*concept*, *specification*, *instruction*) have focused on content,
    while *usability* is purely about the way in which we express that content. It''s
    vitally important not to overwhelm or confuse user when they learn about your
    software:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/4782ca49-4cf1-4819-82ae-fa269763cb0e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'There are many ways we can confuse and overwhelm. Among them are these the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Too much content**: This can overwhelm a user who may only want to perform
    some specific and narrow task. They may not see the point in crawling through
    reams of documentation just to implement their simple task.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Too little content**: If a user wishes to do something that is not documented
    sufficiently, then they are left with few options. They either have to hope that
    there is community-driven documentation somewhere or that the interfaces are understandable
    enough to decipher without help.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Internal inconsistency**: This is common when there are different areas of
    documentation that have been updated at different times. A user is left wondering
    which document or example is correct and up to date.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lacking structure**: Without structure, a user cannot easily navigate through
    or gain a conceptual understanding of, the entire software. They are left crawling
    through the details without able to get a clear *big picture*. Hierarchy is important
    in software, so it''s important to reflect this in our documentation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Difficult to navigate content**: Without good UX/UI considerations, documentation
    can be very hard to navigate through. If it is not centralized, searchable, and
    accessible, then navigation suffers and users are left in a state of confusion
    and pain.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lacking presentation**: Alongside navigation, another crucial UX component
    within documentation is its aesthetic and typographic layout. A well laid-out
    document is a breeze to read through and learn from. It is entirely reasonable
    to *design* documentation. It should not be a dry *dumping ground* of endless
    prose, but a beautiful educational experience!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In [Chapter 2](fd19fa13-f04a-4e03-9bc3-ba318cacf731.xhtml), *The Tenets of
    Clean Code*, we went into great detail on what *usability* means. We discussed
    how it was not only about intuitive design and accessibility, but also about the
    consideration of *user stories—s*pecific tasks that users wish to carry out and
    how to accommodate these. Documentation is no different to any other interface
    that we provide; it must solve the user''s problems. Consider how you may design
    documentation to cater for these example user stories:'
  prefs: []
  type: TYPE_NORMAL
- en: '*As a user*, I wish to understand what this framework does and how I might
    apply it to my project'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*As a user*, I wish to find out how I can install this framework into my Node.js
    project'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*As a user*, I wish to understand the best practices when using this framework'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*As a user*, I wish to understand how to build a simple example app using this
    framework'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every user is different. Some users will prefer to read through a long and technical
    document, others will prefer short self-contained tutorials. Consider the different
    learning styles that people have (visual, aural, social, solitary, and so on).
    Some learn by studying things at length; others learn by *doing*.
  prefs: []
  type: TYPE_NORMAL
- en: We may consider building different styles of documentation for the different
    types of information a user seeks. More specification-oriented information (for
    example, *how does this specific framework function work?*) may be best suited
    to a traditional long-form document format, while more instruction-oriented information
    (for example, *how can I build an app with this framework?*) may be best suited
    to rich media (for example, a video tutorial).
  prefs: []
  type: TYPE_NORMAL
- en: Due to the many types of information a user may seek, and all the different
    individual users we are catering for, it is absolutely worth dedicating significant
    time to planning, designing, and executing clean documentation. It should never
    be an afterthought.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''re explored our four aspects of clean documentation, let''s explore
    the incredible gamut of available mediums we can employ to express our documentation.
    We do not have to employ only a single dull, scrollable document: there are dozens
    of other ways we can inform and educate our users and colleagues.'
  prefs: []
  type: TYPE_NORMAL
- en: Documentation is everywhere
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we generously define documentation as *a way of learning about a piece of
    software*, we can observe that there are dozens of different mediums of documentation
    that exist. Many of them are implicit or accidental; others are more intentionally
    crafted, either by the creator(s) of the software or the expert community that
    has gathered around it:'
  prefs: []
  type: TYPE_NORMAL
- en: Written documentation (*API specifications, conceptual explanations*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explanatory images and diagrams (for example* flowcharts*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Written tutorials (*walk-throughs, recipes, how to do X*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rich media introductions and tutorials (*videos, podcasts, screencasts*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Public Q&As or issues (for example* GitHub issues that explain how to fix something*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Community-driven Q&As (for example* StackOverflow*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Independent communication between programmers (*online or offline*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Meet-ups, conferences, and seminars (*owner or community-driven*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Official support (*paid support lines, emails, in-person sessions*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Educational classes (*in-person or online,* for example *Coursera*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tests (*that explain concepts, flows, and expectations*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Good abstractions (*that help to explain concepts*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Readable and familiar code (*that can be easily understood*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Structure and delineations (*directory structure, project names,* and so on)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Intuitively designed interfaces (*educating usage via good design*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Error flows and messages (for example* X not working? Try Z instead.*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's worth considering how all these mediums care catered for. When the official
    documentation does not help to solve a user's problem, what other pathways will
    they explore before abandoning your software altogether? How can we channel a
    user's difficulty or questions towards a solution as quickly and fluidly as possible?
    If a user is unlikely to read an entire specification document, then what other
    mediums can we create for them?
  prefs: []
  type: TYPE_NORMAL
- en: Writing for non-technical audiences
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we have seen, when writing documentation, there is a need to adapt the language
    used to the audience. To do this, we must have a good picture in our mind of who
    the audience is, what their current level of knowledge is, and what they''re trying
    to accomplish. A notorious challenge for programmers is communicating with less
    technical or non-technical people. This is a very common and crucial part of their
    role as a creator of software. Whether communicating with end users at specific
    points in a UX, or collaborating with non-technical stakeholders, there is a need
    to tailor our communication to the audience. To do this, we should do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Pick the right level of abstraction**: It''s crucial to find a level of abstraction
    that is fully understood by the audience. Use their roles and proficiencies to
    inform the analogies you use to explain things. For example, if you were talking
    to a patient about a piece of medical software, you might prefer to say *please
    add your medical information* instead of *please populate the medical profile
    fields*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Avoid overly-technical terminology**: Avoid words that mean nothing to the
    audience. Use regular language to explain detailed concepts. For example, you
    might talk about v*isual enhancements* instead of *CSS modifications*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Get constant feedback**: Ensure you are being understood by checking with
    your audience. Don''t assume that people understand you just because they don''t
    explicitly say otherwise. Consider user-oriented prompts in your documentation
    or software (for example, *was this message helpful? [YES] [NO]*)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Communicating with non-technical individuals may appear to be a distinct challenge,
    but it is no different from communicating with anyone else. As we should be doing
    all the time, we just need to *meet the person where they're at* and communicate
    according to their current understanding of the problem domain.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we have explored the difficult art of authoring clean documentation,
    breaking it down into the four vital aspects of clean documentation: *concept*,
    *specification*, *instruction*, and*usability*. We''ve discussed the challenge
    of correctly identifying our audience and how to craft our communications to suit
    them. This knowledge will not only be useful in crafting formal documentation,
    but also in our everyday communications with stakeholders and within our software
    when it needs to communicate with users.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we move swiftly on to the unique challenge of dealing with
    other peoples' code. What happens when we, on the receiving end of potentially
    poor documentation or unintuitive code, need to be productive? We'll find out.
  prefs: []
  type: TYPE_NORMAL
