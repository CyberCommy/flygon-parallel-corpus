- en: Monitoring and Logging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Reading local logs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `journalctl` on `systemd` systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Centralizing logging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Local resource measuring tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Local monitoring tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remote monitoring tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Centralizing logging with the Elastic Stack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Servers are all well and good when they work, but we don't live in a perfect
    world, and it's perfectly possible that problems can occur (either through bad
    code, created by humans, or mismanagement, introduced by humans).
  prefs: []
  type: TYPE_NORMAL
- en: In theory, it would be great to simply install the program you want, set it
    running, and forget about it, but this is the real world, not some fantasy land
    where everything goes 100 percent right 100 percent of the time. This is where
    logging and monitoring shine.
  prefs: []
  type: TYPE_NORMAL
- en: Logging is there so that when something does, inevitably, go wrong, you don't
    have to keep your program in a broken state while you try and work out what's
    broken (though, on odd occasions, this might be precisely what you have to do;
    more about that later). You can bring your system back online, and start to parse
    the log files to find out precisely why your web server suddenly started replacing
    all images on your website with pictures of puppies.
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring is the secondary component in keeping your life simple. There to
    ensure you have a smooth experience when using your software, and keeping tabs
    on the resource allocation on your systems, monitoring can detect issues before
    a human being even wakes up in the morning (actually this happens frequently;
    don't expect a normal sleep pattern if you are on call).
  prefs: []
  type: TYPE_NORMAL
- en: Both of these systems combined can make you appear godlike to those who are
    watching your every move; like Morpheus, you can feel your watch vibrate with
    a notification in a meeting, informing you that the company website is under heavy
    load and about to crash, and calmly inform those talking nonsense around you that
    you feel a disturbance in the force, before excusing yourself to fix the issue
    before the customers notice.
  prefs: []
  type: TYPE_NORMAL
- en: Come to think of it, good logging and monitoring can result in your job appearing
    pointless—what's that Futurama quote?
  prefs: []
  type: TYPE_NORMAL
- en: '"When you do things right, people won''t be sure you''ve done anything at all."
    – Sentient gas cloud'
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we're going to use two CentOS boxes and two Debian boxes but,
    again, the principles we discuss will be fairly universal in nature.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following `Vagrantfile` should be enough to get you started:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Reading local logs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we're going to look at the default place for logging on our
    machines.
  prefs: []
  type: TYPE_NORMAL
- en: Logging is great— it can tell you variously how healthy your system is, how
    busy it is, who's trying to attack it, and who's successfully gained access in
    the last few minutes.
  prefs: []
  type: TYPE_NORMAL
- en: It's fairly standardized these days, unless you're working with a Java application,
    and if you've got the patience to read through a log file, you might want to give
    *War and Peace* a shot afterward.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Log on to your `centos1` VM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Hier manual pages tell us that if we want to find miscellaneous log files,
    we should start by looking in `/var/log/`:'
  prefs: []
  type: TYPE_NORMAL
- en: /var/log
  prefs: []
  type: TYPE_NORMAL
- en: Miscellaneous log files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigating to `/var/log` and listing its contents shows us that this is the
    case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: On CentOS systems, the main log file is the `messages` log; under Debian and
    Ubuntu, this is called `syslog`, but it's effectively the same thing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having a look at the last few lines of this log file should show you various
    output from some of the programs running on your system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see `chronyd` complaining a bit, and we can see the point at which
    I logged in, and `systemd` was kind enough to create me a session.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also see the secure log, for the likes of `sshd`, `sudo`, and `PAM`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'And files such as the `cron` log for `cron`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As these files are just text, you can manipulate them using any of the standard
    tools at your disposal.
  prefs: []
  type: TYPE_NORMAL
- en: 'I might want to `grep` out mentions of `vagrant` from the messages log, and
    then only print the month, timestamp, and the program doing the logging:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Why you'd want to do this I don't know, but people have weird hobbies.
  prefs: []
  type: TYPE_NORMAL
- en: So that log files don't get too big and become a real pain to even open (really,
    a million lines is too many), we also have `logrotate`, which periodically runs
    to swap out the old files for new ones to be written to.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, I force `logrotate` to run, so we can see the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note how the old files have been moved and date stamped, and the new ones have
    been given the same name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using `cat`  on the messages file now will show one line, telling us that the
    `rsyslogd` daemon was `HUPed`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Personally, I think it should be HUP'd, but I can see the argument for `HUPed`.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The daemon logging to text files is `rsyslogd` (on some older systems, it might
    be `syslog-ng`).
  prefs: []
  type: TYPE_NORMAL
- en: 'This reliable and extended syslogd program writes messages that it reads from
    one of two locations, `imuxsock` (old) and `imjournal` (new); this comes directly
    from the `syslog(3)` syscall man page:'
  prefs: []
  type: TYPE_NORMAL
- en: syslog() and vsyslog()
  prefs: []
  type: TYPE_NORMAL
- en: syslog() generates a log message, which will be distributed by syslogd(8).
  prefs: []
  type: TYPE_NORMAL
- en: Note that `syslogd` (referenced here) is an old program, superseded by `rsyslogd`.
  prefs: []
  type: TYPE_NORMAL
- en: If there's more than one entry of the same name, in the man pages, you can specify
    the section by using the number. In this case, it would be `man 3 syslog` on the
    command line.
  prefs: []
  type: TYPE_NORMAL
- en: '`rsyslogd` configuration resides at `/etc/rsyslog.conf` and gives us the first
    bit of information on how specific logs are written where. This is the `RULES`
    section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This shows us the various rules that are applied when certain messages hit
    the log location: if they''re mail messages, they go to `/var/log/maillog`; if
    they''re anything that''s not mail (of `info` level or higher), `authpriv`, or
    `cron`, they go to `/var/log/messages`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `logger` command can be used to write to the log directly, and can be very
    handy for testing purposes and shell scripts, to show how this works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The `logger` command also lets you specify the facility, and the level of the
    log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This seems noisy, so let's create a dedicated log file for `cron` error messages.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need a rule, placed in the `rsyslog.d` directory for such things:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we restart `rsyslog`, and send our `logger` message again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This is much cleaner; our custom rule looks good!
  prefs: []
  type: TYPE_NORMAL
- en: 'Log levels are one of the following, and there''s only loosely defined guidelines
    for when the different levels are used, though generally it''s considered good
    manners not to log trivial events as critical problems:'
  prefs: []
  type: TYPE_NORMAL
- en: 0              emerg
  prefs: []
  type: TYPE_NORMAL
- en: 1              alert
  prefs: []
  type: TYPE_NORMAL
- en: 2              crit
  prefs: []
  type: TYPE_NORMAL
- en: 3              err
  prefs: []
  type: TYPE_NORMAL
- en: 4              warning
  prefs: []
  type: TYPE_NORMAL
- en: 5              notice
  prefs: []
  type: TYPE_NORMAL
- en: 6              info
  prefs: []
  type: TYPE_NORMAL
- en: 7              debug
  prefs: []
  type: TYPE_NORMAL
- en: The numbers are the numerical designation of the individual levels.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we rotated the logs, and `HUPed` the `syslog` daemon, we actually ran
    this script in `logrotate`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Of course, there's no reason an application has to use the `syslog(3)` call
    to log messages, and it could just as easily write a stream of text to `/tmp`,
    but that's entirely up to the application developer in question.
  prefs: []
  type: TYPE_NORMAL
- en: All you need to know as an admin is that most logs will probably end up in text
    format in `/var/log`, and you can generally configure log file locations on a
    program-by-program basis.
  prefs: []
  type: TYPE_NORMAL
- en: Happy logging!
  prefs: []
  type: TYPE_NORMAL
- en: Using journalctl on systemd systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Modern Linux distributions don't just rely on `syslog` files; in fact, they
    don't need to rely on `syslog` at all. Debian, Ubuntu, and CentOS all have `systemd`
    as an init system, and bundled with `systemd` is a service called `journald` (`systemd-journald.service`).
  prefs: []
  type: TYPE_NORMAL
- en: This service acts as the journaling solution for your system, and utilizes binary
    logs instead of text-based logs.
  prefs: []
  type: TYPE_NORMAL
- en: While it's possible to ignore `syslog` entirely, and just use `journald`, a
    lot of systems now use both, to make the transition from one format to another
    easier. If you're using something like Arch or Gentoo, you may decide to dismiss
    `syslog` solutions entirely, in favour of `journald` alone.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this section, we can use the `Vagrantfile` from the first section.
  prefs: []
  type: TYPE_NORMAL
- en: We will only be using `centos1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'SSH to `centos1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned earlier, journald utilizes a binary logging format, meaning it
    can't be opened with traditional text parsers and editors. Instead, we use the
    `journalctl` command to read logs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Simply running the following opens your log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The output for the preceding command is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f41a5795-f1ce-4b8b-8be1-cd42c7b4aa36.png)'
  prefs: []
  type: TYPE_IMG
- en: This is familiar to anyone who's looked as a regular old `syslog` file; note
    that the format is the same by default.
  prefs: []
  type: TYPE_NORMAL
- en: It is quite noisy though, and on a busy system we might not want to see everything
    historic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Maybe we want to just watch the log as it''s written? If this is true, we can
    follow it with `-f`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Whenever a log message is written, it will appear before you, streamed (use *Ctrl*
    + *C* to quit out).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can specifically look at `kernel` logs (as if we were running `dmesg`) with
    the `-k` flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Note that here, I've disabled the pager (in the exact same way it's done in
    `systemctl-land`), and I've only dumped the first eight lines of the log, as the
    `kernel` is quite noisy, especially at boot.
  prefs: []
  type: TYPE_NORMAL
- en: This also serves to show that the logs can still be manipulated on the command
    line; you've just got to query them first (adding a bit of overhead).
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s not to say you have to use `journalctl` and a combination of other
    commands; there''s a good chance you can get what you need with `journalctl` alone.
    Here, I choose a very specific time range to query the logs for:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In 2 minutes, we get 15 lines of log, but this is much easier to sift through
    and digest (assuming the time is correct on your box of course!)
  prefs: []
  type: TYPE_NORMAL
- en: These timestamps are just examples; you could use a full date (`--since="2018-10-10
    17:07:00"`) or even relative statements (`--since=yesterday --until=now`).
  prefs: []
  type: TYPE_NORMAL
- en: 'If it''s not a range of time you''re after, but rather the logs of a specific
    `systemd unit`, `journalctl` also has you covered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Here, I used the `-u` (unit) flag to only look at logs from `chronyd`, minimizing
    the amount of output I have to deal with.
  prefs: []
  type: TYPE_NORMAL
- en: 'What we also get in the preceding example are the `systemd` logs that interact
    with the `chronyd` unit. But if we only want logs from the `chronyd` binary, we
    can do that too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Seriously, how cool is that?
  prefs: []
  type: TYPE_NORMAL
- en: But wait, there's more!
  prefs: []
  type: TYPE_NORMAL
- en: The `journald` command can be more powerful still, as it has the concept of
    message explanations, or message context if you prefer. Some log lines can be
    output in a more verbose fashion (with `-x`) to better understand what's happening.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take the following two examples using the `sshd` unit, with and without the
    `-x` flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `systemd` specific lines suddenly have a lot more context.
  prefs: []
  type: TYPE_NORMAL
- en: We've covered some good basics, but `journalctl` can still be more complex.
    After passing options to the output, we can add specific matches to our statements
    (in the format `FIELD=VALUE`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking at SSH, we can see this in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Here, we've said that we want all the messages from yesterday, generated by
    the `systemd` `sshd` unit, but only those from PID `853` (which happens to be
    the server daemon PID on this box).
  prefs: []
  type: TYPE_NORMAL
- en: For more on matches, take a look at the `systemd.journal-fields` man page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, as with `syslog`, we can specify the priority of messages we want to
    see. Here, we''re looking at the entire log, but we''re only after `err` level
    messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Configured in `/etc/systemd/journald.conf`, journald is a great piece of software
    but, at least on CentOS 7, it's something of a second class citizen, with syslog
    still being the primary method of keeping an eye on logs for a lot of people.
  prefs: []
  type: TYPE_NORMAL
- en: Logs aren't persisted through reboots (more on this later) so it's only good
    for querying the state of a system since boot (which can also be enough, 9 times
    out of 10).
  prefs: []
  type: TYPE_NORMAL
- en: 'The file, as we said, is in binary format, and journald pulls in various sources
    to create its log journals:'
  prefs: []
  type: TYPE_NORMAL
- en: Kernel log messages (`/dev/kmsg`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simple log messages (the `syslog` `libc` call mentioned previously)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Structured journal log messages from the Journal API (imported into `rsyslog`
    with the `imjournal` module)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `stdout` and `stderr` of service unit files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Audit records from the kernel audit subsystem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Like `syslog`, this means `logger` can be used to show we can still populate
    the log manually, here showing only those messages received from the `syslog`
    transport mechanism:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In the future, there's a good chance that `syslog` will be dropped and `journald`
    will become the new norm, but given how long `syslog` as a concept has been around
    for, it'll be a very long time before that becomes the case.
  prefs: []
  type: TYPE_NORMAL
- en: The fact `journald` logs in a binary way is something of a point of contention
    for a lot of traditionalists but, like Columbus, it didn't arrive on the scene
    first, it's just the one that got all the attention. Those of you who've ever
    used OpenBSD, and its firewall `pf`, will perhaps find the notion of binary logging
    a comfort.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One thing to be aware of is the space that the journal log will use. The size
    limitations are governed by options in `journald.conf`.
  prefs: []
  type: TYPE_NORMAL
- en: The options `SystemMaxUse` and `RuntimeMaxUse` govern the maximum disk space
    the journal can use; these default to 10% of the size of the filesystem, with
    a cap of 4 GB.
  prefs: []
  type: TYPE_NORMAL
- en: The `SystemKeepFree` and `RuntimeKeepFree` options govern how much disk space
    `journald` leaves free for other uses; these default to 15% of the size of the
    filesystem, and are also capped to 4 GB.
  prefs: []
  type: TYPE_NORMAL
- en: There are various scenarios governing size but, basically, `journald` will try
    its hardest not to be the reason your filesystem fills up, and it's that sort
    of attention to detail that makes me love it.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'On our CentOS system, the log file is transient, being lost upon reboot. While
    it''s live, it exists in `/run/log/journal/`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We could actually change this behavior quite easily, by adding a `/var/log/` directory
    specifically for the journal, and using a one-liner to change the permissions:
    `sudo systemd-tmpfiles --create --prefix /var/log/journal`'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also list the boots `journalctl` is aware of from the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Centralizing logging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You don't want to log on to each and every box in your estate to check logs,
    you just don't. In this age of the cloud and automatically provisioned infrastructure,
    it's a lot more faff than it's worth, and it's a great case for centralizing your
    logs in one (redundant) location.
  prefs: []
  type: TYPE_NORMAL
- en: Being data, our logs can be manipulated and moved relatively easily. Both `rsyslog`
    and `journald` have the capability to do this, and, in this section, we're going
    to be streaming our logs around the place, showcasing how useful this can be.
  prefs: []
  type: TYPE_NORMAL
- en: Everything we cover here will be natively possible in the respective programs;
    this is different to some of the centralized logging solutions that are provided
    by software such as the Elastic Stack.
  prefs: []
  type: TYPE_NORMAL
- en: For the purpose of these examples, we're not utilizing TLS, meaning logs will
    be streamed in a plain format. I would advise against doing this sort of thing
    in production, without investing in HTTPS setups or tunneled solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this section, we can use the `Vagrantfile` from the first section.
  prefs: []
  type: TYPE_NORMAL
- en: We will be using `centos1` and `centos2` for the first part, and then `debian1` and
    `debian2` for the second part, sending logs from one box to the other.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open two Terminals and connect to both `centos1` and `centos2`; install `tcpdump`
    on both boxes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'For part two (`journald`), connect to both `debian1` and `debian2`, and install
    `tcpdump` and `systemd-journal-remote` on both boxes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll go through both of the logging daemons in turn, starting with `rsyslog`
    and then doing the same basic thing with `journald`.
  prefs: []
  type: TYPE_NORMAL
- en: Remote logging with rsyslog - UDP example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to enable logging to a remote machine with `rsyslog`, you need to enable
    both streaming to a remote location on your client, and receiving on your server.
  prefs: []
  type: TYPE_NORMAL
- en: For this, `centos1` will be our client, and `centos2` will be our server.
  prefs: []
  type: TYPE_NORMAL
- en: 'On `centos1` first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now on  `centos2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We can check this is working immediately with `tcpdump` on our `centos2` VM;
    start it using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, generate a message on `centos1` to send; here, we''re spoofing a `syslog.info`
    message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'On `centos2`, you should see something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9bcab73d-8593-4302-b04f-d5628e1589ed.png)'
  prefs: []
  type: TYPE_IMG
- en: 'And, of course, in the `/var/log/messages` file where our log line will end
    up, you will see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can also see `eth1` being put in promiscuous mode by `tcpdump`, prior
    to and after us delivering our `syslog` message.
  prefs: []
  type: TYPE_NORMAL
- en: Remote logging with rsyslog - TCP example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous example covered UDP, which is simply a stream of information with
    no confirmation that the server on the other side received the noise. With a TCP
    connection, the `syslog` servers communicate with each other to establish a connection
    first.
  prefs: []
  type: TYPE_NORMAL
- en: 'On your `centos1` machine, replace the single `@` sign in your destination
    address with two `@@` signs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Our client is now set, but no logs can be sent until the connection is established.
  prefs: []
  type: TYPE_NORMAL
- en: 'On `centos2`, let''s set the `rsyslog` server to receive TCP connections and
    data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: An `rsyslog` server can listen on UDP and TCP at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s test it out! On `centos2`, set up your `tcpdump` again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'And send a log message from `centos1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Your `tcpdump` output should look similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a65b5ffb-8f04-442c-8710-6abe1666f01b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'And, again, your messages file should have the new alert:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Remote logging with journald
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `systemd-journal-remote` command allows you to receive journal messages
    over a network. Sadly, it's a fairly recent addition to the `systemd` suite, and
    isn't yet available on CentOS systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'On your first Debian system (`debian1`), set up your remote upload location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'On your second box (`debian2`), start by editing the listening service, using
    `systemctl edit`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'When presented with the empty editor, add the following three lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'It should look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/341259df-619f-451b-be4d-55a805bae749.png)'
  prefs: []
  type: TYPE_IMG
- en: Save and exit (*Ctrl* + *O*, *Enter*, *Ctrl* + *X*).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you need to make the remote folder location, and make sure it has the appropriate
    permissions, before finally restarting the service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'And don''t forget to start the service on `debian1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Give it a test by following your log on `debian2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'It can also be tested by using our trusty `logger` command on `debian1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'With any luck, you''ll see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/44ecbf30-a60f-4b80-a642-98f816521792.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What we're effectively doing is opening up a listener for logs in both the `syslog`
    and `journald` solutions. A network port is opened on our boxes, and the daemon
    is aware of a source of data that it might be forced to read from. In the case
    of `syslog`, we had to enable specific modules in the `rsyslog` daemon to make
    this happen; `systemd` and `journald` required specific packages.
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, journald's implementation appears a bit clunkier, but that's mostly
    because it's newer.
  prefs: []
  type: TYPE_NORMAL
- en: Fundamentally, we're just dealing with streaming log data, and neither `syslog`
    nor `journald` care where that data comes from, as long as it's in a format that
    they can understand.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Time is very important when centralizing logging. Think about how confusing
    it can be to look in a log file that features multiple hosts, and discover interspersed
    time jumps.
  prefs: []
  type: TYPE_NORMAL
- en: It can also make log parsing hard, as we can use specific timestamps to properly
    arrange data, and we could miss something critical if our remote box has the wrong
    time.
  prefs: []
  type: TYPE_NORMAL
- en: TLS and secure transport are also something to think about, as mentioned in
    the introduction to this section. You can configure `systemd-journal-remote` to
    listen on HTTPS, instead of HTTP, as long as you sort your certificates properly.
  prefs: []
  type: TYPE_NORMAL
- en: For syslog, TLS and encryption can be a bit trickier, but there are more solutions
    to consider, such as streaming log data over an SSH tunnel, or using a program
    such as `spipe` to offload the heavy work of TLS.
  prefs: []
  type: TYPE_NORMAL
- en: Local resource measuring tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Occasionally, it can be incredibly handy to know what a box is doing right this
    second. Usually, this will be during a debugging session, when you're trying to
    work out why the website is responding an order of magnitude slower, or why it's
    taking 5 minutes to type your SSH command on a remote session.
  prefs: []
  type: TYPE_NORMAL
- en: Here, local resource monitors come in handy. We've already touched on these
    briefly, but this section will look at them in slightly more detail, and will
    cover some of the more obscure tools that you might find useful when remotely
    connected to your server.
  prefs: []
  type: TYPE_NORMAL
- en: We're going to look at the classics of `free` and `top`, before moving on to
    the more recent additions, such as `netdata` and `htop`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this section, we're going to use our `centos1` and `debian1` VMs.
  prefs: []
  type: TYPE_NORMAL
- en: All of the programs we look at will be universally available in one form or
    another.
  prefs: []
  type: TYPE_NORMAL
- en: 'SSH to your `centos1` VM, and ensure that the EPEL repository is enabled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'SSH to your `debian1` VM, very specifically, forwarding port `19999` to your
    local machine (more on this later):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As with most of what we look at, there are classic examples of software that
    has been kicking around in one form or another since roughly the 1970s, back when
    most programs had names of two or three characters (ls, cp, mv). One of these
    is `top` and another is `free`, both of which still have their place.
  prefs: []
  type: TYPE_NORMAL
- en: Then there are the more modern, slick, and beautiful programs. Gone are the
    monochrome CRT-designed applications, and, in their place, are Terminal applications
    that even support 256 colours!
  prefs: []
  type: TYPE_NORMAL
- en: Finally, there's NetData, which I touch on here because it's making quite the
    storm in the world of local administration.
  prefs: []
  type: TYPE_NORMAL
- en: top
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An old friend, and guaranteed to be installed on any Unix or Unix-like system,
    top is your immediate window into what your system thinks it''s doing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The output for the preceding command is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6950a085-46bf-4316-99f4-fbe2499e2e44.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Right from the start, we can see several things:'
  prefs: []
  type: TYPE_NORMAL
- en: The time in the top left, and how long the box has been up – 17:09:46 up 8 min
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The number of users logged in – 1 user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The load average – 0.00, 0.03, 0.03
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The number of running, sleeping, and so on tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CPU usage information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Volatile memory information (RAM)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SWAP information (disk memory)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Breaking these down, let''s look at some in more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Load average**: In detail, the load average is the load of the system over
    the last 1, 5, and 15 minutes. This load average is a display of processes running,
    or those waiting for resources such as CPU time or disk I/O.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The disk I/O element is important, as it's something that's pretty Linux-specific
    and that a lot of people forget. You can have a system that's completely free
    of load on the CPU, and yet has high load average values; this can be an indication
    that you need to upgrade that old and creaking HDD into a shiny new NVMe drive.
  prefs: []
  type: TYPE_NORMAL
- en: '**Tasks**:Basically, you can think of tasks as the number of processes that
    are running now, or that are in the sleeping/zombie/stopped state on your system.
    It''s the same number you''d get with `ps aux`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**%CPU**: It''s best to defer to the man page for this one:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'us, user    : time running un-niced user processes'
  prefs: []
  type: TYPE_NORMAL
- en: 'sy, system  : time running kernel processes'
  prefs: []
  type: TYPE_NORMAL
- en: 'ni, nice    : time running niced user processes'
  prefs: []
  type: TYPE_NORMAL
- en: 'id, idle    : time spent in the kernel idle handler'
  prefs: []
  type: TYPE_NORMAL
- en: 'wa, IO-wait : time waiting for I/O completion'
  prefs: []
  type: TYPE_NORMAL
- en: 'hi : time spent servicing hardware interrupts'
  prefs: []
  type: TYPE_NORMAL
- en: 'si : time spent servicing software interrupts'
  prefs: []
  type: TYPE_NORMAL
- en: 'st : time stolen from this vm by the hypervisor'
  prefs: []
  type: TYPE_NORMAL
- en: '**KiB Mem**: In digits, this is the amount of RAM available to your system,
    broken down into the total, free, used, and buffers/caches.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Buffers/caches are memory that's in use, but which can be annexed by any program
    that wishes to use it in an instant. Linux likes RAM, and unused RAM is wasted
    RAM, so it will do everything it can to use it.
  prefs: []
  type: TYPE_NORMAL
- en: '**KiB Swap**: Also in digits, this is the amount of Swap available, broken
    down once more.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you want a nicer view, cycling through the options by hitting *M* a few
    times will give you visual representations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5b48f441-143c-4040-a8f2-5ba586e05f16.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Lastly, we have the ever-changing process list and information about running
    jobs on your system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/98d0b821-84f3-45b7-a9b8-3130314dadd0.png)'
  prefs: []
  type: TYPE_IMG
- en: By default, this is organized by CPU usage (%CPU) but you can adjust that if
    you wish.
  prefs: []
  type: TYPE_NORMAL
- en: 'Along the top, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The PID of the task in question
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The user running the process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PR, the priority of a task (the higher the priority, the more likely it is to
    get prioritized)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NI, the nice value of a task; minus values have a higher priority
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: VIRT, the virtual memory being used by the task (all memory, including the likes
    of shared libraries)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RES, the non-swapped physical memory being used by the task
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SHR, mostly RES, without some bits that are too technical for this book
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: S, the state of the process (running, sleeping, zombie, and so on)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '%CPU, how much CPU time a task has used since the last refresh, a percentage
    of the total CPU time available'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '%MEM, how much available physical memory a task is currently using'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TIME+, an update of TIME, it's the total CPU time the task has used since starting;
    the plus increases granularity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: COMMAND, the name of the task
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Phew!
  prefs: []
  type: TYPE_NORMAL
- en: That's `top`, but it's so much more than that, and it might look slightly different
    on different systems. It can also do color, but only one distribution I know of
    switches it on out of the box.
  prefs: []
  type: TYPE_NORMAL
- en: It's a good idea to load `top` and hit *H* or *?* for a helpful indication of
    what `top` is capable of.
  prefs: []
  type: TYPE_NORMAL
- en: free
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`free` is a great way to see how busy your system is at a glance; more specifically,
    it''s the quickest way of finding out how much memory is being used on your box.'
  prefs: []
  type: TYPE_NORMAL
- en: Thankfully, `free` has fewer options than `top`. Mostly, the flags are just
    to change the output of the command, making it more human-readable or less, if
    that's your thing.
  prefs: []
  type: TYPE_NORMAL
- en: Personally, I use `-m` which outputs the value in mebibytes, but if your system
    has Gigs of memory, you might find `-g` more useful.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following, you will see `free -ht` on our `centos1` VM: `-h` is used
    for human-readable output, giving a nice mix of mebibyte and gibibyte values;
    `-t` is a flag to add a `Total` line, giving a sum of `Mem` and `Swap` values:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/07d3d8d0-fa5b-47f7-a9dd-4aa68ed2ebdf.png)'
  prefs: []
  type: TYPE_IMG
- en: The important field is `available`, as it effectively tells you how much physical
    memory is available before the system starts swapping; if this is `0`, you're
    going to be constantly reading and writing to disk, which can slow a system drastically.
  prefs: []
  type: TYPE_NORMAL
- en: htop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`htop` is like `top`, but prettier. If a box is under my control (and providing
    the appropriate approval has been given), you''re very likely to find `htop` installed.'
  prefs: []
  type: TYPE_NORMAL
- en: In a pinch, `top` is fine, and you're guaranteed to find it pre-installed on
    a box, but if you want something that doesn't feel like it's from the 1970s, `htop`
    is extremely helpful.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s `htop` on our `centos1` VM:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/38d52dde-947b-4aea-b1fe-8b652ba728c3.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that we still have all the same information that `top` gives us, only now
    we've made use of what a modern Terminal emulator can do, giving us colors by
    default, and nicely aligning output into a window that also supports mouse input
    (try it!).
  prefs: []
  type: TYPE_NORMAL
- en: 'Further to `top`, we have the ability to format our output quickly and easily
    by changing the look of our window; the options such as `Tree` at the bottom of
    the screen (*F5*) can provide a very useful tree view when pressed (note it changes
    to read `Sorted`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/444e082f-3db0-44a6-8277-d7a5f7e5743e.png)'
  prefs: []
  type: TYPE_IMG
- en: As with top, there are also options for changing what's shown in terms of columns
    and information, although, unlike `top`, these are under the Setup menu (*F3*)
    and changes are persisted to disk in the form of a configuration file, located
    at `~/.config/htop/htoprc`.
  prefs: []
  type: TYPE_NORMAL
- en: NetData
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Popular mainly due to being able to market itself effectively, NetData is an
    aggregator of all the system information it can get hold of.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is not an advert nor an endorsement, merely an example of what third-party
    software can do. NetData does use a centralized server for logging some data,
    such as system hostnames, meaning you should check against your internal security
    policy if you intend to use this tool. See the NetData security page for more
    information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.netdata.cloud/docs/netdata-security/](https://docs.netdata.cloud/docs/netdata-security/)'
  prefs: []
  type: TYPE_NORMAL
- en: As with everything, understand what the software you're installing does, before
    you blindly click Accept.
  prefs: []
  type: TYPE_NORMAL
- en: Flipping over to our Debian VM, we're going to install NetData here, as it's
    available in the backports repository (software added to previously released Debian
    versions after the fact).
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to enable the `backports` repository and then we can install
    our package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: As Debian typically starts services by default, after installation, NetData
    is now enabled and started.
  prefs: []
  type: TYPE_NORMAL
- en: By default, though, it will only listen on localhost, which is why we needed
    to forward that IP and port in our *Getting ready* section. If you've not done
    so, log off from your `debian1` VM and use the command from that section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, navigating to `http://127.0.0.1:19999` in your local machine''s web browser
    will forward that connection through to your VM, and you should see the NetData
    GUI:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3754837c-4578-450f-8bc6-0380ed3c646a.png)'
  prefs: []
  type: TYPE_IMG
- en: NetData Homepage
  prefs: []
  type: TYPE_NORMAL
- en: Even I've got to admit, the interface is pretty swish.
  prefs: []
  type: TYPE_NORMAL
- en: Note that, on the right, it even gives you a snippet of information about what
    NetData is doing, and where it's getting information from: netdata on `debian1` collects
    686 metrics every second, presented as 142 charts and monitored by 41 alarms,
    using 11 MB of memory for 1 hour, 6 minutes and 36 seconds of real-time history.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`top` queries the kernel to gather information about a running system, making
    it very fast at reflecting the nature of the box it''s been run on. It''s also
    incredibly lightweight, meaning that unless a box is extremely overloaded, there''s
    a good chance `top` will still run (and if it is overloaded, you''ve got bigger
    issues). It''s been around since the 1980s; it''s tried and tested.'
  prefs: []
  type: TYPE_NORMAL
- en: '`free` takes a look at the values available in `/proc/meminfo`, meaning that
    while you can query these files yourself (and some people do), `free` provides
    a nicer way of looking at values (and gives you the option to refresh on a periodic
    basis, if that''s what you''re after).'
  prefs: []
  type: TYPE_NORMAL
- en: '`htop` queries the system in much the same way as `top` (though this isn''t
    necessarily the same across operating systems such as macOS or the BSD family).
    The difference with `htop` is that it uses the `ncurses` library to display itself,
    and while it''s not as old as `top`, it has been around for about 14 years at
    the time of writing.'
  prefs: []
  type: TYPE_NORMAL
- en: NetData uses various sources (and can use custom plugins) to collect data every
    second; it then displays this data to the user.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: NetData might look cool, and, at a glance, it can be a nifty way of finding
    out what your server is up to (especially if you've got it on a wall in your office
    or something), but this isn't an advertisement, and I would advise caution when
    using tools such as this. Not because they're dangerous (though always check your
    sources), but because they can be a little frivolous, and serve as nothing more
    than a dashboard that management might like to see on your PC monitor occasionally.
  prefs: []
  type: TYPE_NORMAL
- en: Ooh! I've thought of another great use for NetData, maybe as some sort of background
    set-dressing in some cheesy DC or SciFi TV show; that'd be neat too.
  prefs: []
  type: TYPE_NORMAL
- en: What we looked at here are only a sample of the tools on offer. The defaults
    will always be available to you (the tops and frees of the world), but there are
    hundreds of others to choose from, some of which might fit your needs, and some
    of which might fit that wallboard in the corner of the office that no one else
    ever uses.
  prefs: []
  type: TYPE_NORMAL
- en: Have a look around, search the net, and try things out.
  prefs: []
  type: TYPE_NORMAL
- en: It's Linux, there are a hundred ways to accomplish the same thing.
  prefs: []
  type: TYPE_NORMAL
- en: Local monitoring tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like tools that keep an eye on the resources of your system here and now, there
    are tools for looking at the historic data on your system. NetData could be considered
    one of these, depending on how you use it, but there are more besides, and we'll
    look at a few more that can help you to debug past problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re going to take a look at the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`atop`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`vmstat`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this section, we're going to continue to use the `Vagrantfile` from the
    first section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Log on to `centos1`, the VM we''re going to be using in this section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Install the tools we''ll be using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once you've got all your tools installed, work through each of the following
    sections.
  prefs: []
  type: TYPE_NORMAL
- en: atop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: atop (Advanced System and Process Monitoring)
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin, run `atop` normally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7df27ac4-c1bd-4b8d-b33f-14e991620d90.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This gives us some good information, specifically the system and process activity
    since boot, before it rotates onto a rolling display of the activity over the
    previous 10 seconds. In other words, 10 seconds later, it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f4a44ad1-75f7-4fe3-8317-cf644e07bbb6.png)'
  prefs: []
  type: TYPE_IMG
- en: Furthermore, `atop` can be used to store data not just of the current boot,
    but also periodically.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enable the `atop` service as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'You will now find that historic days are logged to `/var/log/atop` in a binary
    format and those same files can then be replayed at a future date, in case you
    want to know what happened to your system in the middle of the night that caused
    all those red alerts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'To read a file again, you can either specify the full filename, or the date
    you''re after:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Because we started the service at `18:56:14`, that''s what we see when we load
    this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3d14cc15-92ae-414f-9d77-50f4fd9d726d.png)'
  prefs: []
  type: TYPE_IMG
- en: We can then adjust the samples by using *t* and *T*to move forward and backward.
  prefs: []
  type: TYPE_NORMAL
- en: '`atop` is restarted at midnight by a `cron` job:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: sar
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`sar` is a way of reading system information, but it also allows you to read
    historic information.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s enabled with a `systemctl` command, which actually triggers a binary
    called `sa1` to start at boot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Run via a `cron` job, `sar` is executed every 10 minutes to grab system information.
    It then has a daily summary created at `23:53`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'To specify a `sar` file to open and read, use the `-f` flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, if you want to be more granular, you can specify start and stop times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: vmstat
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`vmstat` is a great way to report on memory statistics; by default, its output
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Where `vmstat` excels, though, is the fact its initial report (the preceding
    output) is the information since boot, and you can add a digit to the end of your
    command, to get a rolling summary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Again, like NetData, `vmstat` could fit in either category (this or the preceding
    section) and, as a result, it falls to the user to decide how to do it. You could,
    for example, write a `systemd-timer` to run `vmstat` 10 times, every hour, and
    output the result to a file for you to peruse at a later date. This is a bit more
    manual than the out-of-the-box solutions such as `sar` and `atop`, but it would
    be good practice for bigger projects.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As with our previous section, out of the box, a lot of the `atop` and `sar` setup
    is done for you, but further configuration changes can be made in the relevant
    configuration files for the processes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Under CentOS, these live in `/etc/sysconfig`, as is traditional:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: When `atop` is started (using `systemd`), the `/usr/share/atop/atop.daily` script
    is triggered, using options from `sysconfig`.
  prefs: []
  type: TYPE_NORMAL
- en: When `sysstat` is enabled with `systemd`, it specifically tells `sar` to start
    with a dummy record, signifying a new boot. This is in addition to the `cron`
    entries we saw previously, and which are dictated by the configuration file in
    `/etc/sysconfig`.
  prefs: []
  type: TYPE_NORMAL
- en: It's a bit complicated using these tools, but you will soon find the data to
    be invaluable to you if you get good at interpreting and using the information
    they provide.
  prefs: []
  type: TYPE_NORMAL
- en: Remote monitoring tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Being able to query a server locally and find out what it's doing is great,
    but that's rarely how things are done in the real world (outside your single box
    that you might maintain for personal projects). In company scenarios, it's much
    more likely that you'll have a monitoring solution of some sort, perhaps with
    agents on your boxes, which keeps an eye on the health of machines in your care.
  prefs: []
  type: TYPE_NORMAL
- en: Nagios is the undisputed king of monitoring installations the world over, not
    because it's the best, or the most flashy, but simply because it's one of the
    oldest, and once a monitoring solution is in place, you'll find teams are very
    hesitant about switching over to a new one.
  prefs: []
  type: TYPE_NORMAL
- en: It has caused several clones to be created, and various offshoots (some using
    the original source code and some not), but all of them will behave in a similar
    fashion.
  prefs: []
  type: TYPE_NORMAL
- en: In this part, we're going to install **Nagios** on `centos1`, and have it monitor
    both itself and `debian1`, while we install **Icinga2** on `centos2`, and have
    it monitor `debian2`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this section, the `Vagrantfile` from the first section will suffice. We
    will be using all four of our VMs.
  prefs: []
  type: TYPE_NORMAL
- en: We'll run through the Nagios setup first, then move on to Icinga2 afterward.
  prefs: []
  type: TYPE_NORMAL
- en: Connect to each of your boxes, or start with `centos1` and `debian1`, before
    moving on to `centos2` and `debian2` later.
  prefs: []
  type: TYPE_NORMAL
- en: 'When connecting to `centos1` for the `Nagios` installation, you will want to
    use the following port forward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned, we'll run through Nagios first, and then Icinga2.
  prefs: []
  type: TYPE_NORMAL
- en: Nagios
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'On `centos1`, let''s install Nagios from EPEL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that''s finished (which can take some time, as there are a lot of plugins),
    we should start and enable our service, along with `httpd`, which should be installed
    by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Out of the box, you will get an insecure nagios-web setup. If you''ve connected
    to your Vagrant VM as suggested previously, you should now be able to navigate
    to the web interface on the forwarded port (`http://127.0.0.1:8080/nagios`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/efaaa137-c30d-43e7-a502-2599e0146020.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We actually haven''t set our `nagiosadmin` password yet (for the basic `http
    auth` prompt), so let''s do that now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Once your password is set, try inputting it in the prompt box:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2679b5a7-8afe-4834-ac9d-8a7a4a7f2f74.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You should see the Nagios landing page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5d9f6303-81eb-43cb-af2c-4ed92bdaf02a.png)'
  prefs: []
  type: TYPE_IMG
- en: As I've mentioned in other places, I wouldn't recommend using basic HTTP authentication
    in this manner, as it's insecure. If you can't use HTTPS/TLS to secure the web
    page, you should block it so that it can only be accessed on the box locally,
    and use something like SSH forwarding to encrypt connections to the portal. Ideally,
    though, get a certificate from LetsEncrypt and make life easy for yourself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now click on Services on the left-hand side; this is where you''ll mostly want
    to be, as it shows the hosts and services on that host that Nagios is currently
    monitoring:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/151f78e9-dd19-4412-8878-0017c16ed4d0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'By default, you can see that we''re only monitoring our localhost, which is
    fine for now, but we want to add `debian1` into the mix. Back on the command line,
    let''s get to work by first pointing to our `debian1` file in the Nagios configuration
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to create `debian1.cfg`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve got all the same configuration as the `localhost` machine at the moment,
    so we''re going to replace these with `debian1` specific values. We''re also going
    to create a new host group specifically for remote VMs, and we''re going to change
    the local checks to first use `check_nrpe`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'With those in place, we have to define the `check_nrpe` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Once done, we can restart our Nagios installation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Looking again at your Services page, you'll now see `debian1`, likely with a
    lot of checks failing.
  prefs: []
  type: TYPE_NORMAL
- en: This is because NRPE isn't set up on `debian1`, so let's SSH to `debian1` and
    do that now!
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to install the various bits and pieces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to allow our `centos1` box to talk to `debian1` (via port `5666`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to define the client commands that our server is going to request
    be run on the client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we''re at the point we can restart the `nrpe` service on `debian1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, looking back at the Nagios web interface (don''t forget to SSH to the
    `centos1` VM again if you disconnected), we should see our services being checked
    correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3a5cc6d4-73b8-40be-9a85-27543929882a.png)'
  prefs: []
  type: TYPE_IMG
- en: Nagios Services Page with ‘debian1’
  prefs: []
  type: TYPE_NORMAL
- en: Note that we have a failing check (HTTP) because `debian1` doesn't have a web
    server installed and running.
  prefs: []
  type: TYPE_NORMAL
- en: If your checks haven't cycled through yet, you can force all services on a host
    to be checked by clicking on the host's name and then selecting the Schedule a
    check of all services on this host command.
  prefs: []
  type: TYPE_NORMAL
- en: Icinga2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like Nagios (which is where it was originally derived from), Icinga2 has the
    concept of a central server, with agents on other hosts that it can keep an eye
    on.
  prefs: []
  type: TYPE_NORMAL
- en: We're going to install `Icinga2` on our `centos2` VM, and then monitor our `debian2`
    VM from our first host.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started, jump on to `centos2` and install `Icinga2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Note the forwarding section; this will be for the GUI setup later on (port
    `8181`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Run through the `mariadb` installation script (the root password is blank by
    default; set it to something you''ll remember):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Now set up `mariadb` for `icinga`. This information can be found in the Icinga2
    *Getting Started* guide, [https://icinga.com/docs/icinga2/latest/doc/02-getting-started/#setting-up-icinga-web-2](https://icinga.com/docs/icinga2/latest/doc/02-getting-started/#setting-up-icinga-web-2):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, import the supplied `schema` database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Enable the actual plugin in `icinga2`, and `restart` the service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Once the database setup is done, we can move on to the actual web installation.
  prefs: []
  type: TYPE_NORMAL
- en: We included `httpd` (apache) in the installation step of this section, because
    it's what Icinga2 recommends, though NGINX can be used too (and indeed is the
    default on FreeBSD).
  prefs: []
  type: TYPE_NORMAL
- en: 'Begin by starting and enabling it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, enable the `api` feature of `icinga2` and `restart` it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'A root user and random password will be added to `api-users.conf`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Icinga2 web also needs **FastCGI Process Manager** (**FPM**) enabled, so do
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Once done, you should be able to hit the installed Icinga2 web setup in your
    browser (using our forwarded connection), `http://127.0.0.1:8181/icingaweb2/setup`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/418175ed-c6da-4386-8a55-aa12020cc694.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To find your setup code, get back to your `centos2` command line and run the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Enter your code and click next through the installation (making sure there''s
    no *red* on the Requirements page; yellow is okay for the Imagick PHP module):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a85453fc-6c09-4b90-abb3-576789240e6b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When prompted for the authentication type, choose Database:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4f809e92-2931-4edc-ba1d-18a8af575535.png)'
  prefs: []
  type: TYPE_IMG
- en: 'On the next page, you''ll be prompted to provide a database name, a database
    username, and a database password. Choose suitable values (don''t worry if they''re
    not created yet, we''ll do that next):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e6709c08-24cb-40e8-a811-5d75f20457ae.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, you can see I chose `icinga2web` for the database name and username. Click
    Next.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the screen immediately following, you will be asked to pass in the credentials
    of a user who can access MariaDB to create the new database; I chose to use the
    MariaDB root user we set earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7a186994-1e24-489e-8d15-c669d52da5c2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You''ll be prompted to choose a Backend Name, which is an aesthetic decision
    so that you can recognise the backend later:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b08dae41-6c95-4f48-9e16-6b20dc7b490b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'And you''ll be asked to create a web user; I went with `icingaweb`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/59edf32f-5a7b-4aac-8a9b-5fa4503253bd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'I kept the Application Configuration as the default:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b5fd06f3-1308-4536-9d4d-c47d17209882.png)'
  prefs: []
  type: TYPE_IMG
- en: Lastly, you'll be prompted to confirm the settings you've put in; have a quick
    once-over before continuing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Clicking Next a couple more times brings you to the Monitoring Backend setup
    (where IcingaWeb2 looks to find the monitoring database):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/18c564de-06cb-4320-9e00-1facfbeefb88.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You''ll be prompted to add connection details that can be used to query the
    icinga database (which we set up using the MariaDB CLI ealier in this chapter).
    We set the following defaults: username `icinga`, and password `icinga`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/89952058-3cfb-4e43-9896-63d30c8459fc.png)'
  prefs: []
  type: TYPE_IMG
- en: Use the Validate Configuration button to validate your configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the Command Transport screen, you''ll be prompted to enter the details of
    the API user we created. We only added root, so let''s use that for now (from
    the api-users.conf file earlier):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/519a6afc-0555-457b-bb4a-d6e3c6a6ad72.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Click Next until you get to the end, where you should end up with a happy green
    banner:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/74efcfd9-db3e-42a3-8718-e5260453aefc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Continue to the prompted login page, and log in with the web user we created:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/794eaac0-b52c-4c84-8368-878e5ea5e0f5.png)'
  prefs: []
  type: TYPE_IMG
- en: Icinga2 Login Page
  prefs: []
  type: TYPE_NORMAL
- en: 'The design might have changed a bit by the time you get around to reading this
    book, but hopefully you have something that''s close to the following Icinga2
    Dashboard:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/453460db-87ee-45ac-96ee-d234bab7e2ad.png)'
  prefs: []
  type: TYPE_IMG
- en: Have a poke around, before moving onto the next section, where we'll add another
    host.
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, we have to establish our first server as the `master` before we install
    `icinga2` on our client.
  prefs: []
  type: TYPE_NORMAL
- en: 'You do this with a setup script; I''ve put the only change needed in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Do as it suggests and restart `icinga2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Generate a token for our client to use when connecting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Now SSH to your `debian2` box and install `icinga2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Run through the node installation, this time specifying that we''re an agent,
    and passing in the token from earlier when prompted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'Restart `icinga2` on `debian2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to configure the master to actually check the client; we''ve got
    an established connection, viewable with `ss`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, back on `centos2`, add the following configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `hosts` directory for the zone in question:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'And add an appropriate `hosts` configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'Restart `icinga2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, you should see your client in the Icinga2 web GUI:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bcfba0b9-6f14-4d09-8c93-4f6085eb250d.png)'
  prefs: []
  type: TYPE_IMG
- en: Icinga2 Hosts page with pending checks
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s a bit useless to just have ping check a host (well, mostly; ping alerts
    have saved me before), so let''s add some of the recommended service checks too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: Restart the service again.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'Looking back at our GUI, this will now show our `debian2` box with some services
    checks (where one of the five failed):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3ac8e7f5-d3a1-4f26-958d-562a904cbfb2.png)'
  prefs: []
  type: TYPE_IMG
- en: Icinga2 Hosts page with ‘debian2’
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By having a master server that is capable of seeing other servers in an estate,
    you give yourself the visibility needed to know when problems have occurred that
    need your immediate attention.
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring tools such as Nagios and Icinga2 usually work by interacting with
    a remote machine, querying its status by using either scripts on the box, or custom
    commands remotely, and reporting on the output of those commands. This can be
    done in a variety of ways, including, but not limited to, the NRPE agent, remote
    SSH commands, or SNMP results queried from an SNMP daemon.
  prefs: []
  type: TYPE_NORMAL
- en: By creating a single-source-of-truth on the state of your infrastructure, you
    can learn immediately when there's a problem with your estate, and even correlate
    data based on multiple symptoms seen.
  prefs: []
  type: TYPE_NORMAL
- en: Icinga2, Nagios, Zabbix, and Sensu all behave in a relatively similar fashion,
    and all ultimately are good tools for the job, but usually it's down to the personal
    preference of the implementing team (or individual) as to which is adopted.
  prefs: []
  type: TYPE_NORMAL
- en: You won't go wrong by installing Nagios and having a play around with it, as
    it's easily the one I've come across the most in the wild, and its children/cousins
    rule the scene at the moment.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here, we spun up a Nagios and Icinga2 installation quickly, to show what both
    are capable of with a few simple commands. These configurations aren't production-ready,
    and consideration should be given to things such as reusable patterns for monitoring
    checks, as well as security (for things such as TLS on the GUI, and utilizing
    secure communication methods between the master and the clients).
  prefs: []
  type: TYPE_NORMAL
- en: As with a lot of the software in this book, you should now have a good understanding
    of how to get started, but should consider all your options when implementing
    a solution for your own systems. If you have a relatively small pool to monitor,
    and it's unlikely to grow, you might considers the Nagios file-based monitoring
    setup suitable; if you have a larger, multi-region spanning estate, you may find
    Icinga2 and its zones more to your liking.
  prefs: []
  type: TYPE_NORMAL
- en: We also didn't touch on emails and alerting, only mentioning the visual alerts
    that Nagios and Icinga2 produce. There are multiple ways of plugging alerts into
    both solutions (such as SMS alerts, or flashing bulbs in the corner of the room)
    but, out of the box, they both handle email relatively well (assuming you've got
    a functional email server to pass alerts through).
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, this is just a getting started guide, and there are many more ways to
    set up both Icinga2 and Nagios. They can be thought of more as frameworks than
    software in a lot of ways, being a fairly blank canvas out of the box and still
    enabling you to build a production system in as complex or simple a fashion as
    you wish.
  prefs: []
  type: TYPE_NORMAL
- en: I've come across Icinga2 installations where I've been immensely cocky and sure
    of myself (more so than usual), only to start scratching my head 5 minutes in
    as I tried to unpick the mess of hand-cranked configuration that had been left
    for me.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The monitoring plugins we used here are interesting, because there was a bitter
    argument some years ago when the old `nagios-plugins.org` domain was repointed
    from an independently maintained server to one controlled by Nagios Enterprises.
  prefs: []
  type: TYPE_NORMAL
- en: What followed this repointing was an argument and split, which resulted in `monitoring-plugins`
    and `nagios-plugins` becoming seperate entities. For what it's worth, `nagios-plugins`
    is an alias to `monitoring-plugins` on Debian systems at the time of writing.
  prefs: []
  type: TYPE_NORMAL
- en: More information can be found in this blog post: [https://www.monitoring-plugins.org/news/new-project-name.html](https://www.monitoring-plugins.org/news/new-project-name.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'The Debian bug report can be found here: [https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=736331](https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=736331).'
  prefs: []
  type: TYPE_NORMAL
- en: 'And here''s the Red Hat bug report, with added drama (don''t get involved):
    [https://bugzilla.redhat.com/show_bug.cgi?id=1054340](https://bugzilla.redhat.com/show_bug.cgi?id=1054340).'
  prefs: []
  type: TYPE_NORMAL
- en: Centralizing logging with the Elastic Stack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Earlier, we mentioned solutions to remote logging that involved forwarding our
    logging solutions (`syslog` and `journald`) to other hosts, running the same or
    similar software, so that the logs could be aggregated in one spot.
  prefs: []
  type: TYPE_NORMAL
- en: This is a nice solution, and works well in a small environment, but it's not
    got a lot of bells and whistles, and if there's one thing we like in IT, it's
    shiny things we can show to management and then never use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Elastic Stack is one such product; in their own words:'
  prefs: []
  type: TYPE_NORMAL
- en: Built on an open source foundation, the Elastic Stack lets you reliably and
    securely take data from any source, in any format, and search, analyze, and visualize
    it in real time.
  prefs: []
  type: TYPE_NORMAL
- en: Bold claims, but certainly with backing. Elastic Stack is now the *de facto*
    aggregate logging solution for most businesses above a medium size, perhaps with
    a few contenders at the enterprise level.
  prefs: []
  type: TYPE_NORMAL
- en: We're going to set up a small solution on `centos1`, and forward our logs from
    `centos2`, `debian1`, and `debian2` to it.
  prefs: []
  type: TYPE_NORMAL
- en: I've spent the day wrestling with X-Pack and Elastic Stack, so if anything I
    write sounds sarcastic or mean spirited, it's probably intentional.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we're going to use all our VMs, and it might be an idea to
    `vagrant destroy` and `vagrant up` them all first.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that, for this section, we're going to be installing the version
    6 release of certain Elastic Stack components. The configuration has changed historically,
    and may do again by the time you read this book; if anything doesn't work as you
    expect, refer to the Elastic documentation for your version to fill in the gaps.
  prefs: []
  type: TYPE_NORMAL
- en: For this section, we're going to run through the initial setup on `centos1`,
    then pop onto the other VMs and configure their logging destination.
  prefs: []
  type: TYPE_NORMAL
- en: 'Mostly, I don''t suggest this, but it might be a good idea to reset your VMs
    to a fresh starting point for this bit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: For convenience, and because this isn't a book on installing and configuring
    the Elastic Stack, we're going to run through an installation of Elasticsearch,
    Kibana, and Logstash in quite rapid fashion.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need Java:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'On `centos1`, let''s grab the Elastic repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to install the various components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'And we need to start them, with a number of configuration tweaks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re going to use the Elastic `syslog` example (from [https://www.elastic.co/guide/en/logstash/6.4/config-examples.html#_processing_syslog_messages](https://www.elastic.co/guide/en/logstash/6.4/config-examples.html#_processing_syslog_messages))
    to configure our `Logstash` setup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: This configuration sets an input method for data, in this case `tcp` and `udp`
    ports `5000`. It then sets a filter up for `syslog` content, and finally sets
    up an output to Elasticsearch (the backend, if you will).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can start `Logstash`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'What you should see are various ports listening on your box (this may take
    some time, as the various components start up):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can configure our other machines to point to `Logstash` on `centos1`.
  prefs: []
  type: TYPE_NORMAL
- en: centos2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Use the following `rsyslog` change to start forwarding `centos2` logs to `Logstash`
    of the `centos1` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: I recommended rebuilding the VMs earlier, but if you haven't, the preceding
    command may need tweaking if you followed the earlier sections about remote `syslog`
    configuration. Open the file and confirm the line looks as you expect.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can test your configuration by using the following on `centos2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: debian1 and debian2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For the Debian configuration, use the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: Kibana
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have data in `Logstash`, but unless you've jumped the gun a bit, you won't
    be able to see it yet.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you''ve forwarded your connection to `centos1`, as indicated at the start
    of this section, you should be able to navigate to `http://localhost:5601` in
    the browser of your choosing, and be greeted by the Kibana start page (assuming
    your installations have gone okay):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/678d1175-46d4-4ed6-8e6b-4e1ec995cb75.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you''ve used Kibana before, you might expect to click Discover and see your
    logs, but instead you get kicked over to Management:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4e3e7767-5499-4753-a139-9c29b664d3e9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Enter `*` as the wildcard entry for the index pattern, and then click Next
    step on the right:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/efc2e6ad-9dbf-44e6-b2aa-2903645d7a83.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the next section, choose @timestamp from the drop-down list provided and
    then click Create index pattern on the right:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9245b99d-c040-4309-91b7-ad23d2510abe.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once the index has been created, click Discover on the left-hand side again;
    this time, you should be given a proper view:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8ac19d25-18ed-40f8-a86d-914f25a3e7ba.png)'
  prefs: []
  type: TYPE_IMG
- en: Obviously, we want to filter down, just to make sure we've got everything.
  prefs: []
  type: TYPE_NORMAL
- en: 'Put the following filter query in the search box at the top:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d7a019b9-e10a-473d-8869-d80ec1afdaf2.png)'
  prefs: []
  type: TYPE_IMG
- en: Kibana Discover Page
  prefs: []
  type: TYPE_NORMAL
- en: If there's no data visible in Kibana, it's possible that Logstash wasn't fully
    started before you sent logs from the other hosts. Try sending your logs again
    using the  `logger` commands above.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What we''re effectively doing is setting up three things:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Elasticsearch**: To act as the storage point for all the data we want to
    pipe into our box'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Kibana**: To act as the frontend and dashboard to our data, meaning we can
    query and peruse it at our leisure'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Logstash**: To create a listener that acts just like the `syslog` receiver
    we set up earlier on in this chapter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When all three of these components are enabled, they create a way to centralize
    any logs (or other data) that we might wish to throw at our solution.
  prefs: []
  type: TYPE_NORMAL
- en: It's basically a pretty way of making a `syslog` receiver, which also happens
    to be capable of a lot more besides.
  prefs: []
  type: TYPE_NORMAL
- en: One thing we didn't do here was forward our logs from `centos1` to its own `Logstash`
    listener; this can be done, but does require a bit of tweaking to ensure you don't
    accidentally create a storm of logs that grow exponentially as its own log messages
    are fed back into itself. I may or may not have done this once.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Elastic Stack isn't just Elasticsearch, Kibana, and Logstash there are also
    more tools and features that are completely modular and can be integrated into
    your installation as you wish.
  prefs: []
  type: TYPE_NORMAL
- en: 'They include, but aren''t limited to, the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Heartbeat – for uptime monitoring
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filebeat – for sending logs from remote machines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Machine learning capabilities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We also set up a very noddy solution here, and one I certainly wouldn't use
    in production. It lacks security on the transported data, streaming plain logs
    to our receiver, and there's also no login prompt to secure the Kibana dashboard,
    or TLS for security in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: X-Pack is one way to solve these problems, available as a trial in the default
    installation, or through a license, which is going to cost you. It allows you
    to set up security in your installation, both node communication and login security
    (with things such as the Kibana user login).
  prefs: []
  type: TYPE_NORMAL
- en: The Elastic Stack is also quite a resource hungry suite of software, and you
    might want to architect your solution properly before diving right in and installing
    it on the medium-sized box in the cupboard.
  prefs: []
  type: TYPE_NORMAL
- en: Roundup - Monitoring and Logging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While it's no one's favorite subject (outside some very strange individuals
    I know, one of whom is a technical editor for this book), logging and monitoring
    is a crucial part of any installation, big or small.
  prefs: []
  type: TYPE_NORMAL
- en: You want to know when your boxes have died or, better yet, when they're about
    to die, and you also want to be able to retroactively work out why they conked
    out in the first place.
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring and logging can be as complex or simple as you want it to be. Some
    companies hire specific individuals to deal with these components in a silo, but,
    in smaller organizations, it could very well be you who ends up managing and configuring
    everything. If this is the case, then I currently recommend setting up Icinga2
    and some sort of Elastic Stack implementation, but your needs and budget may vary.
  prefs: []
  type: TYPE_NORMAL
- en: One elephant in the room that we need to talk about is on-call, and the fact
    that you're probably going to do it at some point in your career (unless you've
    got to the blessed point where you can say "I've done my time" and leave it for
    lesser mortals to undertake).
  prefs: []
  type: TYPE_NORMAL
- en: In general, monitoring is your friend when doing on-call, and while, in an ideal
    world, you'd never get called out because of a problem, you can at least set up
    things such as automated phone calls to wake you up, before something becomes
    a wider issue that someone else notices outside of your company. You don't want
    to be in the situation where your company website is down all weekend, and you
    lose thousands of pounds of sales.
  prefs: []
  type: TYPE_NORMAL
- en: Over time, logs and long-term monitoring data can also help to highlight issues
    that you didn't realize were recurring, because the time between events is weeks
    or even months; this is a good reason for setting up historic alerts and pattern
    matching on dashboards in Kibana.
  prefs: []
  type: TYPE_NORMAL
- en: If someone is having to clear logs on a box every 5 weeks, and it's a different
    person in the team each time, you might not realize that there's a bigger underlying
    issue that needs addressing, or you might just find you've lost hundreds of hours
    over an issue that could be fixed with a simple `systemd` timer.
  prefs: []
  type: TYPE_NORMAL
- en: On the whole, I hate monitoring, and I'm loath to trawl through logs, but they're
    necessary in our line of work, and there's a lot of clever people making very
    swish tools that you can use to make your life easier.
  prefs: []
  type: TYPE_NORMAL
- en: It also doesn't hurt when you have to show off a dashboard to the CEO, and they're
    distracted by the pretty widgets and whistles.
  prefs: []
  type: TYPE_NORMAL
