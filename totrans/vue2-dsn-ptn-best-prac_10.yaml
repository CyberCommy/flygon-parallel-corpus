- en: Testing Vue.js Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a world with tight deadliness and accelerating requirements, creating automated
    tests for our applications becomes more important than ever. An important factor
    to consider, which most developers overlook, is the fact that testing is a skill,
    and just because you may be comfortable coding up solutions, it doesn't automatically
    mean that you can write good unit tests. As you get more experience in this area,
    you'll find yourself writing tests more often and wonder what you ever did without
    them!
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of this chapter, we will cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Learning about why you should consider using automated testing tools and techniques
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing your first unit test for Vue components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing tests that mock out particular functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing tests that are dependent on Vue.js events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Wallaby.js to see the results of our tests in real time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we talk about testing our Vue projects, we can mean different things, depending
    on the context.
  prefs: []
  type: TYPE_NORMAL
- en: Why testing?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Automated testing tools exist for a reason. When it comes to testing the work
    that we've created manually, you'll know from experience that this is a long,
    (sometimes complex) process that does not allow for consistent results. Not only
    do we have to manually remember whether a particular component works (or otherwise
    write the results down somewhere!), but it isn't resilient to change.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some phrases I''ve heard over the years when testing has been brought
    up:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"But Paul, if I write tests for my application it''ll take three times as
    long!"*'
  prefs: []
  type: TYPE_NORMAL
- en: '*"I don''t know how to write tests..."*'
  prefs: []
  type: TYPE_NORMAL
- en: '*"That''s not my job!"*'
  prefs: []
  type: TYPE_NORMAL
- en: '...and a variety of others.'
  prefs: []
  type: TYPE_NORMAL
- en: The point is that testing is a skill in the same sense that development is a
    skill. You may not be immediately great at one or the other, but with time, practice,
    and perseverance, you should find yourself in a position where testing feels natural
    and a normal part of software development.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Automated testing tools take the manual work we'd be doing each time we want
    to verify that our feature works as expected, and give us a way to run a command
    that tests our assertions one by one. This is then shown to us in reports (or
    live in our editor, as we'll see later on), which gives us the ability to refactor
    code that isn't working as intended.
  prefs: []
  type: TYPE_NORMAL
- en: By using automated testing tools, we're saving ourselves a vast amount of effort
    when compared to manual testing.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing can be defined as a type of testing that only tests one "unit"
    (the smallest testable part of a feature) at a time. We can then automate this
    process to continually test our features as the application gets larger. At this
    point, you may wish to follow Test-Driven Development/Behavior Driven-Development
    practices.
  prefs: []
  type: TYPE_NORMAL
- en: In the modern JavaScript testing ecosystem, there are a variety of test suites
    available. These test suites can be thought of as applications that give us the
    ability to write assertions, run our tests, provide us with coverage reports,
    and much more. We'll be using Jest inside our project, as this is a fast and flexible
    suite created and maintained by Facebook.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a new playground project so that we can get familiar with Unit
    testing. We''ll be using the `webpack` template instead of the `webpack-simple`
    template, as this allows us to configure testing by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s start off by investigating the `test/unit/specs` directory. This is
    where we''ll be placing all of our unit/integration tests when testing our Vue
    components. Open up `HelloWorld.spec.js`, and let''s go through it line by line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then run these tests by running `npm run unit` inside our Terminal (ensure
    that you''re in the project directory). This will then tell us how many tests
    have passed as well as the overall test code coverage. This metric can be used
    as a way to determine how robust an application is in 60; most circumstances;
    however, it should not be used as gospel. In the following screenshot, we can
    clearly see how many of our tests have passed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/86d9e86c-4b1a-405c-a910-2e40e1d5b0c6.png)'
  prefs: []
  type: TYPE_IMG
- en: Setting up vue-test-utils
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For a better testing experience, it''s advised to use the `vue-test-utils`
    module as this provides us with many helpers and patterns that are exclusively
    used with the Vue framework. Let''s create a new project based on the `webpack-simple`
    template and integrate Jest and `vue-test-utils` ourselves. Run the following
    in your Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we have to add some extra configuration to our project so that we can
    run Jest, our test suite. This can be configured inside our project''s `package.json`.
    Add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This means that any time we want to run our tests, we simply run `npm run test`
    inside our Terminal. This runs the local (project installed) version of Jest on
    any files that match the `*.spec.js` name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to tell Jest how to handle Single File Components (that is, `*.vue`
    files) within our project. This requires the `vue-jest` preprocessor. We''ll also
    want to use ES2015+ syntax inside of our tests, so we''ll also need the `babel-jest`
    preprocessor. Let''s install both by running the following in the Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then define the following object inside `package.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This is essentially telling Jest how to handle both JavaScript and Vue files,
    by knowing which preprocessor to use (that is, `babel-jest` or `vue-jest`), depending
    on the context.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also make our tests run quicker if we tell Babel to only transpile features
    for the Node version we''re currently loading. Let''s add a separate test environment
    to our `.babelrc` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now that we've added the appropriate configuration, let's start testing!
  prefs: []
  type: TYPE_NORMAL
- en: Creating a TodoList
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s now create a `TodoList.vue` component inside `src/components` folder.
    This is the component that we will be testing, and we''ll slowly add more features
    to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we just have a simple application that returns an array of
    to-dos with varying items. Let''s create a router inside `src/router/index.js`
    to match our new `TodoList` component and display it as the root:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'As we''re using `vue-router`, we''ll also need to install it. Run the following
    in your Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then add the router to `main.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'I''ve now added `router-view` and elected to remove the Vue logo from `App.vue`,
    so we have a cleaner user interface. Here''s the template for `App.vue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see in our browser, it displays our template with the name of TodoList
    and the `todo` items we created as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/4705e2e3-e78b-4168-843a-f001df506d5d.png)Let''s write some tests
    for this component'
  prefs: []
  type: TYPE_NORMAL
- en: Writing tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Inside the `src/components` folder, make a new folder named `__tests__` and
    then create a file named `TodoList.spec.js`. Jest will automatically find this
    folder and subsequent tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first import our component and the `mount` method from the test utilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `mount` method allows us to test our `TodoList` component in isolation
    and gives us the ability to mock any input props, events, and even outputs. Next,
    let''s create a describe block that we''ll use to contain our test suite:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now mount the component and gain access to the Vue instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to define the `it` block to assert the outcome of our test case.
    Let''s make our first expectation—it should render a list of to-do items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We can watch changes for our tests by running `$ npm run test -- --watchAll`
    in the Terminal. Alternatively, we can make a new script inside `package.json`
    that does this for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Now, if we run `npm run test:watch` inside of the Terminal, it will watch the
    filesystem for any changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are our results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/d9584d12-d6b4-466b-b8ee-6f20344a45fb.png)'
  prefs: []
  type: TYPE_IMG
- en: That's interesting. We have a passing test! However, we have to think to ourselves
    at this point, is this test brittle? In a real-world application, we may not have
    items inside our `TodoList` at runtime by default.
  prefs: []
  type: TYPE_NORMAL
- en: We need a way to set properties on our isolated tests. This is where the ability
    to set our own Vue options comes in handy!
  prefs: []
  type: TYPE_NORMAL
- en: Vue options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can set our own options on a Vue instance. Let''s use `vue-test-utils` to
    set our own data on the instance and see whether this data is being rendered on
    screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, we're now testing against the items rendered on the screen based
    on the data option within our component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add a `TodoItem` component so that we can render a component with a
    `todo` prop dynamically. We can then test this component''s output based on our
    prop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then add it to the `TodoList` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Our tests still pass as expected, because the component is rendered into `li`
    at runtime. It may be a better idea to change this to find the component itself
    though:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s write some tests for our `TodoItem` and create a `TodoItem.spec.js`
    inside `components/__tests__`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'As we''re essentially using the same logic, our test is similar. The main difference
    is that instead of having a list of `todos`, we just have one `todo` object. We''re
    mocking the props with `propsData` instead of data, essentially asserting that
    we can add properties to this component and it renders the correct data. Let''s
    take a look at whether our tests passed or failed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/b7a2c79e-b9aa-4ad1-a0bc-ae7bd88e18df.png)'
  prefs: []
  type: TYPE_IMG
- en: Adding new features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s take a test-driven approach to adding new features to our application.
    We''ll need a way to add new items to our `todo` list, so let''s start by writing
    our tests first. Inside `TodoList.spec.js`, we''ll add another `it` assertion
    that should add an item to our `todo` list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run our tests right now, we''ll get a failing test this is expected!:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ae1c7364-7229-4b62-9446-c816ed199fc3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s do the minimum possible to fix our error. We can add a method named
    `addTodo` inside our Vue instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we get a new error; this time, it states that it Cannot read property ''length''
    of undefined, essentially saying that we have no `newTodos` array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ea3aa57b-9c65-4a84-a90f-9f2b57cbc0b8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s make our `addTodo` function return an array that combines the current
    `todos` with a new todo:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We get this output after running `npm test`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/207f504d-745c-4ddc-970e-83c8a300387d.png)'
  prefs: []
  type: TYPE_IMG
- en: Ta-da! Passing tests.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm. I do remember all of our `todo` items having an appropriate `id`, but it
    looks like that's no longer the case.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ideally, our server-side database should handle `id` numbers for us, but for
    now, we can work with a client-side generated `uuid` using the `uuid` package.
    Let''s install it by running the following in the Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then write our test case to assert that each item added to the list
    has an `id` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the Terminal outputs that we have an issue, and this is caused
    because we evidently don''t have an `id` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/b651c0c2-e3c0-4d1b-b204-fa2c3e02a57e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s use the `uuid` package we installed earlier to achieve this goal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We then get a passing test:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/19d3db16-8823-471d-bd6b-047022afcf56.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Starting off with a failing test is beneficial for multiple reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: It ensures that our test is actually running and we don't spend time debugging
    anything!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We know what we need to implement next, as we're driven by the current error
    message
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can then write the minimum necessary to get a green test and continue to
    refactor our code until we're satisfied with our solution. In the previous tests,
    we could have written even less to get a green result, but for brevity, I've elected
    for smaller examples.
  prefs: []
  type: TYPE_NORMAL
- en: Click events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Great! Our method works, but that''s not how our user will be interacting with
    the application. Let''s see whether we can make our tests take into account a
    user input form and subsequent button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also make a small change to our `addTodo` function, ensuring that `this.todos`
    is given the value of the new `todo` items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The great thing is that by making this change, we can check against all of our
    previous use cases and see that nothing fails! Hurray for automated testing!
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s make an `it` block that we can use to assert that whenever our
    Submit button is clicked on, an item is added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we can get the form element from within the wrapper using find, and this
    allows us to then trigger an event. As we''re submitting a form, we''ll trigger
    the submit event and pass along a parameter to our `submit` function. We can then
    assert that our `todo` list should be `1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also check to see whether the appropriate method was called when the
    form is submitted. Let''s do that using `jest`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Testing events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve made a lot of progress, but wouldn''t it be great if we could test events
    that fire between components? Let''s take a look at this by creating a `TodoInput`,
    component and abstracting our form away into `this` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, our `addTodo` method inside of `this` component fires an event. Let''s
    test that event within a `TodoInput.spec.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: We're introduced to a new concept inside of this method—`mock`. This allows
    us to define our own behavior and subsequently determine what the event was called
    with.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the `addTodo` event is fired, the `mock` function is called instead.
    This allows us to see whether our event is being called and also ensures that
    the event can take a payload.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also ensure that the `TodoList` handles `this` event, but firstly, ensure
    that you''ve updated the `TodoList` to include the `TodoInput` form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, inside our `TodoList.spec.js`, we can start off by importing `TodoInput`
    and then add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Apart from that, we can also ensure that the event does what it''s supposed
    to do; so when we fire the event `it` adds an item to the array and we are testing
    for the array length:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Using Wallaby.js for a better testing experience
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can also use Wallaby.js to see the results of our unit tests in real time
    within our editor. It''s not a free tool, but you may find it useful when creating
    test-driven Vue applications. Let''s start off by cloning/downloading a project
    that already has Wallaby set up. Run the following in your Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: We can then open this up inside our editor and install the Wallaby.js extension
    inside our editor. You can find a list of supported editors and instructions at
    [https://wallabyjs.com/download/](https://wallabyjs.com/download/).
  prefs: []
  type: TYPE_NORMAL
- en: 'I''ll be installing this within Visual Studio Code, which starts by searching
    the extensions marketplace for Wallaby:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/4fe32175-7e93-4710-b862-8276517d2d16.png)'
  prefs: []
  type: TYPE_IMG
- en: We can then tell Wallaby about the project's configuration file (`wallaby.js`),
    by pressing *CMD* + *SHIFT + =* on Mac or *CTRL* + *SHIFT + =* on Windows. From
    the drop-down, click on Select Configuration File and subsequently, type `wallaby.js`.
    This will allow Wallaby and Vue to work together.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start Wallaby, we can open the configuration menu again and select Start.
    We can then navigate to the `tests/unit/specs/Hello.spec.js` file, and we should
    see varying blocks in the line margins of the editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/5fa8444b-706f-4426-9556-3106fa8d1712.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As everything is green, we know that it has passed! What if we change the implementation
    details of the test? Let''s purposely make one or more of our tests fail:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/17998166-4cf0-4664-9507-83e3d278c611.png)'
  prefs: []
  type: TYPE_IMG
- en: Everything stays green apart from the 'should render correct contents' block,
    which can be seen down the left-hand side. This is because we now have a failed
    assertion, but more importantly, we don't have to rerun our tests, and they're
    displayed instantly within our editor. No more Alt-Tab-ing between different windows
    to watch our test output!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter saw us learn about how to appropriately test our Vue components.
    We learned how to follow the fail-first approach to write tests that drive our
    development decisions as well as how to take advantage of Wallaby.js to see the
    results of our tests from within our editor!
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll learn how we can combine our Vue.js applications
    with modern Progressive Web Application techniques, such as service workers, application
    manifests, and much more!
  prefs: []
  type: TYPE_NORMAL
