- en: Chapter 8.  Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We already asserted multiple times throughout the book that pure functions are
    easier to test; it is time we prove it. In this chapter, we will first present
    a small glossary about the topic in order to ensure we speak a common language.
    We will then continue with how a functional approach helps with traditional testing.
    Finally, we will learn about a different way to test code, called **property-based
    testing**.
  prefs: []
  type: TYPE_NORMAL
- en: None of the subjects of this chapter are strictly confined to functional programming;
    you will be able to use anything in any legacy codebase. Also, this is not a book
    about testing, so we will not go into every detail. It is also assumed that you
    have some prior knowledge about testing code in PHP.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Small testing glossary
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing pure functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test parallelization as a speed-up technique
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Property-based testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing vocabulary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I won't claim to give you a complete glossary of all testing-related terms and
    also I won't explain the subtle differences and interpretations that could be
    made for each of them. The idea of this section is simply to lay some common ground.
  prefs: []
  type: TYPE_NORMAL
- en: 'The glossary won''t be in alphabetical order, but rather terms will be grouped
    by categories. Also, it must by no means be considered a complete glossary. There
    are a lot more terms and techniques that pertain to testing than what will be
    presented here, especially if you include all testing methods related to performance,
    security, and usability:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Unit testing**: Tests conducted against each individual component separately.
    What is considered a *unit* varies-a function/method, a whole class, a whole module.
    Usually, dependency to other units is mocked to cleanly isolate each part.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Functional testing**: Tests the software as a black box to ensure that it
    meets the specifications. External dependency is usually mocked.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integration testing**: Tests conducted against the whole application and
    its dependencies, including external ones, to ensure that everything integrates
    correctly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Acceptance testing**: Tests conducted by the final customer / end user against
    a set of agreed-upon criteria.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Regression testing**: Repeats a test after some change is made to ensure
    no issues were introduced in the process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fuzz testing / Fuzzing**: Tests conducted by inputting massive amounts of
    (semi) random data in order to make it crash. This helps discover coding errors
    or security issues.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ad-hoc testing**: Tests performed with no formal framework or plan.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Component testing**: See *unit testing*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Blackbox testing**: See *functional testing*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Behavioral testing**: See *functional testing*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**User Acceptance testing** (**UAT)**: See *acceptance testing*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Alpha version**: Usually, the first version that is tested as a black box.
    It can be unstable and cause data loss.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Beta version**: Usually, the first version that is feature-complete and in
    a state good enough to be released to external people. It can still have serious
    issues and should not be used in a production environment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Release Candidate **(**RC)**: A version that is deemed stable enough to be
    released to the public for a final test. Usually the last RC is "promoted" as
    the released version.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mocking (mock)**: Creating components that imitate other parts of the software
    or an external service to test only the matter at hand.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stubbing** (**stub)**: See *mocking*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Code coverage**: The percentage of the application code or features that
    is covered by the tests. It can have different granularity: by lines, by functions,
    by components, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Instrumentation**: The process of adding code to the application in order
    to test and monitor behavior or coverage. It can be done manually or by a tool
    either in the source, in a compiled form, or in-memory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Peer review**: A process where one or multiple colleagues examine the produced
    work such as code, documentation, or anything pertaining to the release.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Static analysis**: Analysis the application without running it, usually done
    by a tool. It can provide information about coverage, complexity, coding style,
    or even found issues.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Static testing**: All of the testing and reviews performed without executing
    the application. See *peer review* and *static analysis*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Smoke tests**: Superficially testing the main parts of an application to
    ensure the core features work.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Technical review**: See *peer review*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Decision point**: A statement in the code where a change in the control flow
    can happen, typically an `if` condition.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Path**: The sequence of statements executed from the beginning of the function
    to the end. A function can have multiple paths depending on its decision point.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cyclomatic complexity**: A measure of the complexity of a piece of code.
    There are various algorithms to compute it; one is "number of decision points
    + 1".'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Defect**, **failure**, **issue,** or **bug**: Anything that does not work
    as expected in the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**False-positive**: A test result seen as a defect when in fact everything
    works fine.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**False-negative**: A test result seen as a success when in fact there is a
    defect.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Test-driven Development** (**TDD)**: A development methodology where you
    start by writing a test and then the minimum amount of code to make it pass before
    repeating the process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Behavior-driven Development** (**BDD)**: A development methodology based
    on TDD where you describe behavior using a domain-specific language instead of
    writing traditional tests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Type-driven Development**: A running joke in the functional world where you
    replace tests with a strong type system. Depending on whom you ask, the idea might
    be taken more or less seriously.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**X-driven Development**: There is a new best development methodology created
    every week; the website [http://devdriven.by/](http://devdriven.by/) tries to
    reference them all.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing pure functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we just saw in the glossary, there are a lot of potential ways to test an
    application. In this section, we will, however, limit ourselves to tests at the
    function level; or in other words, we will do unit testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, what makes pure functions so much easier to test? There are multiple reasons;
    let''s start by enumerating them and we will then see why with real test cases:'
  prefs: []
  type: TYPE_NORMAL
- en: Mocking is simplified as you only need to provide input arguments. No external
    state to create, no singletons to stub.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Repeated calls will yield exactly the same result for a given arguments list,
    whatever the time of day or previously run tests. There is no need to put the
    application in a certain state.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functional programming encourages smaller functions doing exactly one thing.
    This usually entails test cases that are easier to write and understand.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Referential transparency usually means you need fewer tests to gain the same
    level of trust in your code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The absence of side-effects guarantees that your test will have no consequences
    on any other subsequent tests. This means you can run them in any order you want
    without worrying about resetting the state between each test or running them in
    isolation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some of these claims may seem a bit bold to you, or maybe you are unsure why
    I made them. Let's take some time to verify why they are true with examples. We
    will separate our examples into four different parts to makes things easier to
    follow.
  prefs: []
  type: TYPE_NORMAL
- en: All inputs are explicit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we discovered earlier, a pure function needs to have all of its inputs as
    arguments. You cannot rely on some static method from a singleton, generate random
    numbers, or get any kind of data that can change from an external source.
  prefs: []
  type: TYPE_NORMAL
- en: The corollary is that you can run your test at any time during the day, on any
    environment, and for any given list of arguments, and the output will stay the
    same. This simple fact makes both writing and reading tests a lot easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine you have to test the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The problem is that, when you call the function, you need to know what time
    it is so you can check whether the return value is correct. This fact leads to
    some issues:'
  prefs: []
  type: TYPE_NORMAL
- en: You basically have to re-implement the function logic inside the test, thus
    possibly having the same bug in both the test and the function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a slight chance that, between the time you computed the expected value
    and the function gets the time again to return a result, a minute elapsed, changing
    the current hour and thus the function result. Those kinds of false positive are
    a real headache to debug.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You cannot test all possible outputs without somehow manipulating the system
    clock.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The dependency to the current time being hidden, the person reading the test
    can only infer what the function is doing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By simply moving the `$hour` variable as a parameter, we solve all the previously
    mentioned issues.
  prefs: []
  type: TYPE_NORMAL
- en: Also, if you use a test runner that allows you to create a data provider for
    your tests, such as **PHPUnit** or **atoum**, testing the function becomes as
    simple as creating a provider that creates a list of hours associated with the
    expected return and simply feeds the time to the function and checks the result.
    This test is a lot simpler to write, understand, and expand than anything else
    you would have needed to write earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Referential transparency and no side-effects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Referential transparency ensures that you can replace a function call (with
    certain arguments) with the result of the computation anywhere in your code. This
    is also an interesting property for testing as it mostly means you will need to
    test less to gain the same amount of trust. Let me explain.
  prefs: []
  type: TYPE_NORMAL
- en: Usually, when you do unit testing, you try to choose the smallest unit possible
    that satisfies the trust you want to place in your code. Usually, you will test
    either at the module, class, or method level. Obviously, when doing functional
    programming, you will test at the function level.
  prefs: []
  type: TYPE_NORMAL
- en: Your functions will obviously call other functions. In a traditional testing
    setup, you would try to mock as many as those as possible in order to ensure that
    you test only the functionality of the current unit and you are not impacted by possible
    bugs in other functions.
  prefs: []
  type: TYPE_NORMAL
- en: Although not impossible, it's cumbersome to mock functions in PHP, so this becomes
    a bit difficult in our case. This is especially true for composed functions such
    as `$title = compose('strip_tags', 'trim', 'capitalize');` due to the way composition
    is implemented in PHP using closures.
  prefs: []
  type: TYPE_NORMAL
- en: 'So what do we do? Pretty much nothing. The goal of unit testing is to gain
    confidence in the fact that your code works in the expected way. In a traditional
    imperative approach, you mock as many dependencies as possible for the following
    reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: Each dependency can depend on some state you need to provide, making your job
    tougher. Even worse, dependencies can have dependencies of their own that also
    require some state, and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Imperative code can have side effects, which could lead to your function or
    some dependencies having issues. This means that without mocks, you are not only
    testing your function, but all other dependencies and the interaction between
    them; in other words, you are doing integration testing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Control structures introduce decision points, which can make reasoning about
    a function complex; this means that, if you reduce the number of moving pieces
    to the strict minimum, your function is easier to test. Mocking other function
    calls reduces this complexity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When doing functional programming, the first issue is moot as there is no global
    state. Everything your dependencies will ever need is either already in the arguments
    to your tested function or will be computed along the way. So mocking dependencies
    will make you do more work instead of less.
  prefs: []
  type: TYPE_NORMAL
- en: Since our functions are pure and referentially transparent, there is no risk
    of side effects having any consequences on the computation result, meaning even
    if we have dependency, we are not doing integration testing. Sure, a bug in one
    of the functions that is called will result in an error, but hopefully it will also
    have been caught earlier by another test, making it clear what is happening.
  prefs: []
  type: TYPE_NORMAL
- en: 'Concerning the complexity, if we go back to our composed function, `$title
    = compose(''strip_tags'', ''trim'', ''capitalize'');`, I posit it is really easy
    for anyone to understand what is happening. If all three functions are already
    tested, there is nothing much that can go wrong, even if we were to rewrite this
    without the `compose` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: There is not much to test here. Obviously, we would have to write some tests
    to ensure that we pass the right temporary value to each function and that the
    plumbing works as expected, but if we have confidence in all three called functions,
    we can have a lot of confidence that this function will work also.
  prefs: []
  type: TYPE_NORMAL
- en: This line of reasoning is only possible because we know due to the properties
    of referential transparency that none of the three functions will have any impact
    on any of the others in some subtle way, meaning that their own unit tests give
    us trust enough in the fact that they will not break.
  prefs: []
  type: TYPE_NORMAL
- en: The result of all this is that usually you will write fewer tests for functional
    code because you will gain trust quicker. However, it does not mean that the `title`
    function does not need to be tested, because you could have made a small mistake
    somewhere. Each component should still be tested, but probably with a bit less
    care in correctly isolating everything.
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, we are not talking about database access, or third-party APIs, or
    services here; those should always be mocked for the same reasons as in any test
    suite.
  prefs: []
  type: TYPE_NORMAL
- en: Simplified mocking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This might already be clear, but I really want to stress the point that any
    mocking you will have to do will be greatly simplified.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, you will only need to create the input arguments of the function
    under test. In some cases, this represents creating some pretty big data structures
    or instantiating complex classes, but at least you don't have to mock external
    states or a whole lot of services that are injected in your dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Also, this might not be true in all cases, but usually your functions operate
    on a smaller scale because they are a small part of something bigger, meaning
    that any one function will only take some really precise and concise parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, there will be exceptions, but not that many, and as we discussed
    earlier, since all of the parts making the big picture will already be tested.
    Your degree of confidence should then already be higher than is usually the case
    in a more imperative application.
  prefs: []
  type: TYPE_NORMAL
- en: Building blocks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Functional programming encourages the creation of small building blocks that
    get reused as part of bigger functions. Those small functions do usually only
    one thing. This makes them easier to understand, but also easier to test.
  prefs: []
  type: TYPE_NORMAL
- en: The more decision points a function has, the more difficult it is to come up
    with a way to test each possible execution path. A small specialized function
    has usually at most two of those decision points, making it fairly easy to test.
  prefs: []
  type: TYPE_NORMAL
- en: Bigger function usually don't perform any kind of control flow, they are just
    composed of our smaller blocks in a straightforward way. Since this means there
    is only one possible execution path, it also means that they are easy to test.
  prefs: []
  type: TYPE_NORMAL
- en: Closing words
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Of course, I am not saying that you won't encounter some pure functions that
    are difficult to test. It's just than in general you will have less trouble writing
    your tests and you will also gain trust in your code quicker.
  prefs: []
  type: TYPE_NORMAL
- en: With the industry moving ever closer to methodologies such as TDD, this means
    that functional programming is really a good fit for a modern application. This
    is especially true once you realize that most advice you'll find in order to write
    "testable code" is already enforced by using only functional programming techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Speeding up using parallelization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have ever searched for a solution to speed up your test suites, chances
    are that you found something about test parallelization. Usually, users of PHPUnit
    will find the **ParaTest** utility, for example.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main idea is to run multiple PHP processes simultaneously in order to leverage
    all the processing power of the computer. This approach works for mostly two reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: A single test run has bottlenecks such as disk speed for source file parsing
    or database access.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PHP being single-threaded, a multi-core CPU, like nearly all computers have
    nowadays, is not used to its full potential by a single test run.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By running multiples tests in parallel, both those issues can be solved. The
    ability to do this is, however, limited by the fact that each test suite is independent
    from the others, a property that is already enforced by referential transparency
    in a functional codebase.
  prefs: []
  type: TYPE_NORMAL
- en: This means that, if the functions under test follow the functional principles,
    you can run all your tests in parallel without having to make any adaptation.
    In some cases, this could divide by ten the time taken for your whole test suite,
    greatly improving the feedback loop when you develop in the process.
  prefs: []
  type: TYPE_NORMAL
- en: If you are using PHPUnit utility, the aforementioned ParaTest utility is one
    of the easiest ways to get started. You can find it on GitHub at [https://github.com/brianium/paratest](https://github.com/brianium/paratest).
    I advise you to use the **`-functional`** command-line parameter so that each
    function can be tested simultaneously instead of just the test cases.
  prefs: []
  type: TYPE_NORMAL
- en: There is also a brand-new utility for PHPUnit users called **PHPChunkIt**. I
    haven't had the opportunity to test it, but I hear it is interesting. You can
    find it on GitHub at [https://github.com/jwage/phpchunkit](https://github.com/jwage/phpchunkit).
  prefs: []
  type: TYPE_NORMAL
- en: Another more flexible option is using Fastest, available at [https://github.com/liuggio/fastest](https://github.com/liuggio/fastest).
    The examples shown in the tool documentation are for PHPUnit, but in theory it
    is able to run anything in parallel.
  prefs: []
  type: TYPE_NORMAL
- en: If you are using the atoum utility instead, by default your tests are already
    in what they call *concurrent* mode, which means they run in parallel. You can
    modify this behavior for each test using annotations as stated in the execution
    engine documentation at [https://atoum-en.rtfd.org/en/latest/engine.html](https://atoum-en.rtfd.org/en/latest/engine.html).
  prefs: []
  type: TYPE_NORMAL
- en: The **behat** framework users can use the **Parallel Runner** extension, also
    available on GitHub at [https://github.com/shvetsgroup/ParallelRunner](https://github.com/shvetsgroup/ParallelRunner).
    If you are using **CodeCeption** framework, it is sadly a bit difficult to achieve;
    the documentation ([http://codeception.com/docs/12-ParallelExecution](http://codeception.com/docs/12-ParallelExecution))
    has, however, multiple possible solutions for you.
  prefs: []
  type: TYPE_NORMAL
- en: I strongly suggest you look into parallelizing your tests as it will be time
    well spent. Even if you are only able to save a few seconds on each run, this
    gain quickly accumulates. Faster tests means you will run them more often and
    this is usually a good way to improve code quality.
  prefs: []
  type: TYPE_NORMAL
- en: Property-based testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tired of spending time tediously writing test cases, John Hughes and Koen Claessen
    decided it was time for a change. A little more than 15 years ago, they wrote
    and published a paper about a new tool they called *QuickCheck*.
  prefs: []
  type: TYPE_NORMAL
- en: The main idea is that, instead of defining a list of possible input values and
    then asserting that the result is what we expect, you define a list of properties
    that characterize your function. The tool then generates as many test cases as
    wanted automatically and verifies that the property holds.
  prefs: []
  type: TYPE_NORMAL
- en: The default operating mode is for *QuickCheck* to generate random values and
    feed them to your functions. The result is then checked against the properties.
    If a failure is detected, the tool will then try to reduce the inputs to the minimal
    set of inputs generating the issue.
  prefs: []
  type: TYPE_NORMAL
- en: Having a tool generating as many testing values as you want is invaluable to
    find edge cases it would have taken you hours to think about. The fact that the
    test case is then reduced to its minimal form is also great to easily determine
    what is going wrong and how to fix it. It so happens that random values are not
    always the best way to test something. This is why you can also provide generators
    that will be used instead.
  prefs: []
  type: TYPE_NORMAL
- en: Also, thinking of your tests as a set of properties that need to hold true is
    a great way to focus more clearly on what the system is supposed to do instead
    of focusing on finding test values. This is especially helpful when doing TDD
    as your tests will be more akin to a specification.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to learn more about this approach, the original paper is available
    online at [http://www.cs.tufts.edu/~nr/cs257/archive/john-hughes/quick.pdf](http://www.cs.tufts.edu/~nr/cs257/archive/john-hughes/quick.pdf).
    The author uses Haskell in his paper but the content is however fairly easy to
    read and understand.
  prefs: []
  type: TYPE_NORMAL
- en: What exactly is a property?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A property is a rule that your function must respect in order to be determined
    correct. It can be something really simple, such as the result of a function adding
    to integers requiring also to be an integer, or anything more complex, such as
    verifying the monad laws.
  prefs: []
  type: TYPE_NORMAL
- en: You usually want to create properties that are not already enforced otherwise,
    be it by another property or the language. For example, if we use the scalar type
    systems introduced by PHP 7, our preceding integer example is not needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, we will take something from the paper. Say we just wrote a function
    that reverses the order of elements in an array. The authors propose that this
    function should have the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: The `reverse([x]) == [x]` property reverses an array with a single element and
    should yield the exact same array
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `reverse(reverse(x)) == x` property reverses an array twice and should yield
    the exact same array
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `reverse(array_merge(x, y)) == array_merge(reverse(y), reverse(x))` property,
    reversing two merged arrays should yield the same result as merging the second
    array reversed to the first one reversed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first two properties will guarantee that our function does not mess with
    the values. If we were to have only those two properties, a function doing absolutely
    nothing besides returning its parameter will pass the test with flying colors.
    This is where the third property comes into play. The way it is written ensures
    that our function does what we expect of it because there is no other way the
    property will hold.
  prefs: []
  type: TYPE_NORMAL
- en: What is interesting about those properties is that at no time do they perform
    any kind of computation. They are simple to implement and understand, meaning
    it is nearly impossible to introduce bugs in them. If you were to test your functions
    by somehow re-implementing the computation they are doing, it would kind of defeat
    the whole point.
  prefs: []
  type: TYPE_NORMAL
- en: Although pretty simple, this example shows perfectly that it is not easy to
    find valuable properties that are both meaningful and simple enough to ensure
    they will have no bugs. If you have trouble finding good properties, I encourage
    you to take an overview and think of your function in terms of the business logic
    you are trying to implement. Do not think in terms of inputs and outputs but try
    to see the broader picture.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the add function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A great explanation on why property based testing is a valuable tool can be
    found in a slide deck available online at [http://www.slideshare.net/ScottWlaschin/an-introduction-to-property-based-testing](http://www.slideshare.net/ScottWlaschin/an-introduction-to-property-based-testing).
    There is also a companion blog post with some more information at [http://fsharpforfunandprofit.com/posts/property-based-testing-2/](http://fsharpforfunandprofit.com/posts/property-based-testing-2/).
    I will try to summarize them quickly here.
  prefs: []
  type: TYPE_NORMAL
- en: A developer is asked to write a function adding two values with some tests.
    He writes two tests where the expected result is 4; everything is fine. The person
    asking for the function asks for more tests; they fail for the reason that the
    function was always returning the value 4 instead of doing anything meaningful.
  prefs: []
  type: TYPE_NORMAL
- en: The developer rewrites the function so that the tests pass again, but a new
    round of tests continues to fail. What was really done was to incorporate the
    results to the new tests as special cases in the original function. The excuse
    advanced by the developer is that they were following the TDD best practices saying
    that you need to *write the minimal code that will make the test pass*.
  prefs: []
  type: TYPE_NORMAL
- en: What is happening might seem stupid for such a simple function, but if you replace
    it with some kind of complicated business logic that needs to be implemented,
    such a story is probably more common that you would think and is also one of the
    pitfalls of TDD as stated by its opponent. If you follow TDD to the letter, your
    code will never be better than your tests.
  prefs: []
  type: TYPE_NORMAL
- en: The slide deck continues by introducing tests where each value is a random integer
    and the function is tested by comparing the result to `x + y`. In this case, there
    is no way the developer could cheat using special cases in its function. There
    is obviously another issue, however, you re-implemented the function inside the
    test to verify the result.
  prefs: []
  type: TYPE_NORMAL
- en: Enter property based testing. The first property implemented is `add(x, y) ==
    add(y, x)`. The developer implements the `add` property as being `x * y`, which
    correctly passes the test.
  prefs: []
  type: TYPE_NORMAL
- en: This means we need a second property, for example, the `add(add(x, 1), 1) ==
    add(x, 2)` property. This can also be beaten with the implementation of `x - y`,
    but in this case the first test will fail. This is why the developer's newest
    implementation is simply to return `0`.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, a final property, `add(x, 0) == x` is added. The developer is
    finally forced to write a correct implementation for our function as he isn't
    able to find a way to cheat it this time.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we go back to our final three properties and compare them to what we know
    about the addition properties in mathematics, we can draw the following comparison:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `add(x, 0) == x` property, 0 is the *identity* of the addition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `add(x, y) == add(y, x)` property, the addition is *commutative*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `add(add(x, 1), 1) == add(x, 2)` property, the addition is *associative*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All three properties are in fact well-known properties of the operation we were
    trying to implement. As we said earlier, taking a step back and reflecting about
    the what instead of the who is a great help when coming up with properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'The remainder of the slides are a great and interesting read, but as I don''t
    want to plagiarize the entire content, I''d rather encourage you to go read it
    online. I will just take three more pieces of advice from them as I find them
    really great and easy to remember:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Different paths, same destination**: Come up with two different ways to get
    the same results using the function under tests, like we did for the third property
    of `reverse`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**There and back again**: If your function has an inverse, try applying both
    to see if you get the initial value back, like we did for the second property
    of `reverse`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Some things never change**: If some properties of your input are not changed
    by the function, test for them, for example, array length or type of the data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With all this, you should now have a good idea about how to find good properties
    for your functions. It is still a difficult task, but in the end you'll probably
    save a lot of time as you won't have to add edge cases as you find them.
  prefs: []
  type: TYPE_NORMAL
- en: If you'd like to have a good example of a real-life bug that was discovered
    thanks to property-based testing, John Hughes himself gave a great talk with some
    nice examples at [https://vimeo.com/68383317](https://vimeo.com/68383317).
  prefs: []
  type: TYPE_NORMAL
- en: The PhpQuickCheck testing library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Having seen the theoretical aspects of property-based testing in general, we
    can now shift our attention to a PHP-specific implementation-the `PhpQuickCheck`
    library. The source code is available on GitHub at [https://github.com/steos/php-quickcheck](https://github.com/steos/php-quickcheck)
    and the library can be installed using **`composer`** command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: You might need to change your `minimum-stability` setting to dev in your `composer.json`
    file, or add the dependency manually as explained on the GitHub page, because
    there is currently no stable release of the library.
  prefs: []
  type: TYPE_NORMAL
- en: The project was started in September 2014 and most of its development took place
    until November of the same year. Since then, not many new features have been added,
    mostly improvement of the coding styles and some minor improvements.
  prefs: []
  type: TYPE_NORMAL
- en: Although we can't say the project is really alive today, it is one of the first
    serious attempts to have a `QuickCheck` library in PHP and it has some functionalities
    that are not yet available in its main contender and will be discussed later.
  prefs: []
  type: TYPE_NORMAL
- en: 'But let''s not get ahead of ourselves; let''s get back to our first example,
    the reverse function. Imagine we wrote the `array_reverse` function available
    in PHP and we needed to test it. This is how it would look with the `PhpQuickCheck`
    library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `check` static method accepts the amount of test data it needs to generate
    as the first argument. The second argument is an instance of `Generator` function;
    usually, you will use `Generator::forAll` to create it in the example. The last
    part is an array of options you can pass in the random generator `seed` variable,
    the `max_size` function for the generated data (the meaning of this value depends
    on the generator used), or finally the `echo` options which will display a dot
    (`.`) for each passed test.
  prefs: []
  type: TYPE_NORMAL
- en: The `forAll` instance accepts an array representing the arguments to your test
    and the test itself. In our case, for the first test, we generate random integers
    and for the other two, random integer arrays. The test must return a Boolean value: `true`
    for passed, `false` otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you were to run our little example, it would display a dot for each random
    data generated, because we passed the `echo` option. The resulting variable contains
    information about the test results themselves. In our case, if you displayed `$merge`,
    it would show:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `seed` instance will be different on each run except if you pass one as
    parameter. Reusing the `seed` instance allows you to create the exact same test
    data. This can be useful to check whether a particular edge case is correctly
    fixed after being discovered.
  prefs: []
  type: TYPE_NORMAL
- en: 'An interesting feature is automatically determining which generator to use
    based on type annotations. You can do so using methods on the `Annotation` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This feature can, however, only work with annotation right now and type hints
    will be ignored.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see with those small examples, the `PhpQuickCheck` library relies
    heavily on static functions. The codebase in itself is also sometimes a bit hard
    to understand and the library lacks good documentation and an active community.
  prefs: []
  type: TYPE_NORMAL
- en: All in all, I don't think I would recommend using this over the option we'll
    see next. I just wanted to present the library to you as a possible alternative
    and, who knows, its status might change in the future.
  prefs: []
  type: TYPE_NORMAL
- en: Eris
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Eris** development started out in November 2014, roughly at the time the
    `PhpQuickCheck` library got its last big feature introduced. As we will see, the
    coding style is definitively more modern. Everything is cleanly organized in namespace
    and helpers take the form of functions instead of static methods.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As usual, you can get Eris using the **`composer`** command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The documentation is available online at [http://eris.rtfd.org/](http://eris.rtfd.org/)
    and it is quite complete. The only gripe I have with it is that the sole examples
    are for people using PHPUnit to run their test suites. It should be doable to
    use it with other tests runners, but this is something that isn't documented for
    now.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we wanted to use Eris to test the properties we defined for `array_reduce`,
    our test case would look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The code is somewhat similar to what we wrote for the `PhpQuickCheck` library
    but leverages methods that are added by the provided trait to our test case and
    generator functions instead of static methods. The `forAll` method accepts a list
    of generators representing the arguments to our test function. You can subsequently
    use the `then` keyword to define the function. You have access to all asserters
    provided by PHPUnit.
  prefs: []
  type: TYPE_NORMAL
- en: The documentation explains in detail how you can configure various aspects of
    the library, such as the amount of generated test data, limiting the execution
    time, and so on. Each generator is also detailed at length with various examples
    and use cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see what happens when we have a failing test case. Imagine we want to
    prove that no strings are also a numerical value; we could write the following
    test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: You can see how we raised the number of iterations using the `limitTo` function
    to 1,000 from the default of 100\. This is because a lot of strings are in fact
    not numerical values and without this raise, I was only able to get a failure
    one test out of three. Even with this higher limit, it is still possible that
    sometimes all test data will pass the test without failures.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the kind of output you would get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The test failed after 160 iterations with the string `"9"`. Eris also gives
    you the command to run if you want to reproduce exactly this failing test by seeding
    the random generator manually:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the library is fairly easy to use when your tests are written
    for PHPUnit. Otherwise, you might need to do some adaptation but I think it is
    worth your time.
  prefs: []
  type: TYPE_NORMAL
- en: Closing words
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `QuickCheck` library is easier to use in strictly typed functional programming
    language because it is sufficient to declare generators for certain types and
    some properties for your functions, and nearly everything else can be done automatically.
    The `PhpQuickCheck` library tries to emulate this behavior but the result is a
    bit tedious to use.
  prefs: []
  type: TYPE_NORMAL
- en: However, this doesn't mean you can't use property-based testing effectively
    in PHP! Once you have created your generators, the framework will use it to generate
    as much test data as you let it, possibly uncovering edge cases you would never
    have thought of. For example, there is a bug in the `DateTime` method's implementation
    in PHP that arises on leap years and could easily be overlooked when creating
    test data manually. See the *Testing the language* part at [http://www.giorgiosironi.com/2015/06/property-based-testing-primer.html](http://www.giorgiosironi.com/2015/06/property-based-testing-primer.html) (by
    the creator of Eris) for more details on the issue.
  prefs: []
  type: TYPE_NORMAL
- en: Writing properties can be challenging, especially in the beginning. But more
    often than not, it helps you reason about the feature you are implementing and
    will probably lead to better code because you took the time to think about it
    from a different angle.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we had a quick look at what can be done on the testing front
    when you use a more functional approach to programming. As we saw, functional
    code is often easier to test because it enforces what is considered best practice
    for testing when doing imperative coding.
  prefs: []
  type: TYPE_NORMAL
- en: By having no side-effects and explicit dependencies, you can avoid most of the
    issues you usually encounter when writing tests. This results in less time spent
    testing and more time to concentrate on your application.
  prefs: []
  type: TYPE_NORMAL
- en: We also discovered property-based testing, which is a great way to discover
    issues related to edge cases. It also allows us you to take a step back and think
    about the properties you want to enforce for your functions, which is akin to
    creating a specification for them. This approach is particularly effective when
    doing TDD as it forces you to think about what you want instead of how to do it.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have discussed testing to ensure our functions do what they should,
    we will learn about code optimization in order to allow for application performance
    in the next chapter. A well-tested codebase will help you do the necessary refactoring
    to achieve better speed.
  prefs: []
  type: TYPE_NORMAL
