- en: Curb Your Enthusiasm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will examine some of the ways **dependency injection** (**DI**)
    can go wrong.
  prefs: []
  type: TYPE_NORMAL
- en: As programmers, our enthusiasm towards a new tool or technique can sometimes
    get the better of us. Hopefully, this chapter will help to ground us and keep
    us out of trouble.
  prefs: []
  type: TYPE_NORMAL
- en: It's important to remember that DI is a tool and, as such, it should be applied
    selectively, when it's convenient, and when it's the right tool for the job.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: DI induced damage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Premature future-proofing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mocking HTTP requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unnecessary injection?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You might also find it useful to read and run the full versions of the code
    for this chapter, which are available at [https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/tree/master/ch11](https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/tree/master/ch11).
  prefs: []
  type: TYPE_NORMAL
- en: DI induced damage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: DI induced damage results from situations where the use of DI makes the code
    harder to understand, maintain, or otherwise use.
  prefs: []
  type: TYPE_NORMAL
- en: A long constructor parameter list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A long constructor parameter list is perhaps the most common and most often
    complained about code damage caused by DI. While DI is not the root cause of code
    damage, it certainly doesn't help.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example, which uses constructor injection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The constructor simply has too many parameters. This makes it unwieldy to use,
    test, and maintain. So, what is the cause of the problem here? There are actually
    three different issues.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first and, perhaps, most common when adopting DI for the first time is
    incorrect abstractions. Consider the last two parameters of the constructor are
    `Cache` and `Datastore`. Assuming that the `cache` is used in front of the `datastore`
    and not to cache the output of `MyHandler`, then these should be combined into
    a different abstraction. The `MyHandler` code does not need to be intimately aware 
    of where and how the data is stored; it only needs to be prescriptive about what
    it needs. We should replace these two input values with a more generic abstraction,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Incidentally, this would also be a great place for another package/layer.
  prefs: []
  type: TYPE_NORMAL
- en: The second issue is similar to the first, a single responsibility principle
    violation. Our `MyHandler` has taken on too much responsibility. It is currently
    decoding the request, loading the data from the datastore and/or cache, and then
    rendering the response. The best way to address this is to think about the software's
    layers. The is the top layer, our HTTP handler; it is required to understand and
    speak HTTP. We, therefore, should look for ways to have that as its primary (and
    perhaps only) responsibility.
  prefs: []
  type: TYPE_NORMAL
- en: The third problem are the cross-cutting concerns. Our parameters include logging
    and instrumentation dependencies, which are likely to be used by most of our code
    and seldom changed outside of a few tests. We have a few options to deal with
    this; we could apply config injection, thereby collapsing them into one dependency
    and merging them with any config we might have. Or we could use **just-in-time**
    (**JIT**) injection to access global singletons.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we have decided to go with config injection. After applying it,
    we are left with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We are still left with five parameters, which is far better than what we started
    with, but still rather a lot.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can reduce this even further using composition. Firstly, let''s look at
    our previous example''s constructor, which is demonstrated in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Starting with `MyHandler` as a *base handler*, we can define a new handler
    that wraps our base handler, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can define a new constructor for our `FancyFormatHandler` in the following
    way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: And just like that, we have one parameter fewer. The real source of magic here
    is the anonymous composition; because of that, any calls to `FancyFormatHandler.ServeHTTP()`
    will actually call `MyHandler.ServeHTTP()`. In this case, we're adding a little
    bit of code, to improve the UX of the handlers for our users.
  prefs: []
  type: TYPE_NORMAL
- en: Injecting an object when config would do
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Often times, your first instinct will be to inject a dependency so that you
    can test your code in isolation. However, to do so, you are forced to introduce
    so much abstraction and indirection that the amount of code and complexity increases
    exponentially.
  prefs: []
  type: TYPE_NORMAL
- en: 'One widespread occurrence of this is using the common library for accessing
    external resources, such as network resources, files, or databases. Let''s use
    our sample service''s `data` package, for example. If we wanted to abstract our
    usage of the `sql` package, we would likely start by defining an interface, as
    shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we realize that `QueryRowContext()` and `QueryContext()` return `*sql.Row`
    and `*sql.Rows` respectively. Digging into these structs, we find that there is
    no way for us to populate their internal state from outside of the `sql` package.
    To get around this, we have to define our own `Row` and `Rows` interfaces, as
    shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We are now fully decoupled from the `sql` package and are able to mock it in
    our tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'But let''s stop for a minute and consider where we''re at:'
  prefs: []
  type: TYPE_NORMAL
- en: We've introduced about 60 lines of code, which we haven't yet written any tests
    for
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We cannot test the new code without using an actual database,  which means we'll
    never be fully decoupled from the database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We've added another layer of abstraction and a small amount of complexity along
    with it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, compare this with installing a database locally and ensuring it's in a
    good state. There is complexity here too, but, arguably, an insignificant once-off
    cost, especially when spread across all of the projects we work on. We would also
    have to create and maintain the tables in the database. The easiest option for
    this is an `SQL` script—a script that could also be used to support the live systems.
  prefs: []
  type: TYPE_NORMAL
- en: For our sample service, we decided to maintain an `SQL` file and a locally installed
    database. As a result of this decision, we do not need to mock calls to the database
    but instead only need to pass in the database configuration to our local database.
  prefs: []
  type: TYPE_NORMAL
- en: This kind of situation appears a lot, especially with low-level packages from
    trusted sources, such as the standard library. The key to addressing this is to
    be pragmatic. Ask yourself, do I really need to mock this? Is there some configuration
    I can pass in that will result in less work?
  prefs: []
  type: TYPE_NORMAL
- en: At the end of the day, we have to make sure we are getting enough return from
    the extra work, code, and complexity to justify the effort.
  prefs: []
  type: TYPE_NORMAL
- en: Needless indirection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another way the DI can be misapplied is by introducing abstractions that have
    limited (or no) purpose. Similar to our earlier discussion on injecting config
    instead of objects, this extra level of indirection leads to additional work,
    code, and complexity.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at an example of a case where you could introduce an abstraction
    to help with testing, but there is really no need.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the standard HTTP library, there is a struct called `http.ServeMux`. `ServeMux`
    is used to build an HTTP router, which is a mapping between URLs and HTTP handlers.
    Once `ServeMux` is configured, it is then passed into the HTTP server, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'As our service expands, we need to be sure to add more endpoints. To prevent
    API regression, we''ve decided to add some tests to ensure our router is configured
    correctly. Because of our familiarity with DI, we can jump right in and introduce
    an abstraction of `ServerMux` so that we can add a mock implementation. This is
    shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'With our abstraction in place, we can define a mock implementation, `MyMux`,
    and write ourselves a test, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This all looks pretty good. The problem, however, is that it wasn't necessary.
    Our goal was to protect ourselves from accidental API regression by testing the
    mapping between the endpoints and URLs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our goal can be achieved without mocking the `ServeMux`. First, let''s go back
    to our original function before we introduced the `MyMux` interface, as shown
    in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Digging a little deeper into `ServeMux`, we can see that, if we call the `Handler(req
    *http.Request)` method, it will return the `http.Handler` configured to that URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because we know that we are going to do this once for every endpoint, we should
    define a function to do just that, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'With our function in place, we can now build a test that validates the expected
    handler is returned from for each URL, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In the previous example, you'll also have noticed that our `buildRouter()` function
    and our tests are awfully similar. This leaves us to wonder about the efficacy
    of the tests.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, it would be more effective to ensure we have API regression tests
    that validate not only the router's configuration but also the input and output
    formats, just as we did at the end of [Chapter 10](3006fc58-da4c-49df-b109-10c57a86b7a7.xhtml),
    *Off-the-Shelf Injection*.
  prefs: []
  type: TYPE_NORMAL
- en: Service locator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, a definition—Service locator is a software design pattern that revolves
    around an object that acts as a central repository of all dependencies and is
    able to return them by name. You'll find this pattern in use in many languages
    and at the heart of some DI frameworks and containers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we dig into why this is DI induced damage, let''s look at an example
    of an overly simplified service locator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to use our service locator, we first have to create it and map our
    dependencies with their names, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'With our service locator built and dependencies set, we can now pass it around
    and extract dependencies as needed, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Now, if we wanted to *swap out* the logger for a mock one during testing, then
    we would only have to construct a new service locator with the mock logger and
    pass it into our function.
  prefs: []
  type: TYPE_NORMAL
- en: So what is wrong with that? Firstly, our service locator is now a God object
    (as mentioned in [Chapter 1](32773d95-0c4b-45bc-97e6-ce1ca3f3b3b9.xhtml), *Never
    Stop Aiming for Better*) that we would likely end up passing around all over the
    place. It might sound like a good thing to only have to pass one object into every
    function but it leads to the second issue.
  prefs: []
  type: TYPE_NORMAL
- en: The relationship between an object and the dependencies it uses is now completely
    hidden from the outside. We are no longer able to look at a function or struct
    definition and immediately know what dependencies are required.
  prefs: []
  type: TYPE_NORMAL
- en: 'And lastly, we are operating without the protection of Go''s type system and
    compiler. In the previous example, the following line might have caught your attention:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Because the service locator accepts and returns `interface{}`, every time we
    need to access a dependency, we are required to cast into the appropriate type.
    This casting not only makes the code messier, it can cause runtime crash if the
    value is missing or of the wrong type. We can account for these issues with yet
    more code, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: With the previous approach, our application will no longer crash, but it's getting
    rather messy.
  prefs: []
  type: TYPE_NORMAL
- en: Premature future-proofing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, the application of DI is not wrong, but just unnecessary. A common
    manifestation of this is premature future-proofing. Premature future-proofing
    occurs when we add features to software that we don't yet need, based on the assumption
    that we might need it one day. As you might expect, this results in unnecessary
    work and complexity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example by borrowing from our example service. Currently,
    we have a Get endpoint, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s a simple REST endpoint that returns JSON. If we decided that, one day,
    we might want to output in a different format, we could move the encoding to a
    dependency, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: That code looks reasonable. So, where is the problem? Simply put, it's work
    we didn't need to do.
  prefs: []
  type: TYPE_NORMAL
- en: By extension, it's code that we didn't need to write or maintain. In this simple
    example, our changes only added a small amount of extra complexity and this is
    relatively common. This small amount of additional complexity multiplied across
    the entire system would slow us down.
  prefs: []
  type: TYPE_NORMAL
- en: If this should ever become an actual requirement, then this is absolutely the
    right way to deliver the feature, but at that point, it's a feature and therefore
    a burden that we must have.
  prefs: []
  type: TYPE_NORMAL
- en: Mocking HTTP requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Earlier in this chapter, we talked about how the injection is not the answer
    to all problems and, in some cases, passing in configuration is far more efficient
    and a whole lot less code. A frequently occurring example of this occurs when
    we deal with external services, particularly HTTP services such as the upstream
    currency conversion service in our sample service.
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to mock an HTTP request to the external service and use the mock
    to thoroughly test calls to an external service, but it's just not necessary.
    Let's look at a side-by-side comparison of mocking versus config by using code
    from our sample service.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the code from our sample service, which calls to the external
    currency conversion service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we embark on writing the tests, we should first ask ourselves, what
    do we want to test? Here are the typical test scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Happy path**: The external server returns the data, and we extract it successfully'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Failed/slow request**: The external server returns an error or does not answer
    in time'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Error response**: The external server returns an invalid HTTP response code
    to indicate it''s having issues'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Invalid response**: The external server returns a payload in a format that
    we don''t expect'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will start our comparison by mocking the HTTP request.
  prefs: []
  type: TYPE_NORMAL
- en: Mocking an HTTP request with DI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we are going to use DI and mocks, then the cleanest option is to mock the
    HTTP request so that we can make it return whatever response we need.
  prefs: []
  type: TYPE_NORMAL
- en: 'To achieve this, the first thing we need to do is abstract building and sending
    of HTTP requests, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: You can see we have also included a *go generate* comment that will create the
    mock implementation for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then update our `Converter` to use the `Requester` abstraction, as shown
    in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'With the `requester` abstraction in place, we can use the mock implementation
    to test, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In the previous example, our mock requester returns an invalid response instead
    of calling to the external service. With this, we can ensure that our code behaves
    appropriately when this happens.
  prefs: []
  type: TYPE_NORMAL
- en: In order to cover the other typical test scenarios, we would only need to copy
    this test and change the response from the mock and the expectations.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's compare our mock based tests with the config-based equivalent.
  prefs: []
  type: TYPE_NORMAL
- en: Mocking HTTP requests with config
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can test `Converter` without making any code changes at all. The first step
    is to define an HTTP server that returns the response we need. In the following
    example, the server is returning the same as the mock in the previous section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we take the URL from the test server and pass it in as a config to `Converter`, 
    as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'And now, the following example shows how we can perform the HTTP call and validate
    the response, as we did in the mock version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: With this approach, we can achieve the same level of test scenario coverage
    as the mock-based version, but with far less code and complexity. Perhaps, more
    importantly, we do not incur the test-induced damage of an additional constructor
    parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Unnecessary injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By now, you are probably thinking, *there are times when using DI is not the
    best option, but how do I know when?* For this, I would like to offer you another
    self-survey.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you are unsure how to proceed, or before you embark on a potentially big
    refactor, first take a quick run through my DI Survey:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Is the dependency an environmental concern (such as logging)?**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Environmental dependencies are necessary but have a tendency to pollute the
    UX of the function, particularly a constructor. Injecting them is appropriate,
    but you should prefer a less obtrusive DI method such as JIT injection or config
    injection.
  prefs: []
  type: TYPE_NORMAL
- en: '**Are there tests in place to protect us during refactoring?**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When applying DI to existing code that has low test coverage, adding some monkey
    patching will be the smallest change you can make and therefore the one that poses
    the least risk. Once tests are in place, it will be protected for future changes;
    even if those changes mean the removal of monkey patching.
  prefs: []
  type: TYPE_NORMAL
- en: '**Is the dependency''s existence informative?**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What does the existence of the dependency tell the user about the struct? If
    the answer is not much or nothing, then the dependency can be merged into any
    config injection. Similarly, if the dependency does not exist outside the scope
    of this struct, then you can manage it with JIT injection.
  prefs: []
  type: TYPE_NORMAL
- en: '**How many implementations of the dependency are you going to have?**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the answer is more than one, then injecting the dependency is the right option.
    If the answer is one, then you need to dig a little deeper. Does the dependency
    ever change? If it has never changed, then injecting it is a waste of effort,
    and, likely, adds unnecessary complexity.
  prefs: []
  type: TYPE_NORMAL
- en: '**Is the dependency ever changed outside the tests?**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If it's only changed during testing, then this is a great candidate for JIT
    injection, after all, we want to avoid test-induced damage.
  prefs: []
  type: TYPE_NORMAL
- en: '**Does the dependency need to change for each execution?**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the answer is yes, then you should use method injection. Whenever possible,
    try to avoid adding any logic to your struct that determines which dependency
    you are going to use (for example, `switch` statements). Instead, ensure that
    you either inject the dependency and use it, or inject a factory or locator object
    that includes the logic for deciding the dependency. This will ensure that your
    struct stays clear of any single responsibility related issues. It also helps
    us to avoid making shotgun surgery type changes when we add a new implementation
    of the dependency.
  prefs: []
  type: TYPE_NORMAL
- en: '**Is the dependency stable?**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A stable dependency is something that already exists, is unlikely to change
    (or change in a backward compatible way) and is unlikely to be replaced. Good
    examples of this are the standard library and well managed, infrequently changed
    public packages. If the dependency is stable, then injecting it for the purposes
    of decoupling has less value as the code has not changed and can be trusted.
  prefs: []
  type: TYPE_NORMAL
- en: You may wish to inject a stable dependency to be able to test how you are using
    it, as we saw earlier with the SQL package and HTTP client examples. However,
    to avoid test-induced damage and unnecessary complexity, we should either be adopting
    JIT injection, to avoid polluting the UX, or avoiding the injection altogether.
  prefs: []
  type: TYPE_NORMAL
- en: '**Is this struct going to have one or multiple usages?**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the struct has only a single use, then pressures on that code to be flexible
    and extendable are low. We can, therefore, favor less injection and more specificity
    in our implementation; at least until our situation changes. On the other hand,
    code that is used in many places will have far more considerable pressure to change
    and, arguably, want to have greater flexibility, to be more useful in more cases.
    In these cases, you will want to favor injection more to give the users more flexibility.
    Just be careful not to have so much injection that the UX of the function is terrible.
  prefs: []
  type: TYPE_NORMAL
- en: With shared code, you should also spend more effort decoupling your code from
    as many external (non-stable) dependencies as possible. When users adopt your
    code, they may not want to adopt all of your dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: '**Is this code wrapping the dependency?**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we are wrapping a package to make its UX more convenient to insulate us from
    changes in that package, then injecting that package is unnecessary. The code
    we are writing is tightly coupled with the code it is wrapping, so introducing
    an abstraction does not achieve anything significant.
  prefs: []
  type: TYPE_NORMAL
- en: '**Does applying DI make the code better?**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is, of course, extraordinarily subjective but perhaps also the most crucial
    question. Abstraction is useful, but it also adds indirection and complication.
  prefs: []
  type: TYPE_NORMAL
- en: Decoupling is important but not always necessary. Decoupling between packages
    and layers is more important than decoupling between objects within a package.
  prefs: []
  type: TYPE_NORMAL
- en: With experience and repetition, you'll find that many of these questions will
    become second nature as you develop an intuitive sense of when to apply DI and
    which method to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the meantime, the following table might help:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **  Method** | **  Ideal for:** |'
  prefs: []
  type: TYPE_TB
- en: '| Monkey patching |'
  prefs: []
  type: TYPE_TB
- en: Code that relies on a singleton
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code that currently has no tests or existing dependency injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decoupling packages without making any changes to the dependent package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| Constructor injection |'
  prefs: []
  type: TYPE_TB
- en: Dependencies that are required
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependencies that must be ready before any methods are called
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependencies that are used by most or all of the methods of an object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependencies that don't change between requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependencies that have multiple implementations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| Method injection |'
  prefs: []
  type: TYPE_TB
- en: Used with functions, frameworks and shared libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Request-scoped dependencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stateless objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependencies that provide context or data in the request, and, as such, are
    expected to vary between calls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| Config injection |'
  prefs: []
  type: TYPE_TB
- en: Replacing constructor or method injection to improve the UX of the code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| JIT injection |'
  prefs: []
  type: TYPE_TB
- en: Replacing a dependency that would otherwise have been injected into the constructor
    and of which there is only one production implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing a layer of indirection or abstraction between an object and a global
    singleton or environmental dependency. Particularly when we want to swap out the
    global singleton during testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allowing dependencies to be optionally provided by the user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| Off-the-shelf injection |'
  prefs: []
  type: TYPE_TB
- en: Reducing the cost of adopting constructor injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reducing the complexity of maintaining the order in which dependencies are created
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we examined the effects of applying DI unnecessarily or incorrectly.
    We also discussed some situations where employing DI is not the best tool for
    the job.
  prefs: []
  type: TYPE_NORMAL
- en: We then wrapped up the chapter with a list of 10 questions that you can ask
    yourself to determine whether DI is appropriate for your current use case.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll wrap up our examination of DI with a review of everything
    we've discussed throughout this book. In particular, we'll contrast the state
    of our sample service now with its original state. We'll also take a quick look
    at how to start a new service with DI.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What form of DI induced damage do you see most often?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is it important not to blindly apply DI all of the time?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Does adopting a framework, such as Google Wire, eliminate all forms of DI induced
    damage?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
