- en: Routing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由
- en: The previous chapter was a monster, but it was needed to give you a couple of
    crash courses on two of the technologies you're likely to use, or should definitely
    consider using, in your web development projects (and this is true whether or
    not your project leverages Angular). Additionally, [Chapter 3](6694dd13-5500-4563-9688-74a21a06a9a9.xhtml),
    *Bootstrap – Grid Layout and Components*, was also there to help set the stage
    for the rest of the book.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章是一个庞然大物，但它是必要的，因为它需要给你提供两种你可能会使用的技术的速成课程，或者应该考虑在你的网页开发项目中使用的技术（无论你的项目是否利用Angular）。另外，第三章《Bootstrap
    - 网格布局和组件》也有助于为本书的其余部分铺平道路。
- en: This chapter is much smaller by comparison, but it marks the true beginning
    of our journey into Angular. Each chapter from this point forward, even [Chapter
    12](9610f27b-03db-4258-8a68-24eb3901117b.xhtml), *Integrating Backend Data Services*,
    where the primary focus is on building backend services in Node and MongoDB, has
    Angular material in it (specifically, how to use Angular's HTTP client and how
    to wrap your code up in an Angular service).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 与之相比，本章要小得多，但它标志着我们进入Angular的真正开端。从这一点开始，每一章，甚至第12章《集成后端数据服务》，其中主要关注在Node和MongoDB中构建后端服务，都包含Angular的内容（具体来说，如何使用Angular的HTTP客户端以及如何将代码封装在Angular服务中）。
- en: One other note about this chapter that I'd like to point out is that most books
    on Angular don't introduce routing before they introduce Angular templates and
    components, which is fine; but we won't be following that approach. Although routing
    and component templates are inextricably linked together, which is the the likely
    reason that most books discuss routing after components, understanding components
    is not at all a prerequisite for understanding routing.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 关于本章的另一个注意事项是，大多数关于Angular的书籍在介绍Angular模板和组件之前并不介绍路由，这是可以接受的；但我们不会遵循这种方法。尽管路由和组件模板是密不可分的，这也是大多数书籍在介绍组件之后再讨论路由的原因，但理解组件并不是理解路由的先决条件。
- en: More generally, most programming books try and present all the material and
    concepts in advance, and then circle back at a later time to try and implement
    them in some fashion. One of the problems with this approach is that it goes against
    the way our brains work when assimilating and internalizing new information. It
    is usually better to immediately use new information, in small incremental steps.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 更一般地说，大多数编程书籍都试图提前呈现所有的材料和概念，然后在以后的某个时候回过头来尝试以某种方式实现它们。这种方法的问题之一是，它违反了我们大脑在吸收和内化新信息时的工作方式。通常最好立即以小的增量步骤使用新信息。
- en: This book focuses on being as practical as possible, as soon as possible, and
    in a way that maximizes the retention and understanding of new material. So, in
    order to accomplish this, we'll be building our example application together throughout
    the book, learning the topics as we need them, and not before. This means that
    we will often implement things that haven't yet been fully explained. They will
    be explained to you as we implement them, or immediately afterward—when your brain
    is primed, and looking for patterns to forment understanding.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的重点是尽可能实用，尽快实现，并以最大程度地保留和理解新材料的方式。因此，为了实现这一点，我们将在整本书中一起构建我们的示例应用程序，学习我们需要的主题，而不是在之前。这意味着我们经常会实现尚未完全解释的内容。它们将在实现它们时向您解释，或者在之后立即解释——当您的大脑处于最佳状态，并寻找模式以促进理解时。
- en: So, don't worry about diving in head first—it's usually the best way. I'm your
    guide and I am with you to all the way to the end of the book.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，不要担心头等跳进去——通常这是最好的方式。我是你的向导，我会一直陪伴你到书的最后。
- en: 'Here is what we''ll be covering together in this chapter:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将一起学习以下内容：
- en: Defining what routing is, for Angular applications
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为 Angular 应用程序定义路由是什么
- en: Creating the shell of our application, as well as its first few components,
    using the CLI
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 CLI 创建应用程序的外壳以及它的前几个组件
- en: Configuring routing for our application
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为我们的应用程序配置路由
- en: Taking a look at route redirection, parameterized routes, and route guards
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 研究路由重定向、参数化路由和路由守卫
- en: Completing the routing configuration for our application
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完成我们应用程序的路由配置。
- en: Taking a look at routing strategies
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 研究路由策略
- en: There's quite a bit to cover (even for a small chapter such as this one), so
    let's get started!
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多内容要涵盖（即使是像这样的小章节），所以让我们开始吧！
- en: What is routing in Angular?
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是 Angular 中的路由？
- en: Routing in Angular is simply a set of rules that map a requested URL to a component.
    This tends to confuse people that are coming to Angular from another technology
    that has routing, especially a technology that is not an SPA (that is, a single-page
    application) framework. Let me explain this a bit.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Angular 中，路由简单地将请求的 URL 映射到一个组件。这往往会让从另一个具有路由的技术（特别是不是单页面应用程序框架的技术）转向 Angular
    的人感到困惑。让我稍微解释一下。
- en: Angular applications only have one page (hence, the term single-page application),
    as we'll see in a moment when we create our Angular application. Angular components
    have templates, which are standard HTML elements that are used to design the layout
    of the structure for presentation. And as we'll see in [Chapter 6](acd5e47c-07a7-4954-993d-360134221325.xhtml),
    *Building Angular Components*, they also have styles.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 应用程序只有一个页面（因此，术语单页面应用程序），我们将在创建 Angular 应用程序时看到。Angular 组件有模板，这些模板是用于设计结构和布局的标准
    HTML 元素。正如我们将在第 6 章中看到的 *构建 Angular 组件*，它们也有样式。
- en: As was mentioned in the first chapter of the book, Angular applications can
    be thought of as trees of components. This is to say that components can contain
    other components, and this nesting of components can continue as much as is required
    for your application.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 正如书的第一章中提到的，Angular 应用程序可以被看作是组件树。这意味着组件可以包含其他组件，并且这种组件的嵌套可以根据应用程序的需要继续进行。
- en: 'So, although components have templates (note: some web frameworks refer to
    web pages as templates), Angular''s routing maps URL paths to components, not
    to web pages or templates. When the template of the component that the requested
    URL is rendered (and we''ll see how this happens in just a moment), not only is
    that component''s template rendered, but all nested components'' templates are
    also rendered. The top-level component that is mapped to by Angular''s router
    may contain other child components, which in turn can contain other child components,
    and so forth. This is what is meant by a tree of components.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，尽管组件有模板（注意：一些 web 框架将 web 页面称为模板），Angular 的路由将 URL 路径映射到组件，而不是 web 页面或模板。当请求的
    URL 渲染为组件的模板时（我们马上就会看到这是如何发生的），不仅会渲染该组件的模板，还会渲染所有嵌套组件的模板。由 Angular 路由映射到的顶级组件可能包含其他子组件，这些子组件又可以包含其他子组件，依此类推。这就是组件树的含义。
- en: For the most part, data in Angular applications flow from the parent components
    to their immediate children. It does not flow from the parent component to its
    grandchild component. Moreover, data does not flow upward. It is a unidirectional
    flow—parent to child. I say *for the most part*, because there are techniques
    and libraries that change some of this behavior—for instance, components can talk
    to each other through an intermediary, which we'll look at later on in the book.
    However, by design, and without outside intervention, data flows from parent to
    child.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，Angular应用程序中的数据是从父组件流向其直接子组件的。它不会从父组件流向其孙子组件。此外，数据也不会向上流动。这是一个单向流动-从父级到子级。我说“在大多数情况下”，因为有一些技术和库可以改变部分行为-例如，组件可以通过中介相互通信，我们将在本书后面讨论。但是，按设计，没有外部干预，数据是从父级到子级流动的。
- en: You'll become familiar with all of this as we progress through the book. All
    you have to understand at this point, to understand routing, is that URLs are
    mapped to components instead of to pages, because Angular applications only have
    one page. The only page in Angular apps is the `index.html` page, which is in
    the app directory. In [Chapter 6](acd5e47c-07a7-4954-993d-360134221325.xhtml),
    *Building Angular Components*, we'll see how our default component gets loaded
    into the `index.html` page. For now, let's get back to routing.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们在本书中的进展，您将熟悉所有这些。您现在唯一需要理解的是，要理解路由，URL被映射到组件而不是页面，因为Angular应用程序只有一个页面。Angular应用程序中唯一的页面是`index.html`页面，位于app目录中。在[第6章]中，我们将看到我们的默认组件如何加载到`index.html`页面中。现在，让我们回到路由。
- en: Creating our application's shell using the CLI
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用CLI创建应用程序的外壳
- en: This is where it all starts. We have now reached the point where we are going
    to use the CLI to create our application's starting point, as well as the first
    bunch of components we'll need to connect them to our routing configuration. We've
    looked at how to install the CLI, and we've even created our first Angular application
    together—although our todo application was a tiny one, just to get our feet wet—back
    in [Chapter 1](f1243d74-a120-408f-8181-cb379b457dd1.xhtml), *Quick Start*.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是一切的开始。我们现在已经到达了使用CLI创建应用程序的起点以及我们需要连接到路由配置的第一批组件的点。我们已经学习了如何安装CLI，甚至一起创建了我们的第一个Angular应用程序-尽管我们的待办事项应用程序很小，只是为了让我们入门-在[第1章]中。
- en: If you haven't yet installed the CLI, you're definitely going to want to do
    that now. Once you've done that (hopefully, you already have), fire up your CLI,
    and let's begin!
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还没有安装CLI，那么现在肯定要安装了。一旦您完成了这个步骤（希望您已经完成了），启动CLI，让我们开始吧！
- en: The first order of business is to create a directory on your machine where you're
    going to place all your Angular projects. Don't create a directory for our example
    application, because the CLI will do that for you. Simply create a folder on your
    filesystem and navigate to it from your command line (if your OS is Windows),
    or Terminal (if your OS is a Mac or Linux). For brevity, from here on in, I'll
    be referring to it as your Terminal, and the folders as directories.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 首要任务是在您的计算机上创建一个目录，您将在其中放置所有的Angular项目。不要为我们的示例应用程序创建一个目录，因为CLI会为您完成这项工作。只需在文件系统上创建一个文件夹，并从命令行（如果您的操作系统是Windows）或终端（如果您的操作系统是Mac或Linux）中导航到该文件夹。为了简洁起见，从现在开始，我将称其为您的终端，文件夹为目录。
- en: 'Next, we''re going to use our CLI to create the skeleton of our application
    (that is, the root directory), and all the accompanying files and sub-directories
    that the CLI creates for us that are needed for an Angular application. Enter
    the following command:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用CLI来创建我们应用程序的骨架（即根目录），以及CLI为我们创建的所有必需的Angular应用程序所需的文件和子目录。输入以下命令：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**Note**: This will take about a minute to complete.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：这将需要大约一分钟的时间来完成。'
- en: If you see Project realtycarousel successfully created. as the last line of
    output, you should now have a directory named `realtycarousel` that will contain
    all our application files.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看到最后一行输出为Project realtycarousel successfully created.，那么现在你应该有一个名为`realtycarousel`的目录，其中包含我们应用程序的所有文件。
- en: 'The output of the preceding command is displayed in the following screenshot:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令的输出如下截图所示：
- en: '![](assets/b2659de5-4388-4f65-80f5-2b0906a67ef4.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/b2659de5-4388-4f65-80f5-2b0906a67ef4.png)'
- en: 'Let''s now test that we can run it. Navigate to your `realtycarousel` directory
    with the `cd` command:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们测试一下是否可以运行它。使用`cd`命令导航到你的`realtycarousel`目录：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, start our Angular application with the CLI''s server command:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用CLI的服务器命令启动我们的Angular应用程序：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You should see a bunch of lines output to your Terminal. If one of the lines
    is something similar to `*** NG Live Development* Server is listening on localhost:4200,
    open your browser on http://localhost:4200/ **`, and the last line is `webpack:
    Compiled successfully`, then you should open a browser and point it to `http://localhost:4200`.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '你应该在终端看到一堆行输出。如果其中一行类似于`*** NG Live Development* Server is listening on localhost:4200,
    open your browser on http://localhost:4200/ **`，并且最后一行是`webpack: Compiled successfully`，那么你应该打开浏览器并将其指向`http://localhost:4200`。'
- en: If you see a page with the Angular logo, this means that everything was set
    up correctly. You now have an empty Angular application.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看到一个带有Angular标志的页面，这意味着一切都设置正确了。你现在有一个空的Angular应用程序。
- en: You can press *Ctrl* + *C* to stop the CLI's development server.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以按下*Ctrl* + *C*来停止CLI的开发服务器。
- en: Next, let's add several components, which we will reference in our routing configuration.
    Again, don't worry about components for now. We will look at them in depth in
    [Chapter 6](acd5e47c-07a7-4954-993d-360134221325.xhtml), *Building Angular Components*,
    and [Chapter 7](cd8509d5-4bce-4056-8156-557186df18cd.xhtml), *Templates, Directives,
    and Pipes*.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们添加几个组件，我们将在路由配置中引用它们。同样，现在不要担心组件。我们将在[第6章](acd5e47c-07a7-4954-993d-360134221325.xhtml)
    *构建Angular组件* 和 [第7章](cd8509d5-4bce-4056-8156-557186df18cd.xhtml) *模板、指令和管道* 中深入研究它们。
- en: 'Run the following list of CLI commands, one at a time:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 依次运行以下CLI命令列表：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The output of the first command is given in the following screenshot:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个命令的输出如下截图所示：
- en: '![](assets/07479861-06b6-476d-a513-58f1833149a6.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/07479861-06b6-476d-a513-58f1833149a6.png)'
- en: We should see a similar output when we create all the other components.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建所有其他组件时，我们应该看到类似的输出。
- en: We now have the first set of components that we need. Although their templates
    are empty for now, this will be good enough to enable us to configure routing
    for our application.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有了我们需要的第一组组件。虽然它们的模板现在是空的，但这已经足够让我们为我们的应用程序配置路由了。
- en: Since we'll be using Bootstrap for a few things in our application, such as
    its navigation bar and its responsive grid, we need to install Bootstrap along
    with its dependencies. In [Chapter 3](6694dd13-5500-4563-9688-74a21a06a9a9.xhtml),
    *Bootstrap – Grid Layout and Components*, we simply referenced a few CDN URLs
    in the header of our `index.html` page in order to be able to use Bootstrap. However,
    we will now install Bootstrap differently—we'll be using `npm`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将在应用程序中使用Bootstrap进行一些操作，例如其导航栏和响应式网格，我们需要安装Bootstrap以及其依赖项。在[第3章](6694dd13-5500-4563-9688-74a21a06a9a9.xhtml)中，*Bootstrap
    - 网格布局和组件*，我们只是在`index.html`页面的头部引用了一些CDN URL，以便能够使用Bootstrap。但是，我们现在将以不同的方式安装Bootstrap
    - 我们将使用`npm`。
- en: You will need Node.js installed on your system in order to use the **node package
    manager** (**npm**).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要在系统上安装Node.js才能使用**node package manager**（**npm**）。
- en: 'To install Bootstrap, jQuery, and Popper, run the following command in your
    Terminal:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装Bootstrap、jQuery和Popper，请在终端中运行以下命令：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We have installed the libraries, and now it's time to include them in our config
    file so they are available throughout the application.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经安装了库，现在是时候在我们的配置文件中包含它们，以便它们在整个应用程序中可用。
- en: 'Open up the `angular.json` file and include the stylesheet and JavaScript files
    in the respective sections, as shown in the following code snippet:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`angular.json`文件，并在相应的部分中包含样式表和JavaScript文件，如下面的代码片段所示：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The screenshot shows the edited `angular.json` file:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 屏幕截图显示了编辑后的`angular.json`文件：
- en: '![](assets/5521ee4d-875c-45da-b366-fc395f4e7e01.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/5521ee4d-875c-45da-b366-fc395f4e7e01.png)'
- en: All set!
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 一切准备就绪！
- en: We now have the core files that we need to be able to set up routing for our
    application. We also made sure to install Bootstrap because we're going to create
    our navigation bar for our application in this chapter. Moreover, our navigation
    links will contain special tags that Angular uses for routing, which is another
    reason why we needed to install Bootstrap at this point.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了我们需要为应用程序设置路由的核心文件。我们还确保安装了Bootstrap，因为我们将在本章中为我们的应用程序创建导航栏。此外，我们的导航链接将包含Angular用于路由的特殊标签，这也是我们此时需要安装Bootstrap的另一个原因。
- en: Let's open our project using our IDE (again, it's easiest if you're using Visual
    Studio Code—but you can use whichever IDE you prefer), so we can take a look at
    the project structure. Additionally, in the next section, *Completing our route
    configuration*, we'll be making changes to a couple of files for setting things
    up, so you'll want to have a way to easily open and edit those files.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次使用我们的IDE（最好使用Visual Studio Code，但您可以使用您喜欢的任何IDE）打开我们的项目，这样我们就可以查看项目结构。此外，在下一节“完成我们的路由配置”中，我们将对一些文件进行更改以进行设置，因此您需要一种方便打开和编辑这些文件的方式。
- en: With the project now open in your IDE, navigate to the `app` directory, which
    is located within the `src` directory. As Angular developers, we'll be spending
    the vast majority of our time within the `app` directory. Inside the `app` directory,
    you will find a number of files that all start with *app*. These files make up
    the root component (that is, the app component) in our application, and we're
    going to be examining what each of these files does when we come to [Chapter 6](acd5e47c-07a7-4954-993d-360134221325.xhtml),
    *Building Angular Components*, where you will become very familiar with Angular
    components. You will see many subdirectories in the `app` directory—one for each
    component we created just a few moments ago, such as for about, account, home,
    and so on.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在您的IDE中打开项目后，导航到`app`目录，该目录位于`src`目录内。作为Angular开发人员，我们将在`app`目录中度过绝大部分时间。在`app`目录中，您会找到许多以*app*开头的文件。这些文件组成了我们应用程序中的根组件（即应用程序组件），当我们来到[第6章](acd5e47c-07a7-4954-993d-360134221325.xhtml)
    *构建Angular组件*时，我们将会检查这些文件的每个文件的作用，您将会非常熟悉Angular组件。您将在`app`目录中看到许多子目录，每个子目录都是我们刚刚创建的组件，比如about、account、home等。
- en: Remember, the language Angular applications are written in is TypeScript, which
    is what the `.ts` file extension stands for. Let's roll up our sleeves and configure
    routing for our application.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，Angular应用程序的编写语言是TypeScript，这就是`.ts`文件扩展名的含义。让我们开始为我们的应用程序配置路由。
- en: First things first – basic concepts
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 首先要了解的是基本概念
- en: In this section, we will quickly touch base and get an overview of some of the
    basic concepts before we start adding routing to our Angular apps. In the basic
    concepts, we will learn about `Base Href`, `RouterLink`, and `RouterLinkActive`,
    which we will need to implement in our templates while working with Angular routing.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将在开始为我们的Angular应用程序添加路由之前，快速了解一些基本概念的概述。在基本概念中，我们将学习`Base Href`、`RouterLink`和`RouterLinkActive`，这些是我们在使用Angular路由时需要在模板中实现的内容。
- en: Base Href
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Base Href
- en: Every Angular application, in order to compose the links inside the app, should
    have `base href` defined at the parent level.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在应用程序内部组合链接，每个Angular应用程序都应该在父级别定义`base href`。
- en: Open the application generated by the Angular CLI, and look inside the `index.html`
    file. We will see the base `href` defined to `/`, which resolves to be the root
    or top-level hierarchy.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 打开由Angular CLI生成的应用程序，并查看`index.html`文件。我们将看到基本`href`定义为`/`，这将解析为根或顶级层次结构。
- en: 'The following screenshot shows the default base `href` configuration, as generated
    by the Angular CLI:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了由Angular CLI生成的默认基本`href`配置：
- en: '![](assets/86a36aa5-3a0b-4b7a-9775-a45df003382d.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/86a36aa5-3a0b-4b7a-9775-a45df003382d.png)'
- en: RouterLink and RouterLinkActive
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RouterLink和RouterLinkActive
- en: 'In [Chapter 7](cd8509d5-4bce-4056-8156-557186df18cd.xhtml), *Templates, Directives,
    and Pipes*, we will learn in detail about components, directives, and templates.
    For now, just understand that, like the anchor element and `href` attribute in
    HTML5, Angular provides a way to bind the links and the URL resource:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第7章](cd8509d5-4bce-4056-8156-557186df18cd.xhtml)中，*模板、指令和管道*，我们将详细了解组件、指令和模板。现在，只需了解，就像HTML5中的锚元素和`href`属性一样，Angular提供了一种绑定链接和URL资源的方式：
- en: '[PRE6]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the preceding code, we are adding two links. Notice that we have added the
    `routerLink` attribute to the links, which will help us bind the value of `/home`
    and `/listings`, respectively.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们添加了两个链接。请注意，我们已经在链接中添加了`routerLink`属性，这将帮助我们分别绑定`/home`和`/listings`的值。
- en: Also, notice that we have added the `routerLinkActive` attribute and assigned
    the value as `active`. Whenever a user clicks on the link, the Angular router
    will know and make it active. Some call it magic!
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，我们已经添加了`routerLinkActive`属性，并将值分配为`active`。每当用户点击链接时，Angular路由将知道并使其处于活动状态。有些人称之为魔术！
- en: Configuring routes for our application
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为我们的应用程序配置路由
- en: It's time to add Angular routing to our application.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候为我们的应用程序添加Angular路由了。
- en: 'We have two options for implementing routing:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两种实现路由的选项：
- en: We can use the Angular CLI to add routing during the creation of the project
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用Angular CLI在项目创建期间添加路由
- en: Or we can add Angular routing manually into our applications
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者我们可以手动添加Angular路由到我们的应用程序中
- en: First, let's explore the easy way, using the Angular CLI to add routing.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们探索简单的方法，使用Angular CLI添加路由。
- en: The Angular CLI provides us with an easy way to add routing capabilities to
    our Angular application. While generating a new project, the Angular CLI will
    prompt us to select if we want to add routing to our app.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Angular CLI为我们提供了一种简单的方法来为我们的Angular应用程序添加路由功能。在生成新项目时，Angular CLI将提示我们选择是否要为我们的应用程序添加路由。
- en: 'The following screenshot shows the option displayed in the CLI for adding Angular
    routing:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了在CLI中显示添加Angular路由选项：
- en: '![](assets/e1b33a23-33ed-45e9-a4e6-5f78ba72bd9d.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/e1b33a23-33ed-45e9-a4e6-5f78ba72bd9d.png)'
- en: When we choose the option to add routing in our app, we are using the Angular
    CLI to create files, import the required modules, and create the route's rulesets.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们选择在我们的应用程序中添加路由选项时，我们使用Angular CLI创建文件，导入所需的模块，并创建路由规则集。
- en: Now, let's add routing to our project manually. Let's see how we can configure
    routing in our app.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们手动为我们的项目添加路由。让我们看看如何在我们的应用程序中配置路由。
- en: 'In order to configure our routing, we need to follow these steps:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 为了配置我们的路由，我们需要按照以下步骤进行：
- en: Open the `app.module.ts` file
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`app.module.ts`文件
- en: 'Add the following `import` statement to the `import` section at the top of
    the file:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件顶部的`import`部分添加以下`import`语句：
- en: '[PRE7]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`RouterModule` contains the router service and router directives.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`RouterModule`包含路由服务和路由指令。'
- en: The `Routes` module defiles the routes type (remember, TypeScript adds variable
    typing to JavaScript).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`Routes`模块定义了路由类型（记住，TypeScript为JavaScript添加了变量类型）。'
- en: 'Write a few routes and ruleset in the `app-routing.module.ts` file:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`app-routing.module.ts`文件中编写一些路由和规则集：
- en: '[PRE8]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This code only shows three mappings:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码只显示了三个映射：
- en: Mapping for `HomeComponent`
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HomeComponent`的映射'
- en: Mapping for a redirection
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重定向的映射
- en: Mapping for a wildcard, or *catch-all*, the URL request
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通配符或*catch-all*的URL请求的映射
- en: The first mapping object is the simplest case. A URL path (that is, the part
    of the URL that comes after the domain name) maps to one component, without any
    parameters (note routes can be parameterized, and we'll look at that in the *Parameterized
    routes* section shortly). What this route does is instruct Angular to render the `HomeComponent` template
    when the path in the requested URL ends in the home.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个映射对象是最简单的情况。URL路径（即域名后面的部分）映射到一个组件，没有任何参数（注意路由可以被参数化，我们很快会在*参数化路由*部分看到）。这个路由的作用是指示Angular在请求的URL路径以home结尾时呈现`HomeComponent`模板。
- en: The second mapping object is an example of how to get one path to redirect to
    another URL, and, thus, route. This is typically referred to as route redirection.
    In our case, the path is an empty string, which means that when only the domain
    name is entered into the browser location bar, Angular's routing mechanism will
    redirect the request (that is, change the path in the URL) to `/home`. And since
    there is a mapping object that deals with `/home`, it will get triggered, thus
    rendering the `HomeComponent` template. This is a common practice for websites—entering
    just the domain name typically brings the user to the home or index web page.
    In our case, since we're building an SPA (which is what Angular web applications
    are), there is no home page, but rather a home component, meaning that the home
    component's template is rendered to simulate a home page.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: The third mapping object is an example of a wildcard match and is placed as
    the last mapping object. When Angular's routing mechanism parses the requested
    URL, it compares it to the mapping objects from the top down. If the URL does
    not match any of the mapping rulesets, this last mapping object is triggered.
    What this means for our application is that, if there are no matches, the `PageNotFoundComponent` template
    will be rendered.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: 'Now it''s time to import our `appRoutes`; this is how we tell Angular about
    our routes. `appRoutes` is a constant that holds our route mapping, so let''s
    create that next:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Finally, we will need to import the `app-routing.module.ts` file into `app.module.ts`.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The complete code listing of the `app-routing.module.ts` file is in the *Completing
    our route configuration* section later in this chapter.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: We have added the routes directly into `app.module.ts` file. It's a good practice
    to always separate out the route config file separately. Even better, always use
    the Angular CLI to add routing directly when you create the project.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: That's it; we have implemented routing in our project. In the next section,
    we will learn in detail about adding more routes, adding parameters to our routes,
    and creating child routes.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Parameterized routes
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Parameterized routes are routes that have a variable value as part of the URL
    path. For instance, a common example of this is when we reference something by
    its ID, as in the following:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '`/listing/23` (shows property #23 in our realty site)'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/listing/55` (shows property #55 in our realty site)'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/listing/721` (shows property #721 in our realty site)'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clearly, having to configure potentially hundreds of routes would not only be
    tedious, inefficient, and error-prone, but the maintenance of these routes (that
    is, removing routes and adding new ones as the inventory of property listings
    changed) would be troublesome.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, Angular allows for parameterized routes, which solve issues such
    as these.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the updated routes in the following code snippet:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If you look carefully, in the preceding routes we have added one more route,
    which captures the `id` of the listing, and we are also mapping it to the `ListingDetailsComponent `component.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: In other words, we can also say that we have created a generic template for
    listings and, based on the dynamic value passed during runtime, the respective
    data will be displayed by the component.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: That was easy. What if we have a more complex scenario that involves creating
    child routes? Read on.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Child routes
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The routes we have created so far are very easy and straightforward use cases.
    In complex applications, we will need to use deep linking, which refers to hunting
    down a link into many levels under.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at some examples:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '`/home/listings` (shows listings inside home)'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/listing/55/details` (shows the details of listing #55)'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/listing/721/facilities` (shows the facilities of listing #721)'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That's where child routes can be very handy for us to use.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we are creating a child route inside the home route
    path:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the preceding code, we are defining `children` for the *home* path and, again,
    we are specifying the `path` and `component`, which will correspond to the child
    route path.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: OK, fine. This is good stuff.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: What if we want to add some validation before a user can access a particular
    route? like a bouncer outside a club? That bouncer is called a route guard.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: Route guards
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As in most web applications, there are resources (that is, pages/component templates)
    that are accessible to everyone (such as the **Welcome page**, **Pricing page**,
    **About Us** page, and other informational pages), and there are other resources
    that are only meant to be accessed by authorized users (such as a dashboard page
    and an account page). That's where route guards come in, which are Angular's way
    to prevent unauthorized users from accessing protected parts of our application.
    When someone tries to access a URL that is reserved for authorized users, he will
    typically be redirected to the public home page of the application.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: In traditional web applications, the checks and validations are implemented
    in the server-side code and there is practically no option to validate whether
    the user can access the page at the client side. But using the Angular route guard,
    we can implement the checks at the client side without even hitting the backend
    services.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the various types of guards available that we can use in
    our applications to enhance security for authorization:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '`CanActivate`: Helps to check whether the route can be activated or not'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CanActivateChild`: Helps to check whether the route can access child routes
    or not'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CanDeactivate`: Helps to check whether the route can be deactivated or not'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Resolve`: Helps to retrieve route data before activation of any route'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CanLoad`: Verifies whether the user can activate the module that is being
    lazy loaded'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And before we jump into our hands-on exercise, I want to give you a quick overview
    of Angular route guards, such as where to use them, how to use them, what's the
    return type, and so on. Route guards are always injected as a service (that is,
    we have `@injectable` and we will need to inject it). The guards always return
    a Boolean value, `true` or `false`. We can make our route guards return the observables
    or promises, which internally get resolved into a Boolean value.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: We will continue to work on and expand the example we have created in the previous
    section. We are going to add a new component and call it **CRUD**. As a user,
    when you try to access the `crud` route, we will check when the route returns
    `true`. We will allow the user to navigate and see the template; otherwise, the
    application will throw an error prompt.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s dig right into the code to implement route guards. Just as we learned
    how to generate a component or a service, we can use the `ng` command and generate
    a route guard. In the Terminal, run the following command:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We have just generated a new route guard named `activateAdmin`. The output
    of the preceding command is displayed here:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/12833ce7-fa3e-456a-824e-e926a9b69796.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
- en: 'Let''s take a look at the files generated by the Angular CLI. Open the `activate-admin.guard.ts`
    file in the editor. Take a look at the default code generated in the file:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The first few lines are just importing the required `CanActivate`, `ActivatedRouteSnapShot`,
    and `RouterStateSnapshot` modules from the Angular router. Next, we know that
    since route guards are injectable, by using the `@injectable`
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: decorator, we are informing Angular to inject it inside the root. And we are
    creating a class, `ActivatedAdminGuard`, that has a method already created inside
    it named `canActivate`. Note that this method has to return a Boolean value, either
    `true` or `false`. We have created our route guard, so now let's create a route
    now in our `app-routing.module.ts` file.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the updated code of the `app-routing.module.ts` file:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note that in the routes, we have added the `canActivate` interface and, for
    our `crud` path, when we try to launch the `crud` route, since the `canActivate`
    method is returning `true`, the user will be able to see the component template.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: Now, go ahead and set the value to `false` and find out what happens.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: If you see the application's routing go back to `base href`, don't be surprised.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Completing our route configuration
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As promised in previous sections, I will share the entire source code of `AppModule`,
    including the route configurations. The following code may look lengthy or scary,
    but trust me, it's actually very simple and straightforward.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: During the course of learning this chapter, we have generated many components
    and created their route paths. We are just importing the components and updating `appRoutes`
    with their paths. That's it. I promise.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the complete listing of the `app.module.ts` file:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We have just created our routes, but we will need to update our template file
    by creating a few links that will have the path to the aforementioned-defined
    routes.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: One thing that's most important in any application is a well-designed menu,
    which helps guide users and adds to a good user experience.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: Using the Bootstrap `nav` component, we will design a menu for our application
    in the next section.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Bootstrap navigation bar and router links directives
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just before we cover a couple of routing strategies to wrap up this chapter,
    let's circle back and create our Bootstrap navigation bar for our application.
    If you recall from the previous chapter, [Chapter 3](6694dd13-5500-4563-9688-74a21a06a9a9.xhtml), *Bootstrap –
    Grid Layout and Components*, I had mentioned that we'll be covering the Bootstrap
    navigation component in this chapter. The reason for this is that we're going
    to be tying our navigation bar to our routing by using routing directives as the
    menu links, and so the best place to cover that is in this chapter, since it falls
    into the domain of routing.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: In the previous section, I gave you homework to enter the route path URL manually
    in the browser bar to see the routes working, in this section, we will add all
    the route URLs to the Bootstrap `navbar` component, so that the user can just
    click and navigate instead of typing manually.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: At the starting of the chapter, we briefly touched upon `routerLink` and `routerLinkActive`.
    Now it's time to see them in action.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at the `app.component.html` file, which is the template of
    our app component. If you are familiar with the notion of master pages in ASP.NET,
    or a layout page in Rails, then you can consider the app component template as
    the equivalent for Angular applications. This is because the app component is
    the top-level component in the tree of components that will form our application.
    The reason I brought up the notion of a master layout is that whatever HTML is
    inserted into it is preserved by the server by it rendering the called page within
    the layout page. While this is not what happens in Angular, since it's not a server-side
    technology, it does hold true in concept.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: What I mean by this is that whatever HTML we insert into the app component's
    template, it is generally still visible when other components are rendered within
    it. This makes the app component template a perfect place to hold our navigation
    bar, since it'll always be visible regardless of what component template is selected
    to be rendered by our routing rulesets for a given URL that is requested by our
    users.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code listing for our `app.component.html` file:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Take a deep breath, and let''s analyze the preceding lines of code. We are
    using both Angular directives and attributes, along with Bootstrap built-in classes.
    So let''s begin:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: We are creating a menu `navbar` element, `<nav>`, provided in Bootstrap, and
    assigning the built-in `navbar` classes, `navbar-expand-lg navbar-light bg-light`.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are also creating an element and placeholder for the logo of our application
    using the `navbar-brand` class.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `navbar-nav` class, we are defining a collection of links.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are adding few links using the anchor tag, `<a>`, and assigning the `nav-link` class,
    which will form the links in the menu section.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are also creating a drop-down menu using the `dropdown-menu` class and adding
    items to the menu using `dropdown-item`.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For Angular directives and attributes, we are using `routerLink` and `routerLinkActive`
    and, as explained in the *First thing first - basic concepts*, section, the `routerLink`
    attribute is used to bind the URL resource of the link.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To highlight the active link, we are using the `routerLinkActive` attribute.
    You will notice that for all links, we have assigned the attribute value as `active`.
    Angular at runtime will detect the link clicked and will highlight it.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Awesome, good job so far. We have implemented a `nav` menu for our application.
    We are just one step away from seeing our application in action.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Specifying the location for rendering the component templates
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need to tell Angular where we want the component templates, for the mapped
    components in our routing rulesets, to be displayed. For our application, we want
    to have the components that the router calls upon to be rendered under our navigation
    bar.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: Angular has a directive for doing this, `<router-outlet>`, which is defined
    in `RouterModule`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: 'Under the HTML we added for creating our Bootstrap navigation bar, add this
    following line of HTML:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: That's all that is needed to tell Angular where the components that are called
    upon by the routing service should be rendered.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: Running our application
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have completed configuring routing for our application, let's take
    it for a quick spin.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: 'Do you remember how to build and start our Angular application? Right! Use
    the CLI and issue the `serve` command like this:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Make sure you are in the application's root folder when you do this.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: 'A shortcut for starting the application and opening your browser to localhost
    in one fell swoop, is issuing the `ng server` command with the `open` option,
    like this:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: What you should see is that the URL in the browser's location bar is pointing
    to `http://localhost:4200/home`, which is Angular routing at work. The `ng serve`
    command with the `open` option issued the `http://localhost:4200` URL, but this
    triggered the route redirection to `/home`. Pretty cool, huh?
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: 'When we run the application, we should see the output shown in the following
    screenshot:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/98d58a94-73e5-4779-bbe6-a1c4b9200b42.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
- en: In the next section, we will learn about some of the routing strategies we can
    implement in our apps.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: Routing strategies
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two client-side routing strategies in Angular:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '`HashLocationStrategy` (typically used for client-side purposes, such as anchor
    tags)'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PathLocationStrategy` (this is the default)'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To enable `HashLocationStrategy`, in the `app.module.ts` file, where we have
    `RouterModule.forRoot(appRoutes)`, append `{ useHash: true }` as the second parameter
    in the `forRoot` method. This is what it should look like:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'URLs with `HashLocationStrategy` have a hash sign (#) in their path. Here is
    an example:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[http://madeuplistofpeople.com/superheros#cloudman](http://madeuplistofpeople.com/superheros#cloudman)'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: The preceding URL represents a get request to [http://madeuplistofpeople.com/superheros](http://madeuplistofpeople.com/superheros)
    to the server.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Everything from the hash onward is not part of the request, because the browser
    only sends everything in the browser's location bar, to the left of the hash sign,
    to the server.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: The `#cloudman` portion of the URL is used exclusively by the client, and, typically,
    this is used by the browser to automatically scroll down to the anchor tag on
    the page (in this case, to the anchor tag with a `name` attribute of `cloudman`).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: One use of the `HashLocationStrategy` strategy is for using the hash sign to
    store application state, which is convenient for implementing client-side routing
    for an SPA.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, consider the following URLs:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[http://madeuplistofpeople.com/#/about](http://madeuplistofpeople.com/#/about)'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://madeuplistofpeople.com/#/search](http://madeuplistofpeople.com/#/search)'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://madeuplistofpeople.com/#/contactus](http://madeuplistofpeople.com/#/contactus)'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This URL pattern is great for an SPA because the only request going to the server
    is [http://madeuplistofpeople.com](http://madeuplistofpeople.com), which is essentially
    one page. The client side will handle the different hash fragments (that is, from
    the hash sign to the end of the right-hand side of the hash sign) in whichever
    way it was programmed to.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: To wrap up this section, an important concept of `PathLocationStrategy` is that
    Angular takes advantage of an HTML5 history API called pushstate. We can change
    the URL using the pushstate API while suppressing the traditional default action
    by the browser to send the new request (that is, the altered URL) to the server.
    This makes it possible to implement client-side routing without resorting to using
    a hash sign (#). This is why it is the default client-side routing strategy in
    Angular.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: However, there is a downside. If the browser were to be refreshed, a request
    would be made to the server, which would reset your application with whatever
    the server sent back. In other words, your application would lose its state, unless
    you had implemented local storage strategies.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This was a fairly short chapter, but we still covered a lot of ground. In this
    chapter, we created the skeleton for our application, including creating the components
    that we had our routes mapped to. We then went through a step-by-step process
    of configuring routing for our application. This included importing the two required
    modules (that is, `RoutingModule` and `Routes`), coding up routing rulesets in
    the form of mapping objects, and specifying where the routed components were to
    be rendered.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: We also installed and integrated Bootstrap into our application, and created
    our Bootstrap navigation bar in our root component's template. We then took a
    look at how to make Angular aware of installed node packages, Bootstrap and jQuery
    in particular, since that is how we installed Bootstrap and its dependencies (that
    is, jQuery and Popper).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Although we didn't make use of parameterized routes and route guards in this
    chapter, we mentioned them here because we'll be making use of them later in the
    book—in [Chapter 12](9610f27b-03db-4258-8a68-24eb3901117b.xhtml), *Integrating
    Backend Data Services*, and *[Chapter 14](485921eb-86e2-4068-b314-5c62a1545c22.xhtml),
    Advanced Angular Topics—*and in the spirit of the book, discussing things at the
    time we need them and not before, we are deferring their demonstration until the
    appropriate times.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: And to wrap this chapter up, we took a look at the two client-side routing strategies
    that Angular lets us choose from.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: We've mentioned the word *components* over and over again in this chapter, since
    routing maps URL paths to components. We've even created several components using
    the CLI, but we've spent no time understanding components. That's perfectly fine
    because, as was mentioned, you didn't need to understand components in order to
    understand routing. Now that we have routing under our belt, we'll be looking
    at components in the chapters ahead. But just before we do that, there is another
    short chapter, [Chapter 5](7a55c9e9-7f80-41bc-9678-eb191fdc4c2d.xhtml), *Flex-layout
    – Angular's Responsive Layout Engine*, that we're going to quickly cover. It's
    a bit of an odd-ball chapter because Flex-layout is an alternative to Bootstrap's
    responsive grid and, as such, it is not at all required to build an Angular application.
    However, I thought it may be of interest to you. With that said, let's turn our
    attention to Flex-layout.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
