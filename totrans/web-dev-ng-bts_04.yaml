- en: Routing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous chapter was a monster, but it was needed to give you a couple of
    crash courses on two of the technologies you're likely to use, or should definitely
    consider using, in your web development projects (and this is true whether or
    not your project leverages Angular). Additionally, [Chapter 3](6694dd13-5500-4563-9688-74a21a06a9a9.xhtml),
    *Bootstrap – Grid Layout and Components*, was also there to help set the stage
    for the rest of the book.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter is much smaller by comparison, but it marks the true beginning
    of our journey into Angular. Each chapter from this point forward, even [Chapter
    12](9610f27b-03db-4258-8a68-24eb3901117b.xhtml), *Integrating Backend Data Services*,
    where the primary focus is on building backend services in Node and MongoDB, has
    Angular material in it (specifically, how to use Angular's HTTP client and how
    to wrap your code up in an Angular service).
  prefs: []
  type: TYPE_NORMAL
- en: One other note about this chapter that I'd like to point out is that most books
    on Angular don't introduce routing before they introduce Angular templates and
    components, which is fine; but we won't be following that approach. Although routing
    and component templates are inextricably linked together, which is the the likely
    reason that most books discuss routing after components, understanding components
    is not at all a prerequisite for understanding routing.
  prefs: []
  type: TYPE_NORMAL
- en: More generally, most programming books try and present all the material and
    concepts in advance, and then circle back at a later time to try and implement
    them in some fashion. One of the problems with this approach is that it goes against
    the way our brains work when assimilating and internalizing new information. It
    is usually better to immediately use new information, in small incremental steps.
  prefs: []
  type: TYPE_NORMAL
- en: This book focuses on being as practical as possible, as soon as possible, and
    in a way that maximizes the retention and understanding of new material. So, in
    order to accomplish this, we'll be building our example application together throughout
    the book, learning the topics as we need them, and not before. This means that
    we will often implement things that haven't yet been fully explained. They will
    be explained to you as we implement them, or immediately afterward—when your brain
    is primed, and looking for patterns to forment understanding.
  prefs: []
  type: TYPE_NORMAL
- en: So, don't worry about diving in head first—it's usually the best way. I'm your
    guide and I am with you to all the way to the end of the book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is what we''ll be covering together in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Defining what routing is, for Angular applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the shell of our application, as well as its first few components,
    using the CLI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring routing for our application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Taking a look at route redirection, parameterized routes, and route guards
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Completing the routing configuration for our application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Taking a look at routing strategies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's quite a bit to cover (even for a small chapter such as this one), so
    let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: What is routing in Angular?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Routing in Angular is simply a set of rules that map a requested URL to a component.
    This tends to confuse people that are coming to Angular from another technology
    that has routing, especially a technology that is not an SPA (that is, a single-page
    application) framework. Let me explain this a bit.
  prefs: []
  type: TYPE_NORMAL
- en: Angular applications only have one page (hence, the term single-page application),
    as we'll see in a moment when we create our Angular application. Angular components
    have templates, which are standard HTML elements that are used to design the layout
    of the structure for presentation. And as we'll see in [Chapter 6](acd5e47c-07a7-4954-993d-360134221325.xhtml),
    *Building Angular Components*, they also have styles.
  prefs: []
  type: TYPE_NORMAL
- en: As was mentioned in the first chapter of the book, Angular applications can
    be thought of as trees of components. This is to say that components can contain
    other components, and this nesting of components can continue as much as is required
    for your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, although components have templates (note: some web frameworks refer to
    web pages as templates), Angular''s routing maps URL paths to components, not
    to web pages or templates. When the template of the component that the requested
    URL is rendered (and we''ll see how this happens in just a moment), not only is
    that component''s template rendered, but all nested components'' templates are
    also rendered. The top-level component that is mapped to by Angular''s router
    may contain other child components, which in turn can contain other child components,
    and so forth. This is what is meant by a tree of components.'
  prefs: []
  type: TYPE_NORMAL
- en: For the most part, data in Angular applications flow from the parent components
    to their immediate children. It does not flow from the parent component to its
    grandchild component. Moreover, data does not flow upward. It is a unidirectional
    flow—parent to child. I say *for the most part*, because there are techniques
    and libraries that change some of this behavior—for instance, components can talk
    to each other through an intermediary, which we'll look at later on in the book.
    However, by design, and without outside intervention, data flows from parent to
    child.
  prefs: []
  type: TYPE_NORMAL
- en: You'll become familiar with all of this as we progress through the book. All
    you have to understand at this point, to understand routing, is that URLs are
    mapped to components instead of to pages, because Angular applications only have
    one page. The only page in Angular apps is the `index.html` page, which is in
    the app directory. In [Chapter 6](acd5e47c-07a7-4954-993d-360134221325.xhtml),
    *Building Angular Components*, we'll see how our default component gets loaded
    into the `index.html` page. For now, let's get back to routing.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our application's shell using the CLI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is where it all starts. We have now reached the point where we are going
    to use the CLI to create our application's starting point, as well as the first
    bunch of components we'll need to connect them to our routing configuration. We've
    looked at how to install the CLI, and we've even created our first Angular application
    together—although our todo application was a tiny one, just to get our feet wet—back
    in [Chapter 1](f1243d74-a120-408f-8181-cb379b457dd1.xhtml), *Quick Start*.
  prefs: []
  type: TYPE_NORMAL
- en: If you haven't yet installed the CLI, you're definitely going to want to do
    that now. Once you've done that (hopefully, you already have), fire up your CLI,
    and let's begin!
  prefs: []
  type: TYPE_NORMAL
- en: The first order of business is to create a directory on your machine where you're
    going to place all your Angular projects. Don't create a directory for our example
    application, because the CLI will do that for you. Simply create a folder on your
    filesystem and navigate to it from your command line (if your OS is Windows),
    or Terminal (if your OS is a Mac or Linux). For brevity, from here on in, I'll
    be referring to it as your Terminal, and the folders as directories.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we''re going to use our CLI to create the skeleton of our application
    (that is, the root directory), and all the accompanying files and sub-directories
    that the CLI creates for us that are needed for an Angular application. Enter
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '**Note**: This will take about a minute to complete.'
  prefs: []
  type: TYPE_NORMAL
- en: If you see Project realtycarousel successfully created. as the last line of
    output, you should now have a directory named `realtycarousel` that will contain
    all our application files.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of the preceding command is displayed in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/b2659de5-4388-4f65-80f5-2b0906a67ef4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s now test that we can run it. Navigate to your `realtycarousel` directory
    with the `cd` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, start our Angular application with the CLI''s server command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see a bunch of lines output to your Terminal. If one of the lines
    is something similar to `*** NG Live Development* Server is listening on localhost:4200,
    open your browser on http://localhost:4200/ **`, and the last line is `webpack:
    Compiled successfully`, then you should open a browser and point it to `http://localhost:4200`.'
  prefs: []
  type: TYPE_NORMAL
- en: If you see a page with the Angular logo, this means that everything was set
    up correctly. You now have an empty Angular application.
  prefs: []
  type: TYPE_NORMAL
- en: You can press *Ctrl* + *C* to stop the CLI's development server.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's add several components, which we will reference in our routing configuration.
    Again, don't worry about components for now. We will look at them in depth in
    [Chapter 6](acd5e47c-07a7-4954-993d-360134221325.xhtml), *Building Angular Components*,
    and [Chapter 7](cd8509d5-4bce-4056-8156-557186df18cd.xhtml), *Templates, Directives,
    and Pipes*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following list of CLI commands, one at a time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the first command is given in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/07479861-06b6-476d-a513-58f1833149a6.png)'
  prefs: []
  type: TYPE_IMG
- en: We should see a similar output when we create all the other components.
  prefs: []
  type: TYPE_NORMAL
- en: We now have the first set of components that we need. Although their templates
    are empty for now, this will be good enough to enable us to configure routing
    for our application.
  prefs: []
  type: TYPE_NORMAL
- en: Since we'll be using Bootstrap for a few things in our application, such as
    its navigation bar and its responsive grid, we need to install Bootstrap along
    with its dependencies. In [Chapter 3](6694dd13-5500-4563-9688-74a21a06a9a9.xhtml),
    *Bootstrap – Grid Layout and Components*, we simply referenced a few CDN URLs
    in the header of our `index.html` page in order to be able to use Bootstrap. However,
    we will now install Bootstrap differently—we'll be using `npm`.
  prefs: []
  type: TYPE_NORMAL
- en: You will need Node.js installed on your system in order to use the **node package
    manager** (**npm**).
  prefs: []
  type: TYPE_NORMAL
- en: 'To install Bootstrap, jQuery, and Popper, run the following command in your
    Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We have installed the libraries, and now it's time to include them in our config
    file so they are available throughout the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open up the `angular.json` file and include the stylesheet and JavaScript files
    in the respective sections, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The screenshot shows the edited `angular.json` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/5521ee4d-875c-45da-b366-fc395f4e7e01.png)'
  prefs: []
  type: TYPE_IMG
- en: All set!
  prefs: []
  type: TYPE_NORMAL
- en: We now have the core files that we need to be able to set up routing for our
    application. We also made sure to install Bootstrap because we're going to create
    our navigation bar for our application in this chapter. Moreover, our navigation
    links will contain special tags that Angular uses for routing, which is another
    reason why we needed to install Bootstrap at this point.
  prefs: []
  type: TYPE_NORMAL
- en: Let's open our project using our IDE (again, it's easiest if you're using Visual
    Studio Code—but you can use whichever IDE you prefer), so we can take a look at
    the project structure. Additionally, in the next section, *Completing our route
    configuration*, we'll be making changes to a couple of files for setting things
    up, so you'll want to have a way to easily open and edit those files.
  prefs: []
  type: TYPE_NORMAL
- en: With the project now open in your IDE, navigate to the `app` directory, which
    is located within the `src` directory. As Angular developers, we'll be spending
    the vast majority of our time within the `app` directory. Inside the `app` directory,
    you will find a number of files that all start with *app*. These files make up
    the root component (that is, the app component) in our application, and we're
    going to be examining what each of these files does when we come to [Chapter 6](acd5e47c-07a7-4954-993d-360134221325.xhtml),
    *Building Angular Components*, where you will become very familiar with Angular
    components. You will see many subdirectories in the `app` directory—one for each
    component we created just a few moments ago, such as for about, account, home,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Remember, the language Angular applications are written in is TypeScript, which
    is what the `.ts` file extension stands for. Let's roll up our sleeves and configure
    routing for our application.
  prefs: []
  type: TYPE_NORMAL
- en: First things first – basic concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will quickly touch base and get an overview of some of the
    basic concepts before we start adding routing to our Angular apps. In the basic
    concepts, we will learn about `Base Href`, `RouterLink`, and `RouterLinkActive`,
    which we will need to implement in our templates while working with Angular routing.
  prefs: []
  type: TYPE_NORMAL
- en: Base Href
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every Angular application, in order to compose the links inside the app, should
    have `base href` defined at the parent level.
  prefs: []
  type: TYPE_NORMAL
- en: Open the application generated by the Angular CLI, and look inside the `index.html`
    file. We will see the base `href` defined to `/`, which resolves to be the root
    or top-level hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the default base `href` configuration, as generated
    by the Angular CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/86a36aa5-3a0b-4b7a-9775-a45df003382d.png)'
  prefs: []
  type: TYPE_IMG
- en: RouterLink and RouterLinkActive
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 7](cd8509d5-4bce-4056-8156-557186df18cd.xhtml), *Templates, Directives,
    and Pipes*, we will learn in detail about components, directives, and templates.
    For now, just understand that, like the anchor element and `href` attribute in
    HTML5, Angular provides a way to bind the links and the URL resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we are adding two links. Notice that we have added the
    `routerLink` attribute to the links, which will help us bind the value of `/home`
    and `/listings`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Also, notice that we have added the `routerLinkActive` attribute and assigned
    the value as `active`. Whenever a user clicks on the link, the Angular router
    will know and make it active. Some call it magic!
  prefs: []
  type: TYPE_NORMAL
- en: Configuring routes for our application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's time to add Angular routing to our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have two options for implementing routing:'
  prefs: []
  type: TYPE_NORMAL
- en: We can use the Angular CLI to add routing during the creation of the project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Or we can add Angular routing manually into our applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First, let's explore the easy way, using the Angular CLI to add routing.
  prefs: []
  type: TYPE_NORMAL
- en: The Angular CLI provides us with an easy way to add routing capabilities to
    our Angular application. While generating a new project, the Angular CLI will
    prompt us to select if we want to add routing to our app.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the option displayed in the CLI for adding Angular
    routing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/e1b33a23-33ed-45e9-a4e6-5f78ba72bd9d.png)'
  prefs: []
  type: TYPE_IMG
- en: When we choose the option to add routing in our app, we are using the Angular
    CLI to create files, import the required modules, and create the route's rulesets.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's add routing to our project manually. Let's see how we can configure
    routing in our app.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to configure our routing, we need to follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `app.module.ts` file
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following `import` statement to the `import` section at the top of
    the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '`RouterModule` contains the router service and router directives.'
  prefs: []
  type: TYPE_NORMAL
- en: The `Routes` module defiles the routes type (remember, TypeScript adds variable
    typing to JavaScript).
  prefs: []
  type: TYPE_NORMAL
- en: 'Write a few routes and ruleset in the `app-routing.module.ts` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This code only shows three mappings:'
  prefs: []
  type: TYPE_NORMAL
- en: Mapping for `HomeComponent`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mapping for a redirection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mapping for a wildcard, or *catch-all*, the URL request
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first mapping object is the simplest case. A URL path (that is, the part
    of the URL that comes after the domain name) maps to one component, without any
    parameters (note routes can be parameterized, and we'll look at that in the *Parameterized
    routes* section shortly). What this route does is instruct Angular to render the `HomeComponent` template
    when the path in the requested URL ends in the home.
  prefs: []
  type: TYPE_NORMAL
- en: The second mapping object is an example of how to get one path to redirect to
    another URL, and, thus, route. This is typically referred to as route redirection.
    In our case, the path is an empty string, which means that when only the domain
    name is entered into the browser location bar, Angular's routing mechanism will
    redirect the request (that is, change the path in the URL) to `/home`. And since
    there is a mapping object that deals with `/home`, it will get triggered, thus
    rendering the `HomeComponent` template. This is a common practice for websites—entering
    just the domain name typically brings the user to the home or index web page.
    In our case, since we're building an SPA (which is what Angular web applications
    are), there is no home page, but rather a home component, meaning that the home
    component's template is rendered to simulate a home page.
  prefs: []
  type: TYPE_NORMAL
- en: The third mapping object is an example of a wildcard match and is placed as
    the last mapping object. When Angular's routing mechanism parses the requested
    URL, it compares it to the mapping objects from the top down. If the URL does
    not match any of the mapping rulesets, this last mapping object is triggered.
    What this means for our application is that, if there are no matches, the `PageNotFoundComponent` template
    will be rendered.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now it''s time to import our `appRoutes`; this is how we tell Angular about
    our routes. `appRoutes` is a constant that holds our route mapping, so let''s
    create that next:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we will need to import the `app-routing.module.ts` file into `app.module.ts`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The complete code listing of the `app-routing.module.ts` file is in the *Completing
    our route configuration* section later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We have added the routes directly into `app.module.ts` file. It's a good practice
    to always separate out the route config file separately. Even better, always use
    the Angular CLI to add routing directly when you create the project.
  prefs: []
  type: TYPE_NORMAL
- en: That's it; we have implemented routing in our project. In the next section,
    we will learn in detail about adding more routes, adding parameters to our routes,
    and creating child routes.
  prefs: []
  type: TYPE_NORMAL
- en: Parameterized routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Parameterized routes are routes that have a variable value as part of the URL
    path. For instance, a common example of this is when we reference something by
    its ID, as in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/listing/23` (shows property #23 in our realty site)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/listing/55` (shows property #55 in our realty site)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/listing/721` (shows property #721 in our realty site)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clearly, having to configure potentially hundreds of routes would not only be
    tedious, inefficient, and error-prone, but the maintenance of these routes (that
    is, removing routes and adding new ones as the inventory of property listings
    changed) would be troublesome.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, Angular allows for parameterized routes, which solve issues such
    as these.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the updated routes in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: If you look carefully, in the preceding routes we have added one more route,
    which captures the `id` of the listing, and we are also mapping it to the `ListingDetailsComponent `component.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, we can also say that we have created a generic template for
    listings and, based on the dynamic value passed during runtime, the respective
    data will be displayed by the component.
  prefs: []
  type: TYPE_NORMAL
- en: That was easy. What if we have a more complex scenario that involves creating
    child routes? Read on.
  prefs: []
  type: TYPE_NORMAL
- en: Child routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The routes we have created so far are very easy and straightforward use cases.
    In complex applications, we will need to use deep linking, which refers to hunting
    down a link into many levels under.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/home/listings` (shows listings inside home)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/listing/55/details` (shows the details of listing #55)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/listing/721/facilities` (shows the facilities of listing #721)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That's where child routes can be very handy for us to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we are creating a child route inside the home route
    path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we are defining `children` for the *home* path and, again,
    we are specifying the `path` and `component`, which will correspond to the child
    route path.
  prefs: []
  type: TYPE_NORMAL
- en: OK, fine. This is good stuff.
  prefs: []
  type: TYPE_NORMAL
- en: What if we want to add some validation before a user can access a particular
    route? like a bouncer outside a club? That bouncer is called a route guard.
  prefs: []
  type: TYPE_NORMAL
- en: Route guards
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As in most web applications, there are resources (that is, pages/component templates)
    that are accessible to everyone (such as the **Welcome page**, **Pricing page**,
    **About Us** page, and other informational pages), and there are other resources
    that are only meant to be accessed by authorized users (such as a dashboard page
    and an account page). That's where route guards come in, which are Angular's way
    to prevent unauthorized users from accessing protected parts of our application.
    When someone tries to access a URL that is reserved for authorized users, he will
    typically be redirected to the public home page of the application.
  prefs: []
  type: TYPE_NORMAL
- en: In traditional web applications, the checks and validations are implemented
    in the server-side code and there is practically no option to validate whether
    the user can access the page at the client side. But using the Angular route guard,
    we can implement the checks at the client side without even hitting the backend
    services.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the various types of guards available that we can use in
    our applications to enhance security for authorization:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CanActivate`: Helps to check whether the route can be activated or not'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CanActivateChild`: Helps to check whether the route can access child routes
    or not'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CanDeactivate`: Helps to check whether the route can be deactivated or not'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Resolve`: Helps to retrieve route data before activation of any route'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CanLoad`: Verifies whether the user can activate the module that is being
    lazy loaded'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And before we jump into our hands-on exercise, I want to give you a quick overview
    of Angular route guards, such as where to use them, how to use them, what's the
    return type, and so on. Route guards are always injected as a service (that is,
    we have `@injectable` and we will need to inject it). The guards always return
    a Boolean value, `true` or `false`. We can make our route guards return the observables
    or promises, which internally get resolved into a Boolean value.
  prefs: []
  type: TYPE_NORMAL
- en: We will continue to work on and expand the example we have created in the previous
    section. We are going to add a new component and call it **CRUD**. As a user,
    when you try to access the `crud` route, we will check when the route returns
    `true`. We will allow the user to navigate and see the template; otherwise, the
    application will throw an error prompt.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s dig right into the code to implement route guards. Just as we learned
    how to generate a component or a service, we can use the `ng` command and generate
    a route guard. In the Terminal, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We have just generated a new route guard named `activateAdmin`. The output
    of the preceding command is displayed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/12833ce7-fa3e-456a-824e-e926a9b69796.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s take a look at the files generated by the Angular CLI. Open the `activate-admin.guard.ts`
    file in the editor. Take a look at the default code generated in the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The first few lines are just importing the required `CanActivate`, `ActivatedRouteSnapShot`,
    and `RouterStateSnapshot` modules from the Angular router. Next, we know that
    since route guards are injectable, by using the `@injectable`
  prefs: []
  type: TYPE_NORMAL
- en: decorator, we are informing Angular to inject it inside the root. And we are
    creating a class, `ActivatedAdminGuard`, that has a method already created inside
    it named `canActivate`. Note that this method has to return a Boolean value, either
    `true` or `false`. We have created our route guard, so now let's create a route
    now in our `app-routing.module.ts` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the updated code of the `app-routing.module.ts` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Note that in the routes, we have added the `canActivate` interface and, for
    our `crud` path, when we try to launch the `crud` route, since the `canActivate`
    method is returning `true`, the user will be able to see the component template.
  prefs: []
  type: TYPE_NORMAL
- en: Now, go ahead and set the value to `false` and find out what happens.
  prefs: []
  type: TYPE_NORMAL
- en: If you see the application's routing go back to `base href`, don't be surprised.
  prefs: []
  type: TYPE_NORMAL
- en: Completing our route configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As promised in previous sections, I will share the entire source code of `AppModule`,
    including the route configurations. The following code may look lengthy or scary,
    but trust me, it's actually very simple and straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: During the course of learning this chapter, we have generated many components
    and created their route paths. We are just importing the components and updating `appRoutes`
    with their paths. That's it. I promise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the complete listing of the `app.module.ts` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We have just created our routes, but we will need to update our template file
    by creating a few links that will have the path to the aforementioned-defined
    routes.
  prefs: []
  type: TYPE_NORMAL
- en: One thing that's most important in any application is a well-designed menu,
    which helps guide users and adds to a good user experience.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Bootstrap `nav` component, we will design a menu for our application
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Bootstrap navigation bar and router links directives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just before we cover a couple of routing strategies to wrap up this chapter,
    let's circle back and create our Bootstrap navigation bar for our application.
    If you recall from the previous chapter, [Chapter 3](6694dd13-5500-4563-9688-74a21a06a9a9.xhtml), *Bootstrap –
    Grid Layout and Components*, I had mentioned that we'll be covering the Bootstrap
    navigation component in this chapter. The reason for this is that we're going
    to be tying our navigation bar to our routing by using routing directives as the
    menu links, and so the best place to cover that is in this chapter, since it falls
    into the domain of routing.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous section, I gave you homework to enter the route path URL manually
    in the browser bar to see the routes working, in this section, we will add all
    the route URLs to the Bootstrap `navbar` component, so that the user can just
    click and navigate instead of typing manually.
  prefs: []
  type: TYPE_NORMAL
- en: At the starting of the chapter, we briefly touched upon `routerLink` and `routerLinkActive`.
    Now it's time to see them in action.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at the `app.component.html` file, which is the template of
    our app component. If you are familiar with the notion of master pages in ASP.NET,
    or a layout page in Rails, then you can consider the app component template as
    the equivalent for Angular applications. This is because the app component is
    the top-level component in the tree of components that will form our application.
    The reason I brought up the notion of a master layout is that whatever HTML is
    inserted into it is preserved by the server by it rendering the called page within
    the layout page. While this is not what happens in Angular, since it's not a server-side
    technology, it does hold true in concept.
  prefs: []
  type: TYPE_NORMAL
- en: What I mean by this is that whatever HTML we insert into the app component's
    template, it is generally still visible when other components are rendered within
    it. This makes the app component template a perfect place to hold our navigation
    bar, since it'll always be visible regardless of what component template is selected
    to be rendered by our routing rulesets for a given URL that is requested by our
    users.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code listing for our `app.component.html` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Take a deep breath, and let''s analyze the preceding lines of code. We are
    using both Angular directives and attributes, along with Bootstrap built-in classes.
    So let''s begin:'
  prefs: []
  type: TYPE_NORMAL
- en: We are creating a menu `navbar` element, `<nav>`, provided in Bootstrap, and
    assigning the built-in `navbar` classes, `navbar-expand-lg navbar-light bg-light`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are also creating an element and placeholder for the logo of our application
    using the `navbar-brand` class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `navbar-nav` class, we are defining a collection of links.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are adding few links using the anchor tag, `<a>`, and assigning the `nav-link` class,
    which will form the links in the menu section.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are also creating a drop-down menu using the `dropdown-menu` class and adding
    items to the menu using `dropdown-item`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For Angular directives and attributes, we are using `routerLink` and `routerLinkActive`
    and, as explained in the *First thing first - basic concepts*, section, the `routerLink`
    attribute is used to bind the URL resource of the link.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To highlight the active link, we are using the `routerLinkActive` attribute.
    You will notice that for all links, we have assigned the attribute value as `active`.
    Angular at runtime will detect the link clicked and will highlight it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Awesome, good job so far. We have implemented a `nav` menu for our application.
    We are just one step away from seeing our application in action.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying the location for rendering the component templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need to tell Angular where we want the component templates, for the mapped
    components in our routing rulesets, to be displayed. For our application, we want
    to have the components that the router calls upon to be rendered under our navigation
    bar.
  prefs: []
  type: TYPE_NORMAL
- en: Angular has a directive for doing this, `<router-outlet>`, which is defined
    in `RouterModule`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Under the HTML we added for creating our Bootstrap navigation bar, add this
    following line of HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: That's all that is needed to tell Angular where the components that are called
    upon by the routing service should be rendered.
  prefs: []
  type: TYPE_NORMAL
- en: Running our application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have completed configuring routing for our application, let's take
    it for a quick spin.
  prefs: []
  type: TYPE_NORMAL
- en: 'Do you remember how to build and start our Angular application? Right! Use
    the CLI and issue the `serve` command like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Make sure you are in the application's root folder when you do this.
  prefs: []
  type: TYPE_NORMAL
- en: 'A shortcut for starting the application and opening your browser to localhost
    in one fell swoop, is issuing the `ng server` command with the `open` option,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: What you should see is that the URL in the browser's location bar is pointing
    to `http://localhost:4200/home`, which is Angular routing at work. The `ng serve`
    command with the `open` option issued the `http://localhost:4200` URL, but this
    triggered the route redirection to `/home`. Pretty cool, huh?
  prefs: []
  type: TYPE_NORMAL
- en: 'When we run the application, we should see the output shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/98d58a94-73e5-4779-bbe6-a1c4b9200b42.png)'
  prefs: []
  type: TYPE_IMG
- en: In the next section, we will learn about some of the routing strategies we can
    implement in our apps.
  prefs: []
  type: TYPE_NORMAL
- en: Routing strategies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two client-side routing strategies in Angular:'
  prefs: []
  type: TYPE_NORMAL
- en: '`HashLocationStrategy` (typically used for client-side purposes, such as anchor
    tags)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PathLocationStrategy` (this is the default)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To enable `HashLocationStrategy`, in the `app.module.ts` file, where we have
    `RouterModule.forRoot(appRoutes)`, append `{ useHash: true }` as the second parameter
    in the `forRoot` method. This is what it should look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'URLs with `HashLocationStrategy` have a hash sign (#) in their path. Here is
    an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://madeuplistofpeople.com/superheros#cloudman](http://madeuplistofpeople.com/superheros#cloudman)'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding URL represents a get request to [http://madeuplistofpeople.com/superheros](http://madeuplistofpeople.com/superheros)
    to the server.
  prefs: []
  type: TYPE_NORMAL
- en: Everything from the hash onward is not part of the request, because the browser
    only sends everything in the browser's location bar, to the left of the hash sign,
    to the server.
  prefs: []
  type: TYPE_NORMAL
- en: The `#cloudman` portion of the URL is used exclusively by the client, and, typically,
    this is used by the browser to automatically scroll down to the anchor tag on
    the page (in this case, to the anchor tag with a `name` attribute of `cloudman`).
  prefs: []
  type: TYPE_NORMAL
- en: One use of the `HashLocationStrategy` strategy is for using the hash sign to
    store application state, which is convenient for implementing client-side routing
    for an SPA.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, consider the following URLs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://madeuplistofpeople.com/#/about](http://madeuplistofpeople.com/#/about)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://madeuplistofpeople.com/#/search](http://madeuplistofpeople.com/#/search)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://madeuplistofpeople.com/#/contactus](http://madeuplistofpeople.com/#/contactus)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This URL pattern is great for an SPA because the only request going to the server
    is [http://madeuplistofpeople.com](http://madeuplistofpeople.com), which is essentially
    one page. The client side will handle the different hash fragments (that is, from
    the hash sign to the end of the right-hand side of the hash sign) in whichever
    way it was programmed to.
  prefs: []
  type: TYPE_NORMAL
- en: To wrap up this section, an important concept of `PathLocationStrategy` is that
    Angular takes advantage of an HTML5 history API called pushstate. We can change
    the URL using the pushstate API while suppressing the traditional default action
    by the browser to send the new request (that is, the altered URL) to the server.
    This makes it possible to implement client-side routing without resorting to using
    a hash sign (#). This is why it is the default client-side routing strategy in
    Angular.
  prefs: []
  type: TYPE_NORMAL
- en: However, there is a downside. If the browser were to be refreshed, a request
    would be made to the server, which would reset your application with whatever
    the server sent back. In other words, your application would lose its state, unless
    you had implemented local storage strategies.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This was a fairly short chapter, but we still covered a lot of ground. In this
    chapter, we created the skeleton for our application, including creating the components
    that we had our routes mapped to. We then went through a step-by-step process
    of configuring routing for our application. This included importing the two required
    modules (that is, `RoutingModule` and `Routes`), coding up routing rulesets in
    the form of mapping objects, and specifying where the routed components were to
    be rendered.
  prefs: []
  type: TYPE_NORMAL
- en: We also installed and integrated Bootstrap into our application, and created
    our Bootstrap navigation bar in our root component's template. We then took a
    look at how to make Angular aware of installed node packages, Bootstrap and jQuery
    in particular, since that is how we installed Bootstrap and its dependencies (that
    is, jQuery and Popper).
  prefs: []
  type: TYPE_NORMAL
- en: Although we didn't make use of parameterized routes and route guards in this
    chapter, we mentioned them here because we'll be making use of them later in the
    book—in [Chapter 12](9610f27b-03db-4258-8a68-24eb3901117b.xhtml), *Integrating
    Backend Data Services*, and *[Chapter 14](485921eb-86e2-4068-b314-5c62a1545c22.xhtml),
    Advanced Angular Topics—*and in the spirit of the book, discussing things at the
    time we need them and not before, we are deferring their demonstration until the
    appropriate times.
  prefs: []
  type: TYPE_NORMAL
- en: And to wrap this chapter up, we took a look at the two client-side routing strategies
    that Angular lets us choose from.
  prefs: []
  type: TYPE_NORMAL
- en: We've mentioned the word *components* over and over again in this chapter, since
    routing maps URL paths to components. We've even created several components using
    the CLI, but we've spent no time understanding components. That's perfectly fine
    because, as was mentioned, you didn't need to understand components in order to
    understand routing. Now that we have routing under our belt, we'll be looking
    at components in the chapters ahead. But just before we do that, there is another
    short chapter, [Chapter 5](7a55c9e9-7f80-41bc-9678-eb191fdc4c2d.xhtml), *Flex-layout
    – Angular's Responsive Layout Engine*, that we're going to quickly cover. It's
    a bit of an odd-ball chapter because Flex-layout is an alternative to Bootstrap's
    responsive grid and, as such, it is not at all required to build an Angular application.
    However, I thought it may be of interest to you. With that said, let's turn our
    attention to Flex-layout.
  prefs: []
  type: TYPE_NORMAL
