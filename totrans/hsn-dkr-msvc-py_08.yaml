- en: Using Kubernetes to Coordinate Microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will talk about the basic concepts behind Kubernetes, a
    tool that allows you to manage multiple containers and coordinate them, thereby
    making the microservices that have been deployed on each container work in unison.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will cover what a container orchestrator is and specific Kubernetes
    nomenclature, such as the differences between a pod, a service, a deployment,
    and so on. We will also learn how to analyze a running cluster and perform other
    common operations so that you can apply them to our microservices example.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Defining the Kubernetes orchestrator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the different Kubernetes elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing basic operations with kubectl
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Troubleshooting a running cluster
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you'll know about the basic elements of Kubernetes
    and will be able to perform basic operations. You'll also learn about basic troubleshooting
    skills so that you can detect possible issues.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you''re working with macOS or Windows, the default Docker desktop installation
    can start a local Kubernetes cluster. Just ensure that this is enabled in Kubernetes''
    preferences:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/4437849f-7f85-4020-a25b-34dba652aa6b.png)'
  prefs: []
  type: TYPE_IMG
- en: For Linux, the easiest way to install Kubernetes locally is to use k3s ([https://k3s.io/](https://k3s.io/)).
  prefs: []
  type: TYPE_NORMAL
- en: k3s is a nod to Kubernetes (that is, k8s) but is a simplified version of it.
  prefs: []
  type: TYPE_NORMAL
- en: k3s is a minimalistic installation of Kubernetes that you can use to run a cluster
    contained in a single binary. Check out the installation page ([https://github.com/rancher/k3s/blob/master/README.md](https://github.com/rancher/k3s/blob/master/README.md))
    if you wish to download and run it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To be able to use the Docker version that''s running inside the k3s cluster,
    we need to use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Ensure that you install `kubectl` (k3s installs a separate version of it by
    default). The steps to install `kubectl` can be found at [https://kubernetes.io/docs/tasks/tools/install-kubectl/](https://kubernetes.io/docs/tasks/tools/install-kubectl/).
    The `kubectl` command controls Kubernetes operations.
  prefs: []
  type: TYPE_NORMAL
- en: Check the instructions on the aforementioned page to add Bash completion, which
    will allow us to hit *Tab* to complete some commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'If everything has been correctly installed, you should be able to check the
    running pods with the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note the different namespaces. They are all default ones that were created by
    Kubernetes itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to the following page to install the Ingress controller: [https://github.com/kubernetes/ingress-nginx/blob/master/docs/deploy/index.md](https://github.com/kubernetes/ingress-nginx/blob/master/docs/deploy/index.md).
    In Docker desktop, you''ll need to run these two commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This will create an `ingress-nginx` namespace with a controller pod. Kubernetes
    will use that pod to set up the Ingress configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's take a look at the advantages of using Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the Kubernetes orchestrator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kubernetes is a popular container orchestration tool. It allows us to manage
    and deploy multiple containers that interact with each other in a coordinated
    way. Since each microservice lives in an individual container, as we mentioned
    in [Chapter 1](ddb0a00a-6c5b-4ffe-b403-0f5f9f7a7df2.xhtml), *Making the Move –
    Design, Plan, and Execute*, they can work in unison.
  prefs: []
  type: TYPE_NORMAL
- en: For a more in-depth introduction to Kubernetes, you can check out the following
    comic, which was released by Scott McCloud: [https://cloud.google.com/kubernetes-engine/kubernetes-comic/](https://cloud.google.com/kubernetes-engine/kubernetes-comic/).
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes is aimed at production systems. It was designed to be able to control
    big deployments and to abstract most of the infrastructure's details. Every element
    in a Kubernetes cluster is configured programmatically, and Kubernetes itself
    manages where to deploy clusters based on the capacity that's available.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes can be configured completely using configuration files. This makes
    it possible to replicate clusters, for example, in the event of a full disaster
    that brings down all the physical servers. You can even do this with different
    hardware, where traditional deployments could be extremely difficult.
  prefs: []
  type: TYPE_NORMAL
- en: This example assumes that the data is stored and retrievable; for example, in
    a backup device. Obviously, this may be difficult—disaster recovery always is.
    However, it simplifies a lot of the steps that are required if you wish to replicate
    a cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Given that Kubernetes works with containers and makes it very easy to install
    them, there's a big ecosystem of containers ready to add functionality to Kubernetes
    itself. The best example is probably the Kubernetes dashboard ([https://kubernetes.io/docs/tasks/access-application-cluster/web-ui-dashboard/](https://kubernetes.io/docs/tasks/access-application-cluster/web-ui-dashboard/)),
    a UI that displays an overview of Kubernetes' operations. It isn't installed by
    default, but it can be installed in the same way that you install your services.
    Other examples for such use cases include monitoring and logging. This makes Kubernetes
    very extendable.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing Kubernetes with Docker Swarm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kubernetes is not the only orchestrator that's available. As we mentioned in [Chapter
    3](05dd2141-e113-43a2-8bd9-26fb97057913.xhtml), *Build, Run, and Test Your Service
    Using Docker*, there's `docker-compose`. Docker Compose can also orchestrate different
    containers and coordinate them but does so without dealing with multiple servers.
  prefs: []
  type: TYPE_NORMAL
- en: Docker has a native extension of `docker-compose` called Docker Swarm. This
    allows us to use a cluster of machines to run `docker-compose` while reusing the
    same YAML files, but with a few added details to describe how you want them to
    run.
  prefs: []
  type: TYPE_NORMAL
- en: You can learn more about Docker Swarm in the official documentation ([https://docs.docker.com/engine/swarm/](https://docs.docker.com/engine/swarm/)).
  prefs: []
  type: TYPE_NORMAL
- en: Docker Swarm is easier to set up than Kubernetes, assuming that you have to
    manage the servers. As you extend the functionality of Docker Compose, you'll
    find that it has a low learning curve.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, Kubernetes is way more powerful and customizable. It has
    a bigger community and a higher pace of innovation. It's also better at handling
    issues. The biggest problem is setting up a cluster, but as we'll see in [Chapter
    7](92e63376-1c9e-4c63-9f7f-c34fa6848ef3.xhtml), *Configuring and Securing the
    Production System*, nowadays, there are easy commercial deployments we can use
    to create a cluster in a few minutes, which lowers the barrier of entry for Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: This makes Kubernetes (arguably) a better solution when you're dealing with
    migrating from the old system and when looking toward the future. For small deployments,
    or if you need to deploy and manage your own servers, Docker Swarm can be an interesting
    alternative.
  prefs: []
  type: TYPE_NORMAL
- en: To help you move on from using a `docker-compose.yaml` file to using the equivalent
    Kubernetes YAML files, you can use `kompose` ([https://github.com/kubernetes/kompose](https://github.com/kubernetes/kompose)). It
    may be useful to quickly start a Kubernetes cluster and translate the services
    described in the `docker-compose.yaml` file into their equivalent Kubernetes elements,
    but there are always differences between both systems that may need to be tweaked.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by describing the specific elements and nomenclature of Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the different Kubernetes elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kubernetes has its own nomenclature for different elements. We will be using
    the nomenclature often in this book, and the Kubernetes documentation uses them
    as well. Learning about the differences between them is important since some of
    them can be subtle.
  prefs: []
  type: TYPE_NORMAL
- en: Nodes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main infrastructure elements of Kubernetes are known as **nodes**. A Kubernetes
    cluster is composed of one or more nodes, which are the physical machines (or
    virtual machines) that support the abstraction of the rest of the elements.
  prefs: []
  type: TYPE_NORMAL
- en: Each node needs to be able to communicate with the others, and they all run
    in a *container runtime—*typically Docker—but they can use other systems, such
    as `rktlet` ([https://github.com/kubernetes-incubator/rktlet](https://github.com/kubernetes-incubator/rktlet)).
  prefs: []
  type: TYPE_NORMAL
- en: The nodes create a network between them that routes all the requests that have
    been addressed to the cluster so that any request that's sent to any node in the
    cluster will be answered adequately. Kubernetes will handle what deployable goes
    to what node, even recovering nodes if they go down or moving them around from
    one node to another if there are resources issues.
  prefs: []
  type: TYPE_NORMAL
- en: Nodes don't necessarily need to be identical, and some degree of control is
    needed when it comes to deploying specific elements in specific nodes, but for
    simplicity, they normally are identical.
  prefs: []
  type: TYPE_NORMAL
- en: While nodes are the backbone that supports the cluster, Kubernetes helps in
    abstracting away from specific nodes by defining the desired outcome and letting
    Kubernetes do the heavy lifting of deciding what goes where and being sure that
    the internal network channels' requests are sent to the proper services.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes Control Plane
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Kubernetes Control Plane is where all the processes that Kubernetes uses
    to properly configure a collection of servers as nodes in a Kubernetes cluster
    are kept. Servers allow nodes to connect to each other, allow us to monitor their
    current status, and allows us to make whatever changes are necessary in terms
    of deployment, scale, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The node that's responsible for registering and making these changes is called
    the master node. There can be more than one master node.
  prefs: []
  type: TYPE_NORMAL
- en: All of this control normally runs smoothly behind the scenes. Its network is
    separated from the rest, meaning that a problem at this level won't affect the
    current operation of the cluster, other than us not being able to make changes.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes Objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kubernetes Objects are abstractions that represent the state of the service
    that's deployed in the cluster. Mainly, they deal with running containers and
    routings for those containers, as well as persistent storage.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the different elements, from smallest to biggest. This
    list is not exhaustive; check out the Kubernetes documentation for more details:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Container**: A single Docker container. These are the building blocks of 
    Kubernetes, but they''re never present on their own.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pod: **A basic unit that can be deployed in Kubernetes. A pod is a collection
    of one or more containers that work as a unit, normally from different images.
    Normally, a pod has a single container, but sometimes it may be useful to have
    more. All of the containers in the same pod share the same IP address (the pod
    IP), meaning that a container that accesses a port in `localhost` may be accessing
    a different container instead. This is actually the recommended way of communicating
    with them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This will all be a bit strange to you at first, but normally, multi-container
    pods will have a main container and something else that performs auxiliary tasks,
    such as exporting metrics.
  prefs: []
  type: TYPE_NORMAL
- en: '**ConfigMap**: This defines a set of key-value pairs that can be injected into
    pods, typically as environment variables or files. This allows us to share configurations
    between different defined pods, for example, to make all the containers log debug
    information. Note that pods can have their own configuration, but ConfigMaps are
    a convenient way to share the same values so that they are available to different
    pods.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Volume**: The files that are inside a container are ephemeral and will be
    lost if the container stops its execution. A volume is a form of persistent storage
    that can be used to maintain data information between starts and to share information
    between containers in a pod.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a general principle, try to have as few volumes as possible. Most of your
    applications should be stateless anyway, and any variable data should be stored
    in a database. If containers in the same pod need to communicate, it is better
    to do so through HTTP requests. Remember that any immutable data, such as static
    files, can be stored inside the container image.
  prefs: []
  type: TYPE_NORMAL
- en: '**Deployment**: This is a grouping of one or more identical pods. The definition
    of the deployment will state the desired number and Kubernetes will work to get
    to this, according to whatever strategy is defined. The pods in a single deployment
    can be deployed to different nodes, and normally will be. If any of the pods are
    deleted, finished, or have any kind of problem, the deployment will start another
    until the defined number is reached.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Job**: A job creates one or more pods that are expected to finish. While
    a deployment will assume that any pod that''s finishing is a problem and will
    start another, jobs will retry until the proper number of successes is met. The
    finished pods are not deleted, which means we can check their logs. Jobs are one-off
    executions. There are also **Cron Jobs**, which will run at specific times.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Service**. Since pods are created and recreated and have different IPs, to
    allow services to access them, a service needs to define the name that other elements
    can use to discover it. In other words, it routes requests to the proper pods.
    Normally, a service and a deployment will be related, with the service making
    the deployment accessible and round-robin between all the defined pods. A service
    can also be used to create an internal name for an external service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Services in Kubernetes solve an old problem in distributed systems, that is, *service
    discovery*. This problem occurs when nodes in a cluster need to know where a service
    lives, even if the nodes change; that is, when we add a node or remove it without
    changing the configuration settings of all the nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes will do this automatically if you create a service.
  prefs: []
  type: TYPE_NORMAL
- en: '**Ingress**: While a service is internal, an Ingress is external. It routes
    any external requests to the appropriate service so that they can be served. You
    can define different Ingresses by host name, which ensures that the cluster is
    routed to different services by the target host of the request, or a single Ingress
    is hosted in terms of its path. Internally, an Ingress is implemented as a container
    that implements the Ingress controller, which is `nginx` by default.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Depending on your Kubernetes installation, you may need to install the default
    controller. To install the default controller, follow the instructions at [https://github.com/kubernetes/ingress-nginx/blob/master/docs/deploy/index.md](https://github.com/kubernetes/ingress-nginx/blob/master/docs/deploy/index.md).
  prefs: []
  type: TYPE_NORMAL
- en: '**Namespace**: This is the definition of a virtual cluster. You can define
    more than one namespace in the same physical Kubernetes cluster. Every name that''s
    defined under a namespace needs to be unique, but another namespace could use
    the same definition. Objects in different namespaces can''t communicate with each
    other internally, but they can do so externally.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating different namespaces with very similar definitions can be useful
    if you wish to create different environments for purposes, such as testing, development,
    or demo concepts. The main advantage of Kubernetes is that you can replicate a
    whole system and take advantage of this to create similar environments with small
    changes in terms of details, such as a new version of an environment.
  prefs: []
  type: TYPE_NORMAL
- en: Objects can be found in `.yaml` files, which can be loaded into the system.
    A single `.yaml` file can define multiple objects, for example, a deployment that
    defines pods that contain containers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram summarizes the different objects that are available:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/487eb397-f409-4b5b-9467-33572ff2452a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Jobs and volumes are not present, but two services are available: one that
    points toward a deployment and another that points toward an external service.
    The external service is aimed at internal elements and isn''t exposed externally.'
  prefs: []
  type: TYPE_NORMAL
- en: Performing basic operations with kubectl
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By using `kubectl`, we can perform operations against all the different elements.
    We've already had a sneak peek at `get` to get an idea of what elements are available.
  prefs: []
  type: TYPE_NORMAL
- en: For more information and a quick overview of the most common operations that
    are available within `kubectl`, check out the `kubectl` cheat sheet at [https://kubernetes.io/docs/reference/kubectl/cheatsheet/](https://kubernetes.io/docs/reference/kubectl/cheatsheet/).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use `kubectl` to `create` a new element. For example, to create and
    list namespaces, we can use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We can create various elements, some of which we'll look at throughout this
    book.
  prefs: []
  type: TYPE_NORMAL
- en: Defining an element
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A namespace is a special case as it doesn''t require any configuration. To
    create a new element, a YAML file needs to be created that describes that element.
    For example, we can create a new pod using the official NGINX image in Docker
    Hub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'As a minimum, an element should contain the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The API version of the element.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The element's type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A name for the element, as well as a namespace for it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `spec` section that includes configuration details. For a pod, we need to
    add the necessary containers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: YAML files can be a bit temperamental sometimes, especially when it comes to
    indentation and syntax. You can use a tool such as Kubeval ([https://kubeval.instrumenta.dev/](https://kubeval.instrumenta.dev/))
    to check that the file is correct and that you're following Kubernetes good practices
    before using a file.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will save this file as `example_pod.yml`. We''ll create it by using the
    `apply` command and monitor that it''s running with the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Note the usage of the `-n` parameter to determine the namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now `exec` into the container and run commands inside it. For example,
    to check that the NGINX server is running and serving files, we can use the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The pod can be changed in two ways. The first way is to manually run `edit`,
    which opens your predefined Terminal editor so that you can edit the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ll see the pod with all its default parameters. This way of changing a
    pod is useful for small tests, but in general, it''s better to change the original
    YAML file so that you can keep track of the changes that occur. For example, we
    can change NGINX so that we''re using a previous version of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can `apply` these changes once more, which will restart the pod:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Getting more information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `get` command accepts more configuration. You can retrieve more information
    by using the `wide` output option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'If you make a change and are interested in the changes that this produces,
    you can use the `-w` argument to watch any change. For example, the following
    code shows the restart results of a pod. This restart has been produced due to
    a change being made to the image of the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If you need more information about a particular element, you can `describe`
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This returns a lot of information. The most useful information is normally about
    events, which will return information about the life cycle of the element.
  prefs: []
  type: TYPE_NORMAL
- en: Removing an element
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `delete` command removes an element and everything under it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Be aware that, sometimes, deleting an element will cause it to be recreated.
    This is quite common when pods are created through deployments since the deployment
    will work to get the number of pods to the configured number.
  prefs: []
  type: TYPE_NORMAL
- en: Troubleshooting a running cluster
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main tools that we can use to troubleshoot issues in Kubernetes are the
    `get` and `describe` commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'In my experience, the most common problem with running Kubernetes is that,
    sometimes, certain pods don''t start. The steps for troubleshooting are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Is the container image correct? A problem with downloading the image will show
    `ErrImagePull`. This could be caused if the image can't be downloaded from the
    registry due to an authentication problem.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A status of `CrashLoopBackOff` means that the process for the container has
    been interrupted. The pod will try to restart over and over. This is normally
    caused by an underlying issue with the container. Check that the configuration
    is correct. You can check the `stdout` logs of a container by using the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Ensure that the container is runnable. Try to run it manually using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: A pod is not exposed externally. This is typically due to a problem in the service
    and/or Ingress that exposes them. You can detect whether a pod is responsive inside
    the cluster by using `exec` to get into another container and then try to access
    the service and the internal IP of the pod, normally using `curl`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As we saw previously, `curl` is not installed in containers by default because,
    normally, they only install a minimal set of tools. Don't worry—you can install
    it using whatever package manager your operating system uses, with the advantage
    that, once the container is recycled (which will happen soon enough in a normal
    Kubernetes operation), it won't be using up any space! For the same reason, you
    may need to install it each time you need to debug a problem.
  prefs: []
  type: TYPE_NORMAL
- en: Remember the chain we discussed for Ingress, services, deployments, and pods
    and work from the inside out to find out where the misconfiguration is.
  prefs: []
  type: TYPE_NORMAL
- en: 'While troubleshooting, remember that pods and containers can be accessed through
    `exec` commands, which will allow us to check running processes, files, and much
    more. This is similar to accessing the Terminal of a physical server. You can
    do this using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Be careful as the nature of Kubernetes clusters may require you to check a specific
    container in a pod if there is more than one container running in the same pod.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at the basic concepts of Kubernetes and how it's
    useful to manage and coordinate multiple containers that contain our microservices.
  prefs: []
  type: TYPE_NORMAL
- en: First, we introduced what Kubernetes is and some of its high-level advantages.
    Then, we described the different elements that define a cluster in the Kubernetes
    nomenclature. This included both the physical aspects, where the nodes are the
    main defining elements, as the abstract aspects, such as the pods, deployments,
    services, and Ingress, which are the building blocks we need in order to generate
    a working cluster.
  prefs: []
  type: TYPE_NORMAL
- en: We described `kubectl` and the common operations we can use to define elements
    and retrieve information through YAML files. We also described some of the common
    problems that can arise when handling a Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will define the different options we can use in YAML
    files in order to generate clusters and learn how to generate a Kubernetes cluster
    for our microservices example.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is a container orchestrator?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Kubernetes, what is a node?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between a pod and a container?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between a job and a pod?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When should we add an Ingress?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a namespace?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can we define a Kubernetes element in a file?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between the `get` and `describe` commands of `kubectl`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does a `CrashLoopBackOff` error indicate?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can learn more about Kubernetes by reading *Getting Started with Kubernetes
    – Third Edition* ([https://www.packtpub.com/eu/virtualization-and-cloud/getting-started-kubernetes-third-edition](https://www.packtpub.com/eu/virtualization-and-cloud/getting-started-kubernetes-third-edition))
    and *The Complete Kubernetes Guide* ([https://www.packtpub.com/eu/virtualization-and-cloud/complete-kubernetes-guide](https://www.packtpub.com/eu/virtualization-and-cloud/complete-kubernetes-guide)).
  prefs: []
  type: TYPE_NORMAL
