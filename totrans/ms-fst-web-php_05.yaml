- en: Measuring and Optimizing Database Performance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the first chapter of this book, we used the `mysqlslap` tool to learn how
    to do basic MySQL benchmarking. In this chapter, we will use this tool and others
    to do more advanced benchmarking with our MariaDB (MySQL) server. But, first,
    we will learn query optimization techniques that will use some of MySQL's built-in
    features in order to better analyze our SQL queries.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, we will learn how to measure and optimize database performance through
    the use of simple measurement techniques such as query optimization. Also, we
    will see how to use advanced database benchmarking tools, such as **DBT2** and
    **SysBench**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, we will cover the following points:'
  prefs: []
  type: TYPE_NORMAL
- en: Measuring and optimizing SQL query performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing, configuring and using advanced database benchmarking tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SQL query performance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to better understand SQL query performance, we must first understand
    what indexes are and how they are built.
  prefs: []
  type: TYPE_NORMAL
- en: The structure of indexes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An index is an ordered list of table elements. These elements are first stored
    in a physically unordered doubly linked list. The list is doubly linked to the
    table through pointers to the table entries and to a second structure that stores
    the index values in a logical order, a balanced tree or b-tree. Thus, indexes
    have an algorithmic complexity that is logarithmic—`O(log n)`—for read operations
    on average, which means that the database engine should maintain speed even if
    there is a significant number of entries in the table. Indeed, an index lookup
    implies three steps:'
  prefs: []
  type: TYPE_NORMAL
- en: The tree traversal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Searching the leaf node chain
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fetching the data from the table
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thus, an index lookup is great when reading from the b-tree only, as you avoid
    the linear—`O(n)`—full table scan, for example. That being said though, you can
    never avoid the overhead complexity caused by keeping the index up to date when
    writing to the table.
  prefs: []
  type: TYPE_NORMAL
- en: 'This brings us to our first consideration about query optimization: what is
    the final purpose of the table''s data? Are we simply logging information or are
    we storing a user''s shopping cart items? Are we querying a table that is mostly
    read from or written to? This is important, as optimizing one `SELECT` query might
    slow down a whole series of other `INSERT` or `UPDATE` queries to the same table.'
  prefs: []
  type: TYPE_NORMAL
- en: A second consideration would be the nature of the table's data. Are we trying
    to index values that generate equivocity for example, thus forcing the database
    engine to do further lookups in the leaf nodes of the b-tree in order to determine
    all the values that truly fulfill the expectations of a specific query? When equivocity
    is an issue, we might end up with a "slow index" or what is often called the "degenerated
    index".
  prefs: []
  type: TYPE_NORMAL
- en: A third consideration is the economy of efficiency surrounding the act of querying
    the table. How powerful is the underlying computer? How many users are querying
    the table at a given time on average? Is scalability important?
  prefs: []
  type: TYPE_NORMAL
- en: One last consideration is the storage size of the data. It is important to know
    that, as a general rule, indexes grow, on average, to about 10% of the original
    table's size. Therefore, when tables are large in size, it is expected that the
    table's indexes will be bigger in size also. And, of course, the bigger the index,
    the longer you will be waiting due to I/O latency.
  prefs: []
  type: TYPE_NORMAL
- en: These considerations will determine which query to optimize and how to optimize
    it. Sometimes, optimizing is doing nothing.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we better understand indexes, let's start analyzing simple SQL queries
    in order to understand database engine execution plans.
  prefs: []
  type: TYPE_NORMAL
- en: The execution plan
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will begin understanding the execution plan by analyzing simple `WHERE`
    clauses. To do so, we will use our first Linux for PHP Docker container. In the
    first chapter, we loaded the Sakila database into the MariaDB (MySQL) server.
    We will now use it to learn how an execution plan works and when to use query
    optimization techniques. Once on the container''s CLI, enter the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'These commands should yield the following results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c6ff4e46-8bc9-4631-a7e4-89980e967449.png)The result of the SELECT
    statement'
  prefs: []
  type: TYPE_NORMAL
- en: 'At first glance, this query seems to be fine with an execution time of 0.00
    seconds. But, is this truly the case? To further analyze this query, we will have
    to have a look at the database engine''s execution plan. To do so, enter the keyword
    `EXPLAIN` at the beginning of the query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The following results give us some information on the execution plan:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/1958748c-a572-4ccb-b21f-ed4b2bf1d60b.png)The execution plan of the
    same SELECT statement'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take the time to define each column of this result set:'
  prefs: []
  type: TYPE_NORMAL
- en: The `id` column tells us in what order tables were joined. In this case, there
    is only one table.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `select_type` is `SIMPLE`, which means that there were no subqueries, unions,
    or dependent query types done to execute this query.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `table` column gives us the name of the table that was the object of the
    query. If it had been a temporary materialized table, we would have seen the expression
    `<subquery#>` in this column.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `type` column is very important for query optimization. It gives us information
    on table access and how rows are found and retrieved from the table. In this case,
    a red flag is raised because we can see that the value of this column is `ALL`.
    To read further on the different possible values of this very important column,
    please consult the MariaDB manual at [https://mariadb.com/kb/en/library/explain/](https://mariadb.com/kb/en/library/explain/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `possible_keys` column informs us of keys in the table that could be used
    to answer the query. In this example, the value is `NULL`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `key` column indicates the key that was actually used. Here, again, the
    value is `NULL`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A value in the `key_len` column would mean that only a certain number of bytes
    of a multi-column key was used to complete the query lookup.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ref` column tells us which columns or constants are used to compare against
    the used index. Of course, since no index was used to execute this query, the
    value of this column is `NULL` also.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `rows` column indicates the number of rows the database engine will have
    to examine in order to complete its execution plan. In this example, the engine
    has to go through the 200 rows. If the table was large and had to be joined to
    a previous table, performance would drop fairly quickly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last column is the `Extra` column. This column will give us more information
    on the execution plan. In this example, the database engine uses the `WHERE` clause
    as it has to do a full table scan.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic query optimization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to start optimizing this query, we must go through what I have called
    previously *initial considerations* of query optimization. For the sake of this
    example, let's say that this table will be the object of `READ` queries more than
    `WRITE` queries because the data will remain fairly static once written to the
    table. Also, it is important to note that creating an index on the `first_name` column
    of the `actor` table will make the index prone to generating equivocity due to
    non-unique values in this column. Moreover, let's say that scalability is important
    because we intend on having many users querying this table every hour and that
    the table size should remain manageable on a long-term period.
  prefs: []
  type: TYPE_NORMAL
- en: 'This being given and known, we will therefore proceed to create an index on
    the `first_name` column of the `actor` table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Once done, MariaDB confirms the creation of the index:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/da6584c8-040d-4242-aecf-9778747dbeb5.png)Confirmation that the index
    was created'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the index has been created, we obtain this result when asking the
    database engine to `EXPLAIN` its execution plan:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/46556c09-fbd4-42ff-87f7-a4b6be3f25f7.png)The execution plan is now
    optimized'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `type` column''s value is now `ref`, `possible_keys` is `idx_first_name`,
    `key` is `idx_first_name`, `ref` is `const`, `rows` is `1` and `Extra` is `Using
    index condition`. As we can see, the engine has now identified our newly created
    index as a possible key to use and then proceeds to use it. It uses the constant
    value given in our query to perform the lookup in the index and considers only
    one row when accessing the table. All of this is great but, as we expected in
    our initial considerations, the index is composed of non-unique values. The possible
    equivocity amongst values of the table column might lead to a degenerated index over
    time, hence the access type of `ref` and the extra information indicating that
    the engine is `Using index condition`, which means that the `WHERE` clause is
    pushed down to the table engine for optimization at the index level. In this example,
    with the admitted initial considerations, this is, in the absolute sense, the
    best query optimization that we can do, as it is impossible to get unique values
    in the `first_name` column of the actor table. But, in fact, there is a possible
    optimization depending on the domain use case. If we only wish to use the actor''s
    first name, then we could further optimize the `Using index condition` in the
    `Extra` column by only selecting the appropriate column, thus allowing the database
    engine to only access the index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The database engine then confirms that it is only using the index in the `Extra` column:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ebc4a318-7c49-4160-a4d4-d36a39a6c763.png)The ''Extra'' column now
    contains the information "Using where; Using index"'
  prefs: []
  type: TYPE_NORMAL
- en: And, how does all of this translate into overall performance? Let's run a few
    benchmark tests in order to measure the effects of our changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will run a benchmark test without the index. On the container''s
    CLI, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are the results without the index:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/cd474d43-c861-4658-ac3f-cc890426f7cb.png)The results of the benchmark
    test WITHOUT the use of the index'
  prefs: []
  type: TYPE_NORMAL
- en: 'And, the results with the index:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/f1911b9c-74cb-4ee2-913a-1d78acbef8a8.png)The results of the benchmark
    test WITH the use of the index'
  prefs: []
  type: TYPE_NORMAL
- en: 'And, finally, let''s run the same command while only selecting the appropriate
    column, thus limiting the lookup to the index only:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are the results of this last benchmark test:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/2da239cc-d059-4f8d-bab9-fb0901f6b289.png)The results of the benchmark
    test WITH the use of the index ONLY'
  prefs: []
  type: TYPE_NORMAL
- en: The benchmark test results clearly show that our query optimization did indeed
    satisfy our initial scalability assumption, especially if we were to see the table
    grow in size and our database become more popular with a growing number of users
    over time.
  prefs: []
  type: TYPE_NORMAL
- en: The performance schema and advanced query optimization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The art of query optimization can be pushed a little further still by using
    MariaDB's (MySQL) performance schema to profile queries. Query profiling allows
    us to see what is happening under the hood and to further optimize complex queries.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin, let''s enable the performance schema on our database server. To do
    so, enter these commands on the Linux for PHP container''s CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The database engine will confirm that some rows were modified in the `performance_schema` database:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ee3f513b-60ad-470a-bb21-119e8e4a32f0.png)The ''performance_schema''
    database has been modified'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now check that the performance schema is now enabled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The database engine should return the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/d20cb158-9530-418a-970e-b1e9ccedfaba.png)Confirmation that the performance
    schema is now enabled'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that profiling is enabled and ready, let''s run a complex query on the
    Sakila database. Using subqueries with the `NOT IN` clause often forces the engine
    to iteratively make an extra check against the main query. These queries can be
    optimized using `JOIN` statements. We will take the following query and run it
    on our database server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the query yields the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/7ced38ee-b513-43a5-8826-a37ad6f6ecc5.png)The result of the SELECT
    statement'
  prefs: []
  type: TYPE_NORMAL
- en: 'And, here are the results when using the `EXPLAIN` statement on the previous
    query:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/86930d8f-4d59-483e-b63c-d88e17888a41.png)The execution plan of the
    same SELECT statement'
  prefs: []
  type: TYPE_NORMAL
- en: 'As we can see, the engine is doing a full table scan and uses a materialized
    subquery to complete its lookup. To see what is happening under the hood, we will
    have to see what events the profiler has recorded concerning this query. To do
    so, enter the following query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Once this query is run, you will obtain the original query''s unique identifier:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/d55d0b65-ef49-4bbe-9e7c-2803b6098f18.png)The original query''s identifier'
  prefs: []
  type: TYPE_NORMAL
- en: 'This information allows us to run the following query in order to get the list
    of the underlying events that took place when we ran our original query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is what we find in MariaDB''s performance schema concerning our original
    query:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/607a03e2-2260-4f04-9cb8-6248030c084d.png)The query''s profile reveals
    one particularly long operation'
  prefs: []
  type: TYPE_NORMAL
- en: This result shows that the `NOT IN` clause caused the database engine to create
    a materialized subquery, as the inner query was optimized as a semi-join subquery.
    Thus, the engine had to do a few optimization operations before running the query
    and the materialized subquery. Moreover, the result shows that the materialized
    subquery was the most costly operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The easiest way to optimize these subqueries is to replace them with proper
    `JOIN` statements in the main query, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'By running this query, we obtain the same results from the database, but the
    `EXPLAIN` statement reveals a whole new execution plan in order to get the exact
    same results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/dded5339-419e-4b6b-8567-1c783240e7c0.png)The new execution plan
    shows only ''SIMPLE'' select types'
  prefs: []
  type: TYPE_NORMAL
- en: 'The subqueries have disappeared and have become simple queries. Let''s see
    what the performance schema recorded this time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The profiler recorded the following results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/b8d72d82-9786-4c81-8cfb-fe6a09fbe834.png)The new query''s profile
    reveals considerable performance improvements'
  prefs: []
  type: TYPE_NORMAL
- en: The results clearly show that fewer optimization operations occurred in the
    initialization phases of the execution plan and that query execution as such was
    approximately seven times faster. Not all materialized subqueries can be optimized
    in this way but, when optimizing queries, a materialized subquery, a dependent
    subquery or an uncacheable subquery should always inspire us to ask ourselves
    if we can do any better.
  prefs: []
  type: TYPE_NORMAL
- en: For further information on query optimization, you can listen to a great presentation
    given on this topic by Michael Moussa at *Nomad PHP* ([https://nomadphp.com/product/mysql-analysis-understanding-optimization-queries/](https://nomadphp.com/product/mysql-analysis-understanding-optimization-queries/)).
  prefs: []
  type: TYPE_NORMAL
- en: Advanced benchmarking tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Until now we have used the `mysqlslap` benchmarking tool. But, if you need
    to test your database server more thoroughly, other more advanced benchmarking
    tools do exist. We will have a quick look at two of these tools: DBT2 and SysBench.'
  prefs: []
  type: TYPE_NORMAL
- en: DBT2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This benchmarking tool is used in order to run automated benchmarking tests
    against a MySQL server. It allows you to mimic large amounts of data warehouses.
  prefs: []
  type: TYPE_NORMAL
- en: 'To download, compile and install DBT2, please enter the following commands
    on the container''s CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the data warehouses have been created, you should see the following messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/7cb92b53-f9a6-4766-9c52-1f26c9d3510a.png)Confirmation that the database
    warehouses have been created'
  prefs: []
  type: TYPE_NORMAL
- en: 'You will now have to modify the file `scripts/mysql/mysql_load_db.sh` using
    the vi editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Once inside the editor, type `/LOAD DATA` and press *Enter*. Position your
    cursor at the end of this line, press `*I*` and enter the word `IGNORE` in uppercase.
    Your file should look like this once you are done editing it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/eaf14be8-ed22-41b0-8fa6-7e582f14ca29.png)Inserting the string "IGNORE"
    on the "LOAD DATA" line of the ''mysql_load_db.sh'' script'
  prefs: []
  type: TYPE_NORMAL
- en: Once done, press the *Esc *key and then type `:wq`. This will save the changes
    and close the vi editor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, enter the following command to load the test data into the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the data has been loaded into the database, you should see the following
    messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a892a632-2f5b-4892-8cce-6008167b2eb8.png)Confirmation that the data
    is being loaded into the database'
  prefs: []
  type: TYPE_NORMAL
- en: 'To launch the test, enter this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have entered the command, you will first see this message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/e1b03e63-3a1a-4d00-8d98-029e48929aac.png)Confirmation that the tests
    have begun'
  prefs: []
  type: TYPE_NORMAL
- en: 'You will also get the following messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c7de45f4-984c-4ee5-876c-e1da8f1af596.png)Confirmation that the tests
    are running'
  prefs: []
  type: TYPE_NORMAL
- en: 'After approximately five minutes, you will get the results of the benchmark
    tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c43b7135-035f-4634-b870-c451b74939a6.png)Confirmation that the tests
    are completed'
  prefs: []
  type: TYPE_NORMAL
- en: As we can see from the given results, we can have a good idea of our database
    server's performance in the context of large data warehouses. Additional tests
    could easily confirm the server's limits through edge-case testing. Let's run
    one such test using SysBench.
  prefs: []
  type: TYPE_NORMAL
- en: SysBench
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SysBench is another very popular open source benchmark testing tool. This tool
    not only allows you to test open source RDBMSs, but also your hardware (CPU, I/O,
    and so on).
  prefs: []
  type: TYPE_NORMAL
- en: 'To download, compile and install SysBench, please enter the following commands
    inside the Linux for PHP Docker container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, enter the following command to create a table with 1 million rows as the
    test data into the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the data has been loaded into the database, you should see the following
    messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/0eb6eee6-2020-4ae0-8e10-7ac10fbe7a04.png)Confirmation that the test
    data has been loaded into the database'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to run the test, enter this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have entered the previous command, you will first get the following
    message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/69a93d24-c499-4d1e-ae12-1e31dbf2de7d.png)Confirmation that the tests
    are running'
  prefs: []
  type: TYPE_NORMAL
- en: 'After a few minutes, you should get results similar to these:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/9914961f-d1d6-405e-9167-a12a46df3bb6.png)The results of the SysBench
    tests'
  prefs: []
  type: TYPE_NORMAL
- en: The results show that the MariaDB server on my computer can handle approximately
    2,300 transactions per second and 33,000 read/write requests per second. These
    edge-case tests can give us a very good idea of the general performance level
    that we can expect from our hardware and our database server.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned how to measure and optimize database performance
    through the use of simple measurement techniques such as query optimization. Also,
    we have seen how to use advanced database benchmarking tools such as DBT2 and
    SysBench.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will see how to use modern SQL techniques in order to
    optimize very complex SQL queries.
  prefs: []
  type: TYPE_NORMAL
