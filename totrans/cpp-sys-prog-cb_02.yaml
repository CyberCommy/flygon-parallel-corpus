- en: Revisiting C++
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter acts as a refresher on C++ 11-20, which will be used throughout
    this book. We'll explain why C++ represents a great opportunity that shouldn't
    be missed when it comes to writing good quality code that's concise and more portable
    than ever.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter does not contain *all* the new features introduced by C++ (11 through
    20) – just the ones we will be using for the rest of this book. Specifically,
    you'll get a refresher (if you already know) or learn (if you are new) about the
    most essential new C++ skills needed to write modern code. You'll work, hands-on,
    with lambda expressions, atomics, and move semantics, just to mention a few.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding C++ primitive types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lambda expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automatic type deduction and `decltype`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning how atomic works
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning how `nullptr` works
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Smart pointers – `unique_ptr` and `shared_ptr`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning how semantics works
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding concurrency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the filesystem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The C++ Core Guidelines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding GSL to your makefile
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding concepts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using span
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning how Ranges work
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning how modules work
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To let you try out the programs in this chapter immediately, we've set up a
    Docker image that has all the tools and libraries we'll need throughout this book.
    It's based on Ubuntu 19.04.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to set it up, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Download and install the Docker Engine from [www.docker.com](http://www.docker.com).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pull the image from Docker Hub: `docker pull kasperondocker/system_programming_cookbook:latest`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The image should now be available. Type in the following command to view the
    image: `docker images`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, you should have the following image: `kasperondocker/system_programming_cookbook`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the Docker image with an interactive shell with the help of the following
    command: `docker run -it --cap-add sys_ptrace kasperondocker/system_programming_cookbook:latest /bin/bash`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The shell on the running container is now available. Use `root@39a5a8934370/#
    cd /BOOK/` to get all the programs that have been developed for the chapters in
    this book.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `--cap-add sys_ptrace` argument is needed to allow GDB to set breakpoints
    in the Docker container which, by default, Docker does not allow.
  prefs: []
  type: TYPE_NORMAL
- en: '**Disclaimer**: The C++20 standard has been approved (that is, technically
    finalized) by WG21 in a meeting in Prague at the end of February. This means that
    the GCC compiler version that this book uses, 8.3.0, does not include (or has
    very, very limited support for) the new and cool C++20 features. For this reason,
    the Docker image does not include the C++20 recipe code. GCC keeps the development
    of the newest features in branches (you have to use appropriate flags for that,
    for example, `-std=c++2a`); therefore, you are encouraged to experiment with them
    by yourself. So, clone and explore the GCC contracts and module branches and have
    fun.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding C++ primitive types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will show all the primitive data types defined by the C++ standard,
    as well as their size.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we''ll have a closer look at what primitives the C++ standard
    defines and what other information is important. We''ll also learn that although
    the standard does not define a size for each, it defines another important parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, open a new Terminal and type in the following program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Next, build (compile and link) `g++ primitives.cpp`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This will produce an executable file with the (default) name of `a.out`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The output of the preceding program will be something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/17a5c520-563d-45b6-b17d-5e3c197d535a.png)'
  prefs: []
  type: TYPE_IMG
- en: This represents the minimum and maximum values that a type can represent and
    the size in bytes for the current platform.
  prefs: []
  type: TYPE_NORMAL
- en: The C++ standard **does not** define the size of each type, but it does define
    the minimum **width***:*
  prefs: []
  type: TYPE_NORMAL
- en: '`char`: Minimum width = 8'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`short int`: Minimum width = 16'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int`: Minimum width = 16'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`long int`: Minimum width = 32'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`long int int`: Minimum width = 64'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This point has huge implications as different platforms can have different
    sizes and a programmer should cope with this. To help us get some guidance regarding
    data types, there is the concept of a data model. A **data model** is a set of
    choices (a specific size for each type) made by each implementation (the psABI
    of the architecture that compilers and operating systems adhere to) to define
    all the primitive data types. The following table shows a subset of various types
    and data models that exist:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Data type** | **LP32** | **ILP32** | **LLP64** | **LP64** |'
  prefs: []
  type: TYPE_TB
- en: '| `char` | 8 | 8 | 8 | 8 |'
  prefs: []
  type: TYPE_TB
- en: '| `short int` | 16 | 16 | 16 | 16 |'
  prefs: []
  type: TYPE_TB
- en: '| `int`  | 16 | 32 | 32 | 32 |'
  prefs: []
  type: TYPE_TB
- en: '| `long` | 32 | 32 | 32 | 64 |'
  prefs: []
  type: TYPE_TB
- en: '| `pointer` | 32 | 32 | 64 | 64 |'
  prefs: []
  type: TYPE_TB
- en: The Linux kernel uses the LP64 data model for 64-bit architectures (x86_64).
  prefs: []
  type: TYPE_NORMAL
- en: 'We briefly touched on the psABI topic (short for **platform-specific Application
    Binary Interfaces** (**ABIs**)). Each architecture (for example, x86_64) has a
    psABI specification that the OS adheres to. The **GNU Compiler Collection** (**GCC**)
    has to know these details as it has to know the sizes of the primitive types it
    compiles. The `i386.h` GCC header file contains the size of the primitive data
    types for that architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The program output shows that the current OS (actually, the Ubuntu image we're
    running) uses the LP64 data model as expected and that the machine's architecture
    is x86_64.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we''ve seen, the C++ standard defines the following primitive data types:'
  prefs: []
  type: TYPE_NORMAL
- en: Integer: `int`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Character: `char`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Boolean: `bool`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Floating point: `float`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Double floating point: `double`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Void: `void`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wide character: `wchar_t`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Null pointer: `nullptr_­t`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Data types can have other information so that their types can be defined:'
  prefs: []
  type: TYPE_NORMAL
- en: Modifiers: `signed`, `unsigned`, `long`, and `short`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Qualifiers: `const` and `restrict`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storage type: `auto`, `static`, `extern`, and `mutable`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Obviously, not all these additional attributes can be applied to all the types;
    for example, `unsigned` cannot be applied to the `float` and `double` types (their
    respective IEEE standards would not allow that).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Specifically for Linux, the Linux kernel documentation is generally a good place
    to start digging more into this: [https://www.kernel.org/doc/html/latest](https://www.kernel.org/doc/html/latest/).
    The GCC source code shows the sizes of the primitive data types for every supported
    architecture. Refer to the following link to find out more: [https://github.com/gcc-mirror/gcc](https://github.com/gcc-mirror/gcc).
  prefs: []
  type: TYPE_NORMAL
- en: Lambda expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **lambda expression** (or **lambda** **function**) is a convenient way of
    defining an anonymous, small, and one-time use function to be used in the place
    right where it is needed. Lambda is particularly useful with **Standard Template
    Library** (**STL**), as we'll see.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we''ll write some code in order to get familiar with lambda
    expressions. Although the mechanics are important, pay attention to the code readability
    with lambda, especially in conjunction with STL. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this program, the lambda function gets an integer and prints it to standard
    output. Let''s open a file named `lambda_01.cpp` and write the following code
    in it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In this second program, the lambda function captures a prefix by reference
    and prepends it to the integer in the standard output. Let''s write the following
    code in a file called `lambda_02.cpp`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we compile it with `g++ lambda_02.cpp`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the first example, the lambda function just gets an integer as input and
    prints it. Note that the code is concise and readable. Lambda can capture the
    variables in scope by reference, `&`, or by value, `=`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of the second program is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/271646b2-f3b5-450a-ad5c-ed95229b6c34.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the second example, the lambda **captures**the variable prefix by reference,
    making it visible to the lambda. Here, we captured the `prefix` variable by reference,
    but we might have captured any of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: All the variables by reference `[&]`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the variables by value `[=]`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specifying *what variables to capture* and *how to capture them* `[&var1, =var2]`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are cases where we have to be explicit about the type to return, as in
    this case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `-> std::vector<int>` operator, called **trailing return type**, tells the
    compiler that this lambda will return a vector of integers.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Lambda can be decomposed into six parts:'
  prefs: []
  type: TYPE_NORMAL
- en: Capture clause: `[]`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Parameter list: `()`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Mutable specification: `mutable`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Exception specification: `noexcept`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Trailing return type: `-> type`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Body: `{}`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Here, *1*, *2*, and *6* are mandatory.
  prefs: []
  type: TYPE_NORMAL
- en: Although optional, mutable specification and exception specification are worth
    having a look at as they might be handy in some circumstances. The mutable specification
    allows a by-valueparameter to be modified by the body of the lambda. A variable
    in the parameter list is typically captured *const-by-value*, so the mutable specification
    just removes this restriction. The second case is the exception specification,
    which we can use to specify the exceptions the lambda might throw.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The books *Effective Modern C++* by Scott Meyers and *The C++ Programming Language* by Bjarne
    Stroustrup cover these topics in great detail.
  prefs: []
  type: TYPE_NORMAL
- en: Automatic type deduction and decltype
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'C++ offers two mechanisms for deducting types from an expression: `auto` and
    `decltype()`. `auto` is used to deduce a type from its initializer, while `decltype()`
    is used to deduce a type for more complex cases. This recipe will show examples
    of how to use both.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It might be handy (and it actually is) to avoid explicitly specifying the type
    of variable that will be used, especially when it is particularly long and used
    very locally:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with a typical example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s rewrite it with `auto`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look at another example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '`decltype()` is another mechanism offered by C++ that can deduce the type of
    expression when the expression is more complex than the `auto` case.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at this using an example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Could we use `auto` instead of `decltype()` in these two examples? We'll take
    a look in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first example with `auto` shows that the type is deduced, at compile time,
    from the right-hand parameter. `auto` is used in simple cases.
  prefs: []
  type: TYPE_NORMAL
- en: '`decltype()` deduces the type of expression. In the example, it defines the
    `y` variable so that it''s the same type as `a`. As you can imagine, this would
    not be possible with `auto`. Why? This is pretty simple: `decltype()` tells the
    compiler to *define a variable of a specific type*; in the first example, `y`
    is a variable with the same type as `a`. With `auto`*,* the type is deduced automatically.'
  prefs: []
  type: TYPE_NORMAL
- en: We should use `auto` and `decltype()` anytime we don't have to explicitly specify
    the type of a variable; for example, when we need a `double` type (and not a `float`).
    It's worth mentioning that both `auto` and `decltype()` deduct types of expressions
    that are already known to the compiler, so **they are not runtime mechanisms**.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is a specific case that must be mentioned. When `auto` uses `{}` (uniform
    initializers) for type deduction, it can cause some headaches (or at least behaviors
    that we wouldn''t expect). Let''s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the type that's being deduced is `initializer_list<T>` and not
    an array of integers, as we could expect.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The books *Effective Modern C++* by Scott Meyers and *The C++ Programming Language* by Bjarne
    Stroustrup cover these topics in great detail.
  prefs: []
  type: TYPE_NORMAL
- en: Learning how atomic works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Traditionally, C and C++ have a long tradition of portable code for system programming.
    The `atomic` feature that was introduced in the C++11 standard reinforces this
    by adding, natively, the guarantee that an operation is seen as atomic by other
    threads. Atomic is a template, such as `template <class T> struct atomic;` or `template
    <class T> struct atomic<T*>;`. C++20 has added `shared_ptr` and `weak_ptr` to
    `T` and `T*`. Any operation that's performed on the `atomic` variable is now protected
    from other threads.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`std::atomic` is an important aspect of modern C++ for dealing with concurrency.
    Let''s write some code to master the concept:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first snippet of code shows the basics of `atomic` operations. Let''s write
    this now:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In this second program, we can see that the `is_lock_free()` method returns
    `true` if the implementation is lock-free or if it has been implemented using
    a lock. Let''s write this code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Let's compile the program. When doing so, you may need to add the `atomic` library
    to g++ (due to a GCC bug) with `g++ atomic.cpp -latomic`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`std::atomic<int> speed (0);` defines a `speed` variable as an atomic integer.
    Although the variable will be atomic, this initialization** is not atomic**! Instead,
    the following code: `speed +=10;` atomically increases the speed of `10`. This
    means that there will not be race conditions. By definition, a race condition
    happens when among the threads accessing a variable, at least 1 is a writer.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `std::cout << "current speed is: " << speed;` instruction reads the current
    value of the speed automatically. Pay attention to the fact that reading the value
    from speed is atomic but what happens next is not atomic (that is, printing it
    through `cout`). The rule is that read and write are atomic but the surrounding
    operations are not, as we''ve seen.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of the second program is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/878ed611-133b-41a3-8388-b49f0f8a688e.png)'
  prefs: []
  type: TYPE_IMG
- en: The basic operations for atomic are load, store, swap, and **cas** (short for **compare
    and swap**), which are available on all types of atomics. Others are available,
    depending on the types (for example, `fetch_add`).
  prefs: []
  type: TYPE_NORMAL
- en: 'One question remains open, though. How come `myArray` uses locks and `myStr`
    is lock-free? The reason is simple: C++ provides a lock-free implementation for
    all the primitive types, and the variables inside `MyStr` are primitive types.
    A user will set `myStr.a` and `myStr.b`. `MyArray`, on the other hand, is not
    a fundamental type, so the underlying implementation will use locks.'
  prefs: []
  type: TYPE_NORMAL
- en: The standard guarantee is that for each atomic operation, every thread will
    make progress. One important aspect to keep in mind is that the compiler makes
    code optimizations quite often. The use of atomics imposes restrictions on the
    compiler regarding how the code can be reordered. An example of a restriction
    is that no code that preceded the write of an `atomic` variable can be moved *after*
    the atomic write.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we''ve used the default memory model called `memory_order_seq_cst`.
    Some other memory models that are available are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`memory_order_relaxed`: Only the current operation atomicity is guaranteed.
    That is, there are no guarantees on how memory accesses in different threads are
    ordered with respect to the atomic operation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`memory_order_consume`: The operation is ordered to happen once all accesses
    to memory in the releasing thread that carry a dependency on the releasing operation
    have happened.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`memory_order_acquire`: The operation is ordered to happen once all accesses
    to memory in the releasing thread have happened.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`memory_order_release`: The operation is ordered to happen before a consume
    or acquire operation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`memory_order_seq_cst`: The operation is sequentially consistent ordered.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The books *Effective Modern C++* by Scott Meyers and *The C++ Programming Language* by Bjarne
    Stroustrup cover these topics in great detail. Furthermore, the *Atomic Weapons* talk
    from Herb Sutter, freely available on YouTube ([https://www.youtube.com/watch?v=A8eCGOqgvH4](https://www.youtube.com/watch?v=A8eCGOqgvH4)),
    is a great introduction.
  prefs: []
  type: TYPE_NORMAL
- en: Learning how nullptr works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before C++11, the `NULL` identifier was meant to be used for pointers. In this
    recipe, we'll see why this was a problem and how C++11 solved it.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To understand why `nullptr` is important, let''s look at the problem with `NULL`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s rewrite the preceding code using `nullptr`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first program might not compile or (if it does) call the wrong method.
    We would expect it to call `bool speedUp (char* speed);` instead. The problem
    with `NULL` was exactly this: `NULL` was defined as `0`, which is an integer type,
    and used by the **pre-processor** (which was replacing all the occurrences of
    `NULL` with `0`). This is a huge difference as `nullptr` is now among the C++
    primitives types and managed by the **compiler**.'
  prefs: []
  type: TYPE_NORMAL
- en: For the second program, the `speedUp` (overloaded) method is called with the
    `char*` pointer to `nullptr`. There is no ambiguity here – we're calling the version
    with the `char*` type.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`nullptr` represents *a pointer that does not point to any object*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Due to this, there is no ambiguity, which means that readability improves.
    Another example that improves readability is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This makes the code more readable and clearly indicates that we're comparing
    a pointer.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The books *Effective Modern C++* by Scott Meyers and *The C++ Programming Language* by Bjarne
    Stroustrup cover these topics in great detail.
  prefs: []
  type: TYPE_NORMAL
- en: Smart pointers – unique_ptr and shared_ptr
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will show the basic usage of `unique_ptr` and `shared_ptr`. These
    smart pointers are the main helpers for programmers who don't want to deal with
    memory deallocation manually. Once you've learned how to use them properly, this
    will save headaches and nights of debugging sessions.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we''ll look at the basic use of two smart pointers, `std::unique_ptr`
    and `std::shared_ptr`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s develop a `unique_ptr` example by developing the following class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s develop a `main` class by calling the preceding class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Let's compile `g++ unique_ptr_01.cpp`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Another example with `unique_ptr` shows its behavior with arrays. Let''s reuse
    the same class (`CruiseControl`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see `std::shared_ptr` in action with a small program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '`main` looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The *How it works...* section will describe these three programs in detail.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By running the first `unique_ptr` program, that is, `./a.out`, we get the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a50a8dd3-47ed-411d-bb58-ac9a532dff0c.png)'
  prefs: []
  type: TYPE_IMG
- en: '`unique_ptr` is a **smart pointer** that embodies the concept of unique ownership.
    Unique ownership, simply put, means that there is one and only one variable that
    can *own* a pointer. The first consequence of this concept is that the copy operator
    is not allowed on two unique pointer variables. Just `move` is allowed, where
    the ownership is transferred from one variable to another. The executable that
    was run shows that the object is deallocated at the end of the current scope (in
    this case, the `main` function): `CruiseControl object destroyed`. The fact that
    the developer doesn''t need to bother remembering to call `delete` when needed,
    but still keep control over memory, is one of the main advantages of C++ over
    garbage collector-based languages.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the second `unique_ptr` example, with arrays, there are three objects of
    the `CruiseControl` type that have been allocated and then released. For this,
    the output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/54984bcf-dcb3-49ff-aeaa-a0c0aac1599c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The third example shows usage of `shared_ptr`. The output of the program is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9aecd0d1-6647-41a7-9f60-fcc91164b7aa.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `shared_ptr` smart pointer represents the concept that an object is being
    pointed at (that is, by the owner) by more than one variable. In this case, we''re
    talking about shared ownership. It is clear that the rules are different from
    the `unique_ptr` case. An object**cannot be released** until at least one variable
    is using it. In this example, we defined a `cruiseControlMaster` variable pointing
    to `nullptr`. Then, we defined a block and in that block, we defined another variable:
    `cruiseControlSlave`. So far, so good! Then, still inside the block, we assigned
    the `cruiseControlSlave` pointer to `cruiseControlMaster`. At this point, the
    object allocated has two pointers: `cruiseControlMaster` and `cruiseControlSlave`.
    When this block is closed, the `cruiseControlSlave` destructor is called but the
    object is not freed as it is still used by another one: `cruiseControlMaster`!
    When the program finishes, we see the `shared_ptr test finished` log and immediately
    after the `cruiseControlMaster`, as it is the only one pointing to the `CruiseControl`
    object release, the object and then the constructor is called, as reported in
    the `CruiseControl object destroyed` log.'
  prefs: []
  type: TYPE_NORMAL
- en: Clearly, the `shared_ptr` data type has a concept of **reference counting** to
    keep track of the number of pointers. These references are increased during the
    constructors (not always; the `move` constructor isn't) and the copy assignment
    operator and decreased in the destructors.
  prefs: []
  type: TYPE_NORMAL
- en: Can the reference counting variable be safely increased and decreased? The pointers
    to the same object might be in different threads, so manipulating this variable
    might be an issue. This is not an issue as the reference counting variable is
    atomically managed (that is, it is an atomic variable).
  prefs: []
  type: TYPE_NORMAL
- en: One last point about the size. `unique_ptr` is as big as a raw pointer, whereas `shared_ptr`
    is typically double the size of `unique_ptr` because of the reference counting
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I strongly suggest always using `std::make_unique` and `std::make_shared`. Their
    usage removes code duplication and improves exception safety. Want more details?
    `shared_ptr.h` ([https://github.com/gcc-mirror/gcc/blob/master/libstdc%2B%2B-v3/include/bits/shared_ptr.h](https://github.com/gcc-mirror/gcc/blob/master/libstdc%2B%2B-v3/include/bits/shared_ptr.h))
    and `shared_ptr_base.h` ([https://github.com/gcc-mirror/gcc/blob/master/libstdc%2B%2B-v3/include/bits/shared_ptr_base.h](https://github.com/gcc-mirror/gcc/blob/master/libstdc%2B%2B-v3/include/bits/shared_ptr_base.h)) contain
    the GCC `shared_ptr` implementation so that we can see how reference counting
    is manipulated.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The books *Effective Modern C++* by Scott Meyers and *The C++ Programming Language* by Bjarne
    Stroustrup cover these topics in great detail.
  prefs: []
  type: TYPE_NORMAL
- en: Learning how move semantics works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We know copies are expensive, especially heavy objects. The move semantics that
    were introduced in C++11 help us avoid expensive copies. The foundational concept
    behind `std::move` and `std::forward` is the **rvalue reference**. This recipe
    will show you how to use `std::move`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s develop three programs to learn about `std::move` and its universal
    reference:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by developing a simple program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s develop a second example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look at an example with the universal reference:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The next section will describe these three programs in detail.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The output of the first program is as follows (`g++ move_01.cpp` and `./a.out`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/863d862f-50f8-46c8-894c-f4b94345d9ae.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In this program, `auto b = std::move(a);` does a couple of things:'
  prefs: []
  type: TYPE_NORMAL
- en: It casts the vector, `a`, to the **rvalue reference**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As it is an rvalue reference, the vector move constructor is called, which moves
    the content of the `a` vector to the `b` vector.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`a` doesn''t have the original data anymore, `b` has.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The output of the second program is as follows (`g++ moveSemantics2.cpp` and `./a.out`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0289ab6d-50b2-4b65-9cac-6cf1cddacdbe.png)'
  prefs: []
  type: TYPE_IMG
- en: In this second example, the `str` string we pass to the `print` method is an **lvalue reference** (that
    is, we can take the address of that variable), so it is passed by reference.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of the third program is as follows (`g++ moveSemantics3.cpp` and `./a.out`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bd79797d-ed44-45d1-9215-35b82981f9b3.png)'
  prefs: []
  type: TYPE_IMG
- en: In the third example, the method that's being called is the one with the **universal
    reference** as a parameter: `print (std::string &&s)`. This is because we cannot
    take the address of `this is a string`, which means it is an rvalue reference.
  prefs: []
  type: TYPE_NORMAL
- en: It should be clear now that `std::move` doesn't actually move anything – it
    is a function template that **performs an unconditional cast** to an rvalue, as
    we saw in the first example. This allows us to move (and not copy) the data to
    the destination and invalidate the source. The benefits of `std::move` are huge,
    especially every time we see an rvalue reference parameter to a method (`T&&`) that
    would probably* be a copy in the previous versions of the language (C++98 and
    before).
  prefs: []
  type: TYPE_NORMAL
- en: '*Probably: it depends on compiler optimizations.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`std::forward` is somewhat similar (but with a different purpose). It is a
    conditional cast to an rvalue reference. You are invited to learn more about `std::forward`,
    rvalue, and lvalue by reading the books referenced in the next section.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The books *Effective Modern C++* by Scott Meyers and *The C++ Programming Language* by Bjarne
    Stroustrup cover these topics in great detail.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding concurrency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the past, it was common for a C++ developer to write programs by using threading
    libraries or native threading mechanisms (for example `pthread`, a Windows thread).
    Since C++11, this has changed drastically and concurrency is another big feature
    that was added that goes in the direction of a self-consistent language. The two
    new features we'll look at in this recipe are `std::thread` and `std::async`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we''ll learn how to use `std::thread` with a basic scenario
    (create and join) and how to pass and receive parameters to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::thread`: By using the basic thread methods, `create` and `join`, write
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Compile it with `g++ concurrency_01.cpp -lpthread`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The second example is similar to the previous one but in this case, we pass
    and get parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::thread`: Create and join a thread, passing a parameter and getting a
    result. Write the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Compile it using `g++ concurrency_02.cpp -lpthread`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The third example uses **async **to create a task, execute it, and get the
    result, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::async`: Here, we can see why async is called** task-based threading**.
    Write the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to compile the program. There is a catch here. Since we''re using
    a threading mechanism, the compilers rely on the native implementations, which
    in our case turn out to be `pthread`. In order to compile and link without errors
    (we''d get an undefined reference), we need to include `-lpthread`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'In the fourth example, `std::async` used in conjunction with `std::promise`
    and `std::future` is a good and easy way of making two tasks communicate with
    each other. Let''s take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::async`: This is another `std::async` example showing a basic communication
    mechanism. Let''s code it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: And finally, compile it: `g++ concurrency_04.cpp -lpthread`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s analyze the previous four programs:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::thread`: The following program shows basic thread usage for create and
    join:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d24a2f92-5ce9-46f7-ab4f-7c3b1cba03ab.png)'
  prefs: []
  type: TYPE_IMG
- en: 'There''s nothing really complex in this first test. `std::thread` was initialized
    with a function through the uniform initialization and joined (waiting for the
    thread to be completed). The thread would accept a function object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '`std::thread`: Create and join a thread, passing a parameter and getting a
    result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ae0e61f3-9191-417d-b82f-9b9789c85852.png)'
  prefs: []
  type: TYPE_IMG
- en: This second test shows how to pass a parameter using `std::vector<int>& speeds`
    to the thread and get the return parameter, `int& ret`. This test shows how to
    pass parameters to a thread, and* is not* multithreaded code (that is, passing
    the same parameters to other threads will result in a race condition if *at least
    one* thread will be writing on them)!
  prefs: []
  type: TYPE_NORMAL
- en: '`std::async`: Here, we can see why async is called**task-based ****threading**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/2c7dfa24-2b7e-420a-a868-5dca78c347a6.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that when we call `std::async(asyncFunction);`, we could use `auto fut =
    std::async(asyncFunction);` to deduce the type of the return from `std::async` at
    compile time.
  prefs: []
  type: TYPE_NORMAL
- en: '`std::async`: This is another `std::async` example showing a basic communication
    mechanism:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/3659b664-f69d-4cda-a2f7-1a24654284c2.png)'
  prefs: []
  type: TYPE_IMG
- en: The consumer, `void asyncConsumer(std::future<int> &fut)`, calls the `get()`
    method on the future to get the value set by the producer through the `set_value()`
    method on the promise. `fut.get()` waits for the value to be computed, if necessary (that
    is, it's a blocking call).
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The C++ concurrent library doesn't just include the features shown in this recipe,
    although these are the foundational ones. You are invited to explore the full
    set of concurrency tools that are available by going to *Chapter 5*, paragraph
    three of *The C++ Programming Language* by Bjarne Stroustrup.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The books *Effective Modern C++* by Scott Meyers and *The C++ Programming Language* by Bjarne
    Stroustrup cover these topics in great detail.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the filesystem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C++17 marks another huge milestone in terms of new features. The `filesystem`
    library provides a simpler way of interacting with the filesystem. It was inspired
    by `Boost.Filesystem` (available since 2003). This recipe will show its basics
    features.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we''ll show two examples of the `filesystem` library by using `directory_iterator`
    and `create_directories`. Although there is definitely more under this namespace,
    the goal of these two snippets is to highlight their simplicity:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::filesystem::directory_iterator`: Let''s write the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Now, compile it with `g++ filesystem_01.cpp -std=c++17 -lstdc++fs`, where **`-std=c++17`**
    tells the compiler to use the C++17 standard and `-lstdc++fs` tells the compiler
    to use the `filesystem` library.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The second example is about creating a directory and a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::filesystem::create_directories`: Write the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The compilation is as the same as the previous example: `g++ filesystem_02.cpp -std=c++17 -lstdc++fs`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With just two lines of code, we've created a folder structure, a file, and have
    also written on it! It's as simple (and portable) as that.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `filesystem` library is located in the `<filesystem>` header under the
    `std::filesystem` namespace. These two tests, although pretty simple, were needed
    to show how powerful the `filesystem` library is. The output of the first program
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e3d7f330-c990-493c-aac9-28ea974e1a71.png)'
  prefs: []
  type: TYPE_IMG
- en: 'A complete list of `std::filesystem` methods can be found here: [https://en.cppreference.com/w/cpp/header/filesystem](https://en.cppreference.com/w/cpp/header/filesystem).'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::filesystem::create_directories` create a directory (recursively, if `test/src`
    does not exist) in the current folder, in this case. Of course, an absolute path
    is managed too and the current line would be perfectly valid, that is, `std::filesystem::create_directories("/usr/local/test/config");`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The second line of the source code uses `ofstream` to create an output file
    stream named `test/src/file.txt`and appends `<<` to the string: `This is an example!`*.*'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `filesystem` library is heavily inspired by `Boost.Filesystem`, which has
    been available since 2003\. If you want to experiment and debug a little, just
    add the `-g` option (add the debug symbols to the binary) to the compiler: `g++
    **-g** fs.cpp -std=c++17 -lstdc++fs`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The books *Effective Modern C++* by Scott Meyers and *The C++ Programming Language* by Bjarne
    Stroustrup cover these topics in great detail.
  prefs: []
  type: TYPE_NORMAL
- en: The C++ Core Guidelines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The C++ Core Guidelines are a collaborative effort led by Bjarne Stroustrup,
    much like the C++ language itself. They are the result of many years of discussion
    and design across a number of organizations. Their design encourages general applicability
    and broad adoption but they can be freely copied and modified to meet your organization's
    needs*.* More precisely, these guidelines are referring to the C++14 standard.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go over to GitHub and go to the C++ Core Guideline document ([http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines](http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines)),
    as well as to the GitHub project page: [https://github.com/isocpp/CppCoreGuidelines](https://github.com/isocpp/CppCoreGuidelines).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The C++ Core Guidelines are divided into sections that are easily browsable.
    The sections include class and class hierarchies, resource management, performance,
    and error handling. The C++ Core Guidelines are a collaborative effort led by Bjarne Stroustrup
    and Herb Sutter but, in total, they involve more than 200 contributors (to find
    out more about this, please visit [https://github.com/isocpp/CppCoreGuidelines/graphs/contributors](https://github.com/isocpp/CppCoreGuidelines/graphs/contributors)).
    The quality, suggestions, and best practices they've put in are incredible.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most common way to use the C++ Core Guidelines is to keep a browser tab
    open on the GitHub page and consult it continuously for your daily tasks.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you want to contribute to the issues that have already been provided, the
    GitHub page contains a lot of items, ready to be picked up. For more information,
    please visit [https://github.com/isocpp/CppCoreGuidelines/issues](https://github.com/isocpp/CppCoreGuidelines/issues).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Adding GSL in your makefile* recipe of this chapter will be helpful.
  prefs: []
  type: TYPE_NORMAL
- en: Adding GSL in your makefile
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*"The GSL is the small set of types and aliases specified in these guidelines.
    At the time of writing, their specification herein is too sparse; we plan to add
    a WG21-style interface specification to ensure that different implementations
    agree, and to propose as a contribution for possible standardization, subject
    as usual to whatever the committee decides to accept/improve/alter/reject."* –
    FAQ.50 of the C++ Core Guidelines.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go to GitHub and go to the C++ Core Guideline document: [http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines](http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we''ll integrate the **Guideline Supporting Library** (`gsl`)
    to a program by modifying a makefile:'
  prefs: []
  type: TYPE_NORMAL
- en: Download and copy a `gsl` implementation (for example, [https://github.com/microsoft/GSL](https://github.com/microsoft/GSL)).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the `gsl` folder into your project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the include to the makefile: `-I$HOME/dev/GSL/include`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In your source file, include `#include <gsl/gsl>`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `gsl` currently provides the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GSL.view`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GSL.owner`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GSL.assert: Assertions`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GSL.util: Utilities`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GSL.concept: Concepts`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You might have noticed that to get the `gsl` working, you just need to specify
    the header file folder path in the makefile, that is, `-I$HOME/dev/GSL/include`.
    Another detail to note is that no library is specified in the makefile.
  prefs: []
  type: TYPE_NORMAL
- en: This is because the whole implementation is provided *inline* in the header
    files under the `gsl` folder.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Microsoft GSL ([http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines](http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines))
    is just one implementation maintained by Microsoft. You can find another implementation
    here: [https://github.com/martinmoene/gsl-lite](https://github.com/martinmoene/gsl-lite).
    Both implementations have been released under the MIT license type.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*The C++ Core Guidelines* recipe of this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **concept** is a compile-time predicate that's used in conjunction with templates.
    The C++20 standard definitely boosted generic programming by providing more compile-time
    opportunity for the developer to communicate its intention. We can visualize concepts
    such as requirements (or constraints)the user of the template must adhere to.
    Why do we need concepts? Do you have do define concepts by yourself? This recipe
    will answer these and many more questions.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will develop a concrete template example using `concepts`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to create our own version of the `std::sort` template function from
    the C++ standard library. Let''s start by writing the following code in a `.cpp`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s use our new template class with the constraint that the type we
    pass, an `std::vector`, must be sortable; otherwise, the compiler will notify
    us:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We'll look at the details in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I strongly believe `concepts` were the missing feature. Before them, a template
    didn't have a well-defined set of requirements, nor, in the case of a compilation
    error, a simple and brief description of it. These are the two pillars that drove
    the design of the `concepts` feature.
  prefs: []
  type: TYPE_NORMAL
- en: '*Step 1* includes the algorithms `include` for the `std::sort` method and the
    `concepts` header. To not confuse the compiler and ourselves, we encapsulated
    our new template in a namespace, `sp`. As you can see, there is a very minimal
    difference compared to the classical templates we used to use and the difference
    is with the `requires` keyword.'
  prefs: []
  type: TYPE_NORMAL
- en: '`requires` communicates to the compiler (and to the template user) that this
    template is only valid with a `T Sortable` type (`Sortable<T>`). OK; what is `Sortable`?
    This is a predicate that is only satisfied if it is evaluated to true. There are
    other ways to specify a constraint, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'With the trailing `requires`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'As a `template` parameter:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'I personally prefer the style in the *How to do it...* section as it is more
    idiomatic and, more importantly, allows us to keep all the `requires` together,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we want to communicate that our `sp::sort` method is valid
    with type `T`, which is `Sortable` and `Integral`, for whatever reason.
  prefs: []
  type: TYPE_NORMAL
- en: '*Step 2* simply uses our new customized version of sort. To do this, we instantiated
    a vector (which is `Sortable`!) and passed in input to the `sp::sort` method.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There might be cases where you need to create your own concept. The standard
    library contains plenty of them, so it is a remote probability that you''d need
    one. As we learned in the previous section, a concept is a predicate if and only
    if it is evaluated as true. The definition of a concept as a composite of two
    existing ones might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we can use the `sort` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Why is this cool? For a couple of reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: It lets us immediately know what the template expects without getting lost in
    implementation details (that is, the requirements or constraints are explicit).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At compile time, the compiler will evaluate whether the constraints have been
    met.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*A Tour of C++, Second Edition,* B. Stroustrup: *Chapter 7.2 *and *Chapter* *12.7* for
    a complete list of concepts defined in the standard library.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://gcc.gnu.org/projects/cxx-status.html](https://gcc.gnu.org/projects/cxx-status.html)
    for a list of C++20 features mapped with GCC versions and status.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using span
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We may come across cases where we need to write a method but we'd like to have
    the flexibility to accept a plain array or STL containers as input. `std::span`
    solves this problem. It gives the user a view into a contiguous sequence of elements.
    This recipe will teach you how to use it.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we''ll write a method with one parameter (`std::span`) that
    can be used in different contexts. Then, we''ll highlight the flexibility it offers:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by adding the includes we need. Then, we need to define the `print`
    method by passing the `container` variable of the `std::span` type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'In `main`, we want to print our arrays by calling the `print` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Let's see how this works.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`std::span` describes an object that refers to a contiguous sequence of elements.
    The C++ standard defines an array as having a contiguous portion of memory. This
    definitely simplifies the `std::span` implementation, since a typical one includes
    a pointer to the first element of the sequence and the size.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Step 1* defines the `print` method of passing the `std::span`, which we can
    read as a sequence of integers. Any array type that has contiguous memory will
    be seen from the method as a sequence.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Step 2* uses the `print` method with two different arrays, one C-style and
    the second an `std::vector` part of the STL library. Since both arrays are defined
    in a contiguous portion of memory, `std::span` is able to seamlessly manage them.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our method considers `std::span` with the `int` type. You might need to make
    the method generic. In this case, you''d need to write something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'As we learned in the *Understanding concepts* recipe, it is wise to specify
    some requirements in this template. Therefore, we might write to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The `requires Integral<T>` would make explicit the needs of an `Integral` type
    for the template.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Understanding concepts* recipe to review how to write concepts with templates
    and apply them to `std::span`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://gcc.gnu.org/projects/cxx-status.html](https://gcc.gnu.org/projects/cxx-status.html) for
    a list of C++20 features mapped with GCC versions and their statuses.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning how Ranges work
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The C++20 standard added Ranges, which are an abstraction of containers that
    allow the program to operate uniformly on containers' elements. Furthermore, Ranges
    represent a very modern and concise way of writing expressive code. We'll learn
    that this expressiveness is even greater with pipes and adaptors.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we''ll write a program that will help us learn the main use
    case of Ranges in conjunction with pipes and adaptors. Given an array of temperatures,
    we want to filter out the negative ones and convert the positives (warm temperatures)
    into Fahrenheit:'
  prefs: []
  type: TYPE_NORMAL
- en: 'On a new source file, type the following code. As you can see, two lambda functions
    and a `for` range loop does the job:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: We'll analyze what's behind of Ranges in the next section. We'll also learn
    that Ranges are the first users of `concepts`.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`std::ranges` represents a very modern way of describing a sequence of actions
    on a container in a readable format. This is one of the cases where the language
    improves readability.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Step 1* defines the `temperatures` vector, which contains some data. Then,
    we defined a lambda function that returns true if the input, `i`, is greater or
    equal to zero. The second lambda we defined converts `i` into Fahrenheit. Then,
    we looped over temperatures (`viewable_range`) and piped to the `filter` (called
    `adaptor`, in the scope of Ranges), which removed the negative temperatures based
    on the `minus` lambda function. The output is piped to another adaptor that converts
    every single item of the container so that the final loop can take place and print
    to the standard output.'
  prefs: []
  type: TYPE_NORMAL
- en: C++20 provides another level on top of the one we used to iterate over the container's
    element, one that's more modern and idiomatic. By combining `viewable_range` with
    adaptors, the code is more concise, compact, and readable.
  prefs: []
  type: TYPE_NORMAL
- en: The C++20 standard library provides many more adaptors following the same logic,
    including `std::views::all`, `std::views::take`, and `std::views::split`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All of the adaptors are templates that use concepts to define the requirements
    that the specific adaptor needs. An example of this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'This template is the `std::views::filter` we used in this recipe. This template
    takes two types: the first one is `V`, the input range (that is, the container),
    while the second one is `Pred` (which is the lambda function, in our case). We''ve
    specified two constraints for this template:'
  prefs: []
  type: TYPE_NORMAL
- en: '`V` must be a view'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The predicate must be an object type: a function, lambda, and so on'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Understanding concepts* recipe to review concepts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go to [https://github.com/ericniebler/range-v3](https://github.com/ericniebler/range-v3) to
    see the `range` implementation by the C++20 library proposal author (Eric Niebler).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Learning the Linux fundamentals – shell* recipe in [Chapter 1](c3cda38c-220e-4aae-89c6-c381df46daec.xhtml), *Getting
    Started with System Programming*, to notice that the C++20 Ranges pipe is very
    similar to the concept of pipes we''ve seen on the shell.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To read more about `std::is_object`, please visit the following link: [https://en.cppreference.com/w/cpp/types/is_object](https://en.cppreference.com/w/cpp/types/is_object).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning how modules work
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before C++20, there was only one way of structuring a program in parts: through
    the `#include` directive (which is resolved by the precompiler). The latest standard
    added another and more modern way of achieving the same result, called **module**.
    This recipe will show you how to write code using modules and the differences
    between `#include` and module.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we''ll write a program composed of two modules. This program
    is an improvement of the one we developed in the *Learning how Range works* recipe.
    We''ll encapsulate the temperature code in a module and use it in a client module.
    Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a new `.cpp` source file called `temperature.cpp` and type in
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have to use it. Create a new file (for example, `temperature_client.cpp`)
    and include the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The next section explains how modules work, what relationship they have with
    the namespaces, and the advantages they have over the `#include` precompiler directive.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A module is the C++20 solution to (possibly) the `#include` directive. Possibly
    is mandatory here as the millions of lines of legacy code cannot be converted
    overnight to use modules.
  prefs: []
  type: TYPE_NORMAL
- en: '*Step 1* has the main goal of defining our `temperature_engine` module. The
    first line, `export module temperature_engine;`, defines the module we want to
    export. Next, we have `import std.core`. This is one of the biggest differences
    brought into C++20: there is no need to use `#include` anymore. Specifically,
    `import std.core` is equivalent to `#include <iostream>`. We also `#include` the
    range. In this case, we did it *the old way* to show you that is possible to have
    code that mixes old and new solutions. This is important as it''ll allow us how
    to manage the transition to module better. Every time we want to export something
    from our module, we just need to prefix it with the `export` keyword, as we did
    with the `toFahrenheitFromCelsius` method. The method''s implementation is not
    affected, so its logic doesn''t change.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Step 2* contains the code for the module client using `temperature_engine`.
    As we did in the previous step, we just need to use `import temperature_engine`
    and use the exported objects. We also used `import std.core` to replace `#include
    <iostream>`. Now, we can use the exported method as we normally would, calling
    `toFahrenheitFromCelsius` and passing the expected input  parameters. The `toFahrenheitFromCelsius` method
    returns a vector of integers representing the converted temperatures in Fahrenheit,
    which means all we need to do is use the `for_each` template method to print the
    values by using** `import std.core` **where we normally would have used `#include
    <algorithm>`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The main question at this point is: why should we use module instead of `#include`?
    `Module` does not just represent a syntactic difference – it''s deeper than that:'
  prefs: []
  type: TYPE_NORMAL
- en: A module is compiled only once, while `#includes` are not. To make `#include` compile
    only once, we need to use the `#ifdef` `#define`, and `#endif` precompilers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Module can be imported in any order without affecting the meaning. This is not
    the same for `#include`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a symbol is not exported from the module, the client code cannot use it and
    the compiler will notify with an error if the users do.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modules, unlike includes, are not transitive. Importing module `A` into module
    `B`, when module `C` uses module `B`, doesn't mean it automatically gains access
    to module `A`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This has a great effect on maintainability, the structure of the code, and compilation
    time.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One recurrent question is, aren''t modules in conflict (or overlapping) with
    namespaces? This is a good point, and the answer is no. Namespaces and modules
    solve two different problems. A namespace is yet another mechanism that expresses
    the intention to group some declarations together. Other mechanisms that put group
    declaration together are functions and classes. What if two classes clash? We
    can encapsulate one of them into a namespace. You can see an example of this in
    the *Understanding concepts* recipe, where we created our own version of sort
    called `sp::sort`. A module, on the other hand, is a logical set of functionalities.
    The two concepts are **orthogonal**, which means I can have my namespace spread
    out over more modules. A concrete example is the `std::vector` and `std::list`
    containers, which are in two different modules but on the same `namespace`: `std`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another thing worth highlighting is that modules allow us to set a portion
    of the module as `private` to make it inaccessible to other **Translation Units** (**TUs**).
    This is useful if you want to export a symbol as an incomplete type, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go to [https://gcc.gnu.org/projects/cxx-status.html](https://gcc.gnu.org/projects/cxx-status.html)
    to check the module (and other C++20 features) support timeline.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Lambda expressions* recipe for a refresher on lambdas.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
