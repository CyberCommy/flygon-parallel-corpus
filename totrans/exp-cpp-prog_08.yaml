- en: Code Smells and Clean Code Practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to code smells
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The concept of clean code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How agile and clean code practices are related
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SOLID design principle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code refactoring
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refactoring code smells into clean code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refactoring code smells into design patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clean code is the source code that works in an accurate way functionally and
    is structurally well written. Through thorough testing, we can ensure the code
    is functionally correct. We can improve code quality via code self-review, peer code review,
    code analysis, and most importantly, by code refactoring.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are some of the qualities of clean code:'
  prefs: []
  type: TYPE_NORMAL
- en: Easy to understand
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easy to enhance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding new functionality doesn't require many code changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easy to reuse
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Self-explanatory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Has comments when necessary
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lastly, the best part about writing clean code is that both the development
    team involved in the project or product and the customer will be happy.
  prefs: []
  type: TYPE_NORMAL
- en: Code refactoring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Refactoring helps improve the structural quality of the source code. It doesn't
    modify the functionality of the code; it just improves the structural aspect of
    the code quality. Refactoring makes the code cleaner, but at times it may help
    you improve the overall code performance. However, you need to understand that
    performance tuning is different from code refactoring.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram demonstrates the development process overview:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/18fb6dd3-9b64-448f-b498-ee61513fa728.png)'
  prefs: []
  type: TYPE_IMG
- en: 'How is code refactoring done safely? The answer to this question is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Embrace DevOps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adapt to test-driven development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adapt to behavior-driven development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use acceptance test-driven development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code smell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Source code has two aspects of quality, namely **functional** and **structural**.
    The functional quality of a piece of source code can be achieved by testing the
    code against the customer specifications. The biggest mistake most developers
    make is that they tend to commit the code to version control software without
    refactoring it; that is, they commit the code the moment they believe it is functionally
    complete.
  prefs: []
  type: TYPE_NORMAL
- en: As a matter of fact, committing code to version control often is a good habit,
    as this is what makes continuous integration and DevOps possible. After committing
    the code to version control, what the vast majority of developers ignore is refactoring
    it. It is highly critical that you refactor the code to ensure it is clean, without
    which being agile is impossible.
  prefs: []
  type: TYPE_NORMAL
- en: Code that looks like noodles (spaghetti) requires more efforts to enhance or
    maintain. Hence, responding to a customer's request quickly is not practically
    possible. This is why maintaining clean code is critical to being agile. This
    is applicable irrespective of the agile framework that is followed in your organization.
  prefs: []
  type: TYPE_NORMAL
- en: What is agile?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Agile is all about **fail fast**. An agile team will be able to respond to
    a customer''s requirement quickly without involving any circus from the development
    team. It doesn''t really matter much which agile framework the team is using:
    Scrum, Kanban, XP, or something else. What really matters is, are you following
    them seriously?'
  prefs: []
  type: TYPE_NORMAL
- en: As an independent software consultant, I have personally observed and learned
    who generally complains, and why they complain about agile.
  prefs: []
  type: TYPE_NORMAL
- en: As Scrum is one of the most popular agile frameworks, let's assume a product company,
    say, ABC Tech Private Ltd., has decided to follow Scrum for the new product that
    they are planning to develop. The good news is that ABC Tech, just like most organizations,
    also hosts a Sprint planning meeting, a daily stand-up meeting, Sprint review,
    Sprint retrospective, and all other Scrum ceremonies efficiently. Assume that
    ABC Tech has ensured their Scrum master is Scrum-certified and the product manager
    is a Scrum-certified product owner. Great! Everything sounds good so far.
  prefs: []
  type: TYPE_NORMAL
- en: Let's say the ABC Tech product team doesn't use TDD, BDD, ATDD, and DevOps.
    Do you think the ABC Tech product team is agile? Certainly not. As a matter of
    fact, the development team will be highly stressed with a hectic and impractical
    schedule. At the end of the day, there will be very high attrition, as the team
    will not be happy. Hence, customers will not be happy, as the quality of the product
    will suffer terribly.
  prefs: []
  type: TYPE_NORMAL
- en: What do you think has gone wrong with the ABC Tech product team?
  prefs: []
  type: TYPE_NORMAL
- en: Scrum has two sets of processes, namely the project management process, which
    is covered by Scrum ceremonies. Then, there is the engineering side of the process,
    which most organizations don't pay much attention to. This is evident from the
    interest or awareness of **Certified SCRUM Developer** (**CSD**) certification
    in the IT industry. The amount of interest the IT industry shows to CSM, CSPO,
    or CSP is hardly shown to CSD, which is required for developers. However, I don't
    believe certification alone could make someone a subject-matter expert; it only
    shows the seriousness the person or the organization shows in embracing an agile
    framework and delivering quality products to their customers.
  prefs: []
  type: TYPE_NORMAL
- en: Unless the code is kept clean, how is it possible for the development team to
    respond to customers' requirements quickly? In other words, unless the engineers
    in the development team embrace TDD, BDD, ATDD, continuous integration, and DevOps
    in the product development, no team will be able to succeed in Scrum or, for that
    matter, with any other agile framework.
  prefs: []
  type: TYPE_NORMAL
- en: The bottom line is that unless your organization takes the engineering Scrum
    process and project management Scrum process equally serious, no development team
    can claim to succeed in agile.
  prefs: []
  type: TYPE_NORMAL
- en: SOLID design principle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SOLID is an acronym for a set of important design principles that, if followed,
    can avoid code smells and improve the code quality, both structurally and functionally.
  prefs: []
  type: TYPE_NORMAL
- en: 'Code smells can be prevented or refactored into clean code if your software
    architecture meets the SOLID design principle compliance. The following principles
    are collectively called SOLID design principles:'
  prefs: []
  type: TYPE_NORMAL
- en: Single responsibility principle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Open closed principle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Liskov substitution principle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interface segregation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependency inversion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The best part is that most design patterns also follow and are compliant with
    SOLID design principles.
  prefs: []
  type: TYPE_NORMAL
- en: Let's go through each of the preceding design principles one by one in the following
    sections.
  prefs: []
  type: TYPE_NORMAL
- en: Single responsibility principle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Single responsibility principle** is also referred to as **SRP** in short.
    SRP says that every class must have only one responsibility. In other words, every
    class must represent exactly one object. When a class represents multiple objects,
    it tends to violate SRP and opens up chances for multiple code smells.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s take a simple `Employee` class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2bcd6820-b96b-4bf2-899a-7556198868eb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding class diagram, the `Employee` class seems to represent three
    different objects: `Employee`, `Address`, and `Contact`. Hence, it violates the
    SRP. As per this principle, from the preceding `Employee` class, two other classes
    can be extracted, namely `Address` and `Contact`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/769eb1f5-4ade-4e44-8a4f-97a03b47d4f6.png)'
  prefs: []
  type: TYPE_IMG
- en: For simplicity, the class diagrams used in this section don't show any methods
    that are supported by the respective classes, as our focus is understanding the
    SRP with a simple example.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding refactored design, Employee has one or more addresses (personal
    and official) and one or more contacts (personal and official). The best part
    is that after refactoring the design, every class abstracts one and only thing;
    that is, it has only one responsibility.
  prefs: []
  type: TYPE_NORMAL
- en: Open closed principle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An architecture or design is in compliance with the **open closed principle** (**OCP**)
    when the design supports the addition of new features with no code changes or
    without modifying the existing source code. As you know, based on your professional
    industry experience, every single project you have come across was extensible
    in one way or another. This is how you were able to add new features to your product.
    However, the design will be in compliance with the OCP when such a feature extension
    is done without you modifying the existing code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a simple `Item` class, as shown in the following code. For simplicity,
    only the essential details are captured in the `Item` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Assume the preceding `Item` class is part of a simple billing application for
    a small shop. As the `Item` class will be able to represent a pen, calculator,
    chocolate, notebook, and so on, it is generic enough to support any billable item
    that is dealt by the shop. However, if the shop owner is supposed to collect **Goods
    and Services Tax** (**GST**) or **Value Added Tax** (**VAT**), the existing `Item`
    class doesn't seem to support the tax component. One common approach is to modify
    the `Item` class to support the tax component. However, if we were to modify existing
    code, our design would be non-compliant to OCP.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hence, let''s refactor our design to make it OCP-compliant using Visitor design
    pattern. Let''s explore the refactoring possibility, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Visitable` class is an abstract class with three pure virtual functions.
    The `Item` class will be inheriting the `Visitable` abstract class, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s take a look at the `Visitor` class, shown in the following code.
    It says there can be any number of `Visitor` subclasses that can be implemented
    in future to add new functionalities, all without modifying the `Item` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The `GSTVisitor` class is the one that lets us add the GST functionality without
    modifying the `Item` class. The `GSTVisitor` implementation looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Makefile` looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The refactored design is OCP-compliant, as we would be able to add new functionalities
    without modifying the `Item` class. Just imagine: if the GST calculation varies
    from time to time, without modifying the `Item` class, we would be able to add
    new subclasses of `Visitor` and address the upcoming changes.'
  prefs: []
  type: TYPE_NORMAL
- en: Liskov substitution principle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Liskov substitution principle** (**LSP**) stresses the importance of subclasses
    adhering to the contract established by the base class. In an ideal inheritance
    hierarchy, as the design focus moves up the class hierarchy, we should notice
    generalization; as the design focus moves down the class hierarchy, we should
    notice specialization.'
  prefs: []
  type: TYPE_NORMAL
- en: The inheritance contract is between two classes, hence it is the responsibility
    of the base class to impose rules that all subclasses can follow, and the subclasses
    are equally responsible for obeying the contract once agreed. A design that compromises
    these design philosophies will be non-compliant to the LSP.
  prefs: []
  type: TYPE_NORMAL
- en: LSP says if a method takes the base class or interface as an argument, one should
    be able to substitute the instance of any one of the subclasses unconditionally.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a matter of fact, inheritance violates the most fundamental design principles:
    inheritance is weakly cohesive and strongly coupled. Hence, the real benefit of
    inheritance is polymorphism, and code reuse is a tiny benefit compared to the
    price paid for inheritance. When LSP is violated, we can''t substitute the base
    class instance with one of its subclass instances, and the worst part is we can''t
    invoke methods polymorphically. In spite of paying the design penalties of using
    inheritance, if we can''t reap the benefit of polymorphism, there is no real motivation
    to use it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The technique to identify LSP violation is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Subclasses will have one or more overridden methods with empty implementations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The base class will have a specialized behavior, which will force certain subclasses,
    irrespective of whether those specialized behaviors are of the subclasses' interest
    or not
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Not all generalized methods can be invoked polymorphically
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following are the ways to refactor LSP violations:'
  prefs: []
  type: TYPE_NORMAL
- en: Move the specialized methods from the base class to the subclass that requires
    those specialized behaviors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid forcing vaguely related classes to participate in an inheritance relationship.
    Unless the subclass is a base type, do not use inheritance for the mere sake of
    code reuse.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do not look for small benefits, such as code reuse, but look for ways to use
    polymorphism or aggregation or composition when possible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interface segregation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Interface segregation** design principle recommends modeling many small interfaces
    for a specific purpose, as opposed to modeling one bigger interface that represents
    many things. In the case of C++, an abstract class with pure virtual functions
    can be thought of as an interface.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a simple example to understand interface segregation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, the abstract class demonstrates a chaotic design.
    The design is chaotic as it seems to represent many things, such as employee,
    address, and contact. One of the ways in which the preceding abstract class can
    be refactored is by breaking the single interface into three separate interfaces:
    `IEmployee`, `IAddress`, and `IContact`. In C++, interfaces are nothing but abstract
    classes with pure virtual functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the refactored code snippet, every interface represents exactly one object,
    hence it is in compliance with the interface segregation design principle.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency inversion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A good design will be strongly cohesive and loosely coupled. Hence, our design
    must have less dependency. A design that makes a code dependent on many other
    objects or modules is considered a poor design. If **Dependency Inversion** (**DI**)
    is violated, any change that happens in the dependent modules will have a bad
    impact on our module, leading to a ripple effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a simple example to understand the power of DI. A `Mobile` class
    "has a" `Camera` object and notice that has a form is composition. Composition
    is an exclusive ownership where the lifetime of the `Camera` object is directly
    controlled by the `Mobile` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b2b7826f-1811-40d8-8bac-b49168c0c40d.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see in the preceding image, the `Mobile` class has an instance of
    `Camera` and the *has a* form used is composition, which is an exclusive ownership
    relationship.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the `Mobile` class implementation, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, `Mobile` has implementation-level knowledge about `Camera`,
    which is a poor design. Ideally, `Mobile` should be interacting with `Camera`
    via an interface or an abstract class with pure virtual functions, as this separates
    the `Camera` implementation from its contract. This approach helps replace `Camera`
    without affecting `Mobile` and also gives an opportunity to support a bunch of
    `Camera` subclasses in place of one single camera.
  prefs: []
  type: TYPE_NORMAL
- en: Wondering why it is called **Dependency Injection** (**DI**) or **Inversion
    of Control** (**IOC**)? The reason it is termed dependency injection is that currently,
    the lifetime of `Camera` is controlled by the `Mobile` object; that is, `Camera`
    is instantiated and destroyed by the `Mobile` object. In such a case, it is almost
    impossible to unit test `Mobile` in the absence of `Camera`, as `Mobile` has a
    hard dependency on `Camera`. Unless `Camera` is implemented, we can't test the
    functionality of `Mobile`, which is a bad design approach. When we invert the
    dependency, it lets the `Mobile` object use the `Camera` object while it gives
    up the responsibility of controlling the lifetime of the `Camera` object. This
    process is rightly referred to as IOC. The advantage is that you will be able
    to unit test the `Mobile` and `Camera` objects independently and they will be
    strongly cohesive and loosely coupled due to IOC.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s refactor the preceding code with the DI design principle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The changes are highlighted in bold in the preceding code snippet. IOC is such
    a powerful technique that it lets us decouple the dependency as just demonstrated;
    however, its implementation is quite simple.
  prefs: []
  type: TYPE_NORMAL
- en: Code smell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Code smell is a term used to refer to a piece of code that lacks structural
    quality; however, the code may be functionally correct. Code smells violate SOLID
    design principles, hence they must be taken seriously, as the code that is not
    well written leads to heavy maintenance cost in the long run. However, code smells
    can be refactored into clean code.
  prefs: []
  type: TYPE_NORMAL
- en: Comment smell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As an independent software consultant, I have had a lot of opportunities to
    interact and learn from great developers, architects, QA folks, system administrators,
    CTOs and CEOs, entrepreneurs, and so on. Whenever our discussions crossed the
    billion dollar question, "What is clean code or good code?", I more or less got
    one common response globally, "Good code will be well commented." While this is
    partially correct, certainly that''s where the problem starts. Ideally, clean
    code should be self-explanatory, without any need for comments. However, there
    are some occasions where comments improve the overall readability and maintainability.
    Not all comments are code smells, hence it becomes necessary to differentiate
    a good comment from a bad one. Have a look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: I'm sure you have come across these kinds of comments. Needless to explain that
    the preceding scenario is a code smell. Ideally, the developer should have refactored
    the code to fix the bug instead of writing such a comment. I was once debugging
    a critical issue in the middle of the night and I noticed the control reached
    the mysterious empty code block with just a comment in it. I'm sure you have come
    across funnier code and can imagine the frustration it brings; at times, you too
    would have written such a type of code.
  prefs: []
  type: TYPE_NORMAL
- en: A good comment will express *why* the code is written in a specific way rather
    than express *how* the code does something. A comment that conveys how the code
    does something is a code smell, whereas a comment that conveys the why part of
    the code is a good comment, as the why part is not expressed by the code; therefore,
    a good comment provides value addition.
  prefs: []
  type: TYPE_NORMAL
- en: Long method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A method is long when it is identified to have multiple responsibilities. Naturally,
    a method that has more than 20-25 lines of code tends to have more than one responsibility.
    Having said that, a method with more lines of code is longer. This doesn''t mean
    a method with less than 25 lines of code isn''t longer. Take a look at the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Clearly, the preceding method has multiple responsibilities; that is, it seems
    to validate and save the details. While validating before saving isn''t wrong,
    the same method shouldn''t do both. So the preceding method can be refactored
    into two smaller methods that have one single responsibility:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Each of the refactored methods shown in the preceding code has exactly one responsibility.
    It would be tempting to make the `validateAddress()` method a predicate method;
    that is, a method that returns a bool. However, if `validateAddress()` is written
    as a predicate method, then the client code will be forced to do `if` check, which
    is a code smell. Handling errors by returning error code isn't considered object-oriented
    code, hence error handling must be done using C++ exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: Long parameter list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An object-oriented method takes fewer arguments, as a well-designed object will
    be strongly cohesive and loosely coupled. A method that takes too many arguments
    is a symptom that informs that the knowledge required to make a decision is received
    externally, which means the current object doesn't have all of the knowledge to
    make a decision by itself.
  prefs: []
  type: TYPE_NORMAL
- en: This means the current object is weakly cohesive and strongly coupled, as it
    depends on too much external data to make a decision. Member functions generally
    tend to receive fewer arguments, as the data members they require are generally
    member variables. Hence, the need to pass member variables to member functions
    sounds artificial.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see some of the common reasons why a method tends to receive too many
    arguments. The most common symptoms and reasons are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: The object is weakly cohesive and strongly coupled; that is, it depends too
    much on other objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is a static method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is a misplaced method; that is, it doesn't belong to that object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is not object-oriented code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SRP is violated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The ways to refactor a method that takes **long parameter list** (**LPL**)
    are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: Avoid extracting and passing data in bits and pieces; consider passing an entire
    object and let the method extract the details it requires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identify the object that supplies the arguments to the method that receives
    LPL and consider moving the method there
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Group the list of arguments and create a parameter object and move the method
    that receives LPL inside the new object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Duplicate code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Duplicate code is a commonly recurring code smell that doesn't require much
    explanation. The copying and pasting code culture alone can't be blamed for duplicate
    code. Duplicate code makes code maintenance more cumbersome, as the same issues
    may have to be fixed in multiple places, and integrating new features requires
    too many code changes, which tends to break the unexpected functionalities. Duplicate
    code also increases the application binary footprint, hence it must be refactored
    to clean code.
  prefs: []
  type: TYPE_NORMAL
- en: Conditional complexity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Conditional complexity code smell is about complex large conditions that tend
    to grow larger and more complex with time. This code smell can be refactored with
    the strategy design pattern. As the strategy design pattern deals with many related
    objects, there is scope for using the `Factory` method, and the **null object
    design pattern** can be used to deal with unsupported subclasses in the `Factory`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Large class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A large class code smell makes the code difficult to understand and tougher
    to maintain. A large class can do too many things for one class. Large classes
    can be refactored by breaking them into smaller classes with a single responsibility.
  prefs: []
  type: TYPE_NORMAL
- en: Dead code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dead code is commented code or code that is never used or integrated. It can
    be detected with code coverage tools. Generally, developers retain these instances
    of code due to lack of confidence, and this happens more often in legacy code.
    As every code is tracked in version control software tools, dead code can be deleted,
    and if required, can always be retrieved back from version control software.
  prefs: []
  type: TYPE_NORMAL
- en: Primitive obsession
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Primitive Obsession** (**PO**) is a wrong design choice: use of a primitive
    data type to represent a complex domain entity. For example, if the string data
    type is used to represent date, though it sounds like a smart idea initially,
    it invites a lot of maintenance trouble in the long run.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming you have used a string data type to represent date, the following
    issues will be a challenge:'
  prefs: []
  type: TYPE_NORMAL
- en: You would need to sort things based on date
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Date arithmetic will become very complex with the introduction of string
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Supporting various date formats as per regional settings will become complex
    with string
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ideally, date must be represented by a class as opposed to a primitive data
    type.
  prefs: []
  type: TYPE_NORMAL
- en: Data class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data classes provide only getter and setter functions. Though they are very
    good for transferring data from one layer to another, they tend to burden the
    classes that depend on the data class. As data classes won't provide any useful
    functionalities, the classes that interact or depend on data classes end up adding
    functionalities with the data from the data class. In this fashion, the classes
    around the data class violate the SRP and tend to be a large class.
  prefs: []
  type: TYPE_NORMAL
- en: Feature envy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Certain classes are termed feature envy if they have too much knowledge about
    other internal details of other classes. Generally, this happens when the other
    classes are data classes. Code smells are interrelated; breaking one code smell
    tends to attract other code smells.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you learned about the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Code smells and the importance of refactoring code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'SOLID design principles:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Single responsibility principle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Open closed principle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Liskov substitution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interface segregation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependency injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Various code smells:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comments smell
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Long method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Long parameter list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Duplicate code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conditional complexity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Large class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dead code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Object-oriented code smells' primitive obsession
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Feature envy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You also learned about many refactoring techniques that will help you maintain
    your code cleaner. Happy coding!
  prefs: []
  type: TYPE_NORMAL
