- en: Chapter 8. Scheduling Tasks and Embedding Languages in Scripts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until now, we learned about various useful shell utilities and how to write
    them into a shell script in order to avoid writing the same instructions again
    and again. Automating tasks by writing into scripts reduces the tasks up to a
    certain extent, but still we will have to run those scripts whenever required.
    Sometimes, it happens that we want to run a command or script at a particular
    time, for example, sysadmin has to run a clean-up and maintenance of a system
    available in the data center at 12:30 AM. To perform the required operation, sysadmin
    will login into a machine around 12:30 AM and do the necessary work. But what
    if his or her home network is down and the data center is far? It will be inconvenient
    and tough to perform a task at that moment. There are also a few tasks that need
    to be performed on daily or hourly basis, for example, monitoring the network
    usage of each user, taking a system backup, and so on. It will be very boring
    to execute repetitive tasks again and again.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will see how to solve such issues by scheduling tasks at
    a specific time or interval of time by using utilities `at` and `crontab`. We
    will also see how systemd (the first process started after a system is booted
    up with PID 1) manages processes needed after system start-up. We will also see
    how systemd manages different services and system logs. At the end, we will learn
    how we can embed other scripting languages in a shell script to get extra capabilities
    in the shell script.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: Running tasks at a specific time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cron jobs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing Crontab entry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: systemd
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Embedding languages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running tasks at a specific time
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In general, when we run a command or script, it starts executing instantly.
    However, what if we want it to run later at a specific time? For example, I want
    to download large data from the Internet, but don't want to slow down my Internet
    bandwidth while I am working. So, I would like to run my download script at 1:00
    AM since I won't be using the Internet for any kind of work after 1:00 AM. It
    is possible to schedule download scripts or commands later at a specified time
    using the `at` command. We can also list scheduled tasks using the `atq` command
    or remove any scheduled tasks using the `atrm` command.
  prefs: []
  type: TYPE_NORMAL
- en: Executing scripts using at
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will use the `at` command to run tasks at a given time. The syntax of using
    the `at` command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding syntax, `specified_time` refers to the time at which a command
    or script should run. The time can be in the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Time format | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| HH:MM | The specific time of the day in hours (HH) and minutes (MM). If the
    time is already past, then the next day is assumed. Time is specified in 24 hours
    format. |'
  prefs: []
  type: TYPE_TB
- en: '| noon | At 12:00 during day time. |'
  prefs: []
  type: TYPE_TB
- en: '| teatime | At 16:00 or 4 pm in afternoon. |'
  prefs: []
  type: TYPE_TB
- en: '| midnight | At 12:00 at night. |'
  prefs: []
  type: TYPE_TB
- en: '| today | Refers to the current time on same day. |'
  prefs: []
  type: TYPE_TB
- en: '| tomorrow | Refers to the current time on the next day. |'
  prefs: []
  type: TYPE_TB
- en: '| AM or PM | Suffixed with the time to specify time in 12-hour format, for
    example, 4:00PM. |'
  prefs: []
  type: TYPE_TB
- en: '| now + count time-units | Run a script at the same time after a certain time-unit.
    Count can be an integer number. Time units can be in minutes, hours, days, weeks,
    months, or years. |'
  prefs: []
  type: TYPE_TB
- en: '| Date | A date can be given in the form of month-name, day, and optional year.
    Date can be in one of the following formats: MMDD[CC]YY, MM/DD/[CC]YY, DD.MM.[CC]YY,
    or [CC]YY-MM-DD. |'
  prefs: []
  type: TYPE_TB
- en: 'The options to the `at` command are explained in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Option | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `-f FILE` | Specify a script file to be executed. |'
  prefs: []
  type: TYPE_TB
- en: '| `-l` | Alias to the `atq` command. |'
  prefs: []
  type: TYPE_TB
- en: '| `-m` | Send an e-mail to the user on job completion. |'
  prefs: []
  type: TYPE_TB
- en: '| `-M` | Don''t send an e-mail to the user. |'
  prefs: []
  type: TYPE_TB
- en: '| `-r` | Alias to the `atrm` command. |'
  prefs: []
  type: TYPE_TB
- en: '| `-t time` | Run a job at the time. The format of time is given as [[CC]YY]MMDDhhmm[.ss].
    |'
  prefs: []
  type: TYPE_TB
- en: '| `-c job_number` | Print the job associated with `job_number` on a standard
    output. |'
  prefs: []
  type: TYPE_TB
- en: '| `-v` | Print the time at which the job will be executed. |'
  prefs: []
  type: TYPE_TB
- en: Scheduling commands
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following command is scheduled to run at 14:00, which stores the filesystem''s
    usage in a file called `file_system_usage.log` in a user''s home directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run the `at` command as shown, a warning message **warning: commands
    will be executed using /bin/sh** is printed, which specifies which shell will
    be used to execute commands. In the next line, we will see `at prompt` where we
    can specify the list of commands to be executed at 14:00\. In our case, we entered
    the `df > ~/file_system_usage.log` command, which means run the `df` command and
    save its result in the `file_system_usage.log` file.'
  prefs: []
  type: TYPE_NORMAL
- en: Once the list of commands to be entered is finished, press the *Enter* key and
    then, in the next line, use the *Ctrl* + *d* keys to exit from `at` prompt. Before
    getting a normal shell prompt, we will see the message saying created job number
    and time stamp at which the job will be executed. In our case, the job number
    is `33` and the time stamp is `Mon Sep 21 14:00:00 2015`.
  prefs: []
  type: TYPE_NORMAL
- en: We can check the content of the `file_system_usage.log` file once the time stamp
    we specified is over.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can print on `stdout` what is going to be executed when a particular scheduled
    job runs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '![Scheduling commands](img/4335_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We can see that the `df > ~/file_system_usage.log` command will be executed.
    The rest of the lines specify in what environment a task will be executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, consider a job scheduled by the root user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The job with the number `34` is scheduled by the user root. This job system
    will reboot at `4am`.
  prefs: []
  type: TYPE_NORMAL
- en: Scheduling a script file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can schedule a script file for execution at a specific time using the `-f`
    option with the `at` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we want to run the `loggedin_user_detail.sh` script next week
    at 4 pm. This script lists logged in users and what processes they are running
    when the script gets executed at a scheduled time. The content of the script is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, to run the preceding script at 4 pm next week, we will run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the job has been scheduled to run one week later.
  prefs: []
  type: TYPE_NORMAL
- en: Listing scheduled tasks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes, it happens that a task has been scheduled to run at a specific time,
    but we forget the time at which a task is supposed to run. We can see the already
    scheduled tasks using one of the `atq` or the `at` command with the `-l` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `atq` command displays jobs scheduled by the current user with the job
    number, time, and user''s name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Running `atq` with `sudo`, lists jobs scheduled by all users.
  prefs: []
  type: TYPE_NORMAL
- en: Removing scheduled tasks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can also remove a scheduled task if the task is no longer required to be
    performed. Removing a task is also useful when we want to the modify time at which
    a task is to be executed. To modify time, first remove the scheduled task and
    then create the same task again with the new time.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we don''t want to reboot a system at 1 am instead of 4 am. For
    this, the root user will first remove the job `34` using the `atrm` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the task scheduled by the root user will now run at 1 am instead
    of 4 am.
  prefs: []
  type: TYPE_NORMAL
- en: Cron jobs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cron jobs are jobs or tasks that run at regular intervals of time unlike the
    `at` command. For example, in office, my job is to keep all the detailed information
    of company employees that is confidential. To keep it secure and updated without
    any loss of information, I will have to take the backup of the latest data in
    external devices such as a hard disk or a flash drive. Depending upon the number
    of employees, I may have to take the backup on a minute, hour, daily or weekly
    basis. It's hard, tedious, and a waste of time to back up manually every time.
    By having the knowledge of how to schedule a cron job, it can be very easily achieved.
    A Cron job creation is frequently done by system administrators to schedule tasks
    that are to be performed at regular intervals, for example, taking the backup
    of a system, saving logs of each user who is logged in, monitoring and reporting
    the network usage of each user, performing system clean-up, scheduling system
    update, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Cron consists of two parts: cron daemon and cron configuration.'
  prefs: []
  type: TYPE_NORMAL
- en: Cron daemon
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The cron daemon automatically starts when a system is booted and keeps running
    in the background. Daemon process is known as crond and is started by systemd
    or the init process, depending upon what your system has. Its task is to check
    configuration files regularly at one minute intervals and check whether any tasks
    are to be completed.
  prefs: []
  type: TYPE_NORMAL
- en: Cron configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Cron configuration contains files and directories where the Cron jobs to be
    scheduled are written. They are available in the `/etc/` directory. The most important
    file associated with cron configuration is `crontab`. In a Linux system, configuration
    files related to cron are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/etc/cron.hourly/`: This contains the scripts to be run each hour'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/etc/cron.daily/`: This contains the scripts to be run once in a day'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/etc/cron.weekly/`: This contains the scripts to be run once in a week'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/etc/cron.monthly/`: This contains the scripts to be run once in a month'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/etc/crontab`: This contains commands and the interval at which they should
    run'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/etc/cron.d/`: This is the directory with files having commands and the interval
    at which they should run'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scripts can be directly added into any of the directories such as `cron.hourly/`,
    `cron.daily/`, `cron.weekly/`, or `cron.monthly/`, in order to run them at an
    hourly, daily, weekly, or monthly basis respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a simple shell script `firefox_memcheck.sh`, which checks
    whether a Firefox process is running or not. If Firefox is running and its memory
    usage is greater than 30 percent, then restart Firefox:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We can add this script into the `/etc/cron.hourly/` directory of the system
    and it will keep checking our Firefox memory usage. This script can be modified
    to monitor the memory usage for other processes too.
  prefs: []
  type: TYPE_NORMAL
- en: Crontab entries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By putting scripts into `cron.{hourly, daily, weekly, monthly}`, we can only
    set tasks at an interval of an hour, day, week, and month. What if a task has
    to run at 2-day intervals, 10-day intervals, 90 minute intervals, and so on? To
    achieve this, we can add tasks into the `/etc/crontab` file or the `/etc/cron.d/`
    directory. Each user may have their own crontab entry and files related to each
    users are available in `/var/spool/`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A crontab entry looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Crontab entries](img/4335_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We can see from the preceding screenshot that a crontab entry has five asterisks.
    Each asterisk defines a specific duration. We can replace * with a value suggested
    against each of them or leave it as it is. If * is mentioned in a field, then
    it means consider all the instances of that field.
  prefs: []
  type: TYPE_NORMAL
- en: 'The timing syntax can also be described as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Specify the **minutes** value between 0 to 59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specify **hours** that can range from 0 to 23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specify **days** that can range from 1 to 31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specify **months** that can range from 1 to 12 or we can write Jan, Feb, … Dec
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specify the **day of a week** that can range from 0 to 6 or we can write sun
    (0), mon (1), …, sat (6)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All five fields are separated by blank spaces. It is followed by a **username**
    that specifies by which user the command will be executed. Specifying the username
    is optional and by default it is run as a root. The last field is command that
    is scheduled for execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example demonstrating how to write the crontab entry is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Each field can be explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`20`: 20th minute'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`7`: 7AM'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*`: Each day'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*`: Each month'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0`: On Sunday'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`foo`: This command will run as the foo user'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`command`: This is the specified command to be executed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, the command will run as root at 7:20 AM every Sunday.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can specify multiple instances of a filed using a comma (,):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Here, `command` will run at 8:30 PM and 10:30 PM every day.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also specify a range of time in a field using a hyphen (`-`) as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This means, the run command is at 7:35, 8:35, 9:35, 10:35, and 11:35 on Sunday,
    Monday, Tuesday, and Wednesday.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run a script at a specific interval, we can specify the forward slash (/)
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The command will run on 9th April between 8:20 AM to 8:45 AM at an interval
    of 4 minutes.
  prefs: []
  type: TYPE_NORMAL
- en: Special strings in Crontab
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Crontab may have the following strings specified as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '| String | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `@hourly` | Run once in an hour, equivalent to 0 * * * * |'
  prefs: []
  type: TYPE_TB
- en: '| `@daily` or `@midnight` | Run once in a day, equivalent to 0 0 * * * |'
  prefs: []
  type: TYPE_TB
- en: '| `@weekly` | Run once in a week, equivalent to 0 0 * * 0 |'
  prefs: []
  type: TYPE_TB
- en: '| `@monthly` | Run once in a month, equivalent to 0 0 1 * * |'
  prefs: []
  type: TYPE_TB
- en: '| `@yearly or @annually` | Run once in a year, equivalent to 0 0 1 1 * |'
  prefs: []
  type: TYPE_TB
- en: '| `@reboot` | Run at system start-up |'
  prefs: []
  type: TYPE_TB
- en: Managing the crontab entry
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We don't add or modify an entry of a crontab directly. It is done by using the
    `crontab` command that allows you to add, modify, and list crontab entries. Each
    user can have their own crontab where they can add, delete, or modify tasks. By
    default, it is enabled for all users, but if a system administrator wants to restrict
    some of the users, he or she can add that user in the `/etc/cron.deny` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax of using the `crontab` command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The options of the crontab are explained in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Option | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `-u user` | Appends the name of the user whose `crontab` is to be modified
    |'
  prefs: []
  type: TYPE_TB
- en: '| `-l` | Displays the current crontab on `stdout` |'
  prefs: []
  type: TYPE_TB
- en: '| `-e` | Edit the current `crontab` using an editor specified by the `EDITOR
    env` |'
  prefs: []
  type: TYPE_TB
- en: '| `-r` | Remove the current `crontab` |'
  prefs: []
  type: TYPE_TB
- en: '| `-i` | Interactive removal of the current `crontab` when used with the `-r`
    option |'
  prefs: []
  type: TYPE_TB
- en: Listing crontab entries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To list the `crontab` entries, we use the `-l` option for the current user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The output says that there is no `crontab` entry for the user `foo`. It means
    the user `foo` has not added any task in his or her `crontab` yet.
  prefs: []
  type: TYPE_NORMAL
- en: 'To view `crontab` as the root user, type the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Editing crontab entries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Crontab of the current user can be edited or modified by using the `-e` option
    with crontab:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'After executing the preceding command, an editor will open where the user can
    add tasks into the `crontab` file. In our case, the `vi` editor is launched. The
    following entries have been added into the user `foo crontab` entry:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Editing crontab entries](img/4335_08_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'After saving and exiting from the editor, the output obtained is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'To view the modified crontab entry of the user `foo`, run the `–l` option again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '![Editing crontab entries](img/4335_08_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To create the `crontab` entry of the user root, we can run `crontab` with the
    `-e` option as the root:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: OR
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'After running the preceding command, the editor opens to modify `crontab` for
    the user root that looks as follows after adding entries:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Editing crontab entries](img/4335_08_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To view the `crontab` entry of the root, we can use `crontab -l` as the root
    user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '![Editing crontab entries](img/4335_08_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The root user can also view and modify the `crontab` entry of another user.
    This is done by specifying the `-u` option followed by the username:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Crontab of the user `foo` will be opened for modification as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Editing crontab entries](img/4335_08_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To view the `crontab` entry of another user, run the `-l` option with `–u`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We can display the `crontab` of the user `foo` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Editing crontab entries](img/4335_08_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Crontab entries are created using the `crontab` command and are stored in the
    `/var/spool/cron/` directory. A file is created by the name of the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We can see that a file is created for the users `root` and `foo`.
  prefs: []
  type: TYPE_NORMAL
- en: Removing crontab entries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can also remove `crontab` using the `-r` option with the `crontab` command.
    By default, `crontab` of the current user is deleted. Using the option with `-i`
    allows the interactive removal of crontab:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'By running the preceding command, the `crontab` entry of the user root has
    been deleted. We can verify this by running the `-l` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The user root can also delete `crontab` of other users by specifying the user
    in the`–u` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We specified '`n`' (no) instead of '`y`' (yes), so the removal of the user `foo
    crontab` will be aborted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s delete this now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the `crontab` entry of the user `foo` has been removed. To verify, run
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: systemd
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nowadays, most of the Linux distribution systems such as Fedora, Ubuntu, Arch
    Linux, Debian, openSUSE, and so on, have switched from `init` to systemd. systemd
    is the first process that gets started after system boot-up with PID 1\. It controls
    and manages other processes that should be started after the system boot-up. It
    is also known as basic building block for an operating system. To learn about
    an init-based system, refer to the Wikipedia link at [https://en.wikipedia.org/wiki/Init](https://en.wikipedia.org/wiki/Init).
  prefs: []
  type: TYPE_NORMAL
- en: systemd units
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: systemd has several units, each containing a configuration file with information
    about a service, socket, device, mount point, swap file or partition, start-up
    target, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table explains some of unit files:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Unit type | File extension | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Service unit | `.service` | A system service |'
  prefs: []
  type: TYPE_TB
- en: '| Device unit | `.device` | A device file recognized by kernel |'
  prefs: []
  type: TYPE_TB
- en: '| Mount unit | `.mount` | A file system mount point |'
  prefs: []
  type: TYPE_TB
- en: '| Timer unit | `.timer` | A systemd timer |'
  prefs: []
  type: TYPE_TB
- en: '| Swap unit | `.swap` | A swap file |'
  prefs: []
  type: TYPE_TB
- en: 'To list all the installed unit files in a system, run the `systemctl` command
    with the `list-unit-files` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '![systemd units](img/4335_08_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To list unit files of a unit type, use the `list-unit-files` and `--type` options.
    Running the following command will show only a service unit available in the system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '![systemd units](img/4335_08_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Managing services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: systemd manages all the available services in a system, from the time of Linux
    kernel boot up till the shutdown of the system. A service in a Linux system is
    an application that runs in the background or is waiting to be used. Service management
    files have the suffix `.service` in its file name.
  prefs: []
  type: TYPE_NORMAL
- en: In systemd-based Linux system, a user or an administrator can manage services
    using the `systemctl` command.
  prefs: []
  type: TYPE_NORMAL
- en: Status of a service
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To list the current status of services and check whether it is running or not,
    use `systemctl status`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to see the status of my `NetworkManager` service, run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '![Status of a service](img/4335_08_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We can see that the `NetworkManager` service is running and is in active state.
    It also provides detailed information associated with the current `NetworkManager`
    service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see status of another service called the `sshd`. The `sshd` service
    controls whether `ssh` connection is possible to a system or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '![Status of a service](img/4335_08_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This shows that service `sshd` is inactive currently.
  prefs: []
  type: TYPE_NORMAL
- en: 'If no verbose output is required, then we can just use the `is-active` option
    to see a service status:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Here, `active` means a service is running and `unknown` means a service is not
    running.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling and disabling services
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When a system is booted, systemd automatically starts some of the services.
    A few of the services may not be running as well. To enable a service to run after
    a system is booted, use `systemctl enable` and to stop a service running by a
    system during boot time, use `systemctl disable`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Executing the following command will allow systemd to run the `sshd` service
    after a system is booted up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Executing the following command will allow systemd to not run `sshd.service`
    when a system is booted up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'To check whether a service is enabled or not, run the `systemctl is-enabled`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: It means that the `sshd` service is disabled currently during the system start-up,
    while the `NetworkManager` service is enabled during the start-up by `systemd`.
  prefs: []
  type: TYPE_NORMAL
- en: Start and stop a service
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When a system is running, sometimes we may need some services running. For example,
    to do `ssh` in my current system from another system, the `sshd` service must
    be running.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s see what the current status of the `sshd` service is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The `sshd` service is not running currently. Let''s try to do `ssh` in a system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the `ssh` connection has been refused.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s start running the `sshd` service. We can start a service by using
    the `systemctl start` command as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the `sshd` service is running. Try doing `ssh` into the machine again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Now, the login has been done successfully.
  prefs: []
  type: TYPE_NORMAL
- en: We can even restart a running service using the `systemctl restart` command.
    This is required when a service has been modified. Then, to enable the modified
    setting, we can just restart it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command will restart the `sshd` service.
  prefs: []
  type: TYPE_NORMAL
- en: 'When `ssh` is no longer required, it''s safe to stop running it. This avoids
    an anonymous access to a machine. To stop running a service, run the `systemctl
    stop` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Viewing system logs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To check whether a user is working on an individual or enterprise machine, viewing
    system logs is very important in order to trace a problem and get detailed information
    of activities happening in a system. Viewing system logs plays an important role
    in monitoring and ensuring network traffics are not vulnerable. On a systemd-based
    system, system logs are collected and managed by one of its component called `journald`.
    Its task is to collect a log of applications and kernel. Log files are available
    in the `/var/log/journal/` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'To view a log collected by `journald`, the `journalctl` command is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Running the preceding command displays all system logs collected, starting from
    old and grows down to newer logs.
  prefs: []
  type: TYPE_NORMAL
- en: Viewing the latest log entries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To see the latest log entries and continuously printing new entries as appended
    to the journal, use the `–f` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '![Viewing the latest log entries](img/4335_08_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To see the log entries captured since the last boot of a system, use the `–b`
    option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '![Viewing the latest log entries](img/4335_08_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Viewing logs of a particular time interval
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can also view logs of a particular time interval. For example, to view logs
    of the last 1 hour, we can run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'To view log entries since July 1, 2015 until now, we can run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'To view logs from Aug 7, 2015 at 7:23 PM to Aug 9, 2015 at 7 AM, we can run
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Embedding languages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Shell scripting provides a certain set of features as compared to what we get
    in other scripted programming languages such as Python, Ruby, Perl, and AWK. These
    languages provide additional features as compared to what we get in a shell script
    language. On Linux and UNIX-based system, to use these languages, we have to install
    them separately if they are not preinstalled.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider a simple example: there is a json or XML file and we want to parse
    it and retrieve the data stored in it. It''s very hard and error-prone to do this
    using shell and its commands, but if we are aware of the Python or Ruby languages,
    we can easily do it and then embed it into a shell script. Embedding another language
    in a shell script should be done to reduce the effort and also to achieve better
    performance.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax for embedding other languages in a shell script is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Scripting language | The syntax of embedding into a shell script |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Python (Python version 2) | `python -c` '' ''. Inside single quotes write
    the Python code to be processed |'
  prefs: []
  type: TYPE_TB
- en: '| Python3 | `python3 -c` '' ''. Inside single quotes write the Python version
    3 code to be processed |'
  prefs: []
  type: TYPE_TB
- en: '| Perl | `perl -e` '' ''. Inside single quotes write the Perl code. |'
  prefs: []
  type: TYPE_TB
- en: '| Ruby | `ruby -e` '' ''. Inside single quotes write the Ruby code. |'
  prefs: []
  type: TYPE_TB
- en: '| AWK | This can be used as a command utility. Refer to the awk man page for
    available options. |'
  prefs: []
  type: TYPE_TB
- en: Embedding Python language
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To embed Python language inside a shell script, we will use `python -c " Python
    Code"`. To learn about Python, refer to the official website at [https://www.python.org/](https://www.python.org/).
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple Python example would be printing `Hello World` in Python, which is
    done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: To embed this in a shell script, we can write the code as follows
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'We will now execute the `python_print.sh` script as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'To embed multiple lines of Python code in a shell script, use the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Here, **python -** instructs the python command to take the input from stdin
    and `EOF` is a label that instructs to take the stdin input until it encounters
    the `EOF` text.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example embeds Python language in a shell script and fetches
    unread e-mails from the user''s Gmail account:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'After executing this script, the sample output looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Embedding AWK language
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Awk is a programming language designed for text processing and is mainly used
    for fetching relevant data and for reporting tools. To learn more about AWK programming
    language, refer to its man page or visit the website at [http://www.gnu.org/software/gawk/manual/gawk.html](http://www.gnu.org/software/gawk/manual/gawk.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'The Awk language can be very easily used in a shell script. For example, consider
    the output of the `df` command on a running system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '![Embedding AWK language](img/4335_08_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To fetch the fourth column—that is, the `Avail` field using `awk`—we can write
    a shell script using `awk` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '![Embedding AWK language](img/4335_08_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Consider another example in which we will use an input file that will be the
    `/etc/passwd` file of a system. This file contains the basic information about
    each user or account on a Linux or UNIX-based system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each line of a `/etc/passwd` file looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: There are seven fields and each field is separated by a colon (:). To learn
    the detailed meaning of each field, refer to the Wikipedia link at [https://en.wikipedia.org/wiki/Passwd](https://en.wikipedia.org/wiki/Passwd).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following shell script makes use of awk features and displays some useful
    information from the `/etc/passwd` file. For example, we will consider the following
    as the content of the `passwd` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this script gives following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is also possible to use compiled languages such as C, C++, and Java in a
    shell script. To do so, write commands to compile and execute the code.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After reading this chapter, you should now know how to schedule a task to be
    performed at a specific time using the `at` command. You should also know the
    benefits of creating Cron jobs, which need to be performed multiple times. You
    should have also learned how to use the `crontab` command to add, modify, list,
    and remove crontab entries. You also have a good understanding of `systemd`—the
    first process created on a system—and how it manages other system processes, services,
    and logs. You should also know how to embed other scripting languages such as
    Python, AWK, Ruby, and so on, in a shell script.
  prefs: []
  type: TYPE_NORMAL
- en: After reading all of these chapters and practicing the examples, you should
    now be confident in shell scripting. Being a master of the command line, you are
    now capable of writing your own shell scripts to solve your day-to-day tasks.
    Finally, if anything is not covered in this book, you know that you should look
    into the man page of any command for help.
  prefs: []
  type: TYPE_NORMAL
