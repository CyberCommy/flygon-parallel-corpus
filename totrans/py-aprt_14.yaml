- en: Chapter 9 – Files and resource management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Reading and writing files is a key part of what many real-world programs do.
    The notion of a *file*, however, is somewhat abstract. In some cases a file might
    mean collection of bytes on a hard disk; in others cases it might mean, for example,
    an HTTP resource on a remote system. These two entities share some behavior. For
    example, you can read a sequence of bytes from each. At the same time, they’re
    not identical. You can, for example, generally write bytes back to a local file
    while you can’t do that with HTTP resources.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter we’ll look at Python’s basic support for working with files.
    Since dealing with local files is both common and important, we’ll focus primarily
    on working with them. Be aware, though, that Python and its ecosystem of libraries
    provides similar *file-like* APIs for many other kinds of entities, including
    URI-based resources, databases, and many other sources of data. This use of a
    common API is very convenient and makes it easy to write code that can work against
    a wide range of data sources without change.
  prefs: []
  type: TYPE_NORMAL
- en: Also in this chapter we’ll look at *context managers*, one of Python’s primary
    means for managing resources. Context managers allow you to write code that is
    robust and predictable in the face of exceptions, ensuring that resources such
    as files are properly closed and accounted for when errors occur.
  prefs: []
  type: TYPE_NORMAL
- en: Files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To open a local file in Python we call the built-in `open()` function. This
    takes a number of arguments, but the most commonly used are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`file`: the path to the file. *This is required*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mode`: read, write, append and binary or text. This is optional, but we recommend
    always specifying it for clarity. Explicit is better than implicit.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`encoding`: If the file contains encoded text data, which encoding to use.
    It’s often a good idea to specify this. If you don’t specify it, Python will choose
    a default encoding for you.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Binary and text modes
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: At the filesytem level, of course, files contain only a series of bytes. Python,
    however, distinguishes between files opened in binary and text modes, even when
    the underlying operating system doesn’t. When you open a file in binary mode,
    you are instructing Python to use the data in the file without any decoding; binary
    mode file reflects the raw data in the file.
  prefs: []
  type: TYPE_NORMAL
- en: A file opened in text mode, on the other hand, treats its contents as if it
    contains text strings of the `str` type. When you get data from a text mode file,
    Python first decodes the raw bytes using either a platform-dependent encoding
    or, if provided, the `encoding` argument to `open()` .
  prefs: []
  type: TYPE_NORMAL
- en: By default, text mode files also engage support for Python’s *universal newlines*.
    This causes translation between a single portable newline character in our program
    strings (`'\n'`) and a platform dependent newline representation in the raw bytes
    stored in the file system (for example carriage-return-newline (`'\r\n'`) on Windows).
  prefs: []
  type: TYPE_NORMAL
- en: The importance of encoding
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Getting the encoding right is *crucial* for correctly interpreting the contents
    of a text file, so we want to labor the point a bit. Python ^([24](chap21.xhtml#fn-detecting-encoding))
    can’t reliably determine the encoding of a text file, so it doesn’t try. Yet without
    knowing the encoding of a file, Python can’t properly manipulate the data in the
    file. That’s why it’s critical that you tell Python which encoding to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you don’t specify an encoding Python will use the default from `sys.getdefaultencoding()`.
    In our case, the default encoding is `''utf-8''`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Always remember, though, that there’s no guarantee that the default encoding
    on your system is the same as the default encoding on another system with which
    you wish to exchange files. It’s better for all concerned to make a conscious
    decision about the text-to-bytes encoding by specifying it in your calls to `open()`.
    You can get a list of supported text encodings in the [Python documentation](https://docs.python.org/3/library/codecs.html#standard-encodings).
  prefs: []
  type: TYPE_NORMAL
- en: Opening a file for writing
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s start working with files by opening a file in *write* mode. We’ll be
    explicit about using the UTF-8 encoding, because we have no way of knowing what
    your default encoding is. We’ll also use keyword arguments to make things clearer
    still:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The first argument is the filename. The `mode` argument is a string containing
    letters with different meanings. In this case ‘w’ means *write* and ‘t’ means
    *text*.
  prefs: []
  type: TYPE_NORMAL
- en: 'All mode strings should consist of one of *read*, *write* or *append* mode.
    This table lists the mode codes along with their meanings:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Code | Meaning |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `r` | Open file for reading. The stream is positioned at the |'
  prefs: []
  type: TYPE_TB
- en: '|   | beginning of the file. This is the default. |'
  prefs: []
  type: TYPE_TB
- en: '| `r+` | Open for reading and writing. The stream is positioned at the |'
  prefs: []
  type: TYPE_TB
- en: '|   | beginning of the file. |'
  prefs: []
  type: TYPE_TB
- en: '| `w` | Truncate file to zero length or create file for writing. |'
  prefs: []
  type: TYPE_TB
- en: '|   | The stream is positioned at the beginning of the file. |'
  prefs: []
  type: TYPE_TB
- en: '| `w+` | Open for reading and writing. The file is created if it does not |'
  prefs: []
  type: TYPE_TB
- en: '|   | exist, otherwise it is truncated. The stream is positioned at |'
  prefs: []
  type: TYPE_TB
- en: '|   | the beginning of the file. |'
  prefs: []
  type: TYPE_TB
- en: '| `a` | Open for writing. The file is created if it does not exist. The |'
  prefs: []
  type: TYPE_TB
- en: '|   | stream is positioned at the end of the file. Subsequent writes |'
  prefs: []
  type: TYPE_TB
- en: '|   | to the file will always end up at the then current end of file, |'
  prefs: []
  type: TYPE_TB
- en: '|   | irrespective of any intervening seeks or similar. |'
  prefs: []
  type: TYPE_TB
- en: '| `a+` | Open for reading and writing. The file is created if it does not |'
  prefs: []
  type: TYPE_TB
- en: '|   | exist. The stream is positioned at the end of the file. |'
  prefs: []
  type: TYPE_TB
- en: '|   | Subsequent writes to the file will always end up at the then |'
  prefs: []
  type: TYPE_TB
- en: '|   | current end of file, irrespective of any intervening seeks or |'
  prefs: []
  type: TYPE_TB
- en: '|   | similar. |'
  prefs: []
  type: TYPE_TB
- en: 'One of the preceding should be combined with a selector from the next table
    for specifying *text* or *binary* mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Code | Meaning |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `t` | File contents interpreted as encoded text strings. The bytes in |'
  prefs: []
  type: TYPE_TB
- en: '|   | the file will be encoded and decoded according the to the |'
  prefs: []
  type: TYPE_TB
- en: '|   | specified text encoding, and universal newline translation will |'
  prefs: []
  type: TYPE_TB
- en: '|   | be in effect (unless explicitly disabled). All methods which write |'
  prefs: []
  type: TYPE_TB
- en: '|   | and read data from the file accept and return `str` objects. |'
  prefs: []
  type: TYPE_TB
- en: '|   | *This is the default*. |'
  prefs: []
  type: TYPE_TB
- en: '| `b` | File contents are treated as raw bytes. All methods which write |'
  prefs: []
  type: TYPE_TB
- en: '|   | and read data from the file accept and return `bytes` objects. |'
  prefs: []
  type: TYPE_TB
- en: Examples of typical mode strings might be `'wb'` for “write binary” or `'at'`
    for “append text”. Although both parts of the mode code support defaults, we recommend
    being explicit for the sake of readability.
  prefs: []
  type: TYPE_NORMAL
- en: The exact type of the object returned by `open()` depends on how the file was
    opened. This is dynamic typing in action! For most purposes, however, the actual
    type returned by `open()` is unimportant. It is sufficient to know that the returned
    object is a *file-like object*, and as such we can expect it to support certain
    attributes and methods.
  prefs: []
  type: TYPE_NORMAL
- en: Writing to files
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ve shown previously how we can request `help()` for modules and methods and
    types, but in fact we can request help on instances too. This makes sense when
    you remember that *everything* is an object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Browsing through the help, we can see that `f` supports a method `write()`.
    Quit the help with ‘q’ and continue at the REPL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s write some text to our file useing the `write()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The call to `write()` returns the number of codepoints or characters written
    to the file. Let’s add a few more lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: You’ll notice that we’re explicitly including newlines in the text we write
    to the file. It’s the callers responsibility to provide newline characters where
    they are needed; Python does not provide a `writeline()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Closing files
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we’ve finished writing, we should remember to close the file by calling
    the `close()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Note that it’s only after we close the file that we can be certain that the
    data we’ve written becomes visible to external processes. Closing files is important!
  prefs: []
  type: TYPE_NORMAL
- en: Also remember that you can no longer read from or write to a file after closing
    it. Attempts to do so will result in an exception.
  prefs: []
  type: TYPE_NORMAL
- en: The file outside of Python
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you now exit the REPL, and look in your filesystem you can see that you
    have indeed created a file. On Unix use the `ls` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: You should see the `wasteland.txt` file with 78 bytes.
  prefs: []
  type: TYPE_NORMAL
- en: 'On Windows use `dir`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In this case you should see `wasteland.txt` with 79 bytes because Python’s universal
    newline behavior for files has translated the line ending to your platform’s native
    endings.
  prefs: []
  type: TYPE_NORMAL
- en: The number returned by the `write()` method is the number of codepoints (or
    characters) in the string passed to `write()`, *not* the number of bytes written
    to the file after encoding and universal newline translation. In general, when
    working with text files, you cannot sum the quantities returned by `write()` to
    determine the length of the file in bytes.
  prefs: []
  type: TYPE_NORMAL
- en: Reading files
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To read the file back we use `open()` again, but this time we pass `''rt''`,
    for *read-text*, as the mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If we know how many bytes to read, or if we want to read the whole file, we
    can use `read()`. Looking back through our REPL we can see that the first write
    was 32 characters long, so let’s read that back with a call to the `read()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In text mode, the `read()` method accepts the number of *characters* to read
    from the file, not the number of bytes. The call returns the text and advances
    the file pointer to the end of what was read. Because we opened the file in text
    mode, the return type is `str`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To read *all* the remaining data in the file we can call `read()` without an
    argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This gives us parts of two lines in one string — note the newline character
    in the middle.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end of the file, further calls to `read()` return an empty string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Normally when we have finished reading a file we would `close()` it. For the
    purposes of this exercise, though, we’ll keep the file open and use `seek()` with
    an argument of zero to move the file pointer back to the start of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The return value of `seek()` is the new file pointer position.
  prefs: []
  type: TYPE_NORMAL
- en: Readline line by line
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Using `read()` for text is quite awkward, and thankfully Python provides better
    tools for reading text files line by line. The first of these is `readline()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Each call to `readline()` returns a single line of text. The returned lines
    are terminated by a single newline character, if there is one present in the file.
  prefs: []
  type: TYPE_NORMAL
- en: The last line here does not terminate with a newline because there is no newline
    sequence at the end of the file. You shouldn’t *rely* on the string returned by
    `readline()` being terminated by a newline. And remember that the universal newline
    support will have translated whatever the platform native newline sequence into
    `'\n'`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we reach the end of the file further calls to `readline()` return an empty
    string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Reading multiple lines at once
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Let’s rewind our file pointer again and read our file in a different way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Sometimes when we know we want to read every line in the file — and if we’re
    sure we have enough memory to do so — we can read all lines from the file into
    a list with the `readlines()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This is particularly useful if parsing the file involves hopping backwards and
    forwards between lines; it’s much easier to do this with a list of lines than
    with a file stream of characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'This time, we’ll close the file before moving on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Appending to files
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Sometimes we would like to append to an existing file, and we can do that by
    using the mode `''a''`. In with this mode, the file is opened for writing and
    the file pointer is moved to the end of any existing data. In this example we
    combine `''a''` with `''t''` to be explicit about using text mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Although there is no `writeline()` method in Python, there is a `writelines()`
    method which writes an iterable series of strings to the stream. If you want line
    endings on your strings *you must provide them yourself*. This may seem odd at
    first, but it preserves symmetry with `readlines()` whilst also giving us the
    flexibility for using `writelines()` to write any iterable series of strings to
    a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Notice that only three lines are completed here — we say *completed* because
    the file we’re appending to did not itself end with a newline.
  prefs: []
  type: TYPE_NORMAL
- en: File objects as iterators
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The culmination of these increasingly sophisticated text file reading tools
    is the fact that file objects support the *iterator* protocol. When you iterate
    over a file, each iteration yields the next line in the file. This means that
    they can be used in for-loops and any other place where an iterator can be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we’ll take the opportunity to create a Python module file `files.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We can call this directly from the system command line, passing the name of
    our text file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: You’ll notice that there are empty lines between each line of the poem. This
    occurs because each line in the file is terminated by a new line, and then `print()`
    adds its own.
  prefs: []
  type: TYPE_NORMAL
- en: To fix that, we could use the `strip()` method to remove the whitespace from
    the end of each line prior to printing. Instead we’ll use the `write()` method
    of the `stdout` stream. This is *exactly* the same `write()` method we used to
    write to the file earlier — and can be used because the `stdout` stream is itself
    a file-like object.
  prefs: []
  type: TYPE_NORMAL
- en: 'We get hold of a reference to the `stdout` stream from the `sys` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'If we re-run our program we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Now, alas, it’s time to move on from one of the most important poems of the
    twentieth century and get to grips with something *almost* as exciting, context
    managers.
  prefs: []
  type: TYPE_NORMAL
- en: Context managers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For the next set of examples we’re going to need a data file containing some
    numbers. Using the code in `recaman.py` below, we’ll write a sequence of numbers
    called [Recaman’s sequence](http://mathworld.wolfram.com/RecamansSequence.html)
    to a text file, with one number per line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Recaman’s sequence itself isn’t important to this exercise; we just needed a
    way of generating numeric data. As such, we won’t be explaining the `sequence()`
    generator. Feel free to experiment though.
  prefs: []
  type: TYPE_NORMAL
- en: The module contains a generator for yielding the Recaman numbers and a function
    which writes the start of the sequence to file using the `writelines()` method.
    A generator expression is used to convert each number to a string and add a newline.
    `itertools.islice()` is used to truncate the otherwise infinite sequence.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll write the first 1000 Recaman numbers to a file by executing the module,
    passing the filename and series length as command line arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let’s make a complementary module `series.py` which reads this data file
    back in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We read one line at a time from the open file, strip the newline with a call
    to the `strip()` string method, and convert it to an integer. If we run it from
    the command line, everything should work as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let’s deliberately create an exceptional situation. Open `recaman.dat`
    in a text editor and replace one of the numbers with something that isn’t an stringified
    integer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Save the file, and re-run `series.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The `int()` constructor raises a `ValueError` when passed our new, invalid line.
    The exception is unhandled, and so the program terminates with stack trace.
  prefs: []
  type: TYPE_NORMAL
- en: Managing resources with `finally`
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: One problem here is that our `f.close()` call was never executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'To fix that, we can insert a `try` .. `finally` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the file will always be closed, even in the presence of exceptions. Making
    this change opens up the opportunity for another refactoring: we can replace the
    for-loop with a list comprehension and return this list directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Even in this situation `close()` will still be called; the `finally` block is
    called no matter how the `try` block is exited.
  prefs: []
  type: TYPE_NORMAL
- en: with-blocks
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Up to now our examples have all followed a pattern: `open()` a file, work with
    the file, `close()` the file. The `close()` is important because it informs the
    underlying operating system that you’re done working with the file. If you don’t
    close a file when you’re done with it, it’s possible to lose data. There may be
    pending writes buffered up which might not get written completely. Furthermore,
    if you’re opening lots of files, your system may run out of resources. Since we
    always want to pair every `open()` with a `close()`, we would like a mechanism
    that enforces the relationship even if we forget.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This need for resource clean up is common enough that Python implements a specific
    control flow structure called *with-blocks* to support it. With-blocks can be
    used with any object that supports the *context-manager* protocol, which includes
    the file-objects returned by `open()`. Exploiting the fact the the file object
    is a context-manager, our `read_series()` function can become:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We no longer need to call `close()` explicitly because the `with` construct
    will call it for us when execution exits the block, no matter how we exit the
    block.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can go back and modify our Recaman series writing program to use a with-block,
    too, again removing the need for the explicit `close()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Moment of zen
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '![](images/m09----zen-beautiful-is-better-than-ugly.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The with-block syntax looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This is so-called *syntactic sugar* for a much more complex arrangement of
    `try...except` and `try...finally` blocks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: ^([25](chap21.xhtml#fn-see-pep-343))
  prefs: []
  type: TYPE_NORMAL
- en: Which do you prefer?
  prefs: []
  type: TYPE_NORMAL
- en: Few of us would want our code to look this convoluted, but this is how it would
    need to look without the `with` statement. Sugar may not be good for your health,
    but it can be very healthy for your code!
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Binary files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So far we’ve looked at text files, where we deal with the file contents as Unicode
    strings. There are many cases, however, where files contain data that is not encoded
    text. In these situations we need to be able to work with the exact bytes that
    are present in the file, without any intermediate encoding or decoding. This is
    what *binary mode* is for.
  prefs: []
  type: TYPE_NORMAL
- en: The BMP file format
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To demonstrate handling of binary files, we need an interesting binary data
    format. BMP is an image file format that contains Device Independent Bitmaps.
    It’s simple enough that we can make a BMP file writer from scratch. ^([26](chap21.xhtml#fn-bmp-details))
    Place the following code in a module called `bmp.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This may look complex, but as you’ll see it’s relatively straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: 'For simplicity’s sake, we have decided to deal only with 8-bit grayscale images.
    These have the nice property that they are one byte per pixel. The `write_grayscale()`
    function accepts two arguments: the filename and a collection of pixel values.
    As the docstring points out, this collection should be a sequence of sequences
    of integers. For example, a list of lists of `int` objects will do just fine.
    Furthermore:'
  prefs: []
  type: TYPE_NORMAL
- en: Each `int` must be a pixel value from 0 to 255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each inner list is a row of pixels from left to right
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The outer list is a list of pixel rows, from top to bottom.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first thing we do is figure out the size of the image by counting the number
    of rows (line 19) to give the height and the number of items in the zeroth row
    to get the width (line 20). We assume, but don’t check, that all rows have the
    same length (in production code that’s a check we would want to make).
  prefs: []
  type: TYPE_NORMAL
- en: Next , we `open()` (line 22) the file for *write in binary* mode using the `'wb'`
    mode string. We don’t specify an encoding - that makes no sense for raw binary
    files.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the with-block we start writing what is called the ‘BMP Header’ which
    begins the BMP format.
  prefs: []
  type: TYPE_NORMAL
- en: The header must start with a so-called “magic” byte sequence `b'BM'` to identify
    it as a BMP file. We use the `write()` method (line 24), and, because the file
    was opened in binary mode, we must pass a `bytes` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next four bytes should hold a 32-bit integer containing the file size,
    a value that we don’t yet know. We could have computed it in advance, but instead
    we’ll take a different approach: we’ll write a placeholder value then return to
    this point later to fill in the details. To be able to come back to this point
    we use the `tell()` method of the file object (line 28); this gives us the file
    poiner’s offset from the beginning of the file. We’ll store this offset in a variable
    which will act as a sort of bookmark. We write four zero-bytes as the placeholder
    (line 29), using escaping syntax to specify the zeros.'
  prefs: []
  type: TYPE_NORMAL
- en: The next two pairs of bytes are unused, so we just write zero bytes to them
    too (lines 32 and 33).
  prefs: []
  type: TYPE_NORMAL
- en: The next four bytes are for another 32-bit integer which should contain the
    offset in bytes from the beginning of the file to the start of the pixel data.
    We don’t know that value yet either, so we’ll store another bookmark using `tell()`
    (line 37) and write another four byte placeholder (line 38); we’ll return here
    shortly when we know more.
  prefs: []
  type: TYPE_NORMAL
- en: The next section is called the ‘Image Header’. The first thing we have to do
    is write the length of the image header as a 32-bit integer (line 41). In our
    case the header will always be 40 bytes long. We just hardwire that in hexadecimal.
    Notice that the BMP format is little-endian - the least significant byte is written
    first.
  prefs: []
  type: TYPE_NORMAL
- en: The next four bytes are the image width as a little-endian 32-bit integer. We
    call a module scope implementation detail function here called `_int32_to_bytes()`
    which converts an `int` object into a `bytes` object containing exactly four bytes
    (line 42). We then use the same function again to deal with the image height (line
    43).
  prefs: []
  type: TYPE_NORMAL
- en: The remainder of the header is essentially fixed for 8-bit grayscale images
    and the details aren’t important here, except to note that the whole header does
    in fact total 40 bytes (line 45).
  prefs: []
  type: TYPE_NORMAL
- en: Each pixel in an 8-bit BMP image is an index into a color table with 256 entries.
    Each entry is a four-byte BGR color. For grayscale images we need to write 256
    4-byte gray values on a linear scale (line 54). This snippet is fertile ground
    for experimentation, and an natural enhancement to this function would be to be
    able to supply this palette separately as an optional function argument.
  prefs: []
  type: TYPE_NORMAL
- en: At last, we’re ready to write the pixel data, but before we do we make a note
    of the current file pointer offset using `tell()` (line 59) as this was one of
    the locations we need to go back and fill in later.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the pixel data itself is straightforward enough. We use the `reversed()`
    built-in function (line 60) to flip the order of the rows; BMP images are written
    bottom to top. For each row we pass the iterable series of integers to the `bytes()`
    constructor (line 61). If any of the integers are out of the range 0–255, the
    constructor will raise a `ValueError`.
  prefs: []
  type: TYPE_NORMAL
- en: Each row of pixel data in a BMP file must be a multiple of four bytes long,
    irrespective of image width. To do this (line 63), we take the row length modulus
    four, to give a number between zero and three inclusive, which is the the number
    of bytes over the *previous* four-byte boundary the end of our row falls. To get
    the number of padding bytes required to take us up to the *next* four byte boundary
    we subtract this modulus value from four to give a value of 4 to 1 inclusive.
    However, we never want to pad with four bytes, only with one, two or three, so
    we must take modulus four again, to convert the four byte padding to zero byte
    padding.
  prefs: []
  type: TYPE_NORMAL
- en: This value is used with the repetition operator applied to a single zero-byte
    to produce a bytes object containing zero, one, two or three bytes. We write this
    to the file, to terminate each row (line 65).
  prefs: []
  type: TYPE_NORMAL
- en: After the pixel data we are at the end of the file. We undertook to record this
    offset value earlier, so we record the current position using `tell()` (line 68)
    into an end-of-file bookmark variable.
  prefs: []
  type: TYPE_NORMAL
- en: Now we can return and fulfil our promises by replacing the placeholder offsets
    we recorded with the real thing. First, the file length. To do this we `seek()`
    (line 71) back to the `size_bookmark` we remembered back near the beginning of
    the file and `write()` (line 72) the size stored in `eof_bookmark` as a little-endian
    32-bit integer using our `_int32_to_bytes()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we `seek()` (line 75) to the pixel data offset placeholder bookmarked
    by `pixel_offset_bookmark` and write the 32-bit integer stored in `pixel_data_bookmark`
    (line 76).
  prefs: []
  type: TYPE_NORMAL
- en: As we exit the with-block we can rest assured that the context manager will
    close the file and commit any buffered writes to the file system.
  prefs: []
  type: TYPE_NORMAL
- en: Bitwise operators
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Dealing with binary files often requires pulling apart or assembling data at
    the byte level. This is exactly what our `_int32_to_bytes()` function is doing.
    We’ll take a quick look at it because it shows some features of Python we haven’t
    seen before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The function uses the `>>` (*bitwise-shift*) and `&` (*bitwise-and*) operators
    to extract individual bytes from the integer value. Note that bitwise-and uses
    the ampersand symbol to distinguish it from *logical-and* which is the spelled
    out word “and”. The `>>` operator shifts the binary representation of the integer
    right by the specified number of bits. The routine shifts the integer argument
    one, two, and three bytes to the right before extracting the least significant
    byte with `&` after each shift. The four resulting integers are used to construct
    a tuple which is then passed to the `bytes()` constructor to produce a four byte
    sequence.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a BMP file
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In order to generate a BMP image file, we’re going to need some pixel data.
    We’ve included a simple module `fractal.py` which produces pixel values for the
    iconic [Mandelbrot set fractal](https://en.wikipedia.org/wiki/Mandelbrot_set).
    We’re not going to explain the fractal generation code in detail, still less the
    math behind it. But the code is simple enough, and it doesn’t rely on any Python
    features we haven’t encountered previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The key takeaway is that the `mandelbrot()` function uses nested list comprehensions
    to produce a list of lists of integers in the range 0–255\. This list of lists
    represents an image of the fractal. The integer value for each point is produced
    by the `mandel()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Generating fractal images
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Let’s fire up a REPL and use the `fractal` and `bmp` modules together. First
    we use the `mandelbrot()` function to product an image of 448 by 256 pixels. You’ll
    get best results using images with an aspect ratio of 7:4:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This call to `mandelbrot()` may take a second or so — our fractal generator
    is simple rather than efficient!
  prefs: []
  type: TYPE_NORMAL
- en: 'We can take a look at the returned data structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s a list of lists of integers, just as we were promised. Let’s write those
    pixel values to a BMP file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Find the file and open it in an image viewer, for example by opening it in your
    web browser.
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/m09----mandel.png)'
  prefs: []
  type: TYPE_IMG
- en: Reading binary files
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we’re producing beautiful Mandelbrot images, we should see about reading
    those BMPs back with Python. We’re not going to write a full-blown BMP reader,
    although that would be an interesting exercise. We’ll just make a simple function
    to determine the image dimension in pixels from a BMP file. We’ll add the code
    into `bmp.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Of course, we use a with-statement to manage the file, so we don’t have to worry
    about it being properly closed. Inside the with-block we perform a simple validation
    check by looking for the two first magic bytes that we expect in a BMP file. If
    they’re not present, we raise a `ValueError` which will, of course, cause the
    context manager to close the file.
  prefs: []
  type: TYPE_NORMAL
- en: Looking back at our BMP writer, we can determine that the image dimensions are
    stored exactly 18 bytes from the beginning of the file. We `seek()` to that location
    and use the `read()` method to read two chunks of four bytes each for the two
    32-bit integers which represent the dimensions. Because we opened the file in
    binary mode, `read()` returns a `bytes` object. We pass each of these two `bytes`
    objects to another implementation detail function called `_bytes_to_int32()` which
    assembles them back into an integer. The two integers, representing image width
    and height, are returned as a tuple.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `_bytes_to_int32()` function uses `<<` (*bitwise left-shift*) and `|` (*bitwise-or*),
    together with indexing of the `bytes` object, to reassemble the integer. Note
    that indexing into a `bytes` object returns an integer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'If we use our new reader code, we can see that it does indeed read the correct
    values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: File-like objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is a notion in Python of “file-like objects”. This isn’t as formal as
    a specific protocol^([27](chap21.xhtml#fn-like-sequence-protocol)), but, thanks
    to the polymorphism afforded by duck-typing, it works well in practice.
  prefs: []
  type: TYPE_NORMAL
- en: 'The reason it’s not closely specified is that different types of data streams
    and devices have many different capabilities, expectations, and behaviors. So
    in fact defining a set of protocols to model them would be quite complex, and
    it wouldn’t actually gain us much in practice, other than a smug sense of theoretical
    achievement. This is where the EAFP ^([28](chap21.xhtml#fn-EAFP)) philosophy comes
    into its own: if you want to perform `seek()` on a file-like object without knowing
    in advance that it supports random access, go ahead and try (literally!). Just
    be prepared to fail if the `seek()` method doesn’t exist, or if it *does* exist
    but doesn’t behave as you expect.'
  prefs: []
  type: TYPE_NORMAL
- en: You might say “If it looks like a file and reads like a file, then it is a file”.
  prefs: []
  type: TYPE_NORMAL
- en: You’ve already seen file-like objects!
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ve actually seen file-like objects in action already; the objects returned
    to us when we open files in text and binary mode are actually of different types,
    although both with definite file-like behavior. There are other types in the Python
    standard library which implement file-like behavior, and in fact we saw one of
    them in action back at the beginning of the book, when we used `urlopen()` to
    retrieve data from a URL on the Internet.
  prefs: []
  type: TYPE_NORMAL
- en: Using file-like objects
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s exploit this polymorphism across file-like objects by writing a function
    to count the number of words per line in a file and return that information as
    a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we’ll open a regular text file containing the fragment of T.S. Eliot’s
    masterpiece we created earlier, and pass it to our new function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The actual type of `real_file` is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: But you shouldn’t normally concern yourself with this specific type; is an internal
    Python implementation detail. You’re just care that it behaves “like a file”.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll now do the same using a file-like object representing a web resource
    referred to by a URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The type of `web_file` is quite different from what we just saw:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: However, since they are both file-like objects, our function can work with both.
  prefs: []
  type: TYPE_NORMAL
- en: There’s nothing magical about file-like objects; it’s just a convenient and
    fairly informal description for a set of expectations we can place on an object
    which are exploited through duck-typing.
  prefs: []
  type: TYPE_NORMAL
- en: Other resources
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The with-statement construct can be used with any type of object which implements
    the context manager protocol. We’re not going to show you how to implement a context-manager
    is this book – for that you’ll need to refer to *The Python Journeyman* – but
    we will show you a simple way to make your own classes usable in a with statement.
    Put this code into the module `fridge.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll import `raid()` into the REPL and go on the rampage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Importantly, we remembered to close the door, so the food will be preserved
    until our next raid. Let’s try another raid for something slightly less healthy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, we were interrupted by the health warning and didn’t get around
    to closing the door. We can fix that by using a function called [`closing()`](https://docs.python.org/3/library/contextlib.html#contextlib.closing)
    in the Python Standard Library [`contextlib` module](https://docs.python.org/3/library/contextlib.html).
    After importing the function we wrap our `RefrigeratorRaider` constructor call
    in a call to `closing()`. This wraps our object in a context manager that always
    calls the `close()` method on the wrapped object before exiting. We use this object
    to initialise a with-block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Now when we execute a raid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'We see that our explicit call to `close()` is unnecessary, so let’s fix that
    up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: A more sophisticated implementation would check that the door was already closed
    and ignore other requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'So does it work? Let’s try eating some deep fried pizza once more:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: This time, even though the health warning was triggered, the door was still
    closed for us by the context manager.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Files are opened using the built-in `open()` function which accepts a file mode
    to control read/write/append behaviour and whether the file is to be treated as
    raw binary or encoded text data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For text data you should specify a text encoding.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Text files deal with string objects and perform universal newline translation
    and string encoding.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Binary files deal with `bytes` objects with no newline translation or encoding.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When writing files, it’s your responsibility to provide newline characters for
    line breaks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Files should always be closed after use.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Files provide various line-oriented methods for reading, and are also iterators
    which yield line by line.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Files are context managers and the with-statement can be used with context managers
    to ensure that clean up operations, such as closing files, are performed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The notion of file-like objects is loosely defined, but very useful in practice.
    Exercise EAFP to make the most of them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Context managers aren’t restricted to file-like objects. We can use tools in
    the `contextlib` standard library module, such as the `closing()` wrapper to create
    our own context managers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Along the we way found that:'
  prefs: []
  type: TYPE_NORMAL
- en: '`help()` can be used on instance objects, not just types.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python supports bitwise operators `&`, `|`, `<<` and `>>`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
