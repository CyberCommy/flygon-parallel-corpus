- en: Building a CRM Using React and Microservices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In previous chapters where we used REST services, we concentrated on having
    a single site for dealing with REST calls. Modern applications frequently make
    use of microservices, potentially hosted inside a container-based system such
    as Docker.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we are going to look at how to create a set of microservices
    hosted in multiple Docker containers using Swagger to design our REST API. Our
    React client application will be responsible for drawing these microservices together
    to create a simple **Customer Relationship Management** (**CRM**) system.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Docker and containers
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What microservices are and what they are used for
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decomposing monolithic architectures down into microarchitectures
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sharing common server-side functionality
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Swagger to design APIs
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hosting microservices in Docker
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using React to connect to microservices
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using routing in React
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The finished project can be downloaded from [https://github.com/PacktPublishing/Advanced-TypeScript-3-Programming-Projects/tree/master/Chapter08](https://github.com/PacktPublishing/Advanced-TypeScript-3-Programming-Projects/tree/master/Chapter08).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: After downloading the project, you will have to install the package requirements
    using the **`npm install`** command. Since the services are spread over a number
    of folders, you will have to install each service individually.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Docker and microservices
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since we are building a system that uses microservices hosted inside Docker
    containers, there is a bit of terminology and theory that we need to understand
    beforehand.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we are going to look at common Docker terms and what they mean
    before we move on to looking at what microservices are, what problems they are
    intended to solve, and how to think about breaking monolithic applications down
    into more modular services.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Docker terminology
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are new to Docker, there is a whole slew of terminology surrounding it
    that you will come across. Knowing the terminology will help when we come to set
    up our servers, so let's start with the basics.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Container
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is probably a term you have come across if you have seen any Docker literature
    on the internet. A container is a running instance taking in the various pieces
    of software needed to run an application. This is the starting point for us. Containers
    are built from images, which you can either build yourself or download from a
    central Docker database. Containers can be opened up to other containers, the
    host operating system, or even to the wider world using ports and volumes. One
    of the big selling points of containers is that they are easy to set up and create
    and can be stopped and started very quickly.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Image
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we covered in the previous paragraph, a container starts off as an image.
    There are a huge number of images already available for use, but we can also create
    our own images. When we create an image, the creation steps are cached so that
    they can be reused easily.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Port
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This should be familiar to you already. The term ports in Docker means exactly
    the same as ports does for OSes. These are TCP or UDP ports that are visible to
    the host operating system, or that are connected to the outer world. We will get
    to some interesting code later on in this chapter when we have applications use
    the same port number internally but expose them to the world using different port
    numbers.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Volume
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The easiest way to visualize a volume is that it is similar to a shared folder.
    When a container is created, volumes are initialized and allow us to persist data,
    regardless of the container life cycle.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Registry
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Effectively, a registry could be viewed as the App Store of the Docker world.
    It stores Docker images that can be downloaded, and local images can be pushed
    back to the registry in a similar fashion to pushing an app up to the App Store.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Docker Hub
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker Hub is the original Docker registry, provided by Docker themselves. This
    registry stores a vast number of Docker images, some of which come from Docker
    and some of which have been built for them by software teams.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we aren't going to cover installing Docker, as installing it
    and setting it up is a chapter in its own right, especially since installing Docker
    on Windows is a different experience to installing Docker on macOS or Linux. The
    commands that we will use to compose Docker applications and check the state of
    instances don't change though, so we will cover them as and when they are needed.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Microservices
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's hard to be involved in the corporate software world and not hear the term
    microservices. This is a style of architecture that breaks a so-called monolithic
    system down into a collection of services. The nature of this architecture is
    that services are tightly scoped and testable. Services should be loosely coupled
    so that dependencies between them are limited—it should be up to the end application
    to bring these services together. This loose coupling promotes the idea that they
    can be deployed independently and that services are generally tightly focused
    on business capabilities.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: Despite what we may hear from marketing gurus and consultancies looking to sell
    services, microservices are not always a suitable choice for an application. Sometimes,
    it is better to stay with a monolithic application. If we can't break the application
    down using all the ideas outlined in the preceding paragraph then, chances are,
    the application is not a suitable candidate for microservices.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike a lot of what we have covered in this book so far, such as patterns,
    microservices don''t have an officially approved definition. You can''t follow
    a checklist and say, *this is a microservice because it is doing a, b, and c*.
    Instead, the agreed view on what constitutes a microservice has evolved, based
    on seeing what works and what doesn''t, into a series of characteristics. For
    our purposes, the important attributes of what constitutes a microservice include
    the following:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: The service can be deployed independently of other microservices. In other words,
    the service has no dependency on other microservices.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The service is based on a business process. Microservices are meant to be granular,
    so having them organized around single business areas helps create large-scale
    applications out of small, focused components.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The languages and technologies can be different across the services. This gives
    us the opportunity to leverage the best and most appropriate technologies where
    necessary. For instance, we might have one service hosted in-house while another
    service might be hosted in a cloud service such as Azure.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The service should be small in size. That doesn't mean that it should not have
    much code to it; rather, it means that it is focused on one area only.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing our REST API using Swagger
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When developing REST-driven applications, I find it really useful to use the
    facilities of Swagger ([https://swagger.io](https://swagger.io)). Swagger has
    many features that make it the go-to tool when we want to do things such as creating
    API documentation, creating code for APIs, and testing APIs.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: We're going to use the Swagger UI to prototype the ability to retrieve a list
    of people. From this, we can generate documentation to go along with our API.
    While we could generate the code from this, we are going to use the tooling that's
    available to see what the *shape* of our final REST call will be, which we will
    use to roll our own implementation using the data model we created previously.
    The reason I like to do this is twofold. First, I like to craft small, clean data
    models, and I find the prototype gives me a visualization of the model. Secondly,
    there's a lot of generated code—an awful lot—and I find it easier to tie my data
    model to the database when I craft the code myself.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: For this chapter, we are going to write the code ourselves, but we will use
    Swagger to prototype what we want to deliver.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we need to do is sign into Swagger:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: 'From the home page, click Sign In. This brings up a dialog that asks which
    product we want to log into, that is, SwaggerHub or Swagger Inspector. Swagger
    Inspector is a great tool for testing our APIs, but since we are going to be developing
    the API, we will sign into SwaggerHub. The following screenshot shows how it looks:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/eed2dbdb-d965-4190-9be0-ddbf0bf2eae0.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
- en: 'If you don''t have a Swagger account, you can create one from here either by
    signing up or by using a GitHub account. In order to create an API, we need to
    select Create New > Create New API. Choose None in the Template dropdown and fill
    it in, as follows:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/408868db-6a1b-44f9-8a05-748d562714f3.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
- en: 'At this stage, we are ready to start filling in our API. What we are given
    out of the box is the following:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let''s start building this API out. First of all, we are going to create the
    start of our API paths. Any paths we need to create go under a `paths` node. The
    Swagger editor validates inputs as we are building the API, so don''t worry if
    it comes up with validation errors as we are filling it in. In our example here,
    we are going to create the API to retrieve an array of all the people we have
    added to our database. Therefore, we start off with this, our API endpoint, which
    replaces the `paths: {}` line:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'So, we have said that our REST call will be issued using a `GET` verb. Our
    API is going to return two statuses, `HTTP 200` and `HTTP 400`. Let''s provide
    the beginnings of this by populating a `responses` node with these statuses. When
    we return a `400` error, we need to create the schema that defines what we will
    return over the wire. The `schema` returns an `object` that contains a single `message` string,
    as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Since our API is going to return an array of people, our schema is typed to
    an `array`. The `items` that make up the person map back to the model we discussed
    in the server code. So, by filling in our `schema` for the `200` response, we
    get this:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This is what our `schema` looks like in the editor:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/29dbb934-da56-4d77-b897-bef2ab2516ad.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
- en: Now that we have seen how Swagger can be used to prototype our APIs, we can
    move onto the definition of the project that we want to build.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: Creating a microservices application with Docker
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The project we are going to write is a small part of a CRM system to maintain
    details about customers and add leads for those customers. The way the application
    works is that the user creates addresses; when they add in details about contacts,
    they will select the address from the list of addresses they have already created.
    Finally, they can create leads that use the contacts they have already added.
    The idea behind this system is that, previously, the application used one big
    database for this information—we are going to break this down into three discrete
    services.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: 'Working alongside the GitHub code, this chapter should take about three hours
    to complete. When completed, the application should look as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/5b119141-e7c1-42f6-8830-50256b3fad64.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
- en: After doing this, we'll move on and see how to create apps for Docker and how
    this complements our project.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: Getting started creating a microservices application with Docker
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are making a welcome return to React in this chapter. As well as using React,
    we will also be using Firebase and Docker, hosting Express and Node. REST communications
    between our React application and the Express microservices will be done with
    Axios.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: If you are using Windows 10 for your development, install Docker Desktop for
    Windows, which is available here: [https://hub.docker.com/editions/community/docker-ce-desktop-windows](https://hub.docker.com/editions/community/docker-ce-desktop-windows).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: In order to run Docker on Windows, you need to have Hyper-V virtualization installed.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: If you want to install Docker Desktop on macOS, head to [https://hub.docker.com/editions/community/docker-ce-desktop-mac](https://hub.docker.com/editions/community/docker-ce-desktop-mac).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Docker Desktop on Mac runs on OS X Sierra 10.12 and newer macOS releases.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: The CRM application that we are going to build demonstrates how we can take
    a number of microservices and bring them together into one cohesive application
    where the end user is unaware that our application is working with information
    from a wide number of data sources.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: 'The requirements of our application are as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: The CRM system will provide the ability to enter addresses.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The system will let the user enter details about a person.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When details are entered about a person, the user can choose a previously entered
    address.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The system will let the user enter details about potential leads.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data will be saved to a cloud database.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The people, leads, and address information will be retrieved from separate services.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These separate services will be hosted by Docker.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our user interface will be created as a React system.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have been steadily working toward being able to share functionality in our
    application. Our microservices are going to take this approach to the next level
    by sharing as much common code as possible and then just adding in the little
    bits and pieces that they need to customize the data they fetch and return to
    the client. We can do this because our services are similar in their requirements,
    so they can share a lot of common code.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: Our microservice application starts off from the point of view of a monolithic
    application. That application has the people, addresses, and leads all managed
    by one system. We are going to treat this monolithic application with the contempt
    it deserves and break it down into smaller, discrete chunks, where each constituent
    part exists in isolation from other parts. Here, the leads, addresses, and people
    all exist in their own self-contained services.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: 'The place that we are going to start is with our `tsconfig` file. In previous
    chapters, we had one service per chapter, with a single `tsconfig` file. We are
    going to mix things up here by having a root level `tsconfig.json` file. Our services
    will all use that as a common base:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by creating a folder called `Services`, which will serve as the
    base for our services. Under this, we are going to create separate `Addresses`,
    `Common`, `Leads`, and `People` folders, as well as our base `tsconfig` file.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When we have finished this step, our `Services` folder should look as follows:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/7a971ac6-66c1-4955-8cc0-b99205dc692a.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s add the `tsconfig` settings. These settings are going to be shared
    by all of the services we are going to host:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You might have noticed that we haven't set up our output directory here. We're
    going to leave that to slightly later on. Before we get to that step, we are going
    to start adding in the common functionality that will be shared by our microservices.
    Our shared functionality is going to be added in the `Common` folder. Some of
    what we are going to add should look very familiar because we built similar server
    code in earlier chapters.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Our services are going to save to Firebase, so we are going to start off by
    writing our database code. The `npm` packages that we need to install to work
    with Firebase are `firebase` and `@types/firebase`. While we are adding these,
    we should also import `guid-typescript` and the basic node `cors` and `express`
    packages that we installed previously.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: 'When each service saves data to the database, it will start with the same basic
    structure. We will have a `ServerID` that we are going to set ourselves using
    a GUID. The basic model that we are going to use starts off like this:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We are going to create an `abstract` base class that will work with instances
    of `IDatabaseModelBase`, giving us the ability to `Get` a record, `GetAll` the
    records, and `Save` a record. The beauty of working with Firebase is that, while
    it is a powerful system, the code that we have to write to accomplish each of
    these tasks is very short. Let''s start off with the class definition:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see, our class is generic, which tells us that each service will
    extend `IDatabaseModelBase` and use that in its specific database implementation.
    The collection is the name of the collection that will be written in Firebase.
    For our purposes, we are going to share one Firebase instance to store the different
    collections, but the beauty of our architecture is that we don't need to if we
    don't want to. We can use separate Firebase stores if we need to; in fact, this
    is generally what would happen in a production environment.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s pointless us adding our `GET` methods if we don''t have any data saved,
    so the first thing we are going to do is write our `Save` method. Unsurprisingly,
    our `Save` method is going to be asynchronous, so it will return a `Promise`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Something that might look strange is the `async (coll)` code. Since we are using
    the fat arrow (`=>`), we are creating a simplified function. Since this is a function,
    we add the `async` keyword to it to indicate that the code can have an `await`
    inside it. If we didn't mark this as `async`, then we would not be able to use
    the `await` inside.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: 'Our code allocates a GUID to the `ServerID` before we call a chain of methods
    to set the data. Let''s tackle the code in small chunks to see what each bit does.
    As we discussed in [Chapter 7](e8c1594d-72de-47a5-bc5c-29af9b8e84fb.xhtml), *Angular
    Cloud-Based Mapping with Firebase*, Firebase offers more than just database services,
    so the first thing we need to do is access the database part. If we weren''t following
    method chaining here, we could write this as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In Firestore, we don''t save data in tables, we save it in named collections.
    Once we have `firestore`, we get `CollectionReference`. Following on from the
    preceding code snippet, we could rewrite this as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Once we have `CollectionReference`, we can get access to individual documents
    using the `ServerID` we set up earlier in the method. If we don''t supply our
    own ID, one will be created for us:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, we need to set the data that we want to write to the database:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This will save the data to a document in the appropriate collection in Firestore.
    I have to admit that, while I like the ability to type in code that can be broken
    down like this, method chaining means that I rarely do so if it's available. Where
    the next step in the chain logically follows on from the previous step, I will
    often chain the methods together because you cannot get to the next step without
    going through the previous steps, and it makes it easy for me to visualize the
    sequence of steps if I see them linked together.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the item is saved to the database, we are going to return the saved item,
    complete with `ServerID`, back to the calling code so that it can be used immediately.
    That''s where this line comes in:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The next step in our `FirestoreService` is to add the `GET` method. This method,
    like the `Save` method, is an `async` method that returns a single instance of
    type `T`, wrapped inside a promise. Since we know the ID, the vast majority of
    our Firestore code is the same. The difference here is that we call `get()`, which
    we then use to return the data:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Guess what? We also have an `async GetAll` method to write, this time returning
    an array of `T`. Since we want to retrieve multiple records, rather than just
    a single doc, we call `get()` on our `collection` instead. Once we have the records,
    we use a simple `forEach` to build up the array we need to return:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'With our database code in place, let''s see what this looks like in practice.
    We''re going to start off in the `Addresses` service by creating an `IAddress`
    interface that extends `IDatabaseModelBase`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数据库代码已经就位，让我们看看实际情况是什么样子。我们将从`Addresses`服务开始，创建一个扩展`IDatabaseModelBase`的`IAddress`接口：
- en: '[PRE15]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'With `IAddress` in place, we can now create the class that ties our service
    to the `addresses` collection that we are going to store in Firebase. With all
    the hard work that we have put in, our `AddressesService` is as simple as this:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 有了`IAddress`，我们现在可以创建将我们的服务与我们将在Firebase中存储的`addresses`集合联系起来的类。通过我们的努力，`AddressesService`就像这样简单：
- en: '[PRE16]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You might wonder whether the code for the data models and database access are
    as easy with the other microservices. Let''s see what our `People` interface and
    database service looks like:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想知道数据模型和数据库访问的代码是否与其他微服务一样简单。让我们看看我们的`People`接口和数据库服务是什么样子的：
- en: '[PRE17]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You might also be wondering why we store the address information inside `IPerson`.
    It's tempting to think that we should start a reference to the address only and
    not duplicate data, especially if you are coming to the NoSQL architecture from
    the viewpoint of relational databases where records are linked together through
    foreign keys to create `pointers` to relationships. *Old-fashioned* SQL databases
    use foreign tables to minimize the redundancies in records so we don't end up
    creating duplicate data that's shared across multiple records. While that's a
    useful thing to have available, it does make querying and retrieving records more
    complicated because the information that we are interested in could well be scattered
    over several tables. By storing the address alongside the person, we reduce the
    number of tables we have to query to build up the person's information. This is
    based on the idea that we want to query records far more often than we want to
    change them so, if we needed to change the address, we would change the master
    address and then a separate query would run through all of the people records
    looking for addresses that needed to be updated. We will be achieving this because
    the `ServerID` record in the address part of the person record will match the
    `ServerID` in the master address.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还想知道为什么我们将地址信息存储在`IPerson`内部。如果您是从关系数据库的角度来看待NoSQL架构，那么很容易认为我们应该只开始引用地址，而不是重复数据，特别是在关系数据库中，记录是通过外键链接在一起创建`指针`来建立关系。
    *老式* SQL数据库使用外部表来最小化记录中的冗余，以便我们不会创建跨多个记录共享的重复数据。虽然这是一个有用的功能，但它确实使查询和检索记录变得更加复杂，因为我们感兴趣的信息可能分散在几个表中。通过将地址存储在人员旁边，我们减少了我们需要查询以构建人员信息的表的数量。这是基于我们想要查询记录的频率远远超过我们想要更改记录的想法，因此，如果我们需要更改地址，我们将更改主地址，然后单独的查询将运行通过所有人员记录，寻找需要更新的地址。我们将实现这一点，因为人员记录中地址部分的`ServerID`将与主地址中的`ServerID`匹配。
- en: We won't cover the `Leads` database code; you can read it in the source, and
    it is virtually identical to this. What we did was work out that our microservices
    would be, functionally, very similar so that we can take advantage of inheritance
    in a simple way.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会涵盖`Leads`数据库代码；您可以在源代码中阅读它，它几乎与此相同。我们的做法是，我们的微服务在功能上非常相似，因此我们可以简单地利用继承。
- en: Adding server-side routing support
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加服务器端路由支持
- en: As well as having a common way of working with the database, our incoming API
    requests are all going to be very similar in terms of endpoints. While writing
    this book, I tried to put together snippets of code that could be reused later
    on. One such snippet is the way we handle Express routing. The server-side code
    we put together in [Chapter 4](23db6d37-1947-4f7b-9b25-3195c2df7274.xhtml), *The
    MEAN Stack – Building a Photo Gallery*, was one such area, specifically the code
    for routing. We can bring this code in pretty much exactly as we wrote it all
    those chapters ago.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 除了有一个与数据库共同工作的常见方式之外，我们的传入API请求在端点方面都将非常相似。在写这本书的时候，我试图整理一些以后可以重复使用的代码片段。其中一个片段是我们处理Express路由的方式。我们在[第4章](23db6d37-1947-4f7b-9b25-3195c2df7274.xhtml)中组合的服务器端代码，*MEAN
    Stack - 构建照片库*，就是这样一个区域，特别是路由的代码。我们可以几乎完全按照当时写的方式引入这段代码。
- en: 'Here''s a quick reminder of what the code looks like. First, we have our `IRouter`
    interface:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这是代码的快速提醒。首先，我们有我们的`IRouter`接口：
- en: '[PRE18]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then, we have our routing engine—the code that we are going to plug directly
    into our server:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们有我们的路由引擎 - 这段代码我们将直接插入到我们的服务器中：
- en: '[PRE19]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'So, what does this look like in practice? Well, here''s the code to save an
    address that has been sent over from the client. When we receive an `/add/` request
    from the client, we extract the details from the body and cast it to an `IAddress`,
    which we then use to save to the addresses service:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，在实践中，这是什么样子呢？好吧，这是保存从客户端发送过来的地址的代码。当我们从客户端收到一个`/add/`请求时，我们从请求体中提取详细信息，并将其转换为`IAddress`，然后用于保存到地址服务中：
- en: '[PRE20]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The code to get the address is very similar. We aren''t going to dissect this
    method because it should look very familiar by now:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 获取地址的代码非常相似。我们不打算解剖这个方法，因为现在它应该看起来非常熟悉：
- en: '[PRE21]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The code for the `Leads` and `People` services are virtually identical. Please
    read the code from our GitHub repository to get familiar with it.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`Leads`和`People`服务的代码几乎是相同的。请阅读我们的GitHub存储库中的代码，以熟悉它。'
- en: The Server class
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器类
- en: 'Again, continuing with the theme of reusing code as much as possible, we are
    going to use a slightly modified version of the Express `Server` class we wrote,
    way back in [Chapter 4](23db6d37-1947-4f7b-9b25-3195c2df7274.xhtml), *The MEAN
    Stack – Building a Photo Gallery*. Again, we will quickly go through the code
    to re-familiarize ourselves with it. First, let''s put the class definition and
    constructor in place. Our constructor is a slimmed-down version of the constructor
    from [Chapter 4](23db6d37-1947-4f7b-9b25-3195c2df7274.xhtml), *The MEAN Stack
    – Building a Photo Gallery*:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We also want to add CORS support. While we could make this mandatory, I still
    like the idea that we can put control of whether we want to do this into the hands
    of the service developer, so we will keep this as a `public` method:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In order for our actual server implementations to work, we need to give them
    the ability to add routing. We do this through the `AddRouting` method:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now that we have our `AddRouting` method, we need code in place to start up
    our server:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'What you may have noticed is that we are missing one important piece of the
    puzzle. We have no database support in place in our server, but our service needs
    to initialize Firebase. In our server, we add in the following:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Note that I have not included `Environment.fireBase` in the repository because
    it contains details about servers and keys that I use. This is a constant that
    contains the Firebase connection information. You can replace this with the connection
    information you set up when you created your Firebase database in the cloud. To
    add this, you will need to create a file in the `Common` folder called `Environment.ts`
    which contains code that looks like this:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Creating our Addresses service
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We now have everything we need to create our actual services. Here, we will
    look at the `Addresses` service, understanding that the other services will follow
    the same pattern. Since we already have the data models, data access code, and
    routing in place, all we have to do is create our actual `AddressesServer` class.
    The `AddressesServer` class is as simple as this:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We start the server like this:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The code is as easy as that. We are following a principle called **Don't Repeat
    Yourself **(**DRY**)  as much as possible. This simply states that you should
    aim to retype as little code as possible. In other words, you should try to avoid
    having code that does exactly the same thing scattered about your code base. Sometimes,
    you can't avoid it and sometimes, it doesn't make sense to go to the trouble of
    creating a lot of code scaffolding for a one- or two-line piece of code, but when
    you have large functional areas, you should definitely try to avoid having to
    copy and paste it into multiple parts of your code. Part of the reason for this
    is if you have copied and pasted code and subsequently you find a bug in it, you
    are going to have to fix that bug in multiple places.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: Using Docker to run our services
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we look at our services, we can see that we have an interesting problem;
    namely that they all use the same port to start up on. Obviously, we can't actually
    use the same port for each service, so have we caused ourselves a problem? Does
    this mean that we cannot start more than one service and, if so, does this blow
    our microservice architecture apart and mean that we should go back to a monolithic
    service?
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Given the potential problems we have just discussed and the fact that this chapter
    introduces Docker, it should come as no surprise to learn that Docker is the answer
    to this. With Docker, we can spin up a container, deploy our code to it, and expose
    the service with a different endpoint. So, how do we do this?
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: 'In each service, we are going to add a couple of common files:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The first file, called `.dockerignore`, chooses which files to ignore when copying
    or adding files to the container.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: 'The next file we are going to add is called `Dockerfile`. This file describes
    the Docker container and how to build it up. `Dockerfile` works by building up
    layers of instructions that represent a step toward building up the container.
    The first layer downloads and installs Node in the container, specifically Node
    version 8:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要添加的下一个文件叫做 `Dockerfile`。这个文件描述了 Docker 容器以及如何构建它。`Dockerfile` 通过构建一系列指令的层来构建容器。第一层在容器中下载并安装
    Node，具体来说是 Node 版本 8：
- en: '[PRE31]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The next layer is used to set the default working directory. This directory
    is used for subsequent commands, such as `RUN`, `COPY`, `ENTRYPOINT`, `CMD`, and
    `ADD`:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 下一层用于设置默认工作目录。该目录用于后续命令，比如 `RUN`、`COPY`、`ENTRYPOINT`、`CMD` 和 `ADD`：
- en: '[PRE32]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In some online sources, you'll see that people create their own directories
    to use as the working directory. It's better to use a predefined, well-known location
    such as `/usr/src/app` as `WORKDIR`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些在线资源中，你会看到人们创建自己的目录作为工作目录。最好使用预定义的、众所周知的位置，比如 `/usr/src/app` 作为 `WORKDIR`。
- en: 'Since we have a working directory in place right now, we can start to set up
    the code. We want to copy the necessary files to download and install our `npm`
    packages:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们现在已经有了一个工作目录，我们可以开始设置代码了。我们想要复制必要的文件来下载和安装我们的 `npm` 包：
- en: '[PRE33]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: As a good practice, we copy the `package.json` and `package-lock.json` files
    before copying the code because the install caches the contents of the installation.
    As long as we don't change the `package.json` file, if the code is built again,
    we won't need to re-download the packages.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个良好的实践，我们在复制代码之前复制 `package.json` 和 `package-lock.json` 文件，因为安装会缓存安装的内容。只要我们不改变
    `package.json` 文件，如果代码再次构建，我们就不需要重新下载包。
- en: 'So, we have our packages installed, but we don''t have any code in place. Let''s
    copy the contents of our local folders into the working directory:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们的包已经安装好了，但是我们还没有任何代码。让我们将本地文件夹的内容复制到工作目录中：
- en: '[PRE34]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We want to expose the server port to the outside world, so let''s add that
    layer now:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要将服务器端口暴露给外部世界，所以现在让我们添加这一层：
- en: '[PRE35]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Finally, we want to start the server. To do this, we want to trigger `npm start`:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们想要启动服务器。为了做到这一点，我们想要触发 `npm start`：
- en: '[PRE36]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: As an alternative to running `CMD["npm", "start"]`, we can bypass `npm` altogether
    and use `CMD ["node", "dist/server.js"]` (or whatever the server code is called).
    The reason we might want to consider doing this is that running `npm` starts the
    `npm` process, which then starts our server process, so using Node directly reduces
    the number of services that are running. Also, `npm` has a habit of silently consuming
    process exit signals, so Node has no idea that the process has exited unless `npm`
    tells it.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 作为运行 `CMD["npm", "start"]` 的替代方案，我们可以完全绕过 `npm`，使用 `CMD ["node", "dist/server.js"]`（或者服务器代码叫什么）。我们考虑这样做的原因是，运行
    `npm` 会启动 `npm` 进程，然后启动我们的服务器进程，所以直接使用 Node 减少了运行的服务数量。此外，`npm` 有一个擅自消耗进程退出信号的习惯，所以除非
    `npm` 告诉它，Node 不知道进程已经退出。
- en: 'Now, if we want to start the address service, for instance, we run the following
    commands from the command line:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们想要启动地址服务，例如，我们可以从命令行运行以下命令：
- en: '[PRE37]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The first line builds the container image using `Dockerfile` and gives it a
    tag so that we can identify it in the Docker containers.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行使用 `Dockerfile` 构建容器镜像，并给它一个标签，这样我们就可以在 Docker 容器中识别它。
- en: Once the image has been built, the next command runs the installation and publishes
    the container port to the host. This trick is the *magic* that makes our server
    code work—it exposes the internal port `3000` to the outside world as `17171`.
    Note that we are using `ohanlon/addresses` in both cases to tie the container
    image to the one that we are going to run (you can replace this name with whatever
    you want).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦镜像构建完成，下一个命令运行安装并将容器端口发布到主机。这个技巧是使我们的服务器代码工作的 *魔法*，它将内部端口 `3000` 暴露给外部世界作为
    `17171`。请注意，我们在这两种情况下都使用 `ohanlon/addresses` 来将容器镜像与我们要运行的镜像绑定（你可以用任何你想要的名称替换这个名称）。
- en: The `-d` flag stands for detach, which means that our container runs silently
    in the background. This allows us to start the service and avoid tying up the
    command line.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`-d` 标志代表分离，这意味着我们的容器在后台静默运行。这允许我们启动服务并避免占用命令行。'
- en: If you want to find what images you have available, you can run the `docker
    ps` command.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想找到可用的镜像，可以运行 `docker ps` 命令。
- en: Using docker-compose to compose and start the services
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 docker-compose 来组合和启动服务
- en: Rather than running up our images using `docker build` and `docker run`, we
    have something called `docker-compose` to compose and run multiple containers.
    With Docker composition, we can create our containers from multiple docker files
    or entirely through a file called `docker-compose.yml`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不再使用 `docker build` 和 `docker run` 来运行我们的镜像，而是有一个叫做 `docker-compose` 的东西来组合和运行多个容器。使用
    Docker 组合，我们可以从多个 docker 文件或者完全通过一个名为 `docker-compose.yml` 的文件创建我们的容器。
- en: 'We are going to use a combination of `docker-compose.yml` and the Docker files
    that we created in the previous section to create a composition that we can easily
    run up. In the root of the server code, create a blank file called `docker-compose.yml`.
    We are going to start off by specifying the compose format that the file conforms
    to. In our case, we are going to set it to `2.1`:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `docker-compose.yml` 和我们在上一节中创建的 Docker 文件的组合来创建一个可以轻松运行的组合。在服务器代码的根目录中，创建一个名为
    `docker-compose.yml` 的空文件。我们将首先指定文件符合的组合格式。在我们的情况下，我们将把它设置为 `2.1`：
- en: '[PRE38]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We are going to create three services inside our containers, so let''s start
    by defining the services themselves:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在容器内创建三个服务，所以让我们首先定义这些服务本身：
- en: '[PRE39]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now, each service is made up of discrete information, the first part of which
    details the build information that we want to use. This information comes under
    a build node and consists of the context, which maps to the directory our service
    lives under, and the Docker file, which defines how we build up the container.
    Optionally, we can set the `NODE_ENV` parameter to identify the node environment,
    which we are going to set to `production`. The last piece of our puzzle maps back
    to the `docker run` command where we set the port mapping; each service can set
    its own `ports` mapping. This is what the node looks like that goes under `chapter08_addresses`:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'When we put this all together, our `docker-compose.yml` file looks like this:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Before we can start the processes, we must compile our microservices. Docker
    is not responsible for building the application, so it is our responsibility to
    do this before we attempt to compose our service.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: 'We now have multiple containers that can be started together using one compose
    file. In order to run our compose file, we use the `docker-compose up` command.
    When all of the containers have started, we can verify their status using the
    `docker ps` command, which gives us the following output:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/6f71c67e-1999-4a26-8426-59829276ce7f.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
- en: We have now finished with the server-side code. We have everything in place
    that we need to create our microservices. What we want to do now is move on to
    creating the user interface that is going to interact with our services.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: Creating our React user interface
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve spent a lot of time building Angular applications, so it''s only fair
    that we return to building a React one. In just the same way that Angular can
    work with Express and Node, React can also work with them and, since we have the
    Express/Node side already in place, we are now going to create our React client.
    We will start off with the command to create our React application with TypeScript
    support:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This creates a standard React application, which we will modify to suit our
    needs. The first thing that we need to do is bring in support for Bootstrap, this
    time using the `react-bootstrap` package. While we are at it, we might as well
    install the following dependencies as well—`react-table`, `@types/react-table`,
    `react-router-dom`, `@types/react-router-dom`, and `axios`. We will be using these
    throughout this chapter, so installing them now will save a bit of time later
    on.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this book, we have been using `npm` to install dependencies, but
    this isn't the only option available to us. `npm` has the advantage of being the
    default package manager for Node (it is called Node Package Manager, after all),
    but Facebook introduced its own package manager back in 2015, called Yarn. Yarn
    was created to address issues in the version of `npm` that existed at the time.
    Yarn uses its own set of lock files, instead of the default `package*.lock` that
    `npm` uses. Which one you use really depends on your personal preferences and
    evaluating whether the features they provide are something you need. For our purposes,
    `npm` is a suitable package manager, so that's what we will continue to use.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: Using Bootstrap as our container
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We want to use Bootstrap to render the entirety of our display. Fortunately,
    this is a trivial task and revolves around a minor modification being made to
    our `App` component. In order to render out our display, we will wrap our content
    inside a container, like this:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Now, when we render our content, it will automatically be rendered inside a
    container that stretches to the full width of the page.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Creating a tabbed user interface
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we add in our navigation elements, we are going to create the components
    that we will link to when the user clicks on one of the links. We will start with
    `AddAddress.tsx`, which we will add code into to add an address. We start off
    by adding the class definition:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The default state for our component is an empty `IAddress`, so we add the definition
    for it, and set the component state to our default:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Before we add our code to render out our form, we need to add in a couple of
    methods. As you may remember from our last look at React, we learned that we have
    to explicitly update the state if the user changes anything in the display. Just
    like we did last time, we are going to write an `UpdateBinding` event handler,
    which we will call when the user changes any value on the display. We will see
    this pattern repeated throughout all of our `Add*xxx*` components. As a refresher,
    the ID tells us what field is being updated by the user, which we then use to
    set the appropriate field in the state with the update value. Given this information,
    our `event` handler looks like this:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The other supporting method we need to add in triggers the REST call to our
    address service. We are going to use the Axios package to transmit a `POST` request
    to the add address endpoint. Axios gives us promise-based REST calls so that we
    can, for example, issue the call and wait for it to come back before we continue
    processing. We are going to opt for a simple code model here and send our request
    over in a fire-and-forget fashion so we don't have to wait for any results to
    come back. For the sake of simplicity, we are going to immediately reset the state
    of the UI, ready for the user to add another address.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have added these methods in, we are going to code up our `render`
    method. The definition looks like this:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The `Container` element maps back to the good old container class we are used
    to from Bootstrap. What is missing from this is the actual input elements. Each
    piece of input is grouped inside `Form.Group` so that we can add `Label` and `Control`,
    like this:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: As another reminder, the current value of the binding is rendered to our display
    inside the one-way binding, represented by `value={this.state.Line1}`, and any
    input from the user triggers an update to the state through the `UpdateBinding`
    event handler.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Button` code that we add to save our state looks like this:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Putting it all together, this is what our `render` method looks like:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: So, is everything good with this code? Well, no, there is one small problem
    with the `Save` code. If the user clicked the button, nothing would be saved to
    the database because the state is not visible in the `Save` method. When we do
    `onClick={this.Save}`, we are assigning a callback to the `Save` method. What
    happens internally is that the `this` context is lost, so we cannot use it to
    get the state. Now, we have two fixes for this; one we have seen a lot of already,
    which is to use the fat arrow `=>` to capture the context so that our method can
    cope with it.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: 'The other way to solve this problem (and the reason we have deliberately coded
    the `Save` method to not use the fat arrow, so we can see this method in operation)
    is to add the following code to the constructor to bind the context in:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Well, that's our code in place to add an address in. I hope you will agree that
    it's a simple enough piece of code; time and again, people create unnecessarily
    complicated code where, in general, simplicity is a much more attractive option.
    I am a great fan of making code as simple as possible. There is a habit in the
    industry of trying to make code more complicated than it needs to be, simply to
    impress other developers. I urge people to avoid that temptation as clean code
    is much more impressive.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: The user interface we use for managing our addresses is tabbed, so we have one
    tab responsible for adding the address, while the other tab displays a grid containing
    all of the addresses we have currently added in. It's now time for us to add the
    tab and grid code. We are going to create a new component called `addresses.tsx`,
    which does this for us.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, we start off by creating our class. This time, we are going to set the
    `state` to an empty array. We do this because we are going to populate it later
    on from our address microservice:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'In order to load the data from our microservice, we need a method to handle
    this for us. We are going to make use of Axios again, but this time we are going
    to use the promise features to set the state when it is returned from the server:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The question now, is when do we want to call the `Load` method? We don''t want
    to try to get the state during the constructor as that will slow down the construction
    of the component, so we need another point to retrieve this data. The answer to
    this lies in the React component life cycle. Components go through several methods
    when they are being created. The order that they go through is as follows:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '`constructor();`'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`getDerivedStateFromProps();`'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`render();`'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`componentDidMount();`'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The effect we are going to go for is to display the component using `render`,
    then use binding to update the values to display in the table. That tells us that
    we want to load our state inside `componentDidMount`:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We do have another potential point to trigger the update. If the user adds
    an address and then switches the tab back to the one displaying the table, we''ll
    want to automatically retrieve the updated list of addresses. Let''s add a method
    to cope with this:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: It's time for us to add our `render` method. To keep things simple, we are going
    to add this in two stages; the first is to add the `Tab` and `AddAddress` components.
    In the second stage, we'll add the `Table`.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding the tab requires us to bring in the *Reactified* Bootstrap tab component.
    Inside our `render` method, add the following code:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: We have a `Tabs` component, which contains two individual `Tab` items. Each
    tab is given an `eventKey`, which we can use to set the default active key (in
    this case, we set it to `show`). When a tab is selected, we trigger the loading
    of the data. We will see that our `AddAddress` component has been added in the
    `Add Address` tab.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: 'All that we have left to do here is add the table that we are going to use
    to display the list of addresses. We are going to create a list of columns that
    we want to display in our table. We use the following syntax to create the columns
    list, where `Header` is the title that will be displayed at the top of the column. `accessor`
    tells React what property to pick off the data row:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Finally, we need to add the table in our `Addresses` tab. We are going to use
    the popular `ReactTable` component to display the table. Put the following code
    inside the `<Row></Row>` section to add it:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: There are a number of interesting parameters in here. We bind `data` to `this.state.data`
    to automatically update it when the state changes. The columns that we created
    are bound to the `columns` attribute. I like the fact that we can control how
    many rows a person sees per page using `defaultPageSize`, and the fact that we
    can let the user choose to override the number of rows using `pageSizeOptions`.
    We set `className` to `-striped -highlight` so that the display is striped between
    gray and white, with row highlighting used to show which row the mouse is over
    when the mouse moves over the table.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: Using a select control to select an address when adding a person
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When the user wants to add a person, they only need to type in their first and
    last name. We display a selection box to the user, which is populated with the
    list of previously entered addresses. Let's see how we handle a more complicated
    scenario like this with React.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we need to do is create two separate components. We have an
    `AddPerson` component to type the first name and last name in, and we have an
    `AddressChoice` component, which retrieves and displays the complete list of addresses
    for the user to select from. We will start with the `AddressChoice` component.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: 'This component uses a custom `IAddressProperty`, which provides us with access
    back to the parent component so that we can trigger the update to the currently
    selected address when this component changes value:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'We have told React that our component accepts `IAddressProperty` as the props
    to our component and has `Map<string, string>` as the state. When we retrieve
    the list of addresses from the server, we populate this map with the addresses;
    the key is used to hold `ServerID`, and the value holds a formatted version of
    the address. As the logic behind this looks a little bit complicated, we will
    start with the method to load the addresses, and then we will go back to the constructor:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: We start off by issuing a call to the server to get the complete list of addresses.
    When we get the list back, we are going to iterate over the addresses to build
    up the formatted map that we just discussed. We fill the state with the formatted
    map and copy the unformatted address into a separate addresses field; the reason
    we do this is that while we want to display the formatted version to the display,
    we want to send the unformatted version back to the caller when the selection
    changes. There are other ways that we could have achieved this, but this is a
    useful little hack that keeps things simple.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: 'With the load functionality in place, we can now add our constructor and fields:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Note that we have a changed binding in here, in keeping with the `bind` code
    we discussed in the previous section. Loading the data happens, again, in `componentDidMount`:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'We are ready to build our render method now. To simplify the visualization
    of what goes on inside the building up of the entries that make up the selection
    items, we separate that code out into a separate method. This simply iterates
    over the list of `this.options` to create options to be added to the `select`
    control:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Our render method uses a select `Form.Control`, which displays `Select...`
    as the first option and then renders out the list from `RenderList`:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Eagle-eyed readers will notice that we have referenced a `Changed` method twice
    now, without actually adding it. This method takes the selection value and uses
    it to look up the unformatted address and, if it finds it, uses the `props` to
    trigger the `CurrentSelection` method:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'In our `AddPerson` code, `AddressesChoice` is referenced in the render like
    this:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: We aren't going to cover the rest of the content inside `AddPerson`. I would
    suggest following the downloaded code to see this in place. We also aren't going
    to cover the other components; this chapter could turn into a hundred-page monster
    if we were to continue dissecting the other components, especially since they
    largely follow the same formats as the controls we have just covered.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: Adding our navigation
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The last bit of code we want to add to our client code base is the ability
    to handle client-side navigation. We saw how to do this when we covered Angular,
    so it''s time for us to see how to display different pages based on the link the
    user selects. We are going to use a combination of Bootstrap navigation and React
    route manipulation. We start off by creating a router that contains our navigation:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'We have left a home page in place so that we can add appropriate documentation
    and images if we wanted to *jazz* it up to make it look like a commercial CRM
    system. The other `href` elements will tie back to the router to show the appropriate
    React components. Inside the `Router`, we add `Route` entries that map the `path`
    to the `component` so that, if the user selects `Addresses`, for instance, the
    `Addresses` component will be shown:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Our `routing` code now looks like this:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'In order to add our navigation, complete with routing, we do the following:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: That's it. We now have a client application that can talk to our microservices
    and orchestrate their results together so that they work together, even though
    their implementations are independent of each other.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, we have created a series of microservices. We started off by
    defining a series of shared functionality, which we used as a basis for creating
    specialist services. These services all used the same port in Node.js, which would
    have presented us with a problem, but we solved this problem by creating a series
    of Docker containers to start up our services and redirected the internal ports
    to different external ports. We saw how to create the relevant Docker files and
    Docker compose files to start up the services.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: Then, we created a React-based client application that used a more advanced
    layout by introducing tabs to separate viewing results from the microservices
    from the ability to add records to the services. Along the way, we also used Axios
    to manage our REST calls.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: When it came to REST calls, we saw how we could use Swagger to define our REST
    API and talked about whether or not to use the API code that Swagger provided
    inside our services.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to move away from React and look at how to
    create a Vue client that works with TensorFlow to automatically perform image
    classification.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is a Docker container?
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What do we use to group Docker containers together to start them up, and what
    commands can we use to start them?
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do we map an internal port to a different external port with Docker?
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What features does Swagger provide for us?
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What do we need to do if a method can't see state in React?
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you want to know more about Docker, *Docker Quick Start Guide* by Earl Waud
    ([https://www.packtpub.com/in/networking-and-servers/docker-quick-start-guide](https://www.packtpub.com/in/networking-and-servers/docker-quick-start-guide))
    is a good place to start.
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are running Docker on Windows, *Docker on Windows - Second Edition* ([https://www.packtpub.com/virtualization-and-cloud/docker-windows-second-edition](https://www.packtpub.com/virtualization-and-cloud/docker-windows-second-edition))
    by Elton Stoneman is a great help.
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At this stage, I would hope that your appetite for microservices has been well
    and truly whetted. If that's the case, *Microservices Development Cookbook* by
    Paul Osman ([https://www.packtpub.com/in/application-development/microservices-development-cookbook](https://www.packtpub.com/in/application-development/microservices-development-cookbook))
    should be just what you need to carry on.
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
