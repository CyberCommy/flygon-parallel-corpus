- en: Building a CRM Using React and Microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In previous chapters where we used REST services, we concentrated on having
    a single site for dealing with REST calls. Modern applications frequently make
    use of microservices, potentially hosted inside a container-based system such
    as Docker.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we are going to look at how to create a set of microservices
    hosted in multiple Docker containers using Swagger to design our REST API. Our
    React client application will be responsible for drawing these microservices together
    to create a simple **Customer Relationship Management** (**CRM**) system.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Docker and containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What microservices are and what they are used for
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decomposing monolithic architectures down into microarchitectures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sharing common server-side functionality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Swagger to design APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hosting microservices in Docker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using React to connect to microservices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using routing in React
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The finished project can be downloaded from [https://github.com/PacktPublishing/Advanced-TypeScript-3-Programming-Projects/tree/master/Chapter08](https://github.com/PacktPublishing/Advanced-TypeScript-3-Programming-Projects/tree/master/Chapter08).
  prefs: []
  type: TYPE_NORMAL
- en: After downloading the project, you will have to install the package requirements
    using the **`npm install`** command. Since the services are spread over a number
    of folders, you will have to install each service individually.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Docker and microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since we are building a system that uses microservices hosted inside Docker
    containers, there is a bit of terminology and theory that we need to understand
    beforehand.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we are going to look at common Docker terms and what they mean
    before we move on to looking at what microservices are, what problems they are
    intended to solve, and how to think about breaking monolithic applications down
    into more modular services.
  prefs: []
  type: TYPE_NORMAL
- en: Docker terminology
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are new to Docker, there is a whole slew of terminology surrounding it
    that you will come across. Knowing the terminology will help when we come to set
    up our servers, so let's start with the basics.
  prefs: []
  type: TYPE_NORMAL
- en: Container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is probably a term you have come across if you have seen any Docker literature
    on the internet. A container is a running instance taking in the various pieces
    of software needed to run an application. This is the starting point for us. Containers
    are built from images, which you can either build yourself or download from a
    central Docker database. Containers can be opened up to other containers, the
    host operating system, or even to the wider world using ports and volumes. One
    of the big selling points of containers is that they are easy to set up and create
    and can be stopped and started very quickly.
  prefs: []
  type: TYPE_NORMAL
- en: Image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we covered in the previous paragraph, a container starts off as an image.
    There are a huge number of images already available for use, but we can also create
    our own images. When we create an image, the creation steps are cached so that
    they can be reused easily.
  prefs: []
  type: TYPE_NORMAL
- en: Port
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This should be familiar to you already. The term ports in Docker means exactly
    the same as ports does for OSes. These are TCP or UDP ports that are visible to
    the host operating system, or that are connected to the outer world. We will get
    to some interesting code later on in this chapter when we have applications use
    the same port number internally but expose them to the world using different port
    numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Volume
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The easiest way to visualize a volume is that it is similar to a shared folder.
    When a container is created, volumes are initialized and allow us to persist data,
    regardless of the container life cycle.
  prefs: []
  type: TYPE_NORMAL
- en: Registry
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Effectively, a registry could be viewed as the App Store of the Docker world.
    It stores Docker images that can be downloaded, and local images can be pushed
    back to the registry in a similar fashion to pushing an app up to the App Store.
  prefs: []
  type: TYPE_NORMAL
- en: Docker Hub
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker Hub is the original Docker registry, provided by Docker themselves. This
    registry stores a vast number of Docker images, some of which come from Docker
    and some of which have been built for them by software teams.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we aren't going to cover installing Docker, as installing it
    and setting it up is a chapter in its own right, especially since installing Docker
    on Windows is a different experience to installing Docker on macOS or Linux. The
    commands that we will use to compose Docker applications and check the state of
    instances don't change though, so we will cover them as and when they are needed.
  prefs: []
  type: TYPE_NORMAL
- en: Microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's hard to be involved in the corporate software world and not hear the term
    microservices. This is a style of architecture that breaks a so-called monolithic
    system down into a collection of services. The nature of this architecture is
    that services are tightly scoped and testable. Services should be loosely coupled
    so that dependencies between them are limited—it should be up to the end application
    to bring these services together. This loose coupling promotes the idea that they
    can be deployed independently and that services are generally tightly focused
    on business capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Despite what we may hear from marketing gurus and consultancies looking to sell
    services, microservices are not always a suitable choice for an application. Sometimes,
    it is better to stay with a monolithic application. If we can't break the application
    down using all the ideas outlined in the preceding paragraph then, chances are,
    the application is not a suitable candidate for microservices.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike a lot of what we have covered in this book so far, such as patterns,
    microservices don''t have an officially approved definition. You can''t follow
    a checklist and say, *this is a microservice because it is doing a, b, and c*.
    Instead, the agreed view on what constitutes a microservice has evolved, based
    on seeing what works and what doesn''t, into a series of characteristics. For
    our purposes, the important attributes of what constitutes a microservice include
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The service can be deployed independently of other microservices. In other words,
    the service has no dependency on other microservices.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The service is based on a business process. Microservices are meant to be granular,
    so having them organized around single business areas helps create large-scale
    applications out of small, focused components.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The languages and technologies can be different across the services. This gives
    us the opportunity to leverage the best and most appropriate technologies where
    necessary. For instance, we might have one service hosted in-house while another
    service might be hosted in a cloud service such as Azure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The service should be small in size. That doesn't mean that it should not have
    much code to it; rather, it means that it is focused on one area only.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing our REST API using Swagger
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When developing REST-driven applications, I find it really useful to use the
    facilities of Swagger ([https://swagger.io](https://swagger.io)). Swagger has
    many features that make it the go-to tool when we want to do things such as creating
    API documentation, creating code for APIs, and testing APIs.
  prefs: []
  type: TYPE_NORMAL
- en: We're going to use the Swagger UI to prototype the ability to retrieve a list
    of people. From this, we can generate documentation to go along with our API.
    While we could generate the code from this, we are going to use the tooling that's
    available to see what the *shape* of our final REST call will be, which we will
    use to roll our own implementation using the data model we created previously.
    The reason I like to do this is twofold. First, I like to craft small, clean data
    models, and I find the prototype gives me a visualization of the model. Secondly,
    there's a lot of generated code—an awful lot—and I find it easier to tie my data
    model to the database when I craft the code myself.
  prefs: []
  type: TYPE_NORMAL
- en: For this chapter, we are going to write the code ourselves, but we will use
    Swagger to prototype what we want to deliver.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we need to do is sign into Swagger:'
  prefs: []
  type: TYPE_NORMAL
- en: 'From the home page, click Sign In. This brings up a dialog that asks which
    product we want to log into, that is, SwaggerHub or Swagger Inspector. Swagger
    Inspector is a great tool for testing our APIs, but since we are going to be developing
    the API, we will sign into SwaggerHub. The following screenshot shows how it looks:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/eed2dbdb-d965-4190-9be0-ddbf0bf2eae0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you don''t have a Swagger account, you can create one from here either by
    signing up or by using a GitHub account. In order to create an API, we need to
    select Create New > Create New API. Choose None in the Template dropdown and fill
    it in, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/408868db-6a1b-44f9-8a05-748d562714f3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'At this stage, we are ready to start filling in our API. What we are given
    out of the box is the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s start building this API out. First of all, we are going to create the
    start of our API paths. Any paths we need to create go under a `paths` node. The
    Swagger editor validates inputs as we are building the API, so don''t worry if
    it comes up with validation errors as we are filling it in. In our example here,
    we are going to create the API to retrieve an array of all the people we have
    added to our database. Therefore, we start off with this, our API endpoint, which
    replaces the `paths: {}` line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'So, we have said that our REST call will be issued using a `GET` verb. Our
    API is going to return two statuses, `HTTP 200` and `HTTP 400`. Let''s provide
    the beginnings of this by populating a `responses` node with these statuses. When
    we return a `400` error, we need to create the schema that defines what we will
    return over the wire. The `schema` returns an `object` that contains a single `message` string,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Since our API is going to return an array of people, our schema is typed to
    an `array`. The `items` that make up the person map back to the model we discussed
    in the server code. So, by filling in our `schema` for the `200` response, we
    get this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This is what our `schema` looks like in the editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/29dbb934-da56-4d77-b897-bef2ab2516ad.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that we have seen how Swagger can be used to prototype our APIs, we can
    move onto the definition of the project that we want to build.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a microservices application with Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The project we are going to write is a small part of a CRM system to maintain
    details about customers and add leads for those customers. The way the application
    works is that the user creates addresses; when they add in details about contacts,
    they will select the address from the list of addresses they have already created.
    Finally, they can create leads that use the contacts they have already added.
    The idea behind this system is that, previously, the application used one big
    database for this information—we are going to break this down into three discrete
    services.
  prefs: []
  type: TYPE_NORMAL
- en: 'Working alongside the GitHub code, this chapter should take about three hours
    to complete. When completed, the application should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/5b119141-e7c1-42f6-8830-50256b3fad64.png)'
  prefs: []
  type: TYPE_IMG
- en: After doing this, we'll move on and see how to create apps for Docker and how
    this complements our project.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started creating a microservices application with Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are making a welcome return to React in this chapter. As well as using React,
    we will also be using Firebase and Docker, hosting Express and Node. REST communications
    between our React application and the Express microservices will be done with
    Axios.
  prefs: []
  type: TYPE_NORMAL
- en: If you are using Windows 10 for your development, install Docker Desktop for
    Windows, which is available here: [https://hub.docker.com/editions/community/docker-ce-desktop-windows](https://hub.docker.com/editions/community/docker-ce-desktop-windows).
  prefs: []
  type: TYPE_NORMAL
- en: In order to run Docker on Windows, you need to have Hyper-V virtualization installed.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to install Docker Desktop on macOS, head to [https://hub.docker.com/editions/community/docker-ce-desktop-mac](https://hub.docker.com/editions/community/docker-ce-desktop-mac).
  prefs: []
  type: TYPE_NORMAL
- en: Docker Desktop on Mac runs on OS X Sierra 10.12 and newer macOS releases.
  prefs: []
  type: TYPE_NORMAL
- en: The CRM application that we are going to build demonstrates how we can take
    a number of microservices and bring them together into one cohesive application
    where the end user is unaware that our application is working with information
    from a wide number of data sources.
  prefs: []
  type: TYPE_NORMAL
- en: 'The requirements of our application are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The CRM system will provide the ability to enter addresses.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The system will let the user enter details about a person.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When details are entered about a person, the user can choose a previously entered
    address.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The system will let the user enter details about potential leads.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data will be saved to a cloud database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The people, leads, and address information will be retrieved from separate services.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These separate services will be hosted by Docker.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our user interface will be created as a React system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have been steadily working toward being able to share functionality in our
    application. Our microservices are going to take this approach to the next level
    by sharing as much common code as possible and then just adding in the little
    bits and pieces that they need to customize the data they fetch and return to
    the client. We can do this because our services are similar in their requirements,
    so they can share a lot of common code.
  prefs: []
  type: TYPE_NORMAL
- en: Our microservice application starts off from the point of view of a monolithic
    application. That application has the people, addresses, and leads all managed
    by one system. We are going to treat this monolithic application with the contempt
    it deserves and break it down into smaller, discrete chunks, where each constituent
    part exists in isolation from other parts. Here, the leads, addresses, and people
    all exist in their own self-contained services.
  prefs: []
  type: TYPE_NORMAL
- en: 'The place that we are going to start is with our `tsconfig` file. In previous
    chapters, we had one service per chapter, with a single `tsconfig` file. We are
    going to mix things up here by having a root level `tsconfig.json` file. Our services
    will all use that as a common base:'
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by creating a folder called `Services`, which will serve as the
    base for our services. Under this, we are going to create separate `Addresses`,
    `Common`, `Leads`, and `People` folders, as well as our base `tsconfig` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When we have finished this step, our `Services` folder should look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/7a971ac6-66c1-4955-8cc0-b99205dc692a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s add the `tsconfig` settings. These settings are going to be shared
    by all of the services we are going to host:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: You might have noticed that we haven't set up our output directory here. We're
    going to leave that to slightly later on. Before we get to that step, we are going
    to start adding in the common functionality that will be shared by our microservices.
    Our shared functionality is going to be added in the `Common` folder. Some of
    what we are going to add should look very familiar because we built similar server
    code in earlier chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Our services are going to save to Firebase, so we are going to start off by
    writing our database code. The `npm` packages that we need to install to work
    with Firebase are `firebase` and `@types/firebase`. While we are adding these,
    we should also import `guid-typescript` and the basic node `cors` and `express`
    packages that we installed previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'When each service saves data to the database, it will start with the same basic
    structure. We will have a `ServerID` that we are going to set ourselves using
    a GUID. The basic model that we are going to use starts off like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We are going to create an `abstract` base class that will work with instances
    of `IDatabaseModelBase`, giving us the ability to `Get` a record, `GetAll` the
    records, and `Save` a record. The beauty of working with Firebase is that, while
    it is a powerful system, the code that we have to write to accomplish each of
    these tasks is very short. Let''s start off with the class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, our class is generic, which tells us that each service will
    extend `IDatabaseModelBase` and use that in its specific database implementation.
    The collection is the name of the collection that will be written in Firebase.
    For our purposes, we are going to share one Firebase instance to store the different
    collections, but the beauty of our architecture is that we don't need to if we
    don't want to. We can use separate Firebase stores if we need to; in fact, this
    is generally what would happen in a production environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s pointless us adding our `GET` methods if we don''t have any data saved,
    so the first thing we are going to do is write our `Save` method. Unsurprisingly,
    our `Save` method is going to be asynchronous, so it will return a `Promise`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Something that might look strange is the `async (coll)` code. Since we are using
    the fat arrow (`=>`), we are creating a simplified function. Since this is a function,
    we add the `async` keyword to it to indicate that the code can have an `await`
    inside it. If we didn't mark this as `async`, then we would not be able to use
    the `await` inside.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our code allocates a GUID to the `ServerID` before we call a chain of methods
    to set the data. Let''s tackle the code in small chunks to see what each bit does.
    As we discussed in [Chapter 7](e8c1594d-72de-47a5-bc5c-29af9b8e84fb.xhtml), *Angular
    Cloud-Based Mapping with Firebase*, Firebase offers more than just database services,
    so the first thing we need to do is access the database part. If we weren''t following
    method chaining here, we could write this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In Firestore, we don''t save data in tables, we save it in named collections.
    Once we have `firestore`, we get `CollectionReference`. Following on from the
    preceding code snippet, we could rewrite this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have `CollectionReference`, we can get access to individual documents
    using the `ServerID` we set up earlier in the method. If we don''t supply our
    own ID, one will be created for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to set the data that we want to write to the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This will save the data to a document in the appropriate collection in Firestore.
    I have to admit that, while I like the ability to type in code that can be broken
    down like this, method chaining means that I rarely do so if it's available. Where
    the next step in the chain logically follows on from the previous step, I will
    often chain the methods together because you cannot get to the next step without
    going through the previous steps, and it makes it easy for me to visualize the
    sequence of steps if I see them linked together.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the item is saved to the database, we are going to return the saved item,
    complete with `ServerID`, back to the calling code so that it can be used immediately.
    That''s where this line comes in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step in our `FirestoreService` is to add the `GET` method. This method,
    like the `Save` method, is an `async` method that returns a single instance of
    type `T`, wrapped inside a promise. Since we know the ID, the vast majority of
    our Firestore code is the same. The difference here is that we call `get()`, which
    we then use to return the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Guess what? We also have an `async GetAll` method to write, this time returning
    an array of `T`. Since we want to retrieve multiple records, rather than just
    a single doc, we call `get()` on our `collection` instead. Once we have the records,
    we use a simple `forEach` to build up the array we need to return:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'With our database code in place, let''s see what this looks like in practice.
    We''re going to start off in the `Addresses` service by creating an `IAddress`
    interface that extends `IDatabaseModelBase`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'With `IAddress` in place, we can now create the class that ties our service
    to the `addresses` collection that we are going to store in Firebase. With all
    the hard work that we have put in, our `AddressesService` is as simple as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'You might wonder whether the code for the data models and database access are
    as easy with the other microservices. Let''s see what our `People` interface and
    database service looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: You might also be wondering why we store the address information inside `IPerson`.
    It's tempting to think that we should start a reference to the address only and
    not duplicate data, especially if you are coming to the NoSQL architecture from
    the viewpoint of relational databases where records are linked together through
    foreign keys to create `pointers` to relationships. *Old-fashioned* SQL databases
    use foreign tables to minimize the redundancies in records so we don't end up
    creating duplicate data that's shared across multiple records. While that's a
    useful thing to have available, it does make querying and retrieving records more
    complicated because the information that we are interested in could well be scattered
    over several tables. By storing the address alongside the person, we reduce the
    number of tables we have to query to build up the person's information. This is
    based on the idea that we want to query records far more often than we want to
    change them so, if we needed to change the address, we would change the master
    address and then a separate query would run through all of the people records
    looking for addresses that needed to be updated. We will be achieving this because
    the `ServerID` record in the address part of the person record will match the
    `ServerID` in the master address.
  prefs: []
  type: TYPE_NORMAL
- en: We won't cover the `Leads` database code; you can read it in the source, and
    it is virtually identical to this. What we did was work out that our microservices
    would be, functionally, very similar so that we can take advantage of inheritance
    in a simple way.
  prefs: []
  type: TYPE_NORMAL
- en: Adding server-side routing support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As well as having a common way of working with the database, our incoming API
    requests are all going to be very similar in terms of endpoints. While writing
    this book, I tried to put together snippets of code that could be reused later
    on. One such snippet is the way we handle Express routing. The server-side code
    we put together in [Chapter 4](23db6d37-1947-4f7b-9b25-3195c2df7274.xhtml), *The
    MEAN Stack – Building a Photo Gallery*, was one such area, specifically the code
    for routing. We can bring this code in pretty much exactly as we wrote it all
    those chapters ago.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a quick reminder of what the code looks like. First, we have our `IRouter`
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we have our routing engine—the code that we are going to plug directly
    into our server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'So, what does this look like in practice? Well, here''s the code to save an
    address that has been sent over from the client. When we receive an `/add/` request
    from the client, we extract the details from the body and cast it to an `IAddress`,
    which we then use to save to the addresses service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The code to get the address is very similar. We aren''t going to dissect this
    method because it should look very familiar by now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The code for the `Leads` and `People` services are virtually identical. Please
    read the code from our GitHub repository to get familiar with it.
  prefs: []
  type: TYPE_NORMAL
- en: The Server class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Again, continuing with the theme of reusing code as much as possible, we are
    going to use a slightly modified version of the Express `Server` class we wrote,
    way back in [Chapter 4](23db6d37-1947-4f7b-9b25-3195c2df7274.xhtml), *The MEAN
    Stack – Building a Photo Gallery*. Again, we will quickly go through the code
    to re-familiarize ourselves with it. First, let''s put the class definition and
    constructor in place. Our constructor is a slimmed-down version of the constructor
    from [Chapter 4](23db6d37-1947-4f7b-9b25-3195c2df7274.xhtml), *The MEAN Stack
    – Building a Photo Gallery*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We also want to add CORS support. While we could make this mandatory, I still
    like the idea that we can put control of whether we want to do this into the hands
    of the service developer, so we will keep this as a `public` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In order for our actual server implementations to work, we need to give them
    the ability to add routing. We do this through the `AddRouting` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our `AddRouting` method, we need code in place to start up
    our server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'What you may have noticed is that we are missing one important piece of the
    puzzle. We have no database support in place in our server, but our service needs
    to initialize Firebase. In our server, we add in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that I have not included `Environment.fireBase` in the repository because
    it contains details about servers and keys that I use. This is a constant that
    contains the Firebase connection information. You can replace this with the connection
    information you set up when you created your Firebase database in the cloud. To
    add this, you will need to create a file in the `Common` folder called `Environment.ts`
    which contains code that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Creating our Addresses service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We now have everything we need to create our actual services. Here, we will
    look at the `Addresses` service, understanding that the other services will follow
    the same pattern. Since we already have the data models, data access code, and
    routing in place, all we have to do is create our actual `AddressesServer` class.
    The `AddressesServer` class is as simple as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We start the server like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The code is as easy as that. We are following a principle called **Don't Repeat
    Yourself **(**DRY**)  as much as possible. This simply states that you should
    aim to retype as little code as possible. In other words, you should try to avoid
    having code that does exactly the same thing scattered about your code base. Sometimes,
    you can't avoid it and sometimes, it doesn't make sense to go to the trouble of
    creating a lot of code scaffolding for a one- or two-line piece of code, but when
    you have large functional areas, you should definitely try to avoid having to
    copy and paste it into multiple parts of your code. Part of the reason for this
    is if you have copied and pasted code and subsequently you find a bug in it, you
    are going to have to fix that bug in multiple places.
  prefs: []
  type: TYPE_NORMAL
- en: Using Docker to run our services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we look at our services, we can see that we have an interesting problem;
    namely that they all use the same port to start up on. Obviously, we can't actually
    use the same port for each service, so have we caused ourselves a problem? Does
    this mean that we cannot start more than one service and, if so, does this blow
    our microservice architecture apart and mean that we should go back to a monolithic
    service?
  prefs: []
  type: TYPE_NORMAL
- en: Given the potential problems we have just discussed and the fact that this chapter
    introduces Docker, it should come as no surprise to learn that Docker is the answer
    to this. With Docker, we can spin up a container, deploy our code to it, and expose
    the service with a different endpoint. So, how do we do this?
  prefs: []
  type: TYPE_NORMAL
- en: 'In each service, we are going to add a couple of common files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The first file, called `.dockerignore`, chooses which files to ignore when copying
    or adding files to the container.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next file we are going to add is called `Dockerfile`. This file describes
    the Docker container and how to build it up. `Dockerfile` works by building up
    layers of instructions that represent a step toward building up the container.
    The first layer downloads and installs Node in the container, specifically Node
    version 8:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The next layer is used to set the default working directory. This directory
    is used for subsequent commands, such as `RUN`, `COPY`, `ENTRYPOINT`, `CMD`, and
    `ADD`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In some online sources, you'll see that people create their own directories
    to use as the working directory. It's better to use a predefined, well-known location
    such as `/usr/src/app` as `WORKDIR`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we have a working directory in place right now, we can start to set up
    the code. We want to copy the necessary files to download and install our `npm`
    packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: As a good practice, we copy the `package.json` and `package-lock.json` files
    before copying the code because the install caches the contents of the installation.
    As long as we don't change the `package.json` file, if the code is built again,
    we won't need to re-download the packages.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we have our packages installed, but we don''t have any code in place. Let''s
    copy the contents of our local folders into the working directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We want to expose the server port to the outside world, so let''s add that
    layer now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we want to start the server. To do this, we want to trigger `npm start`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: As an alternative to running `CMD["npm", "start"]`, we can bypass `npm` altogether
    and use `CMD ["node", "dist/server.js"]` (or whatever the server code is called).
    The reason we might want to consider doing this is that running `npm` starts the
    `npm` process, which then starts our server process, so using Node directly reduces
    the number of services that are running. Also, `npm` has a habit of silently consuming
    process exit signals, so Node has no idea that the process has exited unless `npm`
    tells it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if we want to start the address service, for instance, we run the following
    commands from the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The first line builds the container image using `Dockerfile` and gives it a
    tag so that we can identify it in the Docker containers.
  prefs: []
  type: TYPE_NORMAL
- en: Once the image has been built, the next command runs the installation and publishes
    the container port to the host. This trick is the *magic* that makes our server
    code work—it exposes the internal port `3000` to the outside world as `17171`.
    Note that we are using `ohanlon/addresses` in both cases to tie the container
    image to the one that we are going to run (you can replace this name with whatever
    you want).
  prefs: []
  type: TYPE_NORMAL
- en: The `-d` flag stands for detach, which means that our container runs silently
    in the background. This allows us to start the service and avoid tying up the
    command line.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to find what images you have available, you can run the `docker
    ps` command.
  prefs: []
  type: TYPE_NORMAL
- en: Using docker-compose to compose and start the services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rather than running up our images using `docker build` and `docker run`, we
    have something called `docker-compose` to compose and run multiple containers.
    With Docker composition, we can create our containers from multiple docker files
    or entirely through a file called `docker-compose.yml`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to use a combination of `docker-compose.yml` and the Docker files
    that we created in the previous section to create a composition that we can easily
    run up. In the root of the server code, create a blank file called `docker-compose.yml`.
    We are going to start off by specifying the compose format that the file conforms
    to. In our case, we are going to set it to `2.1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We are going to create three services inside our containers, so let''s start
    by defining the services themselves:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, each service is made up of discrete information, the first part of which
    details the build information that we want to use. This information comes under
    a build node and consists of the context, which maps to the directory our service
    lives under, and the Docker file, which defines how we build up the container.
    Optionally, we can set the `NODE_ENV` parameter to identify the node environment,
    which we are going to set to `production`. The last piece of our puzzle maps back
    to the `docker run` command where we set the port mapping; each service can set
    its own `ports` mapping. This is what the node looks like that goes under `chapter08_addresses`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'When we put this all together, our `docker-compose.yml` file looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Before we can start the processes, we must compile our microservices. Docker
    is not responsible for building the application, so it is our responsibility to
    do this before we attempt to compose our service.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now have multiple containers that can be started together using one compose
    file. In order to run our compose file, we use the `docker-compose up` command.
    When all of the containers have started, we can verify their status using the
    `docker ps` command, which gives us the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/6f71c67e-1999-4a26-8426-59829276ce7f.png)'
  prefs: []
  type: TYPE_IMG
- en: We have now finished with the server-side code. We have everything in place
    that we need to create our microservices. What we want to do now is move on to
    creating the user interface that is going to interact with our services.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our React user interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve spent a lot of time building Angular applications, so it''s only fair
    that we return to building a React one. In just the same way that Angular can
    work with Express and Node, React can also work with them and, since we have the
    Express/Node side already in place, we are now going to create our React client.
    We will start off with the command to create our React application with TypeScript
    support:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: This creates a standard React application, which we will modify to suit our
    needs. The first thing that we need to do is bring in support for Bootstrap, this
    time using the `react-bootstrap` package. While we are at it, we might as well
    install the following dependencies as well—`react-table`, `@types/react-table`,
    `react-router-dom`, `@types/react-router-dom`, and `axios`. We will be using these
    throughout this chapter, so installing them now will save a bit of time later
    on.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this book, we have been using `npm` to install dependencies, but
    this isn't the only option available to us. `npm` has the advantage of being the
    default package manager for Node (it is called Node Package Manager, after all),
    but Facebook introduced its own package manager back in 2015, called Yarn. Yarn
    was created to address issues in the version of `npm` that existed at the time.
    Yarn uses its own set of lock files, instead of the default `package*.lock` that
    `npm` uses. Which one you use really depends on your personal preferences and
    evaluating whether the features they provide are something you need. For our purposes,
    `npm` is a suitable package manager, so that's what we will continue to use.
  prefs: []
  type: TYPE_NORMAL
- en: Using Bootstrap as our container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We want to use Bootstrap to render the entirety of our display. Fortunately,
    this is a trivial task and revolves around a minor modification being made to
    our `App` component. In order to render out our display, we will wrap our content
    inside a container, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Now, when we render our content, it will automatically be rendered inside a
    container that stretches to the full width of the page.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a tabbed user interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we add in our navigation elements, we are going to create the components
    that we will link to when the user clicks on one of the links. We will start with
    `AddAddress.tsx`, which we will add code into to add an address. We start off
    by adding the class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The default state for our component is an empty `IAddress`, so we add the definition
    for it, and set the component state to our default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we add our code to render out our form, we need to add in a couple of
    methods. As you may remember from our last look at React, we learned that we have
    to explicitly update the state if the user changes anything in the display. Just
    like we did last time, we are going to write an `UpdateBinding` event handler,
    which we will call when the user changes any value on the display. We will see
    this pattern repeated throughout all of our `Add*xxx*` components. As a refresher,
    the ID tells us what field is being updated by the user, which we then use to
    set the appropriate field in the state with the update value. Given this information,
    our `event` handler looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The other supporting method we need to add in triggers the REST call to our
    address service. We are going to use the Axios package to transmit a `POST` request
    to the add address endpoint. Axios gives us promise-based REST calls so that we
    can, for example, issue the call and wait for it to come back before we continue
    processing. We are going to opt for a simple code model here and send our request
    over in a fire-and-forget fashion so we don't have to wait for any results to
    come back. For the sake of simplicity, we are going to immediately reset the state
    of the UI, ready for the user to add another address.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have added these methods in, we are going to code up our `render`
    method. The definition looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Container` element maps back to the good old container class we are used
    to from Bootstrap. What is missing from this is the actual input elements. Each
    piece of input is grouped inside `Form.Group` so that we can add `Label` and `Control`,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: As another reminder, the current value of the binding is rendered to our display
    inside the one-way binding, represented by `value={this.state.Line1}`, and any
    input from the user triggers an update to the state through the `UpdateBinding`
    event handler.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Button` code that we add to save our state looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Putting it all together, this is what our `render` method looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: So, is everything good with this code? Well, no, there is one small problem
    with the `Save` code. If the user clicked the button, nothing would be saved to
    the database because the state is not visible in the `Save` method. When we do
    `onClick={this.Save}`, we are assigning a callback to the `Save` method. What
    happens internally is that the `this` context is lost, so we cannot use it to
    get the state. Now, we have two fixes for this; one we have seen a lot of already,
    which is to use the fat arrow `=>` to capture the context so that our method can
    cope with it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other way to solve this problem (and the reason we have deliberately coded
    the `Save` method to not use the fat arrow, so we can see this method in operation)
    is to add the following code to the constructor to bind the context in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Well, that's our code in place to add an address in. I hope you will agree that
    it's a simple enough piece of code; time and again, people create unnecessarily
    complicated code where, in general, simplicity is a much more attractive option.
    I am a great fan of making code as simple as possible. There is a habit in the
    industry of trying to make code more complicated than it needs to be, simply to
    impress other developers. I urge people to avoid that temptation as clean code
    is much more impressive.
  prefs: []
  type: TYPE_NORMAL
- en: The user interface we use for managing our addresses is tabbed, so we have one
    tab responsible for adding the address, while the other tab displays a grid containing
    all of the addresses we have currently added in. It's now time for us to add the
    tab and grid code. We are going to create a new component called `addresses.tsx`,
    which does this for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, we start off by creating our class. This time, we are going to set the
    `state` to an empty array. We do this because we are going to populate it later
    on from our address microservice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to load the data from our microservice, we need a method to handle
    this for us. We are going to make use of Axios again, but this time we are going
    to use the promise features to set the state when it is returned from the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The question now, is when do we want to call the `Load` method? We don''t want
    to try to get the state during the constructor as that will slow down the construction
    of the component, so we need another point to retrieve this data. The answer to
    this lies in the React component life cycle. Components go through several methods
    when they are being created. The order that they go through is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`constructor();`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`getDerivedStateFromProps();`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`render();`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`componentDidMount();`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The effect we are going to go for is to display the component using `render`,
    then use binding to update the values to display in the table. That tells us that
    we want to load our state inside `componentDidMount`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'We do have another potential point to trigger the update. If the user adds
    an address and then switches the tab back to the one displaying the table, we''ll
    want to automatically retrieve the updated list of addresses. Let''s add a method
    to cope with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: It's time for us to add our `render` method. To keep things simple, we are going
    to add this in two stages; the first is to add the `Tab` and `AddAddress` components.
    In the second stage, we'll add the `Table`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding the tab requires us to bring in the *Reactified* Bootstrap tab component.
    Inside our `render` method, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: We have a `Tabs` component, which contains two individual `Tab` items. Each
    tab is given an `eventKey`, which we can use to set the default active key (in
    this case, we set it to `show`). When a tab is selected, we trigger the loading
    of the data. We will see that our `AddAddress` component has been added in the
    `Add Address` tab.
  prefs: []
  type: TYPE_NORMAL
- en: 'All that we have left to do here is add the table that we are going to use
    to display the list of addresses. We are going to create a list of columns that
    we want to display in our table. We use the following syntax to create the columns
    list, where `Header` is the title that will be displayed at the top of the column. `accessor`
    tells React what property to pick off the data row:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to add the table in our `Addresses` tab. We are going to use
    the popular `ReactTable` component to display the table. Put the following code
    inside the `<Row></Row>` section to add it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: There are a number of interesting parameters in here. We bind `data` to `this.state.data`
    to automatically update it when the state changes. The columns that we created
    are bound to the `columns` attribute. I like the fact that we can control how
    many rows a person sees per page using `defaultPageSize`, and the fact that we
    can let the user choose to override the number of rows using `pageSizeOptions`.
    We set `className` to `-striped -highlight` so that the display is striped between
    gray and white, with row highlighting used to show which row the mouse is over
    when the mouse moves over the table.
  prefs: []
  type: TYPE_NORMAL
- en: Using a select control to select an address when adding a person
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When the user wants to add a person, they only need to type in their first and
    last name. We display a selection box to the user, which is populated with the
    list of previously entered addresses. Let's see how we handle a more complicated
    scenario like this with React.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we need to do is create two separate components. We have an
    `AddPerson` component to type the first name and last name in, and we have an
    `AddressChoice` component, which retrieves and displays the complete list of addresses
    for the user to select from. We will start with the `AddressChoice` component.
  prefs: []
  type: TYPE_NORMAL
- en: 'This component uses a custom `IAddressProperty`, which provides us with access
    back to the parent component so that we can trigger the update to the currently
    selected address when this component changes value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'We have told React that our component accepts `IAddressProperty` as the props
    to our component and has `Map<string, string>` as the state. When we retrieve
    the list of addresses from the server, we populate this map with the addresses;
    the key is used to hold `ServerID`, and the value holds a formatted version of
    the address. As the logic behind this looks a little bit complicated, we will
    start with the method to load the addresses, and then we will go back to the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: We start off by issuing a call to the server to get the complete list of addresses.
    When we get the list back, we are going to iterate over the addresses to build
    up the formatted map that we just discussed. We fill the state with the formatted
    map and copy the unformatted address into a separate addresses field; the reason
    we do this is that while we want to display the formatted version to the display,
    we want to send the unformatted version back to the caller when the selection
    changes. There are other ways that we could have achieved this, but this is a
    useful little hack that keeps things simple.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the load functionality in place, we can now add our constructor and fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we have a changed binding in here, in keeping with the `bind` code
    we discussed in the previous section. Loading the data happens, again, in `componentDidMount`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'We are ready to build our render method now. To simplify the visualization
    of what goes on inside the building up of the entries that make up the selection
    items, we separate that code out into a separate method. This simply iterates
    over the list of `this.options` to create options to be added to the `select`
    control:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Our render method uses a select `Form.Control`, which displays `Select...`
    as the first option and then renders out the list from `RenderList`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Eagle-eyed readers will notice that we have referenced a `Changed` method twice
    now, without actually adding it. This method takes the selection value and uses
    it to look up the unformatted address and, if it finds it, uses the `props` to
    trigger the `CurrentSelection` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'In our `AddPerson` code, `AddressesChoice` is referenced in the render like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: We aren't going to cover the rest of the content inside `AddPerson`. I would
    suggest following the downloaded code to see this in place. We also aren't going
    to cover the other components; this chapter could turn into a hundred-page monster
    if we were to continue dissecting the other components, especially since they
    largely follow the same formats as the controls we have just covered.
  prefs: []
  type: TYPE_NORMAL
- en: Adding our navigation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The last bit of code we want to add to our client code base is the ability
    to handle client-side navigation. We saw how to do this when we covered Angular,
    so it''s time for us to see how to display different pages based on the link the
    user selects. We are going to use a combination of Bootstrap navigation and React
    route manipulation. We start off by creating a router that contains our navigation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'We have left a home page in place so that we can add appropriate documentation
    and images if we wanted to *jazz* it up to make it look like a commercial CRM
    system. The other `href` elements will tie back to the router to show the appropriate
    React components. Inside the `Router`, we add `Route` entries that map the `path`
    to the `component` so that, if the user selects `Addresses`, for instance, the
    `Addresses` component will be shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `routing` code now looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to add our navigation, complete with routing, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: That's it. We now have a client application that can talk to our microservices
    and orchestrate their results together so that they work together, even though
    their implementations are independent of each other.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, we have created a series of microservices. We started off by
    defining a series of shared functionality, which we used as a basis for creating
    specialist services. These services all used the same port in Node.js, which would
    have presented us with a problem, but we solved this problem by creating a series
    of Docker containers to start up our services and redirected the internal ports
    to different external ports. We saw how to create the relevant Docker files and
    Docker compose files to start up the services.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we created a React-based client application that used a more advanced
    layout by introducing tabs to separate viewing results from the microservices
    from the ability to add records to the services. Along the way, we also used Axios
    to manage our REST calls.
  prefs: []
  type: TYPE_NORMAL
- en: When it came to REST calls, we saw how we could use Swagger to define our REST
    API and talked about whether or not to use the API code that Swagger provided
    inside our services.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to move away from React and look at how to
    create a Vue client that works with TensorFlow to automatically perform image
    classification.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is a Docker container?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What do we use to group Docker containers together to start them up, and what
    commands can we use to start them?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do we map an internal port to a different external port with Docker?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What features does Swagger provide for us?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What do we need to do if a method can't see state in React?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you want to know more about Docker, *Docker Quick Start Guide* by Earl Waud
    ([https://www.packtpub.com/in/networking-and-servers/docker-quick-start-guide](https://www.packtpub.com/in/networking-and-servers/docker-quick-start-guide))
    is a good place to start.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are running Docker on Windows, *Docker on Windows - Second Edition* ([https://www.packtpub.com/virtualization-and-cloud/docker-windows-second-edition](https://www.packtpub.com/virtualization-and-cloud/docker-windows-second-edition))
    by Elton Stoneman is a great help.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At this stage, I would hope that your appetite for microservices has been well
    and truly whetted. If that's the case, *Microservices Development Cookbook* by
    Paul Osman ([https://www.packtpub.com/in/application-development/microservices-development-cookbook](https://www.packtpub.com/in/application-development/microservices-development-cookbook))
    should be just what you need to carry on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
