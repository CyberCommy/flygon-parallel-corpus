- en: '*Chapter 24*: Design Patterns, Multiple Layouts, and Fragments'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have come a long way since the start when we were just setting up Android
    Studio. Back then, we went through everything step by step, but as we have proceeded
    we have tried to show not just how to add x to y or feature a to app b, but to
    enable you to use what you have learned in your own ways to bring your own ideas
    to life.
  prefs: []
  type: TYPE_NORMAL
- en: At first glance, this chapter might seem dry and technical, but this chapter
    is more about your future apps than anything in the book so far. We will look
    at a few aspects of Java and Android that you can use as a framework or template
    to make evermore exciting and complex apps at the same time as keeping the code
    manageable. This is the key to successful modern apps. Furthermore, I will suggest
    areas of further study that there is simply not enough room to even scratch the
    surface of in this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn about the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Patterns and model-view-controller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Android design guidelines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting started with real-world designs and handling multiple different devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An introduction to Fragments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find the code files present in this chapter on GitHub at [https://github.com/PacktPublishing/Android-Programming-for-Beginners-Third-Edition/tree/main/chapter%2024](https://github.com/PacktPublishing/Android-Programming-for-Beginners-Third-Edition/tree/main/chapter%2024).
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the model-view-controller pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The model-view-controller pattern involves the separation of different aspects
    of our app into distinct parts called layers. Android apps commonly use the model-view-controller
    pattern. A pattern is simply a recognized way to structure our code and other
    application resources such as layout files, images, databases, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Patterns are useful to us because by conforming to a pattern, we can be more
    confident we are doing things right and are less likely to have to undo lots of
    hard work because we have coded ourselves into an awkward situation.
  prefs: []
  type: TYPE_NORMAL
- en: There are many patterns in computer science but an understanding of **model-view-controller**
    (**MVC**) will be enough to create some professionally built Android apps.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have been partly using MVC already, so let''s look at each of the three
    layers in turn:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Note` class along with its getters, setters, and JSON code was the data and
    logic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`View` class hierarchy of the Android API.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Controller**: The controller is the bit in between the view and the model.
    It interacts with both and keeps them separate. It contains what is known in geek
    speak as the application logic. If a user taps a button, the application layer
    decides what to do about it. When the user clicks **OK** to add a new note, the
    application layer listens for the interaction on the view layer. It captures the
    data contained in the view and passes it to the model layer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Design patterns are a huge topic. There are many different design patterns
    and if you want a beginner-friendly introduction to the topic in general, I would
    recommend *Head First Design Patterns*. If you want to really dive into the world
    of design patterns, then you can try *Design Patterns: Elements of Reusable Object-Oriented
    Software*, which is recognized as a kind of design pattern oracle but is much
    harder reading.'
  prefs: []
  type: TYPE_NORMAL
- en: As the book progresses, we will also begin to utilize more of the object-oriented
    programming aspects we have discussed but not fully benefited from so far. We
    will do so step by step.
  prefs: []
  type: TYPE_NORMAL
- en: Android design guidelines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: App design is a vast topic. It is a topic that could only begin to be taught
    in a book of its own. Also, like programming, you can only start to get good at
    app design with constant practice, review, and improvement.
  prefs: []
  type: TYPE_NORMAL
- en: So, what exactly do I mean by design? I am talking about where you put the widgets
    on the screen, which widgets, what color should they be, how big should they be,
    how to transition between screens, the best way to scroll a page, when and which
    animation interpolators to use, what screens your app should be divided into,
    and much more besides.
  prefs: []
  type: TYPE_NORMAL
- en: This book will hopefully leave you well qualified to be able to *implement*
    all your choices for the above questions. It unfortunately doesn't have the space,
    and the author probably doesn't have the skill, to teach you how to *make* those
    choices.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You might be wondering, "What should I do?" Keep making apps and don't let a
    lack of design experience and knowledge stop you! Even release your apps to the
    app store. Keep in mind, however, that there is this whole other topic – design
    – that needs some attention if your apps are going to truly be world-class.
  prefs: []
  type: TYPE_NORMAL
- en: In even medium-sized development companies, the designer is rarely also the
    programmer, and even very small companies will often outsource the design of their
    app (or designers might outsource the coding).
  prefs: []
  type: TYPE_NORMAL
- en: Designing is both art and science, and Google has demonstrated that they recognize
    this with high-quality support for both existing designers and aspiring new designers.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'I highly recommend you visit and bookmark this web page: [https://developer.android.com/design/](https://developer.android.com/design/).
    It is quite detailed and comprehensive, is totally Android focused, and has a
    load of resources in the form of images, color palettes, and guidelines.'
  prefs: []
  type: TYPE_NORMAL
- en: Make understanding design principles a short-term goal. Make improving your
    actual design skills an ongoing task. Visit and read design-focused websites and
    try and implement the ideas that you find exciting.
  prefs: []
  type: TYPE_NORMAL
- en: Most important of all, however, don't wait until you are a design expert to
    make apps. Keep bringing your ideas to life and publishing them. Make a point
    of making each app a little better designed than the last.
  prefs: []
  type: TYPE_NORMAL
- en: We will see in the coming chapters and have seen already, that the Android API
    makes available to us a whole bunch of super-stylish UIs that we can take advantage
    of with very little code or design skill. These UIs go a long way to making your
    apps look like they have been designed by a professional.
  prefs: []
  type: TYPE_NORMAL
- en: Real-world apps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have built a dozen or more apps of various complexity. Most of them
    we designed and tested on a phone.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, in the real world, our apps need to work well on any device and must
    be able to handle what happens when in either portrait or landscape view (on all
    devices).
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, it is often not enough for our apps to just work and look "OK"
    on different devices. Often, our apps will need to *behave* differently and appear
    with a significantly different UI based on whether the device is a phone or a
    tablet, and in landscape/portrait orientation.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Android supports apps for large screen TVs, smartwatches via the Wear API, virtual
    reality and augmented reality, as well as "things" for the Internet of Things.
    We will not be covering the two latter cases in this book, but by the end of the
    book, it is the author's guess that you will be prepared enough to venture into
    these topics should you choose to.
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at this screenshot of the BBC weather app running on an Android phone
    in portrait orientation. Look at the basic layout but also study the information
    shown as we will compare it to the tablet app in a moment:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 24.1 – BBC weather app running on an Android phone in portrait orientation'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_24.01_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 24.1 – BBC weather app running on an Android phone in portrait orientation
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, the purpose of the previous screenshot is not so much to show you
    the specific UI features but to allow you to compare it with the next screenshot.
    Look at the exact same app running on a tablet in landscape orientation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 24.2 – BBC weather app running on an Android phone in landscape orientation'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_24.02_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 24.2 – BBC weather app running on an Android phone in landscape orientation
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the tablet UI has an extra panel of information compared to the
    phone app. This extra panel is highlighted in the preceding screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: The point of this screenshot again is not so much the specific UI or even how
    we might implement one like it, but more that the UIs are so different they could
    easily be considered totally different apps. Yet if you download this app, it
    is the same download for tablet and phone.
  prefs: []
  type: TYPE_NORMAL
- en: Android allows us to design real-world apps like this where not only is the
    layout different for varying device types/orientations/sizes but also (and this
    is important) the behavior is different. The Android secret weapon that makes
    this possible is `Fragments`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Google says:'
  prefs: []
  type: TYPE_NORMAL
- en: '"A Fragment represents a behavior or a portion of user interface in an Activity.
    You can combine multiple fragments in a single activity to build a multi-pane
    UI and reuse a fragment in multiple activities.'
  prefs: []
  type: TYPE_NORMAL
- en: You can think of a fragment as a modular section of an activity, which has its
    own lifecycle, receives its own input events, and which you can add or remove
    while the activity is running (sort of like a "sub activity" that you can reuse
    in different activities).
  prefs: []
  type: TYPE_NORMAL
- en: A fragment must always be embedded in an activity and the fragment's lifecycle
    is directly affected by the host activity's lifecycle."
  prefs: []
  type: TYPE_NORMAL
- en: We can design multiple different layouts in different XML files and we will
    do so soon. We can also detect things such as device orientation and screen resolution
    in our Java code, so we can then make decisions about layout, dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: Let's try this out using device detection and then we will have our first look
    at Fragments.
  prefs: []
  type: TYPE_NORMAL
- en: Device detection mini-app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The best way to learn about detecting and responding to devices and their varying
    attributes (screens, orientations, and so on) is to make a simple app:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new `Device Detection`. Leave all the other settings as their defaults.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `activity_main.xml` file in the design tab and delete the default `TextView`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag a `detectDevice`. We will code this method in a minute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag two `txtOrientation` and `txtResolution`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Check you have a layout that looks something like this next screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: I have stretched my widgets (mainly horizontally) and increased the `textSize`
    attributes to `24sp` to make them clearer on the screen, but this is not required
    for the app to work correctly.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 24.3– Layout check'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_24.03_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 24.3– Layout check
  prefs: []
  type: TYPE_NORMAL
- en: Click the **Infer Constraints** button to secure the positions of the UI elements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we will do something new. We will build a layout specifically for landscape
    orientation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Android Studio, make sure the `activity_main.xml` file is selected in the
    editor and locate the **Orientation for preview** button as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 24.4 – Create Landscape Variation'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_24.04_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 24.4 – Create Landscape Variation
  prefs: []
  type: TYPE_NORMAL
- en: Click it and then select **Create Landscape Variation**.
  prefs: []
  type: TYPE_NORMAL
- en: 'You now have a new layout XML file with the same name but orientated in landscape
    mode. The layout appears blank in the editor, but as we will see, this is not
    the case. Look at the `layout` folder in the Project Explorer and notice that
    there are indeed two files named `activity_main`, and one of them (the new one
    we just created) is postfixed with **land**. This is shown in the next screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 24.5 – activity_main folder'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_24.05_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 24.5 – activity_main folder
  prefs: []
  type: TYPE_NORMAL
- en: 'Select this new file (the one postfixed with **land**) and now look at the
    component tree. It is pictured in the next screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 24.6 – Component tree'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_24.06_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 24.6 – Component tree
  prefs: []
  type: TYPE_NORMAL
- en: It would appear that the layout already contains all our widgets – we just cannot
    see them in the design view. The reason for this anomaly is that when we created
    the landscape layout, Android Studio copied the portrait layout, including all
    the constraints. The portrait constraints rarely match the landscape constraints.
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve the problem, click the **Remove all constraints** button; it''s the
    button to the left of the **Infer constraints** button. The UI is now unconstrained.
    All the UI widgets will appear jumbled up in the top-left corner. One at a time,
    rearrange them to look like this next screenshot. I had to add the constraints
    manually to make this design work so I have shown the constraints in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 24.7 – Add the constraints'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_24.07_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 24.7 – Add the constraints
  prefs: []
  type: TYPE_NORMAL
- en: Click the `/Device Detection/layout-land` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The appearance doesn't really matter as long as you can see the contents of
    both `TextView` widgets and click the button.
  prefs: []
  type: TYPE_NORMAL
- en: Now we have a basic layout for two different orientations, we can turn our attention
    to coding the Java.
  prefs: []
  type: TYPE_NORMAL
- en: Coding the MainActivity class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Add the following member variables just after the `MainActivity` class declaration,
    to hold references to our two `TextView` widgets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the `TextView` class at this point:'
  prefs: []
  type: TYPE_NORMAL
- en: '`import android.widget.TextView;`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, in the `onCreate` method of the `MainActivity` class, just after the call
    to `setContentView`, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'After `onCreate`, add the method that handles our button click and runs our
    detection code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the following three classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`import android.graphics.Point;`'
  prefs: []
  type: TYPE_NORMAL
- en: '`import android.view.Display;`'
  prefs: []
  type: TYPE_NORMAL
- en: '`import android.view.View;`'
  prefs: []
  type: TYPE_NORMAL
- en: This code works by declaring and initializing an object of type `Display` called
    `display`. This object (`display`) now holds a whole bunch of data about the specific
    display properties of the device.
  prefs: []
  type: TYPE_NORMAL
- en: The result of the `getRotation` method is output into the top `TextView` widget.
  prefs: []
  type: TYPE_NORMAL
- en: The code then initializes an object of type `Point` called `xy`. The `getSize`
    method then loads up the screen resolution into `xy`. The `setText` method is
    then used to output the horizontal (`xy.x`) and vertical (`xy.y`) resolution into
    the `TextView` widget.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You might remember we used the `Display` and `Point` classes in the Kids drawing
    app.
  prefs: []
  type: TYPE_NORMAL
- en: Each time the button is clicked, the two `TextView` widgets will be updated.
  prefs: []
  type: TYPE_NORMAL
- en: Unlocking the screen orientation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before we run the app, we want to make sure the device isn''t locked in portrait
    mode (most new phones are by default). From the app drawer of the emulator (or
    the device you will be using), tap the **Settings** app and choose **Display**
    and use the switch to set **Auto-rotate screen** to on. I have shown this setting
    in the next screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 24.8 – Auto-rotate screen'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_24.08_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 24.8 – Auto-rotate screen
  prefs: []
  type: TYPE_NORMAL
- en: Running the app
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now you can run the app and click the button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 24.9 – Click the button'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_24.09_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 24.9 – Click the button
  prefs: []
  type: TYPE_NORMAL
- en: 'Rotate the device, using one of the rotate buttons on the emulator control
    panel, to landscape:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 24.10 – Rotate the device'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_24.10_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 24.10 – Rotate the device
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can also use *Ctrl* + *F11* on a PC or *Ctrl* + *FN* + *F11* on Mac.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now click the button again and you will see the landscape layout in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 24.11 – Landscape layout'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_24.11_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 24.11 – Landscape layout
  prefs: []
  type: TYPE_NORMAL
- en: The first thing you will probably notice is that when you rotate the screen,
    it briefly goes blank. This is the Activity restarting and calling the `onCreate`
    method again – just what we need. It calls the `setContentView` method on the
    landscape version of the layout and the code in `MainActivity` refers to widgets
    with the same ID so the exact same code works.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Don't spend too long pondering this because we will discuss it later in the
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: If the 0 and 1 results are less than obvious regarding device orientation, they
    refer to `public static final` variables of the `Surface` class – `Surface.ROTATION_0`
    equals 0 and `Surface.ROTATION_180` equals 1.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Note that if you rotated the screen to the left, then your value will be 1 –
    the same as mine, but if you rotated it to the right, you would have seen the
    value 3\. If you rotate the device to portrait mode upside down, you will get
    the value 4.
  prefs: []
  type: TYPE_NORMAL
- en: And we could code a `switch` block based on the results of these detection tests
    and load up different layouts.
  prefs: []
  type: TYPE_NORMAL
- en: But as we have just seen, Android makes this simpler than this for us by allowing
    us to add specific layouts into folders with configuration qualifiers, such as
    **land**, short for Landscape.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration qualifiers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already met configuration qualifiers such as `layout-large` and `layout-xhdpi`
    in [*Chapter 3*](B16773_03_ePub_RK.xhtml#_idTextAnchor064), *Exploring Android
    Studio and the Project Structure*. Here, we will refresh and expand our understanding
    of them.
  prefs: []
  type: TYPE_NORMAL
- en: We can begin to remove reliance on the controller layer to influence app layout
    by using configuration qualifiers. There are configuration qualifiers for size,
    orientation, and pixel density. To take advantage of a configuration qualifier,
    we simply design a layout in the usual way, optimized for our preferred configuration,
    and then place that layout in a folder with a name that Android recognizes as
    being for that particular configuration.
  prefs: []
  type: TYPE_NORMAL
- en: For example, in the previous app, putting a layout in the `land` folder tells
    Android to use the layout when the device is in the landscape orientation.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is likely that the above statement will seem slightly ambiguous. This is
    because the Android Studio `layout` and `layout-land` folder as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 24.12 – layout and layout-land folder'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_24.12_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 24.12 – layout and layout-land folder
  prefs: []
  type: TYPE_NORMAL
- en: Switch back to the **Android** view or leave it on the **Project Files** view
    – whichever you prefer.
  prefs: []
  type: TYPE_NORMAL
- en: So, if we want to have a different layout for landscape and portrait, we would
    create a folder called `layout-land` in the `res` folder (or use the shortcut
    we used in the previous app) and place our specially designed layout within it.
  prefs: []
  type: TYPE_NORMAL
- en: When the device is in portrait position, the regular layout from the `layout`
    folder will be used and when it is in landscape position, the layout from the
    `layout-land` folder would be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we are designing for different sizes of screen, we place layouts into folders
    with the following names:'
  prefs: []
  type: TYPE_NORMAL
- en: '`layout-small`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`layout-normal`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`layout-large`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`layout-xlarge`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we are designing for screens with different pixel densities, we can place
    XML layouts into folders with names like these:'
  prefs: []
  type: TYPE_NORMAL
- en: '`layout-ldpi` for low-DPI devices'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`layout-mdpi` for medium-DPI devices'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`layout-hdpi` for high-DPI devices'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`layout-xhdpi` for extra-high DPI devices'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`layout-xxhdpi` for extra-extra-high DPI devices'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`layout-xxxhdpi` for extra-extra-extra-high DPI devices'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`layout-nodpi` for devices with a DPI you have not otherwise catered for'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`layout-tvdpi` for TVs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What exactly qualifies as low, high, or extra-high DPI and so on can be researched
    at the link in the next info box. The point here is the principal.
  prefs: []
  type: TYPE_NORMAL
- en: It is worth pointing out that what we have just discussed is a long way from
    being the whole story regarding configuration qualifiers and, as with design,
    it is worth putting this on your list of things to study further.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Often, the Android developer site has lots of detailed information on handling
    layouts for different devices. Try this link for more information: [https://developer.android.com/guide/practices/screens_support](https://developer.android.com/guide/practices/screens_support).'
  prefs: []
  type: TYPE_NORMAL
- en: The limitation of configuration qualifiers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What the previous app and our discussion on configuration qualifiers have shown
    us is certainly very useful in a number of situations. Unfortunately, however,
    configuration qualifiers and detecting attributes in code only solves the problem
    in the view layer of our MVC pattern.
  prefs: []
  type: TYPE_NORMAL
- en: As discussed, our apps sometimes need to have different *behavior* as well as
    layout. This perhaps implies multiple branches of our Java code in the controller
    layer (`MainActivity` in most of our previous apps) and perhaps summons nightmarish
    visions of having huge great `if` or `switch` blocks with different code for each
    different scenario.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, this is not how it's done. For such situations, in fact for most
    apps, Android has fragments.
  prefs: []
  type: TYPE_NORMAL
- en: Fragments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Fragments will likely become a staple of almost every app you make. They are
    so useful, there are so many reasons to use them, and once you get used to them,
    they are so simple, there is almost no reason not to use them.
  prefs: []
  type: TYPE_NORMAL
- en: Fragments are reusable elements of an app just like any class, but as mentioned
    previously, they have special features, such as the ability to load their own
    view/layout as well as their very own lifecycle methods, which make them perfect
    for achieving the goals we discussed in the *Real-world apps* section and having
    different layouts and code for different devices (like the weather app we looked
    at).
  prefs: []
  type: TYPE_NORMAL
- en: Let's dig a bit deeper into fragments, one feature at a time.
  prefs: []
  type: TYPE_NORMAL
- en: Fragments have a lifecycle too
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can set up and control fragments very much like we do Activities, by overriding
    the appropriate lifecycle methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`onCreate`: In the `onCreate` method, we can initialize variables and do almost
    all the things we would typically have done in the `Activity onCreate` method.
    The big exception to this is initializing our UI.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onCreateView`: In this method, we will, as the name suggests, get a reference
    to any of our UI widgets, set up anonymous classes to listen for clicks, and more
    besides, as we will soon see.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onAttach` and `onDetach`: These methods are called just before `Fragment`
    is put into use/taken out of use.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onResume`, `onStart`, `onPause`, and `onStop`: In these methods, we can take
    certain actions, such as creating or deleting objects or saving data, just like
    we have done with their `Activity` based counterparts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to study the details of the `Fragment` lifecycle, you can do so
    on the Android developer website at this link: [https://developer.android.com/guide/components/fragments](https://developer.android.com/guide/components/fragments).'
  prefs: []
  type: TYPE_NORMAL
- en: This is all fine, but we need a way to create our fragments in the first place
    and to be able to call these methods at the right time.
  prefs: []
  type: TYPE_NORMAL
- en: Managing Fragments with FragmentManager
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `FragmentManager` class is part of the `Activity`. We use it to initialize
    a `Fragment`, add Fragments to the Activities layout, and to end a `Fragment`.
    We briefly saw `FragmentManager` before when we initialized our `FragmentDialog`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: It is very hard to learn much about Android without bumping into the `Fragment`
    class, just as it is tough to learn much about Java without constantly bumping
    into OOP/classes, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following highlighted code shows how we used `FragmentManager` (which is
    already a part of `Activity`) being passed in as an argument to create the pop-up
    dialog:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: At the time, I asked you not to concern yourself with the arguments of the method
    call. The second argument of the method call is an ID for `Fragment`. We will
    see how we use `FragmentManager` more extensively, as well as how to use the `Fragment`
    ID.
  prefs: []
  type: TYPE_NORMAL
- en: '`FragmentManager` does exactly what its name suggests. What is important here
    is that `Activity` only has one `FragmentManager`, but it can take care of many
    fragments. This is just what we need to have multiple behaviors and layouts within
    a single app.'
  prefs: []
  type: TYPE_NORMAL
- en: '`FragmentManager` also calls the various lifecycle methods of the fragments
    it is responsible for. This is distinct from the `Activity` lifecycle methods
    that are called by Android, yet closely related because `FragmentManager` calls
    many of the `Fragment` lifecycle methods *in response to* the `Activity` lifecycle
    methods being called. As usual, we don''t need to worry too much about when and
    how if we respond appropriately in each situation.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Fragments are going to be a fundamental part of many, if not all our future
    apps. As we did with naming conventions, string resources, and encapsulation,
    however, we will not use fragments for simple learning purposes or very small
    apps when they would be overkill. The exception to this will of course be when
    we are learning about fragments.
  prefs: []
  type: TYPE_NORMAL
- en: Our first Fragment app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's build `Fragment` in its simplest possible form so we can understand what
    is going on before, in later chapters, we start producing Fragments all over the
    place that are of genuine usefulness.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: I urge all readers to go through and build this project. There is a lot of jumping
    around from file to file and just reading alone can make it seem more complex
    than it really is. Certainly, you can copy and paste the code from the download
    bundle but please also follow the steps and create your own projects and classes.
    Fragments are not too tough but their implementation, as their name suggests,
    is a little fragmented.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new project called `Simple Fragment` using the Empty Activity template
    and leaving the rest of the settings at their defaults.
  prefs: []
  type: TYPE_NORMAL
- en: Switch to `activity_main.xml` and delete the default `TextView` widget.
  prefs: []
  type: TYPE_NORMAL
- en: Now make sure the root `ConstraintLayout` is selected by left-clicking it in
    the`fragmentHolder`. We will now be able to get a reference to this layout in
    our Java code and as the `id` property implies, we will be adding a `Fragment`
    to it.
  prefs: []
  type: TYPE_NORMAL
- en: Now we will create a layout that will define our fragment's appearance. Right-click
    the `fragment_layout`, in the `LinearLayout`, and left-click `LinearLayout`.
  prefs: []
  type: TYPE_NORMAL
- en: Add a single `button`.
  prefs: []
  type: TYPE_NORMAL
- en: Now we have a simple layout for our Fragment to use, let's write some Java code
    to make the actual fragment.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can create a `Fragment` by simply dragging and dropping one from
    the palette, but doing things this way is much less flexible and controllable
    and flexibility and control are the big benefits to fragments, as we will see
    throughout the next chapter. By creating a class that extends `Fragment`, we can
    make as many fragments from it as we like.
  prefs: []
  type: TYPE_NORMAL
- en: In the Project Explorer, right-click the folder that contains the `MainActivity`
    file. From the context menu, choose `SimpleFragment`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Note that there are options to create `Fragment` classes in various pre-coded
    states to implement a `Fragment` more quickly, but now they would slightly cloud
    the learning objectives of this app.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our new `SimpleFragment` class, change the code to extend `Fragment`. As
    you type the code, you will be asked to choose the specific `Fragment` class to
    import, as shown in the next screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 24.13 – Choose the specific Fragment class'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_24.13_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 24.13 – Choose the specific Fragment class
  prefs: []
  type: TYPE_NORMAL
- en: Choose the top option, which is `androidx.fragment.app`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'We will need all of the following `import` statements in this class. The preceding
    step has already added the `androidx.fragment.app.Fragment` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '`import androidx.fragment.app.Fragment;`'
  prefs: []
  type: TYPE_NORMAL
- en: '`import android.os.Bundle;`'
  prefs: []
  type: TYPE_NORMAL
- en: '`import android.view.LayoutInflater;`'
  prefs: []
  type: TYPE_NORMAL
- en: '`import android.view.View;`'
  prefs: []
  type: TYPE_NORMAL
- en: '`import android.view.ViewGroup;`'
  prefs: []
  type: TYPE_NORMAL
- en: '`import android.widget.Button;`'
  prefs: []
  type: TYPE_NORMAL
- en: '`import android.widget.Toast;`'
  prefs: []
  type: TYPE_NORMAL
- en: Now add a single `String` variable called `myString` and a `Button` variable
    called `myButton` as members.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now override the `onCreate` method. Inside the `onCreate` method, initialize
    `myString` to `Hello from SimpleFragment`. Our code so far (excluding the package
    declaration and `import` statements) will look exactly like this next code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code, we created a member variable called `myString`, then in
    the `onCreate` method, we initialized it. This is very much like what we did for
    our previous apps when only using `Activity`.
  prefs: []
  type: TYPE_NORMAL
- en: The difference, however, is that we did not set the view or attempt to get a
    reference to our `Button` member variable, `myButton`.
  prefs: []
  type: TYPE_NORMAL
- en: When using `Fragment`, we need to do this in the `onCreateView` method. Let's
    override that now and see how we set the view and get a reference to our `Button`
    widget.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this code to the `SimpleFragment` class after the `onCreate` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'To understand the previous block of code, we must first look at the `onCreateView`
    method signature. First, notice the start of the method states that it must return
    an object of type `View`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have three arguments. Let''s look at the first two:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We need a `LayoutInflater` reference as we cannot call the `setContentView`
    method because the `Fragment` class provides no such method. In the body of `onCreateView`,
    we use the `inflate` method of `inflater` to inflate our layout contained in `fragment_layout.xml`
    and initialize `view` (an object of type `View`) with the result.
  prefs: []
  type: TYPE_NORMAL
- en: We use `container`, which was passed into `onCreateView` as an argument, in
    the `inflate` method also. The `container` variable is a reference to the layout
    in `activity_main.xml`.
  prefs: []
  type: TYPE_NORMAL
- en: It might seem obvious that `activity_main.xml` is the containing layout, but
    as we will see later in the chapter, the `ViewGroup container` argument allows
    *any* `Activity` with *any* layout to be the container for our fragment. This
    is exceptionally flexible and makes our `Fragment` code reusable to a significant
    extent.
  prefs: []
  type: TYPE_NORMAL
- en: The third argument we pass in to `inflate` is `false`, which means that we don't
    want our layout immediately added to the containing layout. We will do this ourselves
    soon from another part of the code.
  prefs: []
  type: TYPE_NORMAL
- en: The third argument of `onCreateView` is `Bundle savedInstanceState`, which is
    there to help us maintain the data that our fragments hold.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we have an inflated layout contained in `view`, we can use this to get
    a reference to our `Button` widget like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'And use the `view` instance as the return value to the calling code, as required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Now we can add an anonymous class to listen for clicks on our button in the
    usual manner. In the `onClick` method, we display a pop-up `Toast` message to
    demonstrate that everything is working as expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this code just before the `return` statement in the `onCreateView` method
    as highlighted in this next code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: As a reminder, the `getActivity()` method call used as an argument in `makeText`
    gets a reference to the `Activity` that contains the `Fragment`. This is required
    to display a `Toast` message. We also used the `getActivity` method in our `FragmentDialog`
    based classes in the Note to Self app.
  prefs: []
  type: TYPE_NORMAL
- en: We can't run our app just yet; it will not work because there is one more step
    required. We need to create an instance of our `SimpleFragment` class and initialize
    it appropriately. This is where the `FragmentManager` class will get introduced.
  prefs: []
  type: TYPE_NORMAL
- en: This next code creates a new `FragmentManager` by calling `getSupportFragmentManager`.
    The code then creates a new `Fragment`, based on our `SimpleFragment` class using
    the `FragmentManager` and passing in the ID of the layout (within the `Activity`)
    that will hold it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this code in the `onCreate` method of `MainActivity.java`, just after the
    call to the `setContentView` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'You will need to add the following `import` statements to the `MainActivity`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '`import androidx.fragment.app.Fragment;`'
  prefs: []
  type: TYPE_NORMAL
- en: '`import androidx.fragment.app.FragmentManager;`'
  prefs: []
  type: TYPE_NORMAL
- en: '`import android.os.Bundle;`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now run the app and gaze in wonder at our clickable button that displays a
    message with the `Toast` class and took two layouts and two whole classes to create:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 24.14 – Displaying a message with the Toast class'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_24.14_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 24.14 – Displaying a message with the Toast class
  prefs: []
  type: TYPE_NORMAL
- en: 'If you remember achieving more than this way back in [*Chapter 2*](B16773_02_ePub_RK.xhtml#_idTextAnchor043)*,
    First Contact: Java, XML, and the UI Designer*, and with far less code, then it
    is clear that we need a fragment reality check to fully understand the answer
    to the question of why we are doing it like this!'
  prefs: []
  type: TYPE_NORMAL
- en: Fragment reality check
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, what does this `Fragment` stuff really do for us? Our first `Fragment` mini-app
    would have the same appearance and functionality had we not bothered with the
    `Fragment` at all.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, using the `Fragment` class has made the whole thing more complicated!
    Why would we want to do this?
  prefs: []
  type: TYPE_NORMAL
- en: We know that a `Fragment` instance or fragments can be added to the layout of
    an `Activity`.
  prefs: []
  type: TYPE_NORMAL
- en: We know that a `Fragment` not only contains its own layout (view) but also its
    very own code (controller), which, although hosted by an `Activity`, the `Fragment`
    instance is virtually independent.
  prefs: []
  type: TYPE_NORMAL
- en: Our quick app only showed one `Fragment` instance in action, but we could have
    an `Activity` that hosts two or more fragments. We then effectively have two almost
    independent controllers displayed on a single screen.
  prefs: []
  type: TYPE_NORMAL
- en: What is most useful about this, however, is that when the `Activity` starts,
    we can detect attributes of the device our app is running on – perhaps phone or
    tablet; portrait or landscape. We can then use this information to decide to display
    either just one or two of our fragments simultaneously.
  prefs: []
  type: TYPE_NORMAL
- en: This not only helps us achieve the kind of functionality discussed in the section
    *Real-world apps* at the start of the chapter but it also allows us to do so using
    the exact same `Fragment` code for both possible scenarios!
  prefs: []
  type: TYPE_NORMAL
- en: This really is the essence of fragments. We create a whole app by pairing up
    both functionality (controller) and appearance (view) into a bunch of fragments
    that we can reuse in different ways, almost without a care.
  prefs: []
  type: TYPE_NORMAL
- en: It is, of course, possible to foresee a few stumbling blocks so take a look
    at this FAQ.
  prefs: []
  type: TYPE_NORMAL
- en: Frequently asked question
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The missing link is that if all these fragments are fully functioning independent
    controllers, then we need to learn a bit more about how we would implement our
    model layer. If we simply have, say, an `ArrayList`, like with the Note to Self
    app, where will the `ArrayList` instance go? How would we share it between fragments
    (assuming both/all fragments need access to the same data)?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There is an entirely more elegant solution we can use to create a model layer
    (both the data itself and the code to maintain the data). We will see this when
    we explore the `NavigationView` layout in [*Chapter 26*](B16773_26_ePub_RK.xhtml#_idTextAnchor439)*,
    Advanced UI with Navigation Drawer and Fragment*, and Android databases in [*Chapter
    27*](B16773_27_ePub_RK.xhtml#_idTextAnchor462)*, Android Databases*.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we have a broad understanding of what Fragments are for and how we can begin
    to use them, we can start to go deeper into how they are used. In the next chapter,
    we will complete a couple of apps that use multiple Fragments in different ways.
  prefs: []
  type: TYPE_NORMAL
