- en: Installing and Running Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we know a little about the background of Ansible, we will work on installing
    it and, once installed, we will run our first set of playbooks against a test
    virtual machine running CentOS 7\.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: How to install Ansible on macOS and Linux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running Ansible on Windows 10 Professional using the Linux subsystem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Launching a test virtual machine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An introduction to playbooks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will be installing Ansible, so you will need a machine capable
    of running it. I will go into more details about these requirements in the next
    part of the chapter. We will also be using Vagrant to launch a virtual machine
    locally. There is a section that walks through installing Vagrant as well as downloading
    a CentOS 7 Vagrant box, which is around 400 MB.
  prefs: []
  type: TYPE_NORMAL
- en: You can find complete versions of all of the playbooks in the GitHub repository
    that accompanies this book at [https://github.com/PacktPublishing/Learn-Ansible/tree/master/Chapter02](https://github.com/PacktPublishing/Learn-Ansible/tree/master/Chapter02).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also find the code bundle in author''s repository: [https://github.com/russmckendrick/learn-ansible-fundamentals-of-ansible-2x](https://github.com/russmckendrick/learn-ansible-fundamentals-of-ansible-2x).'
  prefs: []
  type: TYPE_NORMAL
- en: Installing Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's dive straight in and install Ansible. Throughout this book, I will be
    assuming that you are running a macOS host machine running macOS High Sierra or
    a Linux machine with Ubuntu 18.04 LTS installed. While we will cover running Ansible
    on Windows 10 Professional using the Linux subsystem for Windows, using Windows
    as a host machine will not be supported in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Installing on macOS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a few different ways you can install Ansible on your macOS High Sierra
    host machine. I will cover them both.
  prefs: []
  type: TYPE_NORMAL
- en: As we are discussing two different ways of installing Ansible, I would recommend
    reading through this section and also the *Pros and cons* section at the end before
    choosing which installation method to use on your own machine.
  prefs: []
  type: TYPE_NORMAL
- en: Homebrew
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first installation method is to use a package called Homebrew.
  prefs: []
  type: TYPE_NORMAL
- en: Homebrew is a package manager of macOS. It can be used to install command-line
    tools and also desktop packages. It describes itself as *The missing package manager
    for macOS* and it is normally one of the first tools I install after a clean installation
    or when getting a new computer. You can find out more about the project at [https://brew.sh/](https://brew.sh/).
  prefs: []
  type: TYPE_NORMAL
- en: 'To install Ansible using Homebrew, you first need to install Homebrew. To do
    this, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: At each step of the installation process, the installer will tell you exactly
    what it is going to do and also prompt you for any additional information it needs
    from you in order to complete the installation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once installed, or if you already have Homebrew installed, run the following
    commands to update your list of packages and also check that your Homebrew installation
    is optimal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Depending on how new your installation is, or when you last used it, you might
    see a different output to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/e7098ac5-a5b9-4284-a9c4-0f78833b94a4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we can check what packages Homebrew provides for Ansible by running the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from the results in the following screenshot, there are several
    packages returned in the search:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/4f75c86c-ed03-493a-ab3a-d81ceb483151.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We just want the Ansible package. You can find out more about the package by
    running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see the results of the command in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/f2f7ce93-575f-4e4b-bafc-6d183b63b066.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the command returns information on the version of the package
    that will be installed, as well as details on where you can see the code for the
    formula that installs the package. In our case, you can view details of the formula
    at [https://github.com/Homebrew/homebrew-core/blob/master/Formula/ansible.rb](https://github.com/Homebrew/homebrew-core/blob/master/Formula/ansible.rb).
  prefs: []
  type: TYPE_NORMAL
- en: 'To install Ansible using Homebrew, we simply have to run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This will download and install all of the dependencies and then the Ansible
    package itself. Depending on how much of the dependencies are already installed
    on your machine, this may take a few minutes. Once installed, you should see something
    like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/20eedb32-0c65-4c4a-aca8-739c34af7c30.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see from the preceding screenshot, Homebrew is quite verbose in its
    output, giving you both feedback on what it is doing and details on how to use
    the packages it installs.
  prefs: []
  type: TYPE_NORMAL
- en: The pip method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The second method, `pip`, is a more traditional approach to installing and configuring
    a Python package.
  prefs: []
  type: TYPE_NORMAL
- en: '`pip` is a package manager for Python software. It is a recursive acronym for
    **pip install packages**. It is a good frontend for installing packages from the
    **Python Package Index** (**PyPI**). You can find the index at [https://pypi.python.org/pypi/](https://pypi.python.org/pypi/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Depending on what you have installed on your machine, you may have to install
    `pip`. To do this, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This will install `pip` using the `easy_install` installer, which ships with
    macOS by default. Once installed, you can install Ansible by running the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You will be prompted for your password, as we are using the `sudo` command,
    like Homebrew. This command will download and install all of the prerequisites
    needed to run Ansible on your system. While it is as verbose as Homebrew, its
    output contains information on what it has done, rather than hints on what do
    to next:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/18f6320e-0289-407a-a27f-61c8b0f0ed55.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, a lot of the requirements were already satisfied.
  prefs: []
  type: TYPE_NORMAL
- en: Pros and cons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, now that we have covered some of the different ways of installing Ansible
    on macOS, which is best? Well, there is no real answer to this as it comes down
    to personal preference. Both methods will install the latest versions of Ansible.
    However, Homebrew tends to be a week or two behind the current release.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have a lot of packages already installed using Homebrew, then you will
    already be used to running the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Every once in a while, do update your installed packages to the latest. If you
    already do this, then it would make sense to use Homebrew to manage your Ansible
    installation.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are not a Homebrew user and want to make sure that you immediately have
    the latest version installed, then use the `pip` command to install Ansible. Upgrading
    to the latest version of Ansible is as simple as running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: I have found that I need to use the `--ignore-installed setuptools` flag, as
    there are problems and conflicts with the version managed by macOS and the one
    which is part of Ansible updates. I have not known this to cause any problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Should you need to, then you can install older versions of Ansible using both
    Homebrew and `pip`. To do this using Homebrew, you just need to remove the current
    version by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you can install an earlier version of the package by running the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, for an even earlier version, you can use the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'For details on exactly which version of the package is going to be installed,
    you can run one of the following two commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'While this will install an earlier version, you do not get much choice in which
    version is installed. If you really need an exact version, you can use the `pip`
    command to install it. For example, to install Ansible 2.3.1.0, you would need
    to run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: You should never need to do this. However, I have found that on some occasions,
    I have had to downgrade to help debug *quirks* in my playbooks introduced by upgrading
    to a later version.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned, I spend the bulk of my time in front of a macOS machine in some
    form or other, so which of the two methods do I use? Primarily, I use Homebrew,
    as I have several other tools installed using Homebrew. However, if I need to
    roll back to a previous version, I use `pip` and then return to Homebrew once
    the issue is resolved.
  prefs: []
  type: TYPE_NORMAL
- en: Installing on Linux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a few different ways of installing Ansible on Ubuntu 18.04\. However,
    I am only going to cover one of them here. While there are packages available
    for Ubuntu from which you can install with `apt`, they tend to quickly become
    out of date and are typically behind the current release.
  prefs: []
  type: TYPE_NORMAL
- en: '**Advanced Packaging Tool**  (**APT**) is the package manager that ships with
    Debian-based systems, including Ubuntu. It is used to manage `.deb` files.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Because of this, we will be using `pip`. The first thing to do is install `pip`,
    and this can be done by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Once `pip` is installed, the instructions for installing Ansible are the same
    as installing on macOS. Simply run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This will download and then install Ansible and its requirements, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/80c75687-b413-4b5d-8198-80961d084820.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once installed, you can upgrade it by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that this time, we do not have to ignore anything as there shouldn''t
    be any problems with the default installation. Also, downgrading Ansible is the
    same command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The preceding commands should work on most Linux distributions, such as CentOS,
    Red Hat Enterprise Linux, Debian, and, Linux Mint.
  prefs: []
  type: TYPE_NORMAL
- en: Installing on Windows 10 Professional
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last platform we are going to cover is Windows 10 Professional; well, sort
    of. There is no supported way of running an Ansible controller on a Windows machine
    natively. Because of this, we will be using the Windows subsystem for Linux.
  prefs: []
  type: TYPE_NORMAL
- en: This is a feature, which, at the time of writing, is in beta, and is only available
    to Windows 10 Professional users. To enable it, you first need to enable developer
    mode. To do this, open the Windows 10 Settings app and then toggle Developer mode,
    which can be found under UPDATE & SECURITY, and then For Developers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once Developer mode has been enabled, you will be able to enable the shell.
    To do this, open Control Panel, then click on Programs and Features, and then
    on Turn Windows features on or off. In the list of features, you should see Windows
    Subsystem for Linux (Beta) listed. Tick the box next to it and then OK. You will
    be prompted to reboot your machine. Following the reboot, click on the Start menu
    and type `bash`. This will trigger the installation process. You should see something
    like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/948c2393-4d7e-4297-b4eb-9b0aecb6b589.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once downloaded, it will extract and install the subsystem. You will be asked
    a few questions. As needed, the entire process will take between 5 and 10 minutes.
    Once installed, you should now have a full Ubuntu 16.04 system running on your
    Windows machine. You can check this by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the output for the preceding command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/375eaa66-603d-42ec-bf86-2c3a6f7bd8ad.png)'
  prefs: []
  type: TYPE_IMG
- en: 'From here, you can run the following commands to install Ansible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the output for the preceding command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/d8aef965-0e43-4577-80f1-cb3e6de99982.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, everything works as if you were running an Ubuntu machine, allowing
    you to run and maintain your Ansible installation in exactly the same way.
  prefs: []
  type: TYPE_NORMAL
- en: The **Windows Subsystem for Linux** (**WSL**) is not running on a virtual machine.
    It is a full native Linux experience baked right into Windows 10 Professional.
    It is targeted at developers who need to run Linux tools as part of their toolchain.
    While the overall support for Linux commands is excellent, I would recommend reading
    through the FAQs written and maintained by Microsoft to get an idea of the limits
    and also any quirks of the subsystem. The FAQs can be found at [https://docs.microsoft.com/en-us/windows/wsl/faq/](https://docs.microsoft.com/en-us/windows/wsl/faq/).
  prefs: []
  type: TYPE_NORMAL
- en: As already mentioned, while this is a viable way of running an Ansible control
    node on a Windows-based machine, some of the other tools we will be covering in
    future chapters may not work with Windows. So while you may follow along using
    the Ubuntu instructions, some parts may not work. Where possible, I will add a
    note saying that it may not work on Windows-based systems.
  prefs: []
  type: TYPE_NORMAL
- en: Launching a virtual machine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to launch a virtual machine to run our first set of Ansible commands
    against, we are going to use Vagrant.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that these instructions may not work if you are running WSL.
  prefs: []
  type: TYPE_NORMAL
- en: Vagrant is a virtual machine manager developed by HashiCorp. It can manage both
    local and remote virtual machines, and supports hypervisors, such as VirtualBox,
    VMware, and Hyper-V.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install Vagrant on macOS, we can use Homebrew along with cask. To install
    cask, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: VirtualBox is an open source hypervisor for x86-based computers. It is currently
    being developed by Oracle and supports both software- and hardware-based virtualization.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, Vagrant uses VirtualBox. Once cask is installed, you can use VirtualBox
    and Vagrant by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'To install on Ubuntu, you can run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Next up, if you don''t already have one, we need to generate a private and
    public key for your user. To do this, run the following command, but if you already
    have a key, you can skip this part:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This will create a key and store it in the `.ssh` folder in your user directory.
    We will use this key to inject into our Vagrant managed CentOS 7 virtual machine.
    To launch the virtual machine or box, as Vagrant calls it, we need a `Vagrantfile`.
    This is the configuration that Vagrant uses to create and boot the box.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Vagrantfile` we are going to be using is shown in the following code.
    You can also find a copy in the `Chapter02` folder in the code examples that accompany
    this book and also in the GitHub repository, which can be found at [https://github.com/PacktPublishing/Learn-Ansible/tree/master/Chapter02](https://github.com/PacktPublishing/Learn-Ansible/tree/master/Chapter02):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from the preceding file, there are a few things going on. First
    of all, in the top section, we are defining a few variables for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`API_VERSION`: This is the Vagrant API version to use. This should stay at
    `2`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BOX_NAME`: This is the base image we want to use. In our case, this is the
    official CentOS 7 Vagrant box image, which can be found at [https://app.vagrantup.com/centos/boxes/7](https://app.vagrantup.com/centos/boxes/7).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BOX_IP`: This is the private IP address of the machine we are launching. Typically,
    you shouldn''t need to hardcode the IP address, but in our case, we will need
    a resolvable hostname and also a fixed IP address for the examples in the next
    section of the chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DOMAIN`: This is the domain name that is used to configure the hostname on
    the machine. We are using the [http://nip.io/](http://nip.io/) service. This provides
    free wildcard DNS entries. This means that our domain `192.168.50.4.nip.io` will
    resolve to `192.168.50.4`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PRIVATE_KEY`: This is the path to your private key. This will be used to SSH
    into the virtual machine once launched.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PUBLIC_KEY`:This is the path to your public key. When the machine is being
    launched, this will be injected into the host, which means that we can access
    it using our private key.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next section takes the preceding values and configures the Vagrant box.
    We then define settings that are just for the two providers that the `Vagrantfile`
    supports. As you can see, the file will launch a box using either VirtualBox or,
    if you have it installed, VMware Fusion.
  prefs: []
  type: TYPE_NORMAL
- en: For more information on the VMware provider plugin for Vagrant, visit [https://www.vagrantup.com/vmware/](https://www.vagrantup.com/vmware/).
    Please note that this part of Vagrant requires a license, which is chargeable,
    as well as requiring you to have VMware Fusion or Workstation installed on your
    host machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have our `Vagrantfile`, we just need to run the following command
    to launch the Vagrant box:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'If you do not pass a provider along, it will default to using VirtualBox. If
    you have the VMware plugin, like me, you can run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'It will take a few minutes while the appropriate box file is downloaded and
    the virtual machine is configured:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/9749465b-0285-464c-a1d9-405f1a4dbb69.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see from the Terminal output, the launch process is very verbose
    and you receive informative feedback at each stage.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the Vagrant box is launched, you can check connectivity to it by running
    the following commands. This will log you into the Vagrant box as the Vagrant
    user and check the details on the hostname and kernel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Your Terminal should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/e847bd68-9500-4410-9e25-7b6cf0c52211.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, because we have told Vagrant which private key to use when
    accessing the box, we have been let straight into the box and can run the commands
    without issue. However, we won''t be using the `vagrant ssh` command in the next
    section, which is why we needed to inject our public key into the host. Instead,
    we will be SSHing directly into the machine from our host machine. To test this,
    you should be able to run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'You should be asked to establish the authenticity of the host by typing `yes`.
    Once you are logged in, you will be able to run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Your Terminal should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/690c1845-96f9-4f30-b298-193c874fe3b1.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, we have resolved and connected to `192.168.50.4.nip.io` using
    the Vagrant user and have authenticated using our private key. Before we move
    on to the next section and try running Ansible for the first time, we should discuss
    Vagrant provisioners.
  prefs: []
  type: TYPE_NORMAL
- en: No doubt you will have already looked at the Vagrant website, which can be found
    at [http://vagrantup.com/](http://vagrantup.com/), and may have spotted that Vagrant
    actually supports Ansible out of the box. If we were to use the Ansible provisioner,
    then Vagrant would dynamically create a host inventory and run our playbook against
    the box as part of the launch process. Before we look at this, I believe it is
    important for us to understand how the host inventory works, so we will look at
    the Ansible provisioner in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Before then, however, let's take a look at some basic playbooks and how we can
    interact with our Vagrant box using Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to playbooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Normally in IT, a playbook is a set of instructions run by someone when something
    happens; a little vague, I know, but stay with me. These range from everything
    to building and configuring new server instances, to how to deploy code updates
    and how to deal with problems when they occur.
  prefs: []
  type: TYPE_NORMAL
- en: In the traditional sense, a playbook is typically a collection of scripts or
    instructions for a user to follow and, while they are meant to introduce consistency
    and conformity across systems, even with the best intentions, this is almost never
    the case.
  prefs: []
  type: TYPE_NORMAL
- en: This is where Ansible comes in. Using an Ansible playbook, you are basically
    saying apply these changes and commands against these sets of hosts rather than
    someone having to log in and start working their way through the runbook manually.
  prefs: []
  type: TYPE_NORMAL
- en: Before we run a playbook, let's discuss how we provide Ansible with a list of
    hosts to target. To do this, we will be using the `setup` command. This simply
    connects to a host and then fetches as much information on the host as it can.
  prefs: []
  type: TYPE_NORMAL
- en: Host inventories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To provide a list of hosts, we need to provide an inventory list. This is in
    the form of a hosts file.
  prefs: []
  type: TYPE_NORMAL
- en: 'In its simplest form, our hosts file could contain a single line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: What this is telling Ansible is that the host we want to contact is `192.168.50.4.nip.io`
    and to use the username of `vagrant`. If we didn't provide the username, it would
    fall back to the user you are logged into your Ansible control host as, which
    in my case is simple—the user `russ`, which does not exist on the Vagrant box.
    There is a copy of the hosts file called `hosts-simple` in the `Chapter02` folder
    of the repository alongside the `Vagrantfile` we used to launch the Vagrant box.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run the `setup` command, we need to run the following command from within
    the same folder where `hosts-simple` is stored:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see some output which looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/8cf0984f-f09a-49ba-a141-12e7bad49015.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see from the preceding screenshot, Ansible has quickly found out
    a lot of information on our Vagrant box. From the screenshot, you can see both
    of the IP addresses configured on the machine, along with the IPv6 addresses.
    It has recorded the time and date and, if you scroll through your own output,
    you will see that there is a lot of information returned detailing the host.
  prefs: []
  type: TYPE_NORMAL
- en: 'Going back to the command we ran:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we are loading the `hosts-simple` file using the `-i` flag.
    We could have also used `--inventory=hosts-simple`, which loads our inventory
    file. The next part of the command is the host to target. In our case, this is`192.168.50.4.nip.io`.
    The final part of the command, `-m`, tells Ansible to use the `setup` module.
    We could have also used `--module-name=setup`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that the full command, if we didn''t use shorthand, would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'As already mentioned, the `hosts-simple` file is as basic as we can get it.
    The following is a more common host inventory file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: There is a copy of the file, called just `hosts`, in the same folder as the
    `hosts-simple` file. As you can see, there is a lot more going on, so let's quickly
    work through it from top to bottom.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first line defines our individual host. Unlike the simple example, we are
    going to be calling our `hosts box` and using `ansible_host`, so we are giving
    Ansible details of where it can SSH to. This means that we can now use the name
    box when referring to `192.168.50.4.nip.io`. This means our command would now
    look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Next up in the file, we are creating a group of hosts called `boxes` and, in
    that group, we are adding our single host `box`. This means that we can also run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: If we had more than just a single host in the group, then the preceding command
    would have looped through all of them. The final section of the `hosts` file sets
    up some common configuration options for all of the hosts in the `boxes` group.
    In this case, we are telling Ansible that all of the hosts in the group are using
    SSH, the user is `vagrant`, the private key at `~/.ssh/id_rsa` should be used,
    and also to not check the host key when connecting.
  prefs: []
  type: TYPE_NORMAL
- en: We will be revisiting the inventory host files in later chapters. From now on,
    we will be using the `hosts` file to target the `boxes` group.
  prefs: []
  type: TYPE_NORMAL
- en: Playbooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous section, running the `ansible` command allowed us to call a
    single module. In this section, we are going to look at calling several modules.
    The following playbook is called `playbook.yml`. It calls the `setup` module we
    called in the previous section and then uses the `debug` module to print a message
    to the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we start to break the configuration down, let''s take a look at the
    results of running the playbook. To do this, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'This will connect to our Vagrant box, gather information on the system, and
    then return just the information we want in a message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/3d8e67b7-be81-44c0-9ba5-0083ee8f84fb.png)'
  prefs: []
  type: TYPE_IMG
- en: The first thing you will notice about the playbook is that it is written in
    **YAML**, which is a recursive acronym that stands for **YAML Ain't Markup Language**.
    YAML was designed to be a human-readable data serialization standard that can
    be used by all programming languages. It is commonly used to help define configurations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The indentation is very important in YAML as it is used to nest and define
    areas of the file. Let''s look at our playbook in more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: While these lines might not seem like much, they are used as document separators,
    as Ansible compiles all of the YAML files into a single file; more on that later.
    It is important to Ansible to know where one document ends and another begins.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next up, we have the configuration for the playbook. As you can see, this is
    where the indentation starts to come into play:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The `-` tells Ansible that this is the start of a section. From there, key-value
    pairs are used. These are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`hosts`: This tells Ansible the host or host group to target in the playbook.
    This must be defined in a host inventory like the ones we covered in the previous
    section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gather_facts`: This tells Ansible to run the `setup` module when it first
    connects to the host. This information is then available to the playbook during
    the remainder of the run.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`become`: This is present because we are connecting to our host as a basic
    user. In this case, the Vagrant user. Ansible may not have enough access privileges
    to execute some of the commands we are telling it to so this instructs Ansible
    to execute all of its commands as the root user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`become_method`: This tells Ansible how to become the root user; in our case,
    we have a passwordless `sudo` configured by Vagrant so we are using `sudo`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tasks`: These are the tasks we can tell Ansible to run when connected to the
    target host.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You will notice that from here, we move the indentation across again. This
    defines another section of the configuration. This time it is for the tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: As we have already seen, the only task we are running is the `debug` module.
    This module allows us to display output in the Ansible playbook run stream you
    saw when we ran the playbook.
  prefs: []
  type: TYPE_NORMAL
- en: You may have already noticed that the information between the curly brackets
    are the keys from the `setup` module. Here, we are telling Ansible to substitute
    the value of each key wherever we use the key—we will be using this a lot in our
    playbooks. We will also be defining our own key values to use as part of our playbook
    runs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s extend our playbook by adding another task. The following can be found
    as `playbook02.yml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we have added a second task which calls the `yum` module. This
    module is designed to help us interact with the package manager used by CentOS
    and other Red Hat-based operating systems called `yum`. We are setting two key
    values here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`name`: This is a wildcard. It tells Ansible to use all of the installed packages
    rather than just a single named package. For example, we could have just used
    something like HTTPD here to target just Apache.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`state`: Here, we are telling Ansible to ensure the package we have defined
    in the name key is the `latest` version. As we have named all of the installed
    packages, this will update everything we have installed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Run the playbook using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'This will give us the following results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/8b59dcc9-f7f7-4c0f-b30f-21e34df5e69e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `yum` task has been marked as `changed` on the host `box`. This means that
    packages were updated. Running the same command again shows the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/07d0d0b9-b6f0-40aa-8e1c-5f867cb1418a.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the `yum` task is now showing as `ok` on our host. This is because
    there are currently no longer any packages requiring updating.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we finish this quick look at playbooks, let''s do something more interesting.
    The following playbook, called `playbook03.yml`, adds installing, configuring,
    and starting the NTP service to our Vagrant box. It also adds a few new sections
    to our playbook as well as using a template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we work through the additions to our playbook, let''s run it to get
    an idea of the feedback you get from Ansible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the output for the preceding command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/db4b6a60-68a5-4f4f-8fea-3d589806a565.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This time, we have three `changed` tasks. Running the playbook again shows
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/92319ee8-6dec-4398-a651-359b21420272.png)'
  prefs: []
  type: TYPE_IMG
- en: As expected, because we haven't changed the playbook or anything on the Vagrant
    box, there are no changes and Ansible is reporting everything as `ok`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's go back to our playbook and discuss the additions. You will notice that
    we have added two new sections, `vars` and `handlers`, as well as two new tasks,
    a second task which uses the `yum` module and the final task, which utilizes the
    `template` module.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `vars` section allows us to configure our own key-value pairs. In this
    case, we are providing a list of NTP servers, which we will be using later in
    the playbook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we are actually providing four different values for the same
    key. These will be used in the `template` task. We could have also written this
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'However, this is a little more difficult to read. The new next section is `handlers`.
    A handler is a task that is assigned a name and called at the end of a playbook
    run depending on what tasks have changed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'In our case, the `restart ntp` handler uses the `service` module to restart
    `ntpd`. Next up, we have the two new tasks, starting with one which installs the
    NTP service and also the `ntpdate` package using `yum`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: As we are installing two packages, we need a way to provide two different package
    names to the `yum` module so that we don't have to have two different tasks for
    each of the package installations. To achieve this, we are using the `with_items`
    command, as part of the task section. Note that this is in addition to the `yum`
    module and is not part of the module—you can tell this by the indentation.
  prefs: []
  type: TYPE_NORMAL
- en: The `with_items` command allows you to provide a variable or list of items to
    the task. Wherever `{{ item }}` is used, it will be replaced with the content
    of the `with_items` value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final addition to the playbook is the following task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: This task uses the `template` module. To read a template file from our Ansible
    controller, process it and upload the processed template to the host machine.
    Once uploaded, we are telling Ansible to notify the `restart ntp` handler if there
    have been any changes to the configuration file we are uploading.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, the template file is the `ntp.conf.j2` file in the same folder
    as the playbooks, as defined in the `src` option. This file looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The bulk of the file is the standard NTP configuration file, with the addition
    of a few Ansible parts. The first addition is the very first line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: If this line wasn't there every time we ran Ansible, the file would be uploaded,
    which would count as a change and the `restart ntp` handler would be called, meaning
    that even if there were no changes, NTP would be restarted.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next part loops through the `ntp_servers` values we defined in the `vars`
    section of the playbook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'For each of the values, add a line that contains the server, then the value,
    and then `iburst`. You can see the output of this by SSHing into the Vagrant machine
    and opening `/etc/ntp.conf`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the output for the preceding command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/1b5665fd-615b-479b-9087-f1652aa728ec.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see from the preceding screenshot of the fully rendered file, we
    have the comment on the first line noting that the file is managed by Ansible
    and also the four lines containing the NTP servers to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you can check that NTP is running as expected by running the following
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the output for the preceding command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/bf97de68-1d85-49c9-9183-50853e18938f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see from the preceding output, NTP is loaded and running as expected.
    Let''s remove our Vagrant box and launch a fresh one by running the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Then launch the box again by running one of the following two commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the box is up and running, we can run the final playbook with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'After a minute or two, you should receive the results of the playbook run.
    You should see five `changed` and six `ok`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/375b83d8-6fe7-48c7-aece-748000af3802.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Running for the second time will just show five `ok`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/eb40006e-dc8a-43bc-832a-bf17a0dec629.png)'
  prefs: []
  type: TYPE_IMG
- en: The reason why we got six `ok` on the first run and five `ok` on the second
    run is that nothing has changed since the first run. Therefore, the handler to
    restart NTP is never being notified so that task to restart the service never
    executes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have finished with the example playbooks, you can terminate the running
    box using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: We will be using the box again in the following chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have taken our first steps with Ansible by installing locally
    and then, using Vagrant, launching a virtual machine to interact with. We learned
    about basic host inventory files and we used the Ansible command to execute a
    single task against our virtual machine.
  prefs: []
  type: TYPE_NORMAL
- en: We then looked at playbooks, starting out with a basic playbook that returned
    some information on our target before then progressing to a playbook that updates
    all of the installed operating system packages before installing and configuring
    the NTP service.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to take a look at other Ansible commands we
    can use.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the command to install Ansible using `pip`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True or false: You can choose exactly which version of Ansible to install or
    roll back to when using Homebrew.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True or false: The Windows Subsystem for Linux runs in a virtual machine.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name three hypervisors that are supported by Vagrant.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: State and explain what a host inventory is.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True or false: Indentation in YAML files is extremely important to their execution
    and isn''t just cosmetic.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update the final playbook to install a service of your choice and have it notify
    a handler to start the service with its default configuration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we used the following Ansible modules, and you can find out
    more information on each module in the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: '`setup`: [http://docs.ansible.com/ansible/latest/setup_module.html](http://docs.ansible.com/ansible/latest/setup_module.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`debug`[:](http://docs.ansible.com/ansible/latest/setup_module.html) [http://docs.ansible.com/ansible/latest/debug_module.html](http://docs.ansible.com/ansible/latest/debug_module.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`yum`: [http://docs.ansible.com/ansible/latest/yum_module.html](http://docs.ansible.com/ansible/latest/yum_module.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`service`: [http://docs.ansible.com/ansible/latest/service_module.html](http://docs.ansible.com/ansible/latest/service_module.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
