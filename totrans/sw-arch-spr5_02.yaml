- en: Software Architecture Dimensions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, you learned that a software's architecture is made
    up of a team's shared knowledge when building a product or service, as well as
    other important aspects surrounding this concept. An architect's job is to share
    this knowledge with the entire team. Even when a team doesn't have somebody assigned
    to the specific role of the architect, individuals often end up becoming responsible
    for the system's architecture.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will review software architecture dimensions and how they
    influence our applications. We will also introduce a model for documenting software
    architectures and making the process of sharing and understanding an architecture
    less difficult for teams. Ultimately, this will allow them to understand the bigger
    picture of software architecture.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics and subtopics:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Software architecture dimensions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Business dimension
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data dimension
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical dimension
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operations dimension
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The C4 model:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Context diagram
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Container diagram
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Components diagram
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class diagram
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dimensions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'According to Google, the word *dimension* has a few meanings. Let''s use the
    following definition, which fits into the context that we will discuss in this
    section:'
  prefs: []
  type: TYPE_NORMAL
- en: '"An aspect or feature of a situation, problem, or thing."'
  prefs: []
  type: TYPE_NORMAL
- en: Starting with this definition, we will consider dimensions as the aspects or
    features that will influence and guide the software architectures that we build.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapter, we talked about the importance of understanding the
    business domain when crafting our solutions. Of course, this knowledge is not
    enough when it comes to generating a system that is able to address all business
    needs. You will also need to think about the mechanisms for supporting these solutions
    from a technical viewpoint, without forgetting the business requirements. As technical
    people, we need to provide a solution that can evolve with the passage of time,
    in order to accomplish new business needs and efficiently achieve goals.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following list is comprised of the most common dimensions in the process
    of crafting a software architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: Business
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Depending on the context of the solution that you are working on, you can add
    some extra points to this list. These four dimensions are highly connected when
    you are looking at a product from a technical viewpoint, and they should be understood
    by the whole team in charge of the system.
  prefs: []
  type: TYPE_NORMAL
- en: The business dimension
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is the most crucial aspect to consider when we are building software,
    and that''s why the software industry has been inventing new ways to collect requirements.
    Within this dimension, two relevant activities should be accomplished efficiently,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Managing user requirements and gaining a clear idea about the domain model of
    the business
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identifying and tracking business metrics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing user requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some years ago, we used to write use cases, which have been renamed as **user
    stories** in the last few years. However, the names are not the key to success
    here, and it makes no difference whether you are using old-fashioned methods (such
    as the **Ration Unified Process** (**RUP**) or the most cutting-edge frameworks
    (such as Scrum) to build your projects. Understanding the domain of the business
    and owning a product will allow teams to develop successful projects.
  prefs: []
  type: TYPE_NORMAL
- en: As you probably know, RUP is a software development framework that defines a
    set of phases and has a tremendous amount of documentation associated with each
    stage. The idea here is to determine what artifacts to generate at each stage.
    This task is tedious, and teams have often ended up defining a large quantity
    of useless and time-consuming documentation, without providing any added value
    to the product. As an alternative to creating documentation, we will discuss the
    C4 model later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Over time, many books have been written to explain how to manage user requirements.
    Two of these include *Writing Effective Use Cases* by Alistair Cockburn and *User
    Stories Applied* by Mike Cohn. These books are the most relevant, and you should
    consider reading them and making them a part of your library, in order to use
    them as a reference source whenever necessary.
  prefs: []
  type: TYPE_NORMAL
- en: An efficient process for gathering user requirements should be a part of the
    vision and the goals that the project should accomplish. Having brainstorming
    meetings with as many people involved in the project as possible is beneficial
    for allowing the team in charge of the software implementation to distinguish
    between the **Minimum Viable Product** (**MVP**) and the desired and expendable
    features that will be implemented as part of a new release once the MVP version
    has been accomplished.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the MVP for the software under construction is paramount; it should
    give you the minimum features possible to satisfy the user requirements. Once
    these features are identified, it is also necessary to define the acceptance criteria
    for them. The products built from here will be used as the base for retrieving
    feedback from the business people (in order to correct any misconceptions) and
    also to add new features (in order to grow the solution).
  prefs: []
  type: TYPE_NORMAL
- en: Today, we also count on bug tracking systems to write user requirements as tickets
    with different classifications, such as bugs, user stories, and spikes, among
    others. These tickets are used to gain a better understanding of how long a feature
    takes to be implemented, and how many bugs are involved in it.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with business requirements in this way gives us useful information that
    can be analyzed later, in order to improve the performance of a team, as well
    as the way it is organized. There are a bunch of explanations of how to manage
    tickets, but if you want a better idea of the principles of bug tracking, I encourage
    you to read a useful article written by Yegor Bugayenko, which is available at [http://www.yegor256.com/2014/11/24/principles-of-bug-tracking.html](http://www.yegor256.com/2014/11/24/principles-of-bug-tracking.html).
  prefs: []
  type: TYPE_NORMAL
- en: Identifying and tracking business metrics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once the business requirements have been collected, another part of the business
    dimension emerges, including a way to identify the essential metrics around the
    business problems that you're solving. These metrics should be determined and
    expressed concerning the business domain, in order to understand how well an application
    addresses the business requirements that it was designed for.
  prefs: []
  type: TYPE_NORMAL
- en: Let's revisit an example that we used in the previous chapter. Suppose that
    the bank is currently using the post office to send monthly bank statements to
    its clients. In this case, you know a priori, how much money it costs, and the
    tasks involved in accomplishing the goal. In addition, you even know how many
    clients you have and how much paper should be printed, according to specific dates.
    After the implementation of your system, you will want to know that all of your
    clients are receiving their bank statements. Consequently, you will want to implement
    a mechanism to identify how many bank statements are being sent by the application,
    and which notification channels are preferred. This information will be used in
    the near future, in order to identify new business opportunities, discover when
    the system has problems, and monitor the ROI of the application. After all, the
    implementation of a system is guided by a business's needs, and you have to verify
    that those needs are met.
  prefs: []
  type: TYPE_NORMAL
- en: Once the application is in production, an excellent technique for assessing
    the business health of your application in the wild is to build bots. These bots
    exercise your application as a regular user; you'll want to at least create bots
    around the most important functionalities of your application. If not, how will
    you know if your application is working?
  prefs: []
  type: TYPE_NORMAL
- en: This goal can be achieved by executing scheduled checks that will send you notifications
    with the obtained results. This simple technique will give you confidence that
    the application is working as expected, and is providing a service to your clients—who
    are the purpose of the system.
  prefs: []
  type: TYPE_NORMAL
- en: The data dimension
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data is considered one of the most critical assets of any business, and that
    is why you have to invest a considerable amount of time in figuring out the best
    approach for dealing with it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Nowadays, we have many options when it comes to choosing our approach to data.
    In the last few years, many kinds of databases and data storage have been created,
    including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: File cloud storage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Relational databases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Document-oriented databases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Real-time databases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Graph databases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In-memory databases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your choice should depend on the problem that you're solving, and not on the
    option used by influential online companies, such as Facebook, Google, and Amazon.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that different business requirements require different methods of approach.
  prefs: []
  type: TYPE_NORMAL
- en: You may now be wondering what kind of data storage you should choose*.* The
    most common answer to that question is that it depends on the context.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, a dependence on the context may not be the ideal answer here, as it
    does not provide you with much guidance. With this in mind, the best advice that
    can be given is to try to make as many analogies as you can, in order to figure
    out the best data storage method for you. One consideration to bear in mind is
    this: don''t get scared because of the eventual consistency inherent in NoSQL
    databases. I have seen a lot of people get rid of this kind of database for that
    reason. You have to understand that eventual consistency is not a technical concern
    at all, but a business one. Let me explain why.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Considering the example presented in [Chapter 1](21088489-d3dd-4c4d-8969-ac7ec0844132.xhtml),
    *Software Architecture Today*, assume that you have been tasked with implementing
    a new feature in a system with the following description:'
  prefs: []
  type: TYPE_NORMAL
- en: '"We noticed that the notification channels do not always work as expected,
    and we decided to use an alternative channel when this happens. For example, if
    the user has configured the email as the preferred channel, then the SMS channel
    should be used if it fails. On the other hand, if the user has configured SMS
    as the preferred notification channel, the email notification should be used as
    an alternative if it fails."'
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that this requirement doesn''t follow the standard user story format:'
  prefs: []
  type: TYPE_NORMAL
- en: '"As a < type of user >, I want < a goal > so that < reason >..."'
  prefs: []
  type: TYPE_NORMAL
- en: However, the requirements are easy to understand and implement for the team
    in charge of working on them. For that reason, I mentioned earlier that even if
    you're still working with use cases or user stories, the matter of business requirements
    is the most important aspect.
  prefs: []
  type: TYPE_NORMAL
- en: An example of where eventual consistency is not a big deal is with the ordering
    of Facebook posts, in which each post is timestamped. Here, when a person adds
    a comment to a post, they think that they are seeing the last comment above theirs,
    but a few seconds later, they see that other comments did, indeed, get added before
    their comment. When this happens, it can be confusing. However, not imposing atomicity
    requirements on the comment order allows Facebook to scale the database globally,
    covering millions of posts per second. In contrast, it is important that a money
    transferring transaction require atomic transactions, in order to maintain consistency
    and avoid fraud or wasting money.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, you first have to understand the business requirement that you want
    to accomplish, make as many analogies as you can with the options available on
    the market, and then, make your choice from those options. Once your decision
    has been made, it's always worth counting on frameworks that will allow you to
    interact with the data storage of your choice. Fortunately, Spring Data supports
    a bunch of data storage options. We will discuss the benefits of using this Spring
    project in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The technical dimension
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This dimension involves deeply exploring technical details. Let''s discuss
    some useful questions that you will have to answer in order to accomplish this
    goal, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: What style of software architecture should I choose?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Currently, there are many options for this. Subsequent chapters of this book
    will explain many of them in detail, and you'll probably find your answers there.
  prefs: []
  type: TYPE_NORMAL
- en: What programming language is right for my application?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many programming languages in the market promise to be the best. For that reason,
    you have to avoid choosing one just because it's the newest or the latest one.
    Instead, you must choose a widely known one that suits you.
  prefs: []
  type: TYPE_NORMAL
- en: The possibility of counting on a vast ecosystem of tooling is always essential,
    and should be part of your decision. Another part of your decision should be how
    difficult it is to find people to work with. It is unlikely that you will want
    to build your software using a programming language that not many people are familiar
    with. After all, you'll want to create an application that will live for a long
    time, and this implies that many people will be involved in writing code to make
    it evolve over time.
  prefs: []
  type: TYPE_NORMAL
- en: Since this book is intended to be focused on the Spring platform, I'll be discussing
    the benefits of using Java and the **Java Virtual Machine** (**JVM**).
  prefs: []
  type: TYPE_NORMAL
- en: We all know that Java is a widely supported programming language that has been
    used to build tons of enterprise applications; this fact gives us the confidence
    to say that it's mature enough to write almost any kind of enterprise software.
    On the other hand, the JVM is built on the premise of *write once, run anywhere.*
    This is important, because a significant part of enterprise applications are currently
    running on Linux servers; however, this doesn't mean that you need to force your
    team to use Linux. Instead, they can keep using their preferred OS, since the
    JVM can run on Windows, Linux, and Mac.
  prefs: []
  type: TYPE_NORMAL
- en: Over the last few years, many programming languages have been written and widely
    adopted to solve different kinds of problems. Many of them run on JVMs, such as
    Scala, Groovy, Kotlin, and Jython, because of the benefits that this offers. All
    of the compiled code of these programming languages check into bytecode, which
    can interact with Java code, introducing a new world of opportunities. It's always
    a good idea to give new programming languages a try, to see how they work in different
    scenarios, and to accomplish different demands. For example, Groovy is a friendly
    programming language that is simple and easy to use. In subsequent chapters, we
    will develop some example applications using different programming languages that
    run on the JVM. These examples will help you to embrace Groovy as a part of your
    toolbox.
  prefs: []
  type: TYPE_NORMAL
- en: What framework is right for me?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Even when a massive list of frameworks crowds the Java world, we encourage
    you to use Spring, not only because this book is about it, but because it offers
    the following benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: Many of the programming languages listed previously are supported
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring offers the chance to build almost any kind of application that you want
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The learning curve is not a big deal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has great support for unit and integration testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring projects make it possible to grow your solution (we will discuss these
    in the next chapter)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has excellent integration with the IDE of your choice
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has a great community
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tons of resources to learn about Spring are available on the internet
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It provides for smooth integration with the most common Java frameworks, such
    as Hibernate, iBatis, Atomikos, Vaadin, and Thymeleaf
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If this list is not enough for you, feel free to type "*why should I use Spring*"
    into Google; you will get a pleasant surprise, and will have the confidence to
    use the Spring framework.
  prefs: []
  type: TYPE_NORMAL
- en: The operations dimension
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This dimension refers to mapping your architecture components to servers. These
    servers can live on-premise or in the cloud. The cloud has been becoming increasingly
    important over the past few years, and now, we can say that it's almost vital
    for every single business to count on services on the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: The mapping of your software architecture components will depend on what they
    do and how the interaction occurs among your components.
  prefs: []
  type: TYPE_NORMAL
- en: How to deploy an application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This point is crucial because deploying a Rest API is not the same as deploying
    a distributed database or a big monolith application. In order to have a better
    understanding of the best approach for deploying a component, you will need to
    research the products supporting it. This can be quite simple; for example, by
    deploying a Spring Boot application that can run like a conventional Java application
    using the following widely-known command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: However, in other cases, some products offer the chance to be deployed as clusters,
    where you will need to consider all of the options available and what your needs
    are. Depending on how in-demand your software is, you will need to have fewer
    or more nodes serving your users' demands. As you have probably noticed, even
    this dimension is derived from the business.
  prefs: []
  type: TYPE_NORMAL
- en: How interaction occurs among your components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's imagine that we have a regular web application persisting information
    in a database. This web application is deployed in server A, and the database
    is deployed in server B. Common sense leads us to realize that the latency won't
    be the same, whether both servers are located in the same or different data centers.
    Another consideration is, of course, where the end users are located. Today, the
    cloud offers the chance to choose where you want to deploy your components, depending
    on your needs, which is helpful when it comes to providing a better user experience.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with infrastructure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once these points have been considered, another aspect to bear in mind is how
    to manage the infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: 'We all know that provisioning new servers is always a headache when we need
    to start from scratch because we will need to install the OS and all of the required
    tooling to make our application work. Some of these require specific files, directories,
    environmental variables, and other artifacts in order to work, which makes this
    process even more complicated. Fortunately, the Infrastructure as Code approach,
    discussed in the following section, will help us reduce the effort of provisioning
    new servers, and will give us other benefits, such as the following points:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the infrastructure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Versioning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the infrastructure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Files are used to store the required configuration and steps needed to provision
    a server in the form of executable scripts. When a new adjustment to an existing
    server is necessary, the idea is to make these changes using the script files,
    instead of directly on the server. This will allow us to get the following benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: Immutable servers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easy application of changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Having more than one identical server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rebuilding a new server from scratch very quickly, without errors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moreover, technical people will be able to read and understand these scripts,
    allowing for an increase of shared understanding around the process of provisioning
    new infrastructure, which is excellent.
  prefs: []
  type: TYPE_NORMAL
- en: Versioning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Keeping the written scripts versioned using a **Version Control System** (**VCS**)
    will allow us to track changes in the script files; this is helpful for increasing
    the audibility of the written code that is being used to shape your infrastructure.
    During the versioning process, builds can (and should) be triggered to validate
    the written code.
  prefs: []
  type: TYPE_NORMAL
- en: Another benefit of versioning is that you can revert changes when needed. Imagine
    that you are writing code to make upgrades to your servers; if an issue is introduced
    during this process, you can always make a rollback and keep using the last stable
    version while the problem is solved.
  prefs: []
  type: TYPE_NORMAL
- en: Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is no way of knowing whether something is working as expected if it has
    not been tested. Treating the Infrastructure as Code offers us the ability to
    test the code used to accomplish this goal, to validate and be sure that it works
    as expected. Otherwise, you will need to do these validations manually, and think
    about the debugging process involved at this level to identify where the errors
    are. Even when you could have Infrastructure as Code without testing, it's highly
    recommended to run tests on the scripts that have been created.
  prefs: []
  type: TYPE_NORMAL
- en: Embracing the Infrastructure as Code approach will help us to take full advantage
    of computers and systems, in order to make the process less tedious for us, and
    people should only be working in front of a data center when an issue occurs.
    This will also help you to keep your infrastructure up to date in a quick and
    easy manner. If you want an in-depth understanding of how to embrace this approach
    effectively, I encourage you to read the *Infrastructure as Code* book by Kief
    Morris.
  prefs: []
  type: TYPE_NORMAL
- en: Cloud versus on-premise
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The choice between using servers on the cloud and using them on-premise is a
    big decision, governed by the restrictions and needs of your business. For security
    reasons, some companies are restricted to use on-premise infrastructures, which
    is probably due to a misconception about how security is managed in the cloud.
    Regardless, this restriction invalidates any attempt to move the infrastructure
    to the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, if you have the chance to choose between these two options,
    I encourage you to use the cloud. It offers many benefits, such as pay as you
    go, which will allow you to save a significant amount of money during the first
    releases of your application. Some services charge you a few cents per hour, depending
    on what you need and the licensing model of the software that you use. For example,
    using free and proprietary software is not the same as using a server with Windows
    or Linux. In the same way, it is not the same as using an RDBMS, such as MariaDB
    or Oracle.
  prefs: []
  type: TYPE_NORMAL
- en: Even when you made the choice to use the cloud, there are a few considerations
    that you need to bear in mind in order to choose the right cloud provider for
    you, according to the set of features required. Some cloud providers, like AWS,
    provide a bunch of services for computing, storage, management tools, analytics,
    and so on, while others, like Heroku, offer a lower quantity of features that
    are good enough, depending on your demands. It isn't a good idea to choose a provider
    just because it gives you more services, because this also implies a higher cost.
    Even when the number of services provided by different vendors is similar, the
    simplicity of the process of deploying an application using the providers mentioned
    earlier is significant.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying your application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is no point in writing code that won't be brought to production. Regardless
    of whether you deploy your application to the cloud or in your on-premise environment,
    you can use some techniques and tools to automate the deployment process. This
    will help you to reduce the amount of effort required.
  prefs: []
  type: TYPE_NORMAL
- en: During the deployment process of a software system some years ago, the whole
    team writing the application had to sit with the operations team, just in case
    something went wrong. Consequently, the deployment date used to be scary for both
    technical and business people involved in the project. Fortunately, this has changed.
    Let's review how this change occurred.
  prefs: []
  type: TYPE_NORMAL
- en: 'Automation is a must when we are entering this field. There are many CI tools
    available for creating pipelines that will help you to automate deployments. The
    most widely used of these are Jenkins, Travis CI, Go CD, Codeship, and Bamboo,
    among others. With the help of these tools, you can create a pipeline that often
    involves the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Downloading the source code
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compiling the code
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Running a defined set of tests
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Deploying the code
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The main step is the third one, which involves different sorts of tests, such
    as those listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integration tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functional tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The more tests you include as a part of your application, the more confidence
    you'll gain. This is the only way to get rid of the fear caused by deployment.
    After all, if your tests verify that the functionality is working as expected,
    there is no reason to be worried about the deployment.
  prefs: []
  type: TYPE_NORMAL
- en: These CI tools also include support for sending notifications about the pipelines,
    generating metrics around the code, executing configuration scripts, and completing
    some other steps inherent to deployment. These pipelines are often triggered by
    commits, and they can also be scheduled.
  prefs: []
  type: TYPE_NORMAL
- en: The adoption of a CI tool is the first step toward automating and managing your
    deployments in a better way. At this point, you will want to adopt practices like
    Continuous Integration, Continuous Delivery, and DevOps, which we will explain
    in depth in [Chapter 11](81e880b2-2345-4231-b7d5-d558f3c55955.xhtml), *DevOps
    and Release Management*.
  prefs: []
  type: TYPE_NORMAL
- en: The C4 model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In general, if something is not visible, it won't provide the desired effect.
    Even the most advanced software, produced with the most cutting-edge technology,
    is entirely useless if the team that works on it is unable to understand it. All
    of the efforts applied by the team will be a waste of time.
  prefs: []
  type: TYPE_NORMAL
- en: Simply designing a software architecture isn't enough. It has to be shared with
    the whole team in a way that allows them to use it correctly when fulfilling their
    activities. The documentation made by the architects speaks for them today, when
    they should be doing things other than answering a hundred questions about software
    architecture, and it speaks for them tomorrow when they have left the project
    and someone else is in charge of its evolution and maintenance.
  prefs: []
  type: TYPE_NORMAL
- en: The second principle of the agile manifesto ([http://agilemanifesto.org](http://agilemanifesto.org))
    is that *"teams should value working software over comprehensive documentation."*
    This is often interpreted incorrectly by people believing that no documentation
    should be produced at all. Instead, the idea behind this principle is to encourage
    teams to only produce valuable documentation, and that's precisely what the C4
    model looks for.
  prefs: []
  type: TYPE_NORMAL
- en: 'This model provides an easy way to communicate the design of the system to
    the whole team. It starts from a high-level viewpoint, and it can be used to delve
    into the smallest details of the software that is (or will be) produced. This
    model proposes four diagrams, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Context diagram
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Container diagram
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Components diagram
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class diagram
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Context diagram
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The context diagram provides the big picture of the users and the other software
    systems that it interacts with. All technical elements should be avoided in order
    to keep it simple and easy to understand. A context diagram should be straightforward
    enough to be understood by non-technical people.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following shows a diagram contextualized for the example proposed in [Chapter
    1](21088489-d3dd-4c4d-8969-ac7ec0844132.xhtml), *Software Architecture Today*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f9f07d90-6234-4717-8ece-91c6d7a0f6b5.png)'
  prefs: []
  type: TYPE_IMG
- en: Context diagram
  prefs: []
  type: TYPE_NORMAL
- en: Container diagram
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Containers are units that are in charge of hosting code or data. Consequently,
    this diagram shows the containers involved in the application, providing high-level
    details about how they interact with each other, as well as some other technical
    details to illustrate how the system works. Let''s look at this diagram as it
    applies to our example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/97eb6c40-48dc-421f-8af1-944c89457b3a.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Container diagram
  prefs: []
  type: TYPE_NORMAL
- en: Components diagram
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The idea behind this diagram is to show you how a container is shaped by components
    and the interactions among them. The components diagram for our example is as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/68a82b05-a0b8-4057-8590-d0241b11fb8d.png)'
  prefs: []
  type: TYPE_IMG
- en: Components diagram
  prefs: []
  type: TYPE_NORMAL
- en: Class diagram
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since the main idea behind the C4 model is to remove unnecessary diagrams, the
    class diagram should be avoided, and should only be used when it's vital to illustrate
    specific details of an application. This diagram is intended for technical people,
    and it can be used when there is an element of your application that people should
    pay close attention to; it can also be used to clarify some specific parts in
    the code that might cause confusion.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although this diagram is not necessary for our example, we will show it for
    illustrative purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1ec2b9eb-4079-400a-a4b4-00b7927cf7f0.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Class diagram
  prefs: []
  type: TYPE_NORMAL
- en: As you may have noticed, the four diagrams that we have presented are not difficult
    to create, and they are helpful when it comes to acquiring a better understanding
    of a system. Even when they are simple, it's always a good idea to review these
    diagrams from time to time to ensure that they are updated. Outdated documentation
    can lead to misconceptions, instead of improving the understanding of the system.
  prefs: []
  type: TYPE_NORMAL
- en: Feel free to avoid creating any diagrams that you do not find helpful. Investing
    time in building unnecessary artifacts is something that you should avoid.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed the four main dimensions associated with software
    architecture and looked at how they affect the way we build our applications.
    We also reviewed the C4 model that's used to document system architectures, using
    a lean approach that helps us to avoid wasting time in creating unnecessary documentation.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will review Spring Projects and how they can be used
    to create applications that satisfy different business demands.
  prefs: []
  type: TYPE_NORMAL
