- en: Chapter 7. Higher Order and Compile-time Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。高阶和编译时编程
- en: A number of Standard Library algorithms take callable entities called **function
    objects** (function pointers, functors, and so on) as parameters. They call these
    function objects on individual elements of containers to compute some value or
    perform some action. Thus, a part of the runtime logic of the algorithm is encapsulated
    in a function or functor and supplied as an argument to the algorithm. A function
    may also return function objects instead of data values. The returned function
    object can be applied on a set of parameters and may in turn return either a value
    or another function object. This gives rise to higher order transforms. This style
    of programming involving passing and returning functions is called **higher order
    programming**.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 许多标准库算法接受可调用实体，称为**函数对象**（函数指针、函数符等）作为参数。它们调用这些函数对象来计算容器中的各个元素的某个值或执行某些操作。因此，算法的一部分运行时逻辑被封装在一个函数或函数符中，并作为算法的参数提供。函数也可以返回函数对象而不是数据值。返回的函数对象可以应用于一组参数，并可能反过来返回一个值或另一个函数对象。这就产生了高阶变换。这种涉及传递和返回函数的编程风格称为**高阶编程**。
- en: C++ templates enable us to write type generic code. Using templates, it is possible
    to execute branching and recursive logic at compile time and conditionally include,
    exclude, and generate code from simpler building blocks. This style of programming
    is called **compile-time programming** or **template metaprogramming**.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: C++模板使我们能够编写类型通用的代码。使用模板，可以在编译时执行分支和递归逻辑，并根据简单的构建块条件地包含、排除和生成代码。这种编程风格称为**编译时编程**或**模板元编程**。
- en: 'In the first part of this chapter, we will learn the applications of higher
    order programming in C++ using the Boost Phoenix Library and C++11 facilities
    like bind and lambda. In the next part of this chapter, we will learn C++ template
    metaprogramming techniques that execute at compile time to help generate more
    efficient and expressive code. In the last part of this chapter we look at domain-specific
    languages created within C++ by applying higher order programming techniques in
    combination with metaprogramming. The topics of this chapter are divided into
    the following sections:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的第一部分，我们将学习使用Boost Phoenix库和C++11的绑定和lambda等设施在C++中应用高阶编程的应用。在本章的下一部分，我们将学习C++模板元编程技术，这些技术在编译时执行，帮助生成更高效和更具表现力的代码。在本章的最后一部分，我们将通过将高阶编程技术与元编程相结合，在C++中创建领域特定语言。本章的主题分为以下几个部分：
- en: Higher order programming using Boost
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Boost进行高阶编程
- en: Compile-time programming using Boost
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Boost进行编译时编程
- en: Domain Specific Embedded Languages
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 领域特定嵌入式语言
- en: In this chapter, we will explore an alternate paradigm of programming, which
    is different from object-oriented and procedural programming and draws heavily
    from functional programming. We will also develop generic programming techniques
    that ultimately help us implement more efficient template libraries.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将探讨一种与面向对象和过程式编程不同的编程范式，它大量借鉴了函数式编程。我们还将开发通用编程技术，最终帮助我们实现更高效的模板库。
- en: Higher order programming with Boost
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Boost进行高阶编程
- en: 'Consider a type `Book` with three string fields: the ISBN, title, and author
    (for our purposes, assume that there is only one author). Here is how we can choose
    to define this type:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个类型`Book`，它有三个字符串字段：ISBN、标题和作者（对于我们的目的，假设只有一个作者）。以下是我们可以选择定义这种类型的方式：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: It is a `struct` with three fields and a constructor that initializes these
    three fields. The `isbn` field uniquely identifies the book and therefore is used
    to define an ordering of `Book` objects, using the overloaded `operator<` (line
    14).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 它是一个带有三个字段和一个构造函数的`struct`，用于初始化这三个字段。`isbn`字段唯一标识书籍，因此用于定义`Book`对象的排序，使用重载的`operator<`（第14行）。
- en: 'Now imagine that we have a list of these `Book` objects in a `std::vector`,
    and we want to sort these books. Thanks to the overloaded `operator<`, we can
    easily sort them using the Standard Library `sort` algorithm:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设我们有一个`std::vector`中的这些`Book`对象的列表，并且我们想对这些书籍进行排序。由于重载的`operator<`，我们可以轻松地使用标准库的`sort`算法对它们进行排序：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the preceding code, we put four `Book` objects in the vector `books`. We
    do this by calling the `emplace_back` method (lines 11-18) rather than `push_back`.
    The `emplace_back` method (introduced in C++11) takes the constructor arguments
    for the stored type (`Book`) and constructs an object in the vector's layout rather
    than copying or moving in a pre-constructed object. We then sort the vector using
    `std::sort`, which ultimately uses the `operator<` for `Book` objects. Without
    this overloaded operator, `std::sort` would have failed to compile.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们将四个`Book`对象放入向量`books`中。我们通过调用`emplace_back`方法（第11-18行）而不是`push_back`来实现这一点。`emplace_back`方法（在C++11中引入）接受存储类型（`Book`）的构造函数参数，并在向量的布局中构造一个对象，而不是复制或移动预先构造的对象。然后我们使用`std::sort`对向量进行排序，最终使用`Book`对象的`operator<`。如果没有这个重载的运算符，`std::sort`将无法编译。
- en: This is all great, but what if you wanted to sort the books in descending order
    of the ISBN? Or you could want to sort the books by their authors instead. Also,
    for two books with the same author, you might want to sort them further by their
    title. We will see a method to sort them this way in the next section.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切都很好，但如果您想按ISBN的降序对书籍进行排序怎么办？或者您可能想按作者对书籍进行排序。此外，对于两本具有相同作者的书，您可能希望进一步按标题对它们进行排序。我们将在下一节中看到一种按这种方式对它们进行排序的方法。
- en: Function objects
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数对象
- en: 'There is a three-argument overload of `std::sort` algorithm that takes a function
    object for comparing two elements as the third argument. This function object
    should return true if the first argument appears before the second argument in
    the final ordering and false otherwise. So, even without an overloaded `operator<`,
    you can tell `std::sort` how to compare two elements and sort the vector. Here
    is how we do the sorting using an ordering function:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::sort`算法有一个三参数重载，第三个参数是一个用于比较两个元素的函数对象。这个函数对象应该在最终排序中如果第一个参数出现在第二个参数之前则返回true，否则返回false。因此，即使没有重载`operator<`，你也可以告诉`std::sort`如何比较两个元素并对向量进行排序。以下是使用排序函数进行排序的方法：'
- en: '**Listing 7.1: Passing functions to algorithms**'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单7.1：将函数传递给算法**'
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The function `byDescendingISBN` takes const references to two books and returns
    true if the ISBN of the first book (`lhs`) is lexically greater than that of the
    second (`rhs`) and false otherwise. The signature of the function compatible with
    the function object that `std::sort` algorithm expects as its third argument.
    To sort the `books` vector in descending order, we pass to `std::sort`, a pointer
    to this function (line 7).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`byDescendingISBN`接受两本书的const引用，并在第一本书的ISBN（`lhs`）在字典顺序上大于第二本书（`rhs`）的ISBN时返回true，否则返回false。该函数的签名与`std::sort`算法期望的函数对象兼容。为了按降序对`books`向量进行排序，我们将指向这个函数的指针传递给`std::sort`（第7行）。
- en: 'Function pointers are by no means the only callable entities you can pass around.
    A *functor* is a type that overloads the function call operator member (`operator()`).
    By applying or calling an instance of a functor on a set of arguments, you invoke
    the overloaded `operator()` member. In the following example, we define a functor
    to order books by author names, and in case of a tie with author names, by titles:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 函数指针绝不是你可以传递的唯一可调用实体。*函数对象*是一种重载了函数调用运算符成员（`operator()`）的类型。通过在一组参数上应用或调用函数对象的实例，你调用了重载的`operator()`成员。在下面的例子中，我们定义了一个函数对象来按作者名对书籍进行排序，如果作者名相同，则按标题排序：
- en: '**Listing 7.2: Defining and passing functors to algorithms**'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单7.2：定义和传递函数对象给算法**'
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We define a functor called `CompareBooks` with an overloaded `operator()` that
    takes two `Book` objects to compare (line 4). It returns true if the name of the
    first book's author is lexicographically smaller than the name of second book's
    author. In case the authors of the two books are same, it returns true if the
    title of the first book is lexicographically smaller than that of the second.
    To use this functor as the sorting criterion, we pass a temporary instance of
    `CompareBooks` as the third argument of the `std::sort` algorithm (line 14). Functors
    like `CompareBooks`, that map one or more arguments to a Boolean truth value are
    called **predicates**.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个名为`CompareBooks`的函数对象，它重载了`operator()`，接受两个要比较的`Book`对象（第4行）。如果第一本书的作者名在字典顺序上小于第二本书的作者名，则返回true。如果两本书的作者相同，则如果第一本书的标题在字典顺序上小于第二本书的标题，则返回true。为了将这个函数对象作为排序标准使用，我们将`CompareBooks`的临时实例作为`std::sort`算法的第三个参数传递（第14行）。像`CompareBooks`这样将一个或多个参数映射到布尔真值的函数对象被称为**谓词**。
- en: Tip
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**A note on terminology**'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**术语说明**'
- en: We use the term **function object** to refer to all callable entities that can
    be passed around and stored for later use by the application. These include function
    pointers and functors as well as other kinds of callable entities like unnamed
    functions or **lambdas**, which we will explore in this chapter.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用术语**函数对象**来指代所有可调用的实体，可以在应用程序中传递和存储以供以后使用。这些包括函数指针和函数对象，以及其他类型的可调用实体，如未命名函数或**lambda**，我们将在本章中探讨。
- en: A **functor** is simply a class or struct that defines an overloaded function
    call operator.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**函数对象**简单地是定义了重载的函数调用运算符的类或结构。'
- en: A function object that takes one or more arguments and maps them to a Boolean
    truth value is usually called a **predicate**.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 一个接受一个或多个参数并将它们映射到布尔真值的函数对象通常被称为**谓词**。
- en: The **arity** of a function object is the number of arguments it takes. A function
    with no arguments has 0-arity or is **nullary**, a function with one argument
    has 1-arity or is **unary**, a function with two arguments has 2-arity or is **binary**,
    and so on.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 函数对象的**arity**是它所接受的参数数量。没有参数的函数具有0-arity或者是**nullary**，一个参数的函数具有1-arity或者是**unary**，两个参数的函数具有2-arity或者是**binary**，依此类推。
- en: A **pure function** is a function whose return value depends solely on the values
    of the arguments passed to it and which has no side effects. Modifying states
    of objects not local to the function, performing I/O, or otherwise modifying the
    execution environment—all qualify as side effects.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**纯函数**是一个其返回值仅取决于传递给它的参数值，并且没有副作用的函数。修改不属于函数的本地状态，执行I/O，或者以其他方式修改执行环境都属于副作用。'
- en: 'Functors are especially useful when you want them to retain some state between
    calls. For example, imagine you have an unsorted list of names, and you just want
    to make a comma-separated list of all names, starting with a particular letter.
    Here is a way to do this:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当你希望函数对象在调用之间保留一些状态时，函数对象特别有用。例如，想象一下你有一个未排序的名字列表，你只想制作一个以特定字母开头的所有名字的逗号分隔列表。以下是一种方法：
- en: '**Listing 7.3: Functors with states**'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单7.3：带状态的函数对象**'
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We define a functor called `ConcatIfStartsWith` (line 6), which stores some
    state, namely the starting character to match (`startCh`) and a string to contain
    the comma-separated list of names (`csNames`). When the functor is invoked on
    a name, it checks whether it starts with the specified character, and if so, concatenates
    it to `csNames` (lines 10-11). We use the `std::for_each` algorithm to apply the
    `ConcatIfStartsWith` functor to each name in a vector of names (lines 30-31),
    looking for names starting with the letter G. The functor we pass is a temporary
    one (line 31), but we need a reference to it in order to access the concatenated
    string stored in it. The `std::for_each` algorithm actually returns a reference
    to the passed functor, which we then use to get the concatenated string. Here
    is the output, listing the names starting with G:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个名为`ConcatIfStartsWith`的函数对象（第6行），它存储一些状态，即要匹配的起始字符（`startCh`）和包含逗号分隔的名称列表的字符串（`csNames`）。当在名称上调用函数对象时，它会检查名称是否以指定字符开头，如果是，则将其连接到`csNames`（第10-11行）。我们使用`std::for_each`算法将`ConcatIfStartsWith`函数对象应用于名称向量中的每个名称（第30-31行），寻找以字母G开头的名称。我们传递的函数对象是一个临时的（第31行），但我们需要一个引用来访问其中存储的连接字符串。`std::for_each`算法实际上返回对传递的函数对象的引用，然后我们使用它来获取连接的字符串。这是输出，列出以G开头的名称：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This illustrates an important point about functors; they are particularly useful
    when you want to maintain state that persists between successive calls to the
    function. They are also great if you need to use them at multiple places in your
    code. By naming them intuitively, their purpose can be made evident at the point
    of use:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这说明了关于函数对象的一个重要观点；当您希望在连续调用函数之间保持状态时，它们特别有用。如果您需要在代码中的多个地方使用它们，它们也非常有用。通过直观地命名它们，可以在使用的地方清楚地表明它们的目的：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: But sometimes, what a functor needs to do is trivial (for example, to check
    whether a number is even or odd). Often, we don't need it to maintain any state
    between calls. We may not even need to use it at multiple places. Sometimes, the
    functionality we are looking for may already be there in some form, maybe as a
    member function of the objects. In such cases, writing a new functor seems like
    overkill. C++11 introduced lambdas or unnamed functions to address precisely such
    cases.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 但有时，一个函数对象需要做的事情是微不足道的（例如，检查一个数字是偶数还是奇数）。通常，我们不需要在调用之间维护任何状态。我们甚至可能不需要在多个地方使用它。有时，我们正在寻找的功能可能已经以某种形式存在，也许作为对象的成员函数。在这种情况下，编写一个新的函数对象似乎有些过度。C++11引入了lambda或未命名函数，以精确解决这种情况。
- en: Lambdas – unnamed function literals
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Lambda - 未命名函数文字
- en: The character string `"hello"` is a valid C++ expression. It has a well-defined
    type (`const char[6]`), can be assigned to variables of type `const char*`, and
    passed to functions that take arguments of type `const char*`. Likewise, there
    are numeric literals like `3.1415` or `64000U`, Boolean literals like `true` and
    `false`, and so on. C++11 introduces **lambda expressions** for generating anonymous
    functions defined at the site, where they are invoked. Often, simply called **lambdas**
    (from Alonzo Church's λ-calculus), they consist of a function body not bound to
    a function name and are used to generate a function definition at any point in
    the lexical scope of a program, where you would expect to pass a function object.
    Let us first understand how this is done with the help of an example.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串`"hello"`是一个有效的C++表达式。它有一个明确定义的类型（`const char[6]`），可以赋值给类型为`const char*`的变量，并传递给接受`const
    char*`类型参数的函数。同样，还有像`3.1415`或`64000U`这样的数字文字，像`true`和`false`这样的布尔文字，等等。C++11引入了**lambda表达式**，用于在调用它们的地方定义匿名函数。通常简称为**lambda**（来自Alonzo
    Church的λ演算），它们由一个未绑定到函数名称的函数体组成，并用于在程序的词法范围内的任何点生成函数定义，您期望传递一个函数对象。让我们首先通过一个例子来了解如何做到这一点。
- en: We have a list of integers, and we want to find the first odd number in the
    list using the `std::find_if` algorithm. The predicate passed to `std::find_if`
    is defined using a lambda.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个整数列表，并希望使用`std::find_if`算法在列表中找到第一个奇数。传递给`std::find_if`的谓词是使用lambda定义的。
- en: '**Listing 7.4: Using lambdas**'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单7.4：使用lambda**'
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The lambda to compute whether a number is odd or even is a block of code passed
    as the third argument to `std::find_if` (lines 9-10). Let us look at the lambda
    in isolation to understand the syntax. First, consider what this function does;
    given an integer, it returns true if it is odd and false otherwise. So, we have
    an unnamed function that maps an `int` to a `bool`. The way to write this in lambda-land
    is as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 计算一个数字是奇数还是偶数的lambda是作为第三个参数传递给`std::find_if`的代码块（第9-10行）。让我们单独看一下lambda以了解语法。首先，考虑这个函数做什么；给定一个整数，如果它是奇数则返回true，否则返回false。因此，我们有一个未命名函数，将`int`映射到`bool`。在lambda-land中编写这个的方式如下：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We introduce the unnamed function with an empty pair of square brackets, and
    we describe the mapping by writing a parameter list like that of a conventional
    function, followed by an arrow and the return type. Following this, we write the
    body of the function just like you would for a normal function:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用一对空方括号引入未命名函数，并通过编写类似于常规函数的参数列表，后跟一个箭头和返回类型来描述映射。在此之后，我们编写函数体，就像为正常函数编写一样：
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The pair of square brackets, often called **lambda introducers**, need not
    be empty, as we will see shortly. There are several other variations possible
    with this syntax, but you can define a lambda using just this bit of syntax. The
    return type specification for lambdas is optional in simple cases, where the compiler
    can easily deduce the return type from the function body. Thus, we could have
    rewritten the lambda from the preceding example without the return type because
    the function body is really simple:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 方括号对，通常称为**lambda引入者**，不一定为空，我们很快就会看到。这种语法还有其他几种变体，但您可以仅使用这一小部分语法来定义lambda。在简单情况下，lambda的返回类型规范是可选的，编译器可以轻松从函数体中推断出返回类型。因此，我们可以重新编写前面示例中的lambda，而不需要返回类型，因为函数体实际上非常简单：
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Lambda captures
  id: totrans-51
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Lambda捕获
- en: 'The lambda we defined in the previous example was a pure function without any
    state. In fact, how could a lambda conceivably store the state that persists between
    calls? Actually, lambdas can access local variables from the surrounding scope
    (in addition to global variables). To enable such an access, we can specify **capture
    clauses** in the lambda introducer to list which variables from the surrounding
    scope are accessible to the lambda and *how*. Consider the following example in
    which we filter out names longer than a user-specified length from a vector of
    names and return a vector containing only the shorter names:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前面的示例中定义的lambda是一个没有任何状态的纯函数。实际上，lambda如何可能存储在调用之间持续存在的状态？实际上，lambda可以访问来自周围范围的局部变量（以及全局变量）。为了启用这样的访问，我们可以在lambda引入器中指定**捕获子句**，列出了来自周围范围的哪些变量可以访问lambda以及*如何*。考虑以下示例，其中我们从名称向量中过滤出长度超过用户指定长度的名称，并返回仅包含较短名称的向量：
- en: '**Listing 7.5: Lambdas with captures**'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单7.5：带捕获的lambda**'
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `getNamesShorterThan` function takes two parameters: a vector called `names`
    and a variable `maxSize` that caps the size of strings to be filtered. It copies
    names shorter than `maxSize` from the `names` vector into a second vector called
    `shortNames`, using the `std::copy_if` algorithm from the standard library. We
    use a lambda expression (lines 12-14) to generate the predicate for `std::copy_if`.
    You can see that we name the `maxSize` variable from the surrounding lexical scope
    inside the square brackets (line 12), and access it inside the body of the lambda
    to compare the size of the passed string (line 13). This enables read-only access
    to the `maxSize` variable inside the lambda. If we wanted to potentially access
    any variable from the surrounding scope instead of a specific one, we could instead
    write the lambda with an equals sign in the square brackets; this would *implicitly
    capture* any variable used from the surrounding scope:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`getNamesShorterThan`函数接受两个参数：一个名为`names`的向量和一个名为`maxSize`的变量，该变量限制要过滤的字符串的大小。它将`names`向量中短于`maxSize`的名称复制到第二个名为`shortNames`的向量中，使用标准库中的`std::copy_if`算法。我们使用lambda表达式（第12-14行）生成`std::copy_if`的谓词。您可以看到我们在方括号中命名了来自周围词法范围的`maxSize`变量（第12行），并在lambda主体中访问它以比较传递的字符串的大小（第13行）。这使得lambda内部对`maxSize`变量的只读访问成为可能。如果我们想要潜在地访问周围范围中的任何变量而不是特定的变量，我们可以在方括号中使用等号来编写lambda；这将*隐式捕获*来自周围范围的任何使用的变量：'
- en: '[PRE12]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You may want to modify a local copy of a variable from the surrounding scope,
    without affecting its value in the surrounding scope. To enable your lambda to
    do this, it must be declared as mutable:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能希望修改来自周围范围的局部变量的副本，而不影响周围范围中的值。为了使您的lambda能够执行此操作，必须将其声明为mutable：
- en: '[PRE13]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `mutable` keyword trails the parameter list but appears before the return
    type if you specify one. This does not affect the value of `maxSize` in the surrounding
    scope.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`mutable`关键字跟在参数列表后面，但如果指定了返回类型，则出现在返回类型之前。这不会影响周围范围中`maxSize`的值。'
- en: You can also modify a variable from the surrounding scope inside a lambda. To
    do this, you must capture the variable by reference, by prefixing an ampersand
    to its name in the square brackets.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在lambda内部修改来自周围范围的变量。为此，必须通过在方括号中的变量名称前加上一个和符号来引用捕获变量。
- en: 'Here is listing 6.3 rewritten using a lambda:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用lambda重写的6.3清单：
- en: '**Listing 7.6: Reference captures in lambda**'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单7.6：lambda中的引用捕获**'
- en: '[PRE14]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the preceding example, we concatenate all names from the vector `names`
    that start with a specific character. The starting character is picked up from
    the variable `startCh`. The concatenated string is stored in the variable `concat`.
    We call `std::for_each` on the elements of the vector and pass a lambda, which
    explicitly captures `concat` as a reference (with a leading ampersand) and `startCh`
    as a read-only value from the surrounding scope (line 13). Thus, it is able to
    append to `concat` (line 15). This code prints the following output:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们将来自向量`names`的所有以特定字符开头的名称连接起来。起始字符取自变量`startCh`。连接的字符串存储在变量`concat`中。我们对向量的元素调用`std::for_each`，并传递一个lambda，该lambda显式地将`concat`作为引用捕获（带有前导和符号），并将`startCh`作为来自周围范围的只读值传递（第13行）。因此，它能够附加到`concat`（第15行）。此代码打印以下输出：
- en: '[PRE15]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In the latest revision of the C++ Standard, dubbed C++14, lambdas get a little
    niftier. You can write a *generic lambda* whose parameter types are deduced based
    on the context. For example, in C++14, you can write the call to `std::for_each`
    in the previous example, as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在最新的C++标准中，被称为C++14，lambda变得更加巧妙。您可以编写一个*通用lambda*，其参数类型是根据上下文推断的。例如，在C++14中，您可以按照前面示例中的调用`std::for_each`，编写如下：
- en: '[PRE16]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The type of the argument to lambda is written as `const auto&`, and the compiler
    deduces it as `const std::string&` based on the type of elements in the iterated
    sequence.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: lambda的参数类型写为`const auto&`，编译器根据迭代序列中元素的类型推断为`const std::string&`。
- en: Delegates and closures
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 委托和闭包
- en: 'Let us suppose you are writing a high-level C++ API for reading incoming messages
    on a message queue. The client of your API must register for the types of messages
    it is interested in and pass a callback—a function object that will be invoked
    when messages of your interest arrive. Your API could be a member of a `Queue`
    class. Here is one possible API signature:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您正在编写一个用于读取消息队列上传入消息的高级C++ API。您的API的客户端必须注册其感兴趣的消息类型，并传递一个回调函数对象，当您感兴趣的消息到达时将调用该对象。您的API可以是`Queue`类的成员。以下是一个可能的API签名：
- en: '[PRE17]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `listen` member template takes two parameters: the message type `msgtype`,
    which identifies the messages of interest, and a callback function object `cb`
    that will be called when a new message arrives. Since we want the client to be
    able to pass function pointers, pointer to member functions, functors, as well
    as lambdas for the callback, we make `listen` a member template parameterized
    on the type of the callback. Of course, the callback should have a specific signature.
    Let us suppose it should be compatible with the signature of the following function:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`listen`成员模板接受两个参数：消息类型`msgtype`，用于标识感兴趣的消息，以及回调函数对象`cb`，当新消息到达时将调用它。由于我们希望客户端能够传递函数指针、成员函数指针、仿函数以及lambda作为回调，因此我们将`listen`作为一个成员模板参数化为回调类型。当然，回调应该具有特定的签名。假设它应该与以下函数的签名兼容：'
- en: '[PRE18]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, `Message` is the type of messages read from the queue. The `listen` member
    template is a little too permissive because it can be instantiated with function
    objects that do not conform to the preceding signature. For a signature-incompatible
    callback, a compilation error occurs at the point where the callback is invoked
    inside `listen` rather than the point where the nonconforming callback is passed.
    This can make debugging the compiler errors more difficult.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`Message`是从队列中读取的消息的类型。`listen`成员模板有点过于宽松，因为它可以实例化为不符合前面签名的函数对象。对于不符合签名的回调，编译错误会发生在调用`listen`内部的回调处，而不是传递不符合签名的回调的地方。这可能会使调试编译器错误变得更加困难。
- en: 'The Boost.Function library and its C++11 incarnate `std::function` offer function
    object wrappers that are tailor-made to fix such problems. We can write the type
    of the function `msgRead` as `void (Message)`. The general syntax for the type
    of a function of arity N is as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Boost.Function库及其C++11版本`std::function`提供了专门设计用于解决此类问题的函数对象包装器。我们可以将函数`msgRead`的类型写为`void
    (Message)`。具有N个参数的函数类型的一般语法如下：
- en: '[PRE19]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The more familiar **function pointer type** corresponding to the preceding
    **function type** would be:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的**函数类型**对应的更熟悉的**函数指针类型**将是：
- en: '[PRE20]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Thus, the type of a function `int foo(double, const char*)` would be:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，函数`int foo(double, const char*)`的类型将是：
- en: '[PRE21]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'A pointer to will be of type:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 指针将是以下类型：
- en: '[PRE22]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Using `std::function` with the appropriate function type, we can declare `listen`
    so that it accepts only function objects that conform to the correct signature:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 使用具有适当函数类型的`std::function`，我们可以声明`listen`，以便它只接受符合正确签名的函数对象：
- en: '[PRE23]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The callback is now declared to be of type `boost::function<void(Message)>`.
    You can now call `listen` with a pointer to a global function, a functor, or even
    a lambda, and it will only compile if the function object has a conforming signature.
    We could have used `std::function` in place of `boost::function` if we were using
    a C++11 compiler. On pre-C++11 compilers, `boost::function` supports signatures
    with up to ten arguments, while `std::function` does not have any such limitation
    as it uses C++11 *variadic templates*. For more features of `boost::function`
    and its differences from `std::function` (which are minor), you can refer to the
    online documentation.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 回调现在被声明为`boost::function<void(Message)>`类型。现在可以使用指向全局函数、仿函数或甚至lambda调用`listen`，只有当函数对象具有符合签名时才会编译。如果使用的是C++11编译器，我们可以使用`std::function`代替`boost::function`。在C++11之前的编译器上，`boost::function`支持最多十个参数的签名，而`std::function`没有任何这样的限制，因为它使用了C++11的*可变模板*。有关`boost::function`的更多特性及其与`std::function`的区别（这些区别很小），您可以参考在线文档。
- en: 'Passing a nonstatic member function as a callback requires a little bit more
    work, because a non-static member must be called on an instance of its class.
    Consider the following class `MessageHandler` with a member `handleMessage`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 将非静态成员函数作为回调需要更多的工作，因为非静态成员必须在其类的实例上调用。考虑以下类`MessageHandler`，它有一个成员`handleMessage`：
- en: '[PRE24]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `handleMessage` member function is implicitly passed a pointer to the `MessageHandler`
    object on which it is invoked as its first parameter; so its effective signature
    is:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`handleMessage`成员函数会隐式地传递一个指向其所调用的`MessageHandler`对象的指针作为其第一个参数；因此它的有效签名是：'
- en: '[PRE25]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: When we want to pass this as a callback to `Queue::listen`, we probably already
    know which object we want `handleMessage` to be called on, and it would be great
    if we could somehow attach that object instance too in the call to listen. There
    are a couple of ways in which this can be done.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要将其作为回调传递给`Queue::listen`时，我们可能已经知道要调用`handleMessage`的对象，如果我们可以在调用listen时以某种方式附加该对象实例，那将是很好的。有几种方法可以做到这一点。
- en: 'The first method involves wrapping the call to `handleMessage` in a lambda
    and passing it to `listen`. The following snippet illustrates this:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法涉及将对`handleMessage`的调用包装在lambda中，并将其传递给`listen`。以下代码片段说明了这一点：
- en: '**Listing 7.7: Member function callbacks using closures**'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单7.7：使用闭包的成员函数回调**'
- en: '[PRE26]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Here, the second argument to `listen` is generated using a lambda expression,
    which also captures a pointer to the `handler` object from the surrounding scope.
    In this example, `handler` is a local variable in the calling scope, but the lambda
    captures it and binds it into the function object it generates. This function
    object is not invoked immediately on it but delayed until a message of interest
    is received on the queue, when it forwards the call to the `handleMessage` method
    on the `handler` object pointer.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`listen`的第二个参数是使用lambda表达式生成的，它还捕获了来自周围范围的`handler`对象的指针。在这个例子中，`handler`是调用范围内的一个局部变量，但是lambda捕获了它并将其绑定到它生成的函数对象中。这个函数对象不会立即被调用，而是延迟到队列上接收到感兴趣的消息时，它会将调用转发到`handler`对象指针上的`handleMessage`方法。
- en: The `handler` pointer is created in the calling scope but becomes indirectly
    accessible in another scope via the lambda capture. This is referred to as **dynamic
    scoping**, and functions of this kind that bind to variables in the lexical scope,
    in which they are created, are called **closures**. Of course, the handler pointer
    must still point to a valid `MessageHandler` object at the time when `handleMessage`
    is called on it, not just when the lambda is created.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: 'More often than not, such lambdas would be generated from inside a member function,
    like a member function of the `MessageHandler` class and would capture the `this`
    pointer with some consequent syntactic simplifications:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing 7.8: Capturing this-pointer in lambdas**'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In the preceding example, we create a closure using a lambda expression that
    captures the `this` pointer (line 6). The call to `handleMsg` inside the lambda
    automatically binds to the `this` pointer, just as it would in a member function.
    Callbacks, especially when bound to specific objects, as mentioned earlier, are
    sometimes called **delegates**.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: The `boost::function` / `std::function` wrapper provides an effective and type-checked
    way of passing and returning function objects as callbacks or delegates. They
    are sometimes called polymorphic function wrappers because they completely abstract
    the type of the underlying callable entity (function pointer, functor, and so
    on) from the caller. Most implementations allocate memory dynamically though,
    so you should pay due diligence to assess their impact on runtime performance.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: Partial function application
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Given the Standard Library function `pow`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Consider the effect of the line of code `x = pow(2, 3)`. When this line is encountered,
    the function `pow` is immediately called with two arguments, the values 2 and
    3\. The function `pow` computes 2 raised to 3 and returns the value 8.0, which
    is then assigned to `x`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, say you have a list of numbers, and you want to put their cubes into another
    list. The Standard Library algorithm `std::transform` is a perfect fit for this.
    We just need to find the right functor to raise the numbers to their cubic power.
    The following functor takes a single numeric argument and raises it to a specific
    power, using the `pow` function:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We could also have used a lambda expression to generate the function object,
    as shown in listing 7.7 and 7.8 in the last section. Using `RaiseTo` with the
    `std::transform` algorithm, the following code does the job:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The core computation in `RaiseTo` is done by the `pow` function. The `RaiseTo`
    functor provides a way to fix the power through the constructor argument and a
    call signature compatible with what `std::transform` expects.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Imagine if you could do this in C++ without functors or lambdas. What if using
    the following *imaginary* syntax, you could do the same thing?
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: It is as if you are passing the `pow` function with one of its two arguments
    fixed at 3 and asking the `transform` algorithm to fill in the blank; supply the
    number to raise to. The expression `pow(_, 3)` would have evaluated to a function
    object, taking one argument instead of 2\. We essentially achieved this using
    the `RaiseTo` functor, but the Boost Bind library and its C++11 incarnate `std::bind`
    help us do this with less syntax. Formally, what we have just done is referred
    to as **partial function application**.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a partially applied function object for `pow` using `bind`, you would
    need to write:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The preceding expression generates an unnamed functor which takes a single argument
    and returns its value raised to the power of 3, using the standard library function
    `pow`. The similarity with our imaginary syntax should be evident. The value to
    be cubed is passed as the sole argument of the generated functor and is mapped
    to the special placeholder `_1`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing 7.9: Using Boost Bind**'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'If the generated functor takes more arguments, then they could be mapped to
    the placeholders `_2`, `_3`, and so on, based on their positions in the argument
    list. In general, the nth argument maps to the placeholder *_n*. Boost Bind by
    default supports maximum nine positional placeholders (`_1` through `_9`); `std::bind`
    might support more (varies from one compiler to the next), but you will need to
    access them from the `std::placeholders` namespace, using one of the following
    directives:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果生成的函数对象接受更多的参数，则可以根据它们在参数列表中的位置将它们映射到占位符`_2`、`_3`等。一般来说，第n个参数映射到占位符`_n`。Boost
    Bind默认支持最多九个位置占位符（`_1`到`_9`）；`std::bind`可能支持更多（根据编译器的不同），但您需要从`std::placeholders`命名空间中访问它们，使用以下指令之一：
- en: '[PRE34]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'You may adapt functions by reordering their arguments without changing function
    arity to achieve a new functionality. For example, given the functor `std::less`
    that returns `true` if its first argument is less than its second argument, we
    can generate a functor, which returns true if its first argument is greater than
    its second argument by swapping the arguments. The following expression generates
    this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过重新排序它们的参数而不改变函数arity来调整函数以实现新的功能。例如，给定返回`true`的函数`std::less`，如果它的第一个参数小于它的第二个参数，我们可以生成一个函数对象，如果它的第一个参数大于它的第二个参数，则返回`true`。以下表达式生成了这个：
- en: '[PRE35]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Here, `std::less<int>` takes two arguments, and we generate a wrapper function
    object, which also takes two arguments but swaps their positions before passing
    them to `std::less`. We can directly call the generated functor in-place, like
    this:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`std::less<int>`接受两个参数，我们生成了一个包装函数对象，它也接受两个参数，但在将它们传递给`std::less`之前交换它们的位置。我们可以直接在原地调用生成的函数对象，就像这样：
- en: '[PRE36]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We can safely assert that 1 is not greater than 10 but is, in fact, less:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以安全地断言1不大于10，但实际上是小于：
- en: '[PRE37]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Boost Bind is also useful for generating delegates, and other methods of generating
    delegates were illustrated in listing 7.7 and 7.8\. Here is Listing 7.8 rewritten
    using `boost::bind`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Boost Bind还可用于生成委托，清单7.7和7.8中还演示了生成委托的其他方法。以下是使用`boost::bind`重写的清单7.8：
- en: '**Listing 7.10: Generating delegates with Boost Bind**'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 清单7.10：使用Boost Bind生成委托
- en: '[PRE38]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We must bind a member function to an object instance. We do this by binding
    `this` to the first argument of `MessageHandler::handleMsg` (lines 6-7). This
    technique is generally useful for invoking member functions on each object in
    a collection. Moreover, `boost::bind` / `std::bind` intelligently deal with objects,
    pointers, smart pointers, and so on, so you do not need to write different binders,
    depending on whether it is a copy of an object, a pointer, or a smart pointer.
    In the following example, we take a vector of `std::string`s, compute their lengths
    using the `size` member function, and put them in a vector of lengths:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须将一个成员函数绑定到一个对象实例。我们通过将`this`绑定到`MessageHandler::handleMsg`的第一个参数（第6-7行）来实现这一点。这种技术通常用于在集合中的每个对象上调用成员函数。此外，`boost::bind`
    / `std::bind`智能地处理对象、指针、智能指针等，因此您无需根据对象的复制、指针或智能指针来编写不同的绑定器。在下面的示例中，我们获取了一个`std::string`的向量，使用`size`成员函数计算它们的长度，并将它们放入一个长度向量中：
- en: '**Listing 7.11: Generating delegates with Boost Bind**'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 清单7.11：使用Boost Bind生成委托
- en: '[PRE39]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The lengths are computed by calling the `size` member function on each `std::string`
    object. The expression `std::bind(&std::string::size, _1)` generates an unnamed
    functor, which calls the `size` member on the `string` object passed to it.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 长度是通过在每个`std::string`对象上调用`size`成员函数来计算的。表达式`std::bind(&std::string::size, _1)`生成了一个未命名的函数对象，它调用传递给它的`string`对象的`size`成员。
- en: Even if `names` was a vector of pointers to `std::string` objects, or smart
    pointers, the bind expression (line 9) would not need to change. The `bind` function
    takes its parameters by value. Thus, in the preceding example, each string is
    copied into the generated functor—a source of potential performance issue.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 即使`names`是指向`std::string`对象的指针或智能指针的向量，绑定表达式（第9行）也不需要改变。`bind`函数按值传递其参数。因此，在前面的示例中，每个字符串都被复制到生成的函数对象中，这可能导致性能问题。
- en: Another function template called `boost::mem_fn` and its Standard Library counterpart
    `std::mem_fn` make it a tad easier to call member functions on objects and generate
    delegates. The `mem­_fn` function template creates a wrapper around pointers to
    class members. For a member function `f` of arity `N` in class `X`, `mem_fn(&X::f)`
    generates a functor of arity `N+1`, whose first argument must be a reference,
    pointer, or smart pointer to the object on which the member function is invoked.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个名为`boost::mem_fn`的函数模板及其标准库对应物`std::mem_fn`使得在对象上调用成员函数和生成委托变得更加容易。`mem_fn`函数模板创建了一个指向类成员的包装器。对于类`X`中的arity`N`的成员函数`f`，`mem_fn(&X::f)`生成一个arity`N+1`的函数对象，其第一个参数必须是对对象的引用、指针或智能指针，该对象上调用成员函数。
- en: 'We can write listing 7.11 to use `mem_fn` instead:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以编写清单7.11来使用`mem_fn`：
- en: '[PRE40]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Because `std::string::size` is nullary, the functor generated by `boost::mem_fn`
    is unary and can be readily used with `transform`, without additional binding.
    The savings are in not having to write the `_1` placeholder, and thus have less
    syntactic noise.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`std::string::size`是nullary的，`boost::mem_fn`生成的函数对象是一元的，并且可以直接与`transform`一起使用，无需额外的绑定。节省了不必写`_1`占位符，因此语法上更简洁。
- en: 'When we generate a function object using `bind`, it does not immediately check
    whether the type and number of arguments match the signature of the function being
    bound to. Only when the generated function object is invoked, does the compiler
    detect parameter type and arity mismatch:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用`bind`生成函数对象时，它不会立即检查参数类型和数量是否与绑定到的函数的签名匹配。只有在调用生成的函数对象时，编译器才会检测到参数类型和arity不匹配：
- en: '[PRE41]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'For example, the preceding code would compile even though you cannot call the
    `size` member function of `std::string` on a numeric literal 5 (line 2). Nor does
    the `size` member function take an additional numeric argument (line 3). But as
    soon as you try to call these generated function objects, you will get errors
    due to type and arity mismatch:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，即使你不能在数字文字 5 上调用 `std::string` 的 `size` 成员函数（第2行），前面的代码也会编译。`size` 成员函数也不接受额外的数字参数（第3行）。但是一旦你尝试调用这些生成的函数对象，你将因为类型和参数数量不匹配而得到错误：
- en: '[PRE42]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Binding member functions that are overloaded requires more syntactic effort.
    Generating functions of even moderate complexity with `bind` is an exercise in
    nesting binds, which more often than not produces unmaintainable code. In general,
    with the availability of C++11 lambda and its further refinement in C++14, lambdas
    rather than bind should be the preferred mechanism of generating unnamed functors.
    Use `bind` only when it makes your code more expressive than a lambda can.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定重载的成员函数需要更多的语法工作。使用 `bind` 生成甚至是中等复杂度的函数是一个嵌套绑定的练习，这往往会产生难以维护的代码。一般来说，有了 C++11
    lambda 的可用性以及在 C++14 中的进一步完善，应该优先使用 lambda 而不是 bind 作为生成匿名函数对象的机制。只有在使用 `bind`
    使你的代码比 lambda 更具表现力时才使用它。
- en: Compile-time programming with Boost
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Boost 进行编译时编程
- en: Templates allow us to write C++ code that is independent of specific types of
    operands and can thus work unchanged with a large family of types. We can create
    both **function templates** and **class templates** (or struct templates), which
    take type parameters, nontype parameters (like constant integers), as well as
    template parameters. When a *specialization* of a class template is instantiated,
    member functions that are not directly or indirectly called are never instantiated.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 模板允许我们编写独立于操作数特定类型的 C++ 代码，因此可以在大量类型的情况下不变地工作。我们可以创建**函数模板**和**类模板**（或结构模板），它们接受类型参数、非类型参数（如常量整数）以及模板参数。当类模板的*特化*被实例化时，从未直接或间接调用的成员函数将不会被实例化。
- en: The power of C++ templates goes beyond the ability to write generic code though.
    C++ templates are a powerful computation subsystem using which we can introspect
    C++ types, glean their properties, and write sophisticated recursive and branching
    logic that executes at compile time. Using these capabilities, it is possible
    to define generic interfaces to implementations that are highly optimized for
    each type they operate upon.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 模板的威力不仅仅在于能够编写通用代码。C++ 模板是一个强大的计算子系统，我们可以利用它来审视 C++ 类型，获取它们的属性，并编写复杂的递归和分支逻辑，这些逻辑在编译时执行。利用这些能力，我们可以定义对每种操作类型高度优化的通用接口。
- en: Basic compile-time control flow using templates
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用模板进行基本的编译时控制流
- en: In this section, we briefly look at branching and recursive logic generated
    using templates.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们简要地看一下使用模板生成的分支和递归逻辑。
- en: Branching
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分支
- en: 'Consider the function template `boost::lexical_cast`, introduced in [Chapter
    2](ch02.html "Chapter 2. The First Brush with Boost''s Utilities"), *The First
    Brush with Boost''s Utilities*. To convert a `string` to a `double`, we would
    write code like the following:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑函数模板 `boost::lexical_cast`，它在[第 2 章](ch02.html "第 2 章. Boost 实用工具的初次尝试")中介绍过，*Boost
    实用工具的初次尝试*。要将 `string` 转换为 `double`，我们可以编写如下代码：
- en: '[PRE43]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The primary template of `lexical_cast` is declared this way:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`lexical_cast` 的主模板是这样声明的：'
- en: '[PRE44]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The default implementation of `lexical_cast` (called the **primary template**)
    writes the source object to a memory buffer via an interface like `ostringstream`
    and reads back from it via another interface like `istringstream`. This conversion
    may incur some performance overhead but has an expressive syntax. Now let us suppose
    that for a particularly performance-intensive application, you want to improve
    the performance of these string-to-double conversions, but do not want to replace
    `lexical_cast` with some other function calls. How would you do it? We can create
    an **explicit specialization** of the `lexical_cast` function template to perform
    a branching at compile time based on the types involved in the conversion. Since
    we want to override the default implementation for `string` to `double` conversions,
    this is how we would write the specialization:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`lexical_cast` 的默认实现（称为**主模板**）通过类似 `ostringstream` 的接口将源对象写入内存缓冲区，然后通过类似 `istringstream`
    的另一个接口从中读取。这种转换可能会产生一些性能开销，但具有表现力的语法。现在假设对于一个特别性能密集型的应用程序，你想要提高这些字符串到双精度浮点数的转换性能，但又不想用其他函数调用替换
    `lexical_cast`。你会怎么做？我们可以创建 `lexical_cast` 函数模板的**显式特化**，以便根据转换中涉及的类型在编译时执行分支。由于我们想要覆盖默认实现的
    `string` 到 `double` 转换，这就是我们会写特化的方式：'
- en: '**Listing 7.12: Explicit specialization of function templates**'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单 7.12：函数模板的显式特化**'
- en: '[PRE45]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The `template` keyword with an empty argument list (`template<>`) indicates
    that this is a specialization for specific type arguments (line 2). The **template
    identifier** `lexical_cast <double, std::string>` lists the specific types for
    which the specialization takes effect (line 3). With this specialization available,
    the compiler invokes it whenever it sees code like this:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`template` 关键字与空参数列表 (`template<>`) 表示这是特定类型参数的特化（第2行）。**模板标识符** `lexical_cast
    <double, std::string>` 列出了特化生效的特定类型（第3行）。有了这个特化，编译器在看到这样的代码时会调用它：'
- en: '[PRE46]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Note that it is possible to *overload function templates* (not just functions).
    For example:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，*重载函数模板*（而不仅仅是函数）是可能的。例如：
- en: '[PRE47]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In the preceding example, `foo` is a function template (1) that is overloaded
    (2 and 3). The function `foo` itself is overloaded (4). The function template
    `foo` (1) is also specialized (5). When the compiler encounters a call to `foo`,
    it first looks for a matching non-template overload, failing which it looks for
    the most specialized template overload. In the absence of a matching specialized
    overload, this would simply resolve to the primary template. Thus, the call to
    `foo(&x)` resolves to `template<typename T> void foo(T*)`. If such an overload
    was not present, it would resolve to `template<typename T> void foo(T)`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: 'It is possible to create specializations for class templates too. In addition
    to explicit specializations, which specialize a class template for a fixed set
    of type and non-type arguments, we can also create **partial specializations**
    of class templates that specialize a class template for a family or category of
    types:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: In the preceding example, the primary template `Bar` takes two type arguments.
    We create a partial specialization for `Bar` for those cases, where the first
    of these two arguments is a pointer-type and the second argument is the pointer-type
    for the first. Thus, instantiating `Bar<int, float>` or `Bar<double, double*>`
    will instantiate the primary template, but `Bar<float*, float>`, `Bar<Foo*, Foo>`,
    etc. will instantiate the partially specialized template. Note that functions
    cannot be partially specified.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: Recursion
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Recursion using templates is best illustrated using an example of calculating
    factorials at compile time. Class templates (as well as function templates) can
    take integer arguments as long as the values are known at compile time.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing 7.13: Compile-time recursion using templates**'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The primary template for calculating factorials defines a compile-time constant
    enum `value`. The `value` enum in `Factorial<N>` contains the value of the factorial
    of `N`. This is calculated recursively by instantiating the `Factorial` template
    for `N-1` and multiplying its nested `value` enum with `N`. The stopping condition
    is provided by the specialization of `Factorial` for 0\. These calculations happen
    at compile time, as the `Factorial` template gets instantiated with successively
    smaller arguments until `Factorial<0>` stops further instantiation. Thus, the
    value `40320` is computed completely at compile time and baked into the binary
    that is built. For example, we could have written the following and it would have
    compiled and generated an array of 40320 integers on the stack:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Boost Type Traits
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Boost Type Traits library provides a set of templates used to query types
    for properties and generate derivative types at compile time. They are useful
    in generic code, that is, code which uses parameterized types, for purposes such
    as choosing an optimal implementation based on the properties of a type parameter.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following template:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The `IsPointer` template has a nested enum called `value`. This is set to 0
    in the primary template. We also define a partial specialization of `IsPointer`
    for pointer-type arguments and set the nested `value` to 1\. How is this class
    template useful? For any type `T`, `IsPointer<T>::value` is 1 if and only if `T`
    is a pointer-type and 0 otherwise. The `IsPointer` template maps its type argument
    to a compile-time constant value 0 or 1, which can be used for further branching
    decisions at compile time.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: The Boost Type Traits library is chock full of such templates (including `boost::is_pointer`)
    that can glean information about types and also generate new types at compile
    time. They can be used for selecting or generating the optimal code for the types
    at hand. Boost Type Traits was accepted for the C++ TR1 release in 2007 and as
    of C++11, there is a Type Traits library in the Standard Library.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: Each type trait is defined in its own header so that you can include only those
    type traits that you need. For example, `boost::is_pointer` would be defined in
    `boost/type_traits/is_pointer.hpp`. The corresponding `std::is_pointer` (introduced
    in C++11) is defined in the standard header `type_traits`, there being no separate
    standard header for it. Each type trait has an embedded type called `type`, and
    in addition, it may have a member `value` of type bool. Here is an example of
    using a few type traits.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing 7.14: Using type traits**'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: In this example, we use a number of type traits to query information about types.
    We define a type `intptr` as an integer pointer (line 18). Applying `boost::is_pointer`
    to `intptr` yields true (line 20).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: The `decltype` specifier used here was introduced in C++ 11\. It generates the
    type of the expression or entity it is applied to. Thus, `decltype(arr)` (line
    24) yields the declared type of arr, including any `const` or `volatile` qualifiers.
    It is a useful means of computing the type of an expression. We apply the `boost::is_array`
    trait to an array type, which obviously yields true (line 24). To find the number
    of dimensions or the rank of an array, we use the trait `boost::rank` (lines 25
    and 26). The rank of `arr[10]` is 1 (line 25), but the rank of `arr2[10][15]`
    is 2 (line 26). The `boost::extent` trait is used to find the extent of an array's
    rank. It must be passed the array's type and rank. If the rank is not passed,
    it defaults to 0 and returns the extent for one-dimensional arrays (line 27) or
    the zeroth dimension of multi-dimensional arrays (line 28). Otherwise, the rank
    should be explicitly specified (line 29).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: The `boost::is_pod` trait returns whether a type is a Plain Old Data type or
    not. It returns true for a simple struct without any constructors or destructors
    like `MyStruct` (line 34) and false for `std::string`, which is obviously not
    a POD type (line 38).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned before, there is also an embedded type in these traits called `type`.
    This is defined as `boost::true_type` or `boost::false_type`, depending on whether
    the trait returned true or false. Now consider that we are writing a generic algorithm
    to copy arrays of arbitrary objects into an array on the heap. For POD-types,
    a shallow copy or `memcpy` of the whole array is good enough, while for non-POD
    types, we need to perform element by element copies.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing 7.15: Leveraging type traits**'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The `fastCopy` function template creates a copy of the array on the heap (lines
    31-35). We create two overloads of it: one for copying POD-types (lines 11-12)
    and the other for copying non-POD types (lines 21-22), by adding a second parameter
    of type `boost::true_type` in the first case and `boost::false_type` in the second
    case. We create two arrays: one of the POD-type `MyStruct` and the other of the
    non-POD type `std::string` (lines 42-43). We call `fastCopy` on both, which are
    resolved to the one argument overload (line 32). This forwards the call to the
    two argument overloads of `fastCopy`, passing an instance of `boost::is_pod<T>::type`
    as the second argument (line 34). This automatically routes the call to the correct
    overload, depending on whether the stored type `T` is POD-type or not.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: There are many, many more type traits than we can cover in the scope of this
    book. You have type traits to check whether one type is a base class of another
    (`boost::is_base`), whether a type is copy constructible (`boost::is_copy_constructible`),
    has specific operators (for example, `boost::has_pre_increment`), is same as another
    type (`boost::is_same`), and so on. The online documentation is a good place to
    go dig traits and see which ones fit a job at hand.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: SFINAE and enable_if / disable_if
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Each time a compiler encounters a call to a function with the same name as a
    function template, it creates an overload resolution set of matching template
    and non-template overloads. The compiler deduces template arguments as needed
    to determine which function template overloads (and specializations thereof) qualify,
    and the qualifying template overloads are instantiated in the process. If substitution
    of the deduced type arguments in the template's argument list or the function
    parameter list causes an error, this does not cause the compilation to abort.
    Instead, the compiler removes the candidate from its overload resolution set.
    This is referred to as **Substitution Failure Is Not An Error** or **SFINAE**.
    The compiler only flags an error if, at the end of the process, the overload resolution
    set is empty (no candidates) or has multiple equally good candidates (ambiguity).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Using a few clever tricks involving compile-time type computation, it is possible
    to leverage SFINAE to conditionally include templates or exclude them from the
    overload resolution set. The most succinct syntax to do this is provided by the
    `boost::enable_if` / `boost::disable_if` templates that are part of the Boost.Utility
    library.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us write a function template to copy an array of elements into another
    array. The signature of the primary template is as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Thus, you pass two arrays of same size storing the same type of elements, and
    the elements of the second arguments are copied into the first array in the correct
    order. We also assume that the arrays never overlap; this keeps the implementation
    simple. Needless to say this is not the most general setting in which such an
    assignment can take place, but we will relax some of these restrictions a little
    later. Here is a generic implementation for this template:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The first opportunity for optimization here is when T is a POD-type and a bitwise
    copy is good enough and possibly faster. We will create a special implementation
    for POD-types and use SFINAE to choose this implementation only when we are dealing
    with arrays of POD-types. Our technique should exclude this overload from the
    overload set when dealing with non-POD type arrays. Here is the special implementation
    for POD-types:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'If you noticed, the two implementations have identical signature and obviously
    cannot coexist. This is where the `boost::enable_if` template comes in. The `boost::enable_if`
    template takes two parameters: a type `T` and a second type `E`, which defaults
    to `void`. `enable_if` defines an embedded type called `type`, which is typedef''d
    to `E` only when `T` has an embedded type called `type` and `T::type` is `boost::true_type`.
    Otherwise, no embedded type is defined. Using `enable_if`, we modify the optimized
    implementation:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing 7.16: Using enable_if**'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The `typename` keyword is required because otherwise the compiler has no way
    of knowing whether the expression `boost::enable_if<boost::is_pod<T>>::type` names
    a type or a member.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: 'If we now instantiate an array of a non-POD type, it will resolve to the default
    implementation:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The call to `copy` causes the compiler to instantiate both templates but `boost::is_pod<std::string>::type`
    is `boost::false_type`. Now `enable_if<false_type>` does not have a nested type
    as required by the return type specification of the version of `copy` optimized
    for POD-arrays. Therefore, there is a substitution failure, and this overload
    is removed from the overload resolution set, and the first or generic implementation
    is invoked. Now consider what happens in the following case, where we try to copy
    an array of POD-types (`double`):'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: In the current state of affairs, the POD-optimized version will no longer encounter
    a substitution failure, but the default implementation would also be signature-compatible
    with this call. Thus, there would be ambiguity and this would result in a compiler
    error. To fix this, we would have to make sure that the generic implementation
    excuses itself from the overload set this time. This is done using `boost::disable_if`
    (which is really `boost::enable_if` negated) in the return type of the generic
    implementation.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing 7.17: Using disable_if**'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: When `T` is a POD-type, `is_pod<T>::type` is `boost::true_type`. `boost::disable_if<true_type>`
    does not have a nested `type` and thus a substitution failure occurs with the
    generic implementation. This way, we build two mutually exclusive implementations
    that are correctly resolved at compile time.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use the `boost::enable_if_c<>` template which takes a Boolean parameter
    instead of a type. `boost::enable_if_c<true>` has an embedded `type`, while `boost::enable_if_c<false>`
    does not. With these, the return type in listing 7.17 would look like this:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The Standard Library, as of C++11, has `std::enable_if` only, and it behaves
    like `boost::enable_if_c`, taking a Boolean argument rather than a type. It is
    available from the standard header `type_traits`.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: The Boost Metaprogramming Library (MPL)
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Boost Metaprogramming Library**, **MPL** for short, is a general purpose
    library for template metaprogramming. It is ubiquitous in the Boost codebase,
    and most libraries use some metaprogramming facility from MPL. Some libraries
    like Phoenix, BiMap, MultiIndex, and Variant use it very heavily. It is used heavily
    for type manipulation and optimization through conditional selection of specific
    template implementations. This section is a short overview of some of the concepts
    and techniques involving MPL.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: Metafunctions
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The heart of the MPL library is a **metafunction**. Formally, a metafunction
    is either a class template with only type parameters or a class, which exposes
    a single embedded type called `type`. In effect, type parameters if any are analogous
    to parameters to a function and the embedded `type`, which is computed at compile
    time based on the parameters, is analogous to the return value of a function.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: 'Type traits provided by Boost Type Traits library are first-class metafunctions.
    Consider the `boost::add_pointer` type trait:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The type `add_pointer<int>::type` is `int*`. The `add_pointer` template is a
    unary metafunction with a single type parameter and an embedded type called `type`.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, the effective result of a type computation is numeric – case in point
    `boost::is_pointer<T>` (Boolean truth value) or `boost::rank<T>` (a positive integer).
    In such cases, the embedded `type` will have a static member called `value` containing
    this result, and it will also be directly accessible from the metafunction as
    a non-type member called `value`. Thus, `boost::is_pointer<T>::type::value` and
    `boost::is_pointer<T>::value` are both valid, the latter being more concise.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: Using MPL metafunctions
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The MPL working in conjunction with Boost Type Traits makes a lot of metaprogramming
    jobs easy. For this, the MPL provides a number of metafunctions to compose existing
    metafunctions together.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: 'Like type traits, MPL facilities are partitioned into independent, highly granular
    header files. All metafunctions are in the `boost::mpl` namespace. We can compose
    unnamed metafunctions together into composite metafunctions using the MPL library.
    This is not unlike lambdas and bind at runtime. The following snippet uses `boost::mpl::or_`
    metafunction to check whether a type is either an array or a pointer:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing 7.18: Using MPL metafunctions**'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The `boost::mpl::or_` metafunction checks whether any of its argument metafunctions
    evaluates to true. We can create our own reusable metafunction that packages the
    preceding logic by using a technique called **metafunction forwarding**:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing 7.19: Creating your own metafunction**'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: We combine the existing type trait metafunctions using `boost::mpl::or_` and
    inherit from the composed entity, as shown in the preceding listing (line 6).
    We can now use `is_pointer_or_array` like any type trait.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, we need to pass numeric arguments, which are clearly non-type, to
    metafunctions. For example, to compare whether the size of a type T is smaller
    than that of another type U, we ultimately need to compare two numeric sizes.
    Let us write the following trait to compare the size of two types:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '`is_smaller<T, U>::value` will be true if and only if `sizeof(T)` is less than
    `sizeof(U)`, and will be false otherwise.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing 7.20: Using integral wrappers and other metafunctions**'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: MPL provides a metafunction `boost::mpl::integral_c` to wrap integral values
    of a specified type (`size_t`, `short`, etc.). We use it to wrap the sizes of
    the two types. The `boost::mpl::less` metafunction compares the two sizes and
    its nested `value` is set to true only if the first argument is numerically less
    than the second. We can use it like any other trait.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now try to write something slightly less trivial. We want to write
    a function to assign arrays. Here is the function template signature:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The type `T(&)[M]` is a reference to an array of `M` elements of type `T`; likewise
    for `S (&)[N]`. We want to assign the second argument `rhs` to the first argument
    `lhs`.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: You can assign an array of type `S[]` to an array of type `T[]` as long as `S`
    and `T` are the same types, or the conversion from `S` to `T` is allowed and does
    not cause loss of information. Also, `M` must not be smaller than `N`. We will
    define a trait `is_array_assignable` which captures these constraints. Thus, `is_array_assignable<T(&)[M],
    S(&)[N]>::value` will be true only if the preceding constraints are met.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to define three helper metafunctions: `is_floating_assignable`,
    `is_integer_assignable`, and `is_non_pod_assignable`. The `is_floating_assignable<T,
    S>` metafunction checks whether it is possible to assign a numeric value of type
    `S` to a floating point type `T`. The `is_integer_assignable<T, S>` metafunction
    checks whether both `T` and `S` are integers, and an assignment for `T` and `S`
    does not cause any potential loss or narrowing. Thus, signed integers cannot be
    assigned to unsigned integers, unsigned integers can only be assigned to larger
    signed integer types, and so on. The `is_non_pod_assignable<T, S>` trait checks
    whether at least one of `S` and `T` is non-POD type and whether an assignment
    operator from `S` to `T` exists.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: We will then define `is_array_assignable` using these and other metafunctions.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing 7.21: Defining useful type traits using MPL**'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The primary template of the `is_array_assignable` metafunction always returns
    false (lines 61-64). The partial specialization of `is_array_assignable` (line
    66-78) is the heart of the implementation. It uses the `mpl::or_` metafunction
    to check whether any one of the following conditions is met:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: The source and target types are the same (line 70)
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The target type is a floating point, the source type is numeric, and an assignment
    is possible without narrowing (line 71)
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The target type is integral (signed or unsigned), the source type is integral,
    and an assignment is possible without narrowing (line 72)
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At least one of the source and target types is a non-POD type and a conversion
    from the source to the target type is possible (line 73)
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `mpl::or_` metafunction is analogous to the logic or operator of C++, and
    its static member `value` is set to true if any one of the passed conditions is
    true. Along with this composite condition being true, the following condition
    must also hold:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: The number of elements in the target array should be at least as much as the
    elements in the source array.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: We use the `mpl::greater_equal` metafunction to compare these two values `M`
    and `N`. Since the metafunction needs to take type parameters, we generate type
    parameters corresponding to `M` and `N` using `boost::mpl::integral_c` wrapper
    (lines 75-76). We compute the logical-OR of conditions 1-4 and its logical-AND
    with condition 5 using the `mpl::and_` metafunction (line 61).
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: We use `boost::enable_if` that leverages SFINAE to disable `assignArray` when
    `is_array_assignable` returns false.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: Let us now look at the implementation of the `is_integer_assignable`. It checks
    if the target and source types are both integral, (lines 38-39) and the source
    type is not bigger than the target type (line 40). In addition, we use `boost::mpl::if_`
    metafunction, which takes three metafunctions; if the first metafunction evaluates
    to `true`, the second metafunction is returned, otherwise the third metafunction
    is returned. Using `mpl::if_`, we express the constraints on the source and target
    types (lines 41-47). If the source type is a signed integer (line 41), then the
    target type must also be a signed integer (line 42). But if the source type be
    an unsigned integer, then the target type must either be an unsigned integer (line
    43) or a signed integer larger than the source type (lines 44-45). The rest of
    the traits are similarly defined using Boost MPL library facilities.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: Metaprogramming is not just a tool for choosing optimal implementations or catching
    violations at compile time. It actually helps create expressive libraries like
    `boost::tuple` or `boost::variant`, involving significant type manipulation. We
    introduced only a few basic abstractions from the Boost MPL library to help you
    ease into template metaprogramming. If you have worked through the examples in
    this chapter, you should have no problems exploring MPL further on your own.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: Domain Specific Embedded Languages
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last third of this chapter, we look at the applications of higher order
    and compile-time programming mainly in the area Domain Specific Embedded Languages.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: Lazy evaluation
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In C++, when we see the following code:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: We know that the value of `z` is immediately computed when the control reaches
    past the statement `z = x + y()`. In fact, the act of computing the sum involves
    evaluating the expressions `x` and `y()` themselves. Here, `y` is presumably a
    function or a functor instance, so the call to `y()` will in turn trigger more
    evaluations. Irrespective of whether `z` is ever used for anything later, its
    value would still be computed. This is the model of **eager evaluation** that
    a lot of programming languages follow. The actual story is slightly more complex
    because compilers can reorder and optimize away computations but there is little
    control the programmer has on the process.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: 'What if we could defer the evaluation of such expressions and any of their
    sub-expressions until we have to make use of the result? This is the **lazy evaluation**
    model seen in a lot of functional programming languages, like Haskell. If we could
    construct arbitrary language expressions that are lazily evaluated, then such
    expressions could be passed around just like functors and evaluated where necessary.
    Imagine a function called `integrate` that evaluates definite integrals of arbitrary
    functions, given boundary values:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Imagine being able to evaluate the integral ![Lazy evaluation](img/1217OT_07_02.jpg)
    by calling the following code:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The key would be to not evaluate the expression `x + 1/x` eagerly but pass
    it to the `integrate` function as a lazy expression. Now C++ does not have any
    built-in mechanism to create lazy expressions like these using regular variables.
    But we can quite easily write a lambda to get our job done:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: This works albeit with some syntactic noise, but in many applications, lambda
    and bind just do not scale with complexity. In this section, we briefly study
    **expression templates** and more generally, **Domain Specific Embedded Languages**
    (**DSELs**), which are the means of constructing lazily evaluated function objects
    within C++ that get your job done without sacrificing on expressive syntax.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: Expression templates
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So, how do we express a function *f(x)=x+1/x* in the language of the domain
    rather than through a syntactic compromise within the confines of C++? To create
    a generic solution, we must be able to support a variety of algebraic expressions.
    Let us start with the most basic function—a constant function, such as *f(x)=5*.
    Irrespective of the value of *x*, this function should always return 5.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: 'The following functor can be used for this purpose:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing 7.22a: An expression template mini-library – lazy literals**'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The `operator()` returns the stored `val_` and ignores its argument, which
    is unnamed. Now let us see how we can represent a function like *f(x)=x*, using
    a similar functor:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing 7.22b: An expression template mini-library – lazy variables**'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'We now have a functor that yields whatever value is passed to it; exactly what
    *f(x)=x* does. But how do we express an expression like *x + 1/x*? The general
    form of a functor that represents an arbitrary function of a single variable should
    be as follows:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Both `Constant` and `Variable` conform to this form. But consider a more complex
    expression like *f(x)=x+1/x*. We can break it down to two sub-expressions *x*
    and *1/x* acted upon by the binary operation +. The expression *1/x* can be further
    broken down to two sub-expressions *1* and *x* acted upon by the binary operation
    /.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be represented by an **Abstract Syntax Tree** (**AST**), as shown
    here:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '![Expression templates](img/1217OT_07_01.jpg)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
- en: 'The non-leaf nodes in the tree represent operations. Binary operation nodes
    have two children: the left operand is the left child and the right operand is
    the right child. The AST has an operation (*+*) at the root and two sub-expressions
    as two children. The left sub-expression is *x*, while the right sub-expression
    is *1/x*. This *1/x* is further deconstructed in a sub-tree with operation (*/*)
    at the root, *1* as the left child, and *x* as the right child. Notice that values
    like *1* and *x* only appear at the leaf level and correspond to the `Constant`
    and `Variable` classes we defined. All non-leaf nodes represent operators.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: 'We can model a complex expression as one that is composed of two sub-expressions
    with an operator:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing 7.22c: An expression template mini-library – complex expressions**'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: When the `ComplexExpression` functor is invoked, that is, when it evaluates
    its left and right sub-expressions and then applies the operator on them (line
    7), this in turn triggers the evaluation of the left and right sub-expressions.
    If they are `ComplexExpression`s themselves, then they trigger further evaluations
    that traverse down the tree, depth-first. This is definitive **lazy evaluation**.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: Now, in order to easily generate complex expression functors, we need to overload
    the arithmetic operators to combine sub-expressions of type `Constant`, `Variable`,
    `ComplexExpression<>`, or primitive arithmetic types. To do this better, we create
    an abstraction for all kinds of expressions called `Expr`. We also modify our
    definition of `ComplexExpression` to use `Expr`.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing 7.22d: An expression template mini-library – generic expressions**'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'We will pass around all kinds of expressions wrapped in `Expr`, for example,
    `Expr<Constant>`, `Expr<ComplexExpression>`, and so on. If you are unsure why
    we need the second template parameter `Enable`, then hang on for the answer in
    a bit. Before that, we will define the arithmetic operators between any two `Expr`s,
    starting with `operator+`:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing 7.22e: An expression template mini-library – overloaded operators**'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Any binary operation will produce a `ComplexExpression`. Since we will pass
    everything abstracted as `Expr`, we return `Expr<ComplexExpression<…>>` from the
    arithmetic operators. It is easy to write an `operator-`, `operator*`, or `operator/`
    on the same lines. We can replace `std::plus` with `std::minus`, `std::multiples`,
    or `std::divides` in the preceding implementation.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: 'There is only one more detail to take care of. With the preceding code, we
    can write expressions of the following form:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: But we cannot write *x + 1/x* using numeric literals. To do this, we must automatically
    convert numeric literals to `Constant`. For this, we will create a partial specialization
    of `Expr` and use `boost::enable_if` to enable it for numeric types. This is where
    the `Enable` argument of the `Expr` template comes in handy. It defaults to `void`
    for the primary template, but it helps us write the partial specialization for
    wrapping arithmetic-type literals.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing 7.22f: An expression template mini-library – a small trick**'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'This partial specialization is invoked only when `E` is an arithmetic type
    (`int`, `double`, `long`, etc.). This stores the arithmetic value as a `Constant`.
    With this change, we can use numeric literals in our expressions, and as long
    as there is a single `Variable` in the expression, the literals would get wrapped
    in a `Constant` via the partial specialization in listing 7.22f. We can now generate
    a functor using just natural algebraic expressions:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing 7.22g: An expression template mini-library – using the expressions**'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: We can add many more refinements to this very basic *expression template* library
    of not even a hundred lines of code. But it already allows us to generate arbitrary
    algebraic functions of a single variable using very simple syntax. This is an
    example of a *Domain Specific Language*. Also, specifically, because we use valid
    C++ syntax to do all this instead of defining a new syntax, it is specifically
    called **Domain Specific Embedded Language** (**DSEL**) or sometimes **Embedded
    Domain Specific Language** (**EDSL**). We will now look at Boost Phoenix, an elaborate
    library of lazy expressions.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: Boost Phoenix
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Boost Phoenix 3 is a library for enabling functional programming constructs
    in C++. It defines an elaborate and very readable DSEL with scores of functors
    and operators, which can be used to generate fairly involved lambdas. It provides
    a comprehensive library for constructing lazy expressions and an excellent example
    of what expression templates can achieve. This section features a very short introduction
    to using Phoenix expressions as lambdas, and we will see some examples of using
    Phoenix with Boost Spirit Parser Framework. It is too extensive a library to cover
    in a single chapter, let alone a subsection of it, but this introduction should
    still provide enough tail wind to master Phoenix, with the benefit of the excellent
    online documentation.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: Phoenix expressions are composed of **actors**, which are abstractions for lazy
    functions. Actors are used to generate unnamed functions or lambdas. They support
    partial function application by binding some arguments to values and keeping others
    unspecified. They can be composed to generate more complex functors. In that sense,
    Phoenix is a lambda language library.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: 'Actors are categorized based on functionality and exposed through a set of
    header files. The most basic actor is `val` which represents a lazy immutable
    value (not unlike the `Constant` functor in our expression template example).
    The `ref` actor is used to create a lazy mutable variable reference, and the `cref`
    actor generates a lazy immutable reference. There is a whole set of actors that
    define lazy operators, including arithmetic (`+`, `-`), comparison (`<`, `==`,
    `>`), logical (`&&`, `||`), bitwise operators (`|`, `^`, `&`), and other kinds
    of operators. Using just these, we can construct algebraic expressions, as we
    do in the following example:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing 7.23: Lazy algebraic expressions with Phoenix**'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Using `boost::phoenix::ref`, we generate an actor for lazily evaluating the
    variable `eX` (**e** for **eager**) and cache it in a variable `x`. The expressions
    `x + 1/x` and `x*x – x + 4` generate anonymous functors just like the expression
    templates from listing 7.22, except that `x` is already bound to the variable
    `eX`. The actor `x` is said to **infect** the numeric literals in the expressions
    by its presence; the literals get wrapped in `boost::phoenix::val`. The operators
    `+`, `-`, `*`, and `/` used in the expression are lazy operators from Phoenix
    (just like the operators we defined for our expression template in listing 7.22e)
    and generate anonymous functors.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: 'Writing simple lambdas can sometimes be extremely succinct using Phoenix. Look
    at how we can print each element in a vector using `std::for_each` and Phoenix''s
    lazy `operator<<`:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing 7.24: Simpler lambdas with Phoenix**'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: The expression `std::cout << arg1` is actually a lambda that generates a functor.
    The actor `arg1` (`boost::phoenix::arg_names::arg1`) represents the first argument
    to the functor and is lazily evaluated. The presence of `arg1` in the expression
    `std::cout << arg1` invokes the lazy `operator<<` and infects the entire expression
    to generate an unnamed function that prints its argument to the standard output.
    In general, you can use `arg1` through `argN` to refer to the lazy arguments of
    an N-ary functor generated with Phoenix. By default, up to ten argument actors
    (`arg1` through `arg10`) are supported. These are akin to `_1`, `_2`, etc. for
    `boost::bind`. You can also use `boost::phoenix::placeholders::_1`, `_2`, etc.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: 'Phoenix actors are not limited to expressions involving operators. We can generate
    actors that lazily evaluate entire blocks of code with branching and looping constructs.
    Let us say we have a vector of the names of personnel in a band''s lineup, and
    we want to print whether a person is a vocalist or instrumentalist:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing 7.25: Lazy control structures with Phoenix**'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: We want to run through the vector of last names of the four legendary members
    of *The Who* and list them with their roles. For (Roger) Daltrey, the role would
    be of a vocalist and for the others, instrumentalist. We use `std::for_each` to
    iterate the list of names. We pass a unary functor to it generated using Phoenix's
    statement actors, specifically `boost::phoenix::if_`.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax is intuitive enough to look at and understand what is going on.
    The actual statements in the `if_` and `else_` blocks are put in square brackets
    instead of braces (which cannot be overloaded) and are lazily evaluated. If there
    were multiple statements, they would need to be separated by commas. Notice how
    the `else_` is a member call invoked with a dot on the preceding expression (line
    18). The presence of `arg1` is said to *infect* the statements, that is, it invokes
    the lazy `operator<<` and causes the literal character strings to be automatically
    wrapped in `boost::phoenix::val` (lines 16, 17, 19). Running this code prints
    the following:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'The power of Phoenix should be evident already. It defines an expressive sub-language
    using, standard C++ operator overloading and functors that easily generates unnamed
    functions or lambdas as needed, and starts to mimic the host language itself.
    There is more to the Phoenix library. It is chock-full of actors for lazy evaluation
    of STL container member functions and STL algorithms. Let us look at an example
    to understand this better:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing 7.26: Actors for STL algorithms and container member functions**'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: We have a vector `greets` of hello greetings in different languages (English,
    Spanish, Swahili, and German), and we want to search for a specific greet. We
    want to do so lazily using Phoenix. Phoenix provides actors for generating lazy
    versions of most STL algorithms. We use the lazy form of the `std::find` algorithm
    available via the header `boost/phoenix/stl/algorithm.hpp` (line 5), and call
    the `boost::phoenix::find` actor to generate a unary functor named `finder` (line
    14). The `finder` functor takes as its only argument, the string to look for in
    `greets`. The call `boost::phoenix::find(greets, arg1)` takes two arguments and
    generates a unary functor. The first argument is a reference to the vector `greets`,
    which is automatically wrapped in a `cref` actor and stored for lazy evaluation
    later. The second argument to `find` is the Phoenix placeholder `arg1`.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: When `finder` is called with the string to lookup as its sole argument, it evaluates
    the `arg1` actor to get this string argument. It also evaluates the `cref` actor
    it stored earlier to get a reference to `greets`. It then calls `std::find` on
    the `greets` vector, looking for the string passed, which returns an iterator.
    We look for the string `Hujambo` which is the present in the vector(line 15).
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: 'To check whether the iterator returned is valid, we need to compare it against
    `greets.end()`. Just to show that it can be done, we generate the lazy version
    of the `end` member function call using the `boost::phoenix::end` actor available
    from the header `boost/phoenix/stl/algorithm.hpp`. The call `boost::phoenix::end(greets)`
    generates a functor, and we call it in-place by suffixing parentheses. We compare
    the result with the iterator returned by `finder` (line 17). We print the greeting
    pointed by the iterator returned by `find` and the element after that (lines 18-20):'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Actors from Phoenix are polymorphic. You can apply `boost::phoenix::find` on
    any kind of container that supports searching via `std::find`, and you can look
    up an object of any type that the underlying container can store.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: 'In the final example on Phoenix, we look at how we can define our own actors,
    which can fit in with the rest of Phoenix. We have a vector of names from which
    we print the first name in each entry, using `std::for_each` and functors generated
    using Phoenix. We extract first names from a name string by looking up the first
    space character in the string and extracting the prefix up to that point. We can
    use the `find` actor to locate the space but to extract the prefix, we need a
    lazy way to call the `substr` member of `std::string`. There is no `substr` actor
    currently available in Phoenix, so we need to roll out our own:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing 7.27: User defined actors and STL actors**'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: We write the `substr_impl` functor, which has a member template `operator()`
    (line 17) and a metafunction called `result` (line 12). The `operator()` is a
    template used to make `substr_impl` polymorphic. Any type `C` with a member function
    called `substr`, which takes two parameters of type `F1` and `F2` (which may or
    may not be of different types) can be covered by this single implementation (lines
    17-20). The embedded `type` in the `result` metafunction is the return type of
    the wrapped function (`substr`). The actual `substr` actor is an instance of type
    `boost::phoenix::function<substr_impl>` (line 29). We use the `substr` actor,
    we just defined, to generate a unary functor, which we pass to the `std::for_each`
    algorithm (lines 32-33). Since we want to extract the first name from each string
    in the `names` vector, the first argument is `arg1` (the name passed to the functor),
    the second offset argument is 0, while the third length argument is the offset
    of the first space character in the string. The third argument is calculated lazily
    as the expression `boost::phoenix::find(arg1, ' ') – boost::phoenix::begin(arg1)`.
    The `find(arg1, ' ')` is an actor that looks up the first space in the string
    passed to it using the generic find actor from Phoenix that we also used in listing
    7.26\. The `begin(arg1)` is an actor that returns the begin iterator of its argument
    (in this case the string). The difference between them returns the length of the
    first name.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: Boost Spirit Parser Framework
  id: totrans-329
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Boost Spirit is a very popular DSEL used for generating lexers and parsers,
    which uses Boost Phoenix. Writing custom lexers and parsers used to be heavily
    reliant on specialized tools like lex/flex, yacc/bison, and ANTLR that generated
    C or C++ code from a language neutral specification in the **Extended Backus-Naur
    Form** (EBNF). Spirit eliminates the need for creating such a specification outside
    the language, and for tools to translate from such specifications. It defines
    a declarative DSEL with intuitive syntax in C++ and uses only the C++ compiler
    to generate parsers. Spirit makes heavy use of template metaprogramming, resulting
    in slower compile times but generates parsers that are efficient at runtime.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: Spirit is a rich framework that includes Spirit Lex – a lexer, Spirit Qi – a
    parser, and Spirit Karma – a generat. You can use these separately, or use them
    all in collaboration to build powerful data translation engines.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: 'In this book we only look at Spirit Qi. It is used primarily to parse *text
    data* according to some specified *grammar* that the data is supposed to obey,
    with the following objectives:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: Verifying that the input conforms to the grammar
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decomposing a conforming input into meaningful semantic components
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, we can parse some input text to verify whether it is a valid timestamp,
    and if it is, extract the components of the timestamp, such as year, month, day,
    hours, minutes, and so on. For this, we need to define a grammar for the timestamp,
    and we need to define the actions to be taken, as we parse the data in terms of
    its semantic constituents. Let us see a concrete example.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: Using Spirit Qi
  id: totrans-336
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Spirit provides **predefined parsers**, which can be combined using **parser
    operators** defined by Spirit, to define a parser for our needs. Once defined,
    we can store the parser or its components as **rules** that can be combined with
    other rules. Or we can directly pass it to a Qi **parsing API**, such as `parse`
    or `phrase_parse`, along with the input to parse.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: Predefined parsers
  id: totrans-338
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Qi provides a number of predefined parsers that can be used to parse basic
    pieces of data. The parsers are available or aliased under the namespace `boost::spirit::qi`.
    Here is a listing of these parsers with their purpose:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: '| Input class | Parsers | Purpose |'
  id: totrans-340
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-341
  prefs: []
  type: TYPE_TB
- en: '| Integers | `int_`, `uint_`, `short_`, `ushort_`, `long_`, `ulong_`, `long_long`,
    `ulong_long` | Parse signed and unsigned integers |'
  id: totrans-342
  prefs: []
  type: TYPE_TB
- en: '| Real numbers | `float_`, `double_`, `long_double` | Parse real numbers with
    decimal points |'
  id: totrans-343
  prefs: []
  type: TYPE_TB
- en: '| Boolean | `bool_`, `true_`, `false_` | Parse either or both the strings,
    `true` and `false` |'
  id: totrans-344
  prefs: []
  type: TYPE_TB
- en: '| Characters | `char_`, `alpha`, `lower`, `upper`,`digit`, `xdigit`, `alnum`,`space`,
    `blank`,`punct`, `cntrl`, `graph`, `print` | Parse characters of different classes,
    like letters, digits, hexadecimal digits, punctuation, etc. |'
  id: totrans-345
  prefs: []
  type: TYPE_TB
- en: '| Strings | `String` | Parse specific strings |'
  id: totrans-346
  prefs: []
  type: TYPE_TB
- en: The parsers listed in the preceding table are predefined objects rather than
    types. There are generic parser templates corresponding to each of these parsers.
    For example, the template `boost::spirit::qi::int_parser` can be used to define
    custom parsers for signed integers. There are many other templates, including
    `boost::spirit::qi::uint_parser`, `boost::spirit::qi::bool_parser`, and so on.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: The parsing API
  id: totrans-348
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Qi provides two function templates, `parse` and `phrase_parse`, that are used
    to parse text input. Each takes a pair of iterators that define the input range
    and a parser expression. In addition, `phrase_parse` takes a second parser expression
    that is used to match and skip whitespace. The following short example shows you
    the essence of using Spirit:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing 7.28: A simple Spirit example**'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: We include the header file `boost/spirit/include/qi.hpp` in order to access
    Spirit Qi functions, types, and objects. Our input is the string `Hello, world!`,
    and using the predefined parser `alpha`, we want to enforce that the first character
    is a letter from the Latin alphabet, as opposed to a digit or a punctuation symbol.
    For this, we use the `parse` function, passing it a pair of iterators defining
    the input and the `alpha` parser (line 10). The `parse` function returns `true`
    if the parser successfully parses the input and false otherwise. The iterator
    to the start of the range is incremented to point to the first unparsed character
    in the input. Since the first character of `Hello, world!` is H, the `alpha` parser
    parses it successfully, incrementing the `iter` by 1 (line 13) and `parse` returns
    `true` (line 12). Note that the first iterator is passed as a non-const reference
    to `parse` and is incremented by parse; the reason we pass a copy of `str.begin()`.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: Parser operators and expressions
  id: totrans-353
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Spirit defines a number of overloaded operators called **parser operators**
    which can be used to compose a complex parser expression out of simpler parsers,
    including the predefined ones. The following table summarizes some of these operators:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: '| Operator | Type | Purpose | Example |'
  id: totrans-355
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  id: totrans-356
  prefs: []
  type: TYPE_TB
- en: '| >> (Sequence operator) | Binary, infix | Two parsers serially parse two tokens
    | `string("Hello") >> string("world")`Matches `Helloworld`. |'
  id: totrans-357
  prefs: []
  type: TYPE_TB
- en: '| &#124; (Disjunction operator) | Binary, infix | Any one of the two parsers
    is able to parse the token, but not both | `string("Hello") &#124; string("world")`Matches
    either `Hello` or `world` but not `Helloworld`. |'
  id: totrans-358
  prefs: []
  type: TYPE_TB
- en: '| * (Kleene operator) | Unary, prefix | Parses the empty string or one or more
    matching tokens | `*string("Hello")`Matches the empty string, `Hello`, `HelloHello,`
    and so on. |'
  id: totrans-359
  prefs: []
  type: TYPE_TB
- en: '| + (Plus operator) | Unary, prefix | Parses one or more matching tokens |
    `+string("Hello")`Matches `Hello`, `HelloHello,` and so on, but not the empty
    string. |'
  id: totrans-360
  prefs: []
  type: TYPE_TB
- en: '| ~ (Negation operator) | Unary, prefix | Parses a token that does not match
    the parser | `~xdigit`Will parse any character that is not a hexadecimal digit.
    |'
  id: totrans-361
  prefs: []
  type: TYPE_TB
- en: '| - (Optional operator) | Unary, prefix | Parses the empty string or a single
    matching token | `-string("Hello")`Matches `Hello` or the empty string. |'
  id: totrans-362
  prefs: []
  type: TYPE_TB
- en: '| - (Difference operator) | Binary, infix | *P1 - P2* parses any token that
    P1 can parse and P2 cannot | `uint_ - ushort_`Matches any `unsigned int` that
    is not also an `unsigned short`. Matches 65540 but not 65530 on a system with
    2-byte `short`. |'
  id: totrans-363
  prefs: []
  type: TYPE_TB
- en: '| % (List operator) | Binary, infix | *P1 % D* splits the input into tokens
    that match P1 at delimiters that match D | `+alnum % +(space&#124;punct)`Splits
    input text strings into alphanumeric strings, using spaces and punctuations as
    delimiters. |'
  id: totrans-364
  prefs: []
  type: TYPE_TB
- en: '| &#124;&#124; (Sequential OR operator) | Binary, infix | *P1 &#124;&#124;
    P2* is equivalent to *P1 &#124; (P1 >> P2)* | `string("Hello") &#124;&#124; string("world")`Matches
    either `Hello` or `Helloworld` but not `world`. |'
  id: totrans-365
  prefs: []
  type: TYPE_TB
- en: Note that there is a unary `operator-`, which is the optional operator, and
    binary `operator-`, which is the difference operator.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: The `boost::spirit::qi::parse` function template does not skip any characters
    whitespaces while parsing. Sometimes, it is convenient to ignore intervening spaces
    between tokens while parsing, and the `boost::spirit::qi::phrase_parse` does this.
    For example, the parser `string("Hello") >> string("world")` would parse `Helloworld`
    when we use `boost::spirit::qi::parse`, but not `Hello, world!`. But if we used
    `phrase_parse` and ignored spaces and punctuation, then it would parse `Hello,
    world!` too.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing 7.29: Using phrase_parse**'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Note that we pass `+(space|punct)` as the fourth argument to `phrase_parse`,
    which tells it which characters to ignore; spaces and punctuation.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: Parsing directives
  id: totrans-371
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Parsing directives are modifiers that can be used to alter the behavior of
    parsers in some way. For example, we can perform case-insensitive parses using
    the `no_case` directive, as shown in the following snippet:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'The `skip` directive can be used to skip whitespace over a section of the input:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: The directive `qi::skip(qi::space)[parser]` ignores spaces even though we called
    `parse` and not `phrase_parse`. It can be selectively applied to parser sub-expressions.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: Semantic actions
  id: totrans-377
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: More often than not, while using Spirit, we are not just looking to verify that
    a piece of text conforms to a certain grammar; we want to extract the tokens and
    perhaps use them in some kind of calculation or store them away. We can associate
    some action to a parser instance to be run when it successfully parses text, and
    this action can perform the necessary computation using the result of the parse.
    Such actions are defined using a function object enclosed in square brackets,
    trailing the parser it is associated with.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing 7.30: Defining actions associated with parsers**'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: In the preceding example, we parse a list of unsigned integers separated by
    spaces (line 10) using the `uint_` parser (line 14). We define a function `print`
    (line 5) to print unsigned integers and associate it as an action with the `uint_`
    parser (line 14). For each unsigned integer parsed, the preceding code prints
    it on a new line by invoking the specified action. Actions can also be specified
    using functors, including those generated by Boost Bind and Boost Phoenix.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: Each parser, from the primitive to the most complex, has an associated *attribute*,
    which is set to the result of a successful parse, that is, the text it matches
    when it is applied to some input converted to the appropriate type. For a simple
    parser like `uint_`, this attribute would be of type `unsigned int`. For complex
    parsers, this could be an ordered tuple of attributes of its constituent parsers.
    When an action associated with a parser is invoked, it is passed the value of
    the parser's attribute.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: 'The expression `+qi::uint_[print]` associates the print function with the `uint_`
    parser. If instead we wanted to associate an action with the composite parser
    `+qi::uint_`, then we would need to use a function with a different signature—one
    with a parameter of type `std::vector<unsigned int>` that would contain all the
    parsed numbers:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'We can use Boost Bind expressions and Phoenix actors too for generating the
    action. Thus, we could have written `+qi::uint_[boost::bind(print, ::_1)]` to
    call `print` on each parsed number. The placeholders `::_1` through `::_9` are
    defined by the Boost Bind library in the global namespace. Spirit provides Phoenix
    actors that can be used for a variety of actions. The following snippet shows
    a way to add parsed numbers into a vector:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: The action expression `push_back(boost::phoenix::ref(vec), qi::_1)` uses the
    `boost::phoenix::push_back` actor to append each parsed number (represented by
    the placeholder `qi::_1`) to the vector `vec`.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: 'There are overloads of the `parse` and `phrase_parse` function templates that
    take an attribute argument in which you can directly store the data parsed by
    the parser. Thus, we can pass a `vector` of `unsigned int`s as the attribute argument,
    while parsing the list of unsigned integers:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Rules
  id: totrans-390
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'So far, we have generated parsers using inline expressions. When dealing with
    more complex parsers, it is useful to cache the components and reuse them. For
    this purpose, we use the `boost::spirit::qi::rule` template. The rule template
    takes up to four arguments of which the first, that is, the iterator type for
    the input, is mandatory. Thus, we can cache a parser that parses spaces in `std::string`
    objects, as shown here:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Notice that `space_rule`, defined as above, is a parser that follows the same
    grammar as `qi::space`.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: 'More often than not, we are interested in consuming the value parsed by the
    parser. To define a rule containing such a parser, we need to specify the signature
    of a method that would be used to obtain the parsed value. For example, the `boost::spirit::qi::double_`
    parser''s attribute is of type `double`. So, we consider a function taking no
    arguments and returning a `double` as the appropriate signature `double()` to
    use. This signature is passed as the second template argument to the rule:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'If the rule is meant to skip spaces, we specify the type of parser that is
    used to identify the characters to skip as the third template argument to `rule`.
    Thus, to define a parser for a list of `double`s separated by spaces, we can use
    the following rule with `qi::space_type`, specifying the type of the space parser:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'When a rule is defined in terms of a combination of parsers, the value parsed
    by the rule is synthesized from the values parsed by the individual component
    parsers. This is called the **synthesized attribute** of the rule. The signature
    argument to the rule template should be compatible with the type of the synthesized
    attribute. For example, the parser `+qi::double_` returns a sequence of doubles,
    and therefore, the type of the synthesized attribute is `std::vector<std::double>`:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Notice that we assign the parser to the rule on a separate line, using `operator
    %=`. If we did not use the `%=` operator and used the plain assignment operator
    instead, then the result of a successful parse using `+qi::double_` would not
    be propagated to the synthesized attribute of `doubles_p`. Thanks to the `%=`
    operator, we can associate a semantic action with `doubles_p` to access its synthesized
    value as a `std::vector<double>`, as shown in the following example:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: Parsing timestamps
  id: totrans-402
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Consider timestamps of the form YYYY-mm-DD HH:MM:SS.ff, in which the date part
    is mandatory and the time part is optional. Moreover, the seconds and fractional
    seconds part of the time are also optional. We need to define a suitable parser
    expression.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we require is a way to define parsers for fixed-length unsigned
    integers. The `boost::spirit::qi::int_parser` template comes in handy for this
    purpose. Using template parameters of `int_parser`, we specify the base integral
    type to use, the radix or base of the number system, and the minimum and maximum
    number of digits to allow. Thus, for 4-digit years, we can use a parser type `int_parser<unsigned
    short, 10, 4, 4>`, both the minimum and maximum width being 4, as we need fixed-length
    integers. The following are the rules constructed using `int_parser`:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Of course, we need to define actions to capture the components of the timestamp.
    For simplicity, we will associate actions with the component parsers. We will
    define a type to represent timestamps and associate actions with parsers to set
    attributes of an instance of this type.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing 7.31: Simple date and time parser**'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: The `timestamp_t` type (line 6) represents a timestamp, with getters and setters
    for each of its fields. We have omitted most of the getters and setters for conciseness.
    We define actions associated with parsers for individual fields of the timestamp,
    setting appropriate attributes of a `timestamp_t` instance using `boost::bind`
    (lines 25, 27, 29, 32, 35, 38, 40).
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: Self-test questions
  id: totrans-410
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For multiple choice questions, choose all the options that apply:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: Which of the following overloads/specializations does the call `foo(1.0, std::string("Hello"))`
    resolve to?
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. `template <typename T, typename U> foo(T, U);`
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: b. `foo(double, std::string&);`
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: c. `template <> foo<double, std::string>`
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: d. There is ambiguity
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: What is the interface that a metafunction must satisfy?
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. It must have a static `value` field
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: b. It must have an embedded type called `type`
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: c. It must have a static `type` field
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: d. It must have an embedded type called `result`
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: 'What does the following statement do: `boost::mpl::or_<boost::is_floating_point<T>,
    boost::is_signed<T>>`?'
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. Checks whether type T is signed and a floating point type
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: b. Generates a metafunction that checks (a)
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: c. Checks whether type T is signed or a floating point type
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: d. Generates a metafunction that checks (b)
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: 'We have a template declared as: `template <typename T, typename Enable = void>
    class Bar` and does not use the `Enable` parameter in any way. How do you declare
    a partial specialization of Bar that would be instantiated only when T is a non-POD
    type?'
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. `template <T> class Bar<T, boost::is_non_pod<T>>`
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: b. `template <T> class Bar<T, boost::enable_if<is_non_pod<T>>::type>`
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: c. `template <T> class Bar<T, boost::mpl::not<boost::is_pod<T>>>`
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: d. `template <T> class Bar<T, boost::disable_if<is_pod<T>>::type>`
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: Which of the following is true of C++ lambda expressions and Boost Phoenix actors?
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. Lambda expressions are unnamed, Phoenix actors are not
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: b. Phoenix actors are polymorphic, while polymorphic lambda expressions are
    only available from C++14
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: c. Phoenix actors can be partially applied, while lambda expressions cannot
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: d. Lambda expressions can be used as closures but Phoenix actors cannot
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-437
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter was an interlude in our exploration of the Boost libraries. There
    were two key underlying themes: more expressive code and faster code. We saw how
    higher order programming helps us achieve more expressive syntaxes using functors
    and operator overloading. We saw how template metaprogramming techniques allow
    us to write code that executes at compile time and chooses the most optimal implementations
    for the task at hand.'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: We covered a diverse amount of material in a single chapter and introduced a
    paradigm of programming that may be new to some of you. We solved a few problems
    with different functional patterns and saw the power of C++ functors, templates,
    and operator overloading put together. Understanding the subject of this chapter
    will be of immediate help if you are reading the implementation of most Boost
    libraries or trying to write a fast general purpose library that is efficient,
    expressive, and extensible.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: There is a lot that we did not cover in this chapter and do not cover in this
    book, including many, but the most basic details of Boost Spirit, a DSEL construction
    kit, Boost Proto; an expression template-based fast regular expression library,
    Boost Xpressive; and a more advanced tuple library, Boost Fusion. Hopefully, this
    chapter gives you enough of a head start to explore them further. Starting with
    the next chapter, where we cover Boost libraries for date and time calculations,
    we switch gears to focus on systems programming libraries in Boost.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: References
  id: totrans-441
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*C++ Common Knowledge*, *Stephen C. Dewhurst*, *Addison Wesley Professional*'
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Modern C++ Design*, *Andrei Alexandrescu*, *Addison Wesley Professional*'
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*C++ Template Metaprogramming*, *David Abrahams and Aleksey Gurtovoy*, *Addison
    Wesley Professional*'
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Proto: [http://web.archive.org/web/20120906070131/http://cpp-next.com/archive/2011/01/expressive-c-expression-optimization/](http://web.archive.org/web/20120906070131/http://cpp-next.com/archive/2011/01/expressive-c-expression-optimization/)'
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Boost Xpressive FTW: [http://ericniebler.com/2010/09/27/boost-xpressive-ftw/](http://ericniebler.com/2010/09/27/boost-xpressive-ftw/)'
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Fusion: [www.boost.org/libs/fusion](http://www.boost.org/libs/fusion)'
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
