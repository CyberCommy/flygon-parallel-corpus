- en: Creating Reusable Form Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most powerful parts of Vue is its capability to make components.
  prefs: []
  type: TYPE_NORMAL
- en: Components are reusable bits of code that usually include a template, scripts,
    and styles. The amazing thing about components is that you can box up all the
    logic for a specific element, or group of elements, into a single unit.
  prefs: []
  type: TYPE_NORMAL
- en: A good way to start thinking in terms of components is to start breaking down
    everyday objects into simple, smaller pieces. (In your mind please!)
  prefs: []
  type: TYPE_NORMAL
- en: Take, for example, the computer that you are working on. As a whole, the whole
    system could be called a computer. Now break it down even more—it has a monitor,
    a keyboard, and cables. Now take the keyboard and break it down. You now have
    a container, and this container has keys. Each key is a single component, which
    repeats itself, with some properties that vary between each other. The label on
    the key changes, and sometimes also the size.
  prefs: []
  type: TYPE_NORMAL
- en: What about this key component? Can you break it down further? Maybe! But is
    it worth it? A keyboard key is a good single component. It has clear properties
    that define it, and we could clearly define its internal functionality. When it
    is pressed, we need to tell whoever is containing it that a key was pressed, and
    the value of that key.
  prefs: []
  type: TYPE_NORMAL
- en: This process of mentally breaking something down can also be applied to any
    Vue application. Start out with the app as a whole single unit and break it down.
  prefs: []
  type: TYPE_NORMAL
- en: Right now, our current form is one big blob on `App.vue`, which is less than
    ideal. Let's create some components!
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Breaking down an application into reusable components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding `v-model` in custom components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing custom input and select components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code for this chapter can be found in the following GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Building-Forms-with-Vue.js/tree/master/Chapter03](https://github.com/PacktPublishing/Building-Forms-with-Vue.js/tree/master/Chapter03).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the code in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://bit.ly/2qgj7wx](http://bit.ly/2qgj7wx)'
  prefs: []
  type: TYPE_NORMAL
- en: Breaking down the form into components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Taking a look at `App.vue`, let's start with the smallest possible component
    that we can create. If you look carefully, you will see a repeating pattern in
    the code—this is usually a good sign that something could make for a good component!
  prefs: []
  type: TYPE_NORMAL
- en: Within our `<form>` element, we have three different text inputs. Two of them
    are of `type` `text`, and one of them is of `type` `email`. Looks like we will
    need some way to assign these values to the `type` attribute. A prop object could
    be a simple solution!
  prefs: []
  type: TYPE_NORMAL
- en: 'As a quick reminder, here''s the current code for the form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Go ahead and create a new file inside the `src/components` folder, naming it
    `BaseInput.vue`. Personally, I like to name my very basic input components starting
    with `Base`; that way, I know that it is the simplest possible form of an input
    that I can find in my application.
  prefs: []
  type: TYPE_NORMAL
- en: 'If I ever need to make a component that extends or uses `Base` in some way,
    then I can simply import the `BaseInput` component, and make some adjustments!
    Do feel free, however, to use any naming convention that you prefer. If you want
    some actual style guidelines and best practices for naming components and such,
    refer to the official guide here: [https://vuejs.org/v2/style-guide/](https://vuejs.org/v2/style-guide/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s copy over the first input from `App.vue` into our new component inside
    the `<template>` tags, so that we have a base to work on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The first thing we need to do is figure out how to get rid of the hardcoded
    values; the purpose of extracting code into components is, after all, for them
    to be dynamic and reusable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a prop object to hold the value of `label` (with the name `string`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We are going to use the extended way to declare properties, with object notation.
    This way, we can ensure that anyone using our component will at least get yelled
    at by the console in the browser if they forget to define the label.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s go back to the template and actually replace this value with the
    newly created prop object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: One more to go, what about the type? We may want to use this (and we will) for
    email, and eventually password fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a new prop object for this, and bind it, like before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Our new type of property has a default value, which will be used in the event
    that the prop is missing from the component when it's implemented.
  prefs: []
  type: TYPE_NORMAL
- en: '`validator` is a function that, well—validates! It takes a single argument,
    the value that is getting passed into the property, and it has to return a Boolean
    to verify that the value is acceptable for the property (`validator` validates!).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this particular case, we''re just checking that it is one of the three choices
    that we will allow for this component: `text`, `email`, or `password`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we are set, let''s update `<input>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: So far, so good! Except that there is one thing still missing, which we have
    to refactor. Can you spot it?
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have seen how to break down the form into components. Let's now take
    a deeper look at `v-model`, and its importance when creating dynamic components.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding v-model in custom components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you know, `v-model` is shorthand for `v-on:input` and `v-bind:value="value"`
    on a given element. It allows us to two-way bind a particular element's value,
    and the events that it emits to one of our internal state properties.
  prefs: []
  type: TYPE_NORMAL
- en: When talking about component composition, however, we need to take extra things
    into consideration.
  prefs: []
  type: TYPE_NORMAL
- en: In order for a custom component to be able to implement the `v-model` contract,
    we have to make sure that two things happen. That's right! We need to ensure that
    the component has a `value` property and that it `$emits` an input event.
  prefs: []
  type: TYPE_NORMAL
- en: There is a way to change this default behavior by using the `model` property,
    but it is out of the scope of this book. If you want to tell your component to
    use a different property, or a different event for `v-model`, take a look at [https://vuejs.org/v2/api/#model](https://vuejs.org/v2/api/#model).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s put this theory into practice. We''re going to modify our `BaseInput`
    component, in order to be able to use a `v-model` binding. First, let''s add a
    `value` property, and hook it to `<input>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our new `value` prop, we need to bind it to the value of `<input>`.
    Be sure to remove the old `v-model` from it, though! Have a look at the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Almost there; now we need to make sure that `<input>` dispatches input events
    whenever it updates. So, we need to add an event handler that `$emits` this information.
  prefs: []
  type: TYPE_NORMAL
- en: '**Important!** Before we continue, let me tell you about a very common *gotcha* when
    working with `v-model` and forms. Not all inputs are created equally! The `<input>` text
    elements (`text`, `email`, and `password`) and `<textarea>` are easy. They fire
    input events that we can listen to for our `v-model` binding. But, what about
    `select`, `checkboxes`, and `radio`?'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Vue documentation makes it super clear, so I''m going to quote it:'
  prefs: []
  type: TYPE_NORMAL
- en: '"*`v-model` internally uses different properties and emits different events
    for different input elements:*'
  prefs: []
  type: TYPE_NORMAL
- en: '*`text` and `textarea` elements use `value` property and `input` event;*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*`checkboxes` and `radiobuttons` use `checked` property and `change` event;*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*`select` fields use `value` as a prop and `change` as an event.*"'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that we have got that theory out of the way, let''s actually listen to
    our event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Congratulations! Our `BaseInput` component is ready to be used.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a clear understanding of `v-model` and custom components, we're
    going to get to use our component inside our form. It will make it far more readable,
    dynamic, and easy to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a custom input component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating reusable custom components is a core part of Vue, but for the components
    to actually be useful, we have to actually *use* them!
  prefs: []
  type: TYPE_NORMAL
- en: Open up your `App.vue` file, and let's replace the three `<div class="form-group">`
    elements with our custom component.
  prefs: []
  type: TYPE_NORMAL
- en: 'First things first: what we have to do is import the component to our file.
    Let''s get that out of the way. Add the following import to the top of the `<script>`
    element, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Just importing the file is not enough; we actually have to add the component
    to the component''s property on the file, so that we can then use it inside our
    template. We currently do not have such a property inside our Vue instance, so
    let''s create one between `name` and `data()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our component registered, and imported on our `App.vue` file,
    we can go into the template and replace the old inputs with our new component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Go back to your browser, and play around with the app. You should see that,
    even though nothing has actually changed, the form is now driven by reusable input
    components—if we were ever faced with the need to update the inputs' CSS, for
    example, we could simply change it once in that file, and the whole application
    would update to reflect those changes.
  prefs: []
  type: TYPE_NORMAL
- en: Open up your Vue DevTools once again, and make sure that you have the first
    icon selected (the one for the component structure). Drill down into the structure
    and you will see your three `BaseInput` components represented there.
  prefs: []
  type: TYPE_NORMAL
- en: You can even go ahead and click each one of them, and the props panel will clearly
    display what makes each one of them unique—the props!
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following screenshot, you can see that, when I type my name into the
    Name: field, the <BaseInput> component reflects it in its value property:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/eb3fa2e1-52a8-49f4-a9b7-3adfbecd54f6.png)'
  prefs: []
  type: TYPE_IMG
- en: One more thing! Type some values into the form and look at the props box, it
    will update live with the two-way binding in your value property. Now, click on
    the third icon on your DevTools, the one that looks like a bunch of dots—this
    is the events view.
  prefs: []
  type: TYPE_NORMAL
- en: Type in one of the inputs again, and you will see that the events box will fill
    up with entries. Click on one of them, and you'll notice that our input event
    is being fired with each keystroke.
  prefs: []
  type: TYPE_NORMAL
- en: These are two different *actions—*the value getting updated and the input event
    being fired make up for the `v-model` doing its job, as we discussed earlier!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/8da52196-dedc-4554-94eb-2c40913540cc.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding screenshot, you can see how the `<BaseInput>` component is
    emitting input events—`payload` is what the user has typed into the form.
  prefs: []
  type: TYPE_NORMAL
- en: One more time – with dropdowns!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we wrap up the chapter, let's build a custom component that wraps up
    a drop-down input, in order to review what we have learned so far.
  prefs: []
  type: TYPE_NORMAL
- en: Begin by creating the component file—we are going to name it `BaseSelect.vue`,
    and place it inside the `components` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Just as we did with `BaseInput`, first we are going to define our HTML template.
    We will leave some attributes empty for now, since we will bind them later. We
    will also set up some dummy data for easy testing. In component creation, you
    will find that small steps are the way to go!
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code as a template for `BaseSelect`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Looking good! Let''s import this new component into `App.vue`, and into our
    template, so that we can test it in action in our browser. Follow the given steps
    to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the component on the top of your `script` element, next to the `BaseInput`
    import statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Add `BaseSelect` to your `components` declaration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an instance of `BaseSelect` inside the `<template>` element, right below
    the last `BaseInput` component, and before the `div` that holds the input button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Check your browser, and you will see our newly selected component in action.
    Isn't she beautiful?
  prefs: []
  type: TYPE_NORMAL
- en: Let's take it a step further, we are in dire need of some `props`. Let's start
    by adding `label`; we can see from the template that it will need to be made dynamic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create your `props` object inside a new `script` element, and add it to the
    list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, head to the template and dynamically bind them. We need to make the contents
    of `<label>` dynamic with some interpolation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, so good! Go back to `App.vue`, and add these new `props` to our example
    component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Test it out in your browser to make sure nothing is broken. The component is
    working pretty well so far, but the options it displays are still hardcoded. Let's
    implement an `options` property—this time it will be an array of objects, which
    we will use to populate the `select` options.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go back to `BaseSelect.vue` and create the new property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: For the `validator` object, we will use the JavaScript array, in order to find
    a method to see if we can find an element inside the array that is not an object.
    If something is found, the `find` method will return it and `!` will evaluate
    it to `false`, which will throw a console error. If nothing is found (and all
    the elements are objects), then `find` will return `undefined`, which `!` will
    turn to `true`, and the validation will pass.
  prefs: []
  type: TYPE_NORMAL
- en: For more information about the `find` method, check out the following link: [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go ahead and implement a `v-for` loop inside our `<select>` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `v-for` loop will grab each element inside of options, and create a new
    `<option>` element inside `<select>`; don't forget to set the `:key` property!
  prefs: []
  type: TYPE_NORMAL
- en: If you would like to read more about `:key`, that is, when to use it and why,
    check out my article at the following link: [https://www.telerik.com/blogs/in-vue-when-do-i-actually-need-the-key-attribute-and-why](https://www.telerik.com/blogs/in-vue-when-do-i-actually-need-the-key-attribute-and-why).
  prefs: []
  type: TYPE_NORMAL
- en: We will need each object inside options to have a `label` and `value` properties,
    but we will provide a default in case the `label` is missing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go back to `App.vue` and we will create a new internal `state` property inside
    `data()` called `loveOptions`, which will hold our options for this particular
    `<Select>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have set that up, go to the template and bind it to the `options`
    prop of our `BaseSelect` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Go back to your browser after you save and check out the options. It's alive!
  prefs: []
  type: TYPE_NORMAL
- en: There is one more thing missing, which we need to add to this component, the
    `v-model` capabilities. We need to create a `value` prop, make the `option` attribute
    that is selected use it, and make sure that we fire input events from inside our
    component.
  prefs: []
  type: TYPE_NORMAL
- en: '"Remember, remember, the rules of `v-model`, the properties bindings and emit.
    I know of no reason, the `v-model` system, should ever be forgot." - Vue Fawkes'
  prefs: []
  type: TYPE_NORMAL
- en: In this case, since we are going to use `v-model` with a `select`, remember
    that we need to listen to the change, even internally! Another thing to note is
    that you may be tempted to place a `:value` binding on top of the `select` tag,
    this is not the correct way of working with selects!
  prefs: []
  type: TYPE_NORMAL
- en: 'The `<select>` element in HTML does not have a `value` attribute; what it does
    is apply the `selected` attribute to the `option` element inside of it, which
    holds the current value:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `value` property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'You will use the `value` prop to check whether the value of this option is
    equal to it. Make sure that we emit `input` when the `select` element fires a
    `change` event:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Go back to `App.vue` and add the `v-model` binding to this new element. You
    will need to create a new property called `love` inside the `form` prop in `data()`,
    and add the `v-model` attribute to the `BaseSelect` element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The `BaseSelect` element will now have a `v-model` binding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Finally, check in your browser to see that everything is working. Go into DevTools
    and check your App component—you will see that when you switch the value of the
    select, it too will update!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have gone through the process of destructuring a singleton
    application, or form, into reusable dynamic components. We have covered important
    core Vue features such as `v-model`, properties, and events.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to kick it up a notch and implement a very
    near **u****ser experience** (**UX**) related feature, input masks!
  prefs: []
  type: TYPE_NORMAL
