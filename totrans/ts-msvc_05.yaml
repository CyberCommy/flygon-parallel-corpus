- en: Understanding API Gateway
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解API网关
- en: After designing some microservices, we will talk about microservices gateways
    here. When compared to monolithic applications, microservices do not communicate
    via in-memory calls and rather use the network calls. Hence, network design and
    implementation plays an important role in the stability of the distributed system.
    We will debunk API Gateway and learn how it handles important concerns in microservices-based
    architecture.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 设计了一些微服务后，我们将在这里讨论微服务网关。与单片应用程序相比，微服务不通过内存调用进行通信，而是使用网络调用。因此，网络设计和实现在分布式系统的稳定性中起着重要作用。我们将揭示API网关，并了解它如何处理基于微服务的架构中的重要关注点。
- en: 'This chapter will commence with an understanding of API Gateway and why we
    need to use it. It will then talk about all the centralized concerns that an API
    Gateway handles, as well as the benefits, and drawbacks of introducing a gateway.
    We will design our gateway for shopping cart microservices and see all available
    options for a gateway, and get acquainted with design patterns and aspects involved
    in API Gateway. This chapter will talk about the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将从理解API网关及其必要性开始。然后将讨论API网关处理的所有集中关注点，以及引入网关的好处和缺点。我们将为购物车微服务设计我们的网关，并查看网关的所有可用选项，并熟悉API网关中涉及的设计模式和方面。本章将讨论以下主题：
- en: Debunking API Gateway
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 揭示API网关
- en: Concerns API Gateway handles
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API网关处理的关注点
- en: API Gateway design patterns
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API网关设计模式
- en: Circuit breakers and its role
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 断路器及其作用
- en: The need for gateway in our shopping cart microservices
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的购物车微服务中需要网关
- en: Available gateways options
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可用的网关选项
- en: Designing our gateway for shopping cart microservices
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为购物车微服务设计我们的网关
- en: Debunking API Gateway
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 揭示API网关
- en: 'As we go deeper into our microservices development, we see various pitfalls
    ahead. Now that our microservices are ready and when we think of clients utilizing
    those microservices, we will encounter the following issues:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们深入微服务开发，我们看到前方有各种陷阱。现在我们的微服务已经准备就绪，当我们考虑客户端利用这些微服务时，我们将遇到以下问题：
- en: The consumer or the web client runs on a browser. We don't have any discovery
    client on the frontend, which takes care of identifying where the container/VM
    service is located or neither take care of load balancing. We need an extra piece
    of the puzzle which connects the microservices living in different containers
    in the backend and abstracting that implementation from the client.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消费者或Web客户端在浏览器上运行。前端没有任何发现客户端，负责识别容器/VM服务的位置，也不负责负载平衡。我们需要一个额外的拼图，它连接后端不同容器中的微服务，并将该实现从客户端抽象出来。
- en: Untill now, we haven't spoken about centralized concerns like authenticating
    services, versioning services, filtering or transforming any request/response.
    Upon reflection, we realize that they need a central point of control from which
    they can be applied throughout the system without re-implementing the same logic
    everywhere.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 到目前为止，我们还没有讨论像认证服务、版本化服务、过滤或转换任何请求/响应等集中关注点。经过反思，我们意识到它们需要一个中央控制点，可以在整个系统中应用，而无需在每个地方重新实现相同的逻辑。
- en: Further more, different clients may have different contract requirements. One
    client may expect an XML response while other needs JSON response. We need a center
    component which takes care of routing a request, translating the response as per
    protocol needs, and composing various responses as per need.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，不同的客户端可能有不同的合同要求。一个客户端可能期望XML响应，而另一个需要JSON响应。我们需要一个中心组件来处理路由请求，根据协议需求翻译响应，并根据需要组合各种响应。
- en: If we want to scale any of the microservice independently on demand, new instances
    need to be added on demand whose location should be abstracted from the client.
    So we need a central client who constantly communicates with all microservices
    and maintains a registry. Further, if the service is down, it should inform the
    client of this and break the connection there, thus preventing failure to propagate.
    Further, it can act as a place for central cache management.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们想独立按需扩展任何微服务，需要根据需要添加新实例，其位置应该对客户端进行抽象。因此，我们需要一个不断与所有微服务通信并维护注册表的中央客户端。此外，如果服务宕机，它应该通知客户端并在那里断开连接，从而防止故障传播。此外，它可以作为中央缓存管理的地方。
- en: 'An API Gateway is a type of service which solves all mentioned problems. It
    is the entry point in our microservices world and it provides a shared layer for
    clients to communicate with internal services. It can perform tasks like route
    requests, transform protocols, authenticate, rate limiting to a service, and so
    on. It is a center point for governance and it helps to achieve various things
    like the following:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: API网关是一种解决所有上述问题的服务类型。它是我们微服务世界的入口点，并为客户端提供与内部服务通信的共享层。它可以执行路由请求、转换协议、认证、对服务进行速率限制等任务。它是治理的中心点，有助于实现以下各种事项：
- en: Monitor the entire distributed moving system and take action accordingly
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控整个分布式移动系统，并相应地采取行动
- en: Decouple consumers from microservices by abstracting the instance and network
    location, and routing every request via the API Gateway
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过抽象实例和网络位置，以及通过API网关路由每个请求，将消费者与微服务解耦
- en: Avoid code duplication by keeping reusable code in a single place
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过将可重用代码保存在一个地方，避免代码重复
- en: Achieve scaling on demand, and take action on faulty services from a single
    place
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据需要实现按需扩展，并从一个地方对故障服务采取行动
- en: Define API standards, for example, Swagger, Thrift IDL, and so on
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义API标准，例如Swagger，Thrift IDL等
- en: Design contracts
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计合同
- en: Track the life cycle of APIs with various things like versioning, utilization,
    monitoring and alerting, throttling, and so on
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪API的生命周期，包括版本化、利用率、监控和警报、限流等
- en: Avoid chatty communication between client and microservices
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免客户端和微服务之间的啰嗦通信
- en: With being a single entry point into a totally moving distributed system, it
    becomes very easy to enforce any new governance standards (for example, every
    consumer should have JWT token), have some real-time monitoring, auditing, API
    consumption policies, and so on.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: 'The JWT token pattern leverages an encryption algorithm: method of token validation.
    After any successful authentication, our system generates a unique token which
    has the userID, and a timestamp value. This token is returned to the client which
    needs to be sent alongside further requests. On receiving any service requests
    the server reads and decrypts the token. This token is usually termed as **JSON
    Web Token** or **JWT**. To prevent attacks like **cross-site request forgery**
    (**CSRF**) we use this kind of technique.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: The gateway provides flexibility to freely manipulate microservice instances
    as the client is totally abstracted from this logic. It is the best place to handle
    transformation requirements based on a client device. The gateway acts as a buffer
    zone against any sorts of attacks. The service is contaminated and it will not
    compromise the whole system. Gateway handles security by meeting all these standards,
    confidentiality, integrity, and availability. With increasing benefits, if the
    gateway is not properly handled there can be loads of drawbacks too. A gateway
    can introduce an exponential level of complexity with the increased dynamic system.
    With the added layer of communication, it will increase the response time.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following diagram, API Gateway is explained in detail:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f8004844-d3fa-426e-a7d5-78a7d1689b0d.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
- en: Now that we know what a gateway does, let us now understand the basics of what
    a gateway does and what things it handles overall.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: Concerns API Gateway handles
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An API Gateway becomes one of the most important components in microservices
    architecture as it is the only place where core concerns are handled. Hence, a
    common implementation seen across all microservices implementation is introducing
    API Gateway which provides critical functionalities. Furthermore, API Gateway
    is the part which is connected to service discovery which maintains routes of
    all newly added services dynamically. In this section, we will look into gateway
    features and understand the role and impact of the overall architecture of our
    central operational layer.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Security
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With an increase in distribution, there is a considerably high level of freedom.
    There are lots of moving services which may go up or down at any point in time.
    Considering from a security point of view, when there are a lot of moving parts,
    things can go considerably wrong. Hence, certain rules are needed which govern
    security. Therefore, we need to secure remote service invocations of all public
    facing API endpoints. We need to handle various things like authentication, threat
    vulnerabilities, authorizations, message protection, and secure communications. We
    will add SSL/TLS compliant endpoints to safeguard against various attacks like
    a man in the middle, bidirectional encryption against tampering. Furthermore,
    to handle DDoS attacks, API Gateway will handle various factors like limiting
    the rate of requests, number of connections on demand, and many more. Gateway
    will close slow connections, blacklist or whitelist IP addresses, limiting connections
    to other backend microservices, maintaining a number of database connections,
    and so on. API Gateway will handle things like authentication and authorizations.
    We can introduce federal identities such as **OpenID**, **SAML**, and **OAuth**
    here. Also, this layer would generate JWT and authenticate all requests.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the tricky parts of microservices development is identity and access
    management. In huge enterprises, this is usually handled through common systems
    like LDAP. Federal identities are kind of authorization servers (they are used
    across varied applications: for example, you can consider single a Google Account
    linked to various services such as Google Docs, Google Drive, and so on which
    authorize the user and then gives ID token and access token). Famous federal identities
    providers include OAuth and **Security Assertion Markup Language** (**SAML**).'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: Dumb gateways
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most fundamental principles of a gateway is *gateways are always
    dumb*. While designing gateways, an important aspect to take care of is, that
    gateways should not be overly ambitious; that is it should not contain non-generic
    logic or any business requirements. Making it overly ambitious defeats the purpose
    of the gateway and can make it a single point of failure and also make it difficult
    to test and deploy. Smart gateways cannot be easily version controlled or integrated
    into the large pipeline. Furthermore, it introduces tight coupling as when you
    upgrade your gateway, you often have to work on upgrading its dependencies and
    core logic associated with it.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: 'To briefly summarize, API Gateways should contain anything that we can validate
    or maintain within itself without the help of other services or shared states.
    Anything apart from that should be moved out of the API Gateway. The following
    points briefly summarize the dumbness of API Gateway and its functionalities:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Validations like JWT token validation (we are not requesting any external service)
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improving quality of service (things like shrinking responses, HTTP header caching,
    sending cached data, and so on)
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Request and response manipulation (handling multiple content types and manipulating
    request and response accordingly)
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interaction with service discovery (non-blocking interactions with service registry
    to get service request details)
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rate limiting and throttling (isolated features)
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Circuit breaker (detect failures and handle failures accordingly)
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transformation and orchestration
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have divided our microservices well into single responsibility principle;
    however, in order to achieve a business capability, we often require a combination
    of microservices. For example, a person buying a product is a mixture of payment
    microservice, inventory microservice, shipping microservice, and checkout microservice. Just
    like a Linux pipe which combines various commands, we need a similar orchestrator
    solution. This is essential for the consumers as it is an absolute nightmare to
    call every fine-grained service individually. Consider an example for our shopping
    cart microservices. We have the following two microservices:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '**Audience targeting**: These microservices take in user information and return
    a list of all the recommendations (it returns a list of product IDs)'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Product detail**: These microservices takes in product IDs and respond by
    giving product metadata and detailed information'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's say we are designing a recommendation page for 20 items. If we keep it
    as it is, then the consumer will have to make a total of 21 HTTP calls (1 call
    to get a list of product IDs, 20 calls to get product detail information), which
    is a nightmare. To avoid this, we need orchestrator (something which combines
    all these 21 calls). Furthermore, microservices have to deal with different clients
    who have need of varying responses. The API Gateway is a place for transformation
    where all things such as communication protocol, response formats, protocol transformations
    can be taken care of. We can put things like JSON to XML conversion in API Gateway,
    HTTP to gRPC or GraphQL protocols transformations, and so on.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring, alerting, and high availability
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a lot of moving parts in microservices architecture. Hence, it becomes
    vital to have system-wide monitoring and avoid cascading failures. API Gateway
    provides a one-stop solution to that problem. We can monitor and capture the information
    about all data flow which can be kept for security purposes. We can monitor health,
    traffic, and data. API Gateway can monitor various things such as network connectivity,
    log maintenance, backups and recovery, security, and system status and health.
    Further, API Gateway can monitor basic things like a number of requests coming
    for API, maintain remote hosts, browsers, OS, performance statistics, the stack
    trace of messages, violations for breaching gateway policies, and so on. API Gateway
    can integrate with alert tools such as consul alerts ([https://github.com/AcalephStorage/consul-alerts](https://github.com/AcalephStorage/consul-alerts))
    and appropriate actions can be taken accordingly on it to achieve high availability. We
    must deploy multiple instances of API Gateway behind the load balancer to effectively
    load balance the traffic among many instances of API Gateway. We must plan for
    high volume and load. If deployed in the cloud we can have auto-scaling enabled
    if not, then we must make sure it has enough data resources to handle future load.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构中有很多移动部件。因此，系统范围的监控和避免级联故障变得至关重要。API网关为这个问题提供了一站式解决方案。我们可以监控和捕获所有数据流的信息，可以用于安全目的。我们可以监控健康、流量和数据。API网关可以监控各种事物，如网络连接、日志维护、备份和恢复、安全性以及系统状态和健康状况。此外，API网关还可以监控一些基本事物，如API的请求数、维护远程主机、浏览器、操作系统、性能统计、消息的堆栈跟踪、违反网关策略的违规行为等。API网关可以集成警报工具，如consul
    alerts ([https://github.com/AcalephStorage/consul-alerts](https://github.com/AcalephStorage/consul-alerts))，并相应地采取适当的行动以实现高可用性。我们必须在负载均衡器后部署多个API网关实例，以有效地在多个API网关实例之间平衡流量。我们必须计划高容量和负载。如果部署在云中，我们可以启用自动扩展，如果没有，则必须确保它有足够的数据资源来处理未来的负载。
- en: Caching and error handling
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存和错误处理
- en: In order to have maximum optimization and performance, caches are often introduced
    in distributed systems. Redis has seen a huge increase as it is lightweight and
    can serve the purpose of cache very well. Further, in some business capabilities,
    stale data can be tolerated in the age of offline first. API Gateway can take
    care of this part, providing a cached response if the microservice is down or
    to prevent too many database calls. The golden rule while designing a cache mechanism
    can be those service calls which never actually need to be made should be the
    fastest calls. For example, consider the Avengers 4 page is updated in IMDB. It's
    getting more than 20,000 hits per second.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现最大的优化和性能，缓存经常被引入到分布式系统中。Redis因为它轻量级并且可以很好地满足缓存的目的，因此得到了巨大的增长。此外，在某些业务能力中，可以容忍陈旧的数据，这是离线优先时代。API网关可以处理这一部分，如果微服务宕机或者防止过多的数据库调用，提供缓存响应。设计缓存机制的黄金法则可以是那些实际上永远不需要进行的服务调用应该是最快的调用。例如，考虑IMDB中《复仇者联盟4》页面的更新。它每秒都在获得超过20,000次的点击。
- en: The database is hammered with these hits as it also has to fetch other things
    (like comments, reviews, and so on). That's where cache be comes useful. Things
    which will rarely change like actors description, movie description, and so on
    come from the cache layer. The response returned is super fast and it saves a
    network hop as well as it does not increase CPU performance. By implementing a
    caching layer, API Gateway ensures that the user experience is not impacted. In
    a distributed system, due to being chatty, an error is meant to occur, hence errors
    should be properly handled through patterns like timeouts and circuit breakers
    which should give out cached responses.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库受到这些访问的冲击，因为它还必须获取其他东西（如评论、评论等）。这就是缓存变得有用的地方。很少改变的东西，如演员描述、电影描述等，来自缓存层。返回的响应非常快，它节省了网络跳跃，也不会增加CPU性能。通过实施缓存层，API网关确保用户体验不受影响。在分布式系统中，由于通信频繁，错误很可能发生，因此错误应该通过超时和断路器等模式得到适当处理，这些模式应该提供缓存响应。
- en: 'We can manage to cache at the following two levels:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在以下两个级别进行缓存管理：
- en: '**Caching at the API Gateway level:** With this option, we cache the service
    response at the gateway or central level. It provides us the advantage of saving
    the service call as we can return the data at the gateway level itself. Also,
    in case of service unavailability or non-responsiveness, API Gateway could return
    the data from the cache.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在API网关级别进行缓存：** 选择这个选项，我们可以在网关或中央级别缓存服务响应。这样可以节省服务调用的优势，因为我们可以直接在网关级别返回数据。此外，在服务不可用或无响应的情况下，API网关可以从缓存中返回数据。'
- en: '**Caching at the service level:** With this option, each service manages to
    cache its own data. API Gateway is not aware of the inner cache or inner anything
    to be precise. Service can easily invalidate the cache on a need basis. However,
    while implementing this option we should have a default response ready at central
    cache level.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在服务级别进行缓存：** 选择这个选项，每个服务都可以管理自己的缓存数据。API网关不知道内部缓存或内部任何精确的东西。服务可以根据需要轻松地使缓存失效。然而，在实施这个选项时，我们应该在中央缓存级别准备好默认响应。'
- en: '**Netflix Hystrix** is one such useful library which has powerful options like
    timing out the calls which exceed a specific threshold, not to wait needlessly,
    define fall back action such as returning default value or returning value from
    the cache. It has a Node.js client too ([https://www.npmjs.com/package/hystrixjs](https://www.npmjs.com/package/hystrixjs)).'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**Netflix Hystrix** 是一个非常有用的库，具有强大的选项，如超时调用超过特定阈值，不必要等待，定义回退操作，如返回默认值或从缓存返回值。它也有一个Node.js客户端
    ([https://www.npmjs.com/package/hystrixjs](https://www.npmjs.com/package/hystrixjs))。'
- en: Service registry and discovery
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务注册和发现
- en: One of the key advantages of microservices is ease of scaling. At any point
    in time new microservices can be added to adapt to incoming traffic, can be scaled,
    and existing monolithic can be broken down to several microservices. All these
    service instances have dynamically assigned network locations. An API Gateway
    can maintain a connection to service registry which can keep a track of all these
    service instances. API Gateway communicates with service registry which is a database
    containing network locations of all instances. Each service instance tells its
    location to the registry on startup and shutdown. Another component which is connected
    to API Gateway is service discovery. The client consuming various microservices
    needs to have a simple discovery pattern in order to prevent the application from
    becoming too chatty.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务的一个关键优势是易于扩展。在任何时候，新的微服务都可以根据流量进行调整，可以进行扩展，并且现有的单片式可以分解为多个微服务。所有这些服务实例都具有动态分配的网络位置。API网关可以维护与服务注册表的连接，该注册表可以跟踪所有这些服务实例。API网关与包含所有实例的网络位置的数据库进行通信。每个服务实例在启动和关闭时都会告诉注册表其位置。与API网关连接的另一个组件是服务发现。消费各种微服务的客户端需要具有简单的发现模式，以防止应用程序变得过于啰嗦。
- en: Consul is one of the most widely used tools for service registry and discovery.
    It knows how many active containers fail for a specific service, and if that number
    is zero it marks that service as broken.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Consul是最广泛使用的服务注册和发现工具之一。它知道特定服务有多少活动容器失败，如果该数字为零，它会将该服务标记为损坏。
- en: 'There are the following two types of approaches:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 有以下两种类型的方法：
- en: '`push`: Microservice itself takes care of making its entry acknowledged to
    the API gateway'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`推送`：微服务本身负责向API网关确认其入口'
- en: '`pull`: Where API Gateway takes care of checking in all microservices'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`拉取`：API网关负责检查所有微服务'
- en: Circuit breakers
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 断路器
- en: Yet another important concern API Gateway handles is breaking the connection
    whenever the service is down. Let's say one microservice is down and starts throwing
    out a high number of errors. Queuing further requests of that microservice is
    unwise as it will soon have a high resource utilization. An API Gateway introduced
    here can implement things such as breaking the connection or simply saying when
    a certain threshold is passed, the gateway will stop sending data to that failing
    component unless the component is resolved, analyze the logs, implement a fix,
    push an update, and thus prevent failure cascading in the entire system. Scaling
    the underlying and popular microservices thus becomes very easy. The gateway can
    therefore be scaled horizontally as well as vertically. API Gateway helps to achieve
    zero downtime by deploying configuration in a rolling fashion, that is, while
    in new deployments, the circuit is tripped, new requests are not served, older
    requests are honored in a single cluster, and the other cluster meanwhile takes
    new requests. We will see circuit breaker live example in [Chapter 7](162a0f25-2890-4a58-aa41-e9c9b5fc6c2d.xhtml), *Service
    State and Interservice Communication*.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: API网关处理的另一个重要问题是当服务宕机时断开连接。比如说一个微服务宕机并开始抛出大量错误。排队进一步请求该微服务是不明智的，因为它很快就会有很高的资源利用率。在这里引入的API网关可以实现诸如断开连接或者简单地说当某个阈值被超过时，网关将停止向该失败组件发送数据，直到组件被解决，分析日志，实施修复，推送更新，从而防止整个系统中的故障级联。因此，扩展底层和流行的微服务变得非常容易。网关因此可以水平和垂直扩展。API网关通过以滚动方式部署配置来实现零停机时间，也就是说，在新部署时，电路被触发，新请求不会被服务，旧请求在单个集群中被接受，同时另一个集群接受新请求。我们将在[第7章](162a0f25-2890-4a58-aa41-e9c9b5fc6c2d.xhtml)中看到断路器的实时示例，*服务状态和服务间通信*。
- en: Versioning and dependency resolution
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 版本控制和依赖解析
- en: 'When microservices are very fine grained and designed based on the single responsibility
    principle they deal with only specific concerns, and hence they become chatty
    (too many network calls): that is, to perform a usual set of tasks, many requests
    need to be sent to different services. Gateways can provide virtual endpoints
    or facades that can internally be routed to many different microservices. API
    Gateway can resolve all dependencies and segregate all responses in a single response,
    thus making it easy to consume for the client. Furthermore, with increasing changing
    business needs and capabilities we need to maintain versioning, so at any point
    in time, we can go back in time to old services.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当微服务非常细粒度并且基于单一职责原则设计时，它们只处理特定的问题，因此它们变得啰嗦（太多的网络调用）：也就是说，为了执行一组常规任务，需要向不同的服务发送许多请求。网关可以提供虚拟端点或外观，可以在内部路由到许多不同的微服务。API网关可以解析所有依赖关系，并将所有响应分离成一个单一的响应，从而使客户端易于消费。此外，随着不断变化的业务需求和能力，我们需要保持版本控制，因此在任何时候，我们都可以回到旧服务。
- en: 'API versioning is managed in two ways—either by sending it in URI (a URI  not
    to be confused with URL is uniform resource identifier with information contained
    in itself, for example `http://example.com/users/v4/1234/`) or by sending it along
    the header. API Gateway can handle this problem with the following two approaches:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: API版本控制有两种方式进行管理——一种是通过在URI中发送（URI不要与URL混淆，它是包含信息的统一资源标识符，例如`http://example.com/users/v4/1234/`），另一种是通过在标头中发送。API网关可以通过以下两种方式处理这个问题：
- en: '**Microservices discovery**: This is the most widely used pattern wherein coupling
    between microservices and client application is totally removed as microservices
    are dynamically registered (we will see this in more detail in the next chapter).
    This component is in direct touch with API Gateway and provides information about
    service location to it, thereby preventing traditional SOA monolithic approach.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**微服务发现**：这是最广泛使用的模式，其中微服务和客户端应用程序之间的耦合完全消除，因为微服务是动态注册的（我们将在下一章中更详细地看到这一点）。这个组件直接与API网关联系，并向其提供有关服务位置的信息，从而防止传统的SOA单片式方法。'
- en: '**Microservices description**: This approach, on the other hand, focuses more
    on communicating via contracts. It expresses features of microservices in a very
    well written descriptive contract which can be understood by other client applications.
    The contract contains metadata information too, such as API version, requirements,
    and so on.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**微服务描述**：另一方面，这种方法更注重通过合同进行通信。它以非常详细的描述性合同表达微服务的特性，这些合同可以被其他客户端应用程序理解。合同还包含元数据信息，如API版本、要求等。'
- en: 'In this section, we looked at all the concerns which an API Gateway vice handles.
    Special care should be made for API Gateway for the following aspects:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们看了API网关副处理的所有关注点。对于API网关，应特别注意以下几个方面：
- en: It should not be a single point of failure
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不应该是单点故障
- en: It should not be centralized or have synchronous coordination
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不应该是集中化的或具有同步协调
- en: It should not depend on any state
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不应该依赖于任何状态
- en: It should be just another microservice
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应该只是另一个微服务
- en: Business logic should not be encapsulated inside
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 业务逻辑不应该封装在内部
- en: API Gateway design patterns and aspects
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API网关设计模式和方面
- en: Now that we know what API Gateway handles, lets throughout now look at common
    design aspects involved in API Gateway. In this section, we will look at all design
    aspects to be considered while designing API Gateway. We will understand modes
    of designing API Gateway which will help us to design a scalable system with high
    availability.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道API网关处理什么，让我们现在看看API网关涉及的常见设计方面。在这一部分，我们将看看在设计API网关时需要考虑的所有设计方面。我们将了解设计API网关的模式，这将帮助我们设计一个具有高可用性的可扩展系统。
- en: 'Being a core part which handles centralized concerns and being the starting
    point in microservices, API Gateway should be designed so that:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 作为处理集中关注点并且是微服务的起点的核心部分，API网关应该被设计成：
- en: '**It embraces concurrency**: Being heavily distributed due to designing based
    on single responsibility, server-side concurrency is needed which can reduce the
    network chattiness. Node.js being non-blocking and asynchronous, each request
    executes in parallel with other requests and thereby a single heavy client request
    is not much better than many light non-concurrent requests. While business use
    cases may need blocking calls to backend systems, API Gateway should compose these
    calls via an efficient way through reactive frameworks, which does not increase
    resource pool utilization.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**它支持并发性**：由于基于单一责任的设计而具有高度分布性，需要服务器端并发性，这可以减少网络通信。Node.js是非阻塞和异步的，每个请求都与其他请求并行执行，因此单个重型客户端请求并不比许多轻量级非并发请求好多少。虽然业务用例可能需要对后端系统进行阻塞调用，但API网关应该通过响应式框架以高效的方式组合这些调用，这不会增加资源池的利用率。'
- en: '**It should be reactive**: Reactive programming offers varying operators capable
    of filtering, selecting, transforming, combining, and composing observables thus
    by enabling efficient execution and composition in API Gateway layer. It promotes
    the idea of variables which are filled over time. It promotes non-blocking architecture
    as in the observable pattern, the producer just pushes the values to the consumer
    whenever the values are available rather than blocking the thread in that time.
    Values can arrive at any point in time asynchronously or synchronously. It has
    added advantages like the producer can give an ending signal to the consumer that
    there is no more data or if an error has occurred.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**它应该是反应式的**：反应式编程提供了各种操作符，能够过滤、选择、转换、组合和组合可观察对象，从而在API网关层实现高效的执行和组合。它提倡随时间填充的变量的概念。它提倡非阻塞架构，因为在可观察模式中，生产者只是在值可用时向消费者推送值，而不是在那段时间内阻塞线程。值可以在任何时间点异步或同步到达。它还有额外的优势，比如生产者可以向消费者发出结束信号，告诉消费者没有更多的数据，或者发生了错误。'
- en: '**The service layer follows an observable pattern**: When all methods in API
    Gateway return an `Observable<T>` concurrency is enabled by default. The service
    layer then adheres to things like returning a cached response based on conditions
    and if resources are not available or if service is not available, then block
    the request. This can happen without changing anything on the client end.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务层遵循可观察模式**：当API网关中的所有方法都返回`Observable<T>`时，默认启用并发性。服务层然后遵循诸如根据条件返回缓存响应以及如果资源不可用或服务不可用，则阻止请求等操作。这可以在不改变客户端端的情况下发生。'
- en: '**It handle backend services and dependencies**: A gateway abstracts away all
    the backend services and dependencies behind the virtual facade layer due to which
    any inbound request access business capability rather than the entire system.
    This will allow us to change underlying implementations with limited impact on
    code that depends on it. Thus service layer ensures that all models and tight
    couplings stay inbound and are abstracted and are not allowed to leak in the endpoints.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**它处理后端服务和依赖关系**：由于网关在虚拟外观层后面抽象了所有后端服务和依赖关系，因此任何入站请求都可以访问业务能力而不是整个系统。这将允许我们在对依赖它的代码影响有限的情况下更改底层实现。因此，服务层确保所有模型和紧密耦合保持内部，并且被抽象化并且不允许泄漏到端点中。'
- en: '**They should be stateless**: API Gateways should be stateless by nature, which
    means not creating any session data. This will enable us to scale the gateway
    as there won''t be any need later to replicate the session in case of disaster.
    However, API Gateway can maintain cached data, which can either be replicated
    using a peer-to-peer relationship or introducing a cache library such as Redis
    rather than going for in-memory calls. The following is a list of some of the
    general guidelines by seeing most common pitfalls:'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**它们应该是无状态的**：API网关应该是无状态的，这意味着不创建任何会话数据。这将使我们能够扩展网关，因为在灾难情况下不需要在以后复制会话。但是，API网关可以维护缓存数据，可以使用点对点关系复制这些数据，或者引入缓存库（如Redis）而不是进行内存调用。以下是一些常见陷阱的一般指导方针：'
- en: To achieve the best availability API Gateway should be used in the Active-Active
    mode. It means that the system should always be fully operational and able to
    maintain current system state.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Proper analysis and monitoring tools to prevent message flooding. In that case,
    that traffic to that service should be limited.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using tools to constantly monitor the system either via some available tools
    or system logs or network management protocols.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Active/Active mode is a method to deal with failover, load balancing, and
    keeping our system highly available. Here two or more servers are used which aggregate
    the network traffic load and they work together as a team to distribute it to
    the available network servers. Load balancers also persist information requests
    and keep this information in cache. If they return looking for the same information
    the user will be directly locked on to the server which previously served its
    request. This process reduces network traffic load intensely.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: Circuit breakers and its role
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the practical world, errors do occur. Services can timeout, become unreachable,
    or take longer to complete. Being a distributed system, the entire system should
    not go down. The circuit breaker is the solution to this problem and it is a very
    important component in API Gateway.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: 'The pattern essentially works in two states. If the circuit is closed, everything
    is normal, the request is dispatched to the destination, the response is received.
    But if there are errors or timeouts the circuit is open which means that route
    is not available as of now, we need to go a different route or way to achieve
    the service request. To achieve this functionality, Netflix has open sourced their
    project—Hystrix. This is, however, the Node.js version of the same: [https://www.npmjs.com/package/hystrixjs](https://www.npmjs.com/package/hystrixjs)
    (it''s not official from Netflix, but rather an open source project). It even
    has the Hystrix dashboard for monitoring purposes. According to Hystrix''s library,
    it has the following capabilities:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: Protect system against any failures which occur because of network issues or
    any third-party clients or libraries
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stop propagating failures and avoid dispersion of error
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fail fast, fail often, fail better, fail forward, and recover rapidly with counter-measures
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Degrade failures with fallback mechanisms like returning response from the cache
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide dashboard for monitoring purposes
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Take a look at the following diagram:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/64667362-37e9-489f-b474-fd082acb167c.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
- en: 'The circuit breaker follows the same set of rules as the original **Hystrix** module.
    To calculate the health of a command, the following steps are executed:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: 'Maintain a watch on volume across the circuit as follows:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the network volume across the circuit doesn't exceed the predefined value,
    then Hystrix can simply execute the run function without comparing anything at
    all. Metrics can log all told cases for future references.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the network volume across the circuit exceeds the configured brink value,
    Hystrix can check the health first to take preventive measures.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When checking the health, if the error percentage exceeds the pre-defined threshold,
    the transition of circuit happens from closed to open and all subsequent requests
    would be rejected with the open circuit error preventing further requests.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After an organized time Hystrix can enable one request to go through to examine
    whether the services are recovered. If it passes an expectation test, the circuit
    once more transitions to a closed state and all the counters are reset. To use
    it in your application just create service commands and add values:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: To execute those commands just use the execute method. A complete gist can be
    found in the source inside `hystrix` folder.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Need for gateway in our shopping cart microservices
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After debunking gateways in detail lets come back to our shopping cart microservices
    system. We will look at the need for a gateway in our system and the things it
    will handle with our context and then move on to design the gateway. In this section,
    we will look at various design aspects that we need to consider while designing
    the gateway.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在详细解释网关之后，让我们回到我们的购物车微服务系统。我们将看看我们系统中网关的需求以及它将处理的内容，然后继续设计网关。在本节中，我们将看看在设计网关时需要考虑的各种设计方面。
- en: Handle performance and scalability
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理性能和可伸缩性
- en: Being an entry point in system performance, scalability and high availability
    of API Gateway is a very crucial factor. As it will handle all the requests, making
    it on asynchronous non-blocking I/O seems very logical which is what Node.js is.
    All the requests coming from our shopping cart microservices need to be authenticated,
    cached, monitored and constantly send out health aware checks. Consider a scenario
    where our products service has larg traffic. API Gateway should then automatically
    spawn new instances of the server and maintain addresses of the new instances.
    The new instances then need to constantly send health checks to gateway so it
    would know which instances are alive. Consider the same example which we saw earlier
    where we have product microservice and we need to show the client a detailed listing
    of 20 items. Now the client is not going to make 21 HTTP requests but instead,
    we need a core composition component which combines responses from various requests.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 作为系统性能、可伸缩性和API网关高可用性的入口点，非常关键。因为它将处理所有请求，使其成为异步非阻塞I/O似乎非常合乎逻辑，这正是Node.js的特点。来自我们的购物车微服务的所有请求都需要经过身份验证、缓存、监控，并不断发送健康检查。考虑一个场景，我们的产品服务有大量流量。API网关应该自动产生服务器的新实例并维护新实例的地址。然后新实例需要不断向网关发送健康检查，以便知道哪些实例是活着的。考虑之前我们看到的同样的例子，我们有产品微服务，我们需要向客户显示20个项目的详细列表。现在客户不会发出21个HTTP请求，而是我们需要一个核心组合组件，它将从各种请求中组合响应。
- en: Reactive programming to up the odds
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应式编程提高胜算
- en: In order to make sure that we don't have to frequently change the client code,
    the API Gateway simply routes the client request to a microservice. It may make
    other requests by making multiple backend service calls and then aggregate all
    the results. In order to make sure that there is minimum response time, the API
    Gateway should make independent calls concurrently which is where a reactive model
    of programming comes into the picture. API Composition is needed in various cases
    like fetching the users past orders, where we first need to fetch the user details
    and then their past orders. Writing compositional logic using traditional asynchronous
    callbacks will soon lead to the problem of callback hell which will produce coupled,
    tangled, difficult to understand and error-prone code which is where reactive
    programming is very helpful.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们不必频繁更改客户端代码，API网关简单地将客户端请求路由到微服务。它可能通过进行多个后端服务调用来发出其他请求，然后聚合所有结果。为了确保最小的响应时间，API网关应该同时进行独立调用，这就是响应式编程模型发挥作用的地方。在各种情况下都需要API组合，比如获取用户的过去订单，我们首先需要获取用户详情，然后获取他们的过去订单。使用传统的异步回调编写组合逻辑很快就会导致回调地狱的问题，这将产生耦合、混乱、难以理解和容易出错的代码，这就是响应式编程非常有帮助的地方。
- en: Invoking services
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调用服务
- en: Microservices do need to communicate with each other synchronously or asynchronously
    based on the business capability. There must be inter-process communication mechanisms.
    Our shopping cart microservices can have two modes of communication. One involves
    a message broker which queues up messages and sends them to services on availability.
    The other involves brokerless communication and the service directly communicates
    with an other service and this may have data loss. There are lots of event-driven
    message brokers such as AMQP, RabbitMQ, and so on, others such as Zeromq are brokerless.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务确实需要根据业务能力同步或异步地相互通信。必须有进程间通信机制。我们的购物车微服务可以有两种通信模式。一种涉及消息代理，它排队消息并在可用时将它们发送到服务。另一种涉及无代理通信，服务直接与另一个服务通信，这可能会导致数据丢失。有许多事件驱动的消息代理，如AMQP、RabbitMQ等，还有一些无代理的，如Zeromq。
- en: Some business capabilities need asynchronous modes of communication such as
    during the checkout of a product, we need to call payment services. If there is
    successful payment, then and only then can the product be purchased. API Gateway
    needs to support a variety of mechanisms based on business capabilities. We will
    see a live example in [Chapter 7](162a0f25-2890-4a58-aa41-e9c9b5fc6c2d.xhtml), *Service
    State and Interservice Communication*, in the *NetFlix Case study* section.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 一些业务能力需要异步通信模式，比如在产品结账时，我们需要调用支付服务。只有成功支付，产品才能被购买。API网关需要支持基于业务能力的各种机制。我们将在[第7章](162a0f25-2890-4a58-aa41-e9c9b5fc6c2d.xhtml)中看到一个实时例子，*服务状态和服务间通信*，在*NetFlix案例研究*部分。
- en: Discovering services
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发现服务
- en: With constantly dynamic and evolving services, our gateway needs to know the
    location (IP address, service port) of every microservice in the system. Now,
    this can be hotwired in the system but as they are evolving we need a more dynamic
    method as services constantly auto-scale and upgrade. For example, in our shopping
    cart microservices, we may constantly add new services based on use case. Now
    API Gateway needs to know the location of these services so it can query any of
    the services any time to return the response to the client. API Gateway must maintain
    communication with service registry which is just a database of all microservices
    locations and their instances.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: Handling partial service failures
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Yet another need to address is handling partial failures. When one service
    calls another service it may not receive a response at all or it may get delayed
    response. With the increased number of services, any service may go down at any
    point in time. API Gateway should be able to handle partial failures by implementing
    some/all of the following strategies:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous mode of communication by default. Using synchronous mode only when
    needed.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A number of retries should be handled with exponential backoffs that is 1, 2,
    4, 16, and so on.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Well defined network timeouts to prevent blocking of resources.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Circuit breaker pattern to trip the request if service is down or overloaded.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fallbacks or returning cached values. For example images of a product will never
    change frequently, they can be cached.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring the number of queued requests. If the number goes beyond a limit,
    then it doesn't make sense to send further requests.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design considerations
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A good API Gateway should adhere to the following design considerations in
    order to have a rock solid microservice design:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '**Dependency: **There should not be a dependency on any other microservice.
    An API Gateway is just another microservice. If any service ID is unavailable
    for a preconfigured time or does not follow the SLAs then API Gateway should not
    wait for that service. It should rather fail fast using circuit breaker or another
    fall back strategy like returning cached responses.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Database and business logic: **API Gateway should not have database connectivity.
    Gateways are dumb that is they do not have any state. If you need a database then
    we need to create a separate microservice. Likewise business logic should reside
    in the service itself. Gateway just routes any service requests to an appropriate
    destination.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Orchestration and handling multiple content types:** Service choreography
    (a pattern where microservices communicate with each other) should be done at
    API Gateway rather than orchestration. Gateway should be connected to service
    registry which gives us a location of dynamically moving services.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Versioning: **Gateway should have appropriate versioning strategy. Its like
    we need to move a huge rock up the mountain, but as it is too big we break the
    rock into smaller pieces and distribute it to every person. Now each person will
    go at its own pace, but that doesn''t imply that he has to meet the other person''s
    expectation too, because, in the end, it is the whole rock that matters and not
    smaller pieces. Likewise, any particular version of a service should not break
    contract exposed. New contracts should be updated on a need basis so other clients
    can then know the new expectations until which backwards compatibility should
    be there.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**High Availability: **It should be highly available and scalable. Planning
    should be done for high volume and high load. If deployed in the cloud we can
    go with: AWS auto-scaling.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next section, we will dive into available gateway options and discuss
    them in detail. We will look at some cloud provider options too and see pros and
    cons of each.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: Available API Gateways options
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now let us look at some of the practical implementations of API Gateway available.
    In this section, we will look at options like Express Gateway, Netflix OSS, message
    brokers, NGINX as a reverse proxy, and tools available for designing gateway.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: HTTP proxy and Express Gateway
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'HTTP proxy is an HTTP programmable library for proxying. This is helpful for
    applying things such as reverse proxy or load balancing. `http-proxy` available
    in npm has more than 1 lakh download per day. To achieve request dispatching we
    can use `http-proxy`. This is a piece of cake and can be achieved like this:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'One of the gateways built on top of Express.js and Node.js, Express Gateway
    is the most simple to use with wide options such as language agnostic for a microservices
    use case and portable as it can be run anywhere in Docker in public or private
    cloud. It can work with any DevOps tools and it comes with pre-bundled proven
    and popular modules. We can extend this with any express middleware and this is
    totally config based and configs are auto-detected and hot reloaded. The following
    are core components in the express gateway:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '| **Endpoints (API and service)** | They are nothing but URLs. Express Gateway
    maintains them in two forms. API endpoints and service endpoints. API endpoints
    are exposed and it proxies API requests to microservices asked for in service.
    |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
- en: '| **Policies** | Set of conditions or actions or contract that is evaluated
    and acted upon for any request that is passed through the gateway. Middlewares
    are utilized. |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
- en: '| **Pipelines** | Set of policies linked to microservices to be executed sequentially.
    For policy execution an API requested is passed through the pipeline where in
    the end it encounters a proxy policy which guides request to service endpoint.
    |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
- en: '| **Consumers** | Anyone who consumes microservices. To handle varying consumers
    Express Gateway comes with a consumer management module. The golden rule for which
    is an app must belong to a user. |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
- en: '| **Credentials** | Types of authentication and authorizations. Consumer or
    user may have one or more than one set of credentials. Credentials are linked
    to a scope. Express Gateway comes with the credential management module. |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
- en: '| **Scopes** | Labels used to assign authorization. Authorization policies
    protecting the endpoints look up at the credential to make sure the integrity
    of the system and consumer has that corresponding scope. |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
- en: 'Let''s now look at one example of Express Gateway. Following is the sample `gateway.config.yml`
    file which is generated using Express Gateway ( [https://www.express-gateway.io/](https://www.express-gateway.io/).):'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The preceding configuration is a minimalist example of a JWT at gateway and
    proxy routes and is self explanatory.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: Zuul and Eureka
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next option that we are going to look at is the Zuul proxy server provided
    by Netflix. Zuul is an edge service with objective of proxying requests to various
    backing services. Thus it acts as a "unified front door" to consume services.
    Zuul can be integrated with other open sourced tools by Netflix such as Hystrix
    for fault tolerance, Eureka for service discovery, routing engine, load balancing,
    and so on. Zuul is written in Java but can be used for microservices written in
    any language. Zuul provides ease in doing the following things:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Validating contract requirements for each resource. If contract is not fulfilled,
    then rejecting those requests that do not meet them.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Give us accurate view of production by tracking meaningful data and statistics.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting to service registries and dynamically routing to different backend
    clusters as needed.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In order to gauge performance gradually increasing traffic in a cluster.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dropping requests that go over a limit, thus by achieving load shedding by allocating
    capacity for each type of request.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling static or cached responses, thus by preventing internal container trips.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Zuul 2.1 is under active development with the objective of achieving asynchronous
    operations at the gateway level. Zuul 2 is however non blocking and thoroughly
    relies on RxJava and reactive programming. To run Zuul as an API Gateway perform
    the following steps:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: 'Zuul requires a Java environment. Clone the following Spring boot project:
    [https://github.com/kissaten/heroku-zuul-server-demo](https://github.com/kissaten/heroku-zuul-server-demo)'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start the project using `mvn spring-boot:run`.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the project's `src/main/resources/application.yml` file we will write
    our Zuul filters logic.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will add failover logic there. For example consider the following sample
    configuration:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This configuration tells `zuul` to send all requests to the `httpbin` service.
    If we want to define multiple routes here we can. The `httpbin` service then defines
    the number of available servers. If the first host goes down, then proxy will
    fail over to the second host.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: 'The next chapter enables service discovery through another Netflix library:
    Eureka.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: API Gateway versus reverse proxy NGINX
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we are going to look at possible options available at server
    levels. A reverse proxy (NGINX or Apache httpd) can do tasks like authenticating
    a request, handling transportation security, and load balancing. NGINX is one
    of the widely used tools to use a reverse proxy at gateway level in microservices.
    The following code sample depicts configuration with a reverse proxy, SSL certificates,
    and load balancing:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The preceding configuration adds SSL certificates at a central level and adds
    proxies at three domains and load balances all requests among them.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: RabbitMQ
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the most widely deployed message brokers, RabbitMQ operates on AMQP
    protocol. The `amqplib` client for Node.js is widely adopted and has more than
    16,000 downloads per day. In this section, we will look at a sample implementation
    of `amqp` and understand the options given by it. RabbitMQ follows more of an
    event based approach where each service listens to RabbitMQ "tasks" queue and
    on listening for an event, the service completes its task and then sends it to
    a `completed_tasks` queue. API Gateway listens for the `completed_tasks` queue
    and when it receives a message, it sends the response back to the client. So let
    us design our RabbitMQ class by performing the following steps:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: 'We will define our constructor as follows:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next we will define our connection method as follows:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next we will have a `send` method which sends a message to the RabbitMQ channel
    as follows:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You can see the full file here, where you will find all available options. Similar
    to earlier use cases, you can also find types for the `amqp` module at the definitely
    typed repository [https://gist.github.com/insanityrules/4d120b3d9c20053a7c6e280a6d5c5bfb](https://gist.github.com/insanityrules/4d120b3d9c20053a7c6e280a6d5c5bfb).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: 'Next we just have to use the class. For example, take a look at the following
    code:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As a prerequisite of for this project RabbitMQ must be installed on the system,
    which requires the installation of Erlang. Once RabbitMQ is up and running, you
    can check by typing `rabbitmqctl status` to make sure that RabbitMQ service is
    running.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Designing our gateway for shopping cart microservices
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After seeing various options let's now get our hands dirty and start implementing
    our microservices gateway for shopping cart microservices. In this section, we
    will implement gateway from scratch which will have functionalities such as dispatching
    requests from public endpoints to internal endpoints, aggregate responses from
    multiple services, and handle transport security and dependency resolution. Let's
    look at all the concepts that we will use in this module before proceeding with
    code.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: What are we going to use?
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will look at all the following node modules and concepts
    in order to efficiently construct our gateway:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '**ES6 proxy**: Generally speaking, a proxy server is one which acts as an intermediary
    server for requests coming in from clients. One of the most powerful and interesting
    features in ES6 was proxy. ES6 proxy acts as an intermediary among API consumers
    and objects in services. We usually create proxies when we want our own desired
    behavior whenever the properties of the underlying target object are accessed.
    To configure traps for your proxy which has control of the underlying target object
    we use handler functions.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ES6代理**：一般来说，代理服务器是指作为客户端请求的中间服务器。ES6中最强大和有趣的功能之一就是代理。ES6代理在API消费者和服务对象之间充当中间人。当我们希望在访问基础目标对象的属性时获得自己想要的行为时，通常会创建代理。为了配置代理的陷阱，控制基础目标对象，我们使用处理程序函数。'
- en: '**NPM module dockerode**: Its Node.js reactive module for Remote API for docker.
    It has some nice features such as streams for reactive programming, support for
    additional demultiplexing and promises and callback based interfaces for easy
    programming.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NPM模块dockerode**：它是用于Docker远程API的Node.js响应式模块。它具有一些不错的功能，如用于响应式编程的流、支持附加的多路复用和承诺以及基于回调的接口，便于编程。'
- en: '**Dependency injection**: One of the most important design patterns (initially
    started in Java, now it is present everywhere) in which one or more dependencies
    of a service are injected or passed by reference to a dependent object.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**依赖注入**：这是最重要的设计模式之一（最初在Java中开始，现在到处都有），其中一个或多个服务的依赖项被注入或通过引用传递给依赖对象。'
- en: Please check source code of `chapter 5` for custom implementation which includes
    service discovery. You can revisit this exercise after completing `chapter 6`.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看`第5章`的源代码，其中包括服务发现的自定义实现。在完成`第6章`后，您可以重新访问这个练习。
- en: Summary
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we debunked API Gateway. We understood the pros and cons of
    introducing API Gateway and what concerns API Gateway can handle centrally. We
    looked at design aspects of API Gateway and understood the need for API Gateway
    in our system. We had a look at the circuit breaker and why it was vital to have.
    We looked at available gateway options like Zuul, Express Gateway, reverse proxy,
    and designed our own gateway for shopping cart microservices.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们揭示了API网关。我们了解了引入API网关的利弊，以及API网关可以集中处理哪些问题。我们研究了API网关的设计方面，并了解了在我们的系统中需要API网关的原因。我们看了一下断路器以及为什么拥有它是至关重要的。我们研究了可用的网关选项，如Zuul、Express
    Gateway、反向代理，并为购物车微服务设计了我们自己的网关。
- en: In the next chapter, we will learn about service registry and service discovery.
    We will see how gateway connects with service discovery to automatically know
    the location of moving services. We will see ways in which a service can be registered
    and learn the pros and cons of each approach. We will see some options like consul
    and implement them in our shopping cart microservices.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习服务注册表和服务发现。我们将看到网关如何连接到服务发现，自动了解移动服务的位置。我们将看到服务可以注册的方式，并了解每种方法的利弊。我们将看到一些选项，比如consul，并在我们的购物车微服务中实现它们。
