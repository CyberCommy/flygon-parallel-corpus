- en: Understanding API Gateway
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After designing some microservices, we will talk about microservices gateways
    here. When compared to monolithic applications, microservices do not communicate
    via in-memory calls and rather use the network calls. Hence, network design and
    implementation plays an important role in the stability of the distributed system.
    We will debunk API Gateway and learn how it handles important concerns in microservices-based
    architecture.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will commence with an understanding of API Gateway and why we
    need to use it. It will then talk about all the centralized concerns that an API
    Gateway handles, as well as the benefits, and drawbacks of introducing a gateway.
    We will design our gateway for shopping cart microservices and see all available
    options for a gateway, and get acquainted with design patterns and aspects involved
    in API Gateway. This chapter will talk about the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Debunking API Gateway
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Concerns API Gateway handles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API Gateway design patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Circuit breakers and its role
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The need for gateway in our shopping cart microservices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Available gateways options
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing our gateway for shopping cart microservices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debunking API Gateway
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we go deeper into our microservices development, we see various pitfalls
    ahead. Now that our microservices are ready and when we think of clients utilizing
    those microservices, we will encounter the following issues:'
  prefs: []
  type: TYPE_NORMAL
- en: The consumer or the web client runs on a browser. We don't have any discovery
    client on the frontend, which takes care of identifying where the container/VM
    service is located or neither take care of load balancing. We need an extra piece
    of the puzzle which connects the microservices living in different containers
    in the backend and abstracting that implementation from the client.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Untill now, we haven't spoken about centralized concerns like authenticating
    services, versioning services, filtering or transforming any request/response.
    Upon reflection, we realize that they need a central point of control from which
    they can be applied throughout the system without re-implementing the same logic
    everywhere.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Further more, different clients may have different contract requirements. One
    client may expect an XML response while other needs JSON response. We need a center
    component which takes care of routing a request, translating the response as per
    protocol needs, and composing various responses as per need.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we want to scale any of the microservice independently on demand, new instances
    need to be added on demand whose location should be abstracted from the client.
    So we need a central client who constantly communicates with all microservices
    and maintains a registry. Further, if the service is down, it should inform the
    client of this and break the connection there, thus preventing failure to propagate.
    Further, it can act as a place for central cache management.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An API Gateway is a type of service which solves all mentioned problems. It
    is the entry point in our microservices world and it provides a shared layer for
    clients to communicate with internal services. It can perform tasks like route
    requests, transform protocols, authenticate, rate limiting to a service, and so
    on. It is a center point for governance and it helps to achieve various things
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Monitor the entire distributed moving system and take action accordingly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decouple consumers from microservices by abstracting the instance and network
    location, and routing every request via the API Gateway
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid code duplication by keeping reusable code in a single place
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Achieve scaling on demand, and take action on faulty services from a single
    place
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define API standards, for example, Swagger, Thrift IDL, and so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design contracts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Track the life cycle of APIs with various things like versioning, utilization,
    monitoring and alerting, throttling, and so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid chatty communication between client and microservices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With being a single entry point into a totally moving distributed system, it
    becomes very easy to enforce any new governance standards (for example, every
    consumer should have JWT token), have some real-time monitoring, auditing, API
    consumption policies, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The JWT token pattern leverages an encryption algorithm: method of token validation.
    After any successful authentication, our system generates a unique token which
    has the userID, and a timestamp value. This token is returned to the client which
    needs to be sent alongside further requests. On receiving any service requests
    the server reads and decrypts the token. This token is usually termed as **JSON
    Web Token** or **JWT**. To prevent attacks like **cross-site request forgery**
    (**CSRF**) we use this kind of technique.'
  prefs: []
  type: TYPE_NORMAL
- en: The gateway provides flexibility to freely manipulate microservice instances
    as the client is totally abstracted from this logic. It is the best place to handle
    transformation requirements based on a client device. The gateway acts as a buffer
    zone against any sorts of attacks. The service is contaminated and it will not
    compromise the whole system. Gateway handles security by meeting all these standards,
    confidentiality, integrity, and availability. With increasing benefits, if the
    gateway is not properly handled there can be loads of drawbacks too. A gateway
    can introduce an exponential level of complexity with the increased dynamic system.
    With the added layer of communication, it will increase the response time.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following diagram, API Gateway is explained in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f8004844-d3fa-426e-a7d5-78a7d1689b0d.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that we know what a gateway does, let us now understand the basics of what
    a gateway does and what things it handles overall.
  prefs: []
  type: TYPE_NORMAL
- en: Concerns API Gateway handles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An API Gateway becomes one of the most important components in microservices
    architecture as it is the only place where core concerns are handled. Hence, a
    common implementation seen across all microservices implementation is introducing
    API Gateway which provides critical functionalities. Furthermore, API Gateway
    is the part which is connected to service discovery which maintains routes of
    all newly added services dynamically. In this section, we will look into gateway
    features and understand the role and impact of the overall architecture of our
    central operational layer.
  prefs: []
  type: TYPE_NORMAL
- en: Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With an increase in distribution, there is a considerably high level of freedom.
    There are lots of moving services which may go up or down at any point in time.
    Considering from a security point of view, when there are a lot of moving parts,
    things can go considerably wrong. Hence, certain rules are needed which govern
    security. Therefore, we need to secure remote service invocations of all public
    facing API endpoints. We need to handle various things like authentication, threat
    vulnerabilities, authorizations, message protection, and secure communications. We
    will add SSL/TLS compliant endpoints to safeguard against various attacks like
    a man in the middle, bidirectional encryption against tampering. Furthermore,
    to handle DDoS attacks, API Gateway will handle various factors like limiting
    the rate of requests, number of connections on demand, and many more. Gateway
    will close slow connections, blacklist or whitelist IP addresses, limiting connections
    to other backend microservices, maintaining a number of database connections,
    and so on. API Gateway will handle things like authentication and authorizations.
    We can introduce federal identities such as **OpenID**, **SAML**, and **OAuth**
    here. Also, this layer would generate JWT and authenticate all requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the tricky parts of microservices development is identity and access
    management. In huge enterprises, this is usually handled through common systems
    like LDAP. Federal identities are kind of authorization servers (they are used
    across varied applications: for example, you can consider single a Google Account
    linked to various services such as Google Docs, Google Drive, and so on which
    authorize the user and then gives ID token and access token). Famous federal identities
    providers include OAuth and **Security Assertion Markup Language** (**SAML**).'
  prefs: []
  type: TYPE_NORMAL
- en: Dumb gateways
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most fundamental principles of a gateway is *gateways are always
    dumb*. While designing gateways, an important aspect to take care of is, that
    gateways should not be overly ambitious; that is it should not contain non-generic
    logic or any business requirements. Making it overly ambitious defeats the purpose
    of the gateway and can make it a single point of failure and also make it difficult
    to test and deploy. Smart gateways cannot be easily version controlled or integrated
    into the large pipeline. Furthermore, it introduces tight coupling as when you
    upgrade your gateway, you often have to work on upgrading its dependencies and
    core logic associated with it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To briefly summarize, API Gateways should contain anything that we can validate
    or maintain within itself without the help of other services or shared states.
    Anything apart from that should be moved out of the API Gateway. The following
    points briefly summarize the dumbness of API Gateway and its functionalities:'
  prefs: []
  type: TYPE_NORMAL
- en: Validations like JWT token validation (we are not requesting any external service)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improving quality of service (things like shrinking responses, HTTP header caching,
    sending cached data, and so on)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Request and response manipulation (handling multiple content types and manipulating
    request and response accordingly)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interaction with service discovery (non-blocking interactions with service registry
    to get service request details)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rate limiting and throttling (isolated features)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Circuit breaker (detect failures and handle failures accordingly)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transformation and orchestration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have divided our microservices well into single responsibility principle;
    however, in order to achieve a business capability, we often require a combination
    of microservices. For example, a person buying a product is a mixture of payment
    microservice, inventory microservice, shipping microservice, and checkout microservice. Just
    like a Linux pipe which combines various commands, we need a similar orchestrator
    solution. This is essential for the consumers as it is an absolute nightmare to
    call every fine-grained service individually. Consider an example for our shopping
    cart microservices. We have the following two microservices:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Audience targeting**: These microservices take in user information and return
    a list of all the recommendations (it returns a list of product IDs)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Product detail**: These microservices takes in product IDs and respond by
    giving product metadata and detailed information'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's say we are designing a recommendation page for 20 items. If we keep it
    as it is, then the consumer will have to make a total of 21 HTTP calls (1 call
    to get a list of product IDs, 20 calls to get product detail information), which
    is a nightmare. To avoid this, we need orchestrator (something which combines
    all these 21 calls). Furthermore, microservices have to deal with different clients
    who have need of varying responses. The API Gateway is a place for transformation
    where all things such as communication protocol, response formats, protocol transformations
    can be taken care of. We can put things like JSON to XML conversion in API Gateway,
    HTTP to gRPC or GraphQL protocols transformations, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring, alerting, and high availability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a lot of moving parts in microservices architecture. Hence, it becomes
    vital to have system-wide monitoring and avoid cascading failures. API Gateway
    provides a one-stop solution to that problem. We can monitor and capture the information
    about all data flow which can be kept for security purposes. We can monitor health,
    traffic, and data. API Gateway can monitor various things such as network connectivity,
    log maintenance, backups and recovery, security, and system status and health.
    Further, API Gateway can monitor basic things like a number of requests coming
    for API, maintain remote hosts, browsers, OS, performance statistics, the stack
    trace of messages, violations for breaching gateway policies, and so on. API Gateway
    can integrate with alert tools such as consul alerts ([https://github.com/AcalephStorage/consul-alerts](https://github.com/AcalephStorage/consul-alerts))
    and appropriate actions can be taken accordingly on it to achieve high availability. We
    must deploy multiple instances of API Gateway behind the load balancer to effectively
    load balance the traffic among many instances of API Gateway. We must plan for
    high volume and load. If deployed in the cloud we can have auto-scaling enabled
    if not, then we must make sure it has enough data resources to handle future load.
  prefs: []
  type: TYPE_NORMAL
- en: Caching and error handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to have maximum optimization and performance, caches are often introduced
    in distributed systems. Redis has seen a huge increase as it is lightweight and
    can serve the purpose of cache very well. Further, in some business capabilities,
    stale data can be tolerated in the age of offline first. API Gateway can take
    care of this part, providing a cached response if the microservice is down or
    to prevent too many database calls. The golden rule while designing a cache mechanism
    can be those service calls which never actually need to be made should be the
    fastest calls. For example, consider the Avengers 4 page is updated in IMDB. It's
    getting more than 20,000 hits per second.
  prefs: []
  type: TYPE_NORMAL
- en: The database is hammered with these hits as it also has to fetch other things
    (like comments, reviews, and so on). That's where cache be comes useful. Things
    which will rarely change like actors description, movie description, and so on
    come from the cache layer. The response returned is super fast and it saves a
    network hop as well as it does not increase CPU performance. By implementing a
    caching layer, API Gateway ensures that the user experience is not impacted. In
    a distributed system, due to being chatty, an error is meant to occur, hence errors
    should be properly handled through patterns like timeouts and circuit breakers
    which should give out cached responses.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can manage to cache at the following two levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Caching at the API Gateway level:** With this option, we cache the service
    response at the gateway or central level. It provides us the advantage of saving
    the service call as we can return the data at the gateway level itself. Also,
    in case of service unavailability or non-responsiveness, API Gateway could return
    the data from the cache.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Caching at the service level:** With this option, each service manages to
    cache its own data. API Gateway is not aware of the inner cache or inner anything
    to be precise. Service can easily invalidate the cache on a need basis. However,
    while implementing this option we should have a default response ready at central
    cache level.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Netflix Hystrix** is one such useful library which has powerful options like
    timing out the calls which exceed a specific threshold, not to wait needlessly,
    define fall back action such as returning default value or returning value from
    the cache. It has a Node.js client too ([https://www.npmjs.com/package/hystrixjs](https://www.npmjs.com/package/hystrixjs)).'
  prefs: []
  type: TYPE_NORMAL
- en: Service registry and discovery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the key advantages of microservices is ease of scaling. At any point
    in time new microservices can be added to adapt to incoming traffic, can be scaled,
    and existing monolithic can be broken down to several microservices. All these
    service instances have dynamically assigned network locations. An API Gateway
    can maintain a connection to service registry which can keep a track of all these
    service instances. API Gateway communicates with service registry which is a database
    containing network locations of all instances. Each service instance tells its
    location to the registry on startup and shutdown. Another component which is connected
    to API Gateway is service discovery. The client consuming various microservices
    needs to have a simple discovery pattern in order to prevent the application from
    becoming too chatty.
  prefs: []
  type: TYPE_NORMAL
- en: Consul is one of the most widely used tools for service registry and discovery.
    It knows how many active containers fail for a specific service, and if that number
    is zero it marks that service as broken.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are the following two types of approaches:'
  prefs: []
  type: TYPE_NORMAL
- en: '`push`: Microservice itself takes care of making its entry acknowledged to
    the API gateway'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pull`: Where API Gateway takes care of checking in all microservices'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Circuit breakers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Yet another important concern API Gateway handles is breaking the connection
    whenever the service is down. Let's say one microservice is down and starts throwing
    out a high number of errors. Queuing further requests of that microservice is
    unwise as it will soon have a high resource utilization. An API Gateway introduced
    here can implement things such as breaking the connection or simply saying when
    a certain threshold is passed, the gateway will stop sending data to that failing
    component unless the component is resolved, analyze the logs, implement a fix,
    push an update, and thus prevent failure cascading in the entire system. Scaling
    the underlying and popular microservices thus becomes very easy. The gateway can
    therefore be scaled horizontally as well as vertically. API Gateway helps to achieve
    zero downtime by deploying configuration in a rolling fashion, that is, while
    in new deployments, the circuit is tripped, new requests are not served, older
    requests are honored in a single cluster, and the other cluster meanwhile takes
    new requests. We will see circuit breaker live example in [Chapter 7](162a0f25-2890-4a58-aa41-e9c9b5fc6c2d.xhtml), *Service
    State and Interservice Communication*.
  prefs: []
  type: TYPE_NORMAL
- en: Versioning and dependency resolution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When microservices are very fine grained and designed based on the single responsibility
    principle they deal with only specific concerns, and hence they become chatty
    (too many network calls): that is, to perform a usual set of tasks, many requests
    need to be sent to different services. Gateways can provide virtual endpoints
    or facades that can internally be routed to many different microservices. API
    Gateway can resolve all dependencies and segregate all responses in a single response,
    thus making it easy to consume for the client. Furthermore, with increasing changing
    business needs and capabilities we need to maintain versioning, so at any point
    in time, we can go back in time to old services.'
  prefs: []
  type: TYPE_NORMAL
- en: 'API versioning is managed in two ways—either by sending it in URI (a URI  not
    to be confused with URL is uniform resource identifier with information contained
    in itself, for example `http://example.com/users/v4/1234/`) or by sending it along
    the header. API Gateway can handle this problem with the following two approaches:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Microservices discovery**: This is the most widely used pattern wherein coupling
    between microservices and client application is totally removed as microservices
    are dynamically registered (we will see this in more detail in the next chapter).
    This component is in direct touch with API Gateway and provides information about
    service location to it, thereby preventing traditional SOA monolithic approach.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Microservices description**: This approach, on the other hand, focuses more
    on communicating via contracts. It expresses features of microservices in a very
    well written descriptive contract which can be understood by other client applications.
    The contract contains metadata information too, such as API version, requirements,
    and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this section, we looked at all the concerns which an API Gateway vice handles.
    Special care should be made for API Gateway for the following aspects:'
  prefs: []
  type: TYPE_NORMAL
- en: It should not be a single point of failure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It should not be centralized or have synchronous coordination
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It should not depend on any state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It should be just another microservice
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Business logic should not be encapsulated inside
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API Gateway design patterns and aspects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we know what API Gateway handles, lets throughout now look at common
    design aspects involved in API Gateway. In this section, we will look at all design
    aspects to be considered while designing API Gateway. We will understand modes
    of designing API Gateway which will help us to design a scalable system with high
    availability.
  prefs: []
  type: TYPE_NORMAL
- en: 'Being a core part which handles centralized concerns and being the starting
    point in microservices, API Gateway should be designed so that:'
  prefs: []
  type: TYPE_NORMAL
- en: '**It embraces concurrency**: Being heavily distributed due to designing based
    on single responsibility, server-side concurrency is needed which can reduce the
    network chattiness. Node.js being non-blocking and asynchronous, each request
    executes in parallel with other requests and thereby a single heavy client request
    is not much better than many light non-concurrent requests. While business use
    cases may need blocking calls to backend systems, API Gateway should compose these
    calls via an efficient way through reactive frameworks, which does not increase
    resource pool utilization.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**It should be reactive**: Reactive programming offers varying operators capable
    of filtering, selecting, transforming, combining, and composing observables thus
    by enabling efficient execution and composition in API Gateway layer. It promotes
    the idea of variables which are filled over time. It promotes non-blocking architecture
    as in the observable pattern, the producer just pushes the values to the consumer
    whenever the values are available rather than blocking the thread in that time.
    Values can arrive at any point in time asynchronously or synchronously. It has
    added advantages like the producer can give an ending signal to the consumer that
    there is no more data or if an error has occurred.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The service layer follows an observable pattern**: When all methods in API
    Gateway return an `Observable<T>` concurrency is enabled by default. The service
    layer then adheres to things like returning a cached response based on conditions
    and if resources are not available or if service is not available, then block
    the request. This can happen without changing anything on the client end.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**It handle backend services and dependencies**: A gateway abstracts away all
    the backend services and dependencies behind the virtual facade layer due to which
    any inbound request access business capability rather than the entire system.
    This will allow us to change underlying implementations with limited impact on
    code that depends on it. Thus service layer ensures that all models and tight
    couplings stay inbound and are abstracted and are not allowed to leak in the endpoints.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**They should be stateless**: API Gateways should be stateless by nature, which
    means not creating any session data. This will enable us to scale the gateway
    as there won''t be any need later to replicate the session in case of disaster.
    However, API Gateway can maintain cached data, which can either be replicated
    using a peer-to-peer relationship or introducing a cache library such as Redis
    rather than going for in-memory calls. The following is a list of some of the
    general guidelines by seeing most common pitfalls:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To achieve the best availability API Gateway should be used in the Active-Active
    mode. It means that the system should always be fully operational and able to
    maintain current system state.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Proper analysis and monitoring tools to prevent message flooding. In that case,
    that traffic to that service should be limited.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using tools to constantly monitor the system either via some available tools
    or system logs or network management protocols.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Active/Active mode is a method to deal with failover, load balancing, and
    keeping our system highly available. Here two or more servers are used which aggregate
    the network traffic load and they work together as a team to distribute it to
    the available network servers. Load balancers also persist information requests
    and keep this information in cache. If they return looking for the same information
    the user will be directly locked on to the server which previously served its
    request. This process reduces network traffic load intensely.
  prefs: []
  type: TYPE_NORMAL
- en: Circuit breakers and its role
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the practical world, errors do occur. Services can timeout, become unreachable,
    or take longer to complete. Being a distributed system, the entire system should
    not go down. The circuit breaker is the solution to this problem and it is a very
    important component in API Gateway.
  prefs: []
  type: TYPE_NORMAL
- en: 'The pattern essentially works in two states. If the circuit is closed, everything
    is normal, the request is dispatched to the destination, the response is received.
    But if there are errors or timeouts the circuit is open which means that route
    is not available as of now, we need to go a different route or way to achieve
    the service request. To achieve this functionality, Netflix has open sourced their
    project—Hystrix. This is, however, the Node.js version of the same: [https://www.npmjs.com/package/hystrixjs](https://www.npmjs.com/package/hystrixjs)
    (it''s not official from Netflix, but rather an open source project). It even
    has the Hystrix dashboard for monitoring purposes. According to Hystrix''s library,
    it has the following capabilities:'
  prefs: []
  type: TYPE_NORMAL
- en: Protect system against any failures which occur because of network issues or
    any third-party clients or libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stop propagating failures and avoid dispersion of error
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fail fast, fail often, fail better, fail forward, and recover rapidly with counter-measures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Degrade failures with fallback mechanisms like returning response from the cache
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide dashboard for monitoring purposes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Take a look at the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/64667362-37e9-489f-b474-fd082acb167c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The circuit breaker follows the same set of rules as the original **Hystrix** module.
    To calculate the health of a command, the following steps are executed:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Maintain a watch on volume across the circuit as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the network volume across the circuit doesn't exceed the predefined value,
    then Hystrix can simply execute the run function without comparing anything at
    all. Metrics can log all told cases for future references.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the network volume across the circuit exceeds the configured brink value,
    Hystrix can check the health first to take preventive measures.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When checking the health, if the error percentage exceeds the pre-defined threshold,
    the transition of circuit happens from closed to open and all subsequent requests
    would be rejected with the open circuit error preventing further requests.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After an organized time Hystrix can enable one request to go through to examine
    whether the services are recovered. If it passes an expectation test, the circuit
    once more transitions to a closed state and all the counters are reset. To use
    it in your application just create service commands and add values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: To execute those commands just use the execute method. A complete gist can be
    found in the source inside `hystrix` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Need for gateway in our shopping cart microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After debunking gateways in detail lets come back to our shopping cart microservices
    system. We will look at the need for a gateway in our system and the things it
    will handle with our context and then move on to design the gateway. In this section,
    we will look at various design aspects that we need to consider while designing
    the gateway.
  prefs: []
  type: TYPE_NORMAL
- en: Handle performance and scalability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Being an entry point in system performance, scalability and high availability
    of API Gateway is a very crucial factor. As it will handle all the requests, making
    it on asynchronous non-blocking I/O seems very logical which is what Node.js is.
    All the requests coming from our shopping cart microservices need to be authenticated,
    cached, monitored and constantly send out health aware checks. Consider a scenario
    where our products service has larg traffic. API Gateway should then automatically
    spawn new instances of the server and maintain addresses of the new instances.
    The new instances then need to constantly send health checks to gateway so it
    would know which instances are alive. Consider the same example which we saw earlier
    where we have product microservice and we need to show the client a detailed listing
    of 20 items. Now the client is not going to make 21 HTTP requests but instead,
    we need a core composition component which combines responses from various requests.
  prefs: []
  type: TYPE_NORMAL
- en: Reactive programming to up the odds
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to make sure that we don't have to frequently change the client code,
    the API Gateway simply routes the client request to a microservice. It may make
    other requests by making multiple backend service calls and then aggregate all
    the results. In order to make sure that there is minimum response time, the API
    Gateway should make independent calls concurrently which is where a reactive model
    of programming comes into the picture. API Composition is needed in various cases
    like fetching the users past orders, where we first need to fetch the user details
    and then their past orders. Writing compositional logic using traditional asynchronous
    callbacks will soon lead to the problem of callback hell which will produce coupled,
    tangled, difficult to understand and error-prone code which is where reactive
    programming is very helpful.
  prefs: []
  type: TYPE_NORMAL
- en: Invoking services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Microservices do need to communicate with each other synchronously or asynchronously
    based on the business capability. There must be inter-process communication mechanisms.
    Our shopping cart microservices can have two modes of communication. One involves
    a message broker which queues up messages and sends them to services on availability.
    The other involves brokerless communication and the service directly communicates
    with an other service and this may have data loss. There are lots of event-driven
    message brokers such as AMQP, RabbitMQ, and so on, others such as Zeromq are brokerless.
  prefs: []
  type: TYPE_NORMAL
- en: Some business capabilities need asynchronous modes of communication such as
    during the checkout of a product, we need to call payment services. If there is
    successful payment, then and only then can the product be purchased. API Gateway
    needs to support a variety of mechanisms based on business capabilities. We will
    see a live example in [Chapter 7](162a0f25-2890-4a58-aa41-e9c9b5fc6c2d.xhtml), *Service
    State and Interservice Communication*, in the *NetFlix Case study* section.
  prefs: []
  type: TYPE_NORMAL
- en: Discovering services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With constantly dynamic and evolving services, our gateway needs to know the
    location (IP address, service port) of every microservice in the system. Now,
    this can be hotwired in the system but as they are evolving we need a more dynamic
    method as services constantly auto-scale and upgrade. For example, in our shopping
    cart microservices, we may constantly add new services based on use case. Now
    API Gateway needs to know the location of these services so it can query any of
    the services any time to return the response to the client. API Gateway must maintain
    communication with service registry which is just a database of all microservices
    locations and their instances.
  prefs: []
  type: TYPE_NORMAL
- en: Handling partial service failures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Yet another need to address is handling partial failures. When one service
    calls another service it may not receive a response at all or it may get delayed
    response. With the increased number of services, any service may go down at any
    point in time. API Gateway should be able to handle partial failures by implementing
    some/all of the following strategies:'
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous mode of communication by default. Using synchronous mode only when
    needed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A number of retries should be handled with exponential backoffs that is 1, 2,
    4, 16, and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Well defined network timeouts to prevent blocking of resources.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Circuit breaker pattern to trip the request if service is down or overloaded.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fallbacks or returning cached values. For example images of a product will never
    change frequently, they can be cached.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring the number of queued requests. If the number goes beyond a limit,
    then it doesn't make sense to send further requests.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design considerations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A good API Gateway should adhere to the following design considerations in
    order to have a rock solid microservice design:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Dependency: **There should not be a dependency on any other microservice.
    An API Gateway is just another microservice. If any service ID is unavailable
    for a preconfigured time or does not follow the SLAs then API Gateway should not
    wait for that service. It should rather fail fast using circuit breaker or another
    fall back strategy like returning cached responses.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Database and business logic: **API Gateway should not have database connectivity.
    Gateways are dumb that is they do not have any state. If you need a database then
    we need to create a separate microservice. Likewise business logic should reside
    in the service itself. Gateway just routes any service requests to an appropriate
    destination.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Orchestration and handling multiple content types:** Service choreography
    (a pattern where microservices communicate with each other) should be done at
    API Gateway rather than orchestration. Gateway should be connected to service
    registry which gives us a location of dynamically moving services.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Versioning: **Gateway should have appropriate versioning strategy. Its like
    we need to move a huge rock up the mountain, but as it is too big we break the
    rock into smaller pieces and distribute it to every person. Now each person will
    go at its own pace, but that doesn''t imply that he has to meet the other person''s
    expectation too, because, in the end, it is the whole rock that matters and not
    smaller pieces. Likewise, any particular version of a service should not break
    contract exposed. New contracts should be updated on a need basis so other clients
    can then know the new expectations until which backwards compatibility should
    be there.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**High Availability: **It should be highly available and scalable. Planning
    should be done for high volume and high load. If deployed in the cloud we can
    go with: AWS auto-scaling.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next section, we will dive into available gateway options and discuss
    them in detail. We will look at some cloud provider options too and see pros and
    cons of each.
  prefs: []
  type: TYPE_NORMAL
- en: Available API Gateways options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now let us look at some of the practical implementations of API Gateway available.
    In this section, we will look at options like Express Gateway, Netflix OSS, message
    brokers, NGINX as a reverse proxy, and tools available for designing gateway.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP proxy and Express Gateway
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'HTTP proxy is an HTTP programmable library for proxying. This is helpful for
    applying things such as reverse proxy or load balancing. `http-proxy` available
    in npm has more than 1 lakh download per day. To achieve request dispatching we
    can use `http-proxy`. This is a piece of cake and can be achieved like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'One of the gateways built on top of Express.js and Node.js, Express Gateway
    is the most simple to use with wide options such as language agnostic for a microservices
    use case and portable as it can be run anywhere in Docker in public or private
    cloud. It can work with any DevOps tools and it comes with pre-bundled proven
    and popular modules. We can extend this with any express middleware and this is
    totally config based and configs are auto-detected and hot reloaded. The following
    are core components in the express gateway:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Endpoints (API and service)** | They are nothing but URLs. Express Gateway
    maintains them in two forms. API endpoints and service endpoints. API endpoints
    are exposed and it proxies API requests to microservices asked for in service.
    |'
  prefs: []
  type: TYPE_TB
- en: '| **Policies** | Set of conditions or actions or contract that is evaluated
    and acted upon for any request that is passed through the gateway. Middlewares
    are utilized. |'
  prefs: []
  type: TYPE_TB
- en: '| **Pipelines** | Set of policies linked to microservices to be executed sequentially.
    For policy execution an API requested is passed through the pipeline where in
    the end it encounters a proxy policy which guides request to service endpoint.
    |'
  prefs: []
  type: TYPE_TB
- en: '| **Consumers** | Anyone who consumes microservices. To handle varying consumers
    Express Gateway comes with a consumer management module. The golden rule for which
    is an app must belong to a user. |'
  prefs: []
  type: TYPE_TB
- en: '| **Credentials** | Types of authentication and authorizations. Consumer or
    user may have one or more than one set of credentials. Credentials are linked
    to a scope. Express Gateway comes with the credential management module. |'
  prefs: []
  type: TYPE_TB
- en: '| **Scopes** | Labels used to assign authorization. Authorization policies
    protecting the endpoints look up at the credential to make sure the integrity
    of the system and consumer has that corresponding scope. |'
  prefs: []
  type: TYPE_TB
- en: 'Let''s now look at one example of Express Gateway. Following is the sample `gateway.config.yml`
    file which is generated using Express Gateway ( [https://www.express-gateway.io/](https://www.express-gateway.io/).):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The preceding configuration is a minimalist example of a JWT at gateway and
    proxy routes and is self explanatory.
  prefs: []
  type: TYPE_NORMAL
- en: Zuul and Eureka
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next option that we are going to look at is the Zuul proxy server provided
    by Netflix. Zuul is an edge service with objective of proxying requests to various
    backing services. Thus it acts as a "unified front door" to consume services.
    Zuul can be integrated with other open sourced tools by Netflix such as Hystrix
    for fault tolerance, Eureka for service discovery, routing engine, load balancing,
    and so on. Zuul is written in Java but can be used for microservices written in
    any language. Zuul provides ease in doing the following things:'
  prefs: []
  type: TYPE_NORMAL
- en: Validating contract requirements for each resource. If contract is not fulfilled,
    then rejecting those requests that do not meet them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Give us accurate view of production by tracking meaningful data and statistics.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting to service registries and dynamically routing to different backend
    clusters as needed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In order to gauge performance gradually increasing traffic in a cluster.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dropping requests that go over a limit, thus by achieving load shedding by allocating
    capacity for each type of request.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling static or cached responses, thus by preventing internal container trips.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Zuul 2.1 is under active development with the objective of achieving asynchronous
    operations at the gateway level. Zuul 2 is however non blocking and thoroughly
    relies on RxJava and reactive programming. To run Zuul as an API Gateway perform
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Zuul requires a Java environment. Clone the following Spring boot project:
    [https://github.com/kissaten/heroku-zuul-server-demo](https://github.com/kissaten/heroku-zuul-server-demo)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start the project using `mvn spring-boot:run`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the project's `src/main/resources/application.yml` file we will write
    our Zuul filters logic.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will add failover logic there. For example consider the following sample
    configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This configuration tells `zuul` to send all requests to the `httpbin` service.
    If we want to define multiple routes here we can. The `httpbin` service then defines
    the number of available servers. If the first host goes down, then proxy will
    fail over to the second host.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next chapter enables service discovery through another Netflix library:
    Eureka.'
  prefs: []
  type: TYPE_NORMAL
- en: API Gateway versus reverse proxy NGINX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we are going to look at possible options available at server
    levels. A reverse proxy (NGINX or Apache httpd) can do tasks like authenticating
    a request, handling transportation security, and load balancing. NGINX is one
    of the widely used tools to use a reverse proxy at gateway level in microservices.
    The following code sample depicts configuration with a reverse proxy, SSL certificates,
    and load balancing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The preceding configuration adds SSL certificates at a central level and adds
    proxies at three domains and load balances all requests among them.
  prefs: []
  type: TYPE_NORMAL
- en: RabbitMQ
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the most widely deployed message brokers, RabbitMQ operates on AMQP
    protocol. The `amqplib` client for Node.js is widely adopted and has more than
    16,000 downloads per day. In this section, we will look at a sample implementation
    of `amqp` and understand the options given by it. RabbitMQ follows more of an
    event based approach where each service listens to RabbitMQ "tasks" queue and
    on listening for an event, the service completes its task and then sends it to
    a `completed_tasks` queue. API Gateway listens for the `completed_tasks` queue
    and when it receives a message, it sends the response back to the client. So let
    us design our RabbitMQ class by performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will define our constructor as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Next we will define our connection method as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Next we will have a `send` method which sends a message to the RabbitMQ channel
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: You can see the full file here, where you will find all available options. Similar
    to earlier use cases, you can also find types for the `amqp` module at the definitely
    typed repository [https://gist.github.com/insanityrules/4d120b3d9c20053a7c6e280a6d5c5bfb](https://gist.github.com/insanityrules/4d120b3d9c20053a7c6e280a6d5c5bfb).
  prefs: []
  type: TYPE_NORMAL
- en: 'Next we just have to use the class. For example, take a look at the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As a prerequisite of for this project RabbitMQ must be installed on the system,
    which requires the installation of Erlang. Once RabbitMQ is up and running, you
    can check by typing `rabbitmqctl status` to make sure that RabbitMQ service is
    running.
  prefs: []
  type: TYPE_NORMAL
- en: Designing our gateway for shopping cart microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After seeing various options let's now get our hands dirty and start implementing
    our microservices gateway for shopping cart microservices. In this section, we
    will implement gateway from scratch which will have functionalities such as dispatching
    requests from public endpoints to internal endpoints, aggregate responses from
    multiple services, and handle transport security and dependency resolution. Let's
    look at all the concepts that we will use in this module before proceeding with
    code.
  prefs: []
  type: TYPE_NORMAL
- en: What are we going to use?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will look at all the following node modules and concepts
    in order to efficiently construct our gateway:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ES6 proxy**: Generally speaking, a proxy server is one which acts as an intermediary
    server for requests coming in from clients. One of the most powerful and interesting
    features in ES6 was proxy. ES6 proxy acts as an intermediary among API consumers
    and objects in services. We usually create proxies when we want our own desired
    behavior whenever the properties of the underlying target object are accessed.
    To configure traps for your proxy which has control of the underlying target object
    we use handler functions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**NPM module dockerode**: Its Node.js reactive module for Remote API for docker.
    It has some nice features such as streams for reactive programming, support for
    additional demultiplexing and promises and callback based interfaces for easy
    programming.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dependency injection**: One of the most important design patterns (initially
    started in Java, now it is present everywhere) in which one or more dependencies
    of a service are injected or passed by reference to a dependent object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Please check source code of `chapter 5` for custom implementation which includes
    service discovery. You can revisit this exercise after completing `chapter 6`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we debunked API Gateway. We understood the pros and cons of
    introducing API Gateway and what concerns API Gateway can handle centrally. We
    looked at design aspects of API Gateway and understood the need for API Gateway
    in our system. We had a look at the circuit breaker and why it was vital to have.
    We looked at available gateway options like Zuul, Express Gateway, reverse proxy,
    and designed our own gateway for shopping cart microservices.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about service registry and service discovery.
    We will see how gateway connects with service discovery to automatically know
    the location of moving services. We will see ways in which a service can be registered
    and learn the pros and cons of each approach. We will see some options like consul
    and implement them in our shopping cart microservices.
  prefs: []
  type: TYPE_NORMAL
