- en: '*Chapter 4*: Creating and Deploying Applications'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we have learned about Kubernetes nodes. Let's finally
    deploy an application using a Kubernetes deployment, scale the application up,
    and create a service for it.
  prefs: []
  type: TYPE_NORMAL
- en: A Kubernetes deployment is one way to deploy applications from Docker images,
    and we are going to use it for our example applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Kubernetes supports a few container runtimes, all of which can run Docker images:'
  prefs: []
  type: TYPE_NORMAL
- en: Docker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CRI-O
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Containerd
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to pods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a deployment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scaling up an application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to pods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A pod is a collocated group of application containers with shared volumes.
  prefs: []
  type: TYPE_NORMAL
- en: The applications in a pod all use the same network namespace, IP address, and
    port space. They can find and communicate with each other using localhost. Each
    pod has an IP address in a flat shared networking namespace that has full communication
    with other physical computers and containers across the network.
  prefs: []
  type: TYPE_NORMAL
- en: Pods are the smallest deployable units that can be created, scheduled, and managed
    with Kubernetes. Pods also can be created individually. As pods do not have a
    managed life cycle, if they die, they will not be recreated. For that reason,
    it is recommended that you use a deployment even if you are creating a single
    pod.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pods are also used in DaemonSets, StatefulSets, Jobs, and CronJobs:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – Pod with two containers'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B16411_04_001.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.1 – Pod with two containers
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding diagram shows a pod with two containers. Containers in a pod
    share the same Linux network namespace as well as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: IP address
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Localhost
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**IPC** (**inter-process communication**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's move on to deployments, which are more suited to real-world application
    deployments.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Kubernetes deployment provides updates for ReplicaSets, which ensures that
    a specified amount of pods (replicas) are running all the time:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 – Deployment with three pods'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B16411_04_002.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.2 – Deployment with three pods
  prefs: []
  type: TYPE_NORMAL
- en: The preceding diagram shows a deployment with three pods; the ReplicaSet will
    try to keep three pods running all the time. Of course, if there are no free resources
    in the Kubernetes cluster, the running pod replicas might not match the required
    replica count.
  prefs: []
  type: TYPE_NORMAL
- en: There are a few ways to create a Kubernetes deployment – let's explore them.
    The easiest way is using `$ kubectl create deployment`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create an `nginx` deployment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s check the created `nginx` deployment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s check the created `nginx` pod:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command created an `nginx` deployment with one `nginx-86c57db685-c9s49`
    pod.
  prefs: []
  type: TYPE_NORMAL
- en: 'It looks almost too easy, right? One command and boom: your deployment is running.'
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The `kubectl create deployment` command is only recommended for testing images,
    as there you do not specify the deployment template and you do not have much control
    over any additional settings you might want to set for the deployment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s deploy from the file using the `$ kubectl apply` command:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have a file called `deployment.yaml` with the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: When using the preceding file with `kubectl`, it will deploy the same `nginx`
    deployment as we did using the `$ kubectl create deployment` command, but in this
    case, later on, we can update the file according to our needs and upgrade the
    deployment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s delete the previously installed deployment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s redeploy using the `deployment.yaml` file this time:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the preceding commands, we have the deployment with one
    pod (replica) installed, but this time we used the template from the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows a deployment with three pods; the ReplicaSet will
    try to keep three pods uprunning at all times Again, if there are no free resources
    in the Kubernetes cluster, the running pod replicas might not match the required
    replica count:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3 – Kubernetes node'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B16411_04_003.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.3 – Kubernetes node
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at how to create a service.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kubernetes services provide a single stable name and address for a set of pods.
    They act as basic in-cluster load balancers.
  prefs: []
  type: TYPE_NORMAL
- en: Most pods are designed to be long-running, but when a single process dies, the
    pod dies with it. If it dies, the Deployment replaces it with a new pod. Every
    pod gets its own dedicated IP address, which allows containers to have the same
    port (the exception is when NodePort is used), even if they're sharing the same
    host. But when a pod is started by the Deployment, the pod gets a new IP address.
  prefs: []
  type: TYPE_NORMAL
- en: This is where services really help. A service is attached to the deployment.
    Each service gets assigned a virtual IP address that remains constant until the
    service dies. As long as we know the service IP address, the service itself will
    keep track of the pods created by the deployment and will distribute requests
    to the deployment pods.
  prefs: []
  type: TYPE_NORMAL
- en: 'By setting the service, we get an internal Kubernetes DNS name. Also, the service
    acts as an in-cluster load balancer when you have more than one ReplicaSet. With
    a service, you can also expose your application to the internet when the service
    type is set to LoadBalancer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4 – Kubernetes node'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B16411_04_004.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.4 – Kubernetes node
  prefs: []
  type: TYPE_NORMAL
- en: The preceding diagram explains how a service works.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we have our application up and running, let''s create a Kubernetes service
    for it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We used port `80`, and on that port, the `nginx` service was exposed to other
    Kubernetes applications; `target-port=80` is our `nginx` container port. We are
    using the `port=80` container because the official `nginx` Docker image ([https://hub.docker.com/_/nginx](https://hub.docker.com/_/nginx))
    we deployed in [*Chapter 3*](B16411_03_Final_VK_ePub.xhtml#_idTextAnchor039),
    *Working with Nodes*, uses port `80`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s check the created `nginx` service:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The preceding `kubectl get service` command shows the services list and `kubectl
    describe service nginx` describes the service.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see a few things there:'
  prefs: []
  type: TYPE_NORMAL
- en: The service got the same name, `nginx`, as the deployment we exposed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Selector: app=nginx` is the same as `matchLabels` in the `nginx` deployment;
    this is how the service knows how to connect to the right deployment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Type: ClusterIP` is the default service type when no `–type` flag is provided.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Using the `kubectl expose` command looks like an easy way to set up a service
    for the application. But again, we cannot put that command under Git control,
    nor can we change the service settings. For testing purposes, this is fine, but
    not for running a real-world application.
  prefs: []
  type: TYPE_NORMAL
- en: Let's deploy from the file using the `$ kubectl apply` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have a file called `service.yaml` that we are going to use to update the
    service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This time, let's keep the service we created with `kubectl expose` and see whether
    we can apply changes from the `service.yaml` file to the service we have created.
  prefs: []
  type: TYPE_NORMAL
- en: 'To deploy the service, we run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We got a warning (as first we used the `kubectl expose` command, and then we
    tried to update the service from the file), but our changes were applied to the
    service successfully, and from now on we can use `service.yaml` to make changes
    to the `nginx` service.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: When you create a service with `kubectl expose`, you can export its template
    to the YAML file with the `kubectl get service nginx -o yaml > service.yaml` command
    and reuse the file for future changes that you might need to make.
  prefs: []
  type: TYPE_NORMAL
- en: 'To export the `nginx` service, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The output for the preceding command is as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5 – Exporting the nginx service'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B16411_04_005.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.5 – Exporting the nginx service
  prefs: []
  type: TYPE_NORMAL
- en: 'Copy its contents to a file, and there you should remove the following parts,
    which were generated by `kubectl` and aren''t needed there:'
  prefs: []
  type: TYPE_NORMAL
- en: '`annotations`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`creationTimestamp`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`resourceVersion:`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`selfLink`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`uid`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Status`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: You can also export a deployment's template to a YAML file using the `kubectl
    get deployment nginx -o yaml > deployment.yaml` command.
  prefs: []
  type: TYPE_NORMAL
- en: Scaling up an application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we deployed an application with one replica; let's
    scale its deployment to two replicas.
  prefs: []
  type: TYPE_NORMAL
- en: 'The use case of running multiple replicas is to enable high availability for
    an application. To scale our deployment, run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: From the preceding output, we see can that the `$ kubectl get deployment nginx`
    command shows that the `nginx` deployment has two replicas. With `$ kubectl get
    pods`, we see two pods; one is just less than a minute old.
  prefs: []
  type: TYPE_NORMAL
- en: That's a neat command to scale deployments and is handy for testing purposes.
    Let's try to scale the deployment using the `deployment.yaml` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'This time, let''s scale to three replicas but using the `deployment.yaml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Update `deployment.yaml` with three replicas:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the same command as before:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Nice: we have updated the `nginx` deployment with three replicas from the `deployment.yaml`
    file.'
  prefs: []
  type: TYPE_NORMAL
- en: The service will distribute all incoming requests between the three pods in
    a round-robin manner.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned how to create, deploy, and scale up applications
    with `kubectl`. The new skills we have learned in this chapter can now be used
    to deploy real-world applications.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we going to learn how to do more advanced updates to deployed
    applications.
  prefs: []
  type: TYPE_NORMAL
