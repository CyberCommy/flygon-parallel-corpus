- en: Getting More Out of Our Objects with Descriptors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter introduces a new concept that is more advanced in Python development
    since it features descriptors. Moreover, descriptors are not something programmers
    of other languages are familiar with, so there are no easy analogies or parallelisms
    to make.
  prefs: []
  type: TYPE_NORMAL
- en: Descriptors are another distinctive feature of Python that takes object-oriented
    programming to another level, and their potential allows users to build more powerful
    and reusable abstractions. Most of the time, the full potential of descriptors
    is observed in libraries or frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will achieve the following goals that relate to descriptors:'
  prefs: []
  type: TYPE_NORMAL
- en: Understand what descriptors are, how they work, and how to implement them effectively
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analyze the two types of descriptors (data and non-data descriptors), in term
    of their conceptual differences and implementation details
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reuse code effectively through descriptors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analyze examples of good uses of descriptors, and how to take advantage of them
    for our own libraries of APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A first look at descriptors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, we will explore the main idea behind descriptors to understand their
    mechanics and internal workings. Once this is clear, it will be easier to assimilate
    how the different types of descriptors work, which we will explore in the next
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have a first understanding of the idea behind descriptors, we will look
    at an example where their use gives us a cleaner and more Pythonic implementation.
  prefs: []
  type: TYPE_NORMAL
- en: The machinery behind descriptors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The way descriptors work is not all that complicated, but the problem with them
    is that there are a lot of caveats to take into consideration, so the implementation
    details are of the utmost importance here.
  prefs: []
  type: TYPE_NORMAL
- en: In order to implement descriptors, we need at least two classes. For the purposes
    of this generic example, we are going to call the `client` class to the one that
    is going to take advantage of the functionality we want to implement in the `descriptor`
    (this class is generally just a domain model one, a regular abstraction we create
    for our solution), and we are going to call the `descriptor` class to the one
    that implements the logic of the descriptor.
  prefs: []
  type: TYPE_NORMAL
- en: 'A descriptor is, therefore, just an object that is an instance of a class that
    implements the descriptor protocol. This means that this class must have its interface
    containing at least one of the following magic methods (part of the descriptor
    protocol as of Python 3.6+):'
  prefs: []
  type: TYPE_NORMAL
- en: '`__get__`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**`__set__`**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__delete__`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**`__set_name__`**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For the purposes of this initial high-level introduction, the following naming
    convention will be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name** | **Meaning** |'
  prefs: []
  type: TYPE_TB
- en: '| `ClientClass` | The domain-level abstraction that will take advantage of
    the functionality to be implemented by the descriptor. This class is said to be
    a client of the descriptor.This class contains a class attribute (named `descriptor`
    by this convention), which is an instance of `DescriptorClass`. |'
  prefs: []
  type: TYPE_TB
- en: '| `DescriptorClass` | The class that implements the `descriptor` itself. This
    class should implement some of the aforementioned magic methods that entail the
    descriptor protocol. |'
  prefs: []
  type: TYPE_TB
- en: '| `client` | An instance of `ClientClass`.`client = ClientClass()` |'
  prefs: []
  type: TYPE_TB
- en: '| `descriptor` | An instance of `DescriptorClass`.`descriptor = DescriptorClass()`.This
    object is a class attribute that is placed in `ClientClass`. |'
  prefs: []
  type: TYPE_TB
- en: 'This relationship is illustrated in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/583337dd-c514-4f5d-967b-bd0811b56f7f.png)'
  prefs: []
  type: TYPE_IMG
- en: A very important observation to keep in mind is that for this protocol to work,
    the `descriptor` object has to be defined as a class attribute. Creating this
    object as an instance attribute will not work, so it must be in the body of the
    class, and not in the `init` method.
  prefs: []
  type: TYPE_NORMAL
- en: Always place the `descriptor` object as a class attribute!
  prefs: []
  type: TYPE_NORMAL
- en: On a slightly critical note, readers can also note that it is possible to implement
    the descriptor protocol partially—not all methods must always be defined; instead,
    we can implement only those we need, as we will see shortly.
  prefs: []
  type: TYPE_NORMAL
- en: So, now we have the structure in place—we know what elements are set and how
    they interact. We need a class for the `descriptor`, another class that will consume
    the logic of the `descriptor`, which, in turn, will have a `descriptor` object
    (an instance of the `DescriptorClass`) as a class attribute, and instances of
    `ClientClass` that will follow the descriptor protocol when we call for the attribute
    named `descriptor`. But now what? How does all of this fit into place at runtime?
  prefs: []
  type: TYPE_NORMAL
- en: 'Normally, when we have a regular class and we access its attributes, we simply
    obtain the objects as we expect them, and even their properties, as in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: But, in the case of descriptors, something different happens. When an object
    is defined as a class attribute (and this one is a `descriptor`), when a `client`
    requests this attribute, instead of getting the object itself (as we would expect
    from the previous example), we get the result of having called the `__get__` magic
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with some simple code that only logs information about the context,
    and returns the same `client` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'When running this code, and requesting the `descriptor` attribute of an instance
    of `ClientClass`, we will discover that we are, in fact, not getting an instance
    of `DescriptorClass`, but whatever its `__get__()` method returns instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Notice how the logging line, placed under the `__get__` method, was called instead
    of just returning the object we created. In this case, we made that method return
    the `client` itself, hence making true a comparison of the last statement. The
    parameters of this method are explained in more detail in the following subsections
    when we explore each method in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Starting from this simple, yet demonstrative example, we can start creating
    more complex abstractions and better decorators, because the important note here
    is that we have a new (powerful) tool to work with. Notice how this changes the
    control flow of the program in a completely different way. With this tool, we
    can abstract all sorts of logic behind the `__get__` method, and make the `descriptor`
    transparently run all sorts of transformations without clients even noticing.
    This takes encapsulation to a new level.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring each method of the descriptor protocol
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up until now, we have seen quite a few examples of descriptors in action, and
    we got the idea of how they work. These examples gave us a first glimpse of the
    power of descriptors, but you might be wondering about some implementation details
    and idioms whose explanation we failed to address.
  prefs: []
  type: TYPE_NORMAL
- en: Since descriptors are just objects, these methods take `self` as the first parameter.
    For all of them, this just means the `descriptor` object itself.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will explore each method of the descriptor protocol, in
    full detail, explaining what each parameter signifies, and how they are intended
    to be used.
  prefs: []
  type: TYPE_NORMAL
- en: __get__(self, instance, owner)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first parameter, `instance`, refers to the object from which the `descriptor`
    is being called. In our first example, this would mean the `client` object.
  prefs: []
  type: TYPE_NORMAL
- en: The `owner` parameter is a reference to the class of that object, which following
    our example (from the previous class diagram in *The machinery behind descriptors*
    section) would be `ClientClass`.
  prefs: []
  type: TYPE_NORMAL
- en: From the previous paragraph we conclude that the parameter named `instance`
    in the signature of `__get__` is the object over which the descriptor is taking
    action, and `owner` is the class of `instance`. The avid reader might be wondering
    why is the signature define like this, after all the class can be taken from `instance`
    directly (`owner = instance.__class__`). There is an edge case—when the `descriptor`
    is called from the class (`ClientClass`), not from the instance (`client`), then
    the value of `instance` is `None`, but we might still want to do some processing
    in that case.
  prefs: []
  type: TYPE_NORMAL
- en: With the following simple code we can demonstrate the difference of when a descriptor
    is being called from the class, or from an instance. In this case, the `__get__` method
    is doing two separate things for each case.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'When we call it from `ClientClass` directly it will do one thing, which is
    composing a namespace with the names of the classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'And then if we call it from an object we have created, it will return the other
    message instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In general, unless we really need to do something with the `owner` parameter,
    the most common idiom, is to just return the descriptor itself, when `instance
    is None`.
  prefs: []
  type: TYPE_NORMAL
- en: __set__(self, instance, value)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This method is called when we try to assign something to a `descriptor`. It
    is activated with statements such as the following, in which a `descriptor` is
    an object that implements `__set__ ()`**.** The `instance` parameter, in this
    case, would be `client`, and the `value `would be the `"value"` string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: If `client.descriptor` doesn't implement `__set__()`, then `"value"` will override
    the `descriptor` entirely.
  prefs: []
  type: TYPE_NORMAL
- en: Be careful when assigning a value to an attribute that is a descriptor. Make
    sure it implements the `__set__` method, and that we are not causing an undesired
    side effect.
  prefs: []
  type: TYPE_NORMAL
- en: By default, the most common use of this method is just to store data in an object.
    Nevertheless, we have seen how powerful descriptors are so far, and that we can
    take advantage of them, for example, if we were to create generic validation objects
    that can be applied multiple times (again, this is something that if we don't
    abstract, we might end up repeating multiple times in setter methods of properties).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following listing illustrates how we can take advantage of this method
    in order to create generic `validation` objects for attributes, which can be created
    dynamically with functions to validate on the values before assigning them to
    the object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see this object in action in the following listing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The idea is that something that we would normally place in a property can be
    abstracted away into a `descriptor`, and reuse it multiple times. In this case,
    the `__set__()`method would be doing what the `@property.setter` would have been
    doing.
  prefs: []
  type: TYPE_NORMAL
- en: __delete__(self, instance)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This method is called upon with the following statement, in which `self` would
    be the `descriptor` attribute, and `instance` would be the `client` object in
    this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following example, we use this method to create a `descriptor` with
    the goal of preventing you from removing attributes from an object without the
    required administrative privileges. Notice how, in this case, that the `descriptor`
    has logic that is used to predicate with the values of the object that is using
    it, instead of different related objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Before seeing examples of how this object works, it's important to remark some
    of the criteria of this descriptor. Notice the `User` class requires the `username`
    and `email` as mandatory parameters. According to its `**__init__**` method, it
    cannot be a user if it doesn't have an `email` attribute. If we were to delete
    that attribute, and extract it from the object entirely we would be creating an
    inconsistent object, with some invalid intermediate state that does not correspond
    to the interface defined by the class `User`.  Details like this one are really
    important, in order to avoid issues. Some other object is expecting to work with
    this `User`, and it also expects that it has an `email` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, it was decided that the "deletion" of an email will just simply
    set it to `None`, and that is the part of the code listing that is in bold. For
    the same reason, we must forbid someone trying to set a `None` value to it, because
    that would bypass the mechanism we placed in the `**__delete__**` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we can see it in action, assuming a case where only users with `"admin"`
    privileges can remove their email address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Here, in this simple `descriptor`, we see that we can delete the email from
    users that contain the `"admin"` permission only. As for the rest, when we try
    to call `del` on that attribute, we will get a `ValueError` exception.
  prefs: []
  type: TYPE_NORMAL
- en: In general, this method of the descriptor is not as commonly used as the two
    previous ones, but it is worth showing it for completeness.
  prefs: []
  type: TYPE_NORMAL
- en: __set_name__(self, owner, name)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we create the `descriptor` object in the class that is going to use it,
    we generally need the `descriptor` to know the name of the attribute it is going
    to be handling.
  prefs: []
  type: TYPE_NORMAL
- en: This attribute name is the one we use to read from and write to `__dict__` in
    the `__get__` and `__set__` methods, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Before Python 3.6, the descriptor couldn't take this name automatically, so
    the most general approach was to just pass it explicitly when initializing the
    object. This works fine, but it has an issue in that it requires that we duplicate
    the name every time we want to use the descriptor for a new attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what a typical `descriptor` would look like if we didn''t have this
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see how the `descriptor` uses this value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now, if we wanted to avoid writing the name of the attribute twice (once for
    the variable assigned inside the class, and once again as the name of the first
    parameter of the descriptor), we have to resort to a few tricks, like using a
    class decorator, or (even worse) using a metaclass.
  prefs: []
  type: TYPE_NORMAL
- en: In Python 3.6, the new method `__set_name__` was added, and it receives the
    class where that descriptor is being created, and the name that is being given
    to that descriptor. The most common idiom is to use this method for the descriptor
    so that it can store the required name in this method.
  prefs: []
  type: TYPE_NORMAL
- en: For compatibility, it is generally a good idea to keep a default value in the
    `__init__` method but still take advantage of `__set_name__`.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this method, we can rewrite the previous descriptors as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Types of descriptors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Based on the methods we have just explored, we can make an important distinction
    among descriptors in terms of how they work. Understanding this distinction plays
    an important role in working effectively with descriptors, and will also help
    to avoid caveats or common errors at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: If a descriptor implements the `__set__` or `__delete__` methods, it is called
    a** data descriptor**. Otherwise, a descriptor that solely implements `__get__` is
    a** non-data descriptor***.* Notice that `__set_name__` does not affect this classification
    at all.
  prefs: []
  type: TYPE_NORMAL
- en: When trying to resolve an attribute of an object, a data descriptor will always
    take precedence over the dictionary of the object, whereas a non-data descriptor
    will not**.** This means that in a non-data descriptor if the object has a key
    on its dictionary with the same name as the descriptor, this one will always be
    called, and the descriptor itself will never run. Conversely, in a data descriptor,
    even if there is a key in the dictionary with the same name as the descriptor,
    this one will never be used since the descriptor itself will always end up being
    called.
  prefs: []
  type: TYPE_NORMAL
- en: The following two sections explain this in more detail, with examples, in order
    to get a deeper idea of what to expect from each type of descriptor.
  prefs: []
  type: TYPE_NORMAL
- en: Non-data descriptors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will start with a `descriptor` that only implements the `__get__` method,
    and see how it is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'As usual, if we ask for the `descriptor`, we get the result of its `__get__`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'But if we change the `descriptor` attribute to something else, we lose access
    to this value, and get what was assigned to it instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we delete the `descriptor`, and ask for it again, let''s see what we
    get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s rewind what just happened. When we first created the `client` object,
    the `descriptor` attribute lay in the class, not the instance, so if we ask for
    the dictionary of the `client` object, it will be empty:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: And then, when we request the `.descriptor` attribute, it doesn't find any key
    in `client.__dict__` named `"descriptor"`, so it goes to the class, where it will
    find it ... but only as a descriptor, hence why it returns the result of the `__get__`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'But then, we change the value of the `.descriptor` attribute to something else,
    and what this does is set this into the dictionary of the `instance`, meaning
    that this time it won''t be empty:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: So, when we ask for the `.descriptor` attribute here, it will look for it in
    the object (and this time it will find it, because there is a key named `descriptor`
    in the `__dict__` attribute of the object, as the `vars` result is showing us),
    and return it without having to look for it in the class. For this reason, the
    descriptor protocol is never invoked, and the next time we ask for this attribute,
    it will instead return the value we have overridden it with (`99`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Afterward, we delete this attribute by calling `del`, and what this does is
    remove the key `"descriptor"` from the dictionary of the object, leaving us back
    in the first scenario, where it''s going to default to the class where the descriptor
    protocol will be activated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This means that if we set the attribute of the `descriptor` to something else,
    we might be accidentally breaking it. Why? Because the `descriptor` doesn't handle
    the delete action (some of them don't need to).
  prefs: []
  type: TYPE_NORMAL
- en: This is called a non-data descriptor because it doesn't implement the `__set__`
    magic method, as we will see in the next example.
  prefs: []
  type: TYPE_NORMAL
- en: Data descriptors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s look at the difference of using a data descriptor. For this, we
    are going to create another simple `descriptor` that implements the `__set__` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see what the value of the `descriptor` returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s try to change this value to something else, and see what it returns
    instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The value returned by the `descriptor` didn''t change. But when we assign a
    different value to it, it must be set to the dictionary of the object (as it was
    previously):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: So, the `__set__()` method was called, and indeed it did set the value to the
    dictionary of the object, only this time, when we request this attribute, instead
    of using the `__dict__` attribute of the dictionary, the `descriptor` takes precedence
    (because it's an overriding `descriptor`).
  prefs: []
  type: TYPE_NORMAL
- en: 'One more thing—deleting the attribute will not work anymore:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The reason is as follows—given that now, the `descriptor` always takes place,
    calling `del` on an object doesn't try to delete the attribute from the dictionary
    (`__dict__`) of the object, but instead it tries to call the `__delete__()` method
    of the `descriptor` (which is not implemented in this example, hence the attribute
    error).
  prefs: []
  type: TYPE_NORMAL
- en: This is the difference between data and non-data descriptors. If the descriptor
    implements `__set__()`, then it will always take precedence, no matter what attributes
    are present in the dictionary of the object. If this method is not implemented,
    then the dictionary will be looked up first, and then the descriptor will run.
  prefs: []
  type: TYPE_NORMAL
- en: 'An interesting observation you might have noticed is this line on the `set`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: There are a lot of things to question about that line, but let's break it down
    into parts.
  prefs: []
  type: TYPE_NORMAL
- en: First, why is it altering just the name of a `"descriptor"` attribute? This
    is just a simplification for this example, but, as it transpires when working
    with descriptors, it doesn't know at this point the name of the parameter it was
    assigned to, so we just used the one from the example, knowing that it was going
    to be `"descriptor"`.
  prefs: []
  type: TYPE_NORMAL
- en: In a real example, you would do one of two things—either receive the name as
    a parameter and store it internally in the `init` method, so that this one will
    just use the internal attribute, or, even better, use the `__set_name__`method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Why is it accessing the `__dict__` attribute of the instance directly? Another
    good question, which also has at least two explanations. First, you might be thinking
    why not just do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Remember that this method (`__set__`) is called when we try to assign something
    to the attribute that is a `descriptor`. So, using `setattr()` will call this
    `descriptor` again, which, in turn, will call it again, and so on and so forth.
    This will end up in an infinite recursion.
  prefs: []
  type: TYPE_NORMAL
- en: Do not use `setattr()` or the assignment expression directly on the descriptor
    inside the `__set__` method because that will trigger an infinite recursion.
  prefs: []
  type: TYPE_NORMAL
- en: Why, then, is the descriptor not able to book-keep the values of the properties
    for all of its objects?
  prefs: []
  type: TYPE_NORMAL
- en: The `client` class already has a reference to the descriptor. If we add a reference
    from the descriptor to the `client` object, we are creating circular dependencies,
    and these objects will never be garbage-collected. Since they are pointing at
    each other, their reference counts will never drop below the threshold for removal.
  prefs: []
  type: TYPE_NORMAL
- en: A possible alternative here is to use weak references, with the `weakref`module,
    and create a weak reference key dictionary if we want to do that. This implementation
    is explained later on in this chapter, but for the implementations within this
    book, we prefer to use this idiom, since it is fairly common and accepted when
    writing descriptors.
  prefs: []
  type: TYPE_NORMAL
- en: Descriptors in action
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have seen what descriptors are, how they work, and what the main
    ideas behind them are, we can see them in action. In this section, we will be
    exploring some situations that can be elegantly addressed through descriptors.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we will look at some examples of working with descriptors, and we will
    also cover implementation considerations for them (different ways of creating
    them, with their pros and cons), and finally we will discuss what the most suitable
    scenarios for descriptors are.
  prefs: []
  type: TYPE_NORMAL
- en: An application of descriptors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will start with a simple example that works, but that will lead to some code
    duplication. It is not very clear how this issue will be addressed. Later on,
    we will devise a way of abstracting the repeated logic into a descriptor, which
    will address the duplication problem, and we will notice that the code on our
    client classes will be reduced drastically.
  prefs: []
  type: TYPE_NORMAL
- en: A first attempt without using descriptors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The problem we want to solve now is that we have a regular class with some attributes,
    but we wish to track all of the different values a particular attribute has over
    time, for example, in a list. The first solution that comes to our mind is to
    use a property, and every time a value is changed for that attribute in the setter
    method of the property, we add it to an internal list that will keep this trace
    as we want it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine that our class represents a traveler in our application that has a
    current city, and we want to keep track of all the cities that user has visited
    throughout the running of the program. The following code is a possible implementation
    that addresses these requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We can easily check that this code works according to our requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: So far, this is all we need and nothing else has to be implemented. For the
    purposes of this problem, the property would be more than enough. What happens
    if we need the exact same logic in multiple places of the application? This would
    mean that this is actually an instance of a more generic problem—tracing all the
    values of an attribute in another one. What would happen if we want to do the
    same with other attributes, such as keeping track of all tickets Alice bought,
    or all the countries she has been in? We would have to repeat the logic in all
    of these places.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, what would happen if we need this same behavior in different classes?
    We would have to repeat the code or come up with a generic solution (maybe a decorator,
    a property builder, or a descriptor). Since property builders are a particular
    (and more convoluted) case of descriptors, they are beyond of the scope of this
    book, and instead, descriptors are suggested as a cleaner way of proceeding.
  prefs: []
  type: TYPE_NORMAL
- en: The idiomatic implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will now look at how to address the questions of the previous section by
    using a descriptor that is generic enough as to be applied in any class. Again,
    this example is not really needed because the requirements do not specify such
    generic behavior (we haven't even followed the rule of three instances of the
    similar pattern previously creating the abstraction), but it is shown with the
    goal of portraying descriptors in action.
  prefs: []
  type: TYPE_NORMAL
- en: Do not implement a descriptor unless there is actual evidence of the repetition
    we are trying to solve, and the complexity is proven to have paid off.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will create a generic descriptor that, given a name for the attribute
    to hold the traces of another one, will store the different values of the attribute
    in a list.
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned previously, the code is more than what we need for the problem,
    but its intention is just to show how a descriptor would help us in this case.
    Given the generic nature of descriptors, the reader will notice that the logic
    on it (the name of their method, and attributes) does not relate to the domain
    problem at hand (a traveler object). This is because the idea of the descriptor
    is to be able to use it in any type of class, probably on different projects,
    with the same outcomes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to address this gap, some parts of the code are annotated, and the
    respective explanation for each section (what it does, and how it relates to the
    original problem) is described in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Some annotations and comments on the code are as follows (numbers in the list
    correspond to the number annotations in the previous listing):'
  prefs: []
  type: TYPE_NORMAL
- en: The name of the attribute is one of the variables assigned to the `descriptor`,
    in this case, `current_city`. We pass to the `descriptor` the name of the variable
    in which it will store the trace for the variable of the `descriptor`. In this
    example, we are telling our object to keep track of all the values that `current_city`
    has had in the attribute named `cities_visited`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first time we call the `descriptor`, in the `init`, the attribute for tracing
    values will not exist, in which case we initialize it to an empty list to later
    append values to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `init` method, the name of the attribute `current_city` will not exist
    either, so we want to keep track of this change as well. This is the equivalent
    of initializing the list with the first value in the previous example.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Only track changes when the new value is different from the one that is currently
    set.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `init` method, the `descriptor` already exists, and this assignment instruction
    triggers the actions from step 2 (create the empty list to start tracking values
    for it), and step 3 (append the value to this list, and set it to the key in the
    object for retrieval later).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `setdefault` method in a dictionary is used to avoid a `KeyError`. In this
    case an empty list will be returned for those attributes that aren't still available
    (see [https://docs.python.org/3.6/library/stdtypes.html#dict.setdefault](https://docs.python.org/3.6/library/stdtypes.html#dict.setdefault)
    for reference).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is true that the code in the `descriptor` is rather complex. On the other
    hand, the code in the `client` class is considerably simpler. Of course, this
    balance only pays off if we are going to use this `descriptor` multiple times,
    which is a concern we have already covered.
  prefs: []
  type: TYPE_NORMAL
- en: What might not be so clear at this point is that the descriptor is indeed completely
    independent from the `client` class. Nothing in it suggests anything about the
    business logic. This makes it perfectly suitable to apply it in any other class;
    even if it does something completely different, the descriptor will take the same
    effect.
  prefs: []
  type: TYPE_NORMAL
- en: This is the true Pythonic nature of descriptors. They are more appropriate for
    defining libraries, frameworks, or internal APIs, and not that much for business
    logic.
  prefs: []
  type: TYPE_NORMAL
- en: Different forms of implementing descriptors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have to first understand a common issue that's specific to the nature of
    descriptors before thinking of ways of implementing them. First, we will discuss
    the problem of a global shared state, and afterward we will move on and look at
    different ways descriptors can be implemented while taking this into consideration.
  prefs: []
  type: TYPE_NORMAL
- en: The issue of global shared state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have already mentioned, descriptors need to be set as class attributes
    to work. This should not be a problem most of the time, but it does come with
    some warnings that need to be taken into consideration.
  prefs: []
  type: TYPE_NORMAL
- en: The problem with class attributes is that they are shared across all instances
    of that class. Descriptors are not an exception here, so if we try to keep data
    in a `descriptor` object, keep in mind that all of them will have access to the
    same value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see what happens when we incorrectly define a `descriptor` that keeps
    the data itself, instead of storing it in each object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, the `descriptor` object stores the data itself. This carries
    with it the inconvenience that when we modify the value for an `instance` all
    other instances of the same classes are also modified with this value as well.
    The following code listing puts that theory in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Notice how we change one object, and suddenly all of them are from the same
    class, and we can see that this value is reflected. This is because `ClientClass.descriptor`
    is unique; it's the same object for all of them.
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, this might be what we actually want (for instance, if we were
    to create a sort of Borg pattern implementation, on which we want to share state
    across all objects from a class), but in general, that is not the case, and we
    need to differentiate between objects. Such pattern is discussed with more detail
    in [Ch](dee5b4ed-34cd-4077-a5b4-83d4853e6e56.xhtml)[apter](dee5b4ed-34cd-4077-a5b4-83d4853e6e56.xhtml)
    [9](dee5b4ed-34cd-4077-a5b4-83d4853e6e56.xhtml)*, Common Design Patterns*.
  prefs: []
  type: TYPE_NORMAL
- en: To achieve this, the descriptor needs to know the value for each `instance`
    and return it accordingly. That is the reason we have been operating with the
    dictionary (`__dict__`) of each `instance` and setting and retrieving the values
    from there.
  prefs: []
  type: TYPE_NORMAL
- en: This is the most common approach. We have already covered why we cannot use
    `getattr()` and `setattr()` on those methods, so modifying the `__dict__` attribute
    is the last standing option, and, in this case, is acceptable.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing the dictionary of the object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The way we implement descriptors throughout this book is making the `descriptor`
    object store the values in the dictionary of the object, `__dict__`, and retrieve
    the parameters from there as well.
  prefs: []
  type: TYPE_NORMAL
- en: Always store and return the data from the `__dict__` attribute of the instance.
  prefs: []
  type: TYPE_NORMAL
- en: Using weak references
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another alternative (if we don't want to use `__dict__`) is to make the `descriptor`
    object keep track of the values for each instance itself, in an internal mapping,
    and return values from this mapping as well.
  prefs: []
  type: TYPE_NORMAL
- en: There is a caveat, though. This mapping cannot just be any dictionary. Since
    the `client` class has a reference to the descriptor, and now the descriptor will
    keep references to the objects that use it, this will create circular dependencies,
    and, as a result, these objects will never be garbage-collected because they are
    pointing at each other.
  prefs: []
  type: TYPE_NORMAL
- en: In order to address this, the dictionary has to be a weak key one, as defined
    in the `weakref` (WEAKREF 01) module.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, the code for the `descriptor` might look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This addresses the issues, but it does come with some considerations:'
  prefs: []
  type: TYPE_NORMAL
- en: The objects no longer hold their attributes—the descriptor does instead. This
    is somewhat controversial, and it might not be entirely accurate from a conceptual
    point of view. If we forget this detail, we might be asking the object by inspecting
    its dictionary, trying to find things that just aren't there (calling `vars(client)` will
    not return the complete data, for example).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It poses the requirement over the objects that they need to be hashable. If
    they aren't, they can't be part of the mapping. This might be too demanding a
    requirement for some applications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For these reasons, we prefer the implementation that has been shown so far in
    this book, which uses the dictionary of each instance. However, for completeness,
    we have shown this alternative as well.
  prefs: []
  type: TYPE_NORMAL
- en: More considerations about descriptors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here, we will discuss general considerations about descriptors in terms of what
    we can do with them when it is a good idea to use them, and also how things that
    we might have initially conceived as having been resolved by means of another
    approach can be improved through descriptors. We will then analyze the pros and
    cons of the original implementation versus the one after descriptors have been
    used.
  prefs: []
  type: TYPE_NORMAL
- en: Reusing code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Descriptors are a generic tool and a powerful abstraction that we can use to
    avoid code duplication. The best way to decide when to use descriptors is to identify
    cases where we would be using a property (whether for its `get` logic, `set` logic,
    or both), but repeating its structure many times.
  prefs: []
  type: TYPE_NORMAL
- en: Properties are just a particular case of descriptors (the `@property` decorator
    is a descriptor that implements the full descriptor protocol to define their `get`,
    `set`, and `delete` actions), which means that we can use descriptors for far
    more complex tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Another powerful type we have seen for reusing code was decorators, as explained
    in [Chapter 5](f5d9c7e4-4092-48de-a22c-564df482b021.xhtml), *Using Decorators
    to Improve Our Code*. Descriptors can help us create to better decorators by making
    sure that they will be able to work correctly for class methods as well.
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to decorators, we could say that it is safe to always implement
    the `__get__()` method on them, and also make it a descriptor. When trying to
    decide whether the decorator is worth creating, consider the three problems rule
    we stated in [Chapter 5](f5d9c7e4-4092-48de-a22c-564df482b021.xhtml), *Using Decorators
    to Improve Our Code*, but note that there are no extra considerations toward descriptors.
  prefs: []
  type: TYPE_NORMAL
- en: As for generic descriptors, besides the aforementioned three instances rule
    that applies to decorators (and, in general, any reusable component), it is advisable
    to also keep in mind that you should use descriptors for cases when we want to
    define an internal API, which is some code that will have clients consuming it.
    This is a feature-oriented more toward designing libraries and frameworks, rather
    than one-time solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Unless there is a very good reason to, or that the code will look significantly
    better, we should avoid putting business logic in a descriptor. Instead, the code
    of a descriptor will contain more implementational code rather than business code.
    It is more similar to defining a new data structure or object that another part
    of our business logic will use as a tool.
  prefs: []
  type: TYPE_NORMAL
- en: In general, descriptors will contain implementation logic, and not so much business
    logic.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding class decorators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we recall the class decorator we used in [Chapter 5,](f5d9c7e4-4092-48de-a22c-564df482b021.xhtml) *Using
    Decorators to Improve Our Code*, to determine how an event object is going to
    be serialized, we ended up with an implementation that (for Python 3.7+) relied
    on two class decorators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The first one takes the attributes from the annotations to declare the variables,
    whereas the second one defines how to treat each file. Let's see whether we can
    change these two decorators for descriptors instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'The idea is to create a descriptor that will apply the transformation over
    the values of each attribute, returning the modified version according to our
    requirements (for example, hiding sensitive information, and formatting dates
    correctly):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This `descriptor` is interesting. It was created with a function that takes
    one argument and returns one value. This function will be the transformation we
    want to apply to the field. From the base definition that defines generically
    how it is going to work, the rest of the `descriptor` classes are defined, simply
    by changing the particular function each one needs.
  prefs: []
  type: TYPE_NORMAL
- en: The example uses `functools.partial` ([https://docs.python.org/3.6/library/functools.html#functools.partial](https://docs.python.org/3.6/library/functools.html#functools.partial))
    as a way of simulating sub-classes, by applying a partial application of the transformation
    function for that class, leaving a new callable that can be instantiated directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to keep the example simple, we will implement the `__init__()` and
    `serialize()` methods, although they could be abstracted away as well. Under these
    considerations, the class for the event will now be defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see how the object behaves at runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: There are some differences with respect to the previous implementation that
    used a decorator. This example added the `serialize()` method and hid the fields before
    presenting them to its resulting dictionary, but if we asked for any of these
    attributes to an instance of the event in memory at any point, it would still
    give us the original value, without any transformation applied to it (we could
    have chosen to apply the transformation when setting the value, and return it
    directly on the `__get__()`, as well).
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the sensitivity of the application, this may or may not be acceptable,
    but in this case, when we ask the object for its `public` attributes, the descriptor
    will apply the transformation before presenting the results. It is still possible
    to access the original values by asking for the dictionary of the object (by accessing
    `__dict__`), but when we ask for the value, by default, it will return it converted.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, all descriptors follow a common logic, which is defined in
    the base class. The descriptor should store the value in the object and then ask
    for it, applying the transformation it defines. We could create a hierarchy of
    classes, each one defining its own conversion function, in a way that the template
    method design pattern works. In this case, since the changes in the derived classes
    are relatively small (just one function), we opted for creating the derived classes
    as partial applications of the base class. Creating any new transformation field
    should be as simple as defining a new class that will be the base class, which
    is partially applied with the function we need. This can even be done ad hoc,
    so there might be no need to set a name for it.
  prefs: []
  type: TYPE_NORMAL
- en: Regardless of this implementation, the point is that since descriptors are objects,
    we can create models, and apply all rules of object-oriented programming to them.
    Design patterns also apply to descriptors. We could define our hierarchy, set
    the custom behavior, and so on. This example follows the OCP, which we introduced
    in [Chapter 4](532e5ff0-6f3d-44a5-b2a9-94c686bbd6ba.xhtml), *The SOLID Principles*,
    because adding a new type of conversion method would just be about creating a
    new class, derived from the base one with the function it needs, without having
    to modify the base class itself (to be fair, the previous implementation with
    decorators was also OCP-compliant, but there were no classes involved for each
    transformation mechanism).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take an example where we create a base class that implements the `__init__()`
    and `serialize()` methods so that we can define the `LoginEvent` class simply
    by deriving from it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Once we achieve this code, the class looks cleaner. It only defines the attributes
    it needs, and its logic can be quickly analyzed by looking at the class for each
    attribute. The base class will abstract only the common methods, and the class
    of each event will look simpler and more compact.
  prefs: []
  type: TYPE_NORMAL
- en: Not only do the classes for each event look simple, but the descriptor itself
    is very compact and a lot simpler than the class decorators. The original implementation
    with class decorators was good, but descriptors made it even better.
  prefs: []
  type: TYPE_NORMAL
- en: Analysis of descriptors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen how descriptors work so far and explored some interesting situations
    in which they contribute to clean design by simplifying their logic and leveraging
    more compact classes.
  prefs: []
  type: TYPE_NORMAL
- en: Up to this point, we know that by using descriptors, we can achieve cleaner
    code, abstracting away repeated logic and implementation details. But how do we
    know our implementation of the descriptors is clean and correct? What makes a
    good descriptor? Are we using this tool properly or over-engineering with it?
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will analyze descriptors in order to answer these questions.
  prefs: []
  type: TYPE_NORMAL
- en: How Python uses descriptors internally
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Referring to the question as to what makes a good descriptor?, a simple answer
    would be that a good descriptor is pretty much like any other good Python object.
    It is consistent with Python itself. The idea that follows this premise is that
    analyzing how Python uses descriptors will give us a good idea of good implementations
    so that we know what to expect from the descriptors we write.
  prefs: []
  type: TYPE_NORMAL
- en: We will see the most common scenarios where Python itself uses descriptors to
    solve parts of its internal logic, and we will also discover elegant descriptors
    and that they have been there in plain sight all along.
  prefs: []
  type: TYPE_NORMAL
- en: Functions and methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most resonating case of an object that is a descriptor is probably a function.
    Functions implement the `__get__` method, so they can work as methods when defined
    inside a class.
  prefs: []
  type: TYPE_NORMAL
- en: Methods are just functions that take an extra argument. By convention, the first
    argument of a method is named "self", and it represents an instance of the class
    that the method is being defined in. Then, whatever the method does with "self",
    would be the same as any other function receiving the object and applying modifications
    to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order words, when we define something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'It is actually the same as if we define this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: So, it is just another function, modifying the object, only that it's defined
    inside the class, and it is said to be bound to the object.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we call something in the form of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Python is, in fact, doing something equivalent to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Notice that this is just a syntax conversion that is handled internally by Python.
    The way this works is by means of descriptors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since functions implement the descriptor protocol (see the following listing)
    before calling the method, the `__get__()` method is invoked first, and some transformations
    happen before running the code on the internal callable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: In the `instance.method(...)` statement, before processing all the arguments
    of the callable inside the parenthesis, the `"instance.method"` part is evaluated.
  prefs: []
  type: TYPE_NORMAL
- en: Since `method` is an object defined as a class attribute, and it has a `__get__`
    method, this is called. What this does is convert the `function` to a method,
    which means binding the callable to the instance of the object it is going to
    work with.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see this with an example so that we can get an idea of what Python might
    be doing internally.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will define a callable object inside a class that will act as a sort of
    function or method that we want to define to be invoked externally. An instance
    of the `Method` class is supposed to be a function or method to be used inside
    a different class. This function will just print its three parameters—the `instance`
    that it received (which would be the `self` parameter on the class it''s being
    defined in), and two more arguments. Notice that in the `__call__()` method, the
    `self` parameter does not represent the `instance` of `MyClass`, but instead an
    instance of `Method`. The parameter named `instance` is meant to be a `MyClass`
    type of object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Under these considerations and, after creating the object, the following two
    calls should be equivalent, based on the preceding definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'However, only the first one works as expected, as the second one gives an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: We are seeing the same error we faced with a decorator in [Chapter 5](f5d9c7e4-4092-48de-a22c-564df482b021.xhtml),
    *Using Decorators to Improve Our Code*. The arguments are being shifted to the
    left by one, `instance` is taking the place of `self`, `arg1 `is going to be `instance`,
    and there is nothing to provide for `arg2`.
  prefs: []
  type: TYPE_NORMAL
- en: In order to fix this, we need to make `Method` a descriptor.
  prefs: []
  type: TYPE_NORMAL
- en: 'This way, when we call `instance.method` first, we are going to call its `__get__()`,
    on which we bind this callable to the object accordingly (bypassing the object
    as the first parameter), and then proceed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, both calls work as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: What we did is convert the `function` (actually the callable object we defined
    instead) to a method by using `MethodType` from the `types` module. The first
    parameter of this class should be a callable (`self`*,* in this case, is one by
    definition because it implements `__call__`), and the second one is the object
    to bind this function to.
  prefs: []
  type: TYPE_NORMAL
- en: Something similar to this is what function objects use in Python so they can
    work as methods when they are defined inside a class.
  prefs: []
  type: TYPE_NORMAL
- en: Since this is a very elegant solution, it's worth exploring it to keep it in
    mind as a Pythonic approach when defining our own objects. For instance, if we
    were to define our own callable, it would be a good idea to also make it a descriptor
    so that we can use it in classes as class attributes as well.
  prefs: []
  type: TYPE_NORMAL
- en: Built-in decorators for methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you might have known from looking at the official documentation (PYDESCR-02),
    all `@property`, `@classmethod`, and `@staticmethod` decorators are descriptors.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have mentioned several times that the idiom makes the descriptor return
    itself when it''s being called from a class directly. Since properties are actually
    descriptors, that is the reason why, when we ask it from the class, we don''t
    get the result of computing the property, but the entire `property object` instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: For class methods, the `__get__` function in the descriptor will make sure that
    the class is the first parameter to be passed to the function being decorated,
    regardless of whether it's called from the class directly or from an instance.
    For static methods, it will make sure that no parameters are bound other than
    those defined by the function, namely undoing the binding done by `__get__()`
    on functions that make `self `the first parameter of that function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take an example; we create a `@classproperty` decorator that works as
    the regular `@property` decorator, but for classes instead. With a decorator like
    this one, the following code should be able to work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Slots
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a class defines the `__slots__` attribute, it can contain all the attributes
    that the class expects and no more.
  prefs: []
  type: TYPE_NORMAL
- en: Trying to add extra attributes dynamically to a class that defines `__slots __`will
    result in an `AttributeError`. By defining this attribute, the class becomes static,
    so it will not have a `__dict__` attribute where you can add more objects dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: 'How, then, are its attributes retrieved if not from the dictionary of the object?
    By using descriptors. Each name defined in a slot will have its own descriptor
    that will store the value for retrieval later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: While this is an interesting feature, it has to be used with caution because
    it is taking away the dynamic nature of Python. In general, this ought to be reserved
    only for objects that we know are static, and if we are absolutely sure we are
    not adding any attributes to them dynamically in other parts of the code.
  prefs: []
  type: TYPE_NORMAL
- en: As an upside of this, objects defined with slots use less memory, since they
    only need a fixed set of fields to hold values and not an entire dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing descriptors in decorators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now understand how Python uses descriptors in functions to make them work
    as methods when they are defined inside a class. We have also seen examples of
    cases where we can make decorators work by making them comply with the descriptor
    protocol by using the `__get__()` method of the interface to adapt the decorator
    to the object it is being called with. This solves the problem for our decorators
    in the same way that Python solves the issue of functions as methods in objects.
  prefs: []
  type: TYPE_NORMAL
- en: The general recipe for adapting a decorator in such a way is to implement the
    `__get__()` method on it and use `types.MethodType` to convert the callable (the
    decorator itself) to a method bound to the object it is receiving (the `instance `parameter
    received by `__get__`).
  prefs: []
  type: TYPE_NORMAL
- en: For this to work, we will have to implement the decorator as an object, because
    otherwise, if we are using a function, it will already have a `__get__()` method,
    which will be doing something different that will not work unless we adapt it.
    The cleaner way to proceed is to define a class for the decorator.
  prefs: []
  type: TYPE_NORMAL
- en: Use a decorator class when defining a decorator that we want to apply to class
    methods, and implement the `__get__()` method on it.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Descriptors are a more advanced feature in Python that push the boundaries,
    closer to metaprogramming. One of their most interesting aspects is how they make
    crystal-clear that classes in Python are just regular objects, and, as such, they
    have properties and we can interact with them. Descriptors are, in this sense,
    the most interesting type of attribute a class can have because its protocol facilitates
    more advanced, object-oriented possibilities.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen the mechanics of descriptors, their methods, and how all of this
    fits together, making a more interesting picture of object-oriented software design.
    By understanding descriptors, we were able to create powerful abstractions that
    yield clean and compact classes. We have seen how to fix decorators that we want
    to apply to functions and methods, we have understood a lot more about how Python
    works internally, and how descriptors play such a core and critical role in the
    implementation of the language.
  prefs: []
  type: TYPE_NORMAL
- en: This study of how descriptors are used internally in Python should work as a
    reference to identify good uses of descriptors in our own code, with the goal
    of achieving idiomatic solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Despite all of the powerful options that descriptors represent to our advantage,
    we have to keep in mind when to properly make use of them without over-engineering.
    In this line, we have suggested that we should reserve the functionality of descriptors
    for truly generic cases, such as the design of internal development APIs, libraries,
    or frameworks. Another important consideration along these lines is that, in general,
    we should not place business logic in descriptors, but rather logic that implements
    technical functionality to be used by other components that do contain business
    logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Speaking of advanced functionality, the next chapter also covers an interesting
    and in-depth topic: generators. On the face of it generators are rather simple
    (and most readers are probably already familiar with them), but what they have
    in common with descriptors is that they can also be complex, yield a more advanced
    and elegant design, and make Python a unique language to work with.'
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is a list of a few things you can reference for more information:'
  prefs: []
  type: TYPE_NORMAL
- en: Python's official documentation on descriptors ([https://docs.python.org/3/reference/datamodel.html#implementing-descriptors](https://docs.python.org/3/reference/datamodel.html#implementing-descriptors))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*WEAKREF 01*: Python `weakref` module ([https://docs.python.org/3/library/weakref.html](https://docs.python.org/3/library/weakref.html))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*PYDESCR-02*: Built-in decorators as descriptors ([https://docs.python.org/3/howto/descriptor.html#static-methods-and-class-methods](https://docs.python.org/3/howto/descriptor.html#static-methods-and-class-methods))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
