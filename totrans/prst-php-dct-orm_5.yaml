- en: Chapter 5. Going Further
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In previous chapters we learned the basics of the Doctrine ORM. We are now able
    to create complex domain classes, generate underlying SQL tables, load data fixtures,
    and execute advanced queries. We know everything we need to know to develop the
    model layer of small web applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'The library, however, provides more advanced features. In this chapter we will
    briefly cover various topics not addressed previously: inheritance, lifecycle
    callbacks, and native queries.'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like all object-oriented programming languages, PHP is designed on top of the
    inheritance concept; however, relational databases are not. This is the common
    problem when mapping classes to tables.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Doctrine ORM provides the following three ways to achieve inheritance:'
  prefs: []
  type: TYPE_NORMAL
- en: Mapped Superclasses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Single Table Inheritance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class Table Inheritance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To learn about them, we will create three implementations of the same model,
    that is, for content authors.
  prefs: []
  type: TYPE_NORMAL
- en: Both posts and comments have authors. Authors must have a name and an e-mail
    address. Posts' authors (and only them) can also have an optional biography.
  prefs: []
  type: TYPE_NORMAL
- en: 'To represent this, we will create two classes: `PostAuthor` and `CommentAuthor`.
    They both extend an abstract `Author` class. Each `Comment` entity is linked to
    a `CommentAuthor` class and each `Post` entity to a `PostAuthor` class.'
  prefs: []
  type: TYPE_NORMAL
- en: Using Mapped Superclasses
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Mapped Superclasses are simple PHP classes that share mapped properties used
    by their descendant entities. Mapped Superclasses are not entities themselves.
    They are extended by entities.
  prefs: []
  type: TYPE_NORMAL
- en: Mapped Superclasses are never directly persisted to the database. They are not
    retrievable through the query builder and cannot be the inverse-side of an association.
  prefs: []
  type: TYPE_NORMAL
- en: They are like any other PHP class extended by entities, except that they can
    hold properties that will be persisted by their descendants.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This type of inheritance is not well suited for this use case. Single Table
    Inheritance is better here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by creating the Mapped Superclass. Create a new abstract class called
    `Author` in the `Author.php` file at the location `src/Blog/Entity/`as shown in
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Thanks to the `@MappedSuperclass` annotation, the mapped properties of the `Author`
    class inherited by `PostAuthor` and `CommentAuthor` classes will be taken into
    account by Doctrine.
  prefs: []
  type: TYPE_NORMAL
- en: Write getters for all the properties and setters for all except the `$id` instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At the time of writing, Doctrine Command-Line Tools were not able to generate
    getters and setters for a Mapped Superclass and suffered a bug when generating
    getters and setters for child classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `PostAuthor.php` file in the same directory that contains the `PostAuthor`
    class as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `PostAuthor` entity class extends the `Author` Mapped Superclass. `PostAuthor`
    holds specific data of posts'' authors: a `bio` property and a One-To-Many association
    to posts.'
  prefs: []
  type: TYPE_NORMAL
- en: At the database level, a table called `PostAuthor` will be created with all
    the columns defined with the `@Column` annotation in `Author` and `PostAuthor`
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: Write getters and setters for this class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To make this association work, we need to add the code of the owning-side of
    the association to the `src/Blog/Entity/Post.php` file. To do this, add the following
    property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: You guessed it! Write the getter and setter for the preceding property.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now create a file called `CommentAuthor.php` in the same directory containing
    the `CommentAuthor` entity class as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This entity class is very similar to the `PostAuthor` class, except that its
    association is related to `Comment` instead of `Post`, and it doesn't have a `bio`
    property.
  prefs: []
  type: TYPE_NORMAL
- en: Another table called `CommentAuthor` will be created in the database. This table
    will be completely independent of the `PostAuthor` table.
  prefs: []
  type: TYPE_NORMAL
- en: Write the getter and setter for the same property after adding the preceding
    code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We also need to add the owning-side of the association. Open the `src/Blog/Entity/Comment.php`
    file and add the following properties:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: After you've completed the previous step, add the getter and setter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To understand how this type of inheritance is handled by Doctrine, and to test
    our code, we will create a fixture by inserting sample data in the `src/DataFixtures/LoadAuthorData.php`
    file as shown by the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This fixture creates instances of `Post`, `PostAuthor`, `Comment`, and `CommentAuthor`
    and then persists them to the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the following schema:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The following ER diagram represents the schema that will be generated on using
    MySQL as DBMS:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using Mapped Superclasses](graphics/4104OS_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Even if the `PostAuthor` and `CommentAuthor` classes both inherit from the `Author`
    Mapped Superclass, their corresponding SQL schemas do not share anything and are
    not related.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then load the fixtures with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the SQLite client to show the inserted content in each table with the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'After the preceding steps George''s and my details should appear as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**1|L''homme le plus classe du monde|George Abitbol|gabitbol@example.com**'
  prefs: []
  type: TYPE_NORMAL
- en: '**1|Kévin Dunglas|dunglas@gmail.com**'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For practice, the UI of the author feature is used. An example is provided in
    the bonus code sample available on the Packt website.
  prefs: []
  type: TYPE_NORMAL
- en: Using Single Table Inheritance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With Single Table Inheritance, data of all the classes of the hierarchy will
    be stored in the same database table. A column for every property of every child
    class will be created.
  prefs: []
  type: TYPE_NORMAL
- en: This mapping strategy suits very well for a simple type of hierarchy and performs
    well while querying both the same and different types of entities.
  prefs: []
  type: TYPE_NORMAL
- en: 'To change from Mapped Super Class to Single Table Inheritance, we will just
    make some modifications to the classes we just created:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `src/Blog/Entity/Author.php` file and find the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace the preceding snippet with the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the schema and load the fixtures again with the following queries:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot is the ER diagram for the Single Table Inheritance
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using Single Table Inheritance](graphics/4104OS_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Data of both `PostAuthor` and `CommentAuthor` entities is now persisted in a
    unique database table called `Author`.
  prefs: []
  type: TYPE_NORMAL
- en: The entity type is identified in the table, thanks to a **discriminator column**
    added, and automatically managed, by Doctrine.
  prefs: []
  type: TYPE_NORMAL
- en: By default, this discriminator column is called `dtype` and the Doctrine type
    `string`. These values can be overridden thanks to the `@DiscriminatorColumn`
    annotation. This annotation should be used on the entity class marked with the
    `@InheritanceType` annotation (here, the `Author` class).
  prefs: []
  type: TYPE_NORMAL
- en: 'The value stored in this column is used by Doctrine to determine the type of
    entity class to hydrate for a given database row. It defaults to the name of the
    entity class (not fully qualified) in lowercase. The used value for each entity
    class can also be overridden by adding an annotation on the parent entity class:
    `@DiscriminatorMap`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'All these annotations and the Single Table Inheritance type are documented
    at:'
  prefs: []
  type: TYPE_NORMAL
- en: '`http://docs.doctrine-project.org/en/latest/reference/inheritance-mapping.html#single-table-inheritance`'
  prefs: []
  type: TYPE_NORMAL
- en: 'To look at the data we have inserted in the `Author` table with our fixtures,
    run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The result should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**1|Kévin Dunglas|dunglas@gmail.com|commentauthor|**'
  prefs: []
  type: TYPE_NORMAL
- en: '**2|George Abitbol|gabitbol@example.com|postauthor|L''homme le plus classe
    du monde**'
  prefs: []
  type: TYPE_NORMAL
- en: Using Class Table Inheritance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The last strategy provided by Doctrine is the Class Table Inheritance. Data
    of each class of the hierarchy is stored in a specific database table. All the
    tables of the hierarchy are joined during the data retrieval time.
  prefs: []
  type: TYPE_NORMAL
- en: Because of the massive use of joins, this strategy is less efficient than Single
    Table Inheritance, especially with Big Data. The more descendant classes you add,
    the more joins are needed to retrieve data, and the slower the querying.
  prefs: []
  type: TYPE_NORMAL
- en: But because every entity class of the hierarchy is mapped to its own table,
    this strategy also allows great flexibility. Creating or modifying an entity class
    only affects its directly related database table. In cases where performance is
    not a priority and the data model is complex, this type of inheritance can be
    a solution to limit or avoid complex, and even risky, migrations.
  prefs: []
  type: TYPE_NORMAL
- en: 'As for Single Table Inheritance, we just need to make minor changes to create
    our `Author` data model using Class Table Inheritance with the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `src/Blog/Entity/Author.php` file and find the following `@InheritanceType`
    annotation we added to use Single Table Inheritance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace the argument `SINGLE_TABLE` by the following argument:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the schema and load the fixtures, again with the following query:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The following ER diagram represents the generated schema, again using MySQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using Class Table Inheritance](graphics/4104OS_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `Author` table contains shared data between `PostAuthor` and `CommentAuthor`
    entity classes. These child classes only hold their specific data. Their `id`
    columns are foreign keys referencing the `id` column of the `Author` table. This
    allows data linking because the ID in a table storing data of descendant classes
    is the same as the ID in the table storing data of the top class.
  prefs: []
  type: TYPE_NORMAL
- en: As for Single Table Inheritance, a discriminator column allows Doctrine to identify
    the entity class corresponding to the database table's rows. Their default names
    and values are the same. They can also be overridden through `@DicriminatorColumn`
    and `@DicriminatorMap` annotations on the topmost entity class of the hierarchy
    (here, `Author`).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Class Table Inheritance allows referencing the topmost class of a hierarchy
    in associations, but the loading feature will not work anymore.
  prefs: []
  type: TYPE_NORMAL
- en: For further information about Class Table Inheritance, refer to the documentation
    available at [http://docs.doctrine-project.org/en/latest/reference/inheritance-mapping.html#class-table-inheritance](http://docs.doctrine-project.org/en/latest/reference/inheritance-mapping.html#class-table-inheritance).
  prefs: []
  type: TYPE_NORMAL
- en: 'To show data we have inserted with fixtures in the `Author`, `CommentAuthor`
    and `PostAuthor` tables, run the following query with the SQLite client:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the expected result:'
  prefs: []
  type: TYPE_NORMAL
- en: '**1|Kévin Dunglas|dunglas@gmail.com|commentauthor**'
  prefs: []
  type: TYPE_NORMAL
- en: '**2|George Abitbol|gabitbol@example.com|postauthor**'
  prefs: []
  type: TYPE_NORMAL
- en: '**2|L''homme le plus classe du monde**'
  prefs: []
  type: TYPE_NORMAL
- en: '**1**'
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Doctrine Common component comes with a built-in event system. It allows
    dispatching and subscribing to custom events, but its main purpose is to manage
    entity-related events.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 1](ch01.html "Chapter 1. Getting Started with Doctrine 2"), *Getting
    Started with Doctrine 2*, we learned about entity managers, entity states, and
    Unit Of Work. Entity Managers (and their underlying `UnitOfWork` objects) dispatch
    events when the state of the entity changes and when data is stored, updated,
    and removed from the database. They are called lifecycle events.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Doctrine also emits some events not directly related to the entity lifecycle.
  prefs: []
  type: TYPE_NORMAL
- en: 'Doctrine ORM provides the following bunch of lifecycle events:'
  prefs: []
  type: TYPE_NORMAL
- en: '`preRemove`: This event occurs when the state of the entity is set to `removed`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`postRemove`: This event occurs after the removal of an entity''s data from
    the database'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`prePersist`: This event occurs when the state of the entity passes from `new`
    to `managed`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`postPersist`: This event occurs after the `INSERT` SQL query has been executed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`preUpdate`: This event occurs before the `UPDATE` SQL query'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`postUpdate`: This event occurs after the `UPDATE` SQL query'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`postLoad`: This event occurs after the load or the refresh of the entity in
    the `EntityManager`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The full documentation of events (including the non-lifecycle one) on Doctrine
    ORM is available in the online documentation at [http://docs.doctrine-project.org/en/latest/reference/events.html](http://docs.doctrine-project.org/en/latest/reference/events.html).
  prefs: []
  type: TYPE_NORMAL
- en: Lifecycle callbacks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Lifecycle callbacks are the easiest way to use these events. They allow executing
    methods directly defined in entity classes when the lifecycle event occurs.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our blog, we store the date of the publication of posts and comments. Thanks
    to lifecycle callbacks and to the `prePersist` event, it''s possible to automatically
    set this date the first time an entity is passed through the `persist()` method
    of its Entity Manager (when the state goes from `new` to `managed`):'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `Post.php` file in the `src/Blog/Entity/` folder and the `Comment.php`
    file in the `src/Blog/Entity/` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following use statements to both the files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Add the `@HasLifecycleCallbacks` annotations next to `@Entity` to both the files.
    This enables lifecycle callbacks in these two entity classes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, add the following method to both the files, setting the publication date
    when the `prePersist` event occurs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This method is executed when a `Comment` or `Post` entity is passed through
    the `persist()` method of an entity manager. It sets the `publicationDate` property
    to the current time if it has not been already done.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'These callback methods can take an optional argument, allowing access to the
    `EntityManager` and `UnitOfWork` (giving access to the underlying changeset) objects
    related to the entity which can be referenced at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://docs.doctrine-project.org/en/latest/reference/events.html#lifecycle-callbacks-event-argument](http://docs.doctrine-project.org/en/latest/reference/events.html#lifecycle-callbacks-event-argument)'
  prefs: []
  type: TYPE_NORMAL
- en: Thanks to this tweak, we can remove calls using `setPublicationDate()` methods
    in `web/view-post.php` and `web/edit-post.php`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A popular library you should try is *Gediminas Morkevičius* `DoctrineExtensions`.
    It contains many useful behaviors for Doctrine, including, but not limited to,
    timestamps, translations, soft delete, and nested sets. The Doctrine extensions
    can be found at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/l3pp4rd/DoctrineExtensions](https://github.com/l3pp4rd/DoctrineExtensions)'
  prefs: []
  type: TYPE_NORMAL
- en: Knowing about event listeners and event subscribers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Doctrine provides more powerful ways to deal with events: **event subscribers**
    and **event listeners**. Unlike lifecycle callbacks that are defined directly
    in entity classes, both must be defined in external classes. We will take a quick
    look at them.'
  prefs: []
  type: TYPE_NORMAL
- en: The main difference between listeners and subscribers is that listeners are
    attached to an event, and subscribers register themselves to events.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a listener that will strip some French insults from published
    comments in the `src/Blog/Event/InsultEventListener.php` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'And now, we will create an event subscriber that will send an e-mail to a post
    author when a comment is posted in the `src/Blog/Event/MailAuthorOnCommentEventSubscriber.php`
    file, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Events' listener and subscriber methods' names must match the name of the events
    they want to catch. The entity related to the event and it's entity manager are
    available through the `$args` parameter. In our examples, we only used the entity.
  prefs: []
  type: TYPE_NORMAL
- en: Events' listeners and subscribers are only called when the event they have subscribed
    to is dispatched, whatever the type of entity. It's their responsibility to filter
    entities by type. This is why we use the `instanceof` keyword to check whether
    entities are of the type `Comment`.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike event listeners, event subscribers must implement the `EventSubscriber`
    interface. The `getSubscribedEvents()`method must return an array of events to
    listen to.
  prefs: []
  type: TYPE_NORMAL
- en: The last step is to register these events' listeners and subscribers through
    an Event Manager. Unlike for lifecycle callbacks, this is not handled automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `src/bootstrap.php` file and add the following use statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Then find the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace the preceding line with the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We instantiate an Event Manager, and we register our listener and our subscriber.
    For the listener, we need to tell for which events it should be called. The subscriber
    registers itself to events it is interested in.
  prefs: []
  type: TYPE_NORMAL
- en: The Event Manager object must be linked to the entity manager when it is created;
    this is why it is passed as the third argument of the `EntityManager::create()`
    static method (see [Chapter 1](ch01.html "Chapter 1. Getting Started with Doctrine
    2"), *Getting Started with Doctrine 2*).
  prefs: []
  type: TYPE_NORMAL
- en: Writing native queries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned how to create DQL queries through the `QueryBuilder`.
    But DQL has some limitations (that is, queries cannot contain subqueries in `FROM`
    and `JOIN` clauses), and sometimes you want to use specific features of your DBMS
    (that is, MySQL full-text search). In such cases you need to write native SQL
    queries.
  prefs: []
  type: TYPE_NORMAL
- en: The NativeQuery class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `NativeQuery` class allows you to execute native SQL queries and to get
    their results as Doctrine entities. Only `SELECT` queries are supported.
  prefs: []
  type: TYPE_NORMAL
- en: To experiment with this feature, we will create a new command that displays
    the 100 most recent comments. This can be useful to moderate them.
  prefs: []
  type: TYPE_NORMAL
- en: Create a file containing this new command called `last-comments.php` in the
    `bin/` directory of the app.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The `ResultSetMappingBuilder` class is designed to map SQL query results to
    Doctrine entities. The call to its `addRootEntityFromClassMetadata()` method specifies
    the main entity class that will be hydrated (first parameter) as well as its internal
    alias (second parameter). Here it is `Comment`.
  prefs: []
  type: TYPE_NORMAL
- en: The `addJoinedEntityFromClassMetadata()` method permits you to populate an association
    of the root entity. The first parameter is the entity class. The second is the
    internal alias of this entity. The third is the internal alias of its parent entity.
    The fourth is the name of the relation in its parent entity class. And the last
    is an array of mappings between an entity's properties and SQL query aliases.
  prefs: []
  type: TYPE_NORMAL
- en: This last parameter is useful when SQL column names don't match entity's property
    names. Here, we use it to populate the `id` property of the related post with
    the `post_id` column of the `Comment` table.
  prefs: []
  type: TYPE_NORMAL
- en: Both `Comment` and `Post` database tables have columns called `body`, `publication_date`,
    and `author_id`. To get around this conflict, we map the `Post` entity properties
    respectively to `post_body`, `post_publication_date`, and `post_author_id` columns.
    You noticed that the SQL query doesn't return these columns. This is not a problem;
    they will be ignored.
  prefs: []
  type: TYPE_NORMAL
- en: The `createNativeQuery()` method of the `EntityManager` takes the SQL query
    and the `ResultSetMappingBuilder` as parameters. Like DQL queries, SQL queries
    can use named parameters. They will automatically escape to prevent SQL injection
    attacks.
  prefs: []
  type: TYPE_NORMAL
- en: Thanks to `NativeQuery` and `ResultSetMappingBuilder` classes, the result of
    the query is a collection of `Comment` entities (partially hydrated) with their
    related `Post` entity (having only the `id` property hydrated).
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following code to see the last 100 comments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Doctrine DBAL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Doctrine provides an even lower level way to issue native SQL queries. You can
    retrieve the underlying DBAL connection through the `EntityManager` and use it
    directly.
  prefs: []
  type: TYPE_NORMAL
- en: This is useful to execute native `UPDATE` and `DELETE` queries and to retrieve
    data that is not intended to populate entities. Of course, do that only if you
    have a good reason or use DQL's `SELECT`, `UPDATE`, or `DELETE` queries instead.
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate native queries through DBAL, we will create another command that
    displays some simple stats about our blog.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As they don't use any DBMS-specific query, this command should be executed through
    ORM. Native queries are used here only to illustrate this feature.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file for this new command called `stats.php` in the `bin/` directory
    with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We use the `EntityManager` to retrieve the underlying `Doctrine\DBAL\Connection`
    with the `getConnection()` method. DBAL's `Connection` is just a thin wrapper
    around `PDO` and its API is very similar. We use it to compute the total number
    and the last publication date of posts and comments.
  prefs: []
  type: TYPE_NORMAL
- en: 'To show them, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The last chapter was a quick overview of some advanced features of Doctrine:
    handling Inheritance though Mapped Superclass, Single Table Inheritance, and Class
    Table Inheritance; the Doctrine event system including lifecycle callbacks, listeners,
    and subscribers; and finally how to unleash the power of the underlying DBMS for
    specific use cases with native queries.'
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this book, we have learned how to use the Doctrine ORM to create
    a stable model layer in our PHP applications. We are now familiar with concepts
    behind Doctrine components and we are able to smartly use its ORM. We also looked
    at the most powerful (but also complex) features, including entity managers and
    entity states, mapping information, associations, DQL, hydration, inheritance,
    events, and native queries. There is still a lot to learn, and many of these topics
    deserve a dedicated book of their own.
  prefs: []
  type: TYPE_NORMAL
- en: Again, the online documentation of the Doctrine project (available at [http://www.doctrine-project.org/](http://www.doctrine-project.org/))
    is comprehensive and full of advanced examples.
  prefs: []
  type: TYPE_NORMAL
- en: Recall for the last time that to use Doctrine efficiently in production, a cache
    system (APC, Memcache, and Reddis), depending on your needs and of what is available
    on your server platform, must be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'One last thing, Doctrine is free and open source software welcoming your contributions:
    bug reports and fixes, documentation, and adding new features.'
  prefs: []
  type: TYPE_NORMAL
