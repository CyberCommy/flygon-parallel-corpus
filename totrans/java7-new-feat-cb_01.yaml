- en: Chapter 1. Java Language Improvements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Using string literals in switch statements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using underscores in literals to improve code readability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the try-with-resources block to improve exception handling code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a resource that can be used with the try-with-resources technique
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Catching multiple exception types to improve type checking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Re-throwing exceptions in Java 7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the diamond operator for constructor type inference
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the @SafeVarargs annotation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Java 7** was released in July of 2011 and introduced a number of new features.
    In the Java SDK documentation, you may see it referred to as **Java 1.7.** This
    chapter will focus on those that have been grouped as part of the Project Coin
    ([http://openjdk.java.net/projects/coin/](http://openjdk.java.net/projects/coin/)).
    **Project Coin** refers to the small language changes in Java 7 that are designed
    to make programs more readable by removing extra text when possible. The changes
    to the language do not involve modifying the **Java Virtual Machine** (**JVM**).
    These new features include:'
  prefs: []
  type: TYPE_NORMAL
- en: The use of strings in switch statements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The addition of binary literals and the ability to insert underscores into numeric
    literals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The use of a multi-catch block
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The try-with-resources block
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improved type inferences using the diamond operator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improvements in the use of methods with a variable number of arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since the inception of Java, only integer values could be used to control a
    switch statement. Strings can now be used and can provide a more convenient technique
    for controlling the execution flow that is based on a string. The *Using string
    literals in switch statements* recipe illustrates this feature.
  prefs: []
  type: TYPE_NORMAL
- en: Underscores can now be used with literals as examined in the recipe *Using underscores
    in literals to improve code readability*. These can make a program more readable
    and maintainable. In addition, binary literals can now be used. Instead of using
    a hexadecimal literal, for example, the literal bit pattern can be used.
  prefs: []
  type: TYPE_NORMAL
- en: New to Java 7 are the improved try-catch block mechanisms. These include the
    ability to catch more than one exception from a single catch block, and improvements
    in how exceptions can be thrown. The *Catching multiple exception types to improve
    type checking* recipe looks into these enhancements.
  prefs: []
  type: TYPE_NORMAL
- en: Another improvement in exception handling involves the automatic closure of
    resources. In earlier versions of Java, when multiple resources were opened in
    a try block, it could be difficult to effectively close the resources, when an
    exception occurs. Java 7 provides a new technique as discussed in the *Using the
    try-with-resources block to improve exception handling code* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'To take advantage of this technique, a class representing a resource must implement
    the new `java.lang.AutoCloseable` interface. This interface consists of a single
    method, `close` which, when implemented, should release resources as needed. Many
    core Java classes have been augmented to do this. The recipe: *Creating a resource
    that can be used with the try-with-resources technique* illustrates how to do
    this for non-core classes.'
  prefs: []
  type: TYPE_NORMAL
- en: Java 7 provides the capability to re-throw exceptions in a flexible manner.
    It provides a more precise way of throwing exceptions, and more flexibility in
    how they can be handled in a try/catch bock. The *Re-throwing exceptions in Java
    7* recipe illustrates this capability.
  prefs: []
  type: TYPE_NORMAL
- en: When generics were introduced in **Java 1.5**, it became easier to write code
    to address a number of similar problems. However, its usage at times could become
    somewhat verbose. The introduction of the `diamond` operator has eased this burden,
    and is illustrated in the *Using the diamond operator for constructor type inference*
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: When a method uses a variable number of generic arguments, sometimes an invalid
    warning is generated. The `@SafeVarargs` annotation has been introduced to flag
    a method as safe. This issue is related to heap pollution and is discussed in
    the *Using the @SafeVarargs Annotation* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this and the other chapters, most of the code examples will be written to
    execute from within a main method. While no specific **Integrated Development
    Environment** (**IDE**) is needed to use the new features of Java 7, the examples
    in this book were developed using **NetBeans 7.0.1** and **Windows 7**, unless
    otherwise noted. At minimum, a version of the **Java Development Kit** (**JDK**)
    **1.7** or later is needed.
  prefs: []
  type: TYPE_NORMAL
- en: Also, note that the code examples provided do not include `import` statements.
    These are not shown here to reduce the number of lines of code. Most IDEs make
    it easy to insert these imports, but you need to be careful that the correct imports
    are used.
  prefs: []
  type: TYPE_NORMAL
- en: Using string literals in switch statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The ability to use string literals in switch statements is new to Java 7\. Previously,
    only integer values were the valid arguments in a `switch` statement. It is not
    uncommon to need to make a decision based on a string value, and the use of a
    `switch` statement to perform this task can simplify the series of `if` statements
    that would otherwise be needed. This can result in more readable and efficient
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A selection based on a string value may occur in an application. Once such
    a situation is identified, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `String` variable to be processed via the `switch` statement.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the `switch` block, using string literals for the case clauses.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `String` variable to control the `switch` statement.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The example demonstrated here will use a `switch` statement to process an application's
    command line arguments. Create a new console application. In the `main` method,
    we will use the `args` argument to process the application's command line arguments.
    Many applications allow command line arguments to customize or otherwise affect
    the operation of the application. In this example, our application will support
    a verbose mode, logging, and provide a help message regarding the valid command
    line arguments for the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, create a class called `StringSwitchExample` that possesses
    three instance variables to be set by the command line arguments, shown as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Downloading the example code**'
  prefs: []
  type: TYPE_NORMAL
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add the following `main` method, which will set these variables based
    on the command line arguments provided:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following helper method to display the application setting:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the application using the following command line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: If you are using an IDE, then there is usually a way to set the command line
    arguments. For example, in NetBeans, right-clicking on the project name in the
    **Project** window, and selecting **Properties** menu will open a **Project Properties**
    dialog box. In the **Run** category, the **Arguments** textbox allows you to set
    the command line arguments, as shown in the following screenshot:![How to do it...](img/5627_1_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When the application is executed, your output should appear as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Application Settings**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Verbose: true**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Logging: true**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Help: false**'
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The application setting variables are all initialized to `false`. A for-each
    loop iterates through each command line argument. The `switch` statement uses
    a specific command line argument to turn on an application setting. The `switch`
    statement behaves like the earlier Java `switch` statements.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is interesting to note that the Java Virtual Machine (JVM) currently provides
    no direct support for switching with strings. The Java compiler is responsible
    for converting strings in `switch` statements to the appropriate byte code.
  prefs: []
  type: TYPE_NORMAL
- en: When the for loop completes, the `displayApplicationSettings` method is invoked.
    This displays the current application setting, reflecting the configuration specified
    by the command line arguments.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note, however, while a `String` variable may be passed to
    the `switch` statements, as with the other data types used in `switch` statements,
    the strings used in the case clauses must be string literals. The general rules
    regarding `switch` statements apply when using string literals. Each statement
    within the `switch` block must have a valid non-null label, no two labels may
    be identical, and only one default label may be associated with each `switch`
    block.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When using strings, you need to be careful about the following two issues:'
  prefs: []
  type: TYPE_NORMAL
- en: Null values for strings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The case of the string
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using a string reference variable that is assigned a null value will result
    in a `java.lang.NullPointerException`. See the *Handling null references* recipe
    in [Chapter 11](ch11.html "Chapter 11. Odds and Ends"), *Odds and Ends*, for more
    information on how to handle a `NullPointerException`. This is also true when
    used with a `switch` statement. Also, the evaluation of a case expression is case
    sensitive in a `switch` statement. In the previous example, if the command line
    argument is different from what appears in the case expression, then the case
    is skipped. If we had used the following command line instead, where we capitalized
    the word verbose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Then the verbose mode will no longer be used as indicated in the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Application Settings**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Verbose: false**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Logging: true**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Help: false**'
  prefs: []
  type: TYPE_NORMAL
- en: Using underscores in literals to improve code readability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Numerical literals can contain underscore characters (_) in Java 7\. This is
    intended to improve the readability of code by separating digits of a literal
    into significant groups at almost any arbitrary place that meets the needs of
    the developer. The underscore can be applied to primitive data types in any supported
    base (binary, octal, hexadecimal, or decimal), and to both integer and floating-point
    literals.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first step is to identify instances where it will be beneficial for the
    developer to format literals in such a manner. Typically, you will want to identify
    longer numbers or numbers that would have significant parts in their external
    form, such as debit card numbers. The basic steps include:'
  prefs: []
  type: TYPE_NORMAL
- en: Identify a literal to use with underscores.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Insert underscores at appropriate places within the literal to make the literal
    more readable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This example illustrates using underscores to clarify the inherent gaps found
    in most debit card numbers, and demonstrates their use with floating point numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new console application and add the `main` method as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a method to display the credit card number properly formatted for output,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the application. The output will appear as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**The card number is: 1234567898765432**'
  prefs: []
  type: TYPE_NORMAL
- en: '**The formatted card number is: 1234 5678 9876 5432**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Minimum amount limit exceeded 5000.0**'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that in the first output line the displayed number does not contain underscores,
    but our second line is formatted to use spaces where the underscores were. This
    is to illustrate the difference between how the number looks internally, and how
    it needs to be formatted for external display.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The debit card example partitioned the number into four sections making it more
    readable. A `long` variable was needed due to the length of the debit card number.
  prefs: []
  type: TYPE_NORMAL
- en: Next, a minimum limit was placed on the amount of money in a bank account. The
    variable `minAmount` of type `float` was set to 5,000.00 using the underscores
    to denote the location of the comma. Two more `float` called `currentAmount` and
    `withdrawalAmount` were declared and set equal to 5,250.00 and 500.00, respectively.
    The code then determined whether the `withdrawalAmount` could be subtracted from
    the `currentAmount` and still maintain a balance above the `minAmount`. If not,
    a message to that effect was displayed.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In most applications involving currency, the `java.util.Currency` class would
    be a more appropriate choice. The previous example used floating point literals
    only to explain the usage of underscores.
  prefs: []
  type: TYPE_NORMAL
- en: The only purpose of the underscore is to make the code more readable to the
    developer. The compiler ignores the underscores during code generation and during
    any subsequent variable manipulation. Consecutive underscores are treated as one
    and also ignored by the compiler. If the output format of a variable is important,
    it will have to be handled separately.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Underscores can be used for more than base 10 literals. In addition, underscores
    can be misused. Here, we will address the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Simple underscore usage mistakes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using underscores with hexadecimal literals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using underscores with binary literals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simple underscore usage mistakes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Underscores may generally be placed arbitrarily within the literals, but there
    are guidelines limiting their use. It is invalid to place underscores at the beginning
    or end of a number, adjacent to a decimal point when used in a `float` or `double`,
    prior to the D, F, or L suffix, or where a string of digits is required.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the examples of invalid underscore usages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'These will generate the syntax error, **error: illegal underscore**.'
  prefs: []
  type: TYPE_NORMAL
- en: Using underscores with hexadecimal literals
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Underscores can be particularly useful when dealing with binary data expressed
    in hexadecimal or binary. In the following example, an integer value representing
    a command to be sent to a data port was expressed as a hexadecimal and as a binary
    literal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: These two numbers are the same. They are only expressed in different bases.
    Here, we used base 2 and base 16\. The base 16 representation may be more readable
    in this example. Base 2 literals will be discussed in more depth in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: The underscores were used to more clearly identify parts of the command. The
    assumption is that the first four bits of the command represent an operator, while
    the next 16 bits are an operand. The next 8 bits and 4 bits could represent other
    aspects of the command.
  prefs: []
  type: TYPE_NORMAL
- en: Using underscores with binary literals
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can also use underscores with binary literals. For example, to initialize
    a device we may need to send a specific 8 bit sequence to the data port. This
    sequence may be organized such that the first two bits specify the operation (read,
    write, and so on), the next three bits may specify a device resource, and the
    last three bits could represent an operand. We may encode this sequence using
    a binary literal with underscores as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Use of the underscores clearly identifies each field. While it is not necessary
    to use the variable `initializationSequence`, it allows us to use the sequence
    in more than one place in a program. Another example defines a mask where, in
    this case, the first three bits are eliminated during an **AND** operation as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In a bitwise AND operation, each bit of the operands are Anded with each other.
    These examples are illustrated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'When this sequence is executed, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '**initializationSequence: 1110010**'
  prefs: []
  type: TYPE_NORMAL
- en: '**result: 11011**'
  prefs: []
  type: TYPE_NORMAL
- en: The byte cast operator was needed because binary literals default to type `int`.
    Also, notice that the `toBinaryString` method does not display leading zeroes.
  prefs: []
  type: TYPE_NORMAL
- en: Using the try-with-resources block to improve exception handling code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Prior to Java 7, the code required for properly opening and closing resources,
    such as a `java.io.InputStream` or `java.nio.Channel`, was quite verbose and prone
    to errors. The try-with-resources block has been added in an effort to simplify
    error-handling and make the code more concise. The use of the try-with-resources
    statement results in all of its resources being automatically closed when the
    try block exits. Resources declared with the try-with-resources block must implement
    the interface `java.lang.AutoCloseable`.
  prefs: []
  type: TYPE_NORMAL
- en: This approach enables a better programming style as it avoids nested and excessive
    try-catch blocks. It also ensures accurate resource management, which you may
    see referred to as **Automated Resource Management** (**ARM**) in literature.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When working with resources that need to be opened and closed, the `try-with-resource`
    block is implemented by:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the try block and declaring the resources to be managed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the resource within the try block.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a console application and add the following `main` method to it. Create
    a text file in the working directory called `users.txt` and add a list of names
    to the file. This example opens up that file and creates a backup, while demonstrating
    the use of the `try-with-resources` technique, where a `java.io.BufferedReader`
    and `java.io.BufferedWriter` objects are created with the try block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the application. The output should be as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Copy complete!**'
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The resources to be managed are declared and initialized inside a set of parentheses
    between the `try` keyword and the opening curly brace of the try block. In this
    case, two resources are created. The first is a `BufferedReader` object associated
    with the `users.txt` file and the second is a `BufferedWriter` object associated
    with the `users.bak` file. The new IO techniques using the `java.nio.file.Path`
    interface are discussed in [Chapter 6](ch06.html "Chapter 6. Stream IO in Java
    7"), *Stream IO in Java 7*.
  prefs: []
  type: TYPE_NORMAL
- en: The first file is then read line by line and written to the second file. When
    the try block is exited, the two IO streams are automatically closed. A message
    is then displayed showing that the copy operation is complete.
  prefs: []
  type: TYPE_NORMAL
- en: Notice the use of the vertical bar in the catch block. This is new to Java 7
    and allows us to catch multiple exceptions in a single catch block. The use of
    this operator is discussed in the *Catching multiple exception types to improve
    type checking* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Bear in mind that the resources declared with a try-with-resources block are
    separated by semicolons. Failure to do so will result in a compile-time error.
    Also, resources will be attempted to be closed, regardless of whether the try
    block completes normally or not. If the resource cannot be closed, an exception
    is normally thrown.
  prefs: []
  type: TYPE_NORMAL
- en: Regardless of whether resources are closed or not, the catch and finally blocks
    are always executed. However, exceptions can still be thrown from these blocks.
    This is discussed in more detail in the *Creating a resource that can be used
    with the try-with-resources technique* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To complete our understanding of the `try-with-resources` technique, we need
    to address two other topics as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding suppressed exceptions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Structuring issues when using the `try-with-resources` technique
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding suppressed exceptions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In support of this approach, a new constructor was added to the `java.lang.Exception`
    class along with two methods: `addSuppressed` and `getSuppressed`. Suppressed
    exceptions are those exceptions that are not explicitly reported. In the case
    of the try-with-resources try block, exceptions may be thrown from the try block
    itself or when the resources created by the try block are closed. When more than
    one exception is thrown, exceptions may be suppressed.'
  prefs: []
  type: TYPE_NORMAL
- en: In the case of the try-with-resources block, any exceptions associated with
    a close operation are suppressed when an exception is thrown from the block itself.
    This is demonstrated in the *Creating a resource that can be used with the try-with-resources
    technique* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Suppressed exceptions can be retrieved using the `getSuppressed` method. Programmer
    created exceptions can designate an exception as suppressed by using the `addSuppressed`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Structuring issues when using the try-with-resources technique
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It may not be desirable to use this technique when a single resource is used.
    We will show three different implementations of a sequence of code to display
    the contents of the `users.txt` file. The first, as shown in the following code,
    uses the try-with-resources block. However, it is necessary to precede this block
    with a try block to capture the `java.net.URISyntaxException:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This example is predicated upon the need to catch the `URISyntaxException`.
    This can be avoided by creating the `java.net.URI` object inside of the `get`
    method as shown below. However, it does make the code harder to read:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice the use of the multiple catch block as discussed in the *Catching multiple
    exception types to improve type checking* recipe. Another approach is to avoid
    the `URI` object altogether by using the `get` method with a `String` argument
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The methods that are used and the structure of the code affect the readability
    and maintainability of the code. It may or may not be feasible to eliminate the
    use of the `URI` object, or similar objects, in a code sequence. However, careful
    consideration of alternative approaches can go a long way to improving an application.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Catching multiple exception types to improve type checking* recipe and
    *Creating a resource that can be used with the try-with-resources technique* recipe
    provide further coverage of the exception handling in Java 7.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a resource that can be used with the try-with-resources technique
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many resources in Java libraries, which can be used as part of the
    `try-with-resource` technique. However, there may be times when you may wish to
    create your own resources that can be used with this technique. An example of
    how to do this is illustrated in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create a resource that can be used with the `try-with-resources` technique:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a class that implements the `java.lang.AutoCloseable` interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Override the `close` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement resource-specific methods.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Any objects created with the try-with-resources block must implement the `AutoCloseable`
    interface. This interface has a single method, that is, `close`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here, we will illustrate this approach by creating three classes:'
  prefs: []
  type: TYPE_NORMAL
- en: One class that contains the `main` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two classes that implement the `AutoCloseable` interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Create two classes called `FirstAutoCloseableResource` and `SecondAutoCloseableResource`.
    Within these classes, implement a `manipulateResource` and `close` method, shown
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, add the following code to a `main` method. We use the `try-with-resources`
    technique with the two resources, and then call their `manipulateResource` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'When the code executes, the `close` methods throw an `UnsupportedOperationException`
    shown as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**FirstAutoCloseableResource manipulateResource method executed**'
  prefs: []
  type: TYPE_NORMAL
- en: '**SecondAutoCloseableResource manipulateResource method executed**'
  prefs: []
  type: TYPE_NORMAL
- en: '**SecondAutoCloseableResource close method executed**'
  prefs: []
  type: TYPE_NORMAL
- en: '**FirstAutoCloseableResource close method executed**'
  prefs: []
  type: TYPE_NORMAL
- en: '**java.lang.UnsupportedOperationException: A problem has occurred in SecondAutoCloseableResource**'
  prefs: []
  type: TYPE_NORMAL
- en: '**at packt.SecondAutoCloseableResource.close(SecondAutoCloseableResource.java:9)**'
  prefs: []
  type: TYPE_NORMAL
- en: '**at packt.TryWithResourcesExample.displayAutoCloseableExample(TryWithResourcesExample.java:30)**'
  prefs: []
  type: TYPE_NORMAL
- en: '**at packt.TryWithResourcesExample.main(TryWithResourcesExample.java:22)**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Suppressed: java.lang.UnsupportedOperationException: A problem has occurred
    in FirstAutoCloseableResource**'
  prefs: []
  type: TYPE_NORMAL
- en: '**at packt.FirstAutoCloseableResource.close(FirstAutoCloseableResource.java:9)**'
  prefs: []
  type: TYPE_NORMAL
- en: '**... 2 more**'
  prefs: []
  type: TYPE_NORMAL
- en: '**java.lang.UnsupportedOperationException: A problem has occurred in FirstAutoCloseableResource**'
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Within the resource classes, the `manipulateResource` methods were created to
    perform some resource-specific operation. The resource classes were declared as
    part of the try block, and the `manipulateResource` methods were called. This
    was illustrated in the first part of the output. The output has been highlighted
    to clarify the process.
  prefs: []
  type: TYPE_NORMAL
- en: When the try block terminated, the `close` methods were executed. They were
    executed in an opposite order than expected. This is the result of how the application
    program stack works.
  prefs: []
  type: TYPE_NORMAL
- en: Within the catch block, the stack was dumped. In addition, we used the `getSuppressed`
    method to return and display the suppressed methods. Support for suppressed exceptions
    was introduced in Java 7\. These types of exceptions are discussed in the *Using
    the try-with-resource block to improve exception handling code* recipe and later
    on in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Within the `close` method, one of the following three actions is possible:'
  prefs: []
  type: TYPE_NORMAL
- en: Do nothing if there is nothing to close or the resource will always close
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Close the resource and return without error
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attempt to close the resource, but throw an exception upon failure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first two conditions are easy enough to handle. In the case of the last
    one, there are a few things to bear in mind.
  prefs: []
  type: TYPE_NORMAL
- en: Always implement the `close` method and supply specific exceptions. This provides
    the user with more meaningful feedback concerning the underlying problem. Also,
    do not throw an `InterruptedException`. Runtime problems can occur if the `InterruptedException`
    has been suppressed.
  prefs: []
  type: TYPE_NORMAL
- en: The `close` method is not required to be idempotent. An **idempotent** method
    is the one where repeated execution of the method will not cause problems. As
    an example, reading from the same file twice will not necessarily cause problems.
    Whereas, writing the same data twice to the file may. The `close` method does
    not have to be idempotent, however, it is recommended that it should be.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Using the try-with-resources block to improve exception handling code*
    recipe covers the use of this type of try block.
  prefs: []
  type: TYPE_NORMAL
- en: Catching multiple exception types to improve type checking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Within a try block, multiple exceptions can be generated and thrown. A corresponding
    series of catch blocks are used to capture and then deal with the exceptions.
    Frequently, the action needed to deal with one exception is the same for other
    exceptions. An example of this is when the logging of an exception is performed.
  prefs: []
  type: TYPE_NORMAL
- en: In Java 7, it is now possible to handle more than one exception from within
    a single catch block. This ability can reduce the duplication of code. In earlier
    versions of Java, there was often a temptation to address this issue by catching
    a higher-level exception class and handling multiple exceptions from that block.
    There is less need for this approach now.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using a single catch block to capture multiple exceptions is achieved by:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding a catch block
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Including multiple exceptions within the catch blocks' parentheses, separated
    by a vertical bar
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, we wish to deal with invalid input from the user by logging
    an exception. This is a simple approach that will suffice to explain how multiple
    exceptions can be handled.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an application with two classes: `MultipleExceptions` and `InvalidParameter`.
    The `InvalidParameter` class is used to handle invalid user input, and the `MultipleExceptions`
    class contains the `main` method and example code.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the `InvalidParameter` class as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create the `MultipleExceptions` class with a `java.util.logging.Logger`
    object as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the program using a variety of input. Using a valid number, such as
    **12**, results in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Enter a number: 12**'
  prefs: []
  type: TYPE_NORMAL
- en: '**The number is: 12**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using invalid input like a non-numeric value, such as **cat**, or a negative
    number, such as **-5**, will result in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Enter a number: cat**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Invalid input, try again**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Aug 28, 2011 1:48:59 PM packt.MultipleExceptions main**'
  prefs: []
  type: TYPE_NORMAL
- en: '**INFO: Invalid input, try again**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Enter a number: -5**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Invalid input, try again**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Aug 28, 2011 1:49:20 PM packt.MultipleExceptions main**'
  prefs: []
  type: TYPE_NORMAL
- en: '**INFO: Invalid input, try again**'
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The logger was created and when an exception occurred, an entry was made in
    the logger file. The output created by using NetBeans also displayed these log
    messages as they occur.
  prefs: []
  type: TYPE_NORMAL
- en: When an exception was thrown, the catch block was entered. Notice that the two
    exceptions of interest here, `java.util.InputMismatchException` and `InvalidParameter`,
    occur within the same catch statement and are separated with a vertical bar. Also,
    notice that there is only a single variable, `e`, used to represent the exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'This approach is useful when we need to handle a few specific exceptions, and
    need to handle them in the same way. When a catch block handles more than one
    exception, the catch block parameter is implicitly final. This means that it is
    not possible to assign new values to the parameter. The following is illegal and
    its use will result in a syntax error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Besides being more readable and concise than using multiple catch blocks, the
    generated bytecode is also smaller and does not result in the generation of duplicate
    code.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The base class or classes of a set of exceptions impact when to use a catch
    block to capture multiple exceptions. Also, assertions are useful in creating
    robust applications. These issues are addressed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The use of a common exception base class and the `java.lang.ReflectiveOperationException`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `java.lang.AssertionError` class in Java 7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The use of a common exception base class and the ReflectiveOperationException
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Catching multiple exceptions in the same catch block is useful when different
    exceptions need to be handled in the same way. However, if the multiple exceptions
    share a common base exception class, then it may be simpler to catch the base
    class exception instead. This is the case with many `IOException` derived classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the `Files` class'' `delete` method may throw one of the following
    four different exceptions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`java.nio.file.NoSuchFileException`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.nio.file.DirectoryNotEmptyException`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.io.IOException`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.lang.SecurityException`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Of these, `NoSuchFileException` and `DirectoryNotEmptyException` are ultimately
    derived from `IOException`. Thus, catching the `IOException` may be sufficient
    as illustrated in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In this example, notice that a `URISyntaxException` exception is potentially
    thrown by the `URI` constructor. The recipe *Deleting a file or directory*, in
    [Chapter 4](ch04.html "Chapter 4. Managing Files and Directories"), *Managing
    Files and Directories*, details the use of the `delete` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Java 7, a new exception, `ReflectiveOperationException`, has been added
    to the `java.lang` package. It is the base class for the following exceptions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ClassNotFoundException`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IllegalAccessException`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`InstantiationException`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`InvocationTargetException`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NoSuchFieldException`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NoSuchMethodException`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This exception class can ease the handling of reflection type exceptions. The
    use of the multiple exceptions catching mechanism is more appropriate for those
    sets of exceptions which have no common base class.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As a general rule, it is better to catch the exception that is as specific to
    the problem as possible. For example, it is better to catch a `NoSuchFileException`
    as opposed to the more broad `Exception`, when dealing with a missing file. This
    provides more detail about the exception.
  prefs: []
  type: TYPE_NORMAL
- en: Using the AssertionError class in Java 7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Assertions are useful in building an application that is more robust. A good
    introduction to this topic can be found at [http://download.oracle.com/javase/1.4.2/docs/guide/lang/assert.html](http://download.oracle.com/javase/1.4.2/docs/guide/lang/assert.html).
    In Java 7, a new constructor was added that allows a message to be attached to
    a user-generated assertion error. This constructor has two arguments. The first
    is the message to be associated with the `AssertionError` and the second is a
    `Throwable` clause.
  prefs: []
  type: TYPE_NORMAL
- en: In the `MultipleExceptions` class developed earlier in this recipe, we tested
    to see if the number was less than zero, and if so we threw an exception. Here,
    we will illustrate the use of the `AssertionError` constructor by throwing an
    `AssertionError`, if the number is greater than 10.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to the `main` method near the original test of the number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the program and enter **12** again. Your results should be similar
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Enter a number: 12**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exception in thread "main" java.lang.AssertionError: Number was too big**'
  prefs: []
  type: TYPE_NORMAL
- en: '**at packt.MultipleExceptions.main(MultipleExceptions.java:28)**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Caused by: java.lang.Throwable: Throwable assertion message**'
  prefs: []
  type: TYPE_NORMAL
- en: '**... 1 more**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Java Result: 1**'
  prefs: []
  type: TYPE_NORMAL
- en: Prior to Java 7, it was not possible to associate a message with a user-generated
    `AssertionError`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The use of the `Files` class is detailed in [Chapter 4](ch04.html "Chapter 4. Managing
    Files and Directories"), *Managing Files and Directories*.
  prefs: []
  type: TYPE_NORMAL
- en: Rethrowing exceptions in Java 7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When an exception is caught in a catch block, it is sometimes desirable to rethrow
    the exception. This allows the exception to be processed by the current method
    and methods that called the current method.
  prefs: []
  type: TYPE_NORMAL
- en: However, prior to Java 7 only a base class exception could be rethrown. When
    more than one exception needed to be rethrown, you were restricted to declaring
    a common base class in the method declaration. Now, it is possible to be more
    restrictive on the exceptions which can be thrown for a method.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to rethrow exceptions in Java, you must first catch them. From within
    the catch block, use the `throw` keyword with the exception to be thrown. The
    new rethrow technique in Java 7 requires that you:'
  prefs: []
  type: TYPE_NORMAL
- en: Use a base class exception class in the catch block
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the `throw` keyword to throw the derived class exception from the catch
    block
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modify the method's signature to throw the derived exceptions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will modify the `ReflectiveOperationExceptionExample` class developed in
    the *Catching multiple exception types to improve type checking* recipe. Modify
    the `main` method to call the `deleteFile` method in the try block, as shown in
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the `deleteFile` method, shown as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the application using a file that does not exist. The output should
    be as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**java.nio.file.NoSuchFileException**'
  prefs: []
  type: TYPE_NORMAL
- en: '**at packt.ReflectiveOperationExceptionExample.deleteFile(ReflectiveOperationExceptionExample.java:33)**'
  prefs: []
  type: TYPE_NORMAL
- en: '**at packt.ReflectiveOperationExceptionExample.main(ReflectiveOperationExceptionExample.java:16)**'
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `main` method called and handled exceptions generated by the `deleteFile`
    call. The method declared that it can throw a `NoSuchFileException` and a `DirectoryNotEmptyException`.
    Notice that the base class, `IOException`, was used to catch exceptions. Within
    the catch block, a test was made to determine what caused the exception, using
    the `File` class' `isDirectory` method. Once the root cause of the exception was
    determined, the appropriate exception was thrown. The use of the `Files` class
    is detailed in [Chapter 4](ch04.html "Chapter 4. Managing Files and Directories"),
    *Managing Files and Directories*.
  prefs: []
  type: TYPE_NORMAL
- en: By specifying precisely which exceptions can be thrown by the method, we can
    be clear about what callers of the method can expect. In addition, it prevents
    the inadvertent throwing of other `IOException` derived exceptions from the method.
    The drawback of this example is that if another exception, such as a `FileSystemException`,
    is the root cause, then we will have missed it. It will be caught in the `deleteFile`
    method, since it is derived from the `IOException`. However, we have failed to
    handle it in the method or pass it to the calling method.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The previous three recipes provide additional coverage of exception handling
    in Java 7.
  prefs: []
  type: TYPE_NORMAL
- en: Using the diamond operator for constructor type inference
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The use of the diamond operator simplifies the use of generics when creating
    an object. It avoids unchecked warnings in a program, and it reduces generic verbosity
    by not requiring explicit duplicate specification of parameter types. Instead,
    the compiler infers the type. Dynamically-typed languages do this all the time.
    While Java is statically typed, the use of the diamond operator allows more inferences
    than before. There is no difference in the resulting compiled code.
  prefs: []
  type: TYPE_NORMAL
- en: The compiler will infer the parameter types for the constructors. This is an
    example of the convention over configuration ([http://en.wikipedia.org/wiki/Convention_over_configuration](http://en.wikipedia.org/wiki/Convention_over_configuration)).
    By letting the compiler infer the parameter type (convention), we avoid explicit
    specification (configuration) of the object. Java also uses annotations in many
    areas to affect this approach. Type inference is now available, whereas it was
    only available for methods before.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To use the diamond operator:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a generic declaration of an object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the diamond operator,`<>`, to specify the type inference that is to be used.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a simple Java application with a `main` method. Add the following code
    example to the `main` method to see how they work. For example, to declare a `java.util.List`
    of strings, we can use the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The identifier, `list`, is declared as a list of strings. The diamond operator,`<>`,
    is used to infer the `List` type as `String`. No warnings are generated for this
    code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When an object is created without specifying the data type, it is called a raw
    type. For example, the following uses a raw type when instantiating the identifier,
    `list:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'When the code is compiled, the following warnings are generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Note: packt\Bin.java uses unchecked or unsafe operations**.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Note: Recompile with -Xlint:unchecked for details**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'An unchecked warning is generated. It is generally desirable to eliminate unchecked
    warnings in an application. When the **—Xlint:unchecked** is used we get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**packt\Bin.java:26: warning: [unchecked] unchecked conversion**'
  prefs: []
  type: TYPE_NORMAL
- en: '**List<String> arrayList = new ArrayList()**;'
  prefs: []
  type: TYPE_NORMAL
- en: '**^**'
  prefs: []
  type: TYPE_NORMAL
- en: '**required: List<String>**'
  prefs: []
  type: TYPE_NORMAL
- en: '**found: ArrayList**'
  prefs: []
  type: TYPE_NORMAL
- en: '**1 warning**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before Java 7, we could address this warning by explicitly using a parameter
    type as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'With Java 7, the diamond operator makes this shorter and simpler. This operator
    becomes even more useful with more complex data types, such as, a `List` of `Map`
    objects as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are several other aspects of type inference that should be discussed:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the diamond operator when the type is not obvious
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Suppressing unchecked warnings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding erasure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the diamond operator when the type is not obvious
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Type inference is supported in Java 7 and later, only if the parameter type
    for the constructor is obvious. For example, if we use the diamond operator without
    specifying a type for the identifier shown as follows, we will get a series of
    warnings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Compiling the program with **—Xlint:unchecked**, results in the following warnings:'
  prefs: []
  type: TYPE_NORMAL
- en: '**... packt\Bin.java:29: warning: [unchecked] unchecked call to add(E) as a
    member of the raw type ArrayList**'
  prefs: []
  type: TYPE_NORMAL
- en: '**arrayList.add("First")**;'
  prefs: []
  type: TYPE_NORMAL
- en: '**where E is a type-variable:**'
  prefs: []
  type: TYPE_NORMAL
- en: '**E extends Object declared in class ArrayList**'
  prefs: []
  type: TYPE_NORMAL
- en: '**... \packt\Bin.java:30: warning: [unchecked] unchecked call to add(E) as
    a member of the raw type ArrayList**'
  prefs: []
  type: TYPE_NORMAL
- en: '**arrayList.add("Second")**;'
  prefs: []
  type: TYPE_NORMAL
- en: '**where E is a type-variable:**'
  prefs: []
  type: TYPE_NORMAL
- en: '**E extends Object declared in class ArrayList**'
  prefs: []
  type: TYPE_NORMAL
- en: '**2 warnings**'
  prefs: []
  type: TYPE_NORMAL
- en: 'These warnings will go away if the data type is specified as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Suppressing unchecked warnings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'While not necessarily desirable, it is possible to use the `@SuppressWarnings`
    annotation to suppress unchecked exceptions generated by the failure to use the
    diamond operator. The following is an example of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Understanding erasure
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Erasure occurs when generics are used. The data type used in the declaration
    is not available at run-time. This language design decision was made when Java
    1.5 introduced generics, to make the code backwards compatible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following three methods. They differ only in the declaration of
    the `arrayList` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: When these methods are compiled, the type information available at compile-time
    is lost. If we examine the compiled bytecode for these three methods, we will
    find that there is no difference between them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the following command will display the byte codes for the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The generated code is identical for these three methods. The code for the `useImplicitType`
    is shown as follows. It is identical to the other two methods;
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Using the @SafeVarargs annotation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `@SafeVarargs` and `@SuppressWarnings` annotations can be used to deal with
    various warnings that are normally harmless. The `@SuppressWarnings` annotation,
    as its name implies, will suppress specific types of warnings.
  prefs: []
  type: TYPE_NORMAL
- en: The `@SafeVarargs` annotation, introduced in Java 7, is used to designate certain
    methods and constructors that use a variable number of arguments as safe. Methods
    can be passed with a variable number of arguments. These arguments may be generics.
    If they are, then it may be desirable to suppress harmless warnings using the
    `@SafeVarargs` annotation.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `@SafeVarargs` annotation is used with constructors and methods. To use
    the `@SafeVarargs` annotation, the following steps need to be followed:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a method or constructor that uses a variable number of generic parameters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `@SafeVarargs` annotation before the method declaration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Java 7, mandatory compiler warnings are generated with generic variable argument
    methods or constructors. The use of the `@SafeVarargs` annotation suppresses warnings,
    when these methods or constructors are deemed to be harmless.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To demonstrate the `@SafeVarargs` annotation, create an application with a
    method called `displayElements` as follows. The method displays information about
    each parameter and its value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The method uses a variable number of generic parameters. Java implements a variable
    number of arguments as an array of objects, which only hold reifiable types. A
    **reifiable** type is discussed in the *How it works* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code in the `main` method to test the method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the application. The output should appear as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**java.util.ArrayList: [1, 2]**'
  prefs: []
  type: TYPE_NORMAL
- en: '**java.util.ArrayList: [3.0, 4.0]**'
  prefs: []
  type: TYPE_NORMAL
- en: '**java.lang.Integer: 12**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice the use of the diamond operator,`<>`, in the declaration of the `java.util.ArrayList`.
    This operator is new to Java 7, and is discussed in the recipe: *Using the diamond
    operator for constructor type inference*.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Java, a method or constructor with a variable number of arguments is created
    using the `..`. notation as used in the `displayElements` method. In this case,
    the element type is a generic.
  prefs: []
  type: TYPE_NORMAL
- en: The basic problem is the inability of generics and arrays to play well together.
    When generics were added to the Java language in 1.5, they were implemented to
    make them backwards compatible with earlier code. This meant that they were implemented
    using erasure. That is, any type of information that was available at compile-time
    was removed at run-time. This data is referred to as **non-reifiable.**
  prefs: []
  type: TYPE_NORMAL
- en: 'Arrays are reified. Information about an array''s element type is retained
    and can be used at run-time. Note that it is not possible to declare an array
    of generics. It is possible to create a simple array of strings as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'However, we cannot create an array of generics, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'This code will generate the following error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Cannot create a generic array of List<String>**'
  prefs: []
  type: TYPE_NORMAL
- en: A method that uses a variable number of arguments is implemented as an array
    of objects. It can only deal with reifiable types. When a method using a variable
    number of arguments is invoked, an array is created to hold these parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Since we used a method with variable number of generic arguments, a run-time
    problem can occur known as **heap pollution.** Heap pollution occurs when a variable
    of a parameterized type is assigned a different type than that used to define
    it. At run-time, this will manifest itself as an unchecked warning. At run-time,
    it will result in a `java.lang.ClassCastException`. Use the `@SafeVarargs` annotation
    to designate a method as one that avoids heap pollution.
  prefs: []
  type: TYPE_NORMAL
- en: Methods that use a variable number of generic arguments will result in a compile-time
    warning. However, not all methods that use a variable number of generic arguments
    will result in a run-time exception. The `@SafeVarargs` is used to mark the safe
    methods as safe. If it is possible for a run-time exception to occur, then the
    annotation should not be used. This is further explored in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that if the `@SafeVarargs` annotation was not used then the following
    warnings will be generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '**warning: [unchecked] unchecked generic array creation for varargs parameter
    of type ArrayList<? extends INT#1>[]**'
  prefs: []
  type: TYPE_NORMAL
- en: '**warning: [unchecked] Possible heap pollution from parameterized vararg type
    T**'
  prefs: []
  type: TYPE_NORMAL
- en: The first warning is applied against the `displayElements` invocation and the
    second warning is applied against the actual method. There is nothing wrong with
    the code, so suppression of these warnings is perfectly acceptable.
  prefs: []
  type: TYPE_NORMAL
- en: We could use the `@SuppressWarnings("unchecked")` annotation instead to suppress
    the warning at the declaration of the method, but warnings are still generated
    with their usage. Using `@SafeVarargs` suppresses warnings at both places.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Also of interest is:'
  prefs: []
  type: TYPE_NORMAL
- en: The use of `@SafeVarargs` annotation in the Java core libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An example of heap pollution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The use of @SafeVarargs annotation in Java core libraries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'JDK 1.7 libraries have incorporated the `@SafeVarargs` annotation. These include
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`public static <T> List<T> java.util.Arrays.asList(T... a)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public static <T> boolean java.util.Collections.addAll(Collection<? super
    T> c, T... elements)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public static <E extends Enum<E>> java.util.EnumSet<E> EnumSet.of(E first,
    E... rest)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`protected final void javax.swing.SwingWorker.publish(V... chunks)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These methods were tagged with the `@SafeVarargs` annotation to indicate that
    they will not cause heap pollution. These methods are considered to be safe.
  prefs: []
  type: TYPE_NORMAL
- en: An example of heap pollution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some methods should not be marked as safe, as illustrated with the following
    code adapted from the javadoc description of the `@SafeVarargs` annotation ([http://download.oracle.com/javase/7/docs/api/index.html](http://download.oracle.com/javase/7/docs/api/index.html)
    under the `java.lang.SafeVarargs` annotation documentation).
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following method to your code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Test the method with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the program. You should get the following error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exception in thread "main" java.lang.ClassCastException: java.lang.Integer
    cannot be cast to java.lang.String**'
  prefs: []
  type: TYPE_NORMAL
- en: 'A list of strings was passed to the method and assigned to the identifier `stringList`.
    Next, an array of objects was declared and assigned to the same object referenced
    by `stringList`. At this point, the `stringList` and `array` referenced the same
    object, a `java.util.List` of strings. The following illustrates the configuration
    of the memory at this point:'
  prefs: []
  type: TYPE_NORMAL
- en: '![An example of heap pollution](img/5627_1_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'With the following assignment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The first element of the array is reassigned to `tmpList`. This reassignment
    is illustrated in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![An example of heap pollution](img/5627_1_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At this point, we have effectively assigned an `Integer` object to a `String`
    reference variable. It has been assigned to the first element of the array referenced
    by both `stringLists` and `array`. The dashed line shows the old reference, which
    has been replaced with the line. When an attempt is made at run-time to assign
    this `Integer` object to a `String` reference variable, the `ClassCastException`
    occurs.
  prefs: []
  type: TYPE_NORMAL
- en: This method results in heap pollution and should not be annotated with `@SafeVarargs`
    as it is not safe. The assignment of `tmpList` to the first element of the array
    is permitted, since we are simply assigning a `List<Integer>` object to an `Object`
    reference variable. This is an example of **upcasting**, which is legal in Java.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The previous recipe *Using the diamond operator for constructor type inference
    explains an improvement in the use of generics*.
  prefs: []
  type: TYPE_NORMAL
