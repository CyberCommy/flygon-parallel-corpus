- en: Chapter 5. Adding Some Advanced Features to Your Game
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters we saw how to set up a work environment, took a look
    at the Impact engine, and even built two types of games. Now it is time to have
    a look at a few interesting extras.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'To test the elements covered in this chapter, it is best to either download
    the code material in the `chapter 5` folder or build directly on the game we designed
    in [Chapter 3](ch03.html "Chapter 3. Let''s Build a Role Playing Game"), *Let''s
    Build a Role Playing Game*. Since we will not be working with the Box2D extension
    in this chapter, some things will be incompatible with the side scroller game
    in [Chapter 4](ch04.html "Chapter 4. Let''s Build a Side Scroller Game"), *Let''s
    Build a Side Scroller Game*. In this chapter we will cover:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Making a Start and Victory screen
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extra debug possibilities and introducing a customized ImpactJS debug panel
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Saving data with cookies and the lawnchair application, and turning an Excel
    file into useful game data
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A few extra game functionalities for the role playing game (RPG) in [Chapter
    3](ch03.html "Chapter 3. Let's Build a Role Playing Game"), *Let's Build a Role
    Playing Game*
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making your character move by use of a mouse
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Intelligent spawn locations
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding basic conversation
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Showing a player's health bar
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extending the Artificial Intelligence (AI) with a hive mind
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing Playtomic for game analytics
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Start and Game-over screen
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When the player starts your game, the first thing you might want him to see
    is a splash screen. This screen usually has the name of the game and other interesting
    info; often it contains some information on the game's story or controls. At the
    end of the game you could have a Victory screen that tells the player how well
    he did by placing his achieved score in a leaderboard.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: 'With regards to code, this can be done by introducing new game instances next
    to the actual game. Every single screen: Start, Game-over, and Victory are direct
    extensions of the ImpactJS game class. Let''s kick off by creating a Start screen.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: The game's Start screen
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to make a nice opening screen, we need a background image and our
    trusted `main.js` script:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `main.js` script and insert the following code:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The opening screen is an extension of the `ig.Game` function, just like our
    game is. As a matter of fact, when we are done here, we will have four game instances:
    one real game called `MyGame`, and three other games, which will merely act as
    a Start, Victory, or Game-over screen. This might be a little counter intuitive,
    since you would expect the screens to be part of that same game. In reality this
    is most certainly true. However, in code it is more convenient to turn these screens
    into separate game class extensions.'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In this part of the `OpenScreen` code, we first define the image we will be
    showing: `StartScreen.png`.'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally we bind the Space bar to an action state called `LoadGame` shown as
    follows:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now we can load the game by pressing the Space bar, but we still need to actually
    show something on the screen.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can visualize things by manipulating the `draw()` function, as shown in
    the following code snippet, of any ImpactJS class:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `draw()` function will draw the background image we specified when initializing
    our `OpenScreen` function. Having done so, it will also add a small red rectangle
    in which we will print the name of the player, if we have it. We will go into
    getting this name and storing it for later use when we take a look at game data
    later in this chapter. For now, the `GameInfo.name` variable is undefined and
    will show up exactly like starting a new game.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To make sure our brand new opening screen is actually used, we need to replace
    the `MyGame` game class instance by the `OpenScreen` function in our `ig.main`
    function call, as shown in the following code line:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We now have an opening screen! Adding a Game-over screen and a Victory screen
    are very similar procedures. Before making these other screens, let''s quickly
    recap on what we have just done:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: We made sure a background image is available in the `media` folder
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We added the `OpenScreen` function as a new game instance
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We bound the Space bar so it can be used to load the actual game
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We set up the `Draw()` function so it can show the background and even the player's
    name later on
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We initialized our canvas in the `OpenScreen` function window instead of the
    `MyGame` game class instance
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Victory and Game-over screens
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Victory screen is a relatively simple extension of the game entity. The
    procedure is pretty much the same for every type of screen we will want to show.
    To set up the Victory screen, follow these steps:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `game.js` file and add our new `GameEnd` game class, as shown in the
    following code:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: All we need to initialize here is the image we will be showing and a key for
    restarting our game.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Similar to the Start screen, we use the Space bar to load a new game. We continually
    check whether the Space bar was pressed by adding the following `if` statement
    to the `update` function:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We need to draw the actual game-end image and place the text **HIT SPACE TO
    RESTART** using the following code. This way we make sure the player doesn't resort
    to refreshing the browser instead of using the Space bar.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The Victory screen needs to be shown when the player is at the end of the game.
    In our case, this would be when the boss entity is defeated. Open the `boss.js`
    file and change the `kill()` method as shown in the following code so that he
    will load the Victory screen when he dies:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the `kill()` method, we call the `gameWon()` function, which is a method
    of our current game and which is not yet defined.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `game.js` file and add the `gameWon()` method as a new method of the
    `MyGame` file, as shown in the following code.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: At the moment, it may seem rather pointless to introduce an extra intermediary
    function to call the Victory screen. However, this will start to make sense once
    we get into handling game data. Eventually, this function will not only call the
    Victory screen, but will also save the player's score. Using an intermediary function
    is a cleaner way of programming than adding the `ig.system.setGame()` function
    directly into the player entity.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Game-over screen can be the exact equivalent of the Victory screen, except
    that another image is used and it is triggered by the death of the player, not
    the boss.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `gameOver` function to the `game.js` file as shown in the following
    code snippet:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Make sure the `gameOver` function is triggered by the death of our player by
    adjusting his `kill()` method using the following code:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Again we called an intermediary function to handle the actual screen loading.
    This function will need to be added as a method to the `MyGame` game class instance.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `game.js` script, add the `gameOver()` method to the `MyGame` game class
    instance as shown in the following code:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: These are very basic Start and Game-over screens, which show that it can be
    done by using the `ig.game` class as a starting point. A good idea for both the
    Victory and Game-over screen would be to show a leaderboard or any other interesting
    info gathered during the game.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: 'When the game gets more complicated by adding advanced features, debugging
    becomes increasingly important to cope with these added levels of complexities.
    We will now have a look at what advanced debugging options we have at our disposal.
    However, before we do that, let''s quickly recap on the Victory and Game-over
    screens:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: We made two new game instances that function as Victory and Game-over screens
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `update` function was adapted to listen to the Space bar, while the `draw`
    function was adapted to show both the background image and the **HIT SPACE TO
    RESTART** message
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The functions of both the boss and player entity were adapted to trigger the
    Victory and Game-over screens
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We made use of intermediary functions called `gameOver()` and `gameWon()` because
    we wanted to adapt these later on so that they trigger the lawnchair application
    to store a score
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More advanced debugging options
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [Chapter 1](ch01.html "Chapter 1. Firing Up Your First Impact Game"), *Firing
    Up Your First Impact Game*, we took a look at how to debug using the browser and
    what the ImpactJS debug panel has to offer. Here we will go a little further by
    making ourselves a new ImpactJS debug panel. This code is readily made available
    by Dominic on his ImpactJS website but many people overlook this functionality
    even though it is surprisingly useful.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 1](ch01.html "Chapter 1. Firing Up Your First Impact Game"), *Firing
    Up Your First Impact Game*, we also talked about the logical error, an error that
    is very difficult to find because it does not necessarily generate an error in
    the browser debug console. To cope with these kinds of errors, programmers often
    use a method known as unit testing. This basically involves defining in advance
    what your desired result is for every piece of code, translating these desired
    results into conditions, and testing whether the output adheres to these conditions.
    Let's take a look at a short example.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: Short introduction to unit testing
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the most basic components of our ImpactJS scripts is the function. Some
    of our functions return values, others alter properties directly. Let''s assume
    we have a function called `dummyUnitTest()`, which takes a single argument: `functioninput`.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'An `inputnumber` variable can be any number, but our function transforms the
    `inputnumber` variable into an `outputnumber` variable, which it then returns.
    The `inputnumber` variable raised to the power of two should always return a positive
    number. So we can say at least two things about what we expect from this function:
    the output cannot be null and it cannot be negative.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: 'We can unit test this function by adding `assert` functions dedicated to checking
    certain conditions. An `assert` function checks a condition and when it is false,
    it will write a message to the console log. The console element itself has this
    function but so does ImpactJS when the debug module is activated. The `ig.assert()`
    function is the ImpactJS equivalent of the `Console.assert()` function. Remember
    that activating ImpactJS debugging can be done by including `''impact.debug.debug''`
    in the `main.js` file. Using the `ig.assert` function is preferable over the `console.assert()`
    function. This is because getting rid of the `ig` class messages when preparing
    to launch the game is done simply by turning off the ImpactJS debug module. Methods
    of the console class, such as the `console.assert()` call would need to be turned
    off separately. In general, the `assert()` function looks like this:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'For our specific example we could perform several tests as shown in the following
    code:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We could go on, and this method is not without the pitfall of overkill. But
    in general, when you plan on building a very complex game, unit testing can help
    out tremendously by reducing the time you will spend looking for the source of
    logical errors. For example, if in this case our output was a negative number,
    the function itself will not fail; maybe most of the code that relies on this
    function will not either, but somewhere down the chain, something will. While
    introducing all these dependencies, one function built on top of another and so
    on, unit testing is certainly justified.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: Next to the `ig.assert()` and `ig.log()` function is another interesting function.
    It is the ImpactJS equivalent of the `console.log()` function and will write to
    the log at all times, without checking certain conditions. This can be useful
    for keeping an eye on an enemy's health without having to look for it in the **Document
    Object Model** (**DOM**).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s quickly recap what unit testing is about before moving on to our own
    ImpactJS debug panel:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing is about foreseeing what you expect your code components to do,
    and returning and checking the output validity.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We use the `ig.assert()` or `console.assert()` function to check certain conditions
    and print a message to the log if they are violated.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding your own debug panel to the ImpactJS debugger
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As stated earlier, activating the debug panel is done by simply including the
    `'impact.debug'` statement in the `main.js` file. When starting a new game, the
    panel is minimized at the bottom of the screen and can be made entirely visible
    by simply clicking on it.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s get round to building our own panel, which will enable us to activate
    and deactivate entities while playing the game. This way we can venture unharmed,
    past our most ferocious enemies by freezing them in position. Let''s get to it:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: Open a new file and save it as `MyDebugPanel.js`.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Insert the following code in the file:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Before we actually define our panel, we will inject code in two ImpactJS core
    classes: `Game` and `Entity`. Injecting code is like extending, except we don''t
    make a new class. The original code is replaced by an extended version of itself.
    In the previous code we tell the core `loadlevel()` function to load our panel
    as well, which will be called a **Fancy panel**.'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We then upgrade our core entity code by adding a new property: `_shouldUpdate`,
    as shown in the following code:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: When true, the entity's `update` method will be called, which is also the default
    method. However, when false, the `update()` function is bypassed and no real action
    will be performed by the entity.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now let''s have a look at the panel itself. We can see the following code contained
    in the panel:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Our fancy panel is initialized as an extension of the panel of ImpactJS, called
    the `DebugPanel`. Calling the `this.parent` function will make sure a DIV container
    is supplied to the panel so that it can be shown in HTML5\. The container would
    not hold anything if there were no entities in the game, so then a message is
    placed instead. For example, this will be the case for our start and end screens.
    Since the `this.container.innerHTML` function will hold the panel's content, opening
    the panel while in the start screen should result in the message **Entities not
    loaded yet**.![Adding your own debug panel to the ImpactJS debugger](img/4568_5_1.jpg)
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To display the previous message we should add the following code within the
    `this.container.innerHTML` function:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'On loading the level, our panel is filled with all the entities in the game
    and the option to turn their `update()` functions off. Also, their health is shown.
    The `addOption()` function is what makes it possible to switch the `_shouldUpdate`
    property from true to false and back, whenever needed. It takes two arguments:
    a label and the variable that needs to alternate between true and false.'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'These last functions are not used for our particular panel but are useful nonetheless.
    The following code explains the previous functions:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The main difference between the `load()`, `ready()`, `beforeRun()`, and `afterRun()`
    function is the moment they are called within the game. Depending on your needs,
    you will use one, the other, or a combination. We used the `load()` method, which
    is called when a level is loaded. But for other panels you might want to use the
    other methods.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As a last step, we actually add the customized panel to our set of standard
    panels as shown in the following code:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Reload your game and take a look at your new panel. Try freezing your enemies!
    You will notice that the enemies will still face the player but not move towards
    him. This is because we disabled their `update()` method but not their `draw()`
    methods.![Adding your own debug panel to the ImpactJS debugger](img/4568_5_2.jpg)
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will now move on to using game data, but let''s first have a look at what
    we just covered:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: ImpactJS has a very interesting debugger for which you can design your own panels.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Activating the ImpactJS debugger is done by including the `'impact.debug.debug'`
    command in your main script.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We made ourselves a panel by extending the ImpactJS `DebugPanel` class. Our
    own panel needs to enable us to freeze any entity into position, so we can explore
    our levels unimpeded.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making use of a technique called injection; we changed our core entity class
    so that the debug panel gets to control the `update` function of every entity.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally we added our debug panel to the standard set so that it becomes available
    to us at all times.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling game data
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Working with data can be essential for game building. Simple games do not need
    explicit data management. However, when we start looking at games that feature
    conversations or keep high-scores, understanding data handling becomes an important
    topic. We will talk about two things:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: Bringing data into your game
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing data that is generated in a game
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For the latter we will have a look at two different ways of tackling the problem:
    cookies and the lawnchair application.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Let's first have a look at what we need to do if we want to introduce data for
    a conversation between an NPC and a player.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Adding data to your game
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned before, RPGs are often packed with conversations between the player
    and several non-playable characters (NPCs). In these conversations the player
    is given several options when it is his time to answer. The code mechanics for
    this can get pretty complicated and we will get to that later in this chapter,
    but first we need the actual sentences themselves. We can prepare these in an
    application such as Excel.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding data to your game](img/4568_5_3.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
- en: 'Setting up RPG conversations is an art; there are many ways to do it, each
    with its pros and cons. Creating a decent conversation setup and flow, even database-wise,
    is a discussion that reaches beyond the scope of this book. Here we will try to
    keep it simple and work with two tables: one for all the things an NPC can say
    and one for what the player can answer. The flow of a conversation for our game
    will be as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: The NPC says something. Everything an NPC can say has a unique key called **NPC_CONVO_KEY**.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The player is presented with a set of possible answers. Every set gets a key
    called **REPLY_SET_KEY**. In addition to that, although it will not be used by
    us, every answer has its own unique key, which we call **UNIQUE_REPLY_KEY**. It
    is essentially a good practice to have primary keys available, even if you don't
    use them just yet.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The player selects one of the answers. An answer has a foreign key, which leads
    back to the NPC. We named this foreign key: **NPC_CONVO_KEY**.'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using **NPC_CONVO_KEY**, the NPC knows what to say next, and we have completed
    the loop. This will go on until the conversation is abruptly aborted or naturally
    comes to an end.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The actual sentences are kept in the variables **PC_SPEECH** and **NPC_SPEECH**.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: 'We can easily prepare our data in an Excel document but we still need to import
    it into our game. We will do this by using a converter such as the one on the
    following website: [http://shancarter.com/data_converter/](http://shancarter.com/data_converter/).'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: Simply copy and paste the data from Excel to the converter and select **JSON-Column
    Arrays** to get your data in the JSON-format documents.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have it in this format, all we need to do is copy and paste the data
    to separate modules. The following code is what our excel data looks like once
    it is converted to JSON:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We store the data in JSON format just like the Weltmeister does with the level
    files. The following code is the player''s speech data turned into JSON:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'All that remains now is putting the data inside our game directory and including
    both files in the `main.js` file:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If you were to reload your game, you should be able to explore your newly introduced
    data in the DOM with the Firebug application as shown in the following screenshot:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您重新加载游戏，您应该能够在Firebug应用程序中探索您新引入的数据，如下面的屏幕截图所示：
- en: '![Adding data to your game](img/4568_5_4.jpg)![Adding data to your game](img/4568_5_5.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![向游戏添加数据](img/4568_5_4.jpg)![向游戏添加数据](img/4568_5_5.jpg)'
- en: 'Now that we have taken a look at how to introduce data, let''s take a look
    at two ways to store data on the player''s computer, starting with cookies. But
    let''s first summarize what we have done here:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看了如何引入数据，让我们来看一下两种在玩家计算机上存储数据的方法，首先是使用cookie。但首先让我们总结一下我们在这里所做的事情：
- en: Setting up conversations is an art form, which will not be explored in depth
    in this chapter
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置对话是一门艺术，本章不会深入探讨
- en: We set up a simple conversation in Excel or an equivalent application
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在Excel或等效应用程序中设置了一个简单的对话
- en: This Excel sheet is converted to a JSON-format document. You can do this by
    using online converters such as the one on [http://shancarter.com/data_converter/](http://shancarter.com/data_converter/)
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个Excel表格被转换为JSON格式的文档。您可以使用在线转换器来做到这一点，比如[http://shancarter.com/data_converter/](http://shancarter.com/data_converter/)
- en: We turn the new JSON encoded data into ImpactJS modules
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将新的JSON编码数据转换为ImpactJS模块
- en: Finally we include the two newly created data modules in our main script
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们在我们的主脚本中包含了这两个新创建的数据模块
- en: Using cookies to store data on the player's computer
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用cookie在玩家的计算机上存储数据
- en: Cookies are not much more than a piece of string data stored in your browser
    and are used by many websites to track visitors. If you are a user of Google Analytics,
    you probably know that Google provides a script that places several different
    cookies per visitor. Google Analytics is not the only program that works this
    way. After a good day of surfing the Internet, your browser is full of cookies;
    some of them will remain there for several months until finally deleting themselves.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Cookie不过是存储在浏览器中的一段字符串数据，许多网站用它来跟踪访问者。如果您使用Google Analytics，您可能知道Google提供了一个脚本，为每个访问者放置了几个不同的cookie。Google
    Analytics并不是唯一以这种方式工作的程序。在一天愉快的上网之后，您的浏览器中充满了cookie；其中一些将在几个月内保留，直到最终删除自己。
- en: Storing information such as the player's name and high score in the user's browser
    makes sense; no storage is needed from your side, thus, no need for PHP or SQL
    coding. The downside is the loss of data if the player decides it's time to clean
    up his browser. Also, there is no real one-to-one relationship with the player
    while using cookies. One person can have several devices and even several browsers
    per device. Cookies are thus recommended for games you always replay from the
    start. It is certainly not good for games that require a massive time investment
    from the player; for instance, MMORPGs (Massively Multiplayer Online Role Playing
    Games) tend to do. For these more advanced games, working with accounts and server-side
    databases is the way to go.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在用户的浏览器中存储玩家姓名和最高分等信息是有意义的；您不需要从您这边进行存储，因此不需要PHP或SQL编码。缺点是如果玩家决定清理浏览器，数据将丢失。此外，在使用cookie时与玩家之间没有真正的一对一关系。一个人可以有多个设备，甚至每个设备可以有多个浏览器。因此，建议对您总是从头开始重玩的游戏使用cookie。对于需要玩家大量时间投入的游戏来说，这显然不适用；例如，大型多人在线角色扮演游戏（MMORPGs）往往是如此。对于这些更高级的游戏，使用帐户和服务器端数据库是正确的方式。
- en: 'Let''s build ourselves a cookie plugin, using the following steps, which will
    be able to store the player''s name so that we can retrieve it when restarting
    the game:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下步骤构建一个能够存储玩家姓名的cookie插件，这样我们可以在重新开始游戏时检索它：
- en: 'Open a new file and save it as `cookie.js`. Insert basic class extension code
    as follows:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新文件，将其保存为`cookie.js`。插入基本的类扩展代码如下：
- en: '[PRE24]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We start off by defining our cookie plugin as an ImpactJS class extension.
    We know it will have to store a username later on, so let''s initialize it with
    the value `null`. The first thing our new DOM object will do, when created, is
    call the `checkCookie()` function. The `checkCookie()` function will check if
    there is already a cookie with the same username stored inside. There are of course
    two possibilities here: either it exists or it doesn''t. If it doesn''t, the name
    needs to be prompted and stored. If the username was stored before, it can be
    retrieved.'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先将我们的cookie插件定义为ImpactJS类扩展。我们知道它以后将需要存储用户名，所以让我们用值`null`来初始化它。我们的新DOM对象创建时，第一件事就是调用`checkCookie()`函数。`checkCookie()`函数将检查是否已经存在存储了相同用户名的cookie。当然这里有两种可能性：存在或不存在。如果不存在，需要提示并存储名称。如果用户名以前已存储，可以检索出来。
- en: 'Putting a cookie in place is done with the `setCookie()` function as shown
    in the following code:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将cookie放置在位置上是使用`setCookie()`函数完成的，如下面的代码所示：
- en: '[PRE25]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This function takes in three arguments:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个函数接受三个参数：
- en: '`c_name`: The name of the variable it needs to store, which is the username'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`c_name`：它需要存储的变量的名称，即用户名'
- en: '`value`: The value of the username'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`value`：用户名的值'
- en: '`exdays`: The number of days the cookie is allowed to exist until it should
    delete itself from the browser'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exdays`：cookie允许存在的天数，直到它应该从浏览器中删除自己'
- en: The `setcookie()` function serves to check the input data's validity. The value
    is transformed, so it's more difficult for an amateur hacker to insert damaging
    code instead of a name. The data is then stored in the `document.cookie` variable,
    a part of the DOM that stores all the cookies and is not lost while closing the
    page. Going into the intricate working of the `document.cookie` variable will
    lead us too far but it behaves very peculiarly. Assigning a value to the `document.cookie`
    variable, as shown in the previous code snippet, will not replace what was already
    in there with the newly assigned value. Instead, it will be added to the rest
    of the stack.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If there is a `setCookie()` function, there is of course a `getCookie()` function
    as shown in the following code snippet:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The previous code will decode the transformed cookie and return it. Its sole
    input argument is the name of the variable you are looking for.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In programming, especially in Java, it is very common to use a combination of
    the `set` and `get` functions to change properties. So using this programming
    logic, a `health` property for instance should always have a `setHealth()` and
    `getHealth()` function. Changing parameters directly has advantages and disadvantages.
    The main advantage of directly changing properties is pragmatism; things remain
    easy and intuitive to understand. A big downside is the struggle to maintain code
    validity. If everything can just change any property of any entity from anywhere,
    you can end up with serious issues if you lose sight of things.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `checkCookie()` function checks if the username is present in the browser
    by use of the `getCookie()` function:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: If a cookie is present, a `setUserName()` function is called using the fetched
    username as an input parameter. If no cookie is present, the player is prompted
    to insert his or her name and this is subsequently stored with the `setCookie()`
    function.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `getUserName()` and `setUserName()` functions are kept relatively basic
    for this example, as shown in the following code:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `setUsername()` and `getUsername()` functions could be left out by directly
    getting or setting the `this.username` command with the `checkCookie()` and `setCookie()`
    functions. However, as said earlier, it is a good programming practice to use
    the `set` and `get` statements wherever a property needs to be changed. As seen
    in the `setUserName()` function, some extra checks can be built into these functions.
    While the `getCookie()` and `setCookie()` functions make sure the data is stored
    in a harmless way and fetched appropriately, the `setUserName()` and `getUserName()`
    functions can be used to check other constraints, such as name length.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now that we have finished our cookie extension, we can actually make use of
    it. Open the `main.js` file and add the following two lines to the `GameInfo`
    class:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `GameInfo` class is perfect for this; everything we want to remain available
    outside of a game instance needs to be gathered in the `GameInfo` class. Separating
    the data component from the game logic as much as possible is a way of keeping
    things clean and understandable when a game grows more complex.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Our first code line will create an `ig.cookie` array and immediately check if
    a username is present. If it is not present, a prompt will appear and the name
    will be stored after the player has filled out the prompt alert.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The second line simply hands over the username to the `GameInfo` object that
    we first encountered in [Chapter 3](ch03.html "Chapter 3. Let's Build a Role Playing
    Game"), *Let's Build a Role Playing Game*. As you might remember, we used the
    `GameInfo.name` variable in the beginning of this chapter but it was undefined.
    Now it will be set to `null` until the player gives his name and is, henceforth,
    used for every game he plays.![Using cookies to store data on the player's computer](img/4568_5_6.jpg)
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Initially the player's name will be unknown, and **null** would be shown on
    the screen as shown in the previous screenshot.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '![Using cookies to store data on the player''s computer](img/4568_5_7.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
- en: However, the player is prompted to fill out his or her name in the window as
    shown in the previous screenshot.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '![Using cookies to store data on the player''s computer](img/4568_5_8.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
- en: Henceforth, the real name is shown on the screen as shown in the previous screenshot.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: 'While you should be able to get around using cookies, there is another way
    to store data, which is probably more versatile and easy to use: lawnchair. The
    lawnchair application makes use of the HTML5 local storage, also known as the
    DOM storage. Before moving on to the lawnchair application, we will take a quick
    peek into how to use HTML5 local storage even without using the lawnchair application:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: Cookies are a way of storing data in the player's browser. Many websites make
    use of them including the web analytics platform, Google Analytics. Cookies are
    useful for short games that are meant to be played of and over again, not for
    complicated games that require many things to be stored over a long period of
    time.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can implement the use of cookies by creating a `cookies` plugin. This plugin,
    once activated, will check whether a cookie is already active and place one if
    none is found.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this example, we use cookies to store and retrieve the player's name, which
    we first ask him to fill out if no cookie is in place.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Emphasis is put on the use of the `set()` and `get()` functions. These functions
    are a standard practice in Java and are a useful technique to keep sight of things
    and check the validity of any property in the code that grows even more complex.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Local storage
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Local storage, also known as DOM storage, is an HTML5 feature that allows you
    to save information on the user''s computer. It is superior to cookies in almost
    every way but the older browsers do not support it. Using local storage is rather
    straightforward as we can see in the following code snippet:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This plugin is not strictly necessary in order to make use of local storage.
    It is merely an extension with the `get` and `set` technique in order to check
    data validity. You can use the plugin by including the `'plugins.data.local'`
    command in your `main.js` script and calling the `setData()` and `getData()` functions.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Now we'll take a quick look at how to use local storage in general; let's look
    at what the lawnchair application has to offer.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: Using lawnchair as a versatile way of storing data
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The lawnchair application is a free and very professional solution for storing
    data on the client side. It is capable of storing data in several ways, and a
    plugin for ImpactJS is readily available. Let''s look at how to use the lawnchair
    application to store data:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: 'Download the lawnchair application from the following website: [http://brian.io/lawnchair/](http://brian.io/lawnchair/),
    or you can download the ImpactJS adapted version on [https://github.com/jmo84/Lawnchair-plugin-for-ImpactJS](https://github.com/jmo84/Lawnchair-plugin-for-ImpactJS).'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place the files in your `plugin` folder. In this example, they are placed in
    separate subfolders called `data` and `Lawnchair`. However, you are free to use
    any structure you want, as long as you make sure to change the code accordingly.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Include the `impact-plugin` file in your `main.js` file as shown in the following
    code:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Add a store element to your `GameInfo` class by the use of the newly acquired
    `ig.Lawnchair()` method as shown in the following code line:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The `ig.Lawnchair()` method takes two input parameters:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: 'The first parameter is the most important one and is actually an array. In
    this array you will need to specify two things: which method you want to use to
    store everything, and the name of the data storage you want to create. The first
    variable is called the `adaptor` because the lawnchair application uses the adaptor
    pattern technique to decide what needs to happen next. The lawnchair application
    is programmed very efficiently and this immediately becomes apparent by this use
    of patterns. An adaptor pattern is essentially a piece of code that will link
    your own code to that of the lawnchair application''s storing system. Without
    this pattern, it would be really difficult to communicate with the actual lawnchair
    application''s source code, which saves your data. Here we choose to save it as
    a permanent DOM storage, but other options such as Webkit-SQLite are available.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Webkit-SQLite differs from permanent DOM storage such that it acts more like
    a regular database, but on the client's local storage. For instance, like other
    databases, you can query Webkit-SQLite storage with SQL.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: The second input parameter is an optional one. Here you can put functions that
    need to be executed when the `store` variable is prepared. This is the perfect
    place to put log messages.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have our store element ready to go, it is just a matter of storing
    whatever data you want by calling the `store.save()` method. Let's say we want
    to store our player's score. For this we can add a method to our `GameInfo` class
    that does just the same.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The `saveScore()` function can be added to both the `gameOver()` and `gameWon()`
    methods we created while building our victory and Game-over screens as follows:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: When the player dies or wins the game, his score is saved using the lawnchair
    permanent DOM method. Permanent DOM does not mean the DOM is saved permanently
    on the user's PC; it is merely another name for local storage.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The last important thing we need to be able to do is retrieve the data. To
    do this, we introduce three new functions to our `GameInfo` class:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `setScore()` function will save the input parameter as a `GameInfo.score`
    class if it is an actual number, as shown in the following code:'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The `getScore()` method will just return the `score value` stored in the `GameInfo.score`
    class as shown in the following code:'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Note
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Neither `setScore()` nor `getScore()` seem too important, but as explained while
    looking at the concept of cookies, using the `set` and `get` statements are useful
    for doing checks on data validity.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: 'The `GameInfo.getSavedScore()` method is the mirror opposite of the `GameInfo.saveScore()`
    method, as we can see in the following code:'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The `getSavedScore()` method makes use of the `setScore()` function to set the
    `GameInfo.score` class to the number it has withdrawn from the storage. Then it
    returns this score using the `getScore()` method where some extra tests can be
    done on data validity.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can now retrieve the last achieved score whenever you want!
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can adapt our opening screen so that it shows the last achieved score by
    adding the following code line to its `draw()` function.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The last score of the player is displayed as shown in the following screenshot:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '![Using lawnchair as a versatile way of storing data](img/4568_5_9.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
- en: 'Enough about data storage, let''s quickly go over the differences between cookies,
    local storage, and the somewhat more versatile way of using local storage: lawnchair.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '|   | Storage size | Expiration date | Information safety |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
- en: '| **Cookies** | Very limited | Fixed | Can be seen in the URL and will be sent
    to the receiving server and back to the local computer. |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
- en: '| **Local storage** | Big | Session or unlimited | Is stored on a local computer
    and nothing is sent to and from a server. |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
- en: '| **lawnchair** | Big | Depends on the chosen technique | Is stored on a local
    computer and nothing is sent to and from a server. |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
- en: In short, local storage is the newer way to save data locally. You can still
    use cookies, but the new privacy rules dictate that you must ask for permission
    before using them.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: 'Summing up the complete data storage concept, we conclude that:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: The lawnchair application is a code package that is freely downloadable and
    can handle all your client-side storage needs. It can save using several methods,
    such as permanent DOM storage or Webkit-SQLite.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The recommended downloadable code package is located at [https://github.com/jmo84/Lawnchair-plugin-for-ImpactJS](https://github.com/jmo84/Lawnchair-plugin-for-ImpactJS),
    since it comes with an ImpactJS plugin.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making use of the lawnchair storage system constitutes including the library
    and initializing one of our `GameInfo` class' variables as a lawnchair application's
    object. We can then store and retrieve data through the use of the `this` object
    since it inherits all of the lawnchair methods.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extra functionalities for the RPG
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section we will look at a few extra functionalities that might be particularly
    useful for a top-down game such as the **RPG** we designed in [Chapter 3](ch03.html
    "Chapter 3. Let's Build a Role Playing Game"), *Let's Build a Role Playing Game*.
    First, we will implement character movement by mouse click, which is especially
    useful for mobile games, since touching the screen is the mobile equivalent of
    clicking a mouse. Then we will add a smart spawn point. This spawn point first
    checks whether spawning an entity would cause collision and adjusts its spawn
    coordinates accordingly. The third element adds conversation between the player
    and a non-playable character (NPC). The final add-on is a basic head-up display
    (HUD), which allows the players to keep track of their health.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: Moving the player with a mouse click
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Up until here, we moved our player around by use of the keyboard arrow keys.
    This is very intuitive, yet sometimes impossible. If you were to open your game
    on an iPad or any other mobile device, there is no way to move your character
    since no arrow keys are present. Here it would be more useful if our character
    would just walk towards the spot we touch on our screen. In ImpactJS, the mouse
    click and a touch are treated as the same thing, it just depends on the device.
    Therefore, implementing movement by a mouse click automatically results in movement
    by a touch for your mobile device. To make the player move around by clicking
    the mouse or touching the screen, you need to follow these steps:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: In the `main.js` file, bind the mouse click to the action called `'mouseclick'`.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Open the `player.js` file and add a few extra initial variables. We will need
    this once we start using the movement by a mouse function we are about to add.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: If the `movementspeed` variable was not already there as a `"player"` property,
    be sure to add it now. The `mousewalking` command is a flag variable; a value
    of `1` means the player must walk as commanded by a mouse click. The `takemouseinput`
    variable's value is set to `1` when the mouse is clicked and immediately returned
    to `0` after the goal coordinates are calculated. Without this variable, it would
    be possible to steer your character by the position of your mouse instead of a
    single click. This is a matter of choice; steering by mouse position instead of
    mouse click can certainly be part of a valid and intuitive control scheme.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `mousemovement()` method to the `"player"` entity using the following
    code:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The length of this function might be a little daunting but actually the same
    logic is repeated several times. The function basically does two things: it can
    set destination coordinates and it can make the player move towards a target.
    In most cases it will not be necessary to calculate a new target. Thus, the first
    check is whether a new destination needs to be used. For this, both `player.takemouseinput`
    and `player.mousewalking` variables need to be `true`. In the calculation of the
    target location coordinates, a correction is applied for the position of the game
    screen.'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then the function proceeds with the actual movement; whether it should proceed
    or not is set by the value of the `player.mousewalking` variable (`True` or `False`).
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the player needs to walk, the actual distance to the target is calculated
    for both the x and y axes and stored in the local variables, `distancetotargetx`
    and `distancetotargety`. When the target is within 5 pixels of the player on either
    axis, the player will not move.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: However, if the distance is greater than 5 pixels, the player will move towards
    his target in a linear manner. To make sure the player moves at the preset movement
    speed, it will do so at the axis on which the remaining distance is greatest.
    Let's say the player is far away from his target on the x axis but not so far
    on the y axis. In this case he will move at the preset movement speed on the x
    axis but less than the preset movement speed for the y axis. Also he will be facing
    left or right and not up or down.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The two most important triggering variables: `player.mousewalking` and `player.takemouseinput`
    are initialized at a value of `0`; they need to be put to a value of `1` when
    a mouse click is registered. This we do in the `update()` function as shown in
    the following code:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We just made sure that the game checks whether the mouse was clicked at every
    new frame.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If we now call our update function by adding a call to the `mousemovement()`
    method, the player will walk wherever a mouse click is registered on the screen.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Of course, our keyboard controls are still there and this will cause problems.
    In order to make both control methods work, all we need to do is set the value
    of the `player.mousewalking` variable to `0` every time one of the keys is pressed,
    as shown in the following code for the up arrow key:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Whether the value of the `player.mousewalking` variable is `0` or not needs
    to be checked constantly using the following code. If not, our old control system
    will immediately stop the movement because no keyboard input was registered.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Finally, save your files and reload the game.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should now be able to run around by clicking the mouse anywhere on the screen.
    You might notice slight course adjustments if the player encounters an obstacle.
    However, he is not smart enough to actually go around it if the obstacle is too
    big. As a player, you need to steer clear of obstacles yourself.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at how to create an intelligent spawn location. But before
    we do so, let''s recap what was just covered:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: Being able to move the player with a mouse click is an interesting feature when
    moving to mobile devices, since there the keyboard is not an option. With ImpactJS,
    the click of a mouse is considered the same as touching the screen of an iPad.
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Currently our player can move around with the keyboard so we need to implement
    the possibility to use both the keyboard arrow keys and the mouse. All adjustments
    for this will take place within the player entity.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We introduced a new method called `mousemovement()`, which is repeatedly called
    in the player's `update` function. At all times, our method will check whether
    the command for moving by a mouse click was given, and if so will move the player
    to the desired location.
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition to adding this new method, we needed to adjust our old movement
    code so it would allow combining both the arrow keys and the newly implemented
    movement by a mouse click.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding intelligent spawn locations
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While building a level in the Weltmeister, you can immediately add your hostile
    entities to the level itself. This is nice, but sometimes adding a bit of unpredictability
    will increase the replay value of your game. This can be done by adding intelligent
    spawning: spawning enemies on random places but taking collision with other entities
    and the collision layer into account. In order to do this, we will need to create
    a new plugin with the following steps:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file and save it as `spawnlocations.js`.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `'plugins.functions.spawnlocations'` command to your `main.js` file.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create an `ig.spawnlocations` variable as an extension of the ImpactJS class,
    as shown in the following code:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Add the `spawnIf()` method, which is a callback function as shown in the following
    code. It can call itself again when certain conditions are met.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The `spawnIf()` function takes in an x and y start coordinate and checks if
    there is collision with the collision layer or an entity. If this is the case,
    the original coordinates are adjusted with a random number of pixels on both axes.
    These new coordinates are then resubmitted to the `spawnIf()` function until it
    finds a free spot. Once no more collision is detected, an enemy is spawned on
    that location. The `CollisionAt()` and `getEntitiesAt()` functions that it requires
    are also part of the `spawnlocations` class.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `getEntitiesAt()` function will detect entities that would be overlapping
    with the enemy that needs to spawn. The following code depicts the detection process
    applied by the `getEntitiesAt()` function:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: One by one, the entities are checked to see whether they overlap using their
    position, width, and height. If there is an overlap with a single entity, the
    loop is aborted and the `getEntitiesAt()` function returns the value `true`. If
    no overlap was detected it will return the value `false`.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'While the `getEntitiesAt()` function checks for a possible collision with other
    entities, the `CollisionAt()` function checks if the enemy would overlap with
    the collision layer, as shown in the following code snippet:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The most important function is the `collisionMap` method's `trace()` function.
    The `trace()` function will check if something is between the value of the `x`
    coordinate and the sum of the values of the `x` and `ent.size.x` variable's coordinate
    or between the value of the `y` coordinate and the sum of the values of the `y`
    and `ent.size.y` variable's coordinate. The last two arguments are the `size`
    of the entity. This is normally used to check a trajectory but we are using it
    to check a specific location. If there is a collision on either the x or y axes,
    the `CollisionAt()` function will return the value `true`, and the `spawnIf()`
    function will need to look for a new spawn location.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The last thing we need to do is actually spawn an enemy. This we can do within
    `MyGame` in the `main.js` file using the following code:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: An enemy will now spawn at these coordinates if a free space is available, otherwise,
    the coordinates will be adjusted until a suitable spot is found.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now that we added an intelligent spawn point to our game, it is time to move
    on to a somewhat complex game element: conversation. However, before we start
    the conversation process, let''s quickly go through what we just did:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of the intelligent spawn point is to find an open space for an enemy
    to spawn. For this, a check with both the entities already in the game and the
    collision layer of the level will be needed.
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We build a plugin that consists of three parts:'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A callback function that will adjust the coordinates until a good location is
    found, and subsequently spawn the enemy. It makes use of the other two functions
    in our spawn point class.
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The function that must check for potential overlap with other entities.
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A function that checks for an overlap with the collision layer.
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding an enemy to the game can now be done by initiating a new spawn point
    and using its `spawnIf()` method to put a new enemy into the gaming world.
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing basic conversation
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Many role playing games (RPGs) have conversations between the player and some
    of the non-playable characters (NPCs). In this section we will address a way to
    get a simple conversation into your game. The main prerequisite is the conversation
    data we added to our game earlier in this chapter. We need to build a conversation
    menu containing items that can be selected by the player using the following steps.
    Talkie, our lovely NPC from [Chapter 3](ch03.html "Chapter 3. Let''s Build a Role
    Playing Game"), *Let''s Build a Role Playing Game*, will serve as our partner
    in crime. The player will not only have several answering options every time Talkie
    says something, but will also have the NPC react to what the player wants to say
    by opening new options. The cycle should be able to go on until all options are
    exhausted or the conversation is aborted abruptly:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: Open a new file and save it as `menu.js` in the `conversation` subfolder of
    the `plugins` folder.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `'plugins.conversation.menu'` command to your `main.js` file.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a `window.Menu` class as an extension of the ImpactJS class as shown
    in the following code:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Our menu `init()` function will require four input variables; we will turn
    all of them into `menu` properties so they are available in our `menu` methods;
    those four input variables are as follows:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`_font`: This is the font that we will be using'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`_choice_spacing`: This is the space we want between each of the choices that
    will be shown on the screen'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`_choices`: This is the array of choices the player has at a specific part
    of the conversation'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`_entity`: This is the NPC that needs to talk to the player; in this case that
    would be `Talkie`'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Our `init()` method contains some other important variables as follows:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`this.selectedChoice`: This is the variable that will store the array index
    of the currently selected choice. It is initialized at a value `0`, which is always
    the first element of any array and, thus, the first option of the player. The
    `this.selectedChoice` variable is important because the symbols `<<` and `>>`
    will be shown at the sides of the currently selected option as a visual aid.'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`this.cursorLeft` and `this.cursorRight`: They are the variables that store
    the visual aid symbols `<<` and `>>`.'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`this.cursorLeftWidth` and `this.cursorRightWidth`: They are the variables
    that store the length for the `<<` and `>>` symbols for the chosen font so that
    this can be taken into account when actually drawing the choices on screen.'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`_choices[i].labelWidth`: This local variable stores the width that has been
    calculated for each of the choices. The calculated width is then stored in the
    menu property array `choices[i].labelWidth`. The `cursorLeftWidth` and `cursorRightWidth`
    variables will be used to determine the screen positioning while drawing the options
    on screen.'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`this.Menubackground`: This variable will hold a black square, which serves
    as a background so that the white characters of the conversation are always readable,
    regardless of what the level currently looks like. The background adapts itself
    to the length of the longest option and the number of options. This way it doesn''t
    take more space than is absolutely necessary.'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `draw()` method holds all of the menu logic, so we will discuss it in chunks
    using the following code:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The first major thing the `draw()` function does is it adjusts the background
    of the menu so that it is always big enough to fit the different sentences, given
    the chosen font. This logic, among others, could just as well have been stored
    in an `update()` function instead of a `draw()` function. This is a matter of
    choice and you are of course free to rewrite the `menu` class as you please. The
    bottom line is that both the `draw()` and `update()` functions are called in every
    frame, which is the most important common attribute of these methods. In the following
    code we can check out the functionality of a `draw()` function:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Now the position of the text is determined and every choice is written on the
    screen. A check is done to see which option is currently selected. This option
    is encapsulated by the **<<** and **>>** symbols to make the player aware of what
    he is about to choose. To add these functionalities we will look into the following
    code:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The player has three options: he can press the up arrow, down arrow, or the
    interact button on the keyboard; the last action state corresponds to the *Enter*
    key. Here we will explain how it is done for a regular desktop. It is a good exercise
    to try implementing this for mobile devices:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the `'up'` input state is activated, the `'up'` state should currently be
    bound to the up arrow of the keyboard and the selected choice shifts one position
    upwards. In the array this translates to an element with a lower index. However,
    if the position 0 within the index is reached, it can't go any lower since this
    is the first option. In this case it stays at the first option.
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An equivalent logic is used for going down the menu with the down arrow key.
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the `'interact'` state is not yet bound to the *Enter* key, do so now by
    adding the `ig.input.bind( ig.KEY.ENTER, 'interact' );` command to the `main.js`
    file. The player makes his choice by pressing the *Enter* key. Using the `npcreply()`
    function, the NPC knows what to say and will spawn a text balloon containing his
    reply. Based on this reply, the `this.choices` function will be filled with new
    choices for the player to pick from.
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The menu is composed of different items; every separate option corresponds
    to a single menu item. Add this menu item class to the `menu.js` file using the
    following code:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'A menu item is initialized with the following two input parameters:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The label, which is the actual text of a choice or option.
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NPC_Response`, which is the Primary Key of an NPC reply. With this key it
    is possible to look up what the NPC needs to answer and construct new options
    for the player to choose from.'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `npcreply()` method uses the `NPC_Response` key, as shown in the following
    code, to look up the array number of the reply that the NPC will give in the `NPC_CON`
    array we constructed earlier in this chapter:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'As you might recall, there are only two arrays that together make up our entire
    conversation:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`NPC_CON`: This array constitutes everything our NPC has to say'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PC_CON`: This array constitutes everything our player can say'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the menu code, the key is stored in a local variable called `chosen_reply_key`
    and is then re-used in the following two ways:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To make the NPC reply
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To construct new options by inputting it as an argument to the `changechoices()`
    method
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, the `changechoices()` method takes in what the NPC has said, as shown
    in the following code, and constructs new options by going through the `PC_CON`
    array we built earlier in this chapter.
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The conversation is a loop, which theoretically can go on forever. However,
    we still need a start. We could do this by initializing our `Talkie` NPC menu
    with a few options in the `Talkie` NPC itself. This is a very pragmatic approach,
    but then again, so is the entire implementation of this conversation plugin, and
    you are free to adapt and extend it as you please.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: 'We still need to adjust our `Talkie` entity before we can start talking to
    him:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `talkie.js` file and add the following code to the file as properties:'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: We have now added a conversation menu for Talkie and initialized it at the first
    three options of our `PC_CON` array.
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now we need a function that checks whether Talkie was actually selected. Otherwise,
    there will be conflicts if we introduce several NPCs at the same time. To check
    if Talkie has been actually selected we write the following code:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The function will check where the mouse was clicked and correct its position
    for the game screen. No correction would be necessary if our level would perfectly
    fit into the viewport, but this is almost never the case, so a correction needs
    to take place. The function returns a `true` or `false` value. It returns the
    value `true` if the entity was selected, and returns `false` if it wasn't.
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In our `update()` method, we can now check for a mouse click and see if Talkie
    was actually selected using the following code:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: If it was, we set its brand new property `contexted` as `true`. In case Talkie
    wasn't selected, `contexted` is set to `false`.
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If the `Talkie` entity was clicked and there is a menu available, it will be
    drawn underneath the `Talkie` entity with the following code:'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Talkie is now ready to talk! Certainly try setting up your own conversation
    and see it unfold in your game.
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As a last useful plugin before we move on to discussing some advanced AI, we
    will add a nice bar, visually presenting the player''s health. However, before
    we do so, we will first recap the conversation plugin:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: We want to set up a conversation between our player and an NPC. For this, we
    will make use of the data we imported earlier in this chapter and a new plugin
    called `Menu`.
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `Menu` plugin consists of two parts: the menu itself and the options within
    the menu. We create both as an extension of the `ImpactJS` class.'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After setting up both the `Menu` plugin and the menu items, some extra adjustments
    need to be made to our friendly NPC Talkie. When the player clicks the `Talkie`
    entity with the mouse button, the menu, featuring several options, should appear
    underneath him. When one of the options is chosen, Talkie replies. To show the
    reply, we make use of the speech balloon, which we created in [Chapter 3](ch03.html
    "Chapter 3. Let's Build a Role Playing Game"), *Let's Build a Role Playing Game*.
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The entire conversation is a loop, which ends when either the player or the
    NPC runs out of sentences or the player just walks away.
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a basic Head-Up Display
  id: totrans-347
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our player has health, but he is not aware of how much or little he is left
    with at any given time. Because being aware of how much health you have left as
    a player is so vital, we are going to show this on the screen as both a number
    and a health bar. For this, we build ourselves the HUD plugin using the following
    steps:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: Open a new file and save it as `hud.js` under a `hud` subfolder of the `plugin`
    folder.
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `'plugins.hud.hud'` command to the `main.js` script.
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Start off by inserting the following code in the new `plugin` file:'
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'As usual, we define a new class based on the ImpactJS class. We initiate two
    variables: canvas and context, which will allow us to see whether the game is
    being viewed. Also, we initiate a `maxHealth` variable at a value `null`. However,
    unlike the usual condition, we use the inject technique as we did when we constructed
    our debug panel. When extending code, you create a new instance of that original
    code and supply it with a new name. It is, by all means, a copy of the original
    with the difference being the extra code you added. But while injecting, you modify
    the original code. In this case we overwrite the `draw()` function of our game.
    The `this.parent()` function points to our former `draw()` function, so everything
    which was already there is kept. What we add is the check for the presence of
    a player entity. If a player is in the game, a HUD is drawn. Our HUD is comprised
    of two parts: the number and the health bar.'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `number` function will draw a black and slightly transparent rectangle
    in which the health will be visible, using the following code:'
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'In the first part of our `number()` function, we define and draw the rectangle.
    Since it will need to be situated underneath the number, it needs to be drawn
    first. Unlike before, we are directly using canvas element''s properties to draw
    on the screen. The font, for instance, does not need to be set by using the ImpactJS
    `ig.font` function. As shown here, you can just write characters to the screen
    by directly addressing the canvas and setting the canvas'' `font` property. The
    canvas properties we use here are pretty straightforward and are listed as follows:'
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`fillstyle`: This property will set the color'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`font`: This property will set the font'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setAlpha()`: This property will set the transparency, with a value `1` being
    solid and `0` being fully transparent'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fillRect()`: This property will draw a rectangle to the screen at a given
    position with a given width and height'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fillText()`: This property will draw text on the screen at a certain position'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Our health bar function works in a similar way as that of the number function,
    as shown in the following code:'
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Here we draw two rectangles on top of each other. The bottom one is black at
    all times and is slightly transparent. The top rectangle is either blue or red,
    depending on how much health the player is left with. If the player's health value
    is `30` or higher, the bar will be blue, otherwise it will be red indicating impending
    demise.
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The size of the black transparent bottom bar is always the same, but its width
    depends on how much health a player has when he starts the game. This we can capture
    with the `setMaxHealth()` method as depicted in the following code:'
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'All we now need to do is initialize a HUD and feed it with the player''s health
    using our `setMaxHealth()` method. Add the following code to the `main.js` file:'
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: While reloading the game, we should now have a blue health bar and an indication
    that we have a **health** value of **100** left, as shown in the following screenshot:![Adding
    a basic Head-Up Display](img/4568_5_10.jpg)
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: However, after a small battle with our foes we can see by our red health bar
    that it is time to consult a doctor, as shown in the following screenshot:![Adding
    a basic Head-Up Display](img/4568_5_11.jpg)
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now that we took a look at some interesting extensions to [Chapter 3](ch03.html
    "Chapter 3. Let''s Build a Role Playing Game"), *Let''s Build a Role Playing Game*,
    let''s revisit our AI and introduce a new level of complexity. Before moving on,
    let''s quickly go over the way we constructed our HUD:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: A HUD or Head-Up Display offers a quick view on several key measures of the
    player, which help the player to be successful. In a shooter, this depicts how
    much ammo he is left with, both in total and in the current magazine. It can indicate
    other items or his overall score. Here we allow him to keep track of his health
    using a classic health bar.
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `hud` plugin is an extension of the ImpactJS class and has two elements:
    the health as a number and as a colored bar. They both have their separate methods
    within the `hud` plugin. You can extend the `hud` plugin yourself by adding new
    methods that represent other trackable statistics.'
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In building the HUD, we used the `canvas` properties as an alternative to using
    ImpactJS classes such as `ig.font`.
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Artificial intelligence: The hive mind'
  id: totrans-375
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 3](ch03.html "Chapter 3. Let''s Build a Role Playing Game"), *Let''s
    Build a Role Playing Game*, we already covered AI and why behavior should be separated
    from the process of decision making. We have also taken a look at strategies,
    but only applied a single strategy: attacking. Here we will set up a supplementary
    layer of intelligence that will decide which entity will follow which strategy.
    Because the decision making process takes into account all enemies in the same
    level, we call it hive mind intelligence. It is very similar to the queen of a
    beehive or the general on a battlefield who decides who should attack and who
    should stay put. The strategy decided in our hive mind is sent to the AI that
    we put in place during [Chapter 3](ch03.html "Chapter 3. Let''s Build a Role Playing
    Game"), *Let''s Build a Role Playing Game*, where it is interpreted and translated
    into behavior. The behavioral commands are in turn sent to the entity itself,
    which then acts upon them. Let''s create our general `ai` plugin using the following
    steps:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: Open a new file and save it as `general_ai.js`.
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Insert the `'plugins.ai.general_ai'` class in the `main.js` file.
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the `ig.general_ai` class as an ImpactJS class extension. Generally,
    the class `general_ai.js` has been created as shown in the following code:'
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The first thing we do is define the possible strategies. Here we will issue
    only two strategies: `Approach` or `Rest`.'
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `getStrategy()` function is located where our hive mind decides to keep
    it, and it is the function that shall be called by our AI in order to receive
    a strategy. This strategy is in turn translated into behavior using the following
    code:'
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The `getStrategy()` method contains our entire hive mind logic and consists
    of three main parts:'
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: First, a list of enemies and the player entity are each assigned to a local
    variable.
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These local variables are then used to calculate the distance between each enemy
    and the player for those enemies who have more than 100 health value. Every enemy
    below the health value of 100 is regarded to be weakened and too scared to attack.
    This code could be made more complex by adding personality to each enemy. We could,
    for example, initialize each enemy with a `courage` property, filled with a random
    number within the health range of our enemy; in our case this is `0` to `200`.
    This way we could decide whether a certain enemy feels bold enough to attack by
    comparing his current health with his courage instead of comparing with a fixed
    value. Certainly try this yourself; it adds depth and unpredictability to the
    game.
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, all enemies bold enough to attack are compared by their distance to
    the target, and only the closest of them will attack. The others are issued the
    `Rest` strategy and will only attack when they become the closest enemy around.
    As a player you should still be careful though. If none of them feel strong enough
    to attack on their own, they will join forces and attack together.
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In our previously built AI, we now need to call the `getStrategy()` function
    using the following code:'
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: If the strategy is `Approach`, the AI will translate this into the appropriate
    action.
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: If the strategy is something else, it is immediately translated into the `Rest`
    action. Because we only have these two strategies, this makes sense. If you have
    more strategies, you will need more checks.
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now that we have extended our AI to incorporate strategies, it is time to take
    a look at the final part of this chapter: implementing game analytics with Playtomic.
    Let''s quickly recap the hive mind AI before moving on:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: The hive mind is an overhead decision making organ, which will issue strategies
    to the different entities in the game. It is a way to make them act as part of
    a group rather than a bunch of unorganized individuals.
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In [Chapter 3](ch03.html "Chapter 3. Let's Build a Role Playing Game"), *Let's
    Build a Role Playing Game*, we had the decision-making process, which was translated
    into behavior. Now we have a strategy, which translates into individual decision
    making, which is in turn converted to behavior.
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The hive mind plugin is separate from our AI that we built in [Chapter 3](ch03.html
    "Chapter 3. Let's Build a Role Playing Game"), *Let's Build a Role Playing Game*.
    This way we can still return to our individualistic AI with only minor code corrections.
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The hive mind logic follows three main steps:'
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fetch all enemies and the player within the level.
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check the health value for each enemy to see if he is a viable candidate for
    an attack.
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From this list of viable enemies, choose the one who is closest to the player
    and let him attack. How the enemy will perform this attack is not specified by
    the general AI; this is a decision of the individual AI.
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing Playtomic for game analytics
  id: totrans-401
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Playtomic can be regarded as the Google Analytics for games. You can tag certain
    parts of your game and check if they are used often or not. For example, if you
    have a hidden level in your game, you would be able to see how many times and
    by how many different gamers it was discovered by tagging the `loadlevel()` function
    of this hidden level. Then you would be able to determine whether it might be
    too easy or too hard to discover, and adjust your game accordingly. But this is
    just one of the many ways you can apply game statistics. However, you need to
    be aware that tagging your game will tax its performance to a certain degree.
    And so, tagging every inch of code might not be as fertile a solution as intended.
    In addition, you would be left with massive amounts of data that you would then
    need to analyze, which could be a daunting task.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: In addition to supplying you with insights on your game usage, Playtomic allows
    you to store certain things on their server, such as scores, which you can turn
    into a leaderboard.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: If all of this sounds good to you, by all means go over to [https://playtomic.com/](https://playtomic.com/)
    and create yourself a free account.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: A few warnings are appropriate though. Playtomic is still in its infancy, and
    this translates into some bugs or illogical choices. For example, the default
    practice for saving a score in a leaderboard is not to overwrite the first one,
    even if the new one is higher. This doesn't make sense for a leaderboard and even
    the documentation indicates the default setting to be set on allowing score overwrites.
    Contacting the Playtomic server will slow down your game load, and often data
    is lost because no stable connection was made.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: 'But even though there are flaws in the implementation, server speed, and documentation,
    Playtomic is worth taking a look at if you want to gather insights about your
    game. The following screenshot depicts the data collected by Playtomic and its
    representation:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing Playtomic for game analytics](img/4568_5_12.jpg)'
  id: totrans-407
  prefs: []
  type: TYPE_IMG
- en: 'In order to implement Playtomic, there are a few things you will need to do:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: Create a Playtomic account and fetch your data transmission credentials. You
    will need these to set up a connection to their server.
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `index.html` file we will need to include the Playtomic source script
    as shown in the following code. Certainly check what the latest version is, at
    the time of installation. At the time of writing this book it was Version 2.2
    but these things develop fast.
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Open a new file and save it as `PlayTomic.js` under the `data` subfolder in
    the `plugins` folder. Here we will place the functions that we will need in order
    to work with Playtomic.
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Include this plugin file in our `main.js` script as shown in the following
    code line:'
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Define the `PlayTomic` plugin module using the following code:'
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Our new Playtomic class will have the task of saving the player's score on the
    Playtomic server. However, first a connection with the server needs to be established;
    this is done in the `init()` function. Inserting log messages at key moments is
    extremely useful when implementing and testing your Playtomic setup. You will
    need to fill out your own connection credentials in the highlighted part of the
    previous code.
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once we have a connection, we will need to send data. Since we are going to
    save the score, we need a `saveScore` method as shown in the following code:'
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: The `Playtomic` class has a **leaderboards** property to which you can save
    the player's score using its `save()` method. You will need to specify that you
    want to save to the high scores table and add the value of the score. You can
    name the table yourself in your **leaderboards** settings on the Playtomic website,
    as shown in the following screenshot:![Implementing Playtomic for game analytics](img/4568_5_13.jpg)
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We add an optional function that will give us feedback if the submit was successful.
    Keeping track of all the sent and received data is highly recommended while working
    with Playtomic. As a final parameter, we will allow duplicates on the leaderboard
    so that one person can have several scores on the board.
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `submitComplete()` function is just a way for us to keep track of whether
    a certain data transmission was successful or not:'
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'All that is left to do now is integrating our `PlayTomic` analytics, as shown
    in the following code, using the `GameInfo.saveScore()` function we built for
    saving scores with the lawnchair application:'
  id: totrans-424
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Our `saveScore()` method now not only saves the score locally by use of the
    lawnchair application, but also sends the result to the Playtomic server where
    it is put in a leaderboard, as shown in the following screenshot:![Implementing
    Playtomic for game analytics](img/4568_5_14.jpg)
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There is a lot more to Playtomic than was covered here but that will be up to
    you to discover in full. With this humble introduction, you should already feel
    confident in starting up your own game analytics. Though, be aware that privacy
    regulations apply and they are constantly changing. It is best to ask the player's
    permission to keep the game statistics and make sure you take this into account
    while implementing your Playtomic code.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: 'Summing up the complete process of introducing Playtomic in our game, we conclude
    that:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: Playtomic is the Google Analytics of mobile games and is free and relatively
    easy to implement.
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first thing you need after creating a Playtomic account is a connection
    to their script, which can be included in your `index.html` file.
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A connection to the Playtomic server needs to be established. This is done using
    the credentials of your account, though you are free to test with the credentials
    in the example code.
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The goal of this introduction was to send scores from our game platform to the
    Playtomic server where they can be represented in a leaderboard. For this we made
    our own Playtomic plugin.
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  id: totrans-433
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we have taken a look at some of the more advanced things you
    can do with your game, and applied them on the RPG that we designed in [Chapter
    3](ch03.html "Chapter 3. Let's Build a Role Playing Game"), *Let's Build a Role
    Playing Game*.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: We constructed an introductory, Victory, and Game-over screen and made our game
    prompt for the player's name so we could show it on the intro screen.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: We went deeper into how to debug code by unit testing and made our own ImpactJS
    debug panel. Then we took a look at handling data and ways to store it on the
    player's device. The RPG was extended with a few fun elements, such as a way to
    move the player by a mouse click, an intelligent spawnpoint, NPC conversation,
    and a health bar.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: Our AI was enhanced by introducing overhead strategy decision making, such as
    the hive mind. Finally we took a look at Playtomic and how to send the player
    scores to the Playtomic database.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter we will have a look at music and sound effects. The aim
    is to get the basic sounds and music needed to start making your first game.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
