- en: Chapter 4. Algorithms for Game Development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, the following recipes will be covered:'
  prefs: []
  type: TYPE_NORMAL
- en: Using sorting techniques to arrange items
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using searching techniques to look for an item
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding the complexity of an algorithm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding the endian-ness of a device
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using dynamic programming to break down a complex problem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using greedy algorithms to solve problems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using divide and conquer algorithms to solve problems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An algorithm refers to a list of steps that should be applied to perform a task.
    Searching and sorting algorithms are techniques with which we can search or sort
    elements in a container. A container, by itself, will have no advantage unless
    we can search items within that container. Based on certain containers, certain
    algorithms become more powerful for some containers than others. As an algorithm
    will run slower on a slower system and faster on a superior system, computation
    time is not an effective way to measure the effectiveness of an algorithm. Algorithms
    are rather measured as steps. Games are real-time applications, so the algorithms
    that will be applied have to be effective for games to be executed at least at
    30 frames per second. The ideal frame rate is 60 frames per second.
  prefs: []
  type: TYPE_NORMAL
- en: Using sorting techniques to arrange items
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sorting is a way to arrange items in a container. We can arrange them in ascending
    or descending order. If we have to implement the high score system and leader
    board of a game, sorting becomes necessary. In the game, the moment a user achieves
    a score higher than his previous highest score, we should update that value as
    the current highest score and push it to a local or online leader board. If it's
    local, we should arrange all the user's previous high scores in descending order
    and display the top 10 scores. If it is an online leader board, we need to sort
    all the users' latest high scores and display the result.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To work through this recipe, you will need a machine running Windows. You also
    need to have a working copy of Visual Studio installed on your Windows machine.
    No other prerequisites are required.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will find out how easy it is to arrange items in a container
    using different sorting techniques:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Visual Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new C++ project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Win32 Console Application**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a header file called `Sorting.h`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following lines of code to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example four sorting techniques have been used. The four techniques
    are **bubble** **sort**, **selection** **sort**, **insertion** **sort**, and **quick**
    **sort**.
  prefs: []
  type: TYPE_NORMAL
- en: '**Bubble sort** is a sorting algorithm that works by continuously traversing
    the container to be sorted, comparing each pair of adjacent items and swapping
    them if they are in the wrong order. The process is continued until no more swaps
    are required. The average, best, and worst case scenarios have the order of *O(n^2)*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Insertion sort** is a simple sorting algorithm, a comparison sort in which
    the sorted container is built one entry at a time. It is a very simple algorithm
    to implement. However, it is not so effective on large sets of data. The worst
    and average case scenarios have an order of *O(n^2)* and the best case scenario,
    when the container is sorted, has an order of *O(n)*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Selection sort** is an algorithm that attempts to place an item in its correct
    position in the sorted list at every pass. The best, worst, and average case scenarios
    have an order of *O(n^2)*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Quick sort** is an algorithm that creates a pivot and then sorts the container
    based on the pivot. Then the pivot is shifted and the process continues. Quick
    sort is a very effective algorithm and works on almost all real-world data and
    most modern architectures. It makes excellent use of memory hierarchy. Even the
    inbuilt standard template library uses a modified version of quick sort for its
    sorting algorithm. The best and average case scenarios for this algorithm are
    *O(n*log n)* and the worst case is *O(n^2)*.'
  prefs: []
  type: TYPE_NORMAL
- en: Using searching techniques to look for an item
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Searching techniques are a group of algorithms that involve the process of looking
    for an item in a container. Searching and sorting go hand in hand. A sorted container
    will be easier to search. After a container is sorted or ordered, we can apply
    an appropriate searching algorithm to find an element. Suppose we need to find
    the names of the guns that have been used to kill more than 25 enemies. If the
    container stores the values of the name of the gun and total kills associated
    with that gun, all we need to do is to first sort that container in ascending
    number of kills made by the guns. Then we can do a linear search in which we find
    the first gun that has more than 25 kills. Correspondingly, the next items in
    the container after that will have more than 25 kills, as the container is sorted.
    However, we can apply better searching techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to have a working copy of Visual Studio installed on your Windows machine.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will find out how we can easily apply searching algorithms
    to our program:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Visual Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new C++ project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Win32 Console Application**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a source file called `Source.cpp`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following lines of code to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Searching for items in a container can be done in many ways. However, it matters
    a lot whether the container has been sorted or not. Let us assume that the container
    is sorted. The worst way to search for an item is to traverse the whole container
    and search for the item. This will take a lot of time for large data sets and
    is absolutely not advisable in games programming. A better way to search for an
    item is by using binary searching. Binary searching works by dividing the container
    into two halves. It checks at the midpoint if the value to be searched is less
    than or greater than the midpoint value. If it is greater, we can ignore the first
    half of the container and continue searching only in the second half. Again repeat
    the process for the second half, by further dividing into two halves. Consequently,
    by doing this we can reduce the search space of the algorithm immensely. The order
    of this algorithm is O(log n).
  prefs: []
  type: TYPE_NORMAL
- en: Finding the complexity of an algorithm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need an effective way to measure algorithms. That way we will find out whether
    our algorithm is effective or not. An algorithm will work more slowly on slower
    machines and more quickly on faster machines, so computation time is not an effective
    way to measure algorithms. Algorithms should rather be measured as a number of
    steps. We call that the order of the algorithm. We also need to find out the best
    case, worst case, and average case scenarios for the order of the algorithm. This
    will give us a clearer picture of how our algorithm will be applied to small sets
    of data and larger sets of data. Complex algorithms or algorithms of a higher
    order should be avoided, as these will increase the number of steps that the device
    will need to do to perform the task, and hence will slow down the application.
    Also, debugging becomes difficult with such algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to have a working copy of Visual Studio installed on your Windows machine.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we will find out how easy it is to find the complexity of an
    algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Open Visual Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new C++ project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Win32 Console Application**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a source file called `Source.cpp`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following lines of code to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, we can see how the order of an algorithm, or the "Big O" notation,
    varies with implementation. If we take the first function, `Cubic_Order`, the
    innermost implementation will take *n*n*n* steps to find the answer. So it has
    an order of n-cubed, *O(n^3)*. This is really bad. Imagine if n is a really large
    data set, for example let's say *n =1000*, it will take 1,000,000,000 steps to
    find the solution. Avoid cubic order algorithms whenever you can. The second function,
    `square_order`, has a square order. The innermost implementation will take *n*n*
    steps to find a solution, so the order of that algorithm is *O(n^2)*. This is,
    again, bad practice.
  prefs: []
  type: TYPE_NORMAL
- en: We should attempt to achieve at least *O(log N)* complexity. We can achieve
    log *N* complexity if we continuously decrease the search space by half, for example,
    by using binary searching. There are order algorithms that achieve *O (log N)*,
    which is greatly optimized.
  prefs: []
  type: TYPE_NORMAL
- en: As a general rule, all algorithms following *divide and conquer* will have *O
    (log N)* complexity.
  prefs: []
  type: TYPE_NORMAL
- en: Finding the endian-ness of a device
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The endian-ness of a platform refers to the way the most significant byte is
    stored on that device. This information is highly important as many algorithms
    can be optimized based on this information. Notably, the two most popular rendering
    SDKs, DirectX and OpenGL, differ in their endian-ness. The two different types
    of endian-ness are called big endian and little endian.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, you will need a Windows machine with a working copy of Visual
    Studio.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we will find out how easy it is to find the endian-ness of a
    device.
  prefs: []
  type: TYPE_NORMAL
- en: Open Visual Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new C++ project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Win32 Console Application**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a source file called `Source.cpp`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following lines of code to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Little and big endian are two different ways in which multibyte data types are
    stored on different machines. In little endian machines, the least significant
    byte of the multibyte data type is stored first. On the other hand, in big endian
    machines, the most significant byte of binary representation of the multibyte
    data type is stored first.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding program, a character pointer `c` is pointing to an integer
    `i`. Since the size of character is 1 byte when the character pointer is dereferenced,
    it will contain only the first byte of the integer. If the machine is little endian,
    then `*c` will be `1` (because the last byte is stored first), and if the machine
    is big endian then `*c` will be 0.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose the integer is stored as 4 bytes; then, a variable `x` with value 0x01234567
    will be stored as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/Endian.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Most of the time, a compiler takes care of endian-ness; however, endian-ness
    becomes an issue in network programming if we are sending data from a little endian
    machine to a big endian machine. Also, it becomes an issue if we switch our rendering
    pipeline from DirectX to OpenGL.
  prefs: []
  type: TYPE_NORMAL
- en: Using dynamic programming to break down a complex problem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dynamic programming is a very modern way to solve problems. The process involves
    breaking a big problem into smaller chunks of problems, finding solutions for
    those chunks and repeating the process to solve the entire complex problem. It
    is a bit difficult to grasp this technique at first, but with sufficient practice
    any problem can be solved using dynamic programming. Most of the problems we will
    encounter while programming a video game will be complex. Hence, mastering this
    technique will be really useful.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, you will need a Windows machine with a working copy of Visual
    Studio.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will find out how easy it is to use dynamic programming
    to solve a problem:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Visual Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new C++ project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Win32 Console Application**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a source file called `Source.cpp`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following lines of code to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is an example of the classical *knapsack* problem. This can be applied
    to many scenarios in game programming, especially for AI resource management.
    Let us consider that the total weight (sack) that the AI can carry is a constant.
    In our example, this is the total weight of the knapsack. Every item that the
    AI collects in the game has a weight and a value. The AI now needs to decide how
    to fill up his inventory/sack so that he can sell the total sack for maximum value
    and get coins.
  prefs: []
  type: TYPE_NORMAL
- en: We solve the problem by recursion by solving for every small combination of
    items (weight and value) and checking for the maximum value of the two combinations,
    and repeating the process until the total weight of the knapsack is reached.
  prefs: []
  type: TYPE_NORMAL
- en: Using greedy algorithms to solve problems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A greedy algorithm works by finding the optimal solution at every stage. So
    before processing the next step, it will decide its next step based on the previous
    outcome and the current needs of the application. In this way, it is better than
    dynamic programming. However, we cannot apply this principle to all problems,
    hence a greedy algorithm cannot be used for all situations.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To go through this recipe, you will need a machine running Windows. You also
    need to have a working copy of Visual Studio installed on your Windows machine.
    No other prerequisites are required.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will find out how easy it is to use greedy algorithm to
    solve a problem:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Visual Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new C++ project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Win32 Console Application**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `Source.cpp` files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following lines of code to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, we have a set of start times and finish times for different
    activities. We need to find out which activities can be performed by a single
    person. We can assume that the container is already sorted based on the finish
    time. So at every pass, we check whether the current start time is greater than
    or equal to the previous finish time. Only then can we take up the task. We traverse
    the container and keep checking the same condition. Because we are checking at
    every step, this algorithm is pretty well optimized.
  prefs: []
  type: TYPE_NORMAL
- en: Using divide and conquer algorithms to solve problems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In general, divide and conquer is based on the following idea. The whole problem
    we want to solve may be too big to understand or solve at once. We break it up
    into smaller pieces, solve the pieces separately, and combine the separate pieces.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, you will need a Windows machine with a working copy of Visual
    Studio.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will find out how easy it is to use a greedy algorithm to
    solve a problem:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Visual Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new C++ project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a source file called `Source.cpp`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following lines of code to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A **heap sorting** **algorithm** works by first organizing the data to be sorted
    into a special type of binary tree called a **heap**. The heap itself has, by
    definition, the largest value at the top of the tree, so the heap sorting algorithm
    must also reverse the order. It does this with the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Remove the topmost item (the largest) and replace it with the rightmost leaf.
    The topmost item is stored in an array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Re-establish the heap.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat steps 1 and 2 until there are no more items left in the heap. The sorted
    elements are now stored in an array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
