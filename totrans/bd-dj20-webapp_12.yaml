- en: Building an API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that Mail Ape can send emails to our subscribers, let's make it easier for
    our users to integrate with Mail Ape using an API. In this chapter, we will build
    a RESTful JSON API that will let users create mailing lists and add subscribers
    to a mailing list. To simplify creating our API, we will use the **Django REST
    framework** (**DRF**). Finally, we'll access our API on the command line using
    curl.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will do the following things:'
  prefs: []
  type: TYPE_NORMAL
- en: Summarize the core concepts of DRF
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create `Serializer`s that define how to parse and serialize `MailingList` and
    `Subscriber` models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a permission class to restrict API to users who are`MailingList` owners
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the Django REST framework's class-based views to create the views for our
    API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Access our API over HTTP using curl
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test our API in a unit test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start this chapter with DRF.
  prefs: []
  type: TYPE_NORMAL
- en: Starting with the Django REST framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll start by installing DRF and then reviewing its configuration. As we review
    the DRF configuration, we'll learn about the features and concepts that make it
    useful.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the Django REST framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start by adding DRF to our `requirements.txt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we can install it using `pip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have the library installed, let''s add DRF to our `INSTALLED_APPS`
    list in the `django/mailinglist/settings.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Configuring the Django REST Framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: DRF is highly configurable through its view classes. However, we can avoid repeating
    the same common settings across all our DRF views using DRF's settings in our
    `settings.py` file.
  prefs: []
  type: TYPE_NORMAL
- en: All of DRF's features project out from how DRF handles views. DRF provides a
    rich collection of views that extend `APIView` (which in turn extends Django's
    `View` class). Let's look at the APIView's life cycle and the related settings.
  prefs: []
  type: TYPE_NORMAL
- en: 'A DRF view''s life cycle perform the following actions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Wrap Django''s request object in the DRF request object**: DRF has a specialized
    `Request` class that wraps Django''s `Request` class, as will be discussed in
    the following sections.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Perform content negotiation**: Find the request parser and response renderer.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Perform authentication**: Check the credentials associated with the request.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Check permissions**: Checks whether the user associated with the request
    can access this view.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Check throttles**: Checks whether there haven''t been too many requests recently
    by this user.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Execute the view handler**: Performs the action associated with the view
    (for example, creating the resource, querying the database, and so on).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Render the response**: Renders the response to the correct content type.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: DRF's custom `Request` class is much like Django's `Request` class, except that
    it can be configured with a parser. A DRF view finds the correct parser for the
    request based on the view's settings and the content type of the request during
    content negotiation. The parsed contents are available as `request.data` just
    like a Django request with a `POST` form submission.
  prefs: []
  type: TYPE_NORMAL
- en: DRF views also use a specialized `Response` class that uses a render instead
    of a Django template. The renderer is selected during the content negotiation
    step.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most of the preceding steps are performed using configurable classes. DRF is
    configurable by creating a dictionary in our project''s `settings.py` under the
    name `REST_FRAMEWORK`. Let''s review some of the most important settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '`DEFAULT_PARSER_CLASSES`: This supports JSON, forms and multipart forms by
    default. Other parsers (for example, YAML and MessageBuffer) are available as
    third-party community packages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DEFAULT_AUTHENTICATION_CLASSES`: This supports session-based authentication
    and HTTP basic authentication by default. Session authentication can make using
    your API in your app''s frontend easier. DRF ships with a token authentication
    class. OAuth (1 and 2) support is available through third-party community packages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DEFAULT_PERMISSION_CLASSES`: This defaults to allowing any user to any action
    (including update and delete operations). DRF ships with a collection of stricter
    permissions listed in the documentation ([https://www.django-rest-framework.org/api-guide/permissions/#api-reference](https://www.django-rest-framework.org/api-guide/permissions/#api-reference)).
    We''ll also take a look at how to create a custom permission class later in this
    chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DEFAULT_THROTTLE_CLASSES`/`DEFAULT_THROTTLE_RATES`: This is empty (unthrottled)
    by default. DRF offers a simple throttling scheme, letting us set different rates
    for anonymous requests and user requests out of the box.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DEFAULT_RENDERER_CLASSES`: This defaults to JSON and a *browsable* template
    renderer. The browsable template renderer makes a simple UI for view and testing
    your views, suitable to development.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will configure our DRF to be a bit stricter, even in development. Let''s
    update `django/config/settings.py` with the following new setting `dict`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This configuration restricts the API to authenticated users by default and sets
    a throttle on their requests. Authenticated users can make 60 requests per minute
    before being throttled. Unauthenticated users can make 30 requests per minute.
    DRF accepts throttle periods of `second`, `minute`, `hour`, or `day`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's take a look at DRF `Serializer`s.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Django REST Framework Serializers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a DRF parser parses a request's body, the parser basically returns a Python
    dictionary. However, before we can perform any operation on that data, we will
    need to confirm that the data is valid. In our previous Django views, we'd use
    a Django form. In DRF, we use a `Serializer` class.
  prefs: []
  type: TYPE_NORMAL
- en: DRF `Serializer` classes are very similar to Django form classes. Both are involved
    in receiving validation data and preparing models for output. However, a `Serializer` class
    doesn't know how to render its data, unlike a Django form that does. Remember
    that in a DRF view, the renderers are responsible for rendering the result into
    JSON or whatever format was negotiated by the request.
  prefs: []
  type: TYPE_NORMAL
- en: Much like a Django form, a `Serializer` can be created to work on an arbitrary
    data or be based on a Django Model. Also, `Serializer` is composed of a collection
    of fields that we can use to control serialization. When a `Serializer` is related
    to a model, the Django REST framework knows which serializer `Field` to use for
    which model `Field`, similar to how `ModelForm`s work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a `Serializer` for our `MailingList` model in `django/mailinglist/serializers.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This seems very similar to how we wrote `ModelForm`s; let''s take a closer
    look:'
  prefs: []
  type: TYPE_NORMAL
- en: '`HyperlinkedModelSerializer`: This is the `Serializer` class that shows a hyperlink
    to any related model, so when it shows the related `Subscriber` model instances of
    a `MailingList`, it will show a link (URL) to that instance''s detail view.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`owner = serializers.PrimaryKeyRelatedField(...)`: This changes the field for
    serializing the model''s `owner` field. The `PrimaryKeyRelatedField` returns the
    related object''s primary key. This is useful when the related model doesn''t
    have a serializer or a related API view (like the user model in Mail Ape).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`model = MailingList`: Tells our `Serializer` which mode it''s serializing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fields = (''url'', ''id'', ...)`: This lists the model''s fields to serialize.
    The `HyperlinkedModelSerializer` includes an extra field `url`, which is the URL
    to the serialized model''s detail view. Much like with a Django `ModelForm`, a
    `ModelSerializer` class (such as `HyperlinkedModelSerializer`) has a set of default
    serializer fields for each model field. In our case, we''ve decided to override
    how `owner` is represented (refer to the preceding point about the `owner` attribute).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`read_only_fields = (''subscriber_set'', )`: This concisely lists which fields
    may not be modified. In our case, this prevents users from tampering with the
    mailing list a `Subscriber` is in.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`extra_kwargs`: This dictionary lets us provide extra arguments to each field''s
    constructor without overriding the entire field. This is usually done to provide
    a `view_name` argument which is needed to look up the URL to a view.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''url'': {''view_name'': ''...''},`: This provides the name of the `MailingList`
    API detail view.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''subscriber_set'': {''view_name'': ''...''},`: This provides the name of
    the `Subscriber` API detail view.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are actually two ways of marking a `Serializer`'s field read only. One
    way is using the `read_only_fields` attribute as in the preceding code sample.
    Another is to pass `read_only=True` as an argument to a `Field` class's constructor
    (for example, `email = serializers.EmailField(max_length=240, read_only=True)`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we''ll create two serializers for our `Subscriber` model. Our two subscribers
    are going to have one difference: whether `Subscriber.email` is editable. We will
    need to let users write to `Subscriber.email` when they''re creating `Subscriber`.
    However, we don''t want them to be able to change the email after they''ve created
    the user.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s create a `Serializer` for the `Subscription` model in `django/mailinglist/serialiers.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `SubscriberSerializer` is just like our `MailingListSerializer`. We use
    many of the same elements:'
  prefs: []
  type: TYPE_NORMAL
- en: Subclassing `serializers.HyperlinkedModelSerializer`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Declaring the related model using an inner `Meta` class's `model` attribute
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Declaring the related model's fields using an inner `Meta` class's `fields`
    attribute
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Giving the related model's detail view's name using the `extra_kwargs` dictionary
    and the `view_name` key.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For our next `Serializer` class, we''ll create one just like `SubscriberSerializer`
    but make the `email` field read only; let''s add it to `django/mailinglist/serialiers.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This `Serializer` lets us update whether a `Subscriber` is `confirmed` or not,
    but it won't let the `Subscriber`'s `email` field change.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've create a few `Serializers`, we can see how similar they are to
    Django's built-in `ModelForm`s. Next, let's create a `Permission` class to prevent
    a user from accessing each other's `MailingList` and `Subscriber` model instances.
  prefs: []
  type: TYPE_NORMAL
- en: API permissions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll create a permission class that the Django REST framework
    will use to check whether a user may perform an operation on a `MailingList` or
    `Subscriber`. This will perform a very similar role to the `UserCanUseMailingList`
    mixin we created in [Chapter 10](4c521041-4786-4a7f-bcaf-f44e3c5abedc.xhtml),
    Starting Mail Ape.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create our `CanUseMailingList` class in `django/mailinglist/permissions.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a closer look at some of the new elements introduced in our `CanUseMailingList` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '`BasePermission`: Provides the basic contract of a permission class, implementing
    the `has_permission()` and `has_object_permission()` methods to always return
    `True`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`message`: This is the message that the `403` response body'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`def has_object_permission(...)`: Checks whether the request''s user is the
    owner of the related `MailingList`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `CanUseMailingList` class doesn't override `BasePermission.has_permission(self,
    request, view)` because the permissions in our system are both at the object level
    rather than the view or model level.
  prefs: []
  type: TYPE_NORMAL
- en: If you need a more dynamic permission system, you may want to use Django's built-in
    permission system ([https://docs.djangoproject.com/en/2.0/topics/auth/default/#permissions-and-authorization](https://docs.djangoproject.com/en/2.0/topics/auth/default/#permissions-and-authorization))
    or Django Guardian ([https://github.com/django-guardian/django-guardian](https://github.com/django-guardian/django-guardian)).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our `Serializer`s and permission class, we will write our API
    views.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our API views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll create the actual views that define Mail Ape's RESTful
    API. The Django REST framework offers a collection of class-based views that are
    similar to Django's suite of class-based views. One of the main differences between
    the DRF generic views and the Django generic views is how they combine multiple
    operations in a single view class. For example, DRF offers the `ListCreateAPIView`
    class but Django only offers a `ListView` class and a `CreateView` class. DRF
    offers a `ListCreateAPIView` class because a resource at `/api/v1/mailinglists`
    would be expected to provide both a list of `MailingList` model instances and
    a creation endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: Django REST Framework also offers a suite of function decorators ([http://www.django-rest-framework.org/api-guide/views/#function-based-views](http://www.django-rest-framework.org/api-guide/views/#function-based-views))
    so that you use function-based views too.
  prefs: []
  type: TYPE_NORMAL
- en: Let's learn more about DRF views by creating our API, starting with the `MailingList`
    API views.
  prefs: []
  type: TYPE_NORMAL
- en: Creating MailingList API views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Mail Ape will provide an API to create, read, update, and delete `MailingList`s.
    To support these operations, we will create the following two views:'
  prefs: []
  type: TYPE_NORMAL
- en: A `MailingListCreateListView` that extends `ListCreateAPIView`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `MailingListRetrieveUpdateDestroyView` that extends `RetrieveUpdateDestroyAPIView`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Listing MailingLists by API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To support getting a list of a user''s `MailingList` model instances and creating
    new `MailingList` model instances, we will create the `MailingListCreateListView` class
    in `django/mailinglist/views.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s review our `MailingListCreateListView` class in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ListCreateAPIView`: This is the DRF generic view we extend. It responds to
    `GET` requests with the serialized contents returned by the `get_queryset()` method.
    When it receives a `POST` request, it will create and return a `MailingList` model
    instance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`permission_classes`: This is a collection of permission classes that will
    be called in an order. If `IsAuthenticated` fails, then `IsOwnerPermission` won''t
    be called.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`serializer_class = MailingListSerializer`: This is the serializer this view
    uses.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`def get_queryset(self)`: This is used to get a `QuerySet` of models to serialize
    and return.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`def get_serializer(...)`: This is used to get the serializer instance. In
    our case, we''re overriding the owner (if any) that we received as input from
    the request with the currently logged in user. By doing so, we ensure that a user
    can''t create a mailing list owned by another. This is very similar to how we
    might override `get_initial()` in a Django form view (for example, refer to the `CreateMessageView` class
    from [Chapter 10](4c521041-4786-4a7f-bcaf-f44e3c5abedc.xhtml), *Starting Mail
    Ape*).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that we have our view, let''s add it to our URLConf in `django/mailinglist/urls.py`
    with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can create and list `MailingList` model instances by sending a request
    to `/mailinglist/api/v1/mailing-list`.
  prefs: []
  type: TYPE_NORMAL
- en: Editing a mailing list via an API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next, let''s add a view to view, update, and delete a single `MailingList` model
    instance by adding a new view to `django/mailinglist/views.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '`MailingListRetrieveUpdateDestroyView` looks very similar to our previous view
    but extends the `RetrieveUpdateDestroyAPIView` class. Like Django''s built-in
    `DetailView`, `RetrieveUpdateDestroyAPIView` expects that it will receive the
    `pk` of the `MailingList` model instance it is to operate on in the request''s
    path. `RetrieveUpdateDestroyAPIView` knows how to handle a variety of HTTP methods:'
  prefs: []
  type: TYPE_NORMAL
- en: On a `GET` request, it retrieves the model identified by the `pk` argument
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On a `PUT` request, it overwrites all the fields of the model identified by
    the `pk` with the fields received in the argument
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On a `PATCH` request, it overwrites only the fields received in the request
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On a `DELETE` request, it deletes the model identified by the `pk`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any updates (whether by `PUT` or by `PATCH`) are validated by the `MailingListSerializer`.
  prefs: []
  type: TYPE_NORMAL
- en: Another difference is that we define a `queryset` attribute for the view (`MailingList.objects.all()`)
    instead of a `get_queryset()` method. We don't need to restrict our `QuerySet`
    dynamically because the `CanUseMailingList` class will protect us from users editing/viewing
    `MailingLists` they don't have permission to access.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like before, we now need to connect our view to our app''s URLConf in
    `django/mailinglist/urls.py` with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Note that we parse the `<uuid:pk>` argument out of the request's path just like
    we do with some of Django's regular views that operate on a single model instance.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our `MailingList` API, let's allow our users to manage `Subscriber`s
    by API as well.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Subscriber API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we''ll create an API to manage `Subscriber` model instances.
    This API will be powered by two views:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SubscriberListCreateView` to list and create `Subscriber` model instances'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SubscriberRetrieveUpdateDestroyView` to retrieve, update, and delete a `Subscriber`
    model instance'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Listing and Creating Subscribers API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Subscriber` model instances have an interesting difference from `MailingList` model
    instances in that `Subscriber` model instances are not directly related to a user.
    To get a list of `Subscriber` model instances, we need to know which `MailingList` model
    instance we should query. `Subscriber` model instance creation faces the same
    question, so both these operations will have to receive a related `MailingList`''s
    `pk` to execute.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with our by creating our `SubscriberListCreateView` in `django/mailinglist/views.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `SubscriberListCreateView` class has much in common with our `MailingListCreateListView` class,
    including the same base class and `permission_classes` attribute. Let''s take
    a closer look at some of the differences:'
  prefs: []
  type: TYPE_NORMAL
- en: '`serializer_class`: Uses a `SubscriberSerializer`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`get_queryset()`: Checks whether the related `MailingList` model instance identified
    in the URL exists before returning a `QuerySet` of all the related `Subscriber` model
    instances.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`get_serializer()`: Ensures the new `Subscriber` is associated with the `MailingList`
    in the URL. We use the `reverse()` function to identify the associated `MailingList` model
    instance because the `SubscriberSerializer` class is inherits from the `HyperlinkedModelSerializer` class. `HyperlinkedModelSerializer`
    wants related models to be identified by a hyperlink or path (not a `pk`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, we will add a `path()` object for our `SubscriberListCreateView` class
    to the URLConf in `django/mailinglist/urls.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: When adding a `path()` object for our `SubscriberListCreateView` class, we will
    need to ensure that we have a `mailing_list_pk` parameter. This lets `SubscriberListCreateView`
    know which `Subscriber` model instances to operate on.
  prefs: []
  type: TYPE_NORMAL
- en: Our users are now able to add `Subscriber` s to their `MailingList` via our
    RESTful API. Adding a user to our API will then trigger a confirmation email because
    `Subscriber.save()` will be called by our `SubscriberSerializer`. Our API doesn't
    need to know how to send emails because our *fat model* is the expert on the behavior
    of `Subscriber`.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, this API does present a potential bug in Mail Ape. Our current API
    lets us add a `Subscriber` who has been already confirmed. However, our `Subscriber.save()` method
    will send a confirmation email to the email address of all new `Subscriber` model
    instances. This can lead to us spamming the already confirmed `Subscriber`s. To
    fix this bug, let''s update `Subscriber.save` in `django/mailinglist/models.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Now, we're only calling `self.send_confirmation_email()` if we're saving a new
    *and* unconfirmed `Subscriber` model instance.
  prefs: []
  type: TYPE_NORMAL
- en: Great! Now, let's create a view to retrieve, update, and delete a `Subscriber` model
    instance.
  prefs: []
  type: TYPE_NORMAL
- en: Updating subscribers via an API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, that we have created and list API operations for Subscriber model instances,
    we can create an API view for retrieving, updating, and deleting a single `Subscriber` model
    instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add our view to `django/mailinglist/views.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `SubscriberRetrieveUpdateDestroyView` is very similar to our `MailingListRetrieveUpdateDestroyView`
    view. Both inherit from the same `RetrieveUpdateDestroyAPIView` class to provide
    the core behavior in response to HTTP requests and use the same `permission_classes`
    list. `SubscriberRetrieveUpdateDestroyView` however has two differences:'
  prefs: []
  type: TYPE_NORMAL
- en: '`serializer_class = ReadOnlyEmailSubscriberSerializer`: This is a different
    `Serializer`. In the case of updates, we don''t want the user to be able to change
    email addresses.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`queryset = Subscriber.objects.all()`: This is a `QuerySet` of all `Subscribers`.
    We don''t need to restrict the `QuerySet` because the `CanUseMailingList` will
    prevent unauthorized access.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, let''s make sure that we can route to it by adding it to the `urlpatterns`
    list in `django/mailinglist/urls.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have our views, let's try interacting with it on the command line.
  prefs: []
  type: TYPE_NORMAL
- en: Running our API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we''ll run Mail Ape on the command line and interact with
    our API on the command line using `curl`, a popular command-line tool used for
    interacting with servers. In this section, we will perform the following functions:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a user on the command line
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a mailing list on the command line
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting a list of `MailingList` s on the command line
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a `Subscriber` on the command line
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting a list of `Subscriber` s on the command line
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s start by creating our user using the Django `manage.py shell` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: If you've already registered a user using the web interface, you can use that
    user. Also, never use `secret` as your password in production.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a user who we can use on the command line, let''s start our
    local Django server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that our server is running, we can open a different shell and get a list
    of `MailingList` s for our user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a closer look at our command:'
  prefs: []
  type: TYPE_NORMAL
- en: '`curl`: This is the tool we''re using.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"http://... api/v1/mailing-list"`: This is the URL we''re sending our request
    to.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-u ''user:secret''`: This is the basic authentication credentials. `curl`
    takes care of encoding these correctly for us.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[]`: This is an empty JSON list returned by the server. In our case, `user`
    doesn''t have any `MailingList`s yet.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We get a JSON response because the Django REST framework is configured to use
    JSON rendering by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a `MailingList` for our user, we will need to send a `POST` request
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a much longer command with a proportionately longer result. Let''s
    take a look at each new argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-H ''Content-Type: application/json; charset=utf-8'' \`: This adds a new HTTP
    `Content-Type` header to tell the server to parse the body as JSON.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-d $''{ ... }''`: This specifies the body of the request. In our case, we''re
    sending a JSON object with the name of the new mailing list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"url":"http://...cd983e25-c6c8-48fa-9afa-1fd5627de9f1"`: This is the URL for
    the full details of the new `MailingLIst`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"name":"New List"`: This shows the name of the new list that we requested.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"owner":2`: This shows the ID of the owner of the list. This matches the ID
    of the user we created earlier and included in this request (using `-u`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"subscriber_set":[]`: This shows that there are no subscribers in this mailing
    list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can now repeat our initial request to list `MailingList`s and check whether
    our new `MailingList` is included:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Seeing that we can run our server and API in development is great, but we don't
    want to always rely on manual testing. Let's take a look at how to automate testing
    our API next.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to test creating subscribers, make sure that your Celery broker
    (for example, Redis) is running and that you've got a worker consuming tasks to
    get the full experience.
  prefs: []
  type: TYPE_NORMAL
- en: Testing your API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: APIs provide value to our users by letting them automate their interactions
    with our service. Naturally, DRF helps us automate testing our code as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'DRF provides replacements for all the common Django tools we discussed in [Chapter
    8](20763fd1-7b33-43c7-bb4b-a5b919e84048.xhtml), *Testing Answerly*:'
  prefs: []
  type: TYPE_NORMAL
- en: '`APIRequestFactory` for Django''s `RequestFactory` class'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`APIClient` for Django''s `Client` class'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`APITestCase` for Django''s `TestCase` class'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`APIRequestFactory` and `APIClient` make it easier to send requests formatted
    for our API. For example, they provide an easy way to set credentials for a request
    that isn''t relying on session-based authentication. Otherwise, the two classes
    serve the same purpose as their default Django equivalents.'
  prefs: []
  type: TYPE_NORMAL
- en: The `APITestCase` class simply extends Django's `TestCase` class and replaces
    Django's `Client` with `APIClient`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at an example that we can add to `django/mailinglist/tests.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a closer look at the new code introduced in our `ListMailingListsWithAPITestCase` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '`class ListMailingListsWithAPITestCase(APITestCase)`: This makes `APITestCase`
    our parent class. The `APITestCase` class is basically a `TestCase` class with
    an `APIClient` object instead of the regular Django `Client` object assigned to
    the `client` attribute. We will use this class to test our view.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`base64.b64encode(...)`: This does a base64 encoding of our username and password.
    We''ll use this to provide an HTTP basic authentication header. We must use `base64.b64encode()`
    instead of `base64.base64()` because the latter introduces white space to visually
    break up long strings. Also, we will need to `encode`/`decode` our strings because
    `b64encode()` operates on `byte` objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`client.credentials()`: This lets us set an authentication header to be sent
    all future requests by this `client` object. In our case, we''re sending an HTTP
    basic authentication header.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`json.loads(response.content)`: This parses the content body of the response
    return a Python list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`self.assertEqual(3, len(parsed))`: This confirms that the number of items
    in the parsed list is correct.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we were to send a second request using `self.client`, we would not need to
    re-authenticate because `client.credentials()` remembers what it received and
    continues passing it to all requests. We can clear the credentials by calling
    `client.credentials()`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we know how to test our API code!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered how to use the Django REST framework to create an
    RESTful API for our Django project. We saw how the Django REST framework uses
    similar principles to Django forms and Django generic views. We also used some
    of the core classes in the Django REST framework, we used a `ModelSerializer` to
    build a `Serializer` based on a Django models, and we used a `ListCreateAPIView`
    to create a view that can list and create Django models We used `RetrieveUpdateDestroyAPIView`
    to manage a Django model instance based on its primary key.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we'll deploy our code to the internet using Amazon Web Services.
  prefs: []
  type: TYPE_NORMAL
