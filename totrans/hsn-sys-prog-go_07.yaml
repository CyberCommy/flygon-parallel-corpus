- en: Handling Streams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter deals with streams of data, extending input and output interfaces
    beyond the filesystem, and how to implement custom readers and writers to serve
    any purpose.
  prefs: []
  type: TYPE_NORMAL
- en: It also focuses on the missing parts of the input and output utilities that
    combine them in several different ways, with the goal being to have full control
    of the incoming and outgoing data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Streams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom readers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom writers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utilities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter requires Go to be installed and your favorite editor to be set
    up. For more information, refer to [Chapter 3](602a92d5-25f7-46b8-83d4-10c6af1c6750.xhtml),
    *An Overview of Go*.
  prefs: []
  type: TYPE_NORMAL
- en: Streams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Writers and readers are not just for files; they are interfaces that abstract
    flows of data in one direction or another. These flows, often referred to as **streams**, are
    an essential part of most applications.
  prefs: []
  type: TYPE_NORMAL
- en: Input and readers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Incoming streams of data are considered the `io.Reader` interface if the application
    has no control over the data flow, and will wait for an error to end the process,
    receiving the `io.EOF` value in the best case scenario, which is a special error
    that signals that there is no more content to read, or another error otherwise.
    The other option is that the reader is also capable of terminating the stream.
    In this case, the correct representation is the `io.ReadCloser` interface.
  prefs: []
  type: TYPE_NORMAL
- en: Besides `os.File`, there are several implementations of readers spread across
    the standard package.
  prefs: []
  type: TYPE_NORMAL
- en: The bytes reader
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `bytes` package contains a useful structure that treats a slice of bytes
    as an `io.Reader` interface, and it implements many more I/O interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '`io.Reader`: This can act as a regular reader'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`io.ReaderAt`: This makes it possible to read from a certain position onward'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`io.WriterTo`: This makes it possible to write the contents with an offset'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`io.Seeker`: This can move the reader''s cursor freely'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`io.ByteScanner`: This can execute a read operation for each byte separately'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`io.RuneScanner`: This can do the same with characters that are made of more
    bytes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The difference between runes and bytes can be clarified by this example, where
    we have a string made up of one rune, `⌘`, which is represented by three bytes, `e28c98`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The full example is available at [https://play.golang.org/p/gVZOufSmlq1](https://play.golang.org/p/gVZOufSmlq1).
  prefs: []
  type: TYPE_NORMAL
- en: There is also `bytes.Buffer`, which adds writing capabilities on top of `bytes.Reader`
    and makes it possible to access the underlying slice or get the content as a string.
  prefs: []
  type: TYPE_NORMAL
- en: The `Buffer.String` method converts bytes to string, and this type of casting
    in Go is done by making a copy of the bytes, because strings are immutable. This
    means that eventual changes to the buffer are made after the copy will not propagate
    to the string.
  prefs: []
  type: TYPE_NORMAL
- en: The strings reader
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `strings` package contains another structure that is very similar to the
    `io.Reader`  interface, called `strings.Reader`. This works exactly like the first
    but the underlying value is a string instead of a slice of bytes.
  prefs: []
  type: TYPE_NORMAL
- en: One of the main advantages of using a string instead of the byte reader, when
    dealing with strings that need to be read, is the avoidance of copying the data
    when initializing it. This subtle difference helps with both performance and memory
    usage because it does fewer allocations and requires the **Garbage Collector**
    (**GC**) to clean up the copy.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a reader
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Any Go application can define a custom implementation of the `io.Reader` interface.
    A good general rule when implementing interfaces is to accept interfaces and return
    concrete types, avoiding unnecessary abstraction.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at a practical example. We want to implement a custom reader that
    takes the content from another reader and transforms it into uppercase; we could
    call this `AngryReader`, for instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a pretty straightforward example that uses `unicode` and `unicode/utf8` to
    achieve its goal:'
  prefs: []
  type: TYPE_NORMAL
- en: '`utf8.DecodeRune` is used to obtain the first rune and its width is a portion
    of the slice read'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unicode.IsLetter` determines whether a rune is a letter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unicode.ToUpper` converts the text into uppercase'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ut8.EncodeLetter` writes the new letter in the necessary bytes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The letter and its uppercase version should be the same width
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The full example is available at [https://play.golang.org/p/PhdSsbzXcbE](https://play.golang.org/p/PhdSsbzXcbE).
  prefs: []
  type: TYPE_NORMAL
- en: Output and writers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The reasoning that applies to incoming streams also applies to outgoing ones.
    We have the `io.Writer` interface, in which the application can only send data,
    and the `io.WriteCloser` interface, in which it is also able to close the connection.
  prefs: []
  type: TYPE_NORMAL
- en: The bytes writer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We already saw that the `bytes` package offers `Buffer`, which has both reading
    and writing capabilities. This implements all the methods of the `ByteReader`
    interface, plus more than one `Writer` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '`io.Writer`: This can act as a regular writer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`io.WriterAt`: This makes it possible to write from a certain position onward'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`io.ByteWriter`: This makes it possible to write single bytes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bytes.Buffer` is a very flexible structure considering that it works for both,
    `Writer` and `ByteWriter` and works best if reused, thanks to the `Reset` and
    `Truncate` methods. Instead of leaving a used buffer to be recycled by the GC
    and make a new buffer, it is better to reset the existing one, keeping the underlying
    array for the buffer and setting the slice length to `0`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous chapter, we saw a good example of buffer usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'A buffer is not made for composing string values. For this reason, when the
    `String` method is called, bytes get converted into strings, which are immutable,
    unlike slices. The new string created this way is made with a copy of the current
    slice, and changes to the slice do not touch the string. It''s neither a limit
    nor a feature; it is an attribute that can lead to errors if used incorrectly.
    Here''s an example of the effect of resetting a buffer and using the `String`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The full example is available at [https://play.golang.org/p/zBjGPMC4sfF](https://play.golang.org/p/zBjGPMC4sfF)
  prefs: []
  type: TYPE_NORMAL
- en: The string writer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A byte buffer executes a copy of the bytes in order to produce a string. This
    is why, in version 1.10, `strings.Builder` made its debut. It shares all the write-related
    methods of a buffer and does not allow access to the underlying slice via the
    `Bytes` method. The only way of obtaining the final string is with the `String`
    method, which uses the `unsafe` package under the hood to convert the slice to
    a string without copying the underlying data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main consequence of this is that this struct strongly discourages copying—that''s
    because the underlying slice of the copied slice points to the same array, and
    writing in the copy would influence the other one. The resulting operation would
    panic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Defining a writer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Any custom implementation of any writer can be defined in the application.
    A very common case is a decorator, which is a writer that wraps another writer
    and alters or extends what the original writer does. As for the reader, it is
    a good habit to have a constructor that accepts another writer and possibly wraps
    it in order to make it compatible with a lot of the standard library structures,
    such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`*os.File`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*bytes.Buffer`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*strings.Builder`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get a real-world use case—we want to produce some texts with scrambled
    letters in each word to test when it starts to become unreadable by a human. We
    will create a configurable writer that will scramble the letters before writing
    it to the destination writer and we will create a binary that accepts a file and
    creates its scrambled version. We will use the `math/rand` package to randomize
    the scrambling.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s define our struct and its constructor. This will accept another writer,
    a random number generator, and a scrambling `chance`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Write` method needs to execute the bytes without letters as they are,
    and scramble the sequence of letters. It will iterate the runes, using the `ut8.DecodeRune`
    function we saw earlier, print whatever is not a letter, and stack all the sequences
    of letters it can find:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'When the sequence is over, it will be handled by the `shambleWrite` method,
    which will effectively execute a shamble and write the shambled runes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The full example is available at [https://play.golang.org/p/0Xez--6P7nj](https://play.golang.org/p/0Xez--6P7nj).
  prefs: []
  type: TYPE_NORMAL
- en: Built-in utilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a number of other functions in the `io` and `io/ioutil` packages that
    help with managing readers, writers, and more. Knowing all the tools available
    will help you to avoid writing unnecessary code, and will guide you in using the
    best tool for the job.
  prefs: []
  type: TYPE_NORMAL
- en: Copying from one stream to another
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are three main functions in the `io` package that make it possible to
    transfer data from a writer to a reader. This is a very common scenario; you could
    be writing the contents from a file opened for reading to another file opened
    for writing, for instance, or draining a buffer and writing its content as standard
    output.
  prefs: []
  type: TYPE_NORMAL
- en: We already saw how to use the `io.Copy` function on a file to simulate the behavior
    of the `cp` command in [Chapter 4](0b73653d-6073-4708-b015-fe6a43cb9f37.xhtml)*,
    Working with the Filesystem*. This behavior can be extended to any sort of reader
    and writer implementation, from buffers to network connections.
  prefs: []
  type: TYPE_NORMAL
- en: If the writer is also an `io.WriterTo` interface, the copy calls the `WriteTo`
    method. If not, it executes a series of writes using a buffer of fixed size (32
    KB). If the operation ends with the `io.EOF` value, no error is returned. A common
    case scenario is the `bytes.Buffer` struct, which is capable of writing its content
    to another writer and will behave accordingly. Alternatively, if the destination
    is an `io.ReaderFrom` interface, the `ReadFrom` method is executed.
  prefs: []
  type: TYPE_NORMAL
- en: If the interface is a simple `io.Writer` interface, this method uses a temporary
    buffer that will be cleaned afterwards. To avoid wasting computing power on garbage
    collection, and maybe reuse the same buffers, there's another function—the `io.CopyBuffer`
    function. This has an additional argument, and a new buffer gets allocated only
    if this extra argument is `nil`.
  prefs: []
  type: TYPE_NORMAL
- en: The last function is `io.CopyN`, which works exactly like `io.Copy` but makes
    it possible to specify a limit to the number of bytes to be written to the extra
    argument. If the reader is also `io.Seeker`, it can be useful to write partial
    content—the seeker first moves the cursor to the correct offset, then a certain
    number of bytes is written.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s make an example of copying `n` bytes at once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The full example is available at [https://play.golang.org/p/8wCqGXp5mSZ](https://play.golang.org/p/8wCqGXp5mSZ).
  prefs: []
  type: TYPE_NORMAL
- en: Connected readers and writers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `io.Pipe` function creates a pair of readers and writers that are connected.
    This means that whatever is sent to the writer will be received from the reader.
    Write operations are blocked if there is still data that is hanging from the last
    one; only when the reader has finished consuming what has been sent will the new
    operation be concluded.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is not an important tool for non-concurrent applications, which are more
    likely to use concurrent tools such as channels, but when the reader and writer
    are executing on different goroutines, this can be an excellent mechanism for
    synchronization, as in the following program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The full example is available at [https://play.golang.org/p/0YpRK25wFw_c](https://play.golang.org/p/0YpRK25wFw_c).
  prefs: []
  type: TYPE_NORMAL
- en: Extending readers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When it comes to incoming streams, there are a lot of functions available in
    the standard library to improve the capabilities of readers. One of the easiest
    examples is `ioutil.NopCloser`, which takes a reader and returns `io.ReadCloser`,
    which does nothing. This is useful if a function is in charge of releasing a resource,
    but the reader used is not `io.Closer` (like in `bytes.Buffer`).
  prefs: []
  type: TYPE_NORMAL
- en: There are two tools that constrain the number of bytes read. The `ReadAtLeast`
    function defines a minimum number of bytes to read. The result will be `EOF` only
    if there are no bytes to read; otherwise, if a smaller number of bytes is read
    before `EOF`, `ErrUnexpectedEOF` will be returned. If the bytes buffer is shorter
    than the bytes requested, which does not make sense, there will be a `ErrShortBuffer`.
    In the event of a reading error, the function manages to read at least the desired
    number of bytes, and that error is dropped.
  prefs: []
  type: TYPE_NORMAL
- en: There is then `ReadFull`, which is expected to fill the buffer and will return `ErrUnexpectedEOF` otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other constraining function is `LimitReader`. This function is a decorator
    that gets a reader and returns another reader that will return `EOF` once the
    desired bytes are read. This could be used for a preview of the content of an
    actual reader, as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The full example is available at [https://play.golang.org/p/LllOdWg9uyU](https://play.golang.org/p/LllOdWg9uyU).
  prefs: []
  type: TYPE_NORMAL
- en: More readers can be combined in a sequence with the `MultiReader` function will
    read each part sequentially until it reaches `EOF`, and then jump to the next
    one.
  prefs: []
  type: TYPE_NORMAL
- en: One reader and one writer can be connected so that whatever comes from the reader
    is copied to the writer—the opposite of what happens with `io.Pipe`. This is done
    via `io.TeeReader`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try to use it to create a writer that acts as a search engine in the
    filesystem, printing only the rows with a match to the query requested. We want
    a program that does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Reads a directory path and a string to search from the arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gets a list of files in the selected path
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reads each file and passes the lines that contain the selected string to another
    writer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This other writer will inject color characters to highlight the string and copy
    its content to the standard output
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s start with color injection. In a Unix shell, colored output is obtained
    with the following sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '`\xbb1`: An escape character'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[`: An opening bracket'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`39`: A number'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`m`: The letter *m*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The number determines both the background and foreground color. For this example,
    we'll use `31` (red) and `39` (default).
  prefs: []
  type: TYPE_NORMAL
- en: 'We are creating a writer that will print the rows with a match and highlight
    the text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This will be used with `TeeReader` with an open file, so that reading the file
    will write to `queryWriter`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, there is no need to write; reading from the file automatically
    writes to the query writer that is connected to the standard output.
  prefs: []
  type: TYPE_NORMAL
- en: Writers and decorators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a plethora of tools to enhance, decorate, and use for readers, but
    the same thing does not apply to writers.
  prefs: []
  type: TYPE_NORMAL
- en: There is also the `io.WriteString` function, which prevents unnecessary conversions
    from strings to bytes. First, it checks whether the writer supports string writing,
    attempting a cast to `io.stringWriter`, an unexported interface with just the `WriteString` method,
    then writes the string if successful, or converts it into bytes otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is the `io.MultiWriter` function, which creates a writer that replicates
    the information to a series of other writers, which it receives upon creation.
    A practical example is writing some content while showing it on the standard output,
    as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The full example is available at [https://play.golang.org/p/ZWDF2vCDfsM](https://play.golang.org/p/ZWDF2vCDfsM).
  prefs: []
  type: TYPE_NORMAL
- en: There is also a useful variable, `ioutil.Discard`, which is a writer that writes
    to `/dev/null`, a null device. This means that writing to this variable ignores
    the data.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we introduced the concept of streams for describing incoming
    and outgoing flows of data. We saw that the reader interface represents the data
    received, while the writer is the sent data.
  prefs: []
  type: TYPE_NORMAL
- en: We compared the different readers that are available in the standard package.
    We looked at files in the previous chapter, and in this one we added byte and
    string readers to the list. We learned how to implement custom readers with an
    example, and saw that it's always good to design a reader to be built on top of
    another.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we focused on writers. We discovered that files are also writers if opened
    correctly and that there are several writers in the standard package, including
    the byte buffer and the string builder. We also implemented a custom writer and
    saw how to handle bytes and runes with the `utf8` package.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we explored the remaining functionality in `io` and `ioutil`, analyzing
    the various tools offered for copying data, and connecting readers and writers.
    We also saw which decorators are available for improving or changing readers'
    and writers' capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will talk about pseudo terminal applications, and we
    will use all that knowledge to build some of them.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What's a stream?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What interfaces abstract incoming streams?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which interfaces represent outgoing streams?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When should a bytes reader be used? When should a string reader be used instead?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What's the difference between a string builder and a bytes buffer?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why should readers and writers implementations accept an interface as input?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does a pipe differ from `TeeReader`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
