- en: Streams and Pipelines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The lambda expressions described and demonstrated in the previous chapter, together
    with functional interfaces, added a powerful functional programming capability
    to Java. It allows for passing behaviors (functions) as parameters to the libraries
    optimized for the performance of the data processing. This way, an application
    programmer can concentrate on the business aspects of the developed system, leaving
    the performance aspects to the specialists: the authors of the library. One example
    of such a library is the `java.util.stream` package, which is going to be the
    focus of this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: We will introduce the concept of data streams processing, and will explain what
    streams are, how to process them, and how to build processing pipelines. We will
    also show how easily one can organize stream processing in parallel.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, the following topics will be covered:'
  prefs: []
  type: TYPE_NORMAL
- en: What is a stream?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a stream
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Intermediate operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Terminal operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stream pipelines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parallel processing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exercise – Multiplying all of the stream elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is a stream?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The best way to understand a stream is to compare it to a collection. The latter
    is a data structure stored in memory. Every collection element is computed *before*
    being added to the collection. In contrast, an element emitted by a stream exists
    somewhere else (in the source) and is computed *on demand*. So, a collection can
    be a source for a stream.
  prefs: []
  type: TYPE_NORMAL
- en: In Java, a stream is an object of a `Stream`, `IntStream`, `LongStream`, or `DoubleStream` interface
    of the `java.util.stream` package. All methods present in the `Stream` interface
    are also available (with corresponding type changes) in the `IntStream`, `LongStream`,
    or `DoubleStream` specialized *numeric* stream interfaces. Some of the numeric
    stream interfaces have a few extra methods, such as `average()` and `sum()`, specific
    to the numeric values.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will mostly speak about the `Stream` interface and its methods.
    But everything introduced can be equally applied to the numeric stream interfaces,
    too. At the end of the chapter, we will also review a few methods that are available
    in the numeric stream interfaces, but not in the `Stream` interface.
  prefs: []
  type: TYPE_NORMAL
- en: A stream represents some source of data—a collection, an array, or a file, for
    example—and generates (produces, emits) some values (stream elements of the same
    type as the stream) sequentially, as soon as the previously emitted element has
    been processed.
  prefs: []
  type: TYPE_NORMAL
- en: The `java.util.stream` package allows for the declarative presentation of the
    procedures (functions) that can be applied to the emitted elements, also in parallel.
    Today, with the machine learning requirements of massive data processing and the
    fine-tuning of operations having become ubiquitous, this feature reinforces the
    position of Java among the few modern programming languages of choice.
  prefs: []
  type: TYPE_NORMAL
- en: Stream operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many of the methods of the `Stream` interface (those that have a functional
    interface type as a parameter) are called operations, because they are not implemented
    as traditional methods. Their functionalities are passed into the methods as a
    functions. The methods themselves are just shells that call a method of the functional
    interface, assigned as the type of the method parameter.
  prefs: []
  type: TYPE_NORMAL
- en: For example, let us look at the `Stream<T> filter (Predicate<T> predicate)` method.
    Its implementation is based on the call to the `boolean test(T)` method of the
    `Predicate<T>` function. So, instead of saying, "We use the `filter()` method
    of the `Stream` object to select some of the stream elements and skip others,"
    the programmers prefer to say, "We apply the `filter` operation that allows some
    of the stream elements to get through, and skips others." It sounds similar to
    the statement, "We apply an operation of addition." It describes the nature of
    the action (operation), not the particular algorithm, which is unknown until the
    method receives the particular function.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, there are three groups of methods in the `Stream` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: Static factory methods that create `Stream` objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Intermediate operations, which are instance methods that return `Stream` objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Terminal operations, which are instance methods that return some type other
    than `Stream`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stream processing is organized typically as a pipe using a fluent (dot-connected)
    style (see the *Stream pipeline* section). A `Stream` factory method or another
    stream source starts such a pipe, and a Terminal operation produces the pipe result
    or a side effect, and ends the pipe (thus, the name). An intermediate operation
    can be placed between the originating `Stream` object and the Terminal operation.
    It processes the stream elements (or not, in some cases), and returns the modified
    (or not modified) `Stream` object, so the next intermediate or Terminal operation
    can be applied.
  prefs: []
  type: TYPE_NORMAL
- en: 'Examples of intermediate operations are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`filter()`: This selects only elements matching a criterion.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`map()`: This transforms elements according to a function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`distinct()`: This removes duplicates.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`limit()`: This limits a stream to the specified number of elements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sorted()`: This transforms unsorted stream into a sorted one.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are some other methods that we will discuss in the *Intermediate operations*
    section.
  prefs: []
  type: TYPE_NORMAL
- en: The processing of the stream elements actually begins only when a Terminal operation
    starts executing. Then, all of the intermediate operations (if present) start
    processing. The stream closes (and cannot be reopened) as soon as the Terminal
    operation finishes execution. Examples of Terminal operations are `forEach()`,
    `findFirst()`, `reduce()`, `collect()`, `sum()`, `max()`, and other methods of
    the `Stream` interface that do not return `Stream`. We will discuss them in the *Terminal
    operations* section.
  prefs: []
  type: TYPE_NORMAL
- en: All of the Stream methods support parallel processing, which is especially helpful
    in the case of a large amount of data processed on a multi-core computer. One
    must make sure that the processing pipeline does not use a context state that
    can vary across different processing environments. We will discuss this in the *Parallel
    processing* section.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a stream
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many ways to create a stream—an object of the `Stream` type or any
    of the numeric interfaces. We have grouped them by classes and interfaces that
    have methods creating Stream objects. We did so for the reader's convenience,
    to provide a better overview, so that it will be easier for the reader to find
    them if needed.
  prefs: []
  type: TYPE_NORMAL
- en: Stream interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This group of `Stream` factories is composed of static methods that belong to
    the `Stream` interface.
  prefs: []
  type: TYPE_NORMAL
- en: empty(), of(T t), ofNullable(T t)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following three methods create either empty or single-element `Stream`
    objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Stream<T> empty()`: Creates an empty sequential `Stream` object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Stream<T> of(T t)`: Creates a sequential single-element `Stream` object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Stream<T> ofNullable(T t)`: Creates a sequential `Stream` object containing
    a single element if the `t` parameter is non-null; otherwise, creates an empty
    Stream.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code demonstrates the usage of the preceding methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Stream.empty().forEach(System.out::println);    //prints nothing
  prefs: []
  type: TYPE_NORMAL
- en: 'Stream.of(1).forEach(System.out::println);      //prints: 1'
  prefs: []
  type: TYPE_NORMAL
- en: List<String> list = List.of("1 ", "2");
  prefs: []
  type: TYPE_NORMAL
- en: //printList1(null);                             //NullPointerException
  prefs: []
  type: TYPE_NORMAL
- en: 'printList1(list);                               //prints: 1 2'
  prefs: []
  type: TYPE_NORMAL
- en: void printList1(List<String> list){
  prefs: []
  type: TYPE_NORMAL
- en: list.stream().forEach(System.out::print);;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice how the first call to the `printList1()` method generates `NullPointerException`
    and prints `1 2` when the list is not `null`. To avoid the exception, we could
    implement the `printList1()` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: void printList1(List<String> list){
  prefs: []
  type: TYPE_NORMAL
- en: '(list == null ? Stream.empty() : list.stream())'
  prefs: []
  type: TYPE_NORMAL
- en: .forEach(System.out::print);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, we have used the `ofNullable(T t) ` method, as you can see in the
    following implementation of the `printList2()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: printList2(null);                                //prints nothing
  prefs: []
  type: TYPE_NORMAL
- en: 'printList2(list);                                //prints: [1 , 2]'
  prefs: []
  type: TYPE_NORMAL
- en: void printList2(List<String> list){
  prefs: []
  type: TYPE_NORMAL
- en: Stream.ofNullable(list).forEach(System.out::print);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: That is the use case that has motivated the creation of the `ofNullable(T t)` method. But
    you may have noticed that a stream created by `ofNullable()` emitting the list
    as one object: it is printed as `[1 , 2]`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To process each element of the list in this case, we would need to add an intermediate
    `Stream` operation, `flatMap()`, that converts each element to a `Stream` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Stream.ofNullable(list).flatMap(e -> e.stream())
  prefs: []
  type: TYPE_NORMAL
- en: '.forEach(System.out::print);      //prints: 1 2'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: We will discuss `flatMap()` method further in the *Intermediate operations*
    section.
  prefs: []
  type: TYPE_NORMAL
- en: 'The function passed into the `flatMap()` operation in the preceding code can
    be expressed as a method reference, too:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Stream.ofNullable(list).flatMap(Collection::stream)
  prefs: []
  type: TYPE_NORMAL
- en: '.forEach(System.out::print);      //prints: 1 2'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: iterate(Object, UnaryOperator)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Two static methods of the `Stream` interface allow us to generate a stream
    of values using an iterative process similar to the traditional `for` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Stream<T> iterate(T seed, UnaryOperator<T> func)`: Creates an **infinite**
    sequential `Stream` object, based on the iterative application of the second parameter
    (a `func` function) to the first `seed` parameter, producing a stream of `seed`,
    `f(seed)`, and `f(f(seed))` values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Stream<T> iterate(T seed, Predicate<T> hasNext, UnaryOperator<T> next)`: Creates
    a finite sequential `Stream` object based on the iterative application of the
    third parameter (the `next` function) to the first `seed` parameter, producing
    a stream of `seed`, `f(seed)`, and `f(f(seed))`, values, as long as the third
    parameter (the `hasNext` function) returns `true`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code demonstrates the usage of these methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Stream.iterate(1, i -> ++i).limit(9)
  prefs: []
  type: TYPE_NORMAL
- en: '.forEach(System.out::print);        //prints: 123456789'
  prefs: []
  type: TYPE_NORMAL
- en: Stream.iterate(1, i -> i < 10, i -> ++i)
  prefs: []
  type: TYPE_NORMAL
- en: '.forEach(System.out::print);        //prints: 123456789'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we were forced to add a `limit()` intermediate operator to the first
    pipeline to avoid generating an infinite number of values.
  prefs: []
  type: TYPE_NORMAL
- en: concat(Stream a, Stream b)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Stream<T>` concatenate (`Stream<> a`, `Stream<T> b`) static method of
    the `Stream` interface creates a stream of values based on two Stream objects,
    `a` and `b`, passed in as the parameters. The newly created stream consists of all
    the elements of the first parameter, `a`, followed by all of the elements of the
    second parameter, `b`. The following code demonstrates this method of Stream object
    creation:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Stream<Integer> stream1 = List.of(1, 2).stream();
  prefs: []
  type: TYPE_NORMAL
- en: Stream<Integer> stream2 = List.of(2, 3).stream();
  prefs: []
  type: TYPE_NORMAL
- en: Stream.concat(stream1, stream2)
  prefs: []
  type: TYPE_NORMAL
- en: '.forEach(System.out::print);        //prints: 1223'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the `2` element is present in both original streams, and consequently,
    it is present twice in the resulting stream.
  prefs: []
  type: TYPE_NORMAL
- en: generate(Supplier)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Stream<T> generate(Supplier<T> supplier)` static method of the `Stream` interface creates
    an infinite stream, where each element is generated by the provided `Supplier<T>` function.
    Here are two examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Stream.generate(() -> 1).limit(5)
  prefs: []
  type: TYPE_NORMAL
- en: '.forEach(System.out::print);       //prints: 11111'
  prefs: []
  type: TYPE_NORMAL
- en: Stream.generate(() -> new Random().nextDouble()).limit(5)
  prefs: []
  type: TYPE_NORMAL
- en: '.forEach(System.out::println);     //prints: 0.38575117472619247'
  prefs: []
  type: TYPE_NORMAL
- en: //        0.5055765386778835
  prefs: []
  type: TYPE_NORMAL
- en: //        0.6528038976983277
  prefs: []
  type: TYPE_NORMAL
- en: //        0.4422354489467244
  prefs: []
  type: TYPE_NORMAL
- en: //        0.06770955839148762
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Since the stream is infinite, we have added a `limit()` operation.
  prefs: []
  type: TYPE_NORMAL
- en: of(T... values)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Stream<T> of(T... values)` method accepts varargs, or an array of values,
    and creates a Stream object with the provided values as the stream elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: 'Stream.of("1 ", 2).forEach(System.out::print);      //prints: 1 2'
  prefs: []
  type: TYPE_NORMAL
- en: //Stream<String> stringStream = Stream.of("1 ", 2); //compile error
  prefs: []
  type: TYPE_NORMAL
- en: String[] strings = {"1 ", "2"};
  prefs: []
  type: TYPE_NORMAL
- en: 'Stream.of(strings).forEach(System.out::print);      //prints: 1 2'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that in the first line of the preceding code, a `Stream` object accepts
    elements of different types if there is no type specified in the generics of the `Stream` reference
    declaration. In the next line, the generics define the type of the `Stream` object
    as `String`, and the same mix of element types generates a compile error. Generics
    definitely help programmers to avoid many mistakes, and should be used wherever
    possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `of(T... values)` method can also be used for the concatenation of multiple
    streams. Let''s assume, for example, that we have the following four streams,
    and we would like to concatenate into one:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Stream<Integer> stream1 = Stream.of(1, 2);
  prefs: []
  type: TYPE_NORMAL
- en: Stream<Integer> stream2 = Stream.of(2, 3);
  prefs: []
  type: TYPE_NORMAL
- en: Stream<Integer> stream3 = Stream.of(3, 4);
  prefs: []
  type: TYPE_NORMAL
- en: Stream<Integer> stream4 = Stream.of(4, 5);
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'We expect the new stream to emit the values `1`, `2`, `2`, `3`, `3`, `4`, `4`,
    and `5`. First, we try the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Stream.of(stream1, stream2, stream3, stream4)
  prefs: []
  type: TYPE_NORMAL
- en: .forEach(System.out::print);
  prefs: []
  type: TYPE_NORMAL
- en: '//prints: java.util.stream.ReferencePipeline$Head@58ceff1j'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding code did not do what we hoped. It treated each stream as an object
    of the `java.util.stream.ReferencePipeline` internal class, which is used in the
    `Stream` interface implementation. So, we have added a `flatMap()` operation that
    converts each stream element into a stream (we will describe it in the *Intermediate
    operations* section):'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Stream.of(stream1, stream2, stream3, stream4)
  prefs: []
  type: TYPE_NORMAL
- en: '.flatMap(e -> e).forEach(System.out::print);   //prints: 12233445'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: The function we passed into `flatMap()` as a parameter (`e -> e`) may look like
    it's doing nothing, but that is because each element of the stream is a stream
    already, so we did not need to transform it. By returning an element as the result
    of the `flatMap()` operation, we have told the pipeline to treat it as a `Stream`
    object. That was done, and the expected result was displayed.
  prefs: []
  type: TYPE_NORMAL
- en: The Stream.Builder interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Stream.Builder<T> builder()` static method returns an internal (located
    inside the interface `Stream` interface) `Builder` interface that can be used
    to construct a `Stream` object. The `Builder` interface extends the `Consumer`
    interface, and has the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`void accept(T t)`: Adds an element to the stream (this method comes from the
    `Consumer` interface).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`default Stream.Builder<T> add(T t)`: Calls the `accept(T)` method and returns
    `this`, thus allowing chaining `add(T)` methods in a fluent, dot-connected style.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Stream<T> build()`: Transitions this builder from the constructing state to
    the built state. After this method is called, no new elements can be added to
    the stream.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using the `add()` method is straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Stream.<String>builder().add("cat").add(" dog").add(" bear")
  prefs: []
  type: TYPE_NORMAL
- en: '.build().forEach(System.out::print);  //prints: cat dog bear'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Just notice the `<String>` generics that we have added in front of the `builder()`
    method. This way, we tell the builder that the stream we are creating will have
    `String` type elements. Otherwise, it will add them as `Object` types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `accept()` method is used when the builder is passed as a parameter of
    the `Consumer` type, or when you do not need to chain the methods that add the
    elements. For example, here is how the builder is passed in as a `Consumer` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Stream.Builder<String> builder = Stream.builder();
  prefs: []
  type: TYPE_NORMAL
- en: List.of("1", "2", "3").stream().forEach(builder);
  prefs: []
  type: TYPE_NORMAL
- en: 'builder.build().forEach(System.out::print);        //prints: 123'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are also cases where there is no need to chain the methods while adding
    the stream elements. The following method receives a list of `String` objects,
    and adds some of them (those that contain the character `a`) to a stream:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Stream<String> buildStream(List<String> values){
  prefs: []
  type: TYPE_NORMAL
- en: Stream.Builder<String> builder = Stream.builder();
  prefs: []
  type: TYPE_NORMAL
- en: 'for(String s: values){'
  prefs: []
  type: TYPE_NORMAL
- en: if(s.contains("a")){
  prefs: []
  type: TYPE_NORMAL
- en: builder.accept(s);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: return builder.build();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we have added the `<String>` generics the `Stream.Builder` interface
    for the same reason—to tell the builder that the elements we are adding should
    be treated as `String` types.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the preceding method is called, it produces the expected result:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: List<String> list = List.of("cat", " dog", " bear");
  prefs: []
  type: TYPE_NORMAL
- en: 'buildStream(list).forEach(System.out::print);        //prints: cat bear'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Other classes and interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Java 8, two default methods were added to the `java.util.Collection` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Stream<E> stream()`: Returns a stream of the elements of this collection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Stream<E> parallelStream()`: Returns (possibly) a parallel stream of the elements
    of this collection. We say possibly because the JVM attempts to split the stream
    into several chunks and process them in parallel (if there are several CPUs) or
    virtually parallel (using the time-sharing of the CPU). This is not always possible;
    it depends, in part, on the nature of the requested processing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It means that all of the collection interfaces that extend this interface,
    including `Set` and `List`, have these methods. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: List<Integer> list = List.of(1, 2, 3, 4, 5);
  prefs: []
  type: TYPE_NORMAL
- en: 'list.stream().forEach(System.out::print);    //prints: 12345'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: We will discuss parallel streams further in the *Parallel processing* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Eight static overloaded `stream()` methods were added to the `java.util.Arrays` class,
    too. They create streams of different types from a corresponding array, or its
    subset:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Stream<T> stream(T[] array)`: Creates `Stream` from the provided array.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IntStream stream(int[] array)`: Creates `IntStream` from the provided array.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LongStream stream(long[] array)`: Creates `LongStream` from the provided array.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DoubleStream stream(double[] array)`: Creates `DoubleStream` from the provided
    array.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Stream<T> stream(T[] array, int startInclusive, int endExclusive)`: Creates
    `Stream` from the specified range of the provided array.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IntStream stream(int[] array, int startInclusive, int endExclusive)`: Creates
    `IntStream` from the specified range of the provided array.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LongStream stream(long[] array, int startInclusive, int endExclusive)`: Creates
    `LongStream` from the specified range of the provided array.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DoubleStream stream(double[] array, int startInclusive, int endExclusive)`:
    Creates `DoubleStream` from the specified range of the provided array.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is an example of creating a stream from the subset of an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: int[] arr = {1, 2, 3, 4, 5};
  prefs: []
  type: TYPE_NORMAL
- en: 'Arrays.stream(arr, 2, 4).forEach(System.out::print);    //prints: 34'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we have used the `Stream<T> stream(T[] array, int startInclusive,
    int endExclusive)` method, which means we have created `Stream` and not `IntStream`,
    although all of the elements in the created stream are integers, as in `IntStream`.
    The difference is that `IntStream` provides some numeric-specific operations not
    available in `Stream` (see the *Numeric stream interfaces* section).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `java.util.Random` class allows us to create numeric streams of pseudorandom
    values:'
  prefs: []
  type: TYPE_NORMAL
- en: '`IntStream ints()` and `LongStream longs()`: Create an unlimited stream of
    pseudorandom values of the corresponding type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DoubleStream doubles()`: Creates an unlimited stream of pseudorandom double
    values, each between zero (inclusive) and one (exclusive).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IntStream ints(long streamSize)` and `LongStream longs(long streamSize)`:
    Create a stream of the specified number of pseudorandom values of the corresponding
    type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DoubleStream doubles(long streamSize)`: Creates a stream of the specified
    number of pseudorandom double values, each between zero (inclusive) and one (exclusive).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IntStream ints(int randomNumberOrigin, int randomNumberBound)`, `LongStream
    longs(long randomNumberOrigin, long randomNumberBound)`, and `DoubleStream doubles(long
    streamSize, double randomNumberOrigin, double randomNumberBound)`: Create an infinite
    stream of pseudorandom values of the corresponding type, each value equal to or
    larger than the first parameter, and smaller than the second parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is an example of one of the preceding methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: new Random().ints(5, 8)
  prefs: []
  type: TYPE_NORMAL
- en: .limit(5)
  prefs: []
  type: TYPE_NORMAL
- en: '.forEach(System.out::print);    //prints: 56757'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `java.nio.File` class has six static methods to create streams of lines
    and paths:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Stream<String> lines(Path path)`: Creates a stream of lines from the file
    specified by the provided path.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Stream<String> lines(Path path, Charset cs)`: Creates a stream of lines from
    the file specified by the provided path. Bytes from the file are decoded into
    characters using the provided charset.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Stream<Path> list(Path dir)`: Creates a stream of the entries in the specified
    directory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Stream<Path> walk(Path start, FileVisitOption... options)`: Creates a stream of
    the entries of the file tree rooted at a given starting file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Stream<Path> walk(Path start, int maxDepth, FileVisitOption... options)`:
    Creates a stream of the entries of the file tree rooted at a given starting file
    to the specified depth.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Stream<Path> find(Path start, int maxDepth, BiPredicate<Path, BasicFileAttributes>
    matcher, FileVisitOption... options)`: Creates a stream of the entries of the
    file tree rooted at a given starting file to the specified depth that match the
    provided predicate.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Other classes and methods that create streams include:'
  prefs: []
  type: TYPE_NORMAL
- en: '`IntStream stream()` of the `java.util.BitSet` class: Creates a stream of indices
    for which `BitSet` contains a bit in the set state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Stream<String> lines()` of the `java.io.BufferedReader` class: Creates a stream
    of lines read from the `BufferedReader` object, typically from a file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Stream<JarEntry> stream()` of the `java.util.jar.JarFile` class: Creates a
    stream of the ZIP file entries.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'default `IntStream chars()` of the `java.lang.CharSequence` interface: Creates
    a stream of `int` zero-extending the `char` values from this sequence.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'default `IntStream codePoints()` of the `java.lang.CharSequence` interface:
    Creates a stream of code point values from this sequence.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Stream<String> splitAsStream(CharSequence input)` of the `java.util.regex.Pattern` class:
    Creates a stream from the provided sequence around matches of this pattern.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is also the `java.util.stream.StreamSupport` class, which contains static,
    low-level utility methods for library developers. That is outside the scope of
    this book.
  prefs: []
  type: TYPE_NORMAL
- en: Intermediate operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have already seen how a `Stream` object that represents a source and emits
    elements can be created. As we have mentioned already, the operations (methods)
    provided by the `Stream` interface can be divided into three groups:'
  prefs: []
  type: TYPE_NORMAL
- en: The methods that create a `Stream` object based on a source.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Intermediate operations that accept a function and produce a `Stream` object
    that emits the same, or modified, values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Terminal operations that complete the stream processing, close it, and produce
    the result.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we will review the intermediate operations that, in turn, can
    be grouped by their functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: Filtering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This group includes operations that remove duplicates, skip some of the elements,
    and limit the number of processed elements, only selecting those that are needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Stream<T> distinct()`: Compares stream elements using the `Object.equals(Object)`
    method, and skips the duplicates.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Stream<T> skip(long n)`: Ignores the provided number of stream elements that
    are emitted first.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Stream<T> limit(long maxSize)`: Allows only the provided number of stream
    elements to be processed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Stream<T> filter(Predicate<T> predicate)`: Allows only those elements that
    result in `true` (when processed by the provided `Predicate` function).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Default `Stream<T> dropWhile(Predicate<T> predicate)`: Skips the first elements
    of the stream that result in `true` when processed by the provided `Predicate` function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Default `Stream<T> takeWhile(Predicate<T> predicate)`: Allows only the first
    elements of the stream that result in `true` (when processed by the provided `Predicate` function)
    to be processed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code demonstrates how the preceding operations work:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Stream.of("3", "2", "3", "4", "2").distinct()
  prefs: []
  type: TYPE_NORMAL
- en: '.forEach(System.out::print);  //prints: 324'
  prefs: []
  type: TYPE_NORMAL
- en: List<String> list = List.of("1", "2", "3", "4", "5");
  prefs: []
  type: TYPE_NORMAL
- en: 'list.stream().skip(3).forEach(System.out::print);         //prints: 45'
  prefs: []
  type: TYPE_NORMAL
- en: 'list.stream().limit(3).forEach(System.out::print);        //prints: 123'
  prefs: []
  type: TYPE_NORMAL
- en: list.stream().filter(s -> Objects.equals(s, "2"))
  prefs: []
  type: TYPE_NORMAL
- en: '.forEach(System.out::print);  //prints: 2'
  prefs: []
  type: TYPE_NORMAL
- en: list.stream().dropWhile(s -> Integer.valueOf(s) < 3)
  prefs: []
  type: TYPE_NORMAL
- en: '.forEach(System.out::print);  //prints: 345'
  prefs: []
  type: TYPE_NORMAL
- en: list.stream().takeWhile(s -> Integer.valueOf(s) < 3)
  prefs: []
  type: TYPE_NORMAL
- en: '.forEach(System.out::print);  //prints: 12'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we were able to reuse the `List<String>` source object, but could
    not reuse the `Stream` object. Once it has been closed, it cannot be reopened.
  prefs: []
  type: TYPE_NORMAL
- en: Mapping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This group includes arguably the most important intermediate operations. They
    are the only intermediate operations that modify the elements of the stream. They
    *map* (transform) the original stream element value to a new one:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Stream<R> map(Function<T, R> mapper)`: Applies the provided function to each
    element of the `T` type of this stream, and produces a new element value of the `R` type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IntStream mapToInt(ToIntFunction<T> mapper)`: Converts this stream to an `IntStream`
    of the `Integer` values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LongStream mapToLong(ToLongFunction<T> mapper)`: Converts this stream to a `LongStream`
    of the `Long` values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DoubleStream mapToDouble(ToDoubleFunction<T> mapper)`: Converts this stream
    to a `DoubleStream` of the `Double` values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Stream<R> flatMap(Function<T, Stream<R>> mapper)`: Applies the provided function
    to each element of the `T` type of this stream and produces a `Stream<R>` object
    that emits elements of the `R` type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IntStream flatMapToInt(Function<T, IntStream> mapper)`: Converts each element
    of the `T` type to a stream of `Integer` values, using the provided function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LongStream flatMapToLong(Function<T, LongStream> mapper)`: Converts each element
    of the `T` type to a stream of `Long` values, using the provided function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DoubleStream flatMapToDouble(Function<T, DoubleStream> mapper)`: Converts
    each element of the `T` type to a stream of `Double` values, using the provided
    function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following are examples of the usage of these operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: List<String> list = List.of("1", "2", "3", "4", "5");
  prefs: []
  type: TYPE_NORMAL
- en: list.stream().map(s -> s + s)
  prefs: []
  type: TYPE_NORMAL
- en: '.forEach(System.out::print);        //prints: 1122334455'
  prefs: []
  type: TYPE_NORMAL
- en: list.stream().mapToInt(Integer::valueOf)
  prefs: []
  type: TYPE_NORMAL
- en: '.forEach(System.out::print);             //prints: 12345'
  prefs: []
  type: TYPE_NORMAL
- en: list.stream().mapToLong(Long::valueOf)
  prefs: []
  type: TYPE_NORMAL
- en: '.forEach(System.out::print);             //prints: 12345'
  prefs: []
  type: TYPE_NORMAL
- en: list.stream().mapToDouble(Double::valueOf)
  prefs: []
  type: TYPE_NORMAL
- en: .mapToObj(Double::toString)
  prefs: []
  type: TYPE_NORMAL
- en: .map(s -> s + " ")
  prefs: []
  type: TYPE_NORMAL
- en: '.forEach(System.out::print);//prints: 1.0 2.0 3.0 4.0 5.0'
  prefs: []
  type: TYPE_NORMAL
- en: list.stream().mapToInt(Integer::valueOf)
  prefs: []
  type: TYPE_NORMAL
- en: .flatMap(n -> IntStream.iterate(1, i -> i < n, i -> ++i))
  prefs: []
  type: TYPE_NORMAL
- en: '.forEach(System.out::print);        //prints: 1121231234'
  prefs: []
  type: TYPE_NORMAL
- en: list.stream().map(Integer::valueOf)
  prefs: []
  type: TYPE_NORMAL
- en: .flatMapToInt(n ->
  prefs: []
  type: TYPE_NORMAL
- en: IntStream.iterate(1, i -> i < n, i -> ++i))
  prefs: []
  type: TYPE_NORMAL
- en: '.forEach(System.out::print);        //prints: 1121231234'
  prefs: []
  type: TYPE_NORMAL
- en: list.stream().map(Integer::valueOf)
  prefs: []
  type: TYPE_NORMAL
- en: .flatMapToLong(n ->
  prefs: []
  type: TYPE_NORMAL
- en: LongStream.iterate(1, i -> i < n, i -> ++i))
  prefs: []
  type: TYPE_NORMAL
- en: '.forEach(System.out::print);        //prints: 1121231234;'
  prefs: []
  type: TYPE_NORMAL
- en: list.stream().map(Integer::valueOf)
  prefs: []
  type: TYPE_NORMAL
- en: .flatMapToDouble(n ->
  prefs: []
  type: TYPE_NORMAL
- en: DoubleStream.iterate(1, i -> i < n, i -> ++i))
  prefs: []
  type: TYPE_NORMAL
- en: .mapToObj(Double::toString)
  prefs: []
  type: TYPE_NORMAL
- en: .map(s -> s + " ")
  prefs: []
  type: TYPE_NORMAL
- en: .forEach(System.out::print);
  prefs: []
  type: TYPE_NORMAL
- en: '//prints: 1.0 1.0 2.0 1.0 2.0 3.0 1.0 2.0 3.0 4.0'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding examples, in the case of `Double` values, we converted a numeric
    value to a `String`, and added space, so the result will be printed with a space
    between the numbers. These examples are very simple—just conversion with minimal
    processing. But in real life, each `map` or `flatMap` operation can accept a (function
    of any level of complexity) that does something really useful.
  prefs: []
  type: TYPE_NORMAL
- en: Sorting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following two intermediate operations sort the stream elements. Naturally,
    such an operation cannot be finished until all of the elements are emitted, so
    it creates a lot of overhead, slows down performance, and has to be used either
    for the small size streams:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Stream<T> sorted()`: Sorts the stream elements in a natural order (according
    to their `Comparable` interface implementation).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Stream<T> sorted(Comparator<T> comparator)`: Sorts the stream elements in
    the order according to the provided `Comparator<T>` object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is a demo code:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: List<String> list = List.of("2", "1", "5", "4", "3");
  prefs: []
  type: TYPE_NORMAL
- en: 'list.stream().sorted().forEach(System.out::print);  //prints: 12345'
  prefs: []
  type: TYPE_NORMAL
- en: list.stream().sorted(Comparator.reverseOrder())
  prefs: []
  type: TYPE_NORMAL
- en: '.forEach(System.out::print);           //prints: 54321'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Peeking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A `Stream<T> peek(Consumer<T> action)` intermediate operation applies the provided `Consumer` function
    to each stream element and does not change this `Stream` (returns the same element
    value it has received) because the `Consumer` function returns `void` and cannot
    affect the value. This operation is used for debugging.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: List<String> list = List.of("1", "2", "3", "4", "5");
  prefs: []
  type: TYPE_NORMAL
- en: list.stream().peek(s-> {
  prefs: []
  type: TYPE_NORMAL
- en: if("3".equals(s)){
  prefs: []
  type: TYPE_NORMAL
- en: System.out.print(3);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}).forEach(System.out::print);  //prints: 123345'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Terminal operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Terminal operations are the most important operations of a stream pipeline.
    It is easy to accomplish everything without a need for any other operations. We
    have used already the `forEach(Consumer<T>)` Terminal operation to print each
    element. It does not return a value; thus, it is used for its side effects. But
    the `Stream` interface has many more powerful Terminal operations that do return
    values. The central among them is a `collect()` operation, which has two forms, `R
    collect(Collector<T, A, R> collector)` and `R collect(Supplier<R> supplier, BiConsumer<R,
    T> accumulator, BiConsumer<R, R> combiner)`. These allow us to compose practically
    any process that can be applied to a stream. The classic example is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: List<String> asList = stringStream.collect(ArrayList::new,
  prefs: []
  type: TYPE_NORMAL
- en: ArrayList::add,
  prefs: []
  type: TYPE_NORMAL
- en: ArrayList::addAll);
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, it is implemented in a way suited for parallel processing. It
    uses the first function to produce a value based on the stream element, accumulates
    the result using the second function, and then combines the accumulated results
    from all of the threads that processed the stream.
  prefs: []
  type: TYPE_NORMAL
- en: However, having only one such generic Terminal operation would force the programmers
    to write the same functions repeatedly. That is why the API authors added the `Collectors` class,
    which generates many specialized `Collector` objects without the need to create
    three functions for every `collect()` operation. In addition to that, the API
    authors added even more specialized Terminal operations, which are much simpler
    and easier to use to the `Stream` interface.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will review all of the Terminal operation of the `Stream`
    interface, and, in the `Collecting` subsection, look at the vast population of
    `Collector` objects produced by the `Collectors` class.
  prefs: []
  type: TYPE_NORMAL
- en: We will start with the most simple Terminal operation, which allows for processing
    each element of a stream one at a time.
  prefs: []
  type: TYPE_NORMAL
- en: Processing each element
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two Terminal operations in this group:'
  prefs: []
  type: TYPE_NORMAL
- en: '`void forEach(Consumer<T> action)`: Applies the provided action (process) for
    each element of the stream.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void forEachOrdered(Consumer<T> action)`: Applies the provided action (process)
    for each element of the stream in an order defined by the source, regardless of
    whether the stream is sequential or parallel.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the order in which you need the elements to be processed is important for
    your application, and it has to be in the order the values were arranged in the
    source, use the second method—especially if can foresee that your code is going
    to be executed on a computer with several CPUs. Otherwise, use the first one,
    as we have done in all our examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is not unusual to see this operation being used for *any kind* of stream
    processing, especially when the code is written by an inexperienced programmer.
    For the following example, we have created the `Person` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: class Person {
  prefs: []
  type: TYPE_NORMAL
- en: private int age;
  prefs: []
  type: TYPE_NORMAL
- en: private String name;
  prefs: []
  type: TYPE_NORMAL
- en: public Person(int age, String name) {
  prefs: []
  type: TYPE_NORMAL
- en: this.name = name;
  prefs: []
  type: TYPE_NORMAL
- en: this.age = age;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public String getName() { return this.name; }
  prefs: []
  type: TYPE_NORMAL
- en: public int getAge() {return this.age; }
  prefs: []
  type: TYPE_NORMAL
- en: '@Override'
  prefs: []
  type: TYPE_NORMAL
- en: public String toString() {
  prefs: []
  type: TYPE_NORMAL
- en: return "Person{" + "name='" + this.name + "'" +
  prefs: []
  type: TYPE_NORMAL
- en: '", age=" + age + "}";'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to use this class throughout our discussion of Terminal operations.
    For this example, we are going to read comma-separated values (age and name) from
    a file and create `Person` objects. We have placed the following `persons.csv` file
    (**Comma-Separated Values (CSV)**) in the `resources` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: 23 , Ji m
  prefs: []
  type: TYPE_NORMAL
- en: 2 5 , Bob
  prefs: []
  type: TYPE_NORMAL
- en: 15 , Jill
  prefs: []
  type: TYPE_NORMAL
- en: 17 , Bi ll
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice the spaces that we have added outside and inside of the values. We have
    done it in order to take the opportunity to show you some simple, but very useful,
    tips for working with real-life data. Here is how an inexperienced programmer
    may write the code that reads this file and creates a list of `Person` objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: List<Person> persons = new ArrayList<>();
  prefs: []
  type: TYPE_NORMAL
- en: Path path = Paths.get("src/main/resources/persons.csv");
  prefs: []
  type: TYPE_NORMAL
- en: try (Stream<String> lines = Files.newBufferedReader(path).lines()) {
  prefs: []
  type: TYPE_NORMAL
- en: lines.forEach(s -> {
  prefs: []
  type: TYPE_NORMAL
- en: String[] arr = s.split(",");
  prefs: []
  type: TYPE_NORMAL
- en: int age = Integer.valueOf(StringUtils.remove(arr[0], ' '));
  prefs: []
  type: TYPE_NORMAL
- en: persons.add(new Person(age, StringUtils.remove(arr[1], ' ')));
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  prefs: []
  type: TYPE_NORMAL
- en: '} catch (IOException ex) {'
  prefs: []
  type: TYPE_NORMAL
- en: ex.printStackTrace();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: persons.stream().forEach(System.out::println);
  prefs: []
  type: TYPE_NORMAL
- en: '//prints: Person{name=''Jim'', age=23}'
  prefs: []
  type: TYPE_NORMAL
- en: //        Person{name='Bob', age=25}
  prefs: []
  type: TYPE_NORMAL
- en: //        Person{name='Jill', age=15}
  prefs: []
  type: TYPE_NORMAL
- en: //        Person{name='Bill', age=17}
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: You can see that we used the `String` method, `split()`, to break each line
    by a comma that separates the values, and that we have used the `org.apache.commons.lang3.StringUtils` class
    to remove spaces from each value. The preceding code also provides a real-life
    example of the `try-with-resources` construct, which is used to close the `BufferedReader`
    object automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Although this code works fine in small examples and on a single-core computer,
    it might create unexpected results with a long stream and parallel processing.
    That is, the reason that lambda expressions require all variables to be final,
    or effectively final, because the same function can be executed in a different
    context.
  prefs: []
  type: TYPE_NORMAL
- en: 'In contrast, here is the correct implementation of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: List<Person> persons = new ArrayList<>();
  prefs: []
  type: TYPE_NORMAL
- en: Path path = Paths.get("src/main/resources/persons.csv");
  prefs: []
  type: TYPE_NORMAL
- en: try (Stream<String> lines = Files.newBufferedReader(path).lines()) {
  prefs: []
  type: TYPE_NORMAL
- en: persons = lines.map(s -> s.split(","))
  prefs: []
  type: TYPE_NORMAL
- en: .map(arr -> {
  prefs: []
  type: TYPE_NORMAL
- en: int age = Integer.valueOf(StringUtils.remove(arr[0], ' '));
  prefs: []
  type: TYPE_NORMAL
- en: return new Person(age, StringUtils.remove(arr[1], ' '));
  prefs: []
  type: TYPE_NORMAL
- en: '}).collect(Collectors.toList());'
  prefs: []
  type: TYPE_NORMAL
- en: '} catch (IOException ex) {'
  prefs: []
  type: TYPE_NORMAL
- en: ex.printStackTrace();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: persons.stream().forEach(System.out::println);
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'To improve readability, one can create a method that does the job of mapping:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public List<Person> createPersons() {
  prefs: []
  type: TYPE_NORMAL
- en: List<Person> persons = new ArrayList<>();
  prefs: []
  type: TYPE_NORMAL
- en: Path path = Paths.get("src/main/resources/persons.csv");
  prefs: []
  type: TYPE_NORMAL
- en: try (Stream<String> lines = Files.newBufferedReader(path).lines()) {
  prefs: []
  type: TYPE_NORMAL
- en: persons = lines.map(s -> s.split(","))
  prefs: []
  type: TYPE_NORMAL
- en: .map(this::createPerson)
  prefs: []
  type: TYPE_NORMAL
- en: .collect(Collectors.toList());
  prefs: []
  type: TYPE_NORMAL
- en: '} catch (IOException ex) {'
  prefs: []
  type: TYPE_NORMAL
- en: ex.printStackTrace();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: return persons;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: private Person createPerson(String[] arr){
  prefs: []
  type: TYPE_NORMAL
- en: int age = Integer.valueOf(StringUtils.remove(arr[0], ' '));
  prefs: []
  type: TYPE_NORMAL
- en: return new Person(age, StringUtils.remove(arr[1], ' '));
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we used the `collect()` operation and the `Collector` function
    created by the `Collectors.toList()` method. We will see more of the `Collector`
    functions created by the `Collectors` class in the *Collect* subsection.
  prefs: []
  type: TYPE_NORMAL
- en: Counting all elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `long count()` Terminal operation of the `Stream` interface looks straightforward
    and benign. It returns the number of elements in this stream. Those who are used
    to working with collections and arrays may use the `count()` operation without
    thinking twice. Here is an example that proves it works just fine:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: long count = Stream.of("1", "2", "3", "4", "5")
  prefs: []
  type: TYPE_NORMAL
- en: .peek(System.out::print)
  prefs: []
  type: TYPE_NORMAL
- en: .count();
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.print(count);                 //prints: 5'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the code that implements the method count was able to determine
    the stream size without executing all the pipe. The values of elements were not
    printed by the `peek()` operation, which proves that the elements were not emitted.
    But it is not always possible to determine the stream size at the source. Besides,
    the stream may be infinite. So, one has to use `count()` with care.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we are on the topic of counting elements, we would like to show you another
    possible way to determine the stream size, using the `collect()` operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: int count = Stream.of("1", "2", "3", "4", "5")
  prefs: []
  type: TYPE_NORMAL
- en: '.peek(System.out::print)         //prints: 12345'
  prefs: []
  type: TYPE_NORMAL
- en: .collect(Collectors.counting());
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(count);                //prints: 5'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see that the implementation of the `collect()` operation does not even
    attempt to calculate the stream size at the source (because, as you can see, the
    pipe was fully executed and each element was printed by the `peek()` operation).
    This is because the `collect()` operation is not as specialized as the `count()` operation.
    It just applies the passed-in collector to the stream, and the collector counts
    the elements provided to it by the `collect()` operation. You could consider this
    an example of bureaucratic myopia: every operator does its job as expected, but
    the overall performance is wanting.'
  prefs: []
  type: TYPE_NORMAL
- en: Matching all, any, or none
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are three (seemingly very similar) Terminal operations that allow us
    to asses whether all, any, or none of the stream elements have a certain value:'
  prefs: []
  type: TYPE_NORMAL
- en: '`boolean allMatch(Predicate<T> predicate)`: Returns `true` when each of this
    stream elements returns `true`, when used as a parameter of the provided `Predicate<T>`
    function'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boolean anyMatch(Predicate<T> predicate)`: Returns `true` when one of this
    stream elements returns `true`, when used as a parameter of the provided `Predicate<T>` function'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boolean noneMatch(Predicate<T> predicate)`: Returns `true` when none of the
    stream elements return `true`, when used as a parameter of the provided `Predicate<T>` function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following are examples of their usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: List<String> list = List.of("1", "2", "3", "4", "5");
  prefs: []
  type: TYPE_NORMAL
- en: boolean found = list.stream()
  prefs: []
  type: TYPE_NORMAL
- en: '.peek(System.out::print)          //prints: 123'
  prefs: []
  type: TYPE_NORMAL
- en: .anyMatch(e -> "3".equals(e));
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.print(found);                  //prints: true   <= line 5'
  prefs: []
  type: TYPE_NORMAL
- en: found = list.stream()
  prefs: []
  type: TYPE_NORMAL
- en: '.peek(System.out::print)          //prints: 12345'
  prefs: []
  type: TYPE_NORMAL
- en: .anyMatch(e -> "0".equals(e));
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.print(found);                  //prints: false'
  prefs: []
  type: TYPE_NORMAL
- en: boolean noneMatches = list.stream()
  prefs: []
  type: TYPE_NORMAL
- en: '.peek(System.out::print)          //prints: 123'
  prefs: []
  type: TYPE_NORMAL
- en: .noneMatch(e -> "3".equals(e));
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.print(noneMatches);            //prints: false'
  prefs: []
  type: TYPE_NORMAL
- en: noneMatches = list.stream()
  prefs: []
  type: TYPE_NORMAL
- en: '.peek(System.out::print)          //prints: 12345'
  prefs: []
  type: TYPE_NORMAL
- en: .noneMatch(e -> "0".equals(e));
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.print(noneMatches);            //prints: true  <= line 17'
  prefs: []
  type: TYPE_NORMAL
- en: boolean allMatch = list.stream()
  prefs: []
  type: TYPE_NORMAL
- en: '.peek(System.out::print)          //prints: 1'
  prefs: []
  type: TYPE_NORMAL
- en: .allMatch(e -> "3".equals(e));
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.print(allMatch);               //prints: false'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at the results of the preceding example more closely. Each of these
    operations triggers the stream pipe execution, and at least one element of the
    stream is processed every time. But look at the `anyMatch()` and `noneMatch()`
    operations. Line 5 states that there is at least one element equal to `3`. The
    result was returned *after only three first elements* had been processed. Line
    17 states that there was no element equal to `0` *after all of the elements* of
    the stream had been processed.
  prefs: []
  type: TYPE_NORMAL
- en: The question is, which of these two operations should you when you use would
    like to know whether the stream *does not contain* the `v` value? If `noneMatch()`
    is used, *all of the elements are going to be processed*. But if `anyMatch()`
    is used, all of the elements are going to be processed *only if there is no* `v`* value*
    in the stream. It seems that the `noneMatch()` operation is useless, because when
    `anyMatch()` returns `true`, it means the same as when `noneMatch()` returns `false`,
    while the `anyMatch()` operation achieves it with fewer elements processed. This
    difference grows in significance with the growth of the stream size and the chance
    that there is an element with the `v` value. It seems that the only reason for
    having the `noneMatch()` operation is for code readability, when processing time
    is not important, because the stream size is small.
  prefs: []
  type: TYPE_NORMAL
- en: The `allMatch()` operation does not have an alternative, and, similar to `anyMatch()`,
    either returns when the first non-matching element is encountered or requires
    processing all of the stream elements.
  prefs: []
  type: TYPE_NORMAL
- en: Finding any or first
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following Terminal operations allow us to find any, or the first, element
    of the stream:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Optional<T> findAny()`: Returns `Optional` with the value of any element of
    the stream, or an empty `Optional` if the stream is empty.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Optional<T> findFirst()`: Returns `Optional` with the value of the first element
    of the stream, or an empty `Optional` if the stream is empty.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following example illustrates these operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: List<String> list = List.of("1", "2", "3", "4", "5");
  prefs: []
  type: TYPE_NORMAL
- en: Optional<String> result = list.stream().findAny();
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(result.isPresent());    //prints: true'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(result.get());          //prints: 1'
  prefs: []
  type: TYPE_NORMAL
- en: result = list.stream().filter(e -> "42".equals(e)).findAny();
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(result.isPresent());    //prints: true'
  prefs: []
  type: TYPE_NORMAL
- en: //System.out.println(result.get());        //NoSuchElementException
  prefs: []
  type: TYPE_NORMAL
- en: result = list.stream().findFirst();
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(result.isPresent());    //prints: true'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(result.get());          //prints: 1'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, they return the same results. That is because we are executing
    the pipe in a single thread. The differences between these two operations are
    more prominent in parallel processing. When the stream is broken into several
    parts for parallel processing, the `findFirst()` operation always returns the
    first element of the stream if the stream is not empty, while the `findAny()` operation
    returns the first element only in one of the processing threads.
  prefs: []
  type: TYPE_NORMAL
- en: Let's discuss the `java.util.Optional` class in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Class Optional
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The object of `java.util.Optional` is used to avoid returning `null`, as it
    may cause a `NullPointerException`. Instead, an `Optional` object provides methods
    that can be used to check the value presence and to substitute it if there is
    no value. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: List<String> list = List.of("1", "2", "3", "4", "5");
  prefs: []
  type: TYPE_NORMAL
- en: String result = list.stream().filter(e -> "42".equals(e))
  prefs: []
  type: TYPE_NORMAL
- en: .findAny().or(() -> Optional.of("Not found")).get();
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(result);                       //prints: Not found'
  prefs: []
  type: TYPE_NORMAL
- en: result = list.stream().filter(e -> "42".equals(e))
  prefs: []
  type: TYPE_NORMAL
- en: .findAny().orElse("Not found");
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(result);                        //prints: Not found'
  prefs: []
  type: TYPE_NORMAL
- en: Supplier<String> trySomethingElse = () -> {
  prefs: []
  type: TYPE_NORMAL
- en: //Code that tries something else
  prefs: []
  type: TYPE_NORMAL
- en: return "43";
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: result = list.stream().filter(e -> "42".equals(e))
  prefs: []
  type: TYPE_NORMAL
- en: .findAny().orElseGet(trySomethingElse);
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(result);                          //prints: 43'
  prefs: []
  type: TYPE_NORMAL
- en: list.stream().filter(e -> "42".equals(e))
  prefs: []
  type: TYPE_NORMAL
- en: .findAny().ifPresentOrElse(System.out::println,
  prefs: []
  type: TYPE_NORMAL
- en: '() -> System.out.println("Not found"));  //prints: Not found'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, if the `Optional` object is empty, then:'
  prefs: []
  type: TYPE_NORMAL
- en: The `or()` method of the `Optional` class allows for returning an alternative
    `Optional` object (with a value).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `orElse()` method allows for returning an alternative value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `orElseGet()` method allows for providing the `Supplier` function, which
    returns an alternative value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `ifPresentOrElse()` method allows for providing two functions: one that
    consumes the value from the `Optional` object, and another that does something
    if the `Optional` object is empty.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Min and max
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following Terminal operations return the minimum or maximum value of the
    stream elements, if present:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Optional<T> min`(Comparator<T> comparator): Returns the minimum element of
    this stream, using the provided Comparator object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Optional<T> max`(Comparator<T> comparator): Returns the maximum element of
    this stream, using the provided Comparator object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is the demonstration code:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: List<String> list = List.of("a", "b", "c", "c", "a");
  prefs: []
  type: TYPE_NORMAL
- en: String min = list.stream().min(Comparator.naturalOrder()).orElse("0");
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(min);     //prints: a'
  prefs: []
  type: TYPE_NORMAL
- en: String max = list.stream().max(Comparator.naturalOrder()).orElse("0");
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(max);     //prints: c'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, in the case of non-numerical values, the minimum element is
    the one that is first (when ordered from the left to the right), according to
    the provided comparator; the maximum, accordingly, is the last element. In the
    case of numeric values, the minimum and maximum are just that—the biggest and
    the smallest number among the stream elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: int mn = Stream.of(42, 33, 77).min(Comparator.naturalOrder()).orElse(0);
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(mn);    //prints: 33'
  prefs: []
  type: TYPE_NORMAL
- en: int mx = Stream.of(42, 33, 77).max(Comparator.naturalOrder()).orElse(0);
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(mx);    //prints: 77'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at another example, assuming that there is a `Person` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: class Person {
  prefs: []
  type: TYPE_NORMAL
- en: private int age;
  prefs: []
  type: TYPE_NORMAL
- en: private String name;
  prefs: []
  type: TYPE_NORMAL
- en: public Person(int age, String name) {
  prefs: []
  type: TYPE_NORMAL
- en: this.age = age;
  prefs: []
  type: TYPE_NORMAL
- en: this.name = name;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public int getAge() { return this.age; }
  prefs: []
  type: TYPE_NORMAL
- en: public String getName() { return this.name; }
  prefs: []
  type: TYPE_NORMAL
- en: '@Override'
  prefs: []
  type: TYPE_NORMAL
- en: public String toString() {
  prefs: []
  type: TYPE_NORMAL
- en: return "Person{name:" + this.name + ",age:" + this.age + "}";
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'The task is to find the oldest person in the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: List<Person> persons = List.of(new Person(23, "Bob"),
  prefs: []
  type: TYPE_NORMAL
- en: new Person(33, "Jim"),
  prefs: []
  type: TYPE_NORMAL
- en: new Person(28, "Jill"),
  prefs: []
  type: TYPE_NORMAL
- en: new Person(27, "Bill"));
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to do that, we can create the following `Compartor<Person>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Comparator<Person> perComp = (p1, p2) -> p1.getAge() - p2.getAge();
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, using this comparator, we can find the oldest person:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Person theOldest = persons.stream().max(perComp).orElse(null);
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(theOldest);  //prints: Person{name:Jim,age:33}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: The toArray() operation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These two Terminal operations generate an array that contains the stream elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Object[] toArray()` : Creates an array of objects; each object is an element
    of this stream.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`A[] toArray(IntFunction<A[]> generator)`: Creates an array of the stream elements
    using the provided function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: List<String> list = List.of("a", "b", "c");
  prefs: []
  type: TYPE_NORMAL
- en: Object[] obj = list.stream().toArray();
  prefs: []
  type: TYPE_NORMAL
- en: 'Arrays.stream(obj).forEach(System.out::print);    //prints: abc'
  prefs: []
  type: TYPE_NORMAL
- en: String[] str = list.stream().toArray(String[]::new);
  prefs: []
  type: TYPE_NORMAL
- en: 'Arrays.stream(str).forEach(System.out::print);    //prints: abc'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: The first example is straightforward. It converts elements to an array of the
    same type. As for the second example, the representation of `IntFunction` as `String[]::new`
    is probably not obvious, so let's walk through it.
  prefs: []
  type: TYPE_NORMAL
- en: '`String[]::new` is a method reference that represents the following lambda
    expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: String[] str = list.stream().toArray(i -> new String[i]);
  prefs: []
  type: TYPE_NORMAL
- en: 'Arrays.stream(str).forEach(System.out::print);    //prints: abc'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'And that is already `IntFunction<String[]>`, which, according to its documentation,
    accepts an `int` parameter and returns the result of the specified type. It can
    be defined by using an anonymous class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: IntFunction<String[]> intFunction = new IntFunction<String[]>() {
  prefs: []
  type: TYPE_NORMAL
- en: '@Override'
  prefs: []
  type: TYPE_NORMAL
- en: public String[] apply(int i) {
  prefs: []
  type: TYPE_NORMAL
- en: return new String[i];
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'You may recall (from [Chapter 13](3d6ae5fa-f48e-44e2-ae03-62dae2f78401.xhtml),
    *Java Collections*) how we converted a collection to an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: str = list.toArray(new String[list.size()]);
  prefs: []
  type: TYPE_NORMAL
- en: 'Arrays.stream(str).forEach(System.out::print);    //prints: abc'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: You can see that the `toArray()` operation of the `Stream` interface has a very
    similar signature, except that it accepts a function, instead of just an array.
  prefs: []
  type: TYPE_NORMAL
- en: The reduce operation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This Terminal operation is called *reduce* because it processes all of the stream
    elements and produces one value. It *reduces* all of the stream elements to one
    value. But this is not the only operation that does it. The *collect* operation
    reduces all of the values of the stream element into one result, too. And, in
    a way, all Terminal operations reduce. They produce one value after processing
    of all the elements.
  prefs: []
  type: TYPE_NORMAL
- en: So, you may look at *reduce* and *collect* as synonyms that help to add structure
    and classification to many operations available in the `Stream` interface. Also,
    the operations in the *reduce* group can be viewed as specialized versions of
    the *collect* operation, because `collect()` can be tailored to provide the same
    functionality, too.
  prefs: []
  type: TYPE_NORMAL
- en: 'With that, let''s look at the group of *reduce* operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Optional<T> reduce(BinaryOperator<T> accumulator)`: Reduces the elements of
    this stream by using the provided associative function that defines the logic
    of the element aggregation. Returns `Optional` with the reduced value, if available.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`T reduce(T identity, BinaryOperator<T> accumulator)`: Provides the same functionality
    as the previous `reduce()` version, but with the `identity` parameter used as the initial
    value for an accumulator, or a default value, if a stream is empty.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`U reduce(U identity, BiFunction<U,T,U> accumulator, BinaryOperator<U> combiner)`:
    Provides the same functionality as the previous `reduce()` version, but, in addition,
    uses the `combiner` function to aggregate the results when this operation is applied
    to a parallel stream. If the stream is not parallel, the combiner function is
    not used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For a demonstration of the `reduce()` operation, we are going to use the same `Person` class
    that that we before:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: class Person {
  prefs: []
  type: TYPE_NORMAL
- en: private int age;
  prefs: []
  type: TYPE_NORMAL
- en: private String name;
  prefs: []
  type: TYPE_NORMAL
- en: public Person(int age, String name) {
  prefs: []
  type: TYPE_NORMAL
- en: this.age = age;
  prefs: []
  type: TYPE_NORMAL
- en: this.name = name;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public int getAge() { return this.age; }
  prefs: []
  type: TYPE_NORMAL
- en: public String getName() { return this.name; }
  prefs: []
  type: TYPE_NORMAL
- en: '@Override'
  prefs: []
  type: TYPE_NORMAL
- en: public String toString() {
  prefs: []
  type: TYPE_NORMAL
- en: return "Person{name:" + this.name + ",age:" + this.age + "}";
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'We are also going to use the same list of `Person` objects as the source for
    our stream examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: List<Person> list = List.of(new Person(23, "Bob"),
  prefs: []
  type: TYPE_NORMAL
- en: new Person(33, "Jim"),
  prefs: []
  type: TYPE_NORMAL
- en: new Person(28, "Jill"),
  prefs: []
  type: TYPE_NORMAL
- en: new Person(27, "Bill"));
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, using the `reduce()` operation, let''s find the oldest person in this
    list:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Person theOldest = list.stream()
  prefs: []
  type: TYPE_NORMAL
- en: '.reduce((p1, p2) -> p1.getAge() > p2.getAge() ? p1 : p2).orElse(null);'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(theOldest);         //prints: Person{name:Jim,age:33}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: The implementation is somewhat surprising, isn't it? We were talking about the
    "accumulator," but we did not accumulate anything. We just compared all of the
    stream elements. Well, apparently, the accumulator saves the result of the comparison
    and provides it as the first parameter for the next comparison (with the next
    element). One could say that the accumulator, in this case, accumulates the results
    of all previous comparisons. In any case, it does the job we wanted it to do.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now accumulate something explicitly. Let''s assemble all of the names
    from the list of people in one comma-separated list:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: String allNames = list.stream().map(p->p.getName())
  prefs: []
  type: TYPE_NORMAL
- en: .reduce((n1, n2) -> n1 + ", " + n2).orElse(null);
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(allNames);            //prints: Bob, Jim, Jill, Bill'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: The notion of accumulation, makes a bit more sense in this case, doesn't it?
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s use the identity value to provide an initial value:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: String allNames = list.stream().map(p->p.getName())
  prefs: []
  type: TYPE_NORMAL
- en: '.reduce("All names: ", (n1, n2) -> n1 + ", " + n2);'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(allNames);       //All names: , Bob, Jim, Jill, Bill'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that this version of the `reduce()` operation returns the value, not
    the `Optional` object. That is because, by providing the initial value, we guarantee
    that this value will be present in the result, even if the stream turns out to
    be empty.
  prefs: []
  type: TYPE_NORMAL
- en: 'But the resulting string does not look as pretty as we had hoped. Apparently,
    the provided initial value is treated as any other stream element, and a comma
    is added after it by the accumulator we created. To make the result look pretty
    again, we could use the first version of the `reduce()` operation again, and add
    the initial value this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: 'String allNames = "All names: " + list.stream().map(p->p.getName())'
  prefs: []
  type: TYPE_NORMAL
- en: .reduce((n1, n2) -> n1 + ", " + n2).orElse(null);
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(allNames);         //All names: Bob, Jim, Jill, Bill'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have decided to use a space as a separator, instead of a comma, for demonstration
    purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: String allNames = list.stream().map(p->p.getName())
  prefs: []
  type: TYPE_NORMAL
- en: .reduce("All names:", (n1, n2) -> n1 + " " + n2);
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(allNames);        //All names: Bob, Jim, Jill, Bill'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Now, the result looks better. While demonstrating the `collect()` operation
    in the next subsection, we will show you another way to create a comma-separated
    list of values with a prefix.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look at how to use the third form of the `reduce()` operation—the
    one with three parameters, the last one is called a combiner. Adding the combiner
    to the preceding `reduce()` operation does not change the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: String allNames = list.stream().map(p->p.getName())
  prefs: []
  type: TYPE_NORMAL
- en: .reduce("All names:", (n1, n2) -> n1 + " " + n2,
  prefs: []
  type: TYPE_NORMAL
- en: (n1, n2) -> n1 + " " + n2 );
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(allNames);          //All names: Bob, Jim, Jill, Bill'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: That is because the stream is not parallel, and the combiner is used only with
    a parallel stream.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we make the stream parallel, the result changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: String allNames = list.parallelStream().map(p->p.getName())
  prefs: []
  type: TYPE_NORMAL
- en: .reduce("All names:", (n1, n2) -> n1 + " " + n2,
  prefs: []
  type: TYPE_NORMAL
- en: (n1, n2) -> n1 + " " + n2 );
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(allNames);
  prefs: []
  type: TYPE_NORMAL
- en: '//All names: Bob All names: Jim All names: Jill All names: Bill'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Apparently, for a parallel stream, the sequence of elements is broken into
    subsequences, each being processed independently; their results are aggregated
    by the combiner. When doing so, the combiner adds the initial value (identity)
    to each of the results. Even if we remove the combiner, the result of the parallel
    stream processing remains the same, because a default combiner behavior is provided:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: String allNames = list.parallelStream().map(p->p.getName())
  prefs: []
  type: TYPE_NORMAL
- en: .reduce("All names:", (n1, n2) -> n1 + " " + n2);
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(allNames);
  prefs: []
  type: TYPE_NORMAL
- en: '//All names: Bob All names: Jim All names: Jill All names: Bill'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: In the previous two forms of `reduce()` operations, the identity value was used
    by the accumulator. In the third form, with the `U reduce(U identity, BiFunction<U,T,U>
    accumulator, BinaryOperator<U> combiner)` signature, the identity value is used
    by the combiner (notice that, the `U` type is the combiner type).
  prefs: []
  type: TYPE_NORMAL
- en: 'To get rid of the repetitive identity value in the result, we have decided
    to remove it from the second parameter in the combiner:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: allNames = list.parallelStream().map(p->p.getName())
  prefs: []
  type: TYPE_NORMAL
- en: .reduce("All names:", (n1, n2) -> n1 + " " + n2,
  prefs: []
  type: TYPE_NORMAL
- en: (n1, n2) -> n1 + " " + StringUtils.remove(n2, "All names:"));
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(allNames);       //All names: Bob, Jim, Jill, Bill'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the result now looks much better.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our examples so far, the identity played not only the role of an initial
    value, but also of the identifier (a label) in the result. When the elements of
    the stream are numeric, the identity looks more like the initial value only. Let''s
    look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: List<Integer> ints = List.of(1, 2, 3);
  prefs: []
  type: TYPE_NORMAL
- en: int sum = ints.stream().reduce((i1, i2) -> i1 + i2).orElse(0);
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(sum);                          //prints: 6'
  prefs: []
  type: TYPE_NORMAL
- en: sum = ints.stream().reduce(Integer::sum).orElse(0);
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(sum);                          //prints: 6'
  prefs: []
  type: TYPE_NORMAL
- en: sum = ints.stream().reduce(10, Integer::sum);
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(sum);                         //prints: 16'
  prefs: []
  type: TYPE_NORMAL
- en: sum = ints.stream().reduce(10, Integer::sum, Integer::sum);
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(sum);                         //prints: 16'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: The first two stream pipes are exactly the same, except that the second pipe
    uses a method reference instead of a lambda expression. The third and the fourth
    pipes have the same functionality too. They both use an initial value of 10\.
    Now the first parameter makes more sense as the initial value than the identity,
    isn't it? In the fourth pipe, we added a combiner but it is not used because the
    stream is not parallel.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s make it parallel and see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: List<Integer> ints = List.of(1, 2, 3);
  prefs: []
  type: TYPE_NORMAL
- en: int sum = ints.parallelStream().reduce(10, Integer::sum, Integer::sum);
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(sum);                                   //prints: 36'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'The result is 36 because the initial value of 10 was added three times—with
    each partial result. Apparently, the stream was broken into three subsequences.
    But that is not always the case, it changes as the stream grows and the number
    of CPUs on the computer increases. So, one cannot rely on a certain fixed number
    of subsequences and it is better not to use it for such cases, and add to the
    result if needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: List<Integer> ints = List.of(1, 2, 3);
  prefs: []
  type: TYPE_NORMAL
- en: int sum = ints.parallelStream().reduce(0, Integer::sum, Integer::sum);
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(sum);                                   //prints: 6'
  prefs: []
  type: TYPE_NORMAL
- en: sum = 10 + ints.parallelStream().reduce(0, Integer::sum, Integer::sum);
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(sum);                                   //prints: 16'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: The collect operation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some of the usages of the `collect()` operation are very simple and recommended
    for any beginner, while other cases can be complex and inaccessible even for a
    seasoned programmer. Together with the operations discussed already, the most
    popular cases of `collect()` we present in this section are more than enough for
    all the needs a beginner may have. Add the operations of numeric streams we are
    going to present in the *Numeric stream interfaces* section, and the covered material
    may easily be all a mainstream programmer will need for the foreseeable future.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we have mentioned already, the collect operation is very flexible, and allows
    us to customize the stream processing. It has two forms:'
  prefs: []
  type: TYPE_NORMAL
- en: '`R collect(Collector<T, A, R> collector)`: Processes the elements of this stream
    of the `T` type using the provided `Collector` and producing the result of the `R` type
    via an intermediate accumulation of the `A` type'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`R collect(Supplier<R> supplier, BiConsumer<R, T> accumulator, BiConsumer<R,
    R> combiner)`: Processes the elements of this stream of the `T` type using the
    provided functions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Supplier<R>`: Creates a new result container'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BiConsumer<R, T> accumulator`: A stateless function that adds an element to
    the result container'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BiConsumer<R, R> combiner`: A stateless function that merges two partial result
    containers, adds the elements from the second result container into the first
    result container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s look at the second form of the `collect()` operation. It is very similar
    to the `reduce()` operation, with the three parameters we have just demonstrated.
    The biggest difference is that the first parameter in the `collect()` operation
    is not identity or initial value, but the container—an object—that is going to
    be passed between functions and that maintains the state of the processing. For
    the following example, we are going to use the `Person1` class as the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: class Person1 {
  prefs: []
  type: TYPE_NORMAL
- en: private String name;
  prefs: []
  type: TYPE_NORMAL
- en: private int age;
  prefs: []
  type: TYPE_NORMAL
- en: public Person1(){}
  prefs: []
  type: TYPE_NORMAL
- en: public String getName() { return this.name; }
  prefs: []
  type: TYPE_NORMAL
- en: public void setName(String name) { this.name = name; }
  prefs: []
  type: TYPE_NORMAL
- en: public int getAge() {return this.age; }
  prefs: []
  type: TYPE_NORMAL
- en: public void setAge(int age) { this.age = age;}
  prefs: []
  type: TYPE_NORMAL
- en: '@Override'
  prefs: []
  type: TYPE_NORMAL
- en: public String toString() {
  prefs: []
  type: TYPE_NORMAL
- en: return "Person{name:" + this.name + ",age:" + age + "}";
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, the container has to have a constructor without parameters
    and setters, because it should be able to receive and keep the partial results—the
    name and age of the person that is the oldest, so far. The `collect()` operation
    will use this container while processing each element and, after the last element
    is processed, will contain the name and the age of the oldest person. Here is
    the list of people, which should be familiar to you:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: List<Person> list = List.of(new Person(23, "Bob"),
  prefs: []
  type: TYPE_NORMAL
- en: new Person(33, "Jim"),
  prefs: []
  type: TYPE_NORMAL
- en: new Person(28, "Jill"),
  prefs: []
  type: TYPE_NORMAL
- en: new Person(27, "Bill"));
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'And here is the `collect()` operation that should find the oldest person in
    the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Person1 theOldest = list.stream().collect(Person1::new,
  prefs: []
  type: TYPE_NORMAL
- en: (p1, p2) -> {
  prefs: []
  type: TYPE_NORMAL
- en: if(p1.getAge() < p2.getAge()){
  prefs: []
  type: TYPE_NORMAL
- en: p1.setAge(p2.getAge());
  prefs: []
  type: TYPE_NORMAL
- en: p1.setName(p2.getName());
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '},'
  prefs: []
  type: TYPE_NORMAL
- en: (p1, p2) -> { System.out.println("Combiner is called!"); });
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'We tried to inline the functions in the operation call, but it looks a bit
    difficult to read, so here is the better version of the same code:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: BiConsumer<Person1, Person> accumulator = (p1, p2) -> {
  prefs: []
  type: TYPE_NORMAL
- en: if(p1.getAge() < p2.getAge()){
  prefs: []
  type: TYPE_NORMAL
- en: p1.setAge(p2.getAge());
  prefs: []
  type: TYPE_NORMAL
- en: p1.setName(p2.getName());
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: BiConsumer<Person1, Person1> combiner = (p1, p2) -> {
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("Combiner is called!");        //prints nothing
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: theOldest = list.stream().collect(Person1::new, accumulator, combiner);
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(theOldest);        //prints: Person{name:Jim,age:33}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: The `Person1` container object is created only once—for the first element processing
    (in this sense, it is similar to the initial value of the `reduce()` operation).
    Then it is passed to the accumulator that compared it with the first element.
    The `age` field in the container was initialized to the default value of zero
    and thus, the age and name of the first element were set in the container as the
    parameters of the oldest person, so far.
  prefs: []
  type: TYPE_NORMAL
- en: When the second element (the `Person` object) of the stream was emitted, its `age` field
    was compared with the `age` value currently stored in the container (the `Person1` object),
    and so on, until all elements of the stream were processed. The result is shown
    in the preceding comments.
  prefs: []
  type: TYPE_NORMAL
- en: 'The combiner was never called because the stream is not parallel. But when
    we make it parallel, we need to implement the combiner as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: BiConsumer<Person1, Person1> combiner = (p1, p2) -> {
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("Combiner is called!");   //prints 3 times
  prefs: []
  type: TYPE_NORMAL
- en: if(p1.getAge() < p2.getAge()){
  prefs: []
  type: TYPE_NORMAL
- en: p1.setAge(p2.getAge());
  prefs: []
  type: TYPE_NORMAL
- en: p1.setName(p2.getName());
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: theOldest = list.parallelStream()
  prefs: []
  type: TYPE_NORMAL
- en: .collect(Person1::new, accumulator, combiner);
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(theOldest);  //prints: Person{name:Jim,age:33}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: The combiner compares the partial results (of all the stream subsequences) and
    comes up with the final result. Now we see the `Combiner is called!` message printed
    three times. But, as in the case of the `reduce()` operation, the number of partial
    results (the stream subsequences) may vary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s look at the first form of the `collect()` operation. It requires an
    object of the class that implements the `java.util.stream.Collector<T,A,R>` interface
    where `T` is the stream type, `A` is the container type, and `R` is the result
    type. One can use the `of()` method of the `Collector` interface to create a necessary
    `Collector` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '`static Collector<T,R,R> of(Supplier<R> supplier, BiConsumer<R,T> accumulator,
    BinaryOperator<R> combiner, Collector.Characteristics... characteristics)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`static Collector<T,A,R> of(Supplier<A> supplier, BiConsumer<A,T> accumulator,
    BinaryOperator<A> combiner, Function<A,R> finisher, Collector.Characteristics...
    characteristics)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The functions one has to pass to the preceding methods are similar to those
    we have demonstrated already. But we are not going to do it for two reasons. First,
    it is somewhat more involved and pushes beyond the scope of this introductory
    course, and, second, before doing that, one has to look in the `java.util.stream.Collectors` class
    that provides many ready-to-use collectors.  As we have mentioned already, together
    with the operations discussed in this book and the numeric streams operations
    we are going to present in the *Numeric stream interfaces* section, they cover
    the vast majority of the processing needs in mainstream programming, and there
    is a good chance you would never need to create a custom collector at all.
  prefs: []
  type: TYPE_NORMAL
- en: Class collectors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `java.util.stream.Collectors` class provides more than 40 methods that
    create `Collector` objects. We are going to demonstrate only the simplest and 
    most popular ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Collector<T,?,List<T>> toList()`: Creates a collector that collects the stream
    elements into a `List` object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Collector<T,?,Set<T>> toSet()`: Creates a collector that collects the stream
    elements into a `Set` object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Collector<T,?,Map<K,U>> toMap (Function<T,K> keyMapper, Function<T,U> valueMapper)`:
    Creates a collector that collects the stream elements into a `Map` object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Collector<T,?,C> toCollection (Supplier<C> collectionFactory)`: Creates a
    collector that collects the stream elements into a `Collection` object of the
    type specified by the collection factory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Collector<CharSequence,?,String> joining()`: Creates a collector that concatenates
    the elements into a `String` value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Collector<CharSequence,?,String> joining (CharSequence delimiter)`: Creates
    a collector that concatenates the elements into a delimiter-separated `String`
    value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Collector<CharSequence,?,String> joining (CharSequence delimiter, CharSequence
    prefix, CharSequence suffix)`: Creates a collector that concatenates the elements
    into a delimiter-separated `String` value with the provided prefix and suffix.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Collector<T,?,Integer> summingInt(ToIntFunction<T>)`: Creates a collector
    that calculates the sum of the results generated by the provided function applied
    to each element. The same method exists for the `long` and `double` types.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Collector<T,?,IntSummaryStatistics> summarizingInt(ToIntFunction<T>)`: Creates
    a collector that calculates the sum, min, max, count, and average of the results
    generated by the provided function applied to each element. The same method exists
    for the `long` and `double` types.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Collector<T,?,Map<Boolean,List<T>>> partitioningBy (Predicate<? super T> predicate)`:
    Creates a collector that partitions the elements according to the provided `Predicate`
    function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Collector<T,?,Map<K,List<T>>> groupingBy(Function<T,U>)`: Creates a collector
    that groups elements into a `Map` with keys generated by the provided function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following demo code shows how to use the collectors created by these methods.
    First, we demonstrate usage of the  `toList()`, `toSet()`, `toMap()`, and `toCollection()` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: List<String> ls = Stream.of("a", "b", "c").collect(Collectors.toList());
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(ls);                //prints: [a, b, c]'
  prefs: []
  type: TYPE_NORMAL
- en: Set<String> set = Stream.of("a", "a", "c").collect(Collectors.toSet());
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(set);                //prints: [a, c]'
  prefs: []
  type: TYPE_NORMAL
- en: List<Person> persons = List.of(new Person(23, "Bob"),
  prefs: []
  type: TYPE_NORMAL
- en: new Person(33, "Jim"),
  prefs: []
  type: TYPE_NORMAL
- en: new Person(28, "Jill"),
  prefs: []
  type: TYPE_NORMAL
- en: new Person(27, "Bill"));
  prefs: []
  type: TYPE_NORMAL
- en: Map<String, Person> map = persons.stream()
  prefs: []
  type: TYPE_NORMAL
- en: .collect(Collectors.toMap(p->p.getName() + "-" + p.getAge(), p->p));
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(map); //prints: {Bob-23=Person{name:Bob,age:23},'
  prefs: []
  type: TYPE_NORMAL
- en: Bill-27=Person{name:Bill,age:27},
  prefs: []
  type: TYPE_NORMAL
- en: Jill-28=Person{name:Jill,age:28},
  prefs: []
  type: TYPE_NORMAL
- en: Jim-33=Person{name:Jim,age:33}}
  prefs: []
  type: TYPE_NORMAL
- en: Set<Person> personSet = persons.stream()
  prefs: []
  type: TYPE_NORMAL
- en: .collect(Collectors.toCollection(HashSet::new));
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(personSet);  //prints: [Person{name:Bill,age:27},'
  prefs: []
  type: TYPE_NORMAL
- en: Person{name:Jim,age:33},
  prefs: []
  type: TYPE_NORMAL
- en: Person{name:Bob,age:23},
  prefs: []
  type: TYPE_NORMAL
- en: Person{name:Jill,age:28}]
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `joining()` method allows concatenating the `Character` and `String` values
    in a delimited list with a prefix and suffix:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: List<String> list = List.of("a", "b", "c", "d");
  prefs: []
  type: TYPE_NORMAL
- en: String result = list.stream().collect(Collectors.joining());
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(result);           //abcd
  prefs: []
  type: TYPE_NORMAL
- en: result = list.stream().collect(Collectors.joining(", "));
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(result);           //a, b, c, d
  prefs: []
  type: TYPE_NORMAL
- en: result = list.stream()
  prefs: []
  type: TYPE_NORMAL
- en: '.collect(Collectors.joining(", ", "The result: ", ""));'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(result);          //The result: a, b, c, d'
  prefs: []
  type: TYPE_NORMAL
- en: result = list.stream()
  prefs: []
  type: TYPE_NORMAL
- en: '.collect(Collectors.joining(", ", "The result: ", ". The End."));'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(result);          //The result: a, b, c, d. The End.'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `summingInt()` and `summarizingInt()` methods create collectors that calculate
    the sum and other statistics of the `int` values produced by the provided function
    applied to each element:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: List<Person> list = List.of(new Person(23, "Bob"),
  prefs: []
  type: TYPE_NORMAL
- en: new Person(33, "Jim"),
  prefs: []
  type: TYPE_NORMAL
- en: new Person(28, "Jill"),
  prefs: []
  type: TYPE_NORMAL
- en: new Person(27, "Bill"));
  prefs: []
  type: TYPE_NORMAL
- en: int sum = list.stream().collect(Collectors.summingInt(Person::getAge));
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(sum);  //prints: 111'
  prefs: []
  type: TYPE_NORMAL
- en: IntSummaryStatistics stats =
  prefs: []
  type: TYPE_NORMAL
- en: list.stream().collect(Collectors.summarizingInt(Person::getAge));
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(stats);     //IntSummaryStatistics{count=4, sum=111,
  prefs: []
  type: TYPE_NORMAL
- en: //    min=23, average=27.750000, max=33}
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(stats.getCount());    //4
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(stats.getSum());      //111
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(stats.getMin());      //23
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(stats.getAverage());  //27.750000
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(stats.getMax());      //33
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: There are also `summingLong()`, `summarizingLong()` , `summingDouble()`, and `summarizingDouble()` methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `partitioningBy()` method creates a collector that groups the elements
    by the provided criteria and put the groups (lists) in a `Map` object with a `boolean`
    value as the key:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: List<Person> list = List.of(new Person(23, "Bob"),
  prefs: []
  type: TYPE_NORMAL
- en: new Person(33, "Jim"),
  prefs: []
  type: TYPE_NORMAL
- en: new Person(28, "Jill"),
  prefs: []
  type: TYPE_NORMAL
- en: new Person(27, "Bill"));
  prefs: []
  type: TYPE_NORMAL
- en: Map<Boolean, List<Person>> map =
  prefs: []
  type: TYPE_NORMAL
- en: list.stream().collect(Collectors.partitioningBy(p->p.getAge() > 27));
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(map);
  prefs: []
  type: TYPE_NORMAL
- en: //{false=[Person{name:Bob,age:23}, Person{name:Bill,age:27}],
  prefs: []
  type: TYPE_NORMAL
- en: //  true=[Person{name:Jim,age:33}, Person{name:Jill,age:28}]}
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, using the `p.getAge() > 27` criteria, we were able to put all
    the people in two groups—one is below or equals 27 years of age (the key is `false`),
    and the other is above 27 (the key is `true`).
  prefs: []
  type: TYPE_NORMAL
- en: 'And, finally, the `groupingBy()` method allows us to group elements by a value
    and put the groups (lists) in a `Map` object with this value as a key:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: List<Person> list = List.of(new Person(23, "Bob"),
  prefs: []
  type: TYPE_NORMAL
- en: new Person(33, "Jim"),
  prefs: []
  type: TYPE_NORMAL
- en: new Person(23, "Jill"),
  prefs: []
  type: TYPE_NORMAL
- en: new Person(33, "Bill"));
  prefs: []
  type: TYPE_NORMAL
- en: Map<Integer, List<Person>> map =
  prefs: []
  type: TYPE_NORMAL
- en: list.stream().collect(Collectors.groupingBy(Person::getAge));
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(map);
  prefs: []
  type: TYPE_NORMAL
- en: //{33=[Person{name:Jim,age:33}, Person{name:Bill,age:33}],
  prefs: []
  type: TYPE_NORMAL
- en: // 23=[Person{name:Bob,age:23}, Person{name:Jill,age:23}]}
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: To be able to demonstrate the preceding method, we changed our list of `Person`
    objects by setting the age on each of them either to 23 or to 33\. The result
    is two groups by their age.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are also overloaded `toMap()`, `groupingBy()`, and `partitioningBy()` methods as
    well as the following, often overloaded too, methods that create corresponding
    `Collector` objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '`counting()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reducing()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`filtering()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`toConcurrentMap()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '``collectingAndThen()``'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`maxBy()` and `minBy()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mapping()` and `flatMapping()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`averagingInt()`, `averagingLong()`, and `averagingDouble()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`toUnmodifiableList()`, `toUnmodifiableMap()`, and `toUnmodifiableSet()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you cannot find the operation you need among those discussed in this book,
    search the `Collectors` API first, before building your own `Collector` object.
  prefs: []
  type: TYPE_NORMAL
- en: Numeric stream interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we have mentioned already, all the three numeric interfaces, `IntStream`,
    `LongStream`, and `DoubleStream`,have methods similar to the methods in the `Stream` interface,
    including methods of the `Stream.Builder` interface. This means that everything
    we have talked so far in this chapter equally applies to any of the numeric stream
    interfaces. That is why, in this section, we will only talk about those methods
    that are not present in the `Stream` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: The `range(lower,upper)` and `rangeClosed(lower,upper)` methods in the `IntStream`
    and `LongStream` interfaces. They allow us to create a stream from the values
    in the specified range.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `boxed()` and `mapToObj()` intermediate operations, which convert a numeric
    stream to `Stream`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `mapToInt()`, `mapToLong()`, and `mapToDouble()` intermediate operations,
    which convert a numeric stream of one type to a numeric stream of another type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `flatMapToInt()`, `flatMapToLong()`, and `flatMapToDouble()` intermediate
    operations, which convert a stream to a numeric stream.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `sum()` and `average()` Terminal operations, which calculate sum and average
    of the numeric stream elements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a stream
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to the methods of the `Stream` interface that create streams, the `IntStream` and `LongStream` interfaces
    allow us to create a stream from the values in the specified range.
  prefs: []
  type: TYPE_NORMAL
- en: range(), rangeClosed()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `range(lower, upper)` method generates all the values sequentially, starting
    from the `lower` value and ending with the value just before `upper`:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: 'IntStream.range(1, 3).forEach(System.out::print);  //prints: 12'
  prefs: []
  type: TYPE_NORMAL
- en: 'LongStream.range(1, 3).forEach(System.out::print);  //prints: 12'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `rangeClosed(lower, upper)` method generates all the values sequentially,
    starting from the `lower` value and ending with the `upper` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: 'IntStream.rangeClosed(1, 3).forEach(System.out::print);  //prints: 123'
  prefs: []
  type: TYPE_NORMAL
- en: 'LongStream.rangeClosed(1, 3).forEach(System.out::print);  //prints: 123'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Intermediate operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In addition to the `Stream` intermediate operations, the `IntStream`, `LongStream`,
    and `DoubleStream` interfaces also have number-specific intermediate operations:
    `boxed()`, `mapToObj()`, `mapToInt()`, `mapToLong()`, `mapToDouble()`, `flatMapToInt()`,
    `flatMapToLong()`, and `flatMapToDouble()`.'
  prefs: []
  type: TYPE_NORMAL
- en: boxed() and mapToObj()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `boxed()` intermediate operation converts (boxes) elements of the primitive
    numeric type to the corresponding wrapper type:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: //IntStream.range(1, 3).map(Integer::shortValue)        //compile error
  prefs: []
  type: TYPE_NORMAL
- en: //                     .forEach(System.out::print);
  prefs: []
  type: TYPE_NORMAL
- en: IntStream.range(1, 3).boxed().map(Integer::shortValue)
  prefs: []
  type: TYPE_NORMAL
- en: '.forEach(System.out::print);  //prints: 12'
  prefs: []
  type: TYPE_NORMAL
- en: //LongStream.range(1, 3).map(Long::shortValue)          //compile error
  prefs: []
  type: TYPE_NORMAL
- en: //                      .forEach(System.out::print);
  prefs: []
  type: TYPE_NORMAL
- en: LongStream.range(1, 3).boxed().map(Long::shortValue)
  prefs: []
  type: TYPE_NORMAL
- en: '.forEach(System.out::print);  //prints: 12'
  prefs: []
  type: TYPE_NORMAL
- en: //DoubleStream.of(1).map(Double::shortValue)            //compile error
  prefs: []
  type: TYPE_NORMAL
- en: //                  .forEach(System.out::print);
  prefs: []
  type: TYPE_NORMAL
- en: DoubleStream.of(1).boxed().map(Double::shortValue)
  prefs: []
  type: TYPE_NORMAL
- en: '.forEach(System.out::print);      //prints: 1'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding code, we have commented out the lines that generate compilation
    errors because the elements generated by the `range()` method are of primitive
    types. By adding the `boxed()` operation, we convert the primitive values to the
    corresponding wrapping type and can then process them as a reference type.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `mapToObj()` intermediate operation does a similar transformation, but 
    it is not as specialized as the `boxed()` operation and allows to use an element
    of the primitive type to produce an object of any type:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: IntStream.range(1, 3).mapToObj(Integer::valueOf)
  prefs: []
  type: TYPE_NORMAL
- en: .map(Integer::shortValue)
  prefs: []
  type: TYPE_NORMAL
- en: '.forEach(System.out::print);       //prints: 12'
  prefs: []
  type: TYPE_NORMAL
- en: IntStream.range(42, 43).mapToObj(i -> new Person(i, "John"))
  prefs: []
  type: TYPE_NORMAL
- en: .forEach(System.out::print);
  prefs: []
  type: TYPE_NORMAL
- en: '//prints: Person{name:John,age:42}'
  prefs: []
  type: TYPE_NORMAL
- en: LongStream.range(1, 3).mapToObj(Long::valueOf)
  prefs: []
  type: TYPE_NORMAL
- en: .map(Long::shortValue)
  prefs: []
  type: TYPE_NORMAL
- en: '.forEach(System.out::print);      //prints: 12'
  prefs: []
  type: TYPE_NORMAL
- en: DoubleStream.of(1).mapToObj(Double::valueOf)
  prefs: []
  type: TYPE_NORMAL
- en: .map(Double::shortValue)
  prefs: []
  type: TYPE_NORMAL
- en: '.forEach(System.out::print);          //prints: 1'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding code, we have added the `map()` operation just to prove that
    the `mapToObj()` operation does the job and creates a wrapping type object as
    expected. Also, by adding the stream pipe that produces the `Person` objects,
    we have demonstrated how the `mapToObj()` operation can be used to create an object
    of any type.
  prefs: []
  type: TYPE_NORMAL
- en: mapToInt(), mapToLong(), and mapToDouble()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `mapToInt()`, `mapToLong()`, `mapToDouble()` intermediate operations allow
    us to convert a numeric stream of one type to a numeric stream of another type.
    For the demonstration code, we convert the list of `String` values to a numeric
    stream of different types by mapping each `String` value to its length:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: list.stream().mapToInt(String::length)
  prefs: []
  type: TYPE_NORMAL
- en: '.forEach(System.out::print); //prints: 335'
  prefs: []
  type: TYPE_NORMAL
- en: list.stream().mapToLong(String::length)
  prefs: []
  type: TYPE_NORMAL
- en: '.forEach(System.out::print); //prints: 335'
  prefs: []
  type: TYPE_NORMAL
- en: list.stream().mapToDouble(String::length)
  prefs: []
  type: TYPE_NORMAL
- en: '.forEach(d -> System.out.print(d + " "));   //prints: 3.0 3.0 5.0'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'The elements of the created numeric streams are of a primitive type:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: //list.stream().mapToInt(String::length)
  prefs: []
  type: TYPE_NORMAL
- en: //             .map(Integer::shortValue)   //compile error
  prefs: []
  type: TYPE_NORMAL
- en: //             .forEach(System.out::print);
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'And since we are on this topic, if you would like to convert elements to a
    numeric wrapping type, the `map()` intermediate operation is the way to do it
    (instead of `mapToInt()`):'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: list.stream().map(String::length)
  prefs: []
  type: TYPE_NORMAL
- en: .map(Integer::shortValue)
  prefs: []
  type: TYPE_NORMAL
- en: '.forEach(System.out::print);  //prints: 335'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: flatMapToInt(), flatMapToLong(), and flatMapToDouble()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `flatMapToInt()`, `flatMapToLong()`, `flatMapToDouble()` intermediate operations
    produce a numeric stream of a corresponding type:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: List<Integer> list = List.of(1, 2, 3);
  prefs: []
  type: TYPE_NORMAL
- en: list.stream().flatMapToInt(i -> IntStream.rangeClosed(1, i))
  prefs: []
  type: TYPE_NORMAL
- en: '.forEach(System.out::print);    //prints: 112123'
  prefs: []
  type: TYPE_NORMAL
- en: list.stream().flatMapToLong(i -> LongStream.rangeClosed(1, i))
  prefs: []
  type: TYPE_NORMAL
- en: '.forEach(System.out::print);    //prints: 112123'
  prefs: []
  type: TYPE_NORMAL
- en: list.stream().flatMapToDouble(DoubleStream::of)
  prefs: []
  type: TYPE_NORMAL
- en: '.forEach(d -> System.out.print(d + " "));  //prints: 1.0 2.0 3.0'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, in the preceding code, we have used `int` values in the original
    stream. But it can be a stream of any type:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: List<String> str = List.of("one", "two", "three");
  prefs: []
  type: TYPE_NORMAL
- en: str.stream().flatMapToInt(s -> IntStream.rangeClosed(1, s.length()))
  prefs: []
  type: TYPE_NORMAL
- en: '.forEach(System.out::print);  //prints: 12312312345'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Terminal operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The additional Terminal operations of numeric streams are pretty straightforward.
    There are two of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sum()`: Calculates the sum of the numeric stream elements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`average()`: Calculates the average of the numeric stream elements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: sum() and average()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you need to calculate a sum or an average of the values of numeric stream
    elements, the only requirement for the stream is that it should not be infinite.
    Otherwise, the calculation never finishes:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: int sum = IntStream.empty().sum();
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(sum);          //prints: 0'
  prefs: []
  type: TYPE_NORMAL
- en: sum = IntStream.range(1, 3).sum();
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(sum);          //prints: 3'
  prefs: []
  type: TYPE_NORMAL
- en: double av = IntStream.empty().average().orElse(0);
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(av);           //prints: 0.0'
  prefs: []
  type: TYPE_NORMAL
- en: av = IntStream.range(1, 3).average().orElse(0);
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(av);           //prints: 1.5'
  prefs: []
  type: TYPE_NORMAL
- en: long suml = LongStream.range(1, 3).sum();
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(suml);         //prints: 3'
  prefs: []
  type: TYPE_NORMAL
- en: double avl = LongStream.range(1, 3).average().orElse(0);
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(avl);          //prints: 1.5'
  prefs: []
  type: TYPE_NORMAL
- en: double sumd = DoubleStream.of(1, 2).sum();
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(sumd);         //prints: 3.0'
  prefs: []
  type: TYPE_NORMAL
- en: double avd = DoubleStream.of(1, 2).average().orElse(0);
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(avd);          //prints: 1.5'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, using these operations on an empty stream is not a problem.
  prefs: []
  type: TYPE_NORMAL
- en: Parallel processing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen that changing from a sequential stream to a parallel stream can
    lead to incorrect results if the code was not written and tested for processing
    a parallel stream. The following are a few more considerations related to the
    parallel stream.
  prefs: []
  type: TYPE_NORMAL
- en: Stateless and stateful operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are stateless operations, such as `filter()`, `map()`, and `flatMap()`,
    which do not keep data around (do not maintain state) while moving from processing
    from one stream element to the next. And there are stateful operations, such as
    `distinct()`, `limit()`, `sorted()`, `reduce()`, and `collect()`, which may pass
    the state from previously processed elements to the processing of the next element.
  prefs: []
  type: TYPE_NORMAL
- en: Stateless operations usually do not pose a problem when switching from a sequential
    stream to a parallel one. Each element is processed independently and the stream
    can be broken into any number of sub-streams for independent processing.
  prefs: []
  type: TYPE_NORMAL
- en: With stateful operations, the situation is different. To start with, using them
    for an infinite stream may never finish processing. Also, while discussing the `reduce()`
    and `collect()` stateful operations, we have demonstrated how switching to a parallel
    stream can produce a different result if the initial value (or identity) is set
    without parallel processing in mind.
  prefs: []
  type: TYPE_NORMAL
- en: And there are performance considerations too. Stateful operations often require
    processing all the stream elements in several passes using buffering. For large
    streams, it may tax JVM resources and slow down, if not completely shut down,
    the application.
  prefs: []
  type: TYPE_NORMAL
- en: That is why a programmer should not take switching from a sequential to a parallel
    stream lightly. If stateful operations are involved, the code has to be designed
    and tested to be able to perform the parallel stream processing without negative
    effects.
  prefs: []
  type: TYPE_NORMAL
- en: Sequential or parallel processing?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we indicated in the previous section, parallel processing may or may not
    produce better performance. One has to test every use case before deciding to
    use it. Parallelism can yield better performance, but the code has to be designed
    and possibly optimized to do it. And each assumption has to be tested in the environment
    as close to the production as possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there are a few considerations one can take into account while deciding
    between sequential and parallel processing:'
  prefs: []
  type: TYPE_NORMAL
- en: Small streams typically are processed faster sequentially (well, what is "small"
    for your environment should be determined through testing and measuring the performance)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If stateful operations cannot be replaced with stateless ones, design the code
    carefully for the parallel processing or just avoid it completely
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consider parallel processing for the procedures that require extensive calculations,
    but think about bringing the partial results together for the final result
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exercise – Multiplying all the stream elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Multiply all the values of the following list using a stream:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: List<Integer> list = List.of(2, 3, 4);
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Answer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: int r = list.stream().reduce(1, (x, y) -> x * y);
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(r);     //prints: 24'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter introduced the powerful concept of data-streams processing and
    provided many examples of functional programming usage. It explained what streams
    are, how to process them, and how to build processing pipelines. It also demonstrated
    how one can organize stream processing in parallel and some of the possible pitfalls.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to discuss reactive systems, their advantages,
    and possible implementations. You will learn about asynchronous non-blocking processing,
    reactive programming, and microservices, all with code examples that demonstrate
    the main principles on which these reactive systems are based.
  prefs: []
  type: TYPE_NORMAL
