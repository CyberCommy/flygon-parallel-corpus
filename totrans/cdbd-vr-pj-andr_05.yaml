- en: Chapter 5. RenderBox Engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While the Cardboard Java SDK and OpenGL ES are powerful and robust libraries
    for mobile VR applications, they're pretty low level. Software development best
    practices expect that we abstract common programming patterns into new classes
    and data structures. In [Chapter 3](ch03.html "Chapter 3. Cardboard Box"), *Cardboard
    Box*, we got some hands-on experience with the nitty gritty details. This time,
    we're revisiting those details while abstracting them into a reusable library
    that we'll call **RenderBox**. There'll be vector math, materials, lighting, and
    more, all rolled up into a neat little package.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn to:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Cardboard project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write a `Material` class with shaders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explore our `Math` package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write a `Transform` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write a `Component` class with `RenderObject Cube`, `Camera`, and `Light` components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a `Material` class for rendering cubes with vertex colors and lighting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write a `Time` animation class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Export all this into a `RenderBox` library for reuse
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The source code for this project can be found on the Packt Publishing website,
    and on GitHub at [https://github.com/cardbookvr/renderboxdemo](https://github.com/cardbookvr/renderboxdemo)
    (with each topic as a separate commit). The final `RenderBoxLib` project, which
    will continue to be maintained and reused in other projects in this book, can
    also be found on the Packt Publishing website and on GitHub at [https://github.com/cardbookvr/renderboxlib](https://github.com/cardbookvr/renderboxlib).
  prefs: []
  type: TYPE_NORMAL
- en: Introducing RenderBox – a graphics engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a virtual reality app, you are creating a three-dimensional space with a
    bunch of objects. The user's viewpoint, or camera, is also located in this space.
    With the help of the Cardboard SDK, the scene is rendered twice, once for the
    left and right eye, to create the side-by-side stereoscopic views. The second
    and equally important feature translates the sensor data into a head look direction,
    tracking the real-life user's head. The pixels are drawn on the screen, or rendered,
    using the OpenGL ES library, which talks to the hardware **graphics processor**
    (**GPU**) on your device.
  prefs: []
  type: TYPE_NORMAL
- en: We're going to organize the graphics rendering code into separate Java classes,
    which we'll be able to extract into a reusable graphics engine library. We'll
    call this library **RenderBox**.
  prefs: []
  type: TYPE_NORMAL
- en: As you'll see, the `RenderBox` class implements the `CardboardView.StereoRender`
    interface. But it's more than that. Virtual reality needs 3D graphics rendering,
    and to do all this in low-level OpenGL ES calls (and other supporting APIs) can
    be tedious, to say the least, especially as your application grows. Furthermore,
    these APIs require you to think like a semiconductor chip! Buffers, shaders, and
    matrix math, oh my! I mean seriously, who wants to think like that all the time?
    I'd rather think like a 3D artist and VR developer.
  prefs: []
  type: TYPE_NORMAL
- en: There are many distinct pieces to track and manage, and they can get complicated.
    As software developers, it's our role to identify common patterns and implement
    layers of abstraction, which serve to reduce this complexity, avoid duplicated
    code, and express the program as objects (software classes) closer to the problem
    domain. In our case, this domain makes 3D scenes that can be rendered on Cardboard
    VR devices.
  prefs: []
  type: TYPE_NORMAL
- en: '`RenderBox` starts to abstract away details into a nice clean layer of code.
    It is designed to take care of OpenGL calls and complex arithmetic, while still
    letting us set up our app-specific code the way we want. It also creates a common
    pattern known as the **entity component pattern** ([https://en.wikipedia.org/wiki/Entity_component_system](https://en.wikipedia.org/wiki/Entity_component_system))
    for new materials and component types if our projects demand any special cases.
    Here''s an illustration of the major classes in our library:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introducing RenderBox – a graphics engine](img/B05144_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `RenderBox` class implements `CardboardView.StereoRenderer`, relieving that
    responsibility from the app's `MainActivity` class. As we'll see, `MainActivity`
    communicates with `RenderBox` through the `IRenderBox` interface (with the setup,
    `preDraw`, and `postDraw` hooks) so that `MainActivity` implements `IRenderBox`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider the kinds of `Component` that can participate in a 3D VR scene:'
  prefs: []
  type: TYPE_NORMAL
- en: '`RenderObject`: These are drawable models in the scene, such as cubes and spheres'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Camera`: This is the viewpoint of the user, which is used to render the scene'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Light`: These are sources of illumination used for shading and shadows'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every object in our scene has an X, Y, and Z location in space, a rotation,
    and three scale dimensions. These properties are defined by the `Transform` class.
    Transforms can be arranged in a hierarchy, letting you build more complex objects
    that are assembled from simpler ones.
  prefs: []
  type: TYPE_NORMAL
- en: Each `Transform` class can be associated with one or more `Component` classes.
    Different kinds of components (for example, `Camera`, `Light`, and `RenderObject`)
    extend the `Component` class. A component should not exist without being attached
    to a `Transform` class but the reverse (a transform with no components) is perfectly
    fine.
  prefs: []
  type: TYPE_NORMAL
- en: Internally, `RenderBox` maintains a list of `RenderObjects`. These are the geometric
    models in the scene. Types of `RenderObjects` include `Cube` and `Sphere`, for
    example. These objects are associated with a `Material`, which defines their color,
    texture, and/or shading properties. Materials, in turn, reference, compile, and
    execute low-level shader programs. Maintaining a flat list of components to render
    each frame is more efficient than traversing the transform hierarchy every frame.
    It is a perfect example of why we use the entity component pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Other things in the `RenderBox` package include a `Time` class used to implement
    animations, and a library of `Math` functions used for vector and matrix operations.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's start putting this together.
  prefs: []
  type: TYPE_NORMAL
- en: What's the game plan? The end goal is to create our `RenderBox` graphics engine
    library. It will be handy to maintain it in its own project (and repository if
    you're using source control, such as Git), so it can be improved and maintained
    independently. However, to kick this off, we need a simple app to build it, show
    you how to use it, and verify (if not test) that it is working properly. This
    will be called `RenderBoxDemo`. At the end of the chapter, we will extract the
    `RenderBox` code into an Android library module and then export it.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you''d like more details and explanation about these steps, refer to the
    *Creating a new Cardboard project* section [Chapter 2](ch02.html "Chapter 2. The
    Skeleton Cardboard Project"), *The Skeleton Cardboard Project*, and follow along
    there:'
  prefs: []
  type: TYPE_NORMAL
- en: With Android Studio opened, create a new project. Let's name it `RenderBoxDemo`
    and target **Android 4.4 KitKat (API 19)** with an **Empty Activity**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the Cardboard SDK `common.aar` and `core.aar` library files to your project
    as new modules, using **File** | **New** | **New Module...**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the library modules as dependencies to the project app, using **File** |
    **Project Structure**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Edit the `AndroidManifest.xml` file as explained in [Chapter 2](ch02.html "Chapter 2. The
    Skeleton Cardboard Project"), *The Skeleton Cardboard Project*, being careful
    to preserve the `package` name for this project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Edit the `build.gradle` file as explained in [Chapter 2](ch02.html "Chapter 2. The
    Skeleton Cardboard Project"), *The Skeleton Cardboard Project*, to compile against
    SDK 22.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Edit the `activity_main.xml` layout file as explained in [Chapter 2](ch02.html
    "Chapter 2. The Skeleton Cardboard Project"), *The Skeleton Cardboard Project*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, open the `MainActivity.java` file and edit the `MainActivity` Java class
    to extend `CardboardActivity`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that unlike the previous chapters, we do not implement `CardboardView.StereoRender`.
    Instead, we will implement that interface in the `RenderBox` class (in the next
    topic).
  prefs: []
  type: TYPE_NORMAL
- en: Creating the RenderBox package folder
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since our plan is to export the `RenderBox` code as a library, let's put it
    all into its own package.
  prefs: []
  type: TYPE_NORMAL
- en: In the Android hierarchy panel, use the `Gear` icon and uncheck **Compact Empty
    Middle Packages** so that we can insert the new package under **com.cardbookvr**.
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on the `app/java/com/carbookvr/` folder in the project view, navigate
    to **New** | **Package**, and name it `renderbox`. You may now wish to enable
    **Compact Empty Middle Packages** again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the `renderbox` folder, create three package subfolders named `components`,
    `materials`, and `math`. The project should now have the same folders as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the RenderBox package folder](img/B05144_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Creating an empty RenderBox class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's begin by creating a skeleton of the `RenderBox` class Java code. Right-click
    on the `renderbox/` folder, navigate to **New** | **Java Class**, and name it
    `RenderBox`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, open the `RenderBox.java` file and edit it to implement the `CardboardView.StereoRenderer`
    interfaces. Add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: It's primarily housekeeping at this point. The `RenderBox` class is defined
    as `implements` `CardboardView.StereoRenderer`. Its constructor will receive a
    reference to the `MainActivity` instance and the `IRenderBox` implementer (in
    this case, also the `MainActivity`) class. `MainActivity` will now have to implement
    the `IRenderBox` methods (to be defined next). In this way, we instantiate the
    framework and implement the critical methods.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we also make `RenderBox` a singleton by registering the `this` instance
    in the class constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'We must also add the method overrides for the `StereoRenderer` class. From
    the intellisense menu, select **Implement Methods…** (or *Ctrl* + *I*) to add
    the stub method overrides for the interface, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'It is now a good time to add an error reporting method, `checkGLError`, to
    `RenderBox` to log OpenGL rendering errors, as illustrated in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the previous chapter projects, we defined `MainActivity` so that it implements
    `CardboardView.StereoRenderer`. Now this is delegated to our new `RenderBox` object.
    Let's tell `MainActivity` to use it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `MainActivity.java`, modify the `onCreate` method to create a new instance
    of `RenderBox` and set it as the view renderer, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note that `cardboardView.setRender` is passed new `RenderBox`, which takes the
    `MainActivity` instance as both the `Activity` and `IRenderBox` arguments. Voila,
    we've taken control of the Cardboard SDK integration entirely, and now it's all
    about implementing `IRenderbox`. In this way, we have wrapped the Cardboard SDK,
    OpenGL, and a variety of other external dependencies in our own library. Now,
    if these specifications change, all we have to do is keep `RenderBox` up to date,
    and our app can tell `RenderBox` what to do, the same way as always.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the IRenderBox interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once we've put all this together, the `MainActivity` class will implement the
    `IRenderBox` interface. The interface provides callbacks for the `setup`, `preDraw`,
    and `postDraw` functions that the activity may implement.
  prefs: []
  type: TYPE_NORMAL
- en: The setup method will be called after doing some generic work in `onSurfaceCreated`.
    The `preDraw` and `postDraw` methods will be called during `onDrawEye`. We'll
    get to see this later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can set that up now. Right-click on `renderbox` in the hierarchy panel,
    navigate to **New** | **Java Class**, select **Kind: "Interface"**, and name it
    `IRenderBox`. It''s only a few lines and should include just the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, modify `MainActivity` so that it implements `IRenderBox`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Select intellisense **Implement Methods** (or *Ctrl* + *I*), to add the interface
    methods overrides. Android Studio will automatically fill in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run the empty app now, you will not get any build errors, and it''ll
    display the empty Cardboard split view:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding the IRenderBox interface](img/B05144_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now we have created a skeleton app, ready to implement the `RenderBox` package
    and utilities, which we can use to help build new Cardboard VR applications.
  prefs: []
  type: TYPE_NORMAL
- en: In the next few topics, we will build some of the classes needed in `RenderBox`.
    Unfortunately, we can't display anything interesting on your Cardboard device
    until we get these coded up. This also limits our ability to test and verify that
    the coding is correct. This could be an appropriate time to introduce unit testing,
    such as JUnit. Refer to the *Unit testing support* docs for details ([http://tools.android.com/tech-docs/unit-testing-support](http://tools.android.com/tech-docs/unit-testing-support)).
    Unfortunately, space does not allow us to introduce this subject and use it for
    the projects in this book. But we encourage you to pursue this on your own. (And
    I'll remind you that the GitHub repository for this project has separate commits
    for each topic, incrementally adding code as we go along).
  prefs: []
  type: TYPE_NORMAL
- en: Materials, textures, and shaders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 3](ch03.html "Chapter 3. Cardboard Box"), *Cardboard Box*, we introduced
    the OpenGL ES 2.0 graphics pipeline and simple shaders. We will now extract that
    code into a separate `Material` class.
  prefs: []
  type: TYPE_NORMAL
- en: In computer graphics, materials refer to the visual surface characteristics
    of geometric models. When rendering an object in the scene, materials are used
    together with lighting and other scene information required by the shader code
    and the OpenGL graphics pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: A solid colored material is the simplest; the entire surface of the object is
    a single color. Any color variation in the final rendering will be due to lighting,
    shadows, and other features in a different shader variant. It is quite possible
    to produce solid color materials with lighting and shadows, but the simplest possible
    example just fills raster segments with the same color, such as our very first
    shader.
  prefs: []
  type: TYPE_NORMAL
- en: A textured material may have surface details defined in an image file (such
    as a JPG). Textures are like wallpapers pasted on the surface of the object. They
    can be used to a great extent and are responsible for most of the details that
    the user perceives on an object. A solid colored sphere may look like a ping pong
    ball. A textured sphere may look like the Earth. More texture channels can be
    added to define variations in shading or even to emit light when the surface is
    in shadow. You will see this kind of effect at the end of [Chapter 6](ch06.html
    "Chapter 6. Solar System"), *Solar System*, when we add an artificial light to
    the dark side of the Earth.
  prefs: []
  type: TYPE_NORMAL
- en: More realistic physically-based shading goes beyond texture maps to include
    simulated height maps, metallic shininess, and other imperfections, such as rust
    or dirt. We won't be going into that in this book, but it's common in graphics
    engines such as Unity 3D and the Unreal Engine. Our `RenderBox` library could
    be extended to support it.
  prefs: []
  type: TYPE_NORMAL
- en: Presently, we'll build the infrastructure for a basic solid colored material
    and associated shaders. Later in the chapter, we'll expand it with lighting.
  prefs: []
  type: TYPE_NORMAL
- en: Abstract material
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the `renderbox/materials/` folder, create a new Java class named `Material`
    and begin to write it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This defines an abstract class that will be used to extend the various types
    of materials we define. The `createProgram` method loads the designated shader
    scripts and builds an OpenGL ES program with the shaders attached.
  prefs: []
  type: TYPE_NORMAL
- en: We also define an abstract `draw()` method that will be implemented in each
    shader separately. Among other things, it requires the `modelView` and `modelViewProjection`
    transformation matrices be declared at the top of the class. At this point, we
    will actually only use `modelViewProjection`, but a separate reference to the
    `modelView` matrix will be needed when we add lighting.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add the following utility methods to the `Material` class to load the
    shaders:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As discussed in [Chapter 3](ch03.html "Chapter 3. Cardboard Box"), *Cardboard
    Box*, these methods will load a shader script and compile it.
  prefs: []
  type: TYPE_NORMAL
- en: Later on, we'll derive specific materials from this class, and define specific
    shaders that each one will use.
  prefs: []
  type: TYPE_NORMAL
- en: The Math package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 3](ch03.html "Chapter 3. Cardboard Box"), *Cardboard Box*, we introduced
    3D geometry and matrix math calculations. We will wrap these up into even more
    useful functions.
  prefs: []
  type: TYPE_NORMAL
- en: Much of this math code that we've put together is from existing open source
    projects (attributions are given in comments in the source code). After all, we
    might as well take advantage of the math geniuses who like this stuff and have
    open sourced excellent true and tested code. The code list is included with the
    file downloads for this book.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The following list documents our math API. The actual code is included with
    the file downloads for this book and the GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: Generally speaking, the mathematics falls within the subject of linear algebra,
    but most of it is specific to graphics programming and works within the constraints
    of fast floating point math on modern CPUs.
  prefs: []
  type: TYPE_NORMAL
- en: We encourage you to browse the source code included with the book, which you
    will obviously need access to in order to complete the project. Suffice it to
    say that everything included is pretty standard fare for a 3D game engine and
    was, in fact, largely sourced from (or checked against) an open source engine
    called **LibGDX**. The math library for LibGDX is pretty vast, optimized for mobile
    CPUs, and could make a great drop-in replacement for our simpler math package.
    We will also use the Android `Matrix` class extensively, which, in most cases,
    runs in native code and avoids the overhead of the **Java Virtual Machine** (**JVM**
    or Dalvik VM in the case of Android).
  prefs: []
  type: TYPE_NORMAL
- en: Here's a summary of our math API.
  prefs: []
  type: TYPE_NORMAL
- en: MathUtils
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `MathUtils` variables and methods are mostly self-explanatory: `PI`, `sin`,
    `cos`, and so on, defined to use `floats` as an alternative to Java''s `Math`
    class, which contains doubles. In computer graphics, we speak floats. The math
    takes less power and fewer transistors and the precision loss is acceptable. Your
    `MathUtils` class should look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Matrix4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Matrix4` class manages 4 x 4 transformation matrices and is used to translate
    (position), rotate, and scale points in three-dimensional space. We''ll make good
    use of these soon. Here is an abridged version of the `Matrix4` class with function
    bodies removed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Make a special note of the TRS function. It is used by the `Transform` class
    to combine the position, rotation, and scale information into a useful matrix,
    which represents all three. The order in which this matrix is created is important.
    First, we generate a translation matrix, and then we rotate and scale it. The
    resulting matrix can be multiplied by any 3D point (our vertices) to apply these
    three operations hierarchically.
  prefs: []
  type: TYPE_NORMAL
- en: Quaternion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **quaternion** represents a rotational orientation in three-dimensional space
    in such a way that, when two quaternions are combined, no information is lost.
  prefs: []
  type: TYPE_NORMAL
- en: 'From a human point of view, it''s easier to think of rotational orientation
    as three Euler (pronounced "oiler") angles since we think of three dimensions
    of rotation: pitch, yaw, and roll. The reason we use quaternions as opposed to
    a more straightforward vector representation of rotations is that depending on
    the order in which you apply the three Euler rotations to an object, the resulting
    3D orientation will be different.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For more information on quaternions and Euler angles, refer to the following
    links:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Quaternions_and_spatial_rotation](https://en.wikipedia.org/wiki/Quaternions_and_spatial_rotation)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Euler_angles](https://en.wikipedia.org/wiki/Euler_angles)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://mathworld.wolfram.com/EulerAngles.html](http://mathworld.wolfram.com/EulerAngles.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles](https://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Even though quaternions are a four-dimensional construct, we treat each quaternion
    as a single value, which represents a 3D orientation. Thus, when we apply multiple
    rotation operations in a row, we don''t run into issues where one axis'' rotation
    influences the effect of another. If none of this makes any sense, don''t worry.
    This is one of the trickiest concepts in 3D graphics. Here is the abridged `Quaternion`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Vector2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A **Vector2** is a two-dimensional point or direction vector defined by (X,Y)
    coordinates. With the `Vector2` class, you can transform and manipulate vectors.
    Here is the abridged `Vector2` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Vector3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A **Vector3** is a three-dimensional point or direction vector defined by X,
    Y, and Z coordinates. With the `Vector3` class, you can transform and manipulate
    vectors. Here is the abridged `Vector3` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '`Vector2` and `Vector3` share a lot of the same functionality, but pay special
    attention to the functions that exist in 3D, and that do not exist in 2D. Next,
    we''ll see how the math library gets used when we implement the `Transform` class.'
  prefs: []
  type: TYPE_NORMAL
- en: The Transform class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A 3D virtual reality scene will be constructed from various objects, each with
    a position, rotation, and scale in 3D dimensional space defined by a `Transform`.
  prefs: []
  type: TYPE_NORMAL
- en: It will also be naturally useful to permit transforms to be grouped hierarchically.
    This grouping also creates a distinction between local space and world space,
    where children only keep track of the difference between their **translation,
    rotation, and scale** (**TRS**) and that of their parent (local space). The actual
    data that we are storing is the local position (we'll use the words position and
    translation interchangeably), rotation, and scale. Global position, rotation,
    and scale are computed by combining the local TRS all the way up the chain of
    parents.
  prefs: []
  type: TYPE_NORMAL
- en: First, let's define the `Transform` class. In the Android Studio hierarchy panel,
    right-click on `renderbox/`, go to **New** | **Java Class**, and name it `Transform`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each `Transform` may have one or more associated components. Typically there
    is just one, but it is possible to add as many as you want (as we''ll see in the
    other projects in this book). We''ll maintain a list of components in the transform,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We will define the `Component` class in the next topic. If it really bothers
    you to reference it now before it's defined, you can start with an empty Component
    Java class in the `renderbox/components` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Now back to the `Transform` class. A `Transform` object has a location, orientation,
    and scale in space, defined by its `localPosition`, `localRotation`, and `localScale`
    variables. Let's define these private variables, and then add the methods to manipulate
    them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, as transforms can be arranged in a hierarchy, we''ll include a reference
    to a possible `parent` transform, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The position, rotation, and scale values are initialized to identity values,
    that is, no positional offset, rotation, or resizing until they are explicitly
    set elsewhere. Note that the identity scale is (1, 1, 1).
  prefs: []
  type: TYPE_NORMAL
- en: The `parent` transform variable allows each transform to have a single parent
    in the hierarchy. You can keep the list of children in the transform, but you
    might be surprised to know how far you can get without having to move down the
    hierarchy. If you can avoid it, as we have, you can save a good deal of branching
    when setting/unsetting a parent reference. Maintaining the list of children means
    an *O(n)* operation every time you unparent an object, and an extra *O(1)* insertion
    cost on setting a parent. It is also not very efficient to hunt through children
    looking for a particular object.
  prefs: []
  type: TYPE_NORMAL
- en: Parent methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The transform can be added or removed from its position in the hierarchy with
    the `setParent` and `unParent` methods, respectively. Let''s define them now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Simply, the `setParent` method sets `this.parent` to the given parent transform.
    Optionally, you can specify that the position is updated relative to the parent.
    We added an optimization to skip this procedure if the parent is already set.
    Setting the parent to `null` is equivalent to calling `unParent`.
  prefs: []
  type: TYPE_NORMAL
- en: The `unParent` method removes the transform from the hierarchy. Optionally,
    you can specify that the position is updated relative to the (previous) parents,
    so that the transform is now disconnected from the hierarchy but remains in the
    same position in world space.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the rotation and scale can, and should, also be updated when parenting
    and unparenting. We don't need that in the projects in this book, so they have
    been left as an exercise for the reader. Also, note that our `setParent` methods
    include an argument for whether to update the position. If it is `false`, the
    operation runs a little faster, but the global state of the object will change
    if the parent transform was not set to identity (no translation, rotation, or
    scale). For convenience, you may set `updatePosition` to `true`, which will apply
    the current global transformation to the local variables, keeping the object fixed
    in space, with its current rotation and scale.
  prefs: []
  type: TYPE_NORMAL
- en: Position methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `setPosition` methods set the transform position relative to the parent,
    or apply absolute world position to the local variable if there is no parent.
    Two overloads are provided if you want to use a vector or individual component
    values. `getPosition` will compute the world space position based on parent transforms,
    if they exist. Note that this will have a CPU cost related to the depth of the
    transform hierarchy. As an optimization, you may want to include a system to cache
    world space positions within the `Transform` class, invalidating the cache whenever
    a parent transform is modified. A simpler alternative would be to make sure that
    you store the position in a local variable right after calling `getPosition`.
    The same optimization applies for rotation and scale.
  prefs: []
  type: TYPE_NORMAL
- en: 'Define the position getters and setters as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Rotation methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `setRotation` methods set the transform rotation relative to the parent,
    or the absolute world rotation is applied to the local variable if there is no
    parent. Again, multiple overloads provide options for different input data. Define
    the rotation getters and setters as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Scale methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `setScale` methods set the transform scale relative to the parent, or apply
    the absolute scale to the local variable if there is no parent. Define getters
    and setters for the scale as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Transform to matrix and draw
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The last thing we need to do with the `Transform` class is transform an identity
    matrix into one that will tell OpenGL how to draw the object correctly. To do
    this, we translate, rotate, and scale the matrix, in that order. Technically,
    we can also do cool things with matrices, such as shearing and skewing models,
    but the math is complicated enough as it is. If you want to learn more, type `transformation
    matrix`, `quaternion to matrix`, and some of the other terms that we have been
    throwing around into a search engine. The actual math behind all of this is fascinating
    and way too detailed to explain in a single paragraph.
  prefs: []
  type: TYPE_NORMAL
- en: We also provide the `drawMatrix()` function that sets up the lighting and model
    matrices for a draw call. Since the lighting model is an intermediate step, it
    makes sense to combine this call;
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `drawMatrices` method uses variables from the `RenderObject` class, which
    will be defined later. It might seem very anti-Java that we are just setting our
    matrices to static variables in the `RenderObject` class. As you will see, there
    is actually no need for multiple instances of the `lightingModel` object and model
    to exist. They are always calculated just in time for each object as they are
    drawn. If we were to introduce optimizations that avoid recomputing this matrix
    all the time, it would make sense to keep the information around. For the sake
    of simplicity, we just recalculate the matrix every time each object is drawn,
    since it might have changed since the last frame.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we'll see how the `Transform` class gets used when we implement the `Component`
    class, which will be extended by a number of classes that define objects in the
    3D scene.
  prefs: []
  type: TYPE_NORMAL
- en: The Component class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our 3D virtual reality scenes consist of various kinds of components. Components
    may include geometric objects, lights, and cameras. Components can be positioned,
    rotated, and scaled in 3D space, according to their associated transform. Let's
    create a `Component` class that will serve as the basis for other object classes
    in the scene.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you haven''t created `Component.java` yet, create one now in the `renderbox/components`
    folder. Define it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We've included an `enabled` flag, which will come in handy to easily hide/show
    objects when we draw our scene.
  prefs: []
  type: TYPE_NORMAL
- en: That's it. Next, we'll define our first component, `RenderObject`, to represent
    geometric objects in the scene.
  prefs: []
  type: TYPE_NORMAL
- en: The RenderObject component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`RenderObject` will serve as the parent class of geometric objects that can
    be rendered in the scene. `RenderObject` extends `Component`, so it has a `Transform`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `renderbox/components` folder, create a new Java class, `RenderObject`.
    Define it as an abstract class that extends `Component`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The first thing we do is have each instance add itself to the list of `renderObjects`
    maintained by the `RenderBox` instance. Let's jump over to the `RenderBox` class
    now and add support for this list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `RenderBox.java` file and add a `renderObjects` list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, back to the `RenderObject` class; we''ll implement three methods: `allocateFloatBuffer`,
    `allocateShortBuffer`, and `draw`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'OpenGL ES requires us to allocate a number of different memory buffers for
    various data, including model vertices, normal vectors, and index lists. The `allocateFloatBuffer`
    and `allocateShortBuffer` methods are utility methods that objects can use for
    floats and integers, respectively. Indexes are integers (specifically, shorts);
    everything else will be floats. These will be available to derived object classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Clever readers might have noticed that we're using `ByteBuffer` first, and then
    converting it to `FloatBuffer` or `ShortBuffer`. While the conversion from a byte
    to float might make sense—raw memory is not often represented as floats—some might
    wonder why we don't allocate the `ShortBuffer` as a `ShortBuffer` from the start.
    The reason is actually the same in both cases. We want to take advantage of the
    `allocateDirect` method, which is more efficient and only exists within the `ByteBuffer`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ultimately, the purpose of a `RenderObject` component is to draw geometry on
    the screen. This is done by transforming the 3D view and rendering through a `Material`
    class. Let''s define variables for the material, some setter and getter methods,
    and the `draw` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The `draw` method prepares the model transform for this object, and most of
    the draw action happens in materials. The `draw` method will be called from the
    current `Camera` component as it responds to the pose from the Cardboard SDK's
    `onDrawEye` hook. If the component isn't enabled, it's skipped.
  prefs: []
  type: TYPE_NORMAL
- en: The `RenderObject` class is abstract; we will not be working with `RenderObjects`
    directly. Instead, we'll derive object classes, such as `Cube` and `Sphere`. Let's
    create the `Cube` class from the `RenderObject` component next.
  prefs: []
  type: TYPE_NORMAL
- en: The Cube RenderObject component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For demonstration purposes, we''ll start with a simple cube. Later on, we''ll
    improve it with lighting. In [Chapter 3](ch03.html "Chapter 3. Cardboard Box"),
    *Cardboard Box*, we defined a `Cube` model. We''ll start by using the same class
    and data structure here. You can even copy the code, but it''s shown in the following
    text. Create a `Cube` Java class in the `renderbox/components/` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We list the coordinates for each face of the cube. Each face is made up of two
    triangles, resulting in 12 triangles, or a total of 36 sets of coordinates to
    define the cube.
  prefs: []
  type: TYPE_NORMAL
- en: We also list the different colors for each face of the cube. Rather than duplicating
    the colors 36 times, there's the `cubeFacesToArray` method to generate them.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we need to upgrade `Cube` for `RenderBox`.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, add the words `extends` `RenderObject`. This will provide the `super()`
    method in the constructor and allow you to call the `draw()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Allocate buffers for its vertices and colors, and create the `Material` class
    that''ll be used for rendering:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We ensure that `allocateBuffers` is run only once by checking whether `vertexBuffer`
    is `null`.
  prefs: []
  type: TYPE_NORMAL
- en: We plan to use the `VertexColorMaterial` class for rendering most cubes. That
    will be defined next.
  prefs: []
  type: TYPE_NORMAL
- en: A `Camera` component will call the `draw` method of the `Cube` class (inherited
    from `RenderObject`), which, in turn, calls the `Material` class's `draw` method.
    The `draw` method will be called from the main `Camera` component as it responds
    to the Cardboard SDK's `onDrawEye` hook.
  prefs: []
  type: TYPE_NORMAL
- en: Vertex color material and shaders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Cube` component needs a `Material` to render it on the display. Our `Cube`
    has separate colors for each face, defined as separate vertex colors. We'll define
    a `VertexColorMaterial` instance and the corresponding shaders.
  prefs: []
  type: TYPE_NORMAL
- en: Vertex color shaders
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At a minimum, the OpenGL pipeline requires that we define a vertex shader,
    which transforms vertices from 3D space to 2D, and a fragment shader, which calculates
    the pixel color values for a raster segment. Similar to the simple shaders that
    we created in [Chapter 3](ch03.html "Chapter 3. Cardboard Box"), *Cardboard Box*,
    we''ll create two files, `vertex_color_vertex.shader` and `vertex_color_fragment.shader`.
    Unless you have done so already, create a new Android resource directory with
    the `raw` type and name it `raw`. Then, for each file, right-click on the directory,
    and go to **New** | **File**. Use the following code for each of the two files.
    The code for the vertex shader is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The code for the fragment shader is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The `vertex` shader transforms each vertex by the `u_MVP` matrix, which will
    be supplied by the `Material` class's draw function. The fragment shader simply
    passes through the color specified by the vertex shader.
  prefs: []
  type: TYPE_NORMAL
- en: VertexColorMaterial
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, we''re ready to implement our first material, the `VertexColorMaterial`
    class. Create a new Java class named `VertexColorMaterial` in the `renderbox/materials/`
    directory. Define the class as `extends Material`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The methods we''re going to implement are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`VertexColorMaterial`: These are constructors'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setupProgram`: This creates the shader program and gets its OpenGL variable
    locations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setBuffers`: This sets the allocated buffer used in rendering'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`draw`: This draws a model from a view perspective'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s the complete code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The `setupProgram` method creates an OpenGL ES program for the two shaders that
    we created in `res/raw/` directory—`vertex_color_vertex` and `vertex_color_fragment`.
    It then gets references to the `positionParam`, `colorParam`, and `MVPParm` shader
    variables using the `GetAttribLocation` and `GetUniformLocation` calls that provide
    memory locations within the shader program, which are used later for drawing.
  prefs: []
  type: TYPE_NORMAL
- en: The `setBuffers` method sets the memory buffers for vertices that define an
    object that will be drawn using this material. The method assumes that an object
    model consists of a set of 3D vertices (X, Y, and Z coordinates).
  prefs: []
  type: TYPE_NORMAL
- en: The `draw()` method renders the object specified in the buffers with a given
    set of **model-view-perspective** (**MVP**) transformation matrices. (Refer to
    the *3D camera, perspective, and head rotation* section of [Chapter 3](ch03.html
    "Chapter 3. Cardboard Box"), *Cardboard Box*, for detailed explanations.)
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed that we aren't using that `ShortBuffer` function mentioned
    earlier. Later on, materials will use the `glDrawElements` call along with an
    index buffer. `glDrawArrays` is essentially a degenerate form of `glDrawElements`,
    which assumes a sequential index buffer (that is, 0, 1, 2, 3, and so on). It is
    more efficient with complex models to reuse vertices between triangles, which
    necessitates an index buffer.
  prefs: []
  type: TYPE_NORMAL
- en: For completeness, we will also provide a `destroy()` method for each of the
    `Material` classes. We will come to know exactly why the material must be destroyed
    a little later.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, `Material` encapsulates much of the lower level OpenGL ES 2.0
    calls to compile the shader script, create a render program, set the model-view-perspective
    matrices in the shader, and draw the 3D graphic elements.
  prefs: []
  type: TYPE_NORMAL
- en: We can now implement the `Camera` component.
  prefs: []
  type: TYPE_NORMAL
- en: The Camera component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A `Camera` class is another type of `Component`, positioned in space like other
    component objects. The camera is special because through the camera's eyes, we
    render the scene. For VR, we render it twice, once for each eye.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create the `Camera` class, and then see how it works. Create it in the
    `renderbox/components` folder and define it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Camera` class implements two methods: `onNewFrame` and `onDrawEye`, which
    will be delegated from the `RenderBox` class (which, in turn, is delegated from
    `MainActivity`).'
  prefs: []
  type: TYPE_NORMAL
- en: As the name implies, `onNewFrame` is called on each new frame update. It is
    passed the current Cardboard SDK's `HeadTransform`, which describes the user's
    head orientation. Our camera actually doesn't need the `headTransform` value,
    because `Eye.getEyeView()`, which is combined with the camera matrix, also contains
    rotation information. Instead, we just need to define its position and initial
    direction using `Matrix.setLookAtM` (refer to [http://developer.android.com/reference/android/opengl/Matrix.html](http://developer.android.com/reference/android/opengl/Matrix.html)).
  prefs: []
  type: TYPE_NORMAL
- en: The `onDrawEye` method is called by the Cardboard SDK once for each eye view.
    Given a Cardboard SDK eye view, the method begins to render the scene. It clears
    the surface, including the depth buffer (used to determine visible pixels), applies
    the eye transformation to the camera (including perspective), and then draws each
    `RenderObject` object in the scene.
  prefs: []
  type: TYPE_NORMAL
- en: RenderBox methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Alright! We're getting closer. We're now ready to build a little scene in `RenderBox`
    using the code we created earlier. To start, the scene will simply consist of
    a colored cube and, of course, a camera.
  prefs: []
  type: TYPE_NORMAL
- en: At the beginning of this project, we created the skeleton `RenderBox` class,
    which implements `CardboardView.StereoRenderer`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To this, we now add a `Camera` instance. At the top of the `RenderBox` class,
    declare `mainCamera`, which will get initialized in `onSurfaceCreated`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Note that Android Studio may find other `Camera` classes; ensure that it uses
    the one that we created in this package.
  prefs: []
  type: TYPE_NORMAL
- en: 'Shortly after your app starts and the `MainActivity` class is instantiated,
    the `onSurfaceCreated` callback is called. This is where we can clear the screen,
    allocate buffers, and build shader programs. Let''s add that now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'To be safe, the first thing it does is call reset, which will destroy any materials
    that might have already been compiled by resetting their program handles, before
    possibly compiling others. The need for this will become clear in the later projects
    where we will implement the intent feature to launch/relaunch the apps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The last thing `onSurfaceCreated` does is invoke the `setup` callback. This
    will be implemented in the interface implementer, which in our case is `MainActivity`.
  prefs: []
  type: TYPE_NORMAL
- en: In each new frame, we will call the camera's `onNewFrame` method to build the
    camera matrix and apply it to its model-view.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s also capture the current head pose (`headView` and `headAngles` as transformation
    matrices and angles, respectively) if we want to reference it in the later projects
    (refer to [https://developers.google.com/cardboard/android/latest/reference/com/google/vrtoolkit/cardboard/HeadTransform#public-constructors](https://developers.google.com/cardboard/android/latest/reference/com/google/vrtoolkit/cardboard/HeadTransform#public-constructors)).
    Still in `RenderBox`, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, when the Cardboard SDK goes to draw each eye (for the left and right
    split screen stereoscopic views), we will call the camera''s `onDrawEye` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: While we're at it, we can also enable the `preDraw` and `postDraw` callbacks
    (in the previous code, in `onNewFrame`, and in `onFinishFrame`, respectively).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Should these interface callbacks be implemented in `MainActivity`, they will
    be called from here.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can build a scene that uses a `Camera`, a `Cube`, and the `VertexColorMaterial`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: A simple box scene
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Let''s rock this riddim!* Make a scene with just a cube and, of course, a
    camera (which has been set up automatically by `RenderBox`). Set up the `MainActivity`
    class using the `IRenderBox` interface''s `setup` callback.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `setup` of `MainActivity`, we create a `Transform` for the cube and position
    it so that it''s set back and slightly offset in space:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: In Android Studio, click on **Run**. The program should compile, build, and
    install onto your connected Android phone. If you receive any compile errors,
    fix them now! As mentioned earlier, with the `Matrix` class, make sure that you
    are importing the right `Camera` type. There is also a `Camera` class within the
    SDK, which represents the phone's physical camera.
  prefs: []
  type: TYPE_NORMAL
- en: You will see something like this on your device display. (Remember to start
    the app while the device is facing you, or you might need to look behind you to
    find the cube!)
  prefs: []
  type: TYPE_NORMAL
- en: '![A simple box scene](img/B05144_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: I don't know about you, but I'm excited! Now, let's add some light and shading.
  prefs: []
  type: TYPE_NORMAL
- en: Cube with face normals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, let's add a light to the scene and render the cube with it. To do this,
    we also need to define normal vectors for each face of the cube, which are used
    in the shader calculations.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you derive `Cube` from the one in [Chapter 3](ch03.html "Chapter 3. Cardboard
    Box"), *Cardboard Box*, you may already have this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, add a buffers for the normals, like we have for colors and vertices, and
    allocate them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re going to add a lighting option argument to `createMaterial` and implement
    it using `VertexColorLightingMaterial` if it is set to `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Of course, the `VertexColorLightingMaterial` class hasn't been written yet.
    That's coming up soon. However, first we should create a `Light` component that
    can also be added to illuminate the scene.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will refactor the `Cube()` constructor method with two variations. When
    no arguments are given, the `Cube` does not create any `Material`. When a Boolean
    lighting argument is given, that gets passed to `createMaterial` in order to choose
    the material:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: We'll remind you later, but don't forget to modify the call to new `Cube(true)`
    in `MainActivity` to pass the lighting option.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we're creating the material in the constructor out of convenience.
    There is nothing to stop us from just adding a `setMaterial()` method to `RenderObject`
    or making the material variable public. In fact, as the number of object and material
    types increases, this becomes the only sane way to proceed. This is a drawback
    of our simplified `Material` system, which expects a different class per material
    type.
  prefs: []
  type: TYPE_NORMAL
- en: The Light component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A light source in our scene is a type of `Component` with a color and a float
    array that is used to represent the calculated location in eye space. Let's create
    the `Light` class now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new `Light` Java class in the `renderbox/components` folder. Define
    it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Our default light is white (color 1,1,1).
  prefs: []
  type: TYPE_NORMAL
- en: The `onDraw` method calculates the actual light position in eye space based
    on the position of `Transform` multiplied by the current view matrix.
  prefs: []
  type: TYPE_NORMAL
- en: It's possible to extend `RenderBox` to support multiple light sources and other
    fancy rendering, such as shadows and so on. However, we will limit the scene to
    a single light source. Thus, we'll keep it as an instance variable in `RenderBox`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can add a default light to the scene in `RenderBox`, like how we added
    the `Camera` component earlier. In `RenderBox.java`, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Modify `onSurfaceCreated` to initialize the light and add it to the scene:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, compute its position in the `Camera` class''s `onDrawEye` (it might change
    for every frame). Edit the `Camera` class in `Camera.java`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Then, we'll also be able to reference the `mainLight` object in our `Material`
    class's `draw` method. We could have declared the color and position as static
    variables, since we are only using one light, but it makes more sense to plan
    for supporting multiple lights in the future.
  prefs: []
  type: TYPE_NORMAL
- en: Vertex color lighting material and shaders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This next topic gets a bit complicated. We're going to write new vertex and
    fragment shaders that handle lighting and write a corresponding class extending
    `Material` that makes use of them. Don't worry though, we've already done this
    once before. We're just going to actually explain it this time.
  prefs: []
  type: TYPE_NORMAL
- en: Let's dive right into it. Locate the `res/raw/` folder. Then, for each file,
    right-click on it, and go to **New** | **File** to create new files.
  prefs: []
  type: TYPE_NORMAL
- en: 'File: `res/raw/vertex_color_lighting_vertex.shader`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The vertex shader maps a 3D vertex to 2D screen space using a model-view transformation
    matrix. Then, it finds the light distance and direction to calculate the light
    color and intensity at that point. These values are passed through the graphics
    pipeline. The fragment shader then determines the pixel colors in the raster segment.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we''ll create the `Material`. In the `renderbox/materials/` folder, create
    a `VertexColorLightingMaterial` class. Define it so it extends `Material`, and
    then declare its buffers and methods for `setupProgram` and `draw`. Here''s the
    code in all its gory glory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: There's a lot going on here, but you can follow along if you read through it
    carefully. Mostly, the material code sets up the parameters that we wrote in the
    shader program.
  prefs: []
  type: TYPE_NORMAL
- en: It is especially important that in the `draw()` method, we obtain the current
    position transformation matrix, `RenderBox.instance.mainLight.lightPosInEyeSpace`
    of `mainLight` and the light color, and pass them along to the shader program.
  prefs: []
  type: TYPE_NORMAL
- en: Now is a good time to bring up the calls to `GLES20.glEnableVertexAttribArray`,
    which is required for each vertex attribute you are using. Vertex attributes are
    any data which are specified for each vertex, so in this case, we have positions,
    normals, and colors. Unlike before, we're now using normal and colors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having introduced a new `Material`, let''s follow our pattern of adding it
    to `RenderBox.reset()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, in the `setup()` method of `MainActivity`, make sure that you pass
    the lighting parameter to the `Cube` constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Run your app. TAADAA!! There, we have it. The difference from the nonlit material
    view may be subtle, but it's more real, virtually.
  prefs: []
  type: TYPE_NORMAL
- en: '![Vertex color lighting material and shaders](img/B05144_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you'd like to adjust the shading, you might need to play with the attenuation
    value used to calculate the diffuse lighting (for example, change `COEFF = 0.00001`
    to `0.001`) in `vertex_color_lighting_vertex.shader`, depending on the scale of
    your scene. For those still in the dark (pun intended), attenuation is a fancy
    word for how light intensity diminishes over distance, and actually refers to
    the same property of any physical signal (for example, light, radio, sound, and
    so on). If you have a very large scene, you might want a smaller value (so light
    reaches distant regions) or the inverse (so not everything is in light). You might
    also want to make the attenuation a uniform float parameter, which can be adjusted
    and set on a per-material or per-light basis, in order to achieve just the right
    lighting conditions.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we've been using a single point light to light our scene. A **point
    light** is a light source with a position in 3D space, which casts light equally
    in all directions. Just like a standard light bulb placed at a specific location
    in a room, all that matters is the distance between it and the object, and the
    angle at which the ray strikes the surface. Rotation doesn't matter for point
    lights, unless a cookie is used to apply a texture to the light. We do not implement
    light cookies in the book, but they're super cool.
  prefs: []
  type: TYPE_NORMAL
- en: Other light sources can be directional lights, which will imitate sunlight on
    earth, where all of the light rays are going essentially in the same direction.
    Directional lights have a rotation that affects the direction of the light rays,
    but they do not have a position, as we assume that the theoretical source is infinitely
    far away along that direction vector. The third type of light source, from a graphics
    perspective, is a spotlight, where the light takes a cone shape and casts a circle
    or ellipse on the surface that it hits. The spotlight will end up working in a
    similar way to the perspective transformation that we do to our MVP matrix. We
    will only be using a single point light for the examples in this book. Implementation
    of other light source types is left as an exercise for the reader.
  prefs: []
  type: TYPE_NORMAL
- en: Time for animation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's time to throw in a little more excitement. Let's animate the cube so that
    it rotates. This'll help demonstrate the shading as well.
  prefs: []
  type: TYPE_NORMAL
- en: For this, we need a `Time` class. This is a singleton utility class that ticks
    off frames and makes that information available to the application, for example,
    via `getDeltaTime`. Note that this is a `final` class, which explicitly means
    that it cannot be extended. There is no such thing as a static class in Java,
    but if we make the constructor private, we can ensure that nothing will ever instantiate
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new `Time` class in the `renderbox/` folder. It won''t be getting
    extended, so we can declare it `final`. Here''s the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Start the timer in the `RenderBox` setup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in the `onNewFrame` method of `RenderBox`, call `Time.update()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can use it to modify the cube''s transform each frame, via the `preDraw()`
    interface hook. In `MainActivity`, make the cube rotate 5 degrees per second about
    the *X* axis, 10 degrees on the *Y* axis, and 7.5 degrees on the *Z* axis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The `getDeltaTime()` method returns the fraction of a second since the previous
    frame. So, if we want it to rotate 5 degrees around the *X* axis each second,
    we multiply `deltaTime` by 5 to get the fraction of a degree to turn this particular
    frame.
  prefs: []
  type: TYPE_NORMAL
- en: Run the app. Rock and roll!!!
  prefs: []
  type: TYPE_NORMAL
- en: Detect looking at objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Wait, there's more! Just one more thing to add. Building interactive applications
    require us to be able to determine whether the user is gazing at a specific object.
    We can put this into `RenderObject`, so any objects in the scene can be gaze detected.
  prefs: []
  type: TYPE_NORMAL
- en: The technique that we'll implement is straightforward. Considering each object
    we render is projected onto a camera plane, we really only need to determine whether
    the user is looking at the object's plane. Basically, we check whether the vector
    between the camera and the plane position is the same as the camera's view direction.
    But we'll throw in some tolerance, so you don't have to look exactly at the center
    of the plane (that'd be impractical). We will check a narrow range. A good way
    to do this is to calculate the angle between the vectors. We calculate the pitch
    and yaw angles between these vectors (the up/down *X* axis angle and left/right
    *Y* axis angle, respectively). Then, we check whether these angles are within
    a narrow threshold range, indicating that the user is looking at the plane (more
    or less).
  prefs: []
  type: TYPE_NORMAL
- en: This method is just like the one used in [Chapter 3](ch03.html "Chapter 3. Cardboard
    Box"), *Cardboard Box,* although at that time, we put it in `MainActivity`. Now,
    we'll move it into the `RenderObject` component.
  prefs: []
  type: TYPE_NORMAL
- en: Note that this can get inefficient. This technique is fine for our projects
    because there is a limited number of objects, so the calculation isn't expensive.
    But if we had a large complex scene with many objects, this setup would fall short.
    In that case, one solution is to add an `isSelectable` flag so that only those
    objects that should be interactive in a given frame will be interactive.
  prefs: []
  type: TYPE_NORMAL
- en: If we were using a fully-featured game engine, we would have a physics engine
    capable of doing a `raycast` to precisely determine whether the center of your
    gaze intersects the object with a high degree of accuracy. While this might be
    great in the context of a game, it is overkill for our purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top of `RenderObject`, add a Boolean variable for an `isLooking` value.
    Also, add two variables to hold the yaw and pitch range limits to detect the camera
    viewing angle, and a `modelView` matrix that we''ll use for calculations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The implementation of the `isLookingAtObject` method is as follows. We convert
    the object space to the camera space, using the `headView` value from `onNewFrame`,
    calculate the pitch and yaw angles, and then check whether they''re within the
    range of tolerance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'For convenience, we''ll set the `isLooking` flag at the same time the object
    is drawn. Add the call at the end of the `draw` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: That should do it.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a simple test, we''ll log some text to the console when the user is gazing
    at the cube. In `MainActivity`, make a separate variable for the `Cube` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, test it in `postDraw`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Exporting the RenderBox package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we've finished creating this beautiful `RenderBox` library, how do
    we reuse it in other projects? This is where **modules** and `.aar` files come
    into play. There are a number of ways to share code between Android projects.
    The most obvious way is to literally copy pieces of code into the next project
    as you see fit. While this is perfectly acceptable in certain situations, and
    in fact should be part of your normal process, it can become quite tedious. What
    if we have a bunch of files that reference each other and depend on a certain
    file hierarchy, such as `RenderBox`? If you're familiar with Java development,
    you might say, "Well, obviously just export the compiled classes in a `.jar` file."
    You would be right, except that this is Android. We have some generated classes
    as well as the `/res` folder, which contains, in this case, our shader code. What
    we actually want is an `.aar` file. Android programmers might be familiar with
    `.aidl` files, which are used for similar purposes, but specifically to establish
    interfaces between apps, and not encapsulate feature code.
  prefs: []
  type: TYPE_NORMAL
- en: To generate an `.aar` file, we first need to put our code inside an Android
    Studio module with a different output than an app. You have a few options from
    this point onward. We recommend that you create a dedicated Android Studio project,
    which contains the `RenderBox` module as well a test app, which will build alongside
    the library and serve as a means to ensure that any changes you make to the library
    don't break anything. You can also just copy the `renderbox` package and the `/res/raw`
    folders into a new project and go from there, but eventually, you'll see that
    a module is much more convenient.
  prefs: []
  type: TYPE_NORMAL
- en: You might think "We're gonna call this new project `RenderBox`," but you might
    run into a snag. Basically, the build system can't handle a situation where a
    project and module have the same name (they would be expected to have the same
    package name, which is a no-no). If you call your project `RenderBox`, (technically,
    you shouldn't have if you followed the instructions) and include an activity,
    and then create a module called `RenderBox`, you will see a build error that complains
    about the project and module sharing a name. If you create an empty project with
    no activity called `RenderBox` and add a module called `RenderBox`, you happen
    to get away with it, but as soon as you try to build an app from this project,
    you'll find that you cannot. Hence, we suggest that your next step from here is
    to create a new project called `RenderBoxLib`.
  prefs: []
  type: TYPE_NORMAL
- en: Building the RenderBoxLib module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's give it a shot. Go to **File** | **New** | **New Project**. Name the project
    `RenderBoxLib`.
  prefs: []
  type: TYPE_NORMAL
- en: We don't need a `MainActivity` class, but we're still going to want one, as
    discussed, as a test case to ensure that our library works. Adding a test app
    to the library project not only gives us the convenience of testing changes to
    the library in a single step, but also ensures that we cannot build a new version
    of the library without ensuring that an app that uses it can also compile it.
    Even if your library is free of syntax errors, it might still break compilation
    when you include it in a new project.
  prefs: []
  type: TYPE_NORMAL
- en: So, go ahead and add an **Empty Activity**, and click on **Finish** in the default
    options.
  prefs: []
  type: TYPE_NORMAL
- en: 'All familiar territory so far. However, now we''re going to create a new module:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to **File** | **New** | **New Module** and select **Android Library**:![Building
    the RenderBoxLib module](img/B05144_05_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name it `RenderBox`.![Building the RenderBoxLib module](img/B05144_05_07.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we have a new folder in our project view:![Building the RenderBoxLib module](img/B05144_05_08.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Instead of performing the next steps in Android Studio, let's just use our file
    manager (Windows Explorer or Finder, or the terminal if you're a pro) to copy
    our `RenderBox` files from the existing project into the new one. If you're using
    version control, you might consider transferring your repository to the new project,
    or creating an init commit before the copy; it's up to you and how much you care
    about preserving your history.
  prefs: []
  type: TYPE_NORMAL
- en: We want to copy all your `RenderBox` code to the new module from the `RenderBoxDemo`
    project's `/app/src/main/java/com/cardbookvr/renderbox` folder to the `/renderbox/src/main/java/com/cardbookvr/renderbox`
    folder of `RenderBoxLib`.
  prefs: []
  type: TYPE_NORMAL
- en: The same goes for the resources; copy them from the `RenderBoxDemo` project's
    `/app/src/main/res/raw` folder to `/renderbox/src/main/res/raw`.
  prefs: []
  type: TYPE_NORMAL
- en: This means that almost every `.java` and `.shader` file that we created in the
    original project goes into the module of the new project, in their corresponding
    locations.
  prefs: []
  type: TYPE_NORMAL
- en: We won't be transferring `MainActivity.java`, or any of the XML files, such
    as `layouts/activity_main.xml` or `AndroidManifest.xml` to the module. These are
    app-specific files, which are not included in the library.
  prefs: []
  type: TYPE_NORMAL
- en: Once you've copied the files, go back to Android Studio, and click on the **Synchronize**
    button. This will ensure that Android Studio has noticed the new files.
  prefs: []
  type: TYPE_NORMAL
- en: '![Building the RenderBoxLib module](img/B05144_05_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Then, with `renderbox` selected in the hierarchy panel, initiate a build by
    navigating to **Build** | **Make Module 'RenderBox'** (or *Ctrl* + *Shift* + *F9*).
    You will see a bunch of errors. Let's take care of them.
  prefs: []
  type: TYPE_NORMAL
- en: '`RenderBox` references the Cardboard SDK, and as such, we must include it in
    the `RenderBox` module as a dependency in a similar way to how we do it for the
    main app, like at the beginning of this project:'
  prefs: []
  type: TYPE_NORMAL
- en: Add the Cardboard SDK `common.aar` and `core.aar` library files to your project
    as new modules, using **File** | **New** | **New Module...** and **Import .JAR/.AAR
    Package**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the library modules as dependencies to the `RenderBox` model, using **File**
    | **Project Structure**. In the left-side panel, select `RenderBox`, then choose
    the **Dependencies** tab | **+** | **Module Dependency**, and add common and core
    modules.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you sync the project and trigger a build, you will hopefully see those
    errors related to `CardboardView` and so on disappear.
  prefs: []
  type: TYPE_NORMAL
- en: Another build. Still, other errors?
  prefs: []
  type: TYPE_NORMAL
- en: This is because of the naming issues mentioned earlier. If the package name
    of your module doesn't match the package name from the original project (that
    is, `com.cardbookvr.renderbox`), you will have to rename it in the copied Java
    files. Even if these match, we named our original project `RenderBoxDemo`, which
    means that the generated R class will be part of the `com.cardbookvr.renderboxdemo`
    package. Any import references to this package will need to be changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by deleting the line that references `com.cardbookvr.renderboxdemo` (such
    as the `Material` Java files). Then, any references to the R class will show up
    as errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building the RenderBoxLib module](img/B05144_05_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Delete this line, and Android Studio will generate a new valid import line.
    Try and build it again. If it's error-free, we're good to go.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will now see references to R show up as errors with a suggestion:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building the RenderBoxLib module](img/B05144_05_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you go ahead and press *Alt* + *Enter*, Android Studio will add the appropriate
    import line to your code. If you don't see the *Alt* + *Enter* tooltip, try placing
    your cursor next to R. Using the feature this way, you'll have to select **Import
    Class** from the menu you see after pressing *Alt* + *Enter*. If you still see
    errors, make sure that you've copied the shader code into the `/renderbox/res/raw`
    folder, and that there aren't other errors interfering with this process. Essentially,
    we are removing any external references from the code and getting `RenderBox`
    to build on its own. We can also accomplish this code fix by simply pasting `import
    com.cardbook.renderbox.R;` over `import com.cardbook.renderboxdemo.R;`. That's
    probably easier than the first method, but then you wouldn't have learned about
    *Alt* + *Enter*.
  prefs: []
  type: TYPE_NORMAL
- en: Once this is done, we should be able to build without errors. This might seem
    like a messy way to work, but it doesn't hurt to get messy once in a while. You
    might even learn something new about the build pipeline you didn't know earlier.
  prefs: []
  type: TYPE_NORMAL
- en: If everything goes well, you will see a file called `renderbox-debug.aar` in
    `renderbox/build/outputs/aar/`. If so, you're done. Whew!
  prefs: []
  type: TYPE_NORMAL
- en: 'One final thought: you should include `renderbox-release.aar` in your final
    applications, but you will lose useful debugging features in the meantime. We
    will not discuss how to switch back and forth between debug and release in this
    book, but understanding build configurations is essential to the publication process.'
  prefs: []
  type: TYPE_NORMAL
- en: The RenderBox test app
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This new project houses the `renderbox` module, but there's also an `app` folder
    that we created in the first place. `app` is where we can implement a test application
    to make sure, at a minimum, that the library is built and basically runs.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re going to do the same thing to the app module in `RenderBoxLib` that
    we did in our new projects (like `renderbox`, `app` is a module. It turns out
    that we''ve been using modules the whole time!):'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on the `app` folder, go to **Open Module Settings**, and add the
    existing `renderbox` module as a **Module dependency** with **Compile Scope**.
    Notice that the dependencies cannot be circular. Now that `renderbox` is a dependency
    of the app, the reverse cannot be true.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update `/res/layout/activity_main.xml` and `AndroidManifest.xml`, as we saw
    at the top of this chapter. (If you're just copying code, make sure that you change
    the `package=` value to the current name, for example, `com.cardbookvr.renderboxlib`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set up `class MainActivity extends CardboardActivity implements IRenderBox`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We now also want our `MainActivity` class to instantiate `RenderBox` and define
    a `setup()` method, just like `MainActivity` in `RenderBoxDemo`. In fact, just
    go ahead and copy the entire `MainActivity` class from `RenderBoxDemo`, and make
    that you do not copy/overwrite the package definition at the top of the new file
    in your new project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With any luck, you should be able to click on the green run button, select your
    target device, and see a running app with our buddy, the vertex color cube. We've
    officially gone backward in terms of the final result, but our application-specific
    code is so clean and simple!
  prefs: []
  type: TYPE_NORMAL
- en: Using RenderBox in future projects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we''ve gone through all of this trouble, let''s do a trial run to
    see how to use our pretty little package all tied up with a bow. One more time.
    You can perform the following steps to start each of the subsequent projects in
    this book:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new project, called whatever you like, such as `MyCardboardApp`, for
    API 19 KitKat. Include **Empty Activity**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, go to **File** | **New** | **New Module…**. It's a little counterintuitive,
    but even though we are importing an existing module, we're adding a new one to
    this project. Choose **Import .JAR/.AAR Package**.![Using RenderBox in future
    projects](img/B05144_05_14.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You''ll need to navigate to the `RenderBoxLib/renderbox/build/outputs` folder
    of your `RenderBox` lib project, and select the `.aar` file. We recommend that
    you rename the module to `renderbox`, as opposed to `renderbox-debug`. Click on
    **Finish**. For a production app, you would want to have two different modules
    in your project: one for debug and one for release, but we will only be using
    debug for the projects in this book.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we have this new module, we need to add it as a dependency to the default
    app. Go back to the familiar **Module Settings** screen, and head over to the
    **Dependencies** tab for `app`. Click on the plus tab on the right-hand side,
    and choose **Module dependency**:![Using RenderBox in future projects](img/B05144_05_15.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, you can add `renderbox`:![Using RenderBox in future projects](img/B05144_05_16.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We now have a copy of the `.aar` file in our new project's `/renderbox` module
    folder. When you've made changes to the `RenderBox` library, you just need to
    build a new `.aar` file (build menu, `MakeProject`), overwrite the copy in the
    new project, and trigger a project sync, or clean and rebuild if you want to be
    sure. The new project does not maintain a link to the build folder of your library
    output project.
  prefs: []
  type: TYPE_NORMAL
- en: 'The remaining steps required to setup a new project are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Use **File** | **New Module** to import the Cardboard SDK `.aar` packages `common`
    and `core`, and add them as dependencies to the app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update `/res/layout/activity_main.xml` and `AndroidManifest.xml`, as we've just
    done for `RenderBoxDemo`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set up the `MainActivity` class so that it extends `CardboardActivity` and implements
    `IRenderBox`, using the same code as before.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We now also want our `MainActivity` class to instantiate `RenderBox` and define
    a `setup()` method, just like our `MainActivity` class in `RenderBoxDemo`. In
    fact, just go ahead and copy the entire `MainActivity` class, and be careful not
    to copy/overwrite the package definition at the top of the file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build and run it yet again. Bagged it! We can now proceed with the cool stuff.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This will be our new project process from now on, since the rest of the projects
    in this book make use of the `RenderBox` library module.
  prefs: []
  type: TYPE_NORMAL
- en: 'A final word on the module process: there''s more than one way to peel an orange.
    You could have just created a new module in the `RenderBox` demo project, grabbed
    its output, and been off and running. You can also just copy source files around
    and try using Git submodules or subtrees to synchronize the sources. This page
    from the IntelliJ docs discusses some of the finer points as well ([https://www.jetbrains.com/idea/help/sharing-android-source-code-and-resources-using-library-projects.html](https://www.jetbrains.com/idea/help/sharing-android-source-code-and-resources-using-library-projects.html)).
    We''ve also made certain decisions in terms of keeping the main activity and layout
    files completely application-specific, and including most or all of our shaders
    and materials in the `RenderBox` module, instead of in application code. At any
    one of these decision points, there are pros and cons, and we recommend that you
    think carefully about how you structure your own code in future projects.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we created a short and sweet, lightweight graphics engine to
    build new Cardboard VR applications. We abstracted the low-level OpenGL ES API
    calls into a suite of `Material` classes and a `Camera` class. We defined `RenderObject`
    for geometric entities, a `Camera` and `Light` components which inherit from a
    `Component` class. We defined a `Transform` class to organize and orient entities
    (which contain components) hierarchically in 3D space. All of this is integrated
    under the `RenderBox` class, which is instantiated and controlled in the `MainActivity`
    class, which, in turn, implements the `IRenderBox` interface. We complete the
    circle by specifying the `MainActivity` class as the implementer of `IRenderBox`
    and implementing `setup`, `preDraw`, and `postDraw`.
  prefs: []
  type: TYPE_NORMAL
- en: To develop the library, we followed much of what was covered in [Chapter 3](ch03.html
    "Chapter 3. Cardboard Box"), *Cardboard Box*, with less explanation of how to
    use OpenGL ES and matrix libraries and more focus on implementing our `RenderBox`
    software architecture.
  prefs: []
  type: TYPE_NORMAL
- en: The resulting `RenderBox` engine library is now in its own project. In subsequent
    chapters we will reuse this library, and we will expand it, including new Components
    and Materials. You are encouraged to maintain your `RenderBoxLib` code in a source
    code repository, such as Git. Of course, the final code is provided with the book
    assets and in our GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter is a science project! We're going to build a model of our Solar
    System, replete with the Sun, planets, moons, and a starscape. Using `RenderBox`,
    we will add a `Sphere` component, and we will also add textured shaders to our
    suite of materials.
  prefs: []
  type: TYPE_NORMAL
