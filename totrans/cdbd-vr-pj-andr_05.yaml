- en: Chapter 5. RenderBox Engine
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。RenderBox引擎
- en: While the Cardboard Java SDK and OpenGL ES are powerful and robust libraries
    for mobile VR applications, they're pretty low level. Software development best
    practices expect that we abstract common programming patterns into new classes
    and data structures. In [Chapter 3](ch03.html "Chapter 3. Cardboard Box"), *Cardboard
    Box*, we got some hands-on experience with the nitty gritty details. This time,
    we're revisiting those details while abstracting them into a reusable library
    that we'll call **RenderBox**. There'll be vector math, materials, lighting, and
    more, all rolled up into a neat little package.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Cardboard Java SDK和OpenGL ES是移动VR应用程序强大而稳健的库，但它们的层次相对较低。软件开发最佳实践期望我们将常见的编程模式抽象成新的类和数据结构。在[第3章](ch03.html
    "第3章。Cardboard Box")中，*Cardboard Box*，我们对细节有了一些实际经验。这一次，我们将重温这些细节，同时将它们抽象成一个可重用的库，我们将称之为**RenderBox**。这将涉及向量数学、材料、光照等，全部打包成一个整洁的包。
- en: 'In this chapter, you will learn to:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习：
- en: Create a new Cardboard project
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个新的Cardboard项目
- en: Write a `Material` class with shaders
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个带有着色器的`Material`类
- en: Explore our `Math` package
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索我们的`Math`包
- en: Write a `Transform` class
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个`Transform`类
- en: Write a `Component` class with `RenderObject Cube`, `Camera`, and `Light` components
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个带有`RenderObject Cube`、`Camera`和`Light`组件的`Component`类
- en: Add a `Material` class for rendering cubes with vertex colors and lighting
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个用于渲染带有顶点颜色和光照的`Material`类
- en: Write a `Time` animation class
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个`Time`动画类
- en: Export all this into a `RenderBox` library for reuse
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将所有这些导出到一个可重用的`RenderBox`库中
- en: The source code for this project can be found on the Packt Publishing website,
    and on GitHub at [https://github.com/cardbookvr/renderboxdemo](https://github.com/cardbookvr/renderboxdemo)
    (with each topic as a separate commit). The final `RenderBoxLib` project, which
    will continue to be maintained and reused in other projects in this book, can
    also be found on the Packt Publishing website and on GitHub at [https://github.com/cardbookvr/renderboxlib](https://github.com/cardbookvr/renderboxlib).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目的源代码可以在Packt Publishing网站上找到，并且在GitHub上也可以找到[https://github.com/cardbookvr/renderboxdemo](https://github.com/cardbookvr/renderboxdemo)（每个主题作为单独的提交）。最终的`RenderBoxLib`项目将继续在本书的其他项目中进行维护和重用，也可以在Packt
    Publishing网站和GitHub上找到[https://github.com/cardbookvr/renderboxlib](https://github.com/cardbookvr/renderboxlib)。
- en: Introducing RenderBox – a graphics engine
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍RenderBox - 一个图形引擎
- en: In a virtual reality app, you are creating a three-dimensional space with a
    bunch of objects. The user's viewpoint, or camera, is also located in this space.
    With the help of the Cardboard SDK, the scene is rendered twice, once for the
    left and right eye, to create the side-by-side stereoscopic views. The second
    and equally important feature translates the sensor data into a head look direction,
    tracking the real-life user's head. The pixels are drawn on the screen, or rendered,
    using the OpenGL ES library, which talks to the hardware **graphics processor**
    (**GPU**) on your device.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚拟现实应用程序中，您正在创建一个三维空间，其中包含一堆对象。用户的视点，或者说摄像头，也位于这个空间中。借助Cardboard SDK的帮助，场景被渲染两次，一次为左眼和右眼，以创建并排的立体视图。第二个同样重要的功能是将传感器数据转换为头部朝向，跟踪现实生活中用户的头部。像素是使用OpenGL
    ES库在屏幕上绘制或渲染的，该库与设备上的硬件**图形处理器**（**GPU**）通信。
- en: We're going to organize the graphics rendering code into separate Java classes,
    which we'll be able to extract into a reusable graphics engine library. We'll
    call this library **RenderBox**.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把图形渲染代码组织成单独的Java类，然后将其提取到一个可重用的图形引擎库中。我们将称这个库为**RenderBox**。
- en: As you'll see, the `RenderBox` class implements the `CardboardView.StereoRender`
    interface. But it's more than that. Virtual reality needs 3D graphics rendering,
    and to do all this in low-level OpenGL ES calls (and other supporting APIs) can
    be tedious, to say the least, especially as your application grows. Furthermore,
    these APIs require you to think like a semiconductor chip! Buffers, shaders, and
    matrix math, oh my! I mean seriously, who wants to think like that all the time?
    I'd rather think like a 3D artist and VR developer.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您将看到的，`RenderBox`类实现了`CardboardView.StereoRender`接口。但它不仅仅是这样。虚拟现实需要3D图形渲染，而在低级别的OpenGL
    ES调用（和其他支持的API）中进行所有这些工作可能会很繁琐，至少可以这么说，特别是当您的应用程序不断增长时。此外，这些API要求您像半导体芯片一样思考！缓冲区、着色器和矩阵数学，哦！我是说，谁想一直这样思考？我宁愿像一个3D艺术家和VR开发人员一样思考。
- en: There are many distinct pieces to track and manage, and they can get complicated.
    As software developers, it's our role to identify common patterns and implement
    layers of abstraction, which serve to reduce this complexity, avoid duplicated
    code, and express the program as objects (software classes) closer to the problem
    domain. In our case, this domain makes 3D scenes that can be rendered on Cardboard
    VR devices.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多不同的部分需要跟踪和管理，它们可能会变得复杂。作为软件开发人员，我们的角色是识别常见模式并实现抽象层，以减少这种复杂性，避免重复的代码，并将程序表达为更接近问题域的对象（软件类）。在我们的情况下，这个领域制作可以在Cardboard
    VR设备上渲染的3D场景。
- en: '`RenderBox` starts to abstract away details into a nice clean layer of code.
    It is designed to take care of OpenGL calls and complex arithmetic, while still
    letting us set up our app-specific code the way we want. It also creates a common
    pattern known as the **entity component pattern** ([https://en.wikipedia.org/wiki/Entity_component_system](https://en.wikipedia.org/wiki/Entity_component_system))
    for new materials and component types if our projects demand any special cases.
    Here''s an illustration of the major classes in our library:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`RenderBox`开始将细节抽象成一个干净的代码层。它旨在处理OpenGL调用和复杂的算术，同时仍然让我们以我们想要的方式设置我们的特定于应用程序的代码。如果我们的项目需要任何特殊情况，它还会创建一个称为**实体组件模式**（[https://en.wikipedia.org/wiki/Entity_component_system](https://en.wikipedia.org/wiki/Entity_component_system)）的常见模式，用于新材料和组件类型。这是我们库中主要类的一个示例：'
- en: '![Introducing RenderBox – a graphics engine](img/B05144_05_01.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![介绍RenderBox - 一个图形引擎](img/B05144_05_01.jpg)'
- en: The `RenderBox` class implements `CardboardView.StereoRenderer`, relieving that
    responsibility from the app's `MainActivity` class. As we'll see, `MainActivity`
    communicates with `RenderBox` through the `IRenderBox` interface (with the setup,
    `preDraw`, and `postDraw` hooks) so that `MainActivity` implements `IRenderBox`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`RenderBox`类实现了`CardboardView.StereoRenderer`，从而将这个责任从应用的`MainActivity`类中解放出来。正如我们将看到的，`MainActivity`通过`IRenderBox`接口（具有设置、preDraw和postDraw钩子）与`RenderBox`进行通信，以便`MainActivity`实现`IRenderBox`。'
- en: 'Let''s consider the kinds of `Component` that can participate in a 3D VR scene:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑可以参与3D VR场景的`Component`类型：
- en: '`RenderObject`: These are drawable models in the scene, such as cubes and spheres'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RenderObject`：这些是场景中的可绘制模型，例如立方体和球体。'
- en: '`Camera`: This is the viewpoint of the user, which is used to render the scene'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Camera`：这是用户的视点，用于渲染场景'
- en: '`Light`: These are sources of illumination used for shading and shadows'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Light`：这些是用于阴影和阴影的照明源'
- en: Every object in our scene has an X, Y, and Z location in space, a rotation,
    and three scale dimensions. These properties are defined by the `Transform` class.
    Transforms can be arranged in a hierarchy, letting you build more complex objects
    that are assembled from simpler ones.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们场景中的每个对象都在空间中具有X、Y和Z位置、旋转和三个比例尺。这些属性由`Transform`类定义。变换可以按层次结构排列，让您构建更复杂的对象，这些对象由更简单的对象组装而成。
- en: Each `Transform` class can be associated with one or more `Component` classes.
    Different kinds of components (for example, `Camera`, `Light`, and `RenderObject`)
    extend the `Component` class. A component should not exist without being attached
    to a `Transform` class but the reverse (a transform with no components) is perfectly
    fine.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`Transform`类可以与一个或多个`Component`类关联。不同类型的组件（例如`Camera`、`Light`和`RenderObject`）扩展了`Component`类。组件不应该存在于没有附加到`Transform`类的情况下，但反之（没有组件的变换）是完全可以的。
- en: Internally, `RenderBox` maintains a list of `RenderObjects`. These are the geometric
    models in the scene. Types of `RenderObjects` include `Cube` and `Sphere`, for
    example. These objects are associated with a `Material`, which defines their color,
    texture, and/or shading properties. Materials, in turn, reference, compile, and
    execute low-level shader programs. Maintaining a flat list of components to render
    each frame is more efficient than traversing the transform hierarchy every frame.
    It is a perfect example of why we use the entity component pattern.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，`RenderBox`维护着一个`RenderObjects`列表。这些是场景中的几何模型。`RenderObjects`的类型包括`Cube`和`Sphere`等。这些对象与`Material`相关联，定义了它们的颜色、纹理和/或阴影属性。材料又引用、编译和执行低级着色器程序。每帧维护一个扁平的组件列表比每帧遍历变换层次结构更有效。这是我们使用实体组件模式的一个完美例子。
- en: Other things in the `RenderBox` package include a `Time` class used to implement
    animations, and a library of `Math` functions used for vector and matrix operations.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`RenderBox`包中的其他内容包括用于实现动画的`Time`类，以及用于向量和矩阵操作的`Math`函数库。'
- en: Now, let's start putting this together.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始把这些放在一起。
- en: What's the game plan? The end goal is to create our `RenderBox` graphics engine
    library. It will be handy to maintain it in its own project (and repository if
    you're using source control, such as Git), so it can be improved and maintained
    independently. However, to kick this off, we need a simple app to build it, show
    you how to use it, and verify (if not test) that it is working properly. This
    will be called `RenderBoxDemo`. At the end of the chapter, we will extract the
    `RenderBox` code into an Android library module and then export it.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏计划是什么？最终目标是创建我们的`RenderBox`图形引擎库。将其保留在自己的项目中（如果您使用源代码控制，如Git，则还可以保留在自己的存储库中）将非常方便，因此可以独立地进行改进和维护。但是，为了开始这个过程，我们需要一个简单的应用程序来构建它，向您展示如何使用它，并验证（如果不是测试）它是否正常工作。这将被称为`RenderBoxDemo`。在本章结束时，我们将`RenderBox`代码提取到一个Android库模块中，然后导出它。
- en: Creating a new project
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个新项目
- en: 'If you''d like more details and explanation about these steps, refer to the
    *Creating a new Cardboard project* section [Chapter 2](ch02.html "Chapter 2. The
    Skeleton Cardboard Project"), *The Skeleton Cardboard Project*, and follow along
    there:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解有关这些步骤的更多详细信息和解释，请参考[第2章](ch02.html "第2章。骨架Cardboard项目")中的*创建新的Cardboard项目*部分，*骨架Cardboard项目*，并在那里跟着做：
- en: With Android Studio opened, create a new project. Let's name it `RenderBoxDemo`
    and target **Android 4.4 KitKat (API 19)** with an **Empty Activity**.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Android Studio，创建一个新项目。让我们将其命名为`RenderBoxDemo`，并以**空活动**为目标**Android 4.4 KitKat（API
    19）**。
- en: Add the Cardboard SDK `common.aar` and `core.aar` library files to your project
    as new modules, using **File** | **New** | **New Module...**.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Cardboard SDK的`common.aar`和`core.aar`库文件作为新模块添加到项目中，使用**文件** | **新建** | **新建模块...**。
- en: Set the library modules as dependencies to the project app, using **File** |
    **Project Structure**.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**文件** | **项目结构**将库模块作为项目应用程序的依赖项。
- en: Edit the `AndroidManifest.xml` file as explained in [Chapter 2](ch02.html "Chapter 2. The
    Skeleton Cardboard Project"), *The Skeleton Cardboard Project*, being careful
    to preserve the `package` name for this project.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`AndroidManifest.xml`文件，如[第2章](ch02.html "第2章。骨架Cardboard项目")中所述，*骨架Cardboard项目*，务必保留此项目的`package`名称。
- en: Edit the `build.gradle` file as explained in [Chapter 2](ch02.html "Chapter 2. The
    Skeleton Cardboard Project"), *The Skeleton Cardboard Project*, to compile against
    SDK 22.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`build.gradle`文件，如[第2章](ch02.html "第2章。骨架Cardboard项目")中所述，*骨架Cardboard项目*，以便针对SDK
    22进行编译。
- en: Edit the `activity_main.xml` layout file as explained in [Chapter 2](ch02.html
    "Chapter 2. The Skeleton Cardboard Project"), *The Skeleton Cardboard Project*.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`activity_main.xml`布局文件，如[第2章](ch02.html "第2章。骨架Cardboard项目")中所述，*骨架Cardboard项目*。
- en: 'Now, open the `MainActivity.java` file and edit the `MainActivity` Java class
    to extend `CardboardActivity`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打开`MainActivity.java`文件，并编辑`MainActivity` Java类以扩展`CardboardActivity`：
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that unlike the previous chapters, we do not implement `CardboardView.StereoRender`.
    Instead, we will implement that interface in the `RenderBox` class (in the next
    topic).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: Creating the RenderBox package folder
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since our plan is to export the `RenderBox` code as a library, let's put it
    all into its own package.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: In the Android hierarchy panel, use the `Gear` icon and uncheck **Compact Empty
    Middle Packages** so that we can insert the new package under **com.cardbookvr**.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on the `app/java/com/carbookvr/` folder in the project view, navigate
    to **New** | **Package**, and name it `renderbox`. You may now wish to enable
    **Compact Empty Middle Packages** again.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the `renderbox` folder, create three package subfolders named `components`,
    `materials`, and `math`. The project should now have the same folders as shown
    in the following screenshot:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the RenderBox package folder](img/B05144_05_02.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
- en: Creating an empty RenderBox class
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's begin by creating a skeleton of the `RenderBox` class Java code. Right-click
    on the `renderbox/` folder, navigate to **New** | **Java Class**, and name it
    `RenderBox`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, open the `RenderBox.java` file and edit it to implement the `CardboardView.StereoRenderer`
    interfaces. Add the following code:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: It's primarily housekeeping at this point. The `RenderBox` class is defined
    as `implements` `CardboardView.StereoRenderer`. Its constructor will receive a
    reference to the `MainActivity` instance and the `IRenderBox` implementer (in
    this case, also the `MainActivity`) class. `MainActivity` will now have to implement
    the `IRenderBox` methods (to be defined next). In this way, we instantiate the
    framework and implement the critical methods.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Note that we also make `RenderBox` a singleton by registering the `this` instance
    in the class constructor.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: 'We must also add the method overrides for the `StereoRenderer` class. From
    the intellisense menu, select **Implement Methods…** (or *Ctrl* + *I*) to add
    the stub method overrides for the interface, as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'It is now a good time to add an error reporting method, `checkGLError`, to
    `RenderBox` to log OpenGL rendering errors, as illustrated in the following code:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the previous chapter projects, we defined `MainActivity` so that it implements
    `CardboardView.StereoRenderer`. Now this is delegated to our new `RenderBox` object.
    Let's tell `MainActivity` to use it.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: 'In `MainActivity.java`, modify the `onCreate` method to create a new instance
    of `RenderBox` and set it as the view renderer, as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note that `cardboardView.setRender` is passed new `RenderBox`, which takes the
    `MainActivity` instance as both the `Activity` and `IRenderBox` arguments. Voila,
    we've taken control of the Cardboard SDK integration entirely, and now it's all
    about implementing `IRenderbox`. In this way, we have wrapped the Cardboard SDK,
    OpenGL, and a variety of other external dependencies in our own library. Now,
    if these specifications change, all we have to do is keep `RenderBox` up to date,
    and our app can tell `RenderBox` what to do, the same way as always.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: Adding the IRenderBox interface
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once we've put all this together, the `MainActivity` class will implement the
    `IRenderBox` interface. The interface provides callbacks for the `setup`, `preDraw`,
    and `postDraw` functions that the activity may implement.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: The setup method will be called after doing some generic work in `onSurfaceCreated`.
    The `preDraw` and `postDraw` methods will be called during `onDrawEye`. We'll
    get to see this later in the chapter.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: 'We can set that up now. Right-click on `renderbox` in the hierarchy panel,
    navigate to **New** | **Java Class**, select **Kind: "Interface"**, and name it
    `IRenderBox`. It''s only a few lines and should include just the following code:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Then, modify `MainActivity` so that it implements `IRenderBox`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Select intellisense **Implement Methods** (or *Ctrl* + *I*), to add the interface
    methods overrides. Android Studio will automatically fill in the following:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If you run the empty app now, you will not get any build errors, and it''ll
    display the empty Cardboard split view:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您现在运行空白应用程序，将不会出现任何构建错误，并且它将显示空的Cardboard分屏视图：
- en: '![Adding the IRenderBox interface](img/B05144_05_03.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![添加IRenderBox接口](img/B05144_05_03.jpg)'
- en: Now we have created a skeleton app, ready to implement the `RenderBox` package
    and utilities, which we can use to help build new Cardboard VR applications.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了一个骨架应用程序，准备实现`RenderBox`包和实用程序，这将帮助我们构建新的Cardboard VR应用程序。
- en: In the next few topics, we will build some of the classes needed in `RenderBox`.
    Unfortunately, we can't display anything interesting on your Cardboard device
    until we get these coded up. This also limits our ability to test and verify that
    the coding is correct. This could be an appropriate time to introduce unit testing,
    such as JUnit. Refer to the *Unit testing support* docs for details ([http://tools.android.com/tech-docs/unit-testing-support](http://tools.android.com/tech-docs/unit-testing-support)).
    Unfortunately, space does not allow us to introduce this subject and use it for
    the projects in this book. But we encourage you to pursue this on your own. (And
    I'll remind you that the GitHub repository for this project has separate commits
    for each topic, incrementally adding code as we go along).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几个主题中，我们将构建`RenderBox`中需要的一些类。不幸的是，在我们编写完这些代码之前，我们无法在您的Cardboard设备上显示任何有趣的东西。这也限制了我们测试和验证编码是否正确的能力。这可能是引入单元测试的合适时机，比如JUnit。有关详细信息，请参阅*Unit
    testing support*文档（[http://tools.android.com/tech-docs/unit-testing-support](http://tools.android.com/tech-docs/unit-testing-support)）。不幸的是，空间不允许我们介绍这个主题并在本书的项目中使用它。但我们鼓励您自己去追求这个。
    （我会提醒您，这个项目的GitHub存储库为每个主题都有单独的提交，随着我们的进行逐步添加代码）。
- en: Materials, textures, and shaders
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 材料、纹理和着色器
- en: In [Chapter 3](ch03.html "Chapter 3. Cardboard Box"), *Cardboard Box*, we introduced
    the OpenGL ES 2.0 graphics pipeline and simple shaders. We will now extract that
    code into a separate `Material` class.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](ch03.html "第3章 Cardboard Box")中，我们介绍了OpenGL ES 2.0图形管线和简单的着色器。现在我们将把这些代码提取到一个单独的`Material`类中。
- en: In computer graphics, materials refer to the visual surface characteristics
    of geometric models. When rendering an object in the scene, materials are used
    together with lighting and other scene information required by the shader code
    and the OpenGL graphics pipeline.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机图形学中，材料指的是几何模型的视觉表面特性。在场景中渲染对象时，材料与照明和着色器代码以及OpenGL图形管线所需的其他场景信息一起使用。
- en: A solid colored material is the simplest; the entire surface of the object is
    a single color. Any color variation in the final rendering will be due to lighting,
    shadows, and other features in a different shader variant. It is quite possible
    to produce solid color materials with lighting and shadows, but the simplest possible
    example just fills raster segments with the same color, such as our very first
    shader.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 实色材料是最简单的；物体的整个表面是单一颜色。最终渲染中的任何颜色变化都是由于照明、阴影和其他着色器变体中的特性。完全可以使用照明和阴影来产生实色材料，但最简单的例子只是用相同的颜色填充光栅段，就像我们的第一个着色器一样。
- en: A textured material may have surface details defined in an image file (such
    as a JPG). Textures are like wallpapers pasted on the surface of the object. They
    can be used to a great extent and are responsible for most of the details that
    the user perceives on an object. A solid colored sphere may look like a ping pong
    ball. A textured sphere may look like the Earth. More texture channels can be
    added to define variations in shading or even to emit light when the surface is
    in shadow. You will see this kind of effect at the end of [Chapter 6](ch06.html
    "Chapter 6. Solar System"), *Solar System*, when we add an artificial light to
    the dark side of the Earth.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 纹理材料可能在图像文件（如JPG）中定义表面细节。纹理就像贴在物体表面上的墙纸。它们可以被广泛使用，并负责用户在物体上感知到的大部分细节。一个实色的球体可能看起来像一个乒乓球。一个纹理球可能看起来像地球。可以添加更多的纹理通道来定义阴影的变化，甚至在表面处于阴影时发光。在[第6章](ch06.html
    "第6章 太阳系")结束时，您将看到这种效果，当我们在地球的黑暗一侧添加人造光源时。
- en: More realistic physically-based shading goes beyond texture maps to include
    simulated height maps, metallic shininess, and other imperfections, such as rust
    or dirt. We won't be going into that in this book, but it's common in graphics
    engines such as Unity 3D and the Unreal Engine. Our `RenderBox` library could
    be extended to support it.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 更真实的基于物理的着色超出了纹理贴图，还包括模拟的高度图、金属光泽和其他瑕疵，比如锈迹或污垢。我们不会在本书中涉及到这一点，但在图形引擎如Unity 3D和虚幻引擎中很常见。我们的`RenderBox`库可以扩展以支持它。
- en: Presently, we'll build the infrastructure for a basic solid colored material
    and associated shaders. Later in the chapter, we'll expand it with lighting.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们将为基本的实色材料和相关着色器构建基础设施。在本章的后面，我们将扩展它以支持照明。
- en: Abstract material
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抽象材料
- en: 'In the `renderbox/materials/` folder, create a new Java class named `Material`
    and begin to write it as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在`renderbox/materials/`文件夹中，创建一个名为`Material`的新Java类，并开始编写如下：
- en: '[PRE8]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This defines an abstract class that will be used to extend the various types
    of materials we define. The `createProgram` method loads the designated shader
    scripts and builds an OpenGL ES program with the shaders attached.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这定义了一个抽象类，将用于扩展我们定义的各种类型的材料。`createProgram`方法加载指定的着色器脚本，并构建一个附有着色器的OpenGL ES程序。
- en: We also define an abstract `draw()` method that will be implemented in each
    shader separately. Among other things, it requires the `modelView` and `modelViewProjection`
    transformation matrices be declared at the top of the class. At this point, we
    will actually only use `modelViewProjection`, but a separate reference to the
    `modelView` matrix will be needed when we add lighting.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还定义了一个抽象的`draw()`方法，将在每个着色器中单独实现。除其他事项外，它要求在类的顶部声明`modelView`和`modelViewProjection`变换矩阵。在这一点上，我们实际上只会使用`modelViewProjection`，但当我们添加照明时，将需要一个单独的引用`modelView`矩阵。
- en: 'Next, add the following utility methods to the `Material` class to load the
    shaders:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As discussed in [Chapter 3](ch03.html "Chapter 3. Cardboard Box"), *Cardboard
    Box*, these methods will load a shader script and compile it.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: Later on, we'll derive specific materials from this class, and define specific
    shaders that each one will use.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: The Math package
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 3](ch03.html "Chapter 3. Cardboard Box"), *Cardboard Box*, we introduced
    3D geometry and matrix math calculations. We will wrap these up into even more
    useful functions.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: Much of this math code that we've put together is from existing open source
    projects (attributions are given in comments in the source code). After all, we
    might as well take advantage of the math geniuses who like this stuff and have
    open sourced excellent true and tested code. The code list is included with the
    file downloads for this book.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The following list documents our math API. The actual code is included with
    the file downloads for this book and the GitHub repository.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: Generally speaking, the mathematics falls within the subject of linear algebra,
    but most of it is specific to graphics programming and works within the constraints
    of fast floating point math on modern CPUs.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: We encourage you to browse the source code included with the book, which you
    will obviously need access to in order to complete the project. Suffice it to
    say that everything included is pretty standard fare for a 3D game engine and
    was, in fact, largely sourced from (or checked against) an open source engine
    called **LibGDX**. The math library for LibGDX is pretty vast, optimized for mobile
    CPUs, and could make a great drop-in replacement for our simpler math package.
    We will also use the Android `Matrix` class extensively, which, in most cases,
    runs in native code and avoids the overhead of the **Java Virtual Machine** (**JVM**
    or Dalvik VM in the case of Android).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: Here's a summary of our math API.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: MathUtils
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `MathUtils` variables and methods are mostly self-explanatory: `PI`, `sin`,
    `cos`, and so on, defined to use `floats` as an alternative to Java''s `Math`
    class, which contains doubles. In computer graphics, we speak floats. The math
    takes less power and fewer transistors and the precision loss is acceptable. Your
    `MathUtils` class should look like the following code:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Matrix4
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Matrix4` class manages 4 x 4 transformation matrices and is used to translate
    (position), rotate, and scale points in three-dimensional space. We''ll make good
    use of these soon. Here is an abridged version of the `Matrix4` class with function
    bodies removed:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Make a special note of the TRS function. It is used by the `Transform` class
    to combine the position, rotation, and scale information into a useful matrix,
    which represents all three. The order in which this matrix is created is important.
    First, we generate a translation matrix, and then we rotate and scale it. The
    resulting matrix can be multiplied by any 3D point (our vertices) to apply these
    three operations hierarchically.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Quaternion
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **quaternion** represents a rotational orientation in three-dimensional space
    in such a way that, when two quaternions are combined, no information is lost.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: 'From a human point of view, it''s easier to think of rotational orientation
    as three Euler (pronounced "oiler") angles since we think of three dimensions
    of rotation: pitch, yaw, and roll. The reason we use quaternions as opposed to
    a more straightforward vector representation of rotations is that depending on
    the order in which you apply the three Euler rotations to an object, the resulting
    3D orientation will be different.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For more information on quaternions and Euler angles, refer to the following
    links:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Quaternions_and_spatial_rotation](https://en.wikipedia.org/wiki/Quaternions_and_spatial_rotation)'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Euler_angles](https://en.wikipedia.org/wiki/Euler_angles)'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://mathworld.wolfram.com/EulerAngles.html](http://mathworld.wolfram.com/EulerAngles.html)'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://mathworld.wolfram.com/EulerAngles.html](http://mathworld.wolfram.com/EulerAngles.html)'
- en: '[https://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles](https://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles)'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles](https://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles)'
- en: 'Even though quaternions are a four-dimensional construct, we treat each quaternion
    as a single value, which represents a 3D orientation. Thus, when we apply multiple
    rotation operations in a row, we don''t run into issues where one axis'' rotation
    influences the effect of another. If none of this makes any sense, don''t worry.
    This is one of the trickiest concepts in 3D graphics. Here is the abridged `Quaternion`
    class:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管四元数是一个四维结构，但我们将每个四元数视为一个单一值，它代表一个3D方向。因此，当我们连续应用多个旋转操作时，不会出现一个轴的旋转影响另一个轴的效果的问题。如果这一切都毫无意义，不要担心。这是3D图形中最棘手的概念之一。以下是简化的`Quaternion`类：
- en: '[PRE12]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Vector2
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Vector2
- en: 'A **Vector2** is a two-dimensional point or direction vector defined by (X,Y)
    coordinates. With the `Vector2` class, you can transform and manipulate vectors.
    Here is the abridged `Vector2` class:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**Vector2**是由（X，Y）坐标定义的二维点或方向向量。使用`Vector2`类，您可以转换和操作向量。以下是简化的`Vector2`类：'
- en: '[PRE13]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Vector3
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Vector3
- en: 'A **Vector3** is a three-dimensional point or direction vector defined by X,
    Y, and Z coordinates. With the `Vector3` class, you can transform and manipulate
    vectors. Here is the abridged `Vector3` class:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '**Vector3**是由X、Y和Z坐标定义的三维点或方向向量。使用`Vector3`类，您可以转换和操作向量。以下是简化的`Vector3`类：'
- en: '[PRE14]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`Vector2` and `Vector3` share a lot of the same functionality, but pay special
    attention to the functions that exist in 3D, and that do not exist in 2D. Next,
    we''ll see how the math library gets used when we implement the `Transform` class.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`Vector2`和`Vector3`共享许多相同的功能，但要特别注意3D中存在而2D中不存在的函数。接下来，我们将看到在实现`Transform`类时如何使用数学库。'
- en: The Transform class
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Transform类
- en: A 3D virtual reality scene will be constructed from various objects, each with
    a position, rotation, and scale in 3D dimensional space defined by a `Transform`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 3D虚拟现实场景将由各种对象构建，每个对象在3D空间中由`Transform`定义了位置、旋转和缩放。
- en: It will also be naturally useful to permit transforms to be grouped hierarchically.
    This grouping also creates a distinction between local space and world space,
    where children only keep track of the difference between their **translation,
    rotation, and scale** (**TRS**) and that of their parent (local space). The actual
    data that we are storing is the local position (we'll use the words position and
    translation interchangeably), rotation, and scale. Global position, rotation,
    and scale are computed by combining the local TRS all the way up the chain of
    parents.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 允许对变换进行分层分组也是自然而然的有用的。这种分组还创建了本地空间和世界空间之间的区别，其中子对象只跟踪它们的**平移、旋转和缩放**（**TRS**）与其父对象的差异（本地空间）。我们存储的实际数据是本地位置（我们将使用位置和平移这两个词），旋转和缩放。全局位置、旋转和缩放是通过将本地TRS组合到所有父级链中计算出来的。
- en: First, let's define the `Transform` class. In the Android Studio hierarchy panel,
    right-click on `renderbox/`, go to **New** | **Java Class**, and name it `Transform`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们定义`Transform`类。在Android Studio的层次结构面板中，右键单击`renderbox/`，转到**新建** | **Java类**，并将其命名为`Transform`。
- en: 'Each `Transform` may have one or more associated components. Typically there
    is just one, but it is possible to add as many as you want (as we''ll see in the
    other projects in this book). We''ll maintain a list of components in the transform,
    as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`Transform`可能有一个或多个关联的组件。通常只有一个，但可以添加尽可能多的组件（正如我们将在本书的其他项目中看到的）。我们将在变换中维护组件列表，如下所示：
- en: '[PRE15]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We will define the `Component` class in the next topic. If it really bothers
    you to reference it now before it's defined, you can start with an empty Component
    Java class in the `renderbox/components` folder.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一个主题中定义`Component`类。如果在定义之前现在引用它真的让你困扰，你可以从`renderbox/components`文件夹中的空Component
    Java类开始。
- en: Now back to the `Transform` class. A `Transform` object has a location, orientation,
    and scale in space, defined by its `localPosition`, `localRotation`, and `localScale`
    variables. Let's define these private variables, and then add the methods to manipulate
    them.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在回到`Transform`类。`Transform`对象在空间中有一个位置、方向和缩放，由其`localPosition`、`localRotation`和`localScale`变量定义。让我们定义这些私有变量，然后添加方法来操作它们。
- en: 'Also, as transforms can be arranged in a hierarchy, we''ll include a reference
    to a possible `parent` transform, as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于变换可以按层次结构排列，我们将包括对可能的`parent`变换的引用，如下所示：
- en: '[PRE16]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The position, rotation, and scale values are initialized to identity values,
    that is, no positional offset, rotation, or resizing until they are explicitly
    set elsewhere. Note that the identity scale is (1, 1, 1).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 位置、旋转和缩放值被初始化为身份值，也就是说，直到它们在其他地方被明确设置之前，没有位置偏移、旋转或调整大小。请注意，身份缩放是（1,1,1）。
- en: The `parent` transform variable allows each transform to have a single parent
    in the hierarchy. You can keep the list of children in the transform, but you
    might be surprised to know how far you can get without having to move down the
    hierarchy. If you can avoid it, as we have, you can save a good deal of branching
    when setting/unsetting a parent reference. Maintaining the list of children means
    an *O(n)* operation every time you unparent an object, and an extra *O(1)* insertion
    cost on setting a parent. It is also not very efficient to hunt through children
    looking for a particular object.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`parent`变换变量允许每个变换在层次结构中有一个父级。你可以在变换中保留子对象的列表，但你可能会惊讶地知道，在不必深入层次结构的情况下，你可以走得很远。如果你可以避免，就像我们一样，你可以在设置/取消父引用时节省大量的分支。维护子对象列表意味着每次取消父对象的操作都需要*O(n)*的时间，设置父对象时还需要额外的*O(1)*插入成本。在子对象中寻找特定对象也不是很有效率。'
- en: Parent methods
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 父级方法
- en: 'The transform can be added or removed from its position in the hierarchy with
    the `setParent` and `unParent` methods, respectively. Let''s define them now:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Simply, the `setParent` method sets `this.parent` to the given parent transform.
    Optionally, you can specify that the position is updated relative to the parent.
    We added an optimization to skip this procedure if the parent is already set.
    Setting the parent to `null` is equivalent to calling `unParent`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: The `unParent` method removes the transform from the hierarchy. Optionally,
    you can specify that the position is updated relative to the (previous) parents,
    so that the transform is now disconnected from the hierarchy but remains in the
    same position in world space.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: Note that the rotation and scale can, and should, also be updated when parenting
    and unparenting. We don't need that in the projects in this book, so they have
    been left as an exercise for the reader. Also, note that our `setParent` methods
    include an argument for whether to update the position. If it is `false`, the
    operation runs a little faster, but the global state of the object will change
    if the parent transform was not set to identity (no translation, rotation, or
    scale). For convenience, you may set `updatePosition` to `true`, which will apply
    the current global transformation to the local variables, keeping the object fixed
    in space, with its current rotation and scale.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: Position methods
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `setPosition` methods set the transform position relative to the parent,
    or apply absolute world position to the local variable if there is no parent.
    Two overloads are provided if you want to use a vector or individual component
    values. `getPosition` will compute the world space position based on parent transforms,
    if they exist. Note that this will have a CPU cost related to the depth of the
    transform hierarchy. As an optimization, you may want to include a system to cache
    world space positions within the `Transform` class, invalidating the cache whenever
    a parent transform is modified. A simpler alternative would be to make sure that
    you store the position in a local variable right after calling `getPosition`.
    The same optimization applies for rotation and scale.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: 'Define the position getters and setters as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Rotation methods
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `setRotation` methods set the transform rotation relative to the parent,
    or the absolute world rotation is applied to the local variable if there is no
    parent. Again, multiple overloads provide options for different input data. Define
    the rotation getters and setters as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Scale methods
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `setScale` methods set the transform scale relative to the parent, or apply
    the absolute scale to the local variable if there is no parent. Define getters
    and setters for the scale as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Transform to matrix and draw
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The last thing we need to do with the `Transform` class is transform an identity
    matrix into one that will tell OpenGL how to draw the object correctly. To do
    this, we translate, rotate, and scale the matrix, in that order. Technically,
    we can also do cool things with matrices, such as shearing and skewing models,
    but the math is complicated enough as it is. If you want to learn more, type `transformation
    matrix`, `quaternion to matrix`, and some of the other terms that we have been
    throwing around into a search engine. The actual math behind all of this is fascinating
    and way too detailed to explain in a single paragraph.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: We also provide the `drawMatrix()` function that sets up the lighting and model
    matrices for a draw call. Since the lighting model is an intermediate step, it
    makes sense to combine this call;
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `drawMatrices` method uses variables from the `RenderObject` class, which
    will be defined later. It might seem very anti-Java that we are just setting our
    matrices to static variables in the `RenderObject` class. As you will see, there
    is actually no need for multiple instances of the `lightingModel` object and model
    to exist. They are always calculated just in time for each object as they are
    drawn. If we were to introduce optimizations that avoid recomputing this matrix
    all the time, it would make sense to keep the information around. For the sake
    of simplicity, we just recalculate the matrix every time each object is drawn,
    since it might have changed since the last frame.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`drawMatrices`方法使用了`RenderObject`类的变量，这些变量稍后将被定义。我们只是将我们的矩阵设置为`RenderObject`类中的静态变量，这似乎非常反Java。正如您将看到的，实际上并不需要多个`lightingModel`对象和模型的实例存在。它们总是在每个对象绘制时及时计算出来。如果我们要引入避免一直重新计算这个矩阵的优化，保留这些信息就是有意义的。为了简单起见，我们只是在每次绘制每个对象时重新计算矩阵，因为它可能与上一帧不同。'
- en: Next, we'll see how the `Transform` class gets used when we implement the `Component`
    class, which will be extended by a number of classes that define objects in the
    3D scene.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看到`Transform`类在我们实现`Component`类时是如何被使用的，这个类将被一些定义3D场景中对象的类所扩展。
- en: The Component class
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件类
- en: Our 3D virtual reality scenes consist of various kinds of components. Components
    may include geometric objects, lights, and cameras. Components can be positioned,
    rotated, and scaled in 3D space, according to their associated transform. Let's
    create a `Component` class that will serve as the basis for other object classes
    in the scene.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的3D虚拟现实场景由各种组件组成。组件可能包括几何对象、灯光和摄像机。根据其关联的变换，组件可以在3D空间中定位、旋转和缩放。让我们创建一个`Component`类，它将作为场景中其他对象类的基础。
- en: 'If you haven''t created `Component.java` yet, create one now in the `renderbox/components`
    folder. Define it as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还没有创建`Component.java`，现在在`renderbox/components`文件夹中创建一个。定义如下：
- en: '[PRE22]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We've included an `enabled` flag, which will come in handy to easily hide/show
    objects when we draw our scene.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们包含了一个`enabled`标志，当我们绘制场景时，这将非常方便地隐藏/显示对象。
- en: That's it. Next, we'll define our first component, `RenderObject`, to represent
    geometric objects in the scene.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。接下来，我们将定义我们的第一个组件`RenderObject`，以表示场景中的几何对象。
- en: The RenderObject component
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RenderObject组件
- en: '`RenderObject` will serve as the parent class of geometric objects that can
    be rendered in the scene. `RenderObject` extends `Component`, so it has a `Transform`.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`RenderObject`将作为可以在场景中渲染的几何对象的父类。`RenderObject`扩展了`Component`，因此它有一个`Transform`。'
- en: 'In the `renderbox/components` folder, create a new Java class, `RenderObject`.
    Define it as an abstract class that extends `Component`:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在`renderbox/components`文件夹中，创建一个名为`RenderObject`的新Java类。将其定义为扩展`Component`的抽象类：
- en: '[PRE23]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The first thing we do is have each instance add itself to the list of `renderObjects`
    maintained by the `RenderBox` instance. Let's jump over to the `RenderBox` class
    now and add support for this list.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先要做的是让每个实例将自己添加到由`RenderBox`实例维护的`renderObjects`列表中。现在让我们转到`RenderBox`类，并为这个列表添加支持。
- en: 'Open the `RenderBox.java` file and add a `renderObjects` list:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`RenderBox.java`文件并添加一个`renderObjects`列表：
- en: '[PRE24]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, back to the `RenderObject` class; we''ll implement three methods: `allocateFloatBuffer`,
    `allocateShortBuffer`, and `draw`.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，回到`RenderObject`类；我们将实现三个方法：`allocateFloatBuffer`、`allocateShortBuffer`和`draw`。
- en: 'OpenGL ES requires us to allocate a number of different memory buffers for
    various data, including model vertices, normal vectors, and index lists. The `allocateFloatBuffer`
    and `allocateShortBuffer` methods are utility methods that objects can use for
    floats and integers, respectively. Indexes are integers (specifically, shorts);
    everything else will be floats. These will be available to derived object classes:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL ES要求我们为各种数据分配许多不同的内存缓冲区，包括模型顶点、法向量和索引列表。`allocateFloatBuffer`和`allocateShortBuffer`方法是对象可以用于浮点数和整数的实用方法。索引是整数（具体来说是short）；其他所有内容都将是浮点数。这些将可供派生对象类使用：
- en: '[PRE25]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Clever readers might have noticed that we're using `ByteBuffer` first, and then
    converting it to `FloatBuffer` or `ShortBuffer`. While the conversion from a byte
    to float might make sense—raw memory is not often represented as floats—some might
    wonder why we don't allocate the `ShortBuffer` as a `ShortBuffer` from the start.
    The reason is actually the same in both cases. We want to take advantage of the
    `allocateDirect` method, which is more efficient and only exists within the `ByteBuffer`
    class.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 聪明的读者可能已经注意到我们首先使用`ByteBuffer`，然后将其转换为`FloatBuffer`或`ShortBuffer`。虽然从字节到浮点的转换可能是有道理的——原始内存通常不表示为浮点数——但有些人可能会想知道为什么我们不从一开始就分配`ShortBuffer`作为`ShortBuffer`。实际上，原因在这两种情况下是一样的。我们希望利用`allocateDirect`方法，这是更有效率的，只存在于`ByteBuffer`类中。
- en: 'Ultimately, the purpose of a `RenderObject` component is to draw geometry on
    the screen. This is done by transforming the 3D view and rendering through a `Material`
    class. Let''s define variables for the material, some setter and getter methods,
    and the `draw` method:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，`RenderObject`组件的目的是在屏幕上绘制几何图形。这是通过对3D视图进行变换并通过`Material`类进行渲染来实现的。让我们为材质定义变量，一些setter和getter方法以及`draw`方法：
- en: '[PRE26]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `draw` method prepares the model transform for this object, and most of
    the draw action happens in materials. The `draw` method will be called from the
    current `Camera` component as it responds to the pose from the Cardboard SDK's
    `onDrawEye` hook. If the component isn't enabled, it's skipped.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`draw`方法为这个对象准备了模型变换，大部分绘制动作发生在材质中。`draw`方法将从当前的`Camera`组件中调用，因为它响应Cardboard
    SDK的`onDrawEye`挂钩的姿势。如果组件未启用，则会被跳过。'
- en: The `RenderObject` class is abstract; we will not be working with `RenderObjects`
    directly. Instead, we'll derive object classes, such as `Cube` and `Sphere`. Let's
    create the `Cube` class from the `RenderObject` component next.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`RenderObject`类是抽象的；我们不会直接使用`RenderObjects`。相反，我们将派生对象类，比如`Cube`和`Sphere`。让我们从`RenderObject`组件中创建`Cube`类。 '
- en: The Cube RenderObject component
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For demonstration purposes, we''ll start with a simple cube. Later on, we''ll
    improve it with lighting. In [Chapter 3](ch03.html "Chapter 3. Cardboard Box"),
    *Cardboard Box*, we defined a `Cube` model. We''ll start by using the same class
    and data structure here. You can even copy the code, but it''s shown in the following
    text. Create a `Cube` Java class in the `renderbox/components/` folder:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We list the coordinates for each face of the cube. Each face is made up of two
    triangles, resulting in 12 triangles, or a total of 36 sets of coordinates to
    define the cube.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: We also list the different colors for each face of the cube. Rather than duplicating
    the colors 36 times, there's the `cubeFacesToArray` method to generate them.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Now, we need to upgrade `Cube` for `RenderBox`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: 'First, add the words `extends` `RenderObject`. This will provide the `super()`
    method in the constructor and allow you to call the `draw()` method:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Allocate buffers for its vertices and colors, and create the `Material` class
    that''ll be used for rendering:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We ensure that `allocateBuffers` is run only once by checking whether `vertexBuffer`
    is `null`.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: We plan to use the `VertexColorMaterial` class for rendering most cubes. That
    will be defined next.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: A `Camera` component will call the `draw` method of the `Cube` class (inherited
    from `RenderObject`), which, in turn, calls the `Material` class's `draw` method.
    The `draw` method will be called from the main `Camera` component as it responds
    to the Cardboard SDK's `onDrawEye` hook.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: Vertex color material and shaders
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Cube` component needs a `Material` to render it on the display. Our `Cube`
    has separate colors for each face, defined as separate vertex colors. We'll define
    a `VertexColorMaterial` instance and the corresponding shaders.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: Vertex color shaders
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At a minimum, the OpenGL pipeline requires that we define a vertex shader,
    which transforms vertices from 3D space to 2D, and a fragment shader, which calculates
    the pixel color values for a raster segment. Similar to the simple shaders that
    we created in [Chapter 3](ch03.html "Chapter 3. Cardboard Box"), *Cardboard Box*,
    we''ll create two files, `vertex_color_vertex.shader` and `vertex_color_fragment.shader`.
    Unless you have done so already, create a new Android resource directory with
    the `raw` type and name it `raw`. Then, for each file, right-click on the directory,
    and go to **New** | **File**. Use the following code for each of the two files.
    The code for the vertex shader is as follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The code for the fragment shader is as follows:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `vertex` shader transforms each vertex by the `u_MVP` matrix, which will
    be supplied by the `Material` class's draw function. The fragment shader simply
    passes through the color specified by the vertex shader.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: VertexColorMaterial
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, we''re ready to implement our first material, the `VertexColorMaterial`
    class. Create a new Java class named `VertexColorMaterial` in the `renderbox/materials/`
    directory. Define the class as `extends Material`:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The methods we''re going to implement are as follows:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '`VertexColorMaterial`: These are constructors'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setupProgram`: This creates the shader program and gets its OpenGL variable
    locations'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setBuffers`: This sets the allocated buffer used in rendering'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`draw`: This draws a model from a view perspective'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s the complete code:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `setupProgram` method creates an OpenGL ES program for the two shaders that
    we created in `res/raw/` directory—`vertex_color_vertex` and `vertex_color_fragment`.
    It then gets references to the `positionParam`, `colorParam`, and `MVPParm` shader
    variables using the `GetAttribLocation` and `GetUniformLocation` calls that provide
    memory locations within the shader program, which are used later for drawing.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: The `setBuffers` method sets the memory buffers for vertices that define an
    object that will be drawn using this material. The method assumes that an object
    model consists of a set of 3D vertices (X, Y, and Z coordinates).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: The `draw()` method renders the object specified in the buffers with a given
    set of **model-view-perspective** (**MVP**) transformation matrices. (Refer to
    the *3D camera, perspective, and head rotation* section of [Chapter 3](ch03.html
    "Chapter 3. Cardboard Box"), *Cardboard Box*, for detailed explanations.)
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed that we aren't using that `ShortBuffer` function mentioned
    earlier. Later on, materials will use the `glDrawElements` call along with an
    index buffer. `glDrawArrays` is essentially a degenerate form of `glDrawElements`,
    which assumes a sequential index buffer (that is, 0, 1, 2, 3, and so on). It is
    more efficient with complex models to reuse vertices between triangles, which
    necessitates an index buffer.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: For completeness, we will also provide a `destroy()` method for each of the
    `Material` classes. We will come to know exactly why the material must be destroyed
    a little later.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, `Material` encapsulates much of the lower level OpenGL ES 2.0
    calls to compile the shader script, create a render program, set the model-view-perspective
    matrices in the shader, and draw the 3D graphic elements.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: We can now implement the `Camera` component.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: The Camera component
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A `Camera` class is another type of `Component`, positioned in space like other
    component objects. The camera is special because through the camera's eyes, we
    render the scene. For VR, we render it twice, once for each eye.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create the `Camera` class, and then see how it works. Create it in the
    `renderbox/components` folder and define it as follows:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The `Camera` class implements two methods: `onNewFrame` and `onDrawEye`, which
    will be delegated from the `RenderBox` class (which, in turn, is delegated from
    `MainActivity`).'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: As the name implies, `onNewFrame` is called on each new frame update. It is
    passed the current Cardboard SDK's `HeadTransform`, which describes the user's
    head orientation. Our camera actually doesn't need the `headTransform` value,
    because `Eye.getEyeView()`, which is combined with the camera matrix, also contains
    rotation information. Instead, we just need to define its position and initial
    direction using `Matrix.setLookAtM` (refer to [http://developer.android.com/reference/android/opengl/Matrix.html](http://developer.android.com/reference/android/opengl/Matrix.html)).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: The `onDrawEye` method is called by the Cardboard SDK once for each eye view.
    Given a Cardboard SDK eye view, the method begins to render the scene. It clears
    the surface, including the depth buffer (used to determine visible pixels), applies
    the eye transformation to the camera (including perspective), and then draws each
    `RenderObject` object in the scene.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: RenderBox methods
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Alright! We're getting closer. We're now ready to build a little scene in `RenderBox`
    using the code we created earlier. To start, the scene will simply consist of
    a colored cube and, of course, a camera.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: At the beginning of this project, we created the skeleton `RenderBox` class,
    which implements `CardboardView.StereoRenderer`.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: 'To this, we now add a `Camera` instance. At the top of the `RenderBox` class,
    declare `mainCamera`, which will get initialized in `onSurfaceCreated`:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Note that Android Studio may find other `Camera` classes; ensure that it uses
    the one that we created in this package.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: 'Shortly after your app starts and the `MainActivity` class is instantiated,
    the `onSurfaceCreated` callback is called. This is where we can clear the screen,
    allocate buffers, and build shader programs. Let''s add that now:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'To be safe, the first thing it does is call reset, which will destroy any materials
    that might have already been compiled by resetting their program handles, before
    possibly compiling others. The need for this will become clear in the later projects
    where we will implement the intent feature to launch/relaunch the apps:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The last thing `onSurfaceCreated` does is invoke the `setup` callback. This
    will be implemented in the interface implementer, which in our case is `MainActivity`.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: In each new frame, we will call the camera's `onNewFrame` method to build the
    camera matrix and apply it to its model-view.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s also capture the current head pose (`headView` and `headAngles` as transformation
    matrices and angles, respectively) if we want to reference it in the later projects
    (refer to [https://developers.google.com/cardboard/android/latest/reference/com/google/vrtoolkit/cardboard/HeadTransform#public-constructors](https://developers.google.com/cardboard/android/latest/reference/com/google/vrtoolkit/cardboard/HeadTransform#public-constructors)).
    Still in `RenderBox`, add the following code:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Then, when the Cardboard SDK goes to draw each eye (for the left and right
    split screen stereoscopic views), we will call the camera''s `onDrawEye` method:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: While we're at it, we can also enable the `preDraw` and `postDraw` callbacks
    (in the previous code, in `onNewFrame`, and in `onFinishFrame`, respectively).
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Should these interface callbacks be implemented in `MainActivity`, they will
    be called from here.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can build a scene that uses a `Camera`, a `Cube`, and the `VertexColorMaterial`
    class.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: A simple box scene
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Let''s rock this riddim!* Make a scene with just a cube and, of course, a
    camera (which has been set up automatically by `RenderBox`). Set up the `MainActivity`
    class using the `IRenderBox` interface''s `setup` callback.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: 'In `setup` of `MainActivity`, we create a `Transform` for the cube and position
    it so that it''s set back and slightly offset in space:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In Android Studio, click on **Run**. The program should compile, build, and
    install onto your connected Android phone. If you receive any compile errors,
    fix them now! As mentioned earlier, with the `Matrix` class, make sure that you
    are importing the right `Camera` type. There is also a `Camera` class within the
    SDK, which represents the phone's physical camera.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: You will see something like this on your device display. (Remember to start
    the app while the device is facing you, or you might need to look behind you to
    find the cube!)
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '![A simple box scene](img/B05144_05_04.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
- en: I don't know about you, but I'm excited! Now, let's add some light and shading.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: Cube with face normals
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, let's add a light to the scene and render the cube with it. To do this,
    we also need to define normal vectors for each face of the cube, which are used
    in the shader calculations.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: 'If you derive `Cube` from the one in [Chapter 3](ch03.html "Chapter 3. Cardboard
    Box"), *Cardboard Box*, you may already have this code:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, add a buffers for the normals, like we have for colors and vertices, and
    allocate them:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We''re going to add a lighting option argument to `createMaterial` and implement
    it using `VertexColorLightingMaterial` if it is set to `true`:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Of course, the `VertexColorLightingMaterial` class hasn't been written yet.
    That's coming up soon. However, first we should create a `Light` component that
    can also be added to illuminate the scene.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: 'We will refactor the `Cube()` constructor method with two variations. When
    no arguments are given, the `Cube` does not create any `Material`. When a Boolean
    lighting argument is given, that gets passed to `createMaterial` in order to choose
    the material:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We'll remind you later, but don't forget to modify the call to new `Cube(true)`
    in `MainActivity` to pass the lighting option.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: Note that we're creating the material in the constructor out of convenience.
    There is nothing to stop us from just adding a `setMaterial()` method to `RenderObject`
    or making the material variable public. In fact, as the number of object and material
    types increases, this becomes the only sane way to proceed. This is a drawback
    of our simplified `Material` system, which expects a different class per material
    type.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: The Light component
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A light source in our scene is a type of `Component` with a color and a float
    array that is used to represent the calculated location in eye space. Let's create
    the `Light` class now.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new `Light` Java class in the `renderbox/components` folder. Define
    it as follows:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Our default light is white (color 1,1,1).
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: The `onDraw` method calculates the actual light position in eye space based
    on the position of `Transform` multiplied by the current view matrix.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: It's possible to extend `RenderBox` to support multiple light sources and other
    fancy rendering, such as shadows and so on. However, we will limit the scene to
    a single light source. Thus, we'll keep it as an instance variable in `RenderBox`.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can add a default light to the scene in `RenderBox`, like how we added
    the `Camera` component earlier. In `RenderBox.java`, add the following code:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Modify `onSurfaceCreated` to initialize the light and add it to the scene:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Then, compute its position in the `Camera` class''s `onDrawEye` (it might change
    for every frame). Edit the `Camera` class in `Camera.java`:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Then, we'll also be able to reference the `mainLight` object in our `Material`
    class's `draw` method. We could have declared the color and position as static
    variables, since we are only using one light, but it makes more sense to plan
    for supporting multiple lights in the future.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: Vertex color lighting material and shaders
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This next topic gets a bit complicated. We're going to write new vertex and
    fragment shaders that handle lighting and write a corresponding class extending
    `Material` that makes use of them. Don't worry though, we've already done this
    once before. We're just going to actually explain it this time.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: Let's dive right into it. Locate the `res/raw/` folder. Then, for each file,
    right-click on it, and go to **New** | **File** to create new files.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: 'File: `res/raw/vertex_color_lighting_vertex.shader`'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The vertex shader maps a 3D vertex to 2D screen space using a model-view transformation
    matrix. Then, it finds the light distance and direction to calculate the light
    color and intensity at that point. These values are passed through the graphics
    pipeline. The fragment shader then determines the pixel colors in the raster segment.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now, we''ll create the `Material`. In the `renderbox/materials/` folder, create
    a `VertexColorLightingMaterial` class. Define it so it extends `Material`, and
    then declare its buffers and methods for `setupProgram` and `draw`. Here''s the
    code in all its gory glory:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: There's a lot going on here, but you can follow along if you read through it
    carefully. Mostly, the material code sets up the parameters that we wrote in the
    shader program.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: It is especially important that in the `draw()` method, we obtain the current
    position transformation matrix, `RenderBox.instance.mainLight.lightPosInEyeSpace`
    of `mainLight` and the light color, and pass them along to the shader program.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: Now is a good time to bring up the calls to `GLES20.glEnableVertexAttribArray`,
    which is required for each vertex attribute you are using. Vertex attributes are
    any data which are specified for each vertex, so in this case, we have positions,
    normals, and colors. Unlike before, we're now using normal and colors.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: 'Having introduced a new `Material`, let''s follow our pattern of adding it
    to `RenderBox.reset()`:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Finally, in the `setup()` method of `MainActivity`, make sure that you pass
    the lighting parameter to the `Cube` constructor:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Run your app. TAADAA!! There, we have it. The difference from the nonlit material
    view may be subtle, but it's more real, virtually.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '![Vertex color lighting material and shaders](img/B05144_05_05.jpg)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
- en: If you'd like to adjust the shading, you might need to play with the attenuation
    value used to calculate the diffuse lighting (for example, change `COEFF = 0.00001`
    to `0.001`) in `vertex_color_lighting_vertex.shader`, depending on the scale of
    your scene. For those still in the dark (pun intended), attenuation is a fancy
    word for how light intensity diminishes over distance, and actually refers to
    the same property of any physical signal (for example, light, radio, sound, and
    so on). If you have a very large scene, you might want a smaller value (so light
    reaches distant regions) or the inverse (so not everything is in light). You might
    also want to make the attenuation a uniform float parameter, which can be adjusted
    and set on a per-material or per-light basis, in order to achieve just the right
    lighting conditions.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: So far, we've been using a single point light to light our scene. A **point
    light** is a light source with a position in 3D space, which casts light equally
    in all directions. Just like a standard light bulb placed at a specific location
    in a room, all that matters is the distance between it and the object, and the
    angle at which the ray strikes the surface. Rotation doesn't matter for point
    lights, unless a cookie is used to apply a texture to the light. We do not implement
    light cookies in the book, but they're super cool.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: Other light sources can be directional lights, which will imitate sunlight on
    earth, where all of the light rays are going essentially in the same direction.
    Directional lights have a rotation that affects the direction of the light rays,
    but they do not have a position, as we assume that the theoretical source is infinitely
    far away along that direction vector. The third type of light source, from a graphics
    perspective, is a spotlight, where the light takes a cone shape and casts a circle
    or ellipse on the surface that it hits. The spotlight will end up working in a
    similar way to the perspective transformation that we do to our MVP matrix. We
    will only be using a single point light for the examples in this book. Implementation
    of other light source types is left as an exercise for the reader.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: Time for animation
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's time to throw in a little more excitement. Let's animate the cube so that
    it rotates. This'll help demonstrate the shading as well.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: For this, we need a `Time` class. This is a singleton utility class that ticks
    off frames and makes that information available to the application, for example,
    via `getDeltaTime`. Note that this is a `final` class, which explicitly means
    that it cannot be extended. There is no such thing as a static class in Java,
    but if we make the constructor private, we can ensure that nothing will ever instantiate
    it.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new `Time` class in the `renderbox/` folder. It won''t be getting
    extended, so we can declare it `final`. Here''s the code:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Start the timer in the `RenderBox` setup:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Then, in the `onNewFrame` method of `RenderBox`, call `Time.update()`:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Now, we can use it to modify the cube''s transform each frame, via the `preDraw()`
    interface hook. In `MainActivity`, make the cube rotate 5 degrees per second about
    the *X* axis, 10 degrees on the *Y* axis, and 7.5 degrees on the *Z* axis:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The `getDeltaTime()` method returns the fraction of a second since the previous
    frame. So, if we want it to rotate 5 degrees around the *X* axis each second,
    we multiply `deltaTime` by 5 to get the fraction of a degree to turn this particular
    frame.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: Run the app. Rock and roll!!!
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: Detect looking at objects
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Wait, there's more! Just one more thing to add. Building interactive applications
    require us to be able to determine whether the user is gazing at a specific object.
    We can put this into `RenderObject`, so any objects in the scene can be gaze detected.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: The technique that we'll implement is straightforward. Considering each object
    we render is projected onto a camera plane, we really only need to determine whether
    the user is looking at the object's plane. Basically, we check whether the vector
    between the camera and the plane position is the same as the camera's view direction.
    But we'll throw in some tolerance, so you don't have to look exactly at the center
    of the plane (that'd be impractical). We will check a narrow range. A good way
    to do this is to calculate the angle between the vectors. We calculate the pitch
    and yaw angles between these vectors (the up/down *X* axis angle and left/right
    *Y* axis angle, respectively). Then, we check whether these angles are within
    a narrow threshold range, indicating that the user is looking at the plane (more
    or less).
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: This method is just like the one used in [Chapter 3](ch03.html "Chapter 3. Cardboard
    Box"), *Cardboard Box,* although at that time, we put it in `MainActivity`. Now,
    we'll move it into the `RenderObject` component.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: Note that this can get inefficient. This technique is fine for our projects
    because there is a limited number of objects, so the calculation isn't expensive.
    But if we had a large complex scene with many objects, this setup would fall short.
    In that case, one solution is to add an `isSelectable` flag so that only those
    objects that should be interactive in a given frame will be interactive.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: If we were using a fully-featured game engine, we would have a physics engine
    capable of doing a `raycast` to precisely determine whether the center of your
    gaze intersects the object with a high degree of accuracy. While this might be
    great in the context of a game, it is overkill for our purposes.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top of `RenderObject`, add a Boolean variable for an `isLooking` value.
    Also, add two variables to hold the yaw and pitch range limits to detect the camera
    viewing angle, and a `modelView` matrix that we''ll use for calculations:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The implementation of the `isLookingAtObject` method is as follows. We convert
    the object space to the camera space, using the `headView` value from `onNewFrame`,
    calculate the pitch and yaw angles, and then check whether they''re within the
    range of tolerance:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'For convenience, we''ll set the `isLooking` flag at the same time the object
    is drawn. Add the call at the end of the `draw` method:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: That should do it.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: 'For a simple test, we''ll log some text to the console when the user is gazing
    at the cube. In `MainActivity`, make a separate variable for the `Cube` object:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Then, test it in `postDraw`, as follows:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Exporting the RenderBox package
  id: totrans-330
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we've finished creating this beautiful `RenderBox` library, how do
    we reuse it in other projects? This is where **modules** and `.aar` files come
    into play. There are a number of ways to share code between Android projects.
    The most obvious way is to literally copy pieces of code into the next project
    as you see fit. While this is perfectly acceptable in certain situations, and
    in fact should be part of your normal process, it can become quite tedious. What
    if we have a bunch of files that reference each other and depend on a certain
    file hierarchy, such as `RenderBox`? If you're familiar with Java development,
    you might say, "Well, obviously just export the compiled classes in a `.jar` file."
    You would be right, except that this is Android. We have some generated classes
    as well as the `/res` folder, which contains, in this case, our shader code. What
    we actually want is an `.aar` file. Android programmers might be familiar with
    `.aidl` files, which are used for similar purposes, but specifically to establish
    interfaces between apps, and not encapsulate feature code.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: To generate an `.aar` file, we first need to put our code inside an Android
    Studio module with a different output than an app. You have a few options from
    this point onward. We recommend that you create a dedicated Android Studio project,
    which contains the `RenderBox` module as well a test app, which will build alongside
    the library and serve as a means to ensure that any changes you make to the library
    don't break anything. You can also just copy the `renderbox` package and the `/res/raw`
    folders into a new project and go from there, but eventually, you'll see that
    a module is much more convenient.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: You might think "We're gonna call this new project `RenderBox`," but you might
    run into a snag. Basically, the build system can't handle a situation where a
    project and module have the same name (they would be expected to have the same
    package name, which is a no-no). If you call your project `RenderBox`, (technically,
    you shouldn't have if you followed the instructions) and include an activity,
    and then create a module called `RenderBox`, you will see a build error that complains
    about the project and module sharing a name. If you create an empty project with
    no activity called `RenderBox` and add a module called `RenderBox`, you happen
    to get away with it, but as soon as you try to build an app from this project,
    you'll find that you cannot. Hence, we suggest that your next step from here is
    to create a new project called `RenderBoxLib`.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: Building the RenderBoxLib module
  id: totrans-334
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's give it a shot. Go to **File** | **New** | **New Project**. Name the project
    `RenderBoxLib`.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: We don't need a `MainActivity` class, but we're still going to want one, as
    discussed, as a test case to ensure that our library works. Adding a test app
    to the library project not only gives us the convenience of testing changes to
    the library in a single step, but also ensures that we cannot build a new version
    of the library without ensuring that an app that uses it can also compile it.
    Even if your library is free of syntax errors, it might still break compilation
    when you include it in a new project.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: So, go ahead and add an **Empty Activity**, and click on **Finish** in the default
    options.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: 'All familiar territory so far. However, now we''re going to create a new module:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: Go to **File** | **New** | **New Module** and select **Android Library**:![Building
    the RenderBoxLib module](img/B05144_05_06.jpg)
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name it `RenderBox`.![Building the RenderBoxLib module](img/B05144_05_07.jpg)
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we have a new folder in our project view:![Building the RenderBoxLib module](img/B05144_05_08.jpg)
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Instead of performing the next steps in Android Studio, let's just use our file
    manager (Windows Explorer or Finder, or the terminal if you're a pro) to copy
    our `RenderBox` files from the existing project into the new one. If you're using
    version control, you might consider transferring your repository to the new project,
    or creating an init commit before the copy; it's up to you and how much you care
    about preserving your history.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: We want to copy all your `RenderBox` code to the new module from the `RenderBoxDemo`
    project's `/app/src/main/java/com/cardbookvr/renderbox` folder to the `/renderbox/src/main/java/com/cardbookvr/renderbox`
    folder of `RenderBoxLib`.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: The same goes for the resources; copy them from the `RenderBoxDemo` project's
    `/app/src/main/res/raw` folder to `/renderbox/src/main/res/raw`.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: This means that almost every `.java` and `.shader` file that we created in the
    original project goes into the module of the new project, in their corresponding
    locations.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: We won't be transferring `MainActivity.java`, or any of the XML files, such
    as `layouts/activity_main.xml` or `AndroidManifest.xml` to the module. These are
    app-specific files, which are not included in the library.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: Once you've copied the files, go back to Android Studio, and click on the **Synchronize**
    button. This will ensure that Android Studio has noticed the new files.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: '![Building the RenderBoxLib module](img/B05144_05_09.jpg)'
  id: totrans-348
  prefs: []
  type: TYPE_IMG
- en: Then, with `renderbox` selected in the hierarchy panel, initiate a build by
    navigating to **Build** | **Make Module 'RenderBox'** (or *Ctrl* + *Shift* + *F9*).
    You will see a bunch of errors. Let's take care of them.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: '`RenderBox` references the Cardboard SDK, and as such, we must include it in
    the `RenderBox` module as a dependency in a similar way to how we do it for the
    main app, like at the beginning of this project:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: Add the Cardboard SDK `common.aar` and `core.aar` library files to your project
    as new modules, using **File** | **New** | **New Module...** and **Import .JAR/.AAR
    Package**.
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the library modules as dependencies to the `RenderBox` model, using **File**
    | **Project Structure**. In the left-side panel, select `RenderBox`, then choose
    the **Dependencies** tab | **+** | **Module Dependency**, and add common and core
    modules.
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you sync the project and trigger a build, you will hopefully see those
    errors related to `CardboardView` and so on disappear.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: Another build. Still, other errors?
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: This is because of the naming issues mentioned earlier. If the package name
    of your module doesn't match the package name from the original project (that
    is, `com.cardbookvr.renderbox`), you will have to rename it in the copied Java
    files. Even if these match, we named our original project `RenderBoxDemo`, which
    means that the generated R class will be part of the `com.cardbookvr.renderboxdemo`
    package. Any import references to this package will need to be changed.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by deleting the line that references `com.cardbookvr.renderboxdemo` (such
    as the `Material` Java files). Then, any references to the R class will show up
    as errors:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: '![Building the RenderBoxLib module](img/B05144_05_12.jpg)'
  id: totrans-357
  prefs: []
  type: TYPE_IMG
- en: Delete this line, and Android Studio will generate a new valid import line.
    Try and build it again. If it's error-free, we're good to go.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: 'You will now see references to R show up as errors with a suggestion:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: '![Building the RenderBoxLib module](img/B05144_05_13.jpg)'
  id: totrans-360
  prefs: []
  type: TYPE_IMG
- en: If you go ahead and press *Alt* + *Enter*, Android Studio will add the appropriate
    import line to your code. If you don't see the *Alt* + *Enter* tooltip, try placing
    your cursor next to R. Using the feature this way, you'll have to select **Import
    Class** from the menu you see after pressing *Alt* + *Enter*. If you still see
    errors, make sure that you've copied the shader code into the `/renderbox/res/raw`
    folder, and that there aren't other errors interfering with this process. Essentially,
    we are removing any external references from the code and getting `RenderBox`
    to build on its own. We can also accomplish this code fix by simply pasting `import
    com.cardbook.renderbox.R;` over `import com.cardbook.renderboxdemo.R;`. That's
    probably easier than the first method, but then you wouldn't have learned about
    *Alt* + *Enter*.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: Once this is done, we should be able to build without errors. This might seem
    like a messy way to work, but it doesn't hurt to get messy once in a while. You
    might even learn something new about the build pipeline you didn't know earlier.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: If everything goes well, you will see a file called `renderbox-debug.aar` in
    `renderbox/build/outputs/aar/`. If so, you're done. Whew!
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: 'One final thought: you should include `renderbox-release.aar` in your final
    applications, but you will lose useful debugging features in the meantime. We
    will not discuss how to switch back and forth between debug and release in this
    book, but understanding build configurations is essential to the publication process.'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: The RenderBox test app
  id: totrans-365
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This new project houses the `renderbox` module, but there's also an `app` folder
    that we created in the first place. `app` is where we can implement a test application
    to make sure, at a minimum, that the library is built and basically runs.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re going to do the same thing to the app module in `RenderBoxLib` that
    we did in our new projects (like `renderbox`, `app` is a module. It turns out
    that we''ve been using modules the whole time!):'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on the `app` folder, go to **Open Module Settings**, and add the
    existing `renderbox` module as a **Module dependency** with **Compile Scope**.
    Notice that the dependencies cannot be circular. Now that `renderbox` is a dependency
    of the app, the reverse cannot be true.
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update `/res/layout/activity_main.xml` and `AndroidManifest.xml`, as we saw
    at the top of this chapter. (If you're just copying code, make sure that you change
    the `package=` value to the current name, for example, `com.cardbookvr.renderboxlib`).
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set up `class MainActivity extends CardboardActivity implements IRenderBox`.
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We now also want our `MainActivity` class to instantiate `RenderBox` and define
    a `setup()` method, just like `MainActivity` in `RenderBoxDemo`. In fact, just
    go ahead and copy the entire `MainActivity` class from `RenderBoxDemo`, and make
    that you do not copy/overwrite the package definition at the top of the new file
    in your new project.
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With any luck, you should be able to click on the green run button, select your
    target device, and see a running app with our buddy, the vertex color cube. We've
    officially gone backward in terms of the final result, but our application-specific
    code is so clean and simple!
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: Using RenderBox in future projects
  id: totrans-373
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we''ve gone through all of this trouble, let''s do a trial run to
    see how to use our pretty little package all tied up with a bow. One more time.
    You can perform the following steps to start each of the subsequent projects in
    this book:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: Create a new project, called whatever you like, such as `MyCardboardApp`, for
    API 19 KitKat. Include **Empty Activity**.
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, go to **File** | **New** | **New Module…**. It's a little counterintuitive,
    but even though we are importing an existing module, we're adding a new one to
    this project. Choose **Import .JAR/.AAR Package**.![Using RenderBox in future
    projects](img/B05144_05_14.jpg)
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You''ll need to navigate to the `RenderBoxLib/renderbox/build/outputs` folder
    of your `RenderBox` lib project, and select the `.aar` file. We recommend that
    you rename the module to `renderbox`, as opposed to `renderbox-debug`. Click on
    **Finish**. For a production app, you would want to have two different modules
    in your project: one for debug and one for release, but we will only be using
    debug for the projects in this book.'
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we have this new module, we need to add it as a dependency to the default
    app. Go back to the familiar **Module Settings** screen, and head over to the
    **Dependencies** tab for `app`. Click on the plus tab on the right-hand side,
    and choose **Module dependency**:![Using RenderBox in future projects](img/B05144_05_15.jpg)
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, you can add `renderbox`:![Using RenderBox in future projects](img/B05144_05_16.jpg)
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We now have a copy of the `.aar` file in our new project's `/renderbox` module
    folder. When you've made changes to the `RenderBox` library, you just need to
    build a new `.aar` file (build menu, `MakeProject`), overwrite the copy in the
    new project, and trigger a project sync, or clean and rebuild if you want to be
    sure. The new project does not maintain a link to the build folder of your library
    output project.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: 'The remaining steps required to setup a new project are as follows:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: Use **File** | **New Module** to import the Cardboard SDK `.aar` packages `common`
    and `core`, and add them as dependencies to the app.
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update `/res/layout/activity_main.xml` and `AndroidManifest.xml`, as we've just
    done for `RenderBoxDemo`.
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set up the `MainActivity` class so that it extends `CardboardActivity` and implements
    `IRenderBox`, using the same code as before.
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We now also want our `MainActivity` class to instantiate `RenderBox` and define
    a `setup()` method, just like our `MainActivity` class in `RenderBoxDemo`. In
    fact, just go ahead and copy the entire `MainActivity` class, and be careful not
    to copy/overwrite the package definition at the top of the file.
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build and run it yet again. Bagged it! We can now proceed with the cool stuff.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-387
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This will be our new project process from now on, since the rest of the projects
    in this book make use of the `RenderBox` library module.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: 'A final word on the module process: there''s more than one way to peel an orange.
    You could have just created a new module in the `RenderBox` demo project, grabbed
    its output, and been off and running. You can also just copy source files around
    and try using Git submodules or subtrees to synchronize the sources. This page
    from the IntelliJ docs discusses some of the finer points as well ([https://www.jetbrains.com/idea/help/sharing-android-source-code-and-resources-using-library-projects.html](https://www.jetbrains.com/idea/help/sharing-android-source-code-and-resources-using-library-projects.html)).
    We''ve also made certain decisions in terms of keeping the main activity and layout
    files completely application-specific, and including most or all of our shaders
    and materials in the `RenderBox` module, instead of in application code. At any
    one of these decision points, there are pros and cons, and we recommend that you
    think carefully about how you structure your own code in future projects.'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-390
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we created a short and sweet, lightweight graphics engine to
    build new Cardboard VR applications. We abstracted the low-level OpenGL ES API
    calls into a suite of `Material` classes and a `Camera` class. We defined `RenderObject`
    for geometric entities, a `Camera` and `Light` components which inherit from a
    `Component` class. We defined a `Transform` class to organize and orient entities
    (which contain components) hierarchically in 3D space. All of this is integrated
    under the `RenderBox` class, which is instantiated and controlled in the `MainActivity`
    class, which, in turn, implements the `IRenderBox` interface. We complete the
    circle by specifying the `MainActivity` class as the implementer of `IRenderBox`
    and implementing `setup`, `preDraw`, and `postDraw`.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: To develop the library, we followed much of what was covered in [Chapter 3](ch03.html
    "Chapter 3. Cardboard Box"), *Cardboard Box*, with less explanation of how to
    use OpenGL ES and matrix libraries and more focus on implementing our `RenderBox`
    software architecture.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: The resulting `RenderBox` engine library is now in its own project. In subsequent
    chapters we will reuse this library, and we will expand it, including new Components
    and Materials. You are encouraged to maintain your `RenderBoxLib` code in a source
    code repository, such as Git. Of course, the final code is provided with the book
    assets and in our GitHub repository.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter is a science project! We're going to build a model of our Solar
    System, replete with the Sun, planets, moons, and a starscape. Using `RenderBox`,
    we will add a `Sphere` component, and we will also add textured shaders to our
    suite of materials.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
