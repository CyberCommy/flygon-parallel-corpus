- en: Improving RESTful Web Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we created RESTful web services in Lumen, and we identified
    some missing elements or improvements required. In this chapter, we will work
    on improving that and completing some missing elements. We will improve certain
    elements with respect to fulfilling loopholes and code quality.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter to improve our RESTful web
    service:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Dingo, simplifying RESTful API development:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing and configuring Dingo API package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simplifying routes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API versioning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rate limiting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Internal requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authentication and middleware
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transformers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Need of encryption:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SSL, different options
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dingo, simplifying RESTful API development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Yes, you heard it right. I didn't say bingo. It's Dingo. Actually, Dingo API
    is a package for Laravel and Lumen that makes it a lot simpler to develop RESTful
    web services. It provides many features out of the box and many are what we saw
    in the previous chapter. Many of these features will make our existing code better
    and easier to understand and maintain. You can check out the Dingo API package
    at [https://github.com/dingo/api](https://github.com/dingo/api).
  prefs: []
  type: TYPE_NORMAL
- en: Let's first install it, and we will keep looking at its benefits and features
    side by side while using them.
  prefs: []
  type: TYPE_NORMAL
- en: Installation and configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Simply install it through composer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Probably, you are wondering what this `@dev` is. So, here is what the Dingo
    documentation says:'
  prefs: []
  type: TYPE_NORMAL
- en: At this time, the package is still in a developmental stage and as such, does
    not have a stable release. You may need to set your minimum stability to dev.
  prefs: []
  type: TYPE_NORMAL
- en: If you are still not sure about why we need to set minimum stability, then it
    is because of the default minimum stability for every package that is set to `stable`.
    So, if you rely on the `dev` package, then it should be explicitly specified,
    or it probably will not install it as minimum stability will not match with the
    package's actual stability status.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once it is installed, you need to register it. Go to `bootstrap/app.php` and
    put this statement in this file somewhere before `return $app;`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'After doing this, there are a few variables you need to set in your `.env`
    file. Add them at the end of the `.env` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Configuration is self-explanatory. Now, let's move forward.
  prefs: []
  type: TYPE_NORMAL
- en: Simplifying routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you look at the `routes/web.php` file where we put our routes, you can see
    that we wrote 54 lines of code for post and comment endpoints. With Dingo API,
    we can replace those 54 lines with just 10 lines of code, and it will be even
    more cleaner. So let''s do that. Here is how your `routes/web.php` file should
    look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we just got the object of the router in `$api`. However, this
    is Dingo API router, not Lumen's default router. As you can see, it has the `resource()`
    method available as we wanted, and we can mention unwanted methods in the `except`
    array. So overall, our routes are now very much simplified.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see the exact routes for your application, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: API versioning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Probably, you have noticed that in the preceding code example in our route file,
    we already mentioned the API version as `v1`. It is because API versioning is
    important and Dingo provides us the facility to do so. It is useful to serve different
    endpoints from different versions. You can have another version group and can
    serve the same endpoint with different content. If there is the same endpoint
    under different versions, then it will pick the version that is mentioned in your
    `.env` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, it is better to have version in URI. To do so, we can simply use the
    following prefix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'With that now, our routes will include version information in URI. This is
    a recommended approach. Because if someone is working with version 1 and we are
    going to change something in version 2, then the client using version 1 will not
    be affected if they are specifying the version number explicitly in their requests.
    So, our endpoint URLs will be something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'However, note that if we are having versions in our URI and routes, then it
    is better to keep that version actually applicable in our controllers as well.
    Without that, version implementation will be very limited. To do so, we should
    have a version-based namespace for controllers. In our controllers (both `PostController`
    and `CommentController`), namespace will be changed to the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now, the controllers directory structure should match the namespace as well.
    So, let's create a directory named `V1` in the `Controllers` directory and move
    our controllers inside the `app\Http\Controllers**\V1**` directory. When we will
    have the next version, we will make another directory named `V2` in `app\Http\Controllers`
    and add new controllers in it. It will also result in a new namespace `App\Http\Controllers**\V2**`.
    With a namespace and directory change, controller's paths in `routes/web.php`
    will also need to be changed accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this change, you will most probably see the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'So, either move `Controller.php` in the controllers directory to the `V1` directory
    or simply access it with a complete namespace such as `\App\Http\Controllers\Controller`
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: It is up to you how you do it.
  prefs: []
  type: TYPE_NORMAL
- en: Rate limiting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Rate limiting is also known as throttling. It means that there should be a
    limit on how much time a particular client is able to hit the API endpoint in
    a specific time interval. To enable it, we must enable the `api.throttling` middleware.
    You can apply throttling on all routes or on specific routes. You will just apply
    middleware on that particular route as shown here. In our case, we want to enable
    it for all endpoints, so let''s put it in a version group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Just for the sake of simplicity, let''s make a change in routes. Instead of
    specifying namespace with every controller''s name, we can simply use namespace
    in a version group as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$api->version(''v1'', [''middleware'' => ''api.throttle'', ''prefix'' => ''api/v1'',
    **namespace => "App\HttpControllers\V1"** **]**`'
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can simply remove it from the controller path.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also mention the limit and time interval in minutes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Here, `expires` is the time interval, while `limit` is the number of times a
    route can be accessed.
  prefs: []
  type: TYPE_NORMAL
- en: Internal requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are mostly making an API to be accessed as a web service from the outside
    by an external client, not from the same application. However, sometimes, we are
    in a situation where we need to make internal requests within the same application
    and want data in the same format as it is being returned to external clients.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say now you want comments data in `PostController` from the API as it
    returns a response instead of an internal function call. We want the same data
    that the `/api/posts/{postId}/comments` endpoint returns when hit from Postman
    or another client. In that case, the Dingo API package helps us. Here is how simple
    it is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Bold statements in the preceding code snippet is what is different, and it
    contributes in making an internal request. As you can say, we have made a `GET`-based
    request to the endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also make it a `POST`-based request by just using a different method
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Responses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Dingo API package provides a lot more support for different types of responses.
    As we will not go in to the detail of each and every thing Dingo API provides,
    you can review it in its documentation at [https://github.com/dingo/api/wiki/Responses](https://github.com/dingo/api/wiki/Responses).
  prefs: []
  type: TYPE_NORMAL
- en: However, later in this chapter, we will look at responses and formats in detail.
  prefs: []
  type: TYPE_NORMAL
- en: We will use the Dingo API package for other things as well, but for now, let's
    move towards other concepts and we will keep using the Dingo API package side
    by side.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication and middleware
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already discussed several times that for a RESTful web service, a session
    is maintained through an authentication token stored on the client side. So, the
    server can look for the authentication token and can find that user's session
    stored on the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several ways to generate a token. In our case, we will use **JWT**
    (**JSON Web Tokens**). As told on `jwt.io`:'
  prefs: []
  type: TYPE_NORMAL
- en: JSON Web Tokens are an open, industry standard RFC 7519 method for representing
    claims securely between two parties.
  prefs: []
  type: TYPE_NORMAL
- en: We will not go into complete detail about JWT as JWT is a way to transfer information
    between two parties (in our case, client and server) as JWT can be used for many
    purposes. Instead, we will use it for access/authentication tokens to maintain
    stateless sessions. So, we will stick with what we need from JWT. We need it for
    maintaining sessions for authentication purposes, and this is something the Dingo
    API package will also help us with.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, Dingo API supports three authentication providers at the time of writing
    this book. By default, HTTP Basic Authentication is enabled. The other two are
    JWT Auth and OAuth 2.0\. We will use JWT Auth.
  prefs: []
  type: TYPE_NORMAL
- en: JWT Auth setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The package that Dingo API uses to integrate JWT authentication can be found
    at [https://github.com/tymondesigns/jwt-auth.](https://github.com/tymondesigns/jwt-auth)
  prefs: []
  type: TYPE_NORMAL
- en: "[\uFEFF](https://github.com/tymondesigns/jwt-auth)"
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to set up JWT Auth:'
  prefs: []
  type: TYPE_NORMAL
- en: We can simply follow instructions for the JWT Auth package and configure it
    to use with Dingo manually and fix problems one by one manually.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can simply install another package that helps us install and set up Dingo
    API and JWT Auth together with some basic configurations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Here, we will see both ways. However, with the manual way, it can be ambiguous
    because of different versions of different packages and Lumen itself. So, although
    I am going to show the manual way, I would recommend that you use an integration
    package so that you don't need to deal with every thing at a low level manually.
    I will show you the manual way just to give you some idea of what is included
    underneath.
  prefs: []
  type: TYPE_NORMAL
- en: The Manual way
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's install the package as mentioned on the installation page at [https://github.com/tymondesigns/jwt-auth/wiki/Installation.](https://github.com/tymondesigns/jwt-auth/wiki/Installation)
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we need to install the JWT Auth package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Note that this version is for Laravel 5.3\. For older versions, you might need
    to use a different version of the JWT Auth package, most probably version 0.5.
  prefs: []
  type: TYPE_NORMAL
- en: 'To register the service provider in the `bootstrap/app.php` file, add this
    line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, add these two class aliases in the same `bootstrap/app.php` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you need to generate a random key that will be used to sign our tokens.
    To do so, run this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This will generate a random key.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might see some error as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[Illuminate\Contracts\Container\BindingResolutionException] Unresolvable dependency
    resolving [Parameter #0 [ <required> $app ]] in class Illuminate\Cache\CacheManager`'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, add the following lines in `bootstrap/app.php` right after `$app->withEloquent();`.
    So, it will fix the problem and you can try generating a random key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'However, you are probably wondering where this random key will be set. Actually,
    some packages were not built for Lumen and require a structure more like Laravel.
    The `tymondesigns/jwt-auth` package is one of them. What it needs is a way to
    publish configurations. While Lumen does not have separate configuration files
    for different packages, as we need it, we can simply let Lumen have such a `config`
    file for this package. To do so, if you don''t have `helpers.php` under `app/`
    directory, then create it and add the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, add `helpers.php` to `composer.json` in the auto-load array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have it, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, you will get another error saying:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Don''t worry; it is all expected. It is because Lumen does not have the `vendor:publish`
    command out of the box. So, we need to install a small package for this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: As this command is going to have a new command, in order to use that command,
    we need to put the following in the `$commands` array in `app/Console/Kernel.php`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, try running the same command again as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, you will see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Now, we have `blog/config/jwt.php` and we can store the `jwt-auth` package-related
    configurations in this file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we need to do is to rerun this command to set random key sign
    signatures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, you can see this key set in the `config/jwt.php` file in the return
    array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The next, you need to do configurations as shown in [https://github.com/tymondesigns/jwt-auth/wiki/Configuration](https://github.com/tymondesigns/jwt-auth/wiki/Configuration).
  prefs: []
  type: TYPE_NORMAL
- en: However, you can also keep other settings in `config/jwt.php` as default.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next thing will be to tell Dingo API to use JWT as the authentication method.
    So add this in `bootstrap/app.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: As per the JWT Auth documentation, we are mostly done with configurations, but
    note that you may face small issues related to versions. If you are using a version
    older than Lumen 5.3, then note that a different version of JWT Auth is required
    based on the different Laravel version. For version 5.2, you should use JWT Auth
    Version 0.5\. So, if you still get any errors in the version older than Laravel
    5.2, then note that it is possible that the error is because of version difference,
    so you have to search on the Internet.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, just to use two packages together to achieve some functionality,
    we have to spend some time on configurations, as suggested in the last few steps.
    Even then, there is a chance of errors because of version differences. So, an
    easy and simple way is to not install the Dingo API package and JWT Auth package
    manually. There is another package, installing which will install the Dingo API
    package, Lumen generators, **CORS** (**Cross Origin Resource Sharing**) support,
    and JWTAuth and make it available to use without that much configuration. Now,
    let's look at that.
  prefs: []
  type: TYPE_NORMAL
- en: Simpler way through Lumen JWT authentication integration package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An easier way is to install both Dingo API package and JWT Auth yourself is
    to simply install [https://packagist.org/packages/krisanalfa/lumen-dingo-adapter.](https://packagist.org/packages/krisanalfa/lumen-dingo-adapter)
  prefs: []
  type: TYPE_NORMAL
- en: 'It will add Dingo and JWT in your Lumen-based application. Simply install this
    package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in `bootstrap/app.php`, add the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, this way, we are using this `LumenDingoAdapter` package, so here is the
    `bootstrap/app.php` file that we will use so that you can compare it with yours:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are wondering what exactly this `$app->withFacades()` do then note that
    this enables facades in application. Facades is a design pattern which is used
    to make complex things abstract while providing simplified interface to interact
    with. In Lumen, as told by Laravel documentation: <q>Facades provide a "static"
    interface to classes that are available in the application''s service container.</q>'
  prefs: []
  type: TYPE_NORMAL
- en: Benefit of using facades is that it provides memorable syntax. We are not going
    to use Facades frequently, and will try to avoid using it because we will favor
    dependency injection over it. However, some packages will may be using facades
    so to let them work, we have enabled facades.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we can protect our endpoints using the `api.auth` middleware. This middleware
    checks for user authentication and gets user from JWT. However, the first thing
    is to make the user log in, create a token based on that user information, and
    return the signed token to the client.
  prefs: []
  type: TYPE_NORMAL
- en: In order to have authentication working, we first need to create an authentication-related
    controller. That controller will not only do token creation based on user login,
    it will also make the user token expire and refresh the token. In order to do
    this, we can put this open source `AuthController` in the `app/Http/Controllers/Auth/`
    directory at
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/Haafiz/REST-API-for-basic-RPG/blob/master/app/Http/Controllers/Auth/AuthController.php.](https://github.com/Haafiz/REST-API-for-basic-RPG/blob/master/app/Http/Controllers/Auth/AuthController.php)'
  prefs: []
  type: TYPE_NORMAL
- en: Just to give credit, I want to tell you that the version we are using for `AuthController`
    is a modified version of [https://github.com/krisanalfa/lumen-jwt/blob/develop/app/Http/Controllers/Auth/AuthController.php](https://github.com/krisanalfa/lumen-jwt/blob/develop/app/Http/Controllers/Auth/AuthController.php).
  prefs: []
  type: TYPE_NORMAL
- en: 'Anyway, in case you don''t see `AuthController` available online while reading
    the book, here is the content of `AuthController`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This controller does three major tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Login in `login()` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Invalidate token
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refresh token
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Log in
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Log in is being done in the `login()` method, and it tries to log in using
    `JWTAuth::attempt($this->getCredentials($request))` . If credentials are not valid
    or if there is some other problem, it will just return an error. However, to access
    this `login()` method, we need to add a route for it. Here is what we will add
    in `routes/web.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Invalidate token
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To invalidate token, in other words, to log out user, the `invalidateToken()`
    method will be used. This method will be called through a route. We will add the
    following route with the delete request method, which will call `AuthController::invalidateToken()`
    from the routed file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Refresh token
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Refresh token is called when the token has expired based on the expiry time.
    In order to refresh the token, we also need to add the following route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Note that all these endpoints will be added under version v1.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have this `AuthController` there and routes are set up, the user can
    log in using the following endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Try this and you will get a JWT-based access token.
  prefs: []
  type: TYPE_NORMAL
- en: '**Lumen, Dingo, JWT Auth, and CORS boilerplate**:'
  prefs: []
  type: TYPE_NORMAL
- en: If you face difficulty in configuring Lumen with Dingo and JWT, then you can
    simply use the repository at [https://github.com/krisanalfa/lumen-jwt.](https://github.com/Haafiz/lumen-jwt)
    This repository will provide you with boilerplate code for setting up your Lumen
    for API development using Dingo API and JWT. You can clone this and simply start
    using it. It is nothing other than a Lumen integration with JWT, Dingo API, and
    CORS support. So, if you are starting a new RESTful web services project, you
    can simply start with this boiler plate code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before proceeding, let''s look at our routes file to make sure we are on the
    same page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we have made a route group. A route group is just a way to group
    similar routes in which we can apply the same middleware or namespace or prefix
    and so on, just like we did in the `v1` group.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we made another route group so that we can add the `api.auth` middleware
    on it. Another thing to note is that we have split some posts routes from post
    resource route to separate routes just to have some routes available without login.
    We did the same for comments routes as well.
  prefs: []
  type: TYPE_NORMAL
- en: Note that if you don't want to split some routes from the resource route, then
    you can do that as well. You will just add the `api.auth` middleware in controllers
    instead of routes file. Both ways are correct; it is just a matter of preference.
    I did it this way because I find it easier to know which routes are protected
    from the same routes file instead of constructors of different controllers. But
    again, it is up to you.
  prefs: []
  type: TYPE_NORMAL
- en: We are letting only logged in users create, update, and delete posts. However,
    we need to make sure that the user that is logged in can only update or delete
    their own posts. Although this thing can also be done by creating another middleware,
    it will be simpler to do it in controller.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how we do it in `PostController`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, there are three places where I have highlighted code. In the
    `store()` method, we got the user ID from it and put it in the input array so
    that the `user_id` of post will be based on the token. Similarly, for `update()`
    and `delete()`, we used that user's ID and placed a check to make sure that Post
    owner is deleting or updating post records. You are probably wondering that when
    we haven't defined the `$this->user` property anywhere, how are we accessing it?
    Actually, we are using the Helpers trait, so `$this->user` is coming from that
    trait.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that in order to access protected resources, you should grab the token
    from the login endpoint and put it in your header as follows: `Authentication:
    bearer <token grabbed from login>`'
  prefs: []
  type: TYPE_NORMAL
- en: In the same way, `CommentController` will have checks to make sure that comments
    modification will be limited to the comment owner only and deletion will be limited
    to the comment or post owner. It will have similar checks and user ID through
    token in the same way. So, I will leave that to you to implement comment controller
    to have those checks.
  prefs: []
  type: TYPE_NORMAL
- en: Transformers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In full-stack MVC framework, we have Model View Controller. In Lumen or in API,
    we don't have Views because we just return some data. However, we may want to
    show data in a different way than usual. We may want to use a different format,
    or we may want to restrict an object with a specific format. In all such cases,
    we need a place where formatting-related tasks will be done, a place where we
    can have different format-related content. We can have it in controller. However,
    we will need to define the same format at different places. In that case, we can
    add a method in model. For example, post model can have a specific way to format
    a post object. So, we can define another method in Post Model.
  prefs: []
  type: TYPE_NORMAL
- en: It will work fine, but if you look at it closely, it is related to formatting,
    not model. So, we have another layer called serializes or transformers. Also,
    sometimes, we need nested objects, so we will not want to do the same nesting
    again and again.
  prefs: []
  type: TYPE_NORMAL
- en: Lumen provides a way to serialize data to JSON. In Eloquent object, there is
    a method named `toJson()`; this method can be overridden to serve the purpose.
    However, it is better to have a separate layer for formatting and serializing
    data than having just a method to do so in the same class. Then comes transformers;
    a transformer is just another layer. You can think of a transformer as the View
    layer of an API or web service.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding and setting transformers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Actually, the package we used, named, Dingo API, contains a lot of stuff that
    we need to create a RESTful web service. The same Dingo API package provides support
    for transformers as well.
  prefs: []
  type: TYPE_NORMAL
- en: Before doing anything, we need to understand that the transformer layer consists
    of transformers. A transformer is a class responsible for data presentation. Dingo
    API transformers support transformers, and for transformers, the API depends on
    another library responsible for transformer functionality. It is up to us which
    transformation layer or library we use. By default, it comes with Fractal, a default
    transformation layer.
  prefs: []
  type: TYPE_NORMAL
- en: We don't need to do anything else related to setup. Let's move towards using
    transformer for our objects. However, before that, make yourself comfortable with
    Fractal. We need to at least know what Fractal is and what it provides. The documentation
    for Fractal can be found at [http://fractal.thephpleague.com/](http://fractal.thephpleague.com/).
  prefs: []
  type: TYPE_NORMAL
- en: Using transformers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two ways to tell Lumen which transformer class has to be used. For
    that, we need to create a transformer class. Let''s first make a transformer for
    our `Post` object and name it `PostTransformer`. First, create a directory named
    `app/Transformers` and in that directory, create a class `PostTransformer` with
    the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'You can do whatever you want to do with the Post response in the `transform()`
    method. Note that we are not optionally overriding the `transform()` method here,
    but we are providing an implementation of `transform()`. You always need to add
    that method in the transformer class. However, this class is of no use if it is
    not used from anywhere. So, let''s use it from our `PostController`. Let''s do
    it in the `index()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we have injected the `PostTransformer` object to the `$this->response->paginator()`
    method. The first thing we need to note here is the `$this->response->paginator()`
    method and the `$this->response` object. We now need to know from where the `$this->response`
    object came from in the first place. We got it because we used the `Helpers` trait
    in `PostController`. Anyway, now, let''s see how it works. Hit the `PostController`
    `index()` method with the following endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'It will return something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: If you look at it, you will see a separate meta section having pagination-related
    content. This is a small thing that Fractal transformer provides by itself. Actually,
    there is a lot more that Fractal can do for us.
  prefs: []
  type: TYPE_NORMAL
- en: We can include nested objects. For example, if we have `user_id` in `Post` and
    we want the `User` object nested inside the same `Post` object, then it can provide
    an easier way to do that as well. Although the transformer layer is just like
    the view layer for API response data, it provides a lot more than that. Right
    now, I will show you how our `PostController` method will look after returning
    with `PostTransformer` from `show()` and other methods. For details of Fractal,
    I would recommend that you look at the Fractal documentation, so that you can
    take full advantage of it, at [http://fractal.thephpleague.com/](http://fractal.thephpleague.com/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how our `PostController` method will look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: From the highlighted lines in the preceding code snippet, you can see that we
    have added the `PostTransformer` object in constructor and placed it in `$this->transformer`
    that we used in other methods. Another thing you can see is that at one place,
    we used the `$this->response->paginator()` method in the `index()` method, while
    we used `$this->response->item()` in others. It is because `$this->response->item()`
    method is used when there is one object, while `paginator` is used when we have
    the `paginator` object in the `index()` method. Note that if you have a collection
    and do not have the `paginator` object, you should use `$this->response->collection()`.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned earlier, Fractal has more features and those are in its documentation.
    So, you need to take a pause and explore its documentation at [http://fractal.thephpleague.com/.](http://fractal.thephpleague.com/)
  prefs: []
  type: TYPE_NORMAL
- en: Encryption
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next thing that we are missing is encryption of communication between client
    and server so that nobody can sniff and read data over the network. For this purpose,
    we will use **SSL** (**Secure Socket Layer**). As this book is not about encryption
    or cryptography or server setup, we will not go into the details of these concepts,
    but it is important that we talk about encryption here. If someone is able to
    sniff data over the network, then our website or web service is not secure.
  prefs: []
  type: TYPE_NORMAL
- en: In order to secure our web service, we will use HTTPS instead of HTTP. The "S"
    in HTTPS stands for Secure. Now, the question is how we can make it secure. Probably,
    you would say that we will use SSL as we said earlier. So what is SSL? SSL is
    Secure Socket Layer, a standard way to secure communication between server and
    browser. SSL refers to a security protocol. Actually SSL protocol had three versions,
    and they were insecure against some attacks. So what we actually use is **TLS**
    (**Transport Layer Security**). However, we still use SSL term when we are referring
    to TLS. If you want to use SSL certificate and SSL to make HTTP secure, actually
    what is used underneath is TLS which is better than original SSL protocols.
  prefs: []
  type: TYPE_NORMAL
- en: What happens is that when a connection is made, the server sends the SSL certificate's
    copy to the browser with the public key as well so that the browser can also encode
    or decode what is communicated to and from the server. We will not go into encryption
    details; however, we need to know how to get the SSL certificate.
  prefs: []
  type: TYPE_NORMAL
- en: SSL certificate, different options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Normally, the SSL certificate is bought from certificate providers. However,
    you can also get a free certificate from [letsencrypt.org](http://letsencrypt.org).
    So, if a free certificate is available, then why are certificates still bought?
    Actually, sometimes, buying it from some authorities is more about insurance than
    security. If you are making an e-commerce site or something that is accepting
    payment or very critical data such as financial information, then you need someone
    to take responsibility in front of your site's user.
  prefs: []
  type: TYPE_NORMAL
- en: Probably there is some minor difference (that I am unaware of) between a certificate
    from [letsencrypt.org](http://letsencrypt.org) and from providers who sell for
    good prices, but normally, it is bought for insurance instead of security.
  prefs: []
  type: TYPE_NORMAL
- en: You will get installation instructions from whoever you get certificates from.
    If you prefer to go with [letsencrypt.org](https://letsencrypt.org/) , then I
    would recommend that you use certbot. Follow the instructions at [https://certbot.eff.org/](https://certbot.eff.org/).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed what we were missing in the previous chapter where
    we implemented RESTful web service endpoints in Lumen. We discussed throttling
    (Request Rate Limiting) to prevent DoS or brute force. We also implemented token-based
    authentication using some packages. Note that we only secured endpoints here,
    which we didn't want to leave accessible without user login. If there are other
    endpoints that you don't want to have public access to but they don't need users
    to log in, then you can use either some sort of key or basic authentication on
    those endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: Other than that, we discussed and used transformers that are a sort of view
    layer for web services. Then, we briefly discussed encryption and SSL importance
    and then discussed the available options for SSL certificates.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I will not give you a list or URLs for more resources because
    we discussed a lot of different things in this chapter, so we were not able to
    go into the details of each and every thing. To completely absorb it, you should
    first look at the documentation of every thing that we discussed here, and then,
    you should practice. You will actually learn when you face problems during practice
    and when you attempt to solve them.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will talk about testing and write test cases for our
    endpoints and our code using automated testing tools.
  prefs: []
  type: TYPE_NORMAL
