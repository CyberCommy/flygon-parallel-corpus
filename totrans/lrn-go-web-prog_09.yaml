- en: Chapter 9. Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter we looked at how to store information generated by our
    application as it works as well as adding unit tests to our suite to ensure that
    the application behaves as we expect it to and diagnose errors when it does not.
  prefs: []
  type: TYPE_NORMAL
- en: In that chapter, we did not add a lot of functionality to our blog app; so let's
    get back to that now. We'll also extend some of the logging and testing functionality
    from this chapter into our new features.
  prefs: []
  type: TYPE_NORMAL
- en: Till now, we have been working on the skeleton of a web application that implements
    some basic inputs and outputs of blog data and user-submitted comments. Just like
    any public networked server, ours is subject to a variety of attack vectors.
  prefs: []
  type: TYPE_NORMAL
- en: None of these are unique to Go, but we have an arsenal of tools at our disposal
    to implement the best practices and extend our server and application to mitigate
    common issues.
  prefs: []
  type: TYPE_NORMAL
- en: When building a publicly accessible networked application, one quick and easy
    reference guide for common attack vectors is the **Open Web Application Security
    Project** (**OWASP**), which provides a periodically updated list of the most
    critical areas where security issues manifest. OWASP can be found at [https://www.owasp.org/](https://www.owasp.org/).
    Its Top Ten Project compiles the 10 most common and/or critical network security
    issues. While it's not a comprehensive list and has a habit of becoming dated
    between updates, but it still remains a good first start when compiling potential
    vectors.
  prefs: []
  type: TYPE_NORMAL
- en: A few of the most pervasive vectors of the years have unfortunately stuck around;
    despite the fact that security experts have been shouting from the rooftops of
    their severity. Some have seen a rapid decrease in exposure across the Web (like
    injection), but they still tend to stick around longer, for years and years, even
    as legacy applications phase out.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a glimpse of four of the most recent top 10 vulnerabilities, from late
    2013, some of which we''ll look at in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Injections**: Any case where untrusted data has an opportunity to be processed
    without escaping, thus allowing data manipulation or access to data or systems,
    normally its not exposed publicly. Most commonly this is an SQL injection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Broken authentication**: This is caused due to poor encryption algorithms,
    weak password requirements, session hijacking is feasible.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**XSS**: Cross-site scripting allows an attacker to access sensitive information
    by injecting and executing scripts on another site.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cross-site request forgery**: Unlike XSS, this allows the attack vector to
    originate from another site, but it fools a user into completing some action on
    another site.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While the other attack vectors range from being relevant to irrelevant for our
    use case, it is worth evaluating the ones that we aren't covering, to see what
    other places might be rife for exploitation.
  prefs: []
  type: TYPE_NORMAL
- en: To get going, we'll look at the best ways to implement and force HTTPS in your
    applications using Go.
  prefs: []
  type: TYPE_NORMAL
- en: HTTPS everywhere – implementing TLS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 5](ch05.html "Chapter 5. Frontend Integration with RESTful APIs"),
    *Frontend Integration with RESTful APIs*, we looked at creating self-signed certificates
    and utilizing HTTPS/TLS in our app. But let's review quickly why this matters
    so much in terms of overall security for not just our application but the Web
    in general.
  prefs: []
  type: TYPE_NORMAL
- en: First, simple HTTP generally produces no encryption for traffic, particularly
    for vital request header values, such as cookies and query parameters. We say
    generally here because RFC 2817 does specify a system use TLS over the HTTP protocol,
    but it's all but unused. Most importantly, it would not give users the type of
    palpable feedback necessary to register that a site is secure.
  prefs: []
  type: TYPE_NORMAL
- en: Second and similarly, HTTP traffic is subsequently vulnerable to man-in-the-middle
    attacks.
  prefs: []
  type: TYPE_NORMAL
- en: 'One other side effect: Google (and perhaps other search engines) begun to favor
    HTTPS traffic over less secure counterparts.'
  prefs: []
  type: TYPE_NORMAL
- en: Until relatively recently, HTTPS was relegated primarily to e-commerce applications,
    but the rise in available and prevalent attacks utilizing the deficiencies of
    HTTP—like sidejacking and man-in-the-middle attacks—began to push much of the
    Web toward HTTPS.
  prefs: []
  type: TYPE_NORMAL
- en: You may have heard of the resulting movement and motto **HTTPS Everywhere**,
    which also bled into the browser plugins that force site usage to implement the
    most secure available protocol for any given site.
  prefs: []
  type: TYPE_NORMAL
- en: One of the easiest things we can do to extend the work in [Chapter 6](ch06.html
    "Chapter 6. Sessions and Cookies"), *Session and Cookies* is to require that all
    traffic goes through HTTPS by rerouting the HTTP traffic. There are other ways
    of doing this, as we'll see at the end of the chapter, but it can be accomplished
    fairly simply.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll implement a `goroutine` to concurrently serve our HTTPS and HTTP
    traffic using the `tls.ListenAndServe` and `http.ListenAndServe` respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This assumes that we set a `SECUREPORT` constant to, likely, `":443"` just as
    we set `PORT` to `":8080"`, or whatever you chose. There's nothing preventing
    you from using another port for HTTPS; the benefit here is that the browser directs
    `https://` requests to port `443` by default, just as it directs HTTP requests
    to ports `80` and sometimes fallback to port `8080`. Remember that you'll need
    to run as sudo or administrator in many cases to launch with ports below `1000`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You''ll note in the preceding example that we''re utilizing a separate handler
    for HTTP traffic called `redirectNonSecure`. This fulfills a very basic purpose,
    as you''ll see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here, `serverName` is set explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: There are some potential issues with gleaning the domain or server name from
    the request, so it's best to set this explicitly if you can.
  prefs: []
  type: TYPE_NORMAL
- en: Another very useful piece to add here is **HTTP Strict Transport Security**
    (**HSTS**), an approach that, when combined with compliant consumers, aspires
    to mitigate protocol downgrade attacks (such as forcing/redirecting to HTTP).
  prefs: []
  type: TYPE_NORMAL
- en: This is nothing more than an HTTPS header that, when consumed, will automatically
    handle and force the `https://` requests for requests that would otherwise utilize
    less secure protocols.
  prefs: []
  type: TYPE_NORMAL
- en: 'OWASP recommends the following setting for this header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note that this header is ignored over HTTP.
  prefs: []
  type: TYPE_NORMAL
- en: Preventing SQL injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While injection remains one of the biggest attack vectors across the Web today,
    most languages have simple and elegant ways of preventing or largely mitigating
    the odds of leaving vulnerable SQL injections in place with prepared statements
    and sanitized inputs.
  prefs: []
  type: TYPE_NORMAL
- en: But even with languages that provide these services, there is still an opportunity
    to leave areas open for exploits.
  prefs: []
  type: TYPE_NORMAL
- en: One of the core tenets of any software development whether on the Web or a server
    or a standalone executable is to never trust input data acquired from an external
    (and sometimes internal) source.
  prefs: []
  type: TYPE_NORMAL
- en: This tenet stands true for any language, though some make interfacing with a
    database safer and/or easier either through prepared queries or abstractions,
    such as **Object-relational mapping** (**ORM**).
  prefs: []
  type: TYPE_NORMAL
- en: Natively, Go doesn't have any ORM and since there technically isn't even an
    O (Object) (Go not being purely object-oriented), it's hard to replicate a lot
    of what object-oriented languages have in this area.
  prefs: []
  type: TYPE_NORMAL
- en: There are, however, a number of third-party libraries that attempt to coerce
    ORM through interfaces and structs, but a lot of this could be very easily written
    by hand since you probably know your schemas and data structures better than any
    library, even in the abstract sense.
  prefs: []
  type: TYPE_NORMAL
- en: For SQL, however, Go has a robust and consistent interface for almost any database
    that supports SQL.
  prefs: []
  type: TYPE_NORMAL
- en: To show how an SQL injection exploit can simply surface in a Go application,
    we'll compare a raw SQL query to a prepared statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we select pages from our database, we use the following query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This shows us how to open up your application to injection vulnerabilities by
    accepting unsanitized user input. In this case, anyone requesting a page like
  prefs: []
  type: TYPE_NORMAL
- en: '`/page/foo;delete from pages` could, in theory, empty your `pages` table in
    a hurry.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have some preliminary sanitization at the router level that does help in
    this regard. As our mux routes only include alphanumeric characters, we can avoid
    some of the characters that would otherwise need to be escaped being routed to
    our `ServePage` or `APIPage` handlers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This is not a foolproof way of addressing this, though. The preceding query
    took raw input and appended it to the SQL query, but we can handle this much better
    with parameterized, prepared queries in Go. The following is what we ended up
    using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This approach is available in any of Go''s query interfaces, which take a query
    using `?` in place of values as a variadic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: While all of these fulfill a slightly different purpose within the world of
    SQL, they all implement the prepared query in the same way.
  prefs: []
  type: TYPE_NORMAL
- en: Protecting against XSS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've touched briefly upon cross-site scripting and limiting this as a vector
    makes your application safer for all users, against the actions of a few bad apples.
    The crux of the issue is the ability for one user to add dangerous content that
    will be shown to users without scrubbing out the aspects that make it dangerous.
  prefs: []
  type: TYPE_NORMAL
- en: Ultimately you have a choice here—sanitize the data as it comes in or sanitize
    the data as you present it to other users.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, if someone produces a block of comment text that includes a
    `script` tag, you must take care to stop that from ever being rendered by another
    user's browser. You can choose to save the raw HTML and then strip all, or only
    the sensitive tags on the output rendering. Or, you can encode it as it's entered.
  prefs: []
  type: TYPE_NORMAL
- en: There's no right answer; however, you may discover value in following the former
    approach, where you accept anything and sanitize the output.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is risk with either, but this approach allows you to keep the original
    intent of the message should you choose to change your approach down the road.
    The downside is that of course you can accidentally allow some of this raw data
    to slip through unsanitized:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The first function will take the data and remove the formatting of the HTML
    to produce a plaintext version of the message input by a user.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second function will do something similar but for JavaScript-specific values.
    You can test these very easily with a quick script similar to the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If we request from the unsafe endpoint, we''ll get our data back:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Protecting against XSS](img/B04294_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Compare this with `/html_safe`, which automatically escapes the input, where
    you can see the content in its sanitized form:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Protecting against XSS](img/B04294_09_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: None of this is foolproof, but if you choose to take input data as the user
    submits it, you'll want to look at ways to relay that information on resulting
    display without opening up other users to XSS.
  prefs: []
  type: TYPE_NORMAL
- en: Preventing cross-site request forgery (CSRF)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While we won't go very deeply into CSRF in this book, the general gist is that
    it is a slew of methods that malicious actors can use to fool a user into performing
    an undesired action on another site.
  prefs: []
  type: TYPE_NORMAL
- en: As it's at least tangentially related to XSS in approach, it's worth talking
    about now.
  prefs: []
  type: TYPE_NORMAL
- en: 'The biggest place where this manifests is in forms; think of it as a Twitter
    form that allows you to send tweets. If a third party forced a request on a user''s
    behalf without their consent, think of something similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Without any protection, anyone who posts to this guestbook would inadvertently
    help spread spam to this attack.
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, Twitter is a mature application that has long ago handled this, but
    you get the general idea. You might think that restricting referrers will fix
    this problem, but that can also be spoofed.
  prefs: []
  type: TYPE_NORMAL
- en: The shortest solution is to generate secure tokens for form submissions, which
    prevents other sites from being able to construct a valid request.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, our old friend Gorilla also provides a few helpful tools in this
    regard. Most relevant is the `csrf` package, which includes tools to produce tokens
    for requests as well as prebaked form fields that will produce `403` if violated
    or ignored.
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest way to produce a token is to include it as part of the interface
    that your handler will be using to produce a template, as so from our `ApplicationAuthenticate()`
    handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point we''ll need to expose `{{.csrfField}}` in our template. To validate,
    we''ll need to chain it to our `ListenAndServe` call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Securing cookies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the attack vectors we looked at earlier was session hijacking, which
    we discussed in the context of HTTP versus HTTPS and the way others can see the
    types of information that are critical to identity on a website.
  prefs: []
  type: TYPE_NORMAL
- en: Finding this data is incredibly simple on public networks for a lot of non-HTTPS
    applications that utilize sessions as definitive IDs. In fact, some large applications
    have allowed session IDs to be passed in URLs
  prefs: []
  type: TYPE_NORMAL
- en: In our application, we've used Gorilla's `securecookie` package, which does
    not rely on HTTPS because the cookie values themselves are encoded and validated
    using HMAC hashing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Producing the key itself can be very simple, as demonstrated in our application
    and the `securecookie` documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For more info on Gorilla''s `securecookie` package see: [http://www.gorillatoolkit.org/pkg/securecookie](http://www.gorillatoolkit.org/pkg/securecookie)'
  prefs: []
  type: TYPE_NORMAL
- en: Presently, our app's server has HTTPS first and secure cookies, which means
    that we likely feel a little more confident about storing and identifying data
    in the cookie itself. Most of our create/update/delete operations are happening
    at the API level, which still implements session checking to ensure our users
    are authenticated.
  prefs: []
  type: TYPE_NORMAL
- en: Using the secure middleware
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the more helpful packages for quickly implementing some of the security
    fixes (and others) mentioned in this chapter is a package from Cory Jacobsen called,
    helpfully, `secure`.
  prefs: []
  type: TYPE_NORMAL
- en: Secure offers a host of useful utilities, such as SSLRedirects (as we implemented
    in this chapter), allowed Hosts, HSTS options, and X-Frame-Options shorthand for
    preventing your site from being loaded into frames.
  prefs: []
  type: TYPE_NORMAL
- en: A good amount of this covers some of the topics that we looked at in this chapter
    and is largely the best practice. As a piece of middleware, secure can be an easy
    way to quickly cover some of those best practices in one swoop.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To grab `secure`, simply go get it at [github.com/unrolled/secure](http://github.com/unrolled/secure).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While this chapter is not a comprehensive review of web security issues and
    solutions, we hoped to address some of the biggest and most common vectors as
    surfaced by OWASP and others.
  prefs: []
  type: TYPE_NORMAL
- en: Within this chapter we covered or reviewed the best practices to prevent some
    of these issues from creeping into your applications.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 10](ch10.html "Chapter 10. Caching, Proxies and Improved Performance"),
    *Caching, Proxies, and Improved Performance*, we'll look at how to make your application
    scale with increased traffic while remaining performant and speedy.
  prefs: []
  type: TYPE_NORMAL
