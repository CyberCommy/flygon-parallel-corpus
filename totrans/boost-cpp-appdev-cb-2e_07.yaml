- en: Manipulating Strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Changing cases and case-insensitive comparison
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Matching strings using regular expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Searching and replacing strings using regular expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Formatting strings using safe printf-like functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Replacing and erasing strings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Representing a string with two iterators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a reference to string type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This whole chapter is devoted to different aspects of changing, searching, and
    representing strings. We'll see how some common string-related tasks can be easily
    done using Boost libraries. This chapter is easy enough; it addresses very common
    string manipulation tasks. So, let's begin!
  prefs: []
  type: TYPE_NORMAL
- en: Changing cases and case-insensitive comparison
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is a pretty common task. We have two non-Unicode or ANSI character strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We need to compare them in a case-insensitive manner. There are a lot of methods
    to do that, let's take a look at Boost's.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Basic knowledge of `std::string` is all we need here.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are different ways to do case-insensitive comparisons:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The most simple one is:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the Boost predicate and standard library method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Making a lowercase copy of both the strings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Making an uppercase copy of the original strings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Converting the original strings to lowercase:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The second method is not an obvious one. In the second method, we compare the
    length of strings. If they have the same length, we compare the strings character
    by character using an instance of the `boost::is_iequal` predicate. The `boost::is_iequal`
    predicate compares two characters in a case insensitive way.
  prefs: []
  type: TYPE_NORMAL
- en: The `Boost.StringAlgorithm` library uses `i` in the name of a method or class,
    if this method is case-insensitive. For example, `boost::is_iequal`, `boost::iequals`,
    `boost::is_iless`, and others.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Each function and the functional object of the `Boost.StringAlgorithm` library
    that works with cases accept `std::locale`. By default (and in our examples),
    methods and classes use default constructed `std::locale`. If we work a lot with
    strings, it may be a good optimization to construct an `std::locale` variable
    once and pass it to all the methods. Another good optimization would be to use
    the *C* locale (if your application logic permits that) via `std::locale::classic()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Nobody forbids you to use both optimizations.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, C++17 has no string functions from `Boost.StringAlgorithm`. All
    the algorithms are fast and reliable, so do not be afraid to use them in your
    code.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Official documentation of the Boost String Algorithms Library can be found at
    [http://boost.org/libs/algorithm/string](http://boost.org/libs/algorithm/string)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See the *C++ Coding Standards* book by Andrei Alexandrescu and Herb Sutter for
    an example on how to make a case-insensitive string with a few lines of code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Matching strings using regular expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's do something useful! It is a common case when the user's input must be
    checked using some **regular expression**. The problem is that there are a lot
    of regular expression syntaxes, expressions written using one syntax are not treated
    well by the other syntaxes. Another problem is that long regexes are not so easy
    to write.
  prefs: []
  type: TYPE_NORMAL
- en: So in this recipe, we are going to write a program that supports different regular
    expression syntaxes and checks that the input strings match the specified regexes.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe requires basic knowledge of standard library. Knowledge of regular
    expression syntaxes can be helpful.
  prefs: []
  type: TYPE_NORMAL
- en: Linking examples against the `boost_regex` library is required.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This regex-matcher example consists of a few lines of code in the `main()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement it, we need the following headers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'At the start of the program, we need to output the available regex syntaxes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, correctly set up flags, according to the chosen syntax:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We are now requesting regex patterns in a loop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Getting a `String to match:` in a loop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Applying regex to it and outputting the result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We will finish our example by restoring `std::cin` and requesting new regex
    patterns:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now if we run the preceding example, we''ll get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the matching is done by the `boost::regex` class. It constructs an object
    that is capable of regex parsing and compilation. Additional configuration options
    are passed to the class using a `flag` input variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the regular expression is incorrect, `boost::regex` throws an exception.
    If the `boost::regex::no_except` flag was passed, it reports an error returning
    a non-zero in the `status()` call (just like in our example):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This will result in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Regular expressions matching is done by a call to the `boost::regex_match` function.
    It returns `true` in case of a successful match. Additional flags may be passed
    to `regex_match`, but we avoided their usage for brevity of the example.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C++11 contains almost all the `Boost.Regex` classes and flags. They can be found
    in the `<regex>` header of the `std::` namespace (instead of `boost::`). Official
    documentation provides information about differences of C++11 and `Boost.Regex`.
    It also contains some performance measures that tell that `Boost.Regex` is fast.
    Some standard libraries have performance issues, so choose wisely between Boost
    and Standard library versions.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Searching and replacing strings by regular expressions* recipe will give
    you more information about the `Boost.Regex` usage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You may also consider official documentation to get more information about flags,
    performance measures, regular expression syntaxes, and C++11 conformance at [http://boost.org/libs/regex](http://boost.org/libs/regex)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Searching and replacing strings using regular expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: My wife enjoyed the *Matching strings by regular expressions* recipe very much.
    But, she wanted more and told me that I'll get no food until I promote the recipe
    to be able to replace parts of the input string according to a regex match.
  prefs: []
  type: TYPE_NORMAL
- en: Ok, here it comes. Each matched sub-expression (part of the regex in parenthesis)
    must get a unique number starting from 1; this number would be used to create
    a new string.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how an updated program should work like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll be reusing the code from the *Matching strings by regular expressions*
    recipe. It is recommended to read it before getting your hands on this one.
  prefs: []
  type: TYPE_NORMAL
- en: Linking an example against the `boost_regex` library is required.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This recipe is based on the code from the previous one. Let''s see what must
    be changed:'
  prefs: []
  type: TYPE_NORMAL
- en: 'No additional headers should be included. However, we need an additional string
    to store the replace pattern:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We replace `boost::regex_match` with `boost::regex_find` and output matched
    results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we need to get the replace pattern and apply it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: That's it! Everyone's happy and I'm fed.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `boost::regex_search` function doesn''t only return a `true` or a `false`
    value (unlike the `boost::regex_match` function does), but also stores matched
    parts. We output matched parts using the following construction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Note that we outputted the results by skipping the first result (`results.begin()
    + 1`), that is because `results.begin()` contains the whole regex match.
  prefs: []
  type: TYPE_NORMAL
- en: The `boost::regex_replace` function does all the replacing and returns the modified
    string.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are different variants of the `regex_*` functions, some of them receive
    bidirectional iterators instead of strings and some provide output to the iterator.
  prefs: []
  type: TYPE_NORMAL
- en: '`boost::smatch` is a `typedef` for `boost::match_results<std::string::const_iterator>`.
    If you are using some other bidirectional iterators instead of `std::string::const_iterator`,
    you shall use the type of your bidirectional iterators as a template parameter
    for `boost::match_results`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`match_results` has a format function, so we may tune our example with it,
    instead of:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We may use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'By the way, `replace_string` supports multiple formats:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: All the classes and functions from this recipe exist in C++11 in the `std::`
    namespace of the `<regex>` header.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Official documentation of `Boost.Regex` will give you more examples and information
    about performance, C++11 standard compatibility, and regular expression syntax
    at [http://boost.org/libs/regex](http://boost.org/libs/regex). The *Matching strings
    by regular expressions* recipe will tell you the basics of `Boost.Regex`.
  prefs: []
  type: TYPE_NORMAL
- en: Formatting strings using safe printf-like functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `printf` family of functions is a threat to security. It is a very bad design
    to allow users to put their own strings as a type and format the specifiers. So
    what do we do when user-defined format is required? How shall we implement the
    `std::string to_string(const std::string& format_specifier) const;` member function
    of the following class?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Basic knowledge of standard library is more than enough for this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We wish to allow users to specify their own output format for a string:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To do that in a safe manner, we need the following header:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we add some comments for the user:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'It is time to make all the parts work:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'That is all. Take a look at this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Imagine that `class_instance` has a member `i` equal to `100`, `s` member equal
    to `"Reader"`, and a member `c` equal to `''!''`. Then, the program will output
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `boost::format` class accepts the string that specifies the resulting string
    format. Arguments are passed to `boost::format` using `operator%`. Values `%1%`,
    `%2%`, `%3%`, `%4%`, and so on, in the format specifying string are replaced by
    arguments passed to `boost::format`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also disable the exceptions for cases when a format string contains fewer
    arguments than passed to `boost::format`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'This is done to allow some formats like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What happens in case of an incorrect format?
  prefs: []
  type: TYPE_NORMAL
- en: 'Nothing awful, an exception is thrown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines are outputted to the console by the previous code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: C++17 has no `std::format`. The `Boost.Format` library is not a very fast library.
    Try not to use it in performance critical sections a lot.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Official documentation contains more information about performance of the `Boost.Format`
    library. More examples and documentation on extended printf-like format is available
    at [http://boost.org/libs/format.](http://boost.org/libs/format)
  prefs: []
  type: TYPE_NORMAL
- en: "[\uFEFF](http://boost.org/libs/format)"
  prefs: []
  type: TYPE_NORMAL
- en: Replacing and erasing strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Situations where we need to erase something in a string, replace a part of the
    string, or erase the first or last occurrence of some sub-string are very common.
    Standard library allows us to do more parts of this, but it usually involves too
    much code writing.
  prefs: []
  type: TYPE_NORMAL
- en: 'We saw the `Boost.StringAlgorithm` library in action in the *Changing cases
    and case-insensitive comparison* recipe. Let''s see how it can be used to simplify
    our lives when we need to modify some strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Basic knowledge of C++ is required for this example.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This recipe shows how different string-erasing and replacing methods from the
    `Boost.StringAlgorithm` library work:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Erasing requires the `#include <boost/algorithm/string/erase.hpp>` header:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'This code outputs the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Replacing requires the `<boost/algorithm/string/replace.hpp>` header:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'This code outputs the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the examples are self-documenting. The only one that is not obvious is the
    `replace_head_copy` function. It accepts count of bytes to replace as a second
    parameter and a replace string as the third parameter. So, in the preceding example,
    `Hello` gets replaced with `Whaaaaaaa!`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are also methods that modify strings in-place. They just do not end on
    `_copy` and return `void`. All the case-insensitive methods (the ones that start
    with `i`) accept `std::locale` as the last parameter and use a default constructed
    locale as a default parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Do you use case insensitive methods a lot and need a better performance? Just
    create a `std::locale` variable holding `std::locale::classic()` and pass it to
    all the algorithms. On small strings most of the time is eaten by `std::locale`
    constructions, not by the algorithms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: C++17 does not have `Boost.StringAlgorithm` methods and classes. However, it
    has a `std::string_view` class that can use substrings without memory allocations.
    You can find out more about `std::string_view` like classes in the next two recipes
    of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Official documentation contains a lot of examples and a full reference of all
    the methods at [http://boost.org/libs/algorithm/string](http://boost.org/libs/algorithm/string)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See the *Changing cases and case-insensitive comparison* recipe from this chapter
    for more information about the `Boost.StringAlgorithm` library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Representing a string with two iterators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are situations when we need to split some strings into substrings and
    do something with those substrings. In this recipe, we want to split string into
    sentences, count characters, and white-spaces and, of course, we want to use Boost
    and be as efficient as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You'll need some basic knowledge of standard library's algorithms for this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'That''s very easy to do with Boost:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, include the right headers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s define our test string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'We make a `typedef` for our splitting iterator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Construct that iterator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can iterate between matches:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Count the number of characters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'And count the white-spaces:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s it. Now if we run an example, it will output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main idea of this recipe is that we do not need to construct `std::string`
    from substrings. We even do not need to tokenize the whole string at once. All
    we need to do is find the first substring and return it as a pair of iterators
    to the beginning and to the end of the substring. If we need more substrings,
    find the next substring and return a pair of iterators for that substring.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00015.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now, let's take a closer look at `boost::split_iterator`. We constructed one
    using the `boost::make_split_iterator` function that takes `range` as the first
    argument and a binary finder predicate (or binary predicate) as the second. When
    `split_iterator` is dereferenced, it returns the first substring as `boost::iterator_range<const
    char*>`, which just holds a pair of pointers and has a few methods to work with
    them. When we increment `split_iterator`, it tries to find the next substring,
    and if there is no substring found, `split_iterator::eof()` returns `true`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Default constructed split iterator represents an `eof()`. So we could rewrite
    the loop condition from `!sentences.eof()` to `sentences != split_iter_t()`. You
    could also use the split iterators with algorithms, for example: `std::for_each(sentences,
    split_iter_t(), [](auto range){ /**/ });`.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `boost::iterator_range` class is widely used across all the Boost libraries.
    You may find it useful even for your own code in situations when a pair of iterators
    must be returned or when a function shall accept/work with a pair of iterators.
  prefs: []
  type: TYPE_NORMAL
- en: The `boost::split_iterator<>` and `boost::iterator_range<>` classes accept a
    forward iterator type as a template parameter. Because we were working with the
    character array in the preceding example, we provided `const char*` as iterators.
    If we were working with `std::wstring`, we would need to use the `boost::split_iterator<std::wstring::const_iterator>`
    and `boost::iterator_range<std::wstring::const_iterator>` types.
  prefs: []
  type: TYPE_NORMAL
- en: C++17 has neither `iterator_range` nor `split_iterator`. However, there are
    discussions going on for accepting `iterator_range` like class that would probably
    have the name `std::span`.
  prefs: []
  type: TYPE_NORMAL
- en: The `boost::iterator_range` class has no virtual functions and no dynamic memory
    allocations, it is fast and efficient. However, its output stream operator `<<`
    has no specific optimizations for character arrays, so streaming could be slow.
  prefs: []
  type: TYPE_NORMAL
- en: The `boost::split_iterator` class has a `boost::function` class in it, so constructing
    it for big functors could be slow. Iterating adds only tiny overheads that you
    won't feel even in performance critical sections.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next recipe will tell you about a nice replacement for `boost::iterator_range<const
    char*>`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Official documentation for `Boost.StringAlgorithm` may provide you with more
    detailed information about classes and a whole bunch of examples at [http://boost.org/libs/algorithm/string](http://boost.org/libs/algorithm/string)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'More information about `boost::iterator_range` can be found here: [http://boost.org/libs/range](http://boost.org/libs/range);
    it is a part of the `Boost.Range` library that is not described in this book,
    but you may wish to study it by yourself'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a reference to string type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This recipe is the most important recipe in this chapter! Let''s take a look
    at a very common case, where we write some function that accepts a string and
    returns a part of the string between character values passed in the `starts` and
    `ends` arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Do you like this implementation? In my opinion, it is awful. Consider the following
    call to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: In this example, a temporary `std::string` variable is constructed from `"Getting
    expression (between brackets)"`. The character array is long enough, so there
    is a big chance that dynamic memory allocation is called inside the `std::string`
    constructor and the character array is copied into it. Then, somewhere inside
    the `between_str` function, new `std::string` is being constructed, which may
    also lead to another dynamic memory allocation and copying.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, this simple function may, and in most cases will:'
  prefs: []
  type: TYPE_NORMAL
- en: Call dynamic memory allocation (two times)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copy string (two times)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deallocate memory (two times)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can we do better?
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe requires basic knowledge of standard library and C++.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We do not really need a `std::string` class here, we only need some lightweight
    class that does not manage resources and only has a pointer to the character array
    and array's size. Boost has the `boost::string_view` class for that.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the `boost::string_view` class, include the following header:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Change the method''s signature:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Change `std::string` to `boost::string_view:` everywhere inside the function
    body:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The `boost::string_view` constructor accepts size as a second parameter, so
    we need to slightly change the code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s it! Now we may call `between("Getting expression (between brackets)",
    ''('', '')'')` and it will work without any dynamic memory allocation and characters
    copying. And we can still use it for `std::string`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As already mentioned, `boost::string_view` contains only a pointer to the character
    array and size of data. It has a lot of constructors and may be initialized in
    different ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The `boost::string_view` class has all the methods required by the `container`
    class, so it is usable with standard library algorithms and Boost algorithms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: The `boost::string_view` class does not really own string, so all its methods
    return constant iterators. Because of that, we cannot use it in methods that modify
    data, such as `boost::to_lower(r)`.
  prefs: []
  type: TYPE_NORMAL
- en: While working with `boost::string_view`, we must take additional care about
    data that it refers to; it must exist and be valid for the whole lifetime of the
    `boost::string_view` variable that references it.
  prefs: []
  type: TYPE_NORMAL
- en: Before Boost 1.61 there was no `boost::string_view` class, but the `boost::string_ref`
    class was used instead. Those classes are really close. `boost::string_view` closer
    follows the C++17 design and has better constexpr support. Since Boost 1.61, `boost::string_ref`
    is deprecated.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `string_view` classes are fast and efficient, because they never allocate
    memory and have no virtual functions! Use them wherever it is possible. They are
    designed to be a drop-in replacement for `const std::string&` and `const char*`
    parameters. It means that you can replace the following three functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'With a single one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `boost::string_view` class is a C++17 class. You can find it in the `<string_view>`
    header in the `std::` namespace if your compiler is C++17 compatible.
  prefs: []
  type: TYPE_NORMAL
- en: Boost's and standard library's version support constexpr usage of `string_view`s;
    however, `std::string_view` currently has more functions marked with constexpr.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that we have accepted the `string_view` variable by value instead of a
    constant reference. That''s the recommended way for passing `boost::string_view`s
    and `std::string_view`s because:'
  prefs: []
  type: TYPE_NORMAL
- en: '`string_view` is a small class with trivial types inside. Passing it by value
    usually results in better performance because of less indirections and it allows
    the compiler to do more optimizations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In other cases, when there's no performance difference writing `string_view
    val` is shorter than writing `const string_view& val`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Just like the C++17''s `std::string_view`, the `boost::string_view` class is
    actually a `typedef`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'You may also find useful the following typedefs for wide characters in the
    `boost::` and `std::` namespaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Boost documentation for `string_ref` and `string_view` can be found at [http://boost.org/libs/utility](http://boost.org/libs/utility).
  prefs: []
  type: TYPE_NORMAL
