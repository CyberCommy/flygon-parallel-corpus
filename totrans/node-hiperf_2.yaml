- en: Chapter 2. Development Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Developing is just great. It gives you a sense of freedom to create new things.
    This is true for almost every language—a freedom to create something in your own
    way. This means that there are good ways and not-so-good ways to do the same task.
    A developer, during the course of their life, will face different problems with
    similar solutions and will adopt patterns. For some problems, they will know the
    patterns they are using; for others, they will be using patterns that they probably
    don't even know.
  prefs: []
  type: TYPE_NORMAL
- en: Some patterns directly increase performance, and others do it indirectly because
    of an architecture pattern that is able to scale. Creating high-performance applications
    involves knowing every bit of running code, which results in knowing the patterns
    used across an application. Sometimes, they're unintentional. At other times,
    they are enforced because of the benefits of a specific pattern. Patterns are
    everywhere, from the creation of objects to the interaction between objects and
    first-class services of an application.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, there are patterns specific to languages and platforms. This is because
    the compiler or interpreter handles some pieces of code better than others. Sometimes,
    it is because it's designed and targeted for best performance on the most common
    scenarios. At other times, it's just because of how the language treats some entities,
    such as functions, types of variables, or some loops. Because of all this, knowing
    how the interpreter treats some code patterns is important.
  prefs: []
  type: TYPE_NORMAL
- en: What are patterns?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Patterns are not libraries or classes. They're concepts—reusable solutions to
    common programming problems, tested and optimized for specific use cases. As they're
    just concepts meant to solve specific problems, they have to be implemented in
    your language. Every pattern has its advantages and disadvantages, and choosing
    a wrong pattern for a problem can cause you a big headache.
  prefs: []
  type: TYPE_NORMAL
- en: Patterns can speed up the development process because they provide well-tested
    and well-proven development paradigms. Reusing patterns helps prevent issues and
    improves code readability between developers who are familiar with them.
  prefs: []
  type: TYPE_NORMAL
- en: Patterns have a lot of importance in high-performance applications. Sometimes,
    in order to achieve some flexibility, patterns introduce a new level of indirection
    in the code, which may reduce performance. You should choose when to introduce
    a pattern and know when that introduction will hurt the performance metric that
    you're targeting.
  prefs: []
  type: TYPE_NORMAL
- en: 'Knowing good patterns is essential in order to avoid the opposite—anti-patterns.
    An anti-pattern is a solution to a recurring problem that is both ineffective
    and counterproductive. Anti-patterns are not specific patterns but more like common
    errors. They are seen by the majority of mature developers/community as strategies
    that you shouldn''t use. Some of the most common and frequent anti-patterns seen
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Repeating yourself**: Don''t repeat excessive parts of the code. Lean back,
    look at the big picture, and refactor it. Some developers tend to look at this
    refactoring as a complexity of the application, but it can actually make your
    application simpler. If you think you won''t be able to understand the simplicity
    of your refactoring, don''t forget to add a couple of introductory comments to
    the code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Golden hammer or silver bullet**: Specifically in the Node.js ecosystem,
    and thanks to NPM, there are literally thousands of modules available out there.
    Don''t reinvent the wheel. Invest your time in using the most common modules for
    your needs, and avoid recreating them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Coding by exception**: Your code should handle all types of common errors.
    If the application is well planned, this accidental complexity should be avoided,
    as it won''t bring anything new to the application. Avoid coding for every type
    of error, handle the most common ones, and default to the most general error.
    This does not mean that you shouldn''t record the error in your backend. Do this
    so that you can analyze it later, but avoid handling all types of errors. This
    decreases your code maintenance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Programming by accident**: Don''t program by trial and error. Success in
    this method is pure luck and a question of odds. This is something you should
    really avoid. Programming by accident can make your code work in some cases, but
    have erroneous behavior in unplanned situations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Node.js patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Because of the structure and API model of the Node.js platform, some patterns
    are more biased or natural. The most obvious are the event-driven and the event
    stream patterns. They're not enforced but strongly engrained in the core API,
    and you're forced to use it in some parts of your application, so it's better
    to know how they work individually, how they work together, and how you can benefit
    from them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the core API, you can access the filesystem, for example, to read a file
    with a single method and a callback; or you can request a read stream and then
    check the data and end events or pipe the stream to somewhere else. This is very
    useful when, say, you don''t want to look at the file and just want to serve it
    to a client. This architecture was designed to work for core modules such as `http`
    and `net`. Similarly, when listening for client connections, you''ll have to listen
    for a connection event (unless you have defined a connection listener during socket
    creation) and then listen for data and end events for each connection. Remember
    not to ignore error events as they trigger exceptions if not listened and will
    force your application to stop. Events are the core feature of the Node.js platform:'
  prefs: []
  type: TYPE_NORMAL
- en: Streams are also present, and one might think they're two distinct things, but
    they're not. Every stream is an extension of an event emitter. In the most basic
    form, a stream is a process of emitting data events with content from some kind
    of buffer. Events, streams, and buffers together make a very good example of an
    event-driven architecture—a pattern that goes very well with the JavaScript language.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Streams of different types might be connected to each other, especially when
    sharing common data and end events. It's very common to use an `fs` stream and
    pipe it to an `http` stream. This usability enables the developer to avoid unnecessary
    memory allocations in the application and just pass the task to the platform.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Events enable a loose coupling between application components, enabling it to
    change and evolve without a strict connection between the components emitting
    events and the ones listening to them. As a downside, there are some edge cases
    to look out for, such as losing an emitted event because we were not listening,
    or leaking memory because of forgetting to stop listening for events that no longer
    exist.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Buffers are objects that you should use when manipulating data that might get
    broken with strings because of the string encoding. They're used by the platform
    to read files and write data to sockets. Many string manipulation functions are
    available for buffers to use.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Types of patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Your application won't be using only the core API. In a complex application,
    you will be using a lot of other modules, some made by you and others that you
    simply downloaded. Patterns exist everywhere in your application. When you use
    a module and you need to create a different interface, you would be using the
    adapter pattern, a structural pattern. If you need to extend the module you just
    downloaded with a couple of functionality methods, you can use the decorator pattern,
    another structural pattern. When the downloaded module might need some complex
    information to initialize, you may want to use the Factory pattern, a creational
    pattern. If your application evolves and this initialization needs more flexibility,
    you'll be using the Builder pattern, another creational pattern. If your application
    accesses relational data, you might have to use the Active Record pattern. If
    you use some kind of software framework, you might be using the MVC pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Many developers don't notice that they're using some of these patterns. It's
    important to know them and especially to know the problems that some patterns
    have in some contexts. In order to be able to analyze and test these patterns,
    they're categorized into several types. Let's see some of these types and some
    of the most common patterns for every type.
  prefs: []
  type: TYPE_NORMAL
- en: Architectural patterns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An architectural pattern is the pattern that is usually implemented inside
    software frameworks. These solve common problems found across most applications.
    They avoid code duplication by creating some kind of layer to common broader problems.
    This image is a description of the Front Controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Architectural patterns](img/4183_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The **Front Controller** pattern, most commonly seen in web applications, is
    the case where a unique controller handles all incoming requests. This is achieved
    by having a single entry point that loads common libraries, such as data access
    and session management, and then loads the specific controller for each request.
    This is a very common practice, as the alternative—having several entry points
    for different actions—would substantially increase and duplicate code, making
    the application more complex to manage and maintain.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Present in most frameworks, this pattern allows your application to grow with
    different modules without duplicating unnecessary code. It has a central point
    that can handle many common tasks, such as database access, session management,
    access logging and error logging, generic access, authorization and accounting,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: This pattern is essential in any well-structured application, as it substantially
    reduces repeated code by forcing a common part of your application to run first
    and perform every check that you need. It can also increase security; if you find
    any breach, it's easier to seal a single entry point than multiple entry points.
    Using a central point where your application can use all kinds of performance
    methods to give a better feeling of a responsive application also increases overall
    performance. The following image is a description of the MVC
  prefs: []
  type: TYPE_NORMAL
- en: '![Architectural patterns](img/4183_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The **Model-View-Controller** (**MVC**) pattern is a pattern that divides an
    application component into three parts: a model, a view, and a controller (hence
    the name). The model is your data structure, or your information logic. This can
    be, for example, one or more tables in a relational database. The view is a visual
    representation, usually the user interface. It can be graphical or text-based.
    It''s a representation of your model in a way that the user can see and manipulate.
    The controller is the part responsible for actually manipulating your model—sometimes
    directly updating the view—as per the actions in the view made by the user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are many variations of this pattern and you should choose the one that
    fits your task and language best. Some of these variations are **Model-View-ViewModel**
    (**MVVM**) and **Model-View-Adapter** (**MVA**), which try to decouple the view
    from the model, causing the model to be not necessarily aware of the view. This
    makes it possible to have several views of the same model.
  prefs: []
  type: TYPE_NORMAL
- en: The main purpose of this pattern is to clearly separate what the user sees (the
    view, or the design) from the programming logic (the model). This is important
    in order for designers to be able to change the view without affecting the logic.
    Also, developers can fix the logic without breaking the design. This pattern is
    essential if you consider yourself at least an intermediate developer. This is
    because, more than a pattern, it is considered an essential practice.
  prefs: []
  type: TYPE_NORMAL
- en: '![Architectural patterns](img/4183_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The **Active Record** pattern is an abstraction layer used to access relational
    databases by providing a simple data object. Manipulating this object can trigger
    changes in the database without the developer needing to know what type of database
    is behind the application. Normally, a table or view in the database is mapped
    to a class, and instances are mapped to rows. Usually, foreign keys are handled
    by referencing instances. Logic can be given to the data objects for common application
    tasks, for example, to calculate a full name based on two different table columns,
    such as the first name and last name. This, altogether, gives a better approach
    to the business logic, making it possible to have your data as well as an extra
    layer on the top extending it to match the projected behavior of the application.
    The pattern is normally used in **object-relational mapping** (**ORM**) libraries
    that extend the functionalities to new levels. An example of this is the possibility
    to have two or more different places of your application referencing the same
    row in the database and (without knowing) having the same referenced data object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This pattern is criticized mainly because of two aspects. The first is that
    there is an abstraction layer between application and data, which can decrease
    performance substantially and improve memory leaks in data-intensive applications.
    Another aspect is the testability; the tight coupling between the data object
    and database makes it difficult to have a real database for proper testing.
  prefs: []
  type: TYPE_NORMAL
- en: '![Architectural patterns](img/4183_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The **Service Locator** pattern is the concept of abstracting access to a service
    by the use of a central registry, called the service locator, that allows services
    to register and get to know each other's access methods. Although this pattern
    involves adding an extra layer between the components of an application, it can
    give adaptation and scalability to it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are a couple of advantages to this approach, the most important being
    the possibility to adapt to the workload. The service locator can control access
    to the registered services and, if you have several instances of the same service
    spread across servers, this locator can rotate access to every one of the instances,
    making it possible to add more instances of the same service and handle more load.
    Another great advantage is the possibility to unregister services and register
    new ones with better performance or bug fixes, giving you the possibility to keep
    zero downtime.
  prefs: []
  type: TYPE_NORMAL
- en: Not everything is good news, however; there are some disadvantages that have
    to be weighted. The service locator can potentially become a single point of failure,
    which is something that no one wants. Security is also important, and service
    registration must be handled with caution to prevent outsiders from hijacking
    the registry. Also, as services are decoupled from the service locator and the
    application, they act as black boxes and it might get harder to handle errors
    and recover from them.
  prefs: []
  type: TYPE_NORMAL
- en: '![Architectural patterns](img/4183_02_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The **Event-driven** pattern is a pattern that promotes production and consumption
    of events. This architecture forces the programming logic to react to events.
    An event is a state change, for example, when a network connection is established,
    data arrives, or a file handle is closed. An object that needs to be notified
    of an event (called a consumer) registers (listens) for an event in an appropriate
    event emitter object (the producer). When this object detects state changes related
    to it, it notifies (emits) the events to the consumers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Events can have data information. For example, if a file reader object is an
    event emitter, it will probably notify consumers when the respective file is opened,
    when it has data from the file (whether it is complete or not), when the file
    is closed (no more data), and if any error occurs eventually (no access permission
    or filesystem being two examples). The data event could eventually get the file
    itself and the error event should get the associated error.
  prefs: []
  type: TYPE_NORMAL
- en: Building applications around this pattern usually makes them more responsive
    because these systems are, by design, targeted at unpredictable and asynchronous
    environments, which exist in the case of any system that uses the network or the
    filesystem. This architecture is extremely loosely coupled, as an event can be
    almost anything and anywhere, making this pattern scalable and distributable.
  prefs: []
  type: TYPE_NORMAL
- en: Frameworks with this pattern normally allow developers to create their own products,
    the event emitters, with custom events and data, extending the core functionality
    and making it possible to make the entire application event-driven.
  prefs: []
  type: TYPE_NORMAL
- en: Creational patterns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Creational patterns are the patterns that developers use when creating new
    data or objects. These patterns give your application the flexibility to choose
    when to instantiate new objects or reuse current ones. In this type of pattern,
    you can find some of the patterns that are described as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creational patterns](img/4183_02_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The **Factory** method pattern is used to abstract the application from specific
    classes. It is used to create new objects. In this pattern, a method is called,
    a new (or reused) object is returned, and the logic of the creation (if needed)
    is handled by another subclass. This pattern is specifically useful when the component
    that needs to create the new object might not have all of the necessary information
    (for example, database information) Another use case is when this object is reused
    across components, the code necessary to create the object might be too complex,
    and duplication of many pieces of code may be required. Again, a database connection
    or another data information service access is a good case for this pattern.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Lazy initialization** pattern is when you delay the creation of an object
    or the calculation of a complex expression. This is also called lazy loading.
    This pattern is usually seen with the factory method when you save an instance
    after you call some factory function so that you can later return that very instance
    when the function is called again. This is another way of getting a singleton.![Creational
    patterns](img/4183_02_06.jpg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Singleton** pattern is used when a single object instance is required
    or desired for your application to work efficiently. This pattern is usually made
    in the class itself, where the developer of the class creates a method to create
    a new instance, and if an instance was previously created, it is returned instead.
    It can also appear inside the Factory pattern, where the application might have
    a library for creating a database connection pool and would prefer that all the
    modules use the same pool instead of creating new ones. This is especially important
    for web applications where you want to avoid connecting to the database every
    time a request comes in. It is also used, for example, in the Active Record pattern,
    when the same row is needed by several components, and instead of returning different
    objects, the same object is returned.![Creational patterns](img/4183_02_08.jpg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Builder** pattern is a class that is responsible for creating new instances
    of other classes. This is similar to the Factory method pattern—more flexible
    but also more complex. A developer normally starts with the factory pattern and
    it evolves into this pattern. This is especially useful when abstracting a class
    with several constructing combinations, for example, when constructing a database
    query.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The classes behind the builder are usually complex, and the builder sometimes
    addresses this complexity by exposing simpler methods and evolving as the need
    arrives. It's a good pattern, where you can cascade or chain the methods to create
    a more fluent interface.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creational patterns](img/4183_02_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the **Object pool** pattern, a set of objects, called the pool, is kept ready
    for use by other components. This pattern is usually associated with connection
    pools and other operations that might involve significant initialization time.
    Usually, such pools are initialized at a lower value (reduced pool size) and grow
    as per the demand to a higher or limit value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This pattern is frequently used in database connections, as they may be expensive
    to create, considering connecting and authenticating. Always keeping a few connections
    alive drastically reduces the initialization time and improves performance.
  prefs: []
  type: TYPE_NORMAL
- en: Structural patterns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another type of pattern is the structural type. In this type, there are patterns
    that help in relationships and communication between components. These are commonly
    used to connect third-party modules together as a common interface. Examples of
    this type are described as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Structural patterns](img/4183_02_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The **Adapter** pattern is the most common pattern, where two components that
    are not compatible are connected by a common interface. One rule to distinguish
    this pattern from similar patterns is that the adapter that connects the two components
    should not have any logic and should only allow the two interfaces to connect
    in a new common interface.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This pattern shows up when you have two interfaces and one needs to be refactored,
    and the interface will change the methods. While you don't have to refactor the
    other interface, you'll need an adapter to keep your application running.
  prefs: []
  type: TYPE_NORMAL
- en: '![Structural patterns](img/4183_02_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The **Composite** pattern is used when a group of objects or a single object
    should be treated and accessed in the same way. This pattern should be used when
    components don''t know when accessing a group of objects or an individual object.
    It is particularly useful when the complexity of code that is meant to treat the
    two variations are: an element or a set of elements is not much. Examples of this
    pattern appear in jQuery and other libraries that treat groups of elements the
    same as a single element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An easy way of creating this pattern is by always assuming a group of objects.
    If the interface supports a group, it should be fairly easy to check the input
    and convert a single object into a group of objects before continuing. In this
    way, the user of the interface won't need to care about it. It's always a good
    pattern when you make your interfaces more tolerant to user input.
  prefs: []
  type: TYPE_NORMAL
- en: '![Structural patterns](img/4183_02_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The **Decorator** pattern is used when a functionality is added to an object
    without affecting the behavior of other objects of the same class. It is actually
    the base of prototypal inheritance, which is a fundamental principle of JavaScript.
    This is achieved by wrapping the object in another class, saving a reference to
    it, and adding the new functionality to the new class. You use this when a module
    you want to use does not have all of the functionality you want, and you decide
    to wrap it and give extra methods. This is an extension, or the next step, of
    the Adapter pattern. It's common that you find a module that almost fits your
    needs, but then you realize that there are one or two missing features, so instead
    of looking for another module (maybe because you're used to it already), you just
    decorate the first.![Structural patterns](img/4183_02_13.jpg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Facade** pattern is in place when you wrap a complex library in an interface
    easier to use and understand. Sometimes libraries become very versatile with many
    different options and this pattern is used when you create a less versatile but
    simpler interface to a complex library.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This pattern appears when a couple of repeating or complex tasks are common
    and you decide that it's better to have an interface to do it. It's not an adapter
    pattern since it's not an interface change; it's a simplified interface. You can
    see this if, for example, you have a class that understands and talks SMTP. You
    need to send an e-mail and prefer to have a single method to send a message than
    a log of complex methods of the original class.
  prefs: []
  type: TYPE_NORMAL
- en: '![Structural patterns](img/4183_02_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The **Proxy** pattern, normally used to simplify a more complex task, is a pattern
    where an object acts as a proxy to access something. It can be another object,
    a file, a folder, or some database information. This pattern is used, for example,
    to add a security layer to something else, as it can restrict how and when the
    application will access a specific resource. An example of this pattern is a REST
    interface to a service.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Behavioral patterns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Behavioral patterns are characterized by identifying communication patterns
    between objects. They classify kinds of behavior and how objects communicate.
    Some of the most common types are described as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Behavioral patterns](img/4183_02_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The **Mediator** pattern creates an abstraction layer, called the mediator,
    that handles communication with multiple classes. As your application becomes
    complex, the need for a mediator to lower the complexity of communication between
    classes arises. This mediator encapsulates communication with all the classes,
    reducing dependency and lowering coupling by keeping objects from interacting
    directly with each other. If your application is modular and different modules
    can be loaded at runtime, this can be called—kind of—your internal API.![Behavioral
    patterns](img/4183_02_16.jpg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Template** method pattern is used by several frameworks. It is usually
    a method that takes a set of options and compiles part of your information, leaving
    placeholders to some modifiable parts. This is used, for example, as a way of
    precompiling a graphic user interface view, leaving some placeholders, such as
    internationalization text, and eventually some code logic to be run later. This
    pattern is very effective when some part of the template doesn't change, reducing
    the time to compile from the template every time it's needed. This is also a typical
    example of **Inversion of Control**, where it's the template that can call parts
    of your application instead of your application calling the methods of the template.![Behavioral
    patterns](img/4183_02_17.jpg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Observer** pattern maintains a list of dependents, called observers, and
    notifies them of the changes by calling a method provided by each dependent. This
    is commonly called an event system, and it's used in event-driven architectures,
    such as Node.js. This pattern is very effective and useful in asynchronous programming.
    On the other hand, if not properly used, it can cause memory leakage when an event
    listener is not properly deregistered and the observer keeps a strong reference
    to it, preventing garbage collection from disposing it (the lapsed listener problem).
    This pattern is heavily used by the Node.js platform and it is essential that
    you embrace and understand it if you want to create a performant application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Event-driven architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Developing in Node.js is no different from other languages. You have some more
    or less native patterns, widely adopted and fully supported. One very common pattern
    is **event-driven architecture**. This pattern promotes production and consumption
    of events. This means that your code should be reactive to events instead of constantly
    trying to detect changes. Usually, many listeners can consume an event. There
    are some variations, such as having a way of stopping the event propagation or
    only allowing the first listener to consume the event, but normally all listeners
    will be able to consume all the events that they're listening to.
  prefs: []
  type: TYPE_NORMAL
- en: This pattern is very effective when you need to communicate inside your application
    in a *one to many* module of your code, as it gives you a very lose coupling.
    This is specifically interesting in **service-oriented architecture** (**SOA**)
    as it ensures your application components (your services) remain loosely coupled
    and can be upgraded over time without affecting other services. Imagine you have
    an application with many services attached and a service called **Sessions**,
    responsible for managing user sessions, creating them, and destroying them. This
    service may eventually produce events when sessions change. In this way, other
    services may listen for the events and act accordingly. This means that a service
    that only wants to know when sessions are created can, for example, just listen
    for the create event, and another service that only needs to know when they're
    destroyed can listen only for that specific event. Other services can then be
    added without having to change much of your application. This is also good for
    somehow creating a boundary between services when, for example, you don't want
    to trust third-party services.
  prefs: []
  type: TYPE_NORMAL
- en: There are some related patterns—sort of variations of this pattern. One widely
    used pattern is the publish-subscribe pattern. One widely used and very similar
    pattern is the publish-subscribe pattern. Instead of events, you have messages;
    instead of listeners, you have subscribers; and instead of event emitters, you
    have publishers. The main advantage of this pattern is that it's usually implemented
    to work using the network layer, and so it can be used by services to communicate
    with each other over the Internet. However, this pattern is actually not that
    simple and can get quite complex compared to Node.js core events, as it allows
    message filtering, in which subscribers can decide what kind of messages they
    want to receive based on message attributes.
  prefs: []
  type: TYPE_NORMAL
- en: Usually, this pattern involves a third element, which is responsible for accepting
    publisher messages and delivering them to subscribers. This element can possibly
    scale and allow a more distributed architecture. On the other hand, as it decouples
    publishers and subscribers, publishers can lose the ability to know who is subscribed
    to which channels. Also, be aware of the message delivery, because the network
    layer can introduce many complications and slow down your workflow. This is not
    something you would want to depend on.
  prefs: []
  type: TYPE_NORMAL
- en: 'An event-driven architecture allows you to create an application in which the
    flow of information is determined by events. This is great but there are two things
    you shouldn''t forget:'
  prefs: []
  type: TYPE_NORMAL
- en: Be careful not to create a kind of deadlock when your flow is expecting an event
    and it's never triggered or you've registered to listening too late. Usually,
    this is not fatal to your application, usually, this is not fatal to your application
    as you're not blocked waiting for the event, but your application will be in an
    intermediate state from where it can't get out and will probably be leaking memory.
    From the user perspective, your application is failing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Always handle errors gracefully; don't ignore them. Core modules such as `http`
    and `net` throw exceptions when you don't properly handle error events. This means
    that an uncaught exception will be triggered and your application will stop fatally.
    You're not listening and ignoring uncaught exceptions, right?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Overall, this is a nice generic pattern that fits perfectly into the Node.js
    platform, and is very handy when you need to communicate between several parts
    of your application. Also, the language itself, JavaScript, handles this pattern
    quite well by supporting anonymous functions, called closures.
  prefs: []
  type: TYPE_NORMAL
- en: Streams
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You might have noticed that events and streams are somehow related in Node.js.
    This is not by accident; it helps make a great workflow that is simple to understand
    and adapt. Streams use events to inform consumers about the data available for
    consumption and when the data reaches an end.
  prefs: []
  type: TYPE_NORMAL
- en: 'One way of looking at streams is to look as if they were Unix pipes ([https://en.wikipedia.org/wiki/Pipeline_(Unix)](https://en.wikipedia.org/wiki/Pipeline_(Unix))).
    The goal is to be as useful as piping data across commands to read data, process
    it, transform it, and then output it. Streams are a fast and easy interface for
    creating readable, writable, duplex, and transform streams. Let''s look at the
    different types of streams, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**readable**: This is, for example, a file parser that reads some kind of format,
    such as CSV, and emits data events for each line. This stream can be piped to
    other types of streams. A readable stream can be in flowing mode, which means
    that data is piped as it becomes available at the source, and the paused mode
    where data has to be fetched manually when needed (and if available).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**writable**: Writing to a file or responding to a client are examples of this
    type of stream. Other examples are data compression streams (`zlib`) and cipher
    streams (`crypto`). This stream writes data to the destination and informs of
    its progress. It can also handle what it''s called back pressure, when data is
    being written to the stream and it''s not being handled in the opposite side,
    forcing the stream to keep data in memory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**duplex**: This is both a readable and writable stream, as it handles both
    the source and the destination. Examples of this type are sockets and, again,
    compression and cipher streams, depending on the objective.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**transform**: This stream is an extension of a duplex stream where you perform
    some kind of data transformation between the source and the destination. Compressing
    data is a good example of this type, but so is converting data between different
    formats.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Buffers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another important piece of the puzzle in the Node.js platform is the buffer.
    Since JavaScript strings are encoded in Unicode, binary data might get scrambled
    in the process. Buffers are an alternative to manipulating binary data. As a bonus,
    you get several methods to read and write numbers in different sizes, whether
    big or little endian.
  prefs: []
  type: TYPE_NORMAL
- en: Because of binary compatibility, the core modules use buffers in stream data
    events. Streaming a file to a client or receiving a file from a client and writing
    it to the disk is as simple as piping streams. And they just work because they
    pass buffers to each other.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using patterns improves your application, as you use well-proven and well-tested
    concepts that help developers to better understand and eventually improve your
    code. But improving your code doesn't end here. There is another type of pattern
    that varies from language to language, and we call it optimization.
  prefs: []
  type: TYPE_NORMAL
- en: An optimization is a pattern that is not specific to any problem but specific
    to a code structure. The idea is to change the code to be more efficient or to
    use less memory or other types of resources while doing the same thing. The goal
    of an optimization is not to get simpler code or to make it more readable. It
    can be bigger but still readable. Don't optimize for the sake of optimizing and
    reducing your code readability.
  prefs: []
  type: TYPE_NORMAL
- en: As Node.js uses the V8 engine as the language processor, we have to use V8-specific
    optimizations in the code. Some optimizations work across versions, others not
    so much and the effort of optimizing might be worthless. This is because V8 is
    constantly improving and Node.js platform ships new versions with every release,
    so an optimization that was good yesterday because of bad performance of V8 on
    some aspect might not be worthwhile tomorrow when V8 fixes that performance issue.
    Now let's take a look at some optimizations that are worth noting.
  prefs: []
  type: TYPE_NORMAL
- en: Hidden types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'JavaScript has dynamic type. This means that a variable has a type that is
    dynamic, and so it can change from, say, a number to a string and vice-versa.
    This feature is hard to optimize at compile time, and V8 has a feature called
    **hidden types** where it shares optimizations between objects of the same type.
    For example, when you create an object using the `new` keyword, if every instance
    of the object does not undergo changes in its prototype, they all share the same
    hidden type and will use the same optimized code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This might not be achievable for complex objects, but for simpler objects, you
    can enforce it by just setting the properties in the constructor and then sealing
    the object to avoid any more changes.
  prefs: []
  type: TYPE_NORMAL
- en: Numbers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Again, since JavaScript has dynamic type, the numbers can change the type.
    The compiler will try to infer the type, and as soon as it knows it, it will tag
    the variable to that type in order to be able to perform operations with other
    variables. Changing the type after that is possible but expensive, so it''s better
    to avoid changing number types. More specifically, avoid getting in and out of
    the 31-bit signed integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Arrays can have a variable length; it is changeable over time. For handling
    this, the compiler has some internal types for each specific type of Array, and
    switching between these types is not desirable. Arrays should have contiguous
    keys, starting from zero. Avoid deleting elements in the middle and accessing
    elements you didn''t initialize before. Similar to numbers, you should keep your
    Array elements in the same type. Also, if you know the size of an Array, you should
    point it out in the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In this specific example, it would be better to initialize all the elements
    up front to allow the compiler to know the hidden type before creating it, instead
    of inferring it twice.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Functions inherit from objects, and so the hidden types apply here too. Polymorphic
    functions will degrade performance substantially. If you want the best performance
    possible, create a separate function for every constructor you need:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, some uses of `arguments` are a performance killer. Avoid reassigning
    them (for example, when undefined). Instead, use another variable. You should
    only use arguments to check arguments length and look at a valid index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The for-in loops
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are some performance penalties when using evaluating code in runtime
    is another feature loop, and for the best performance possible, you should avoid
    it and use a normal `for` loop. The performance penalty comes from edge cases
    where the compiler just can''t optimize. Always use `Object.keys` to get a list
    of keys in an object and then iterate that list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The infinite loops
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You should never create an infinite loop (`while (true) {}` or `for (;;) {}`).
    This is a rule of even greater importance for performance code. It's very hard
    to optimize an infinite loop, and it is preferable to refactor your code and review
    your logic.
  prefs: []
  type: TYPE_NORMAL
- en: The try-catch blocks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The try-catch blocks are important in order to be able to capture exceptions,
    but in an asynchronous architecture, they can be a bit less important. The compiler
    has difficulty in optimizing the scope inside try-catch, so you should try to
    move as much of your code out of the statement as you can.
  prefs: []
  type: TYPE_NORMAL
- en: Eval
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Eval is another feature avoidable at all costs, as any function scope with an
    `eval` call will make the function unoptimizable. Never use this feature unless
    you really need it, and if you need it, put it in the smallest function possible.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Downloading the example code**'
  prefs: []
  type: TYPE_NORMAL
- en: You can download the example code files from your account at [http://www.packtpub.com](http://www.packtpub.com)
    for all the Packt Publishing books you have purchased. If you purchased this book
    elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Developing should be a great experience. Performant applications require some
    restrictions on how they are designed and developed. Knowing most of the common
    patterns helps choose wise paths for your application and avoids some performance
    penalties in the future. However, patterns are not all, and a solid understanding
    of what's behind the Node.js platform really helps you reach a few levels up on
    the performance scale.
  prefs: []
  type: TYPE_NORMAL
- en: Even after choosing good patterns and doing the best at developing using some
    of the optimizations tips described in this chapter, the application can perform
    poorly on some scenarios. Don't optimize unless you need it. Follow the patterns
    and the tips, but don't think excessively about it until you test your application
    performance and realize that you need to optimize it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Prepared for Bentham Chang, Safari ID bentham@gmail.com User number: 2843974
    © 2015 Safari Books Online, LLC. This download file is made available for personal
    use only and is subject to the Terms of Service. Any other use requires prior
    written consent from the copyright owner. Unauthorized use, reproduction and/or
    distribution are strictly prohibited and violate applicable laws. All rights reserved.'
  prefs: []
  type: TYPE_NORMAL
