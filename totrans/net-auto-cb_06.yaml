- en: Administering a Multi-Vendor Network with NAPALM and Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Network Automation and Programmability Abstraction Layer with Multivendor
    support** (**NAPALM**), as the name implies, is a multi-vendor Python library
    intended to interact with different vendor equipment, and it provides a consistent
    method to interact with all these devices, irrespective of the vendor equipment
    used.'
  prefs: []
  type: TYPE_NORMAL
- en: In previous chapters, we have seen how to interact with different network devices
    using Ansible. However, for each vendor OS, we had to use a different Ansible
    module to support that specific OS. Furthermore, we saw that the data returned
    from each vendor OS is completely different. Although writing a playbook for multi-vendor
    devices is still possible, it requires the use of multiple different modules,
    and we need to work with the different data structures returned by these devices.
    This is the main issue that NAPALM tries to address. NAPALM attempts to provide
    an abstracted and consistent API to interact with multiple vendor OSes, while
    the data returned by NAPALM from these different vendor OSes is normalized and
    consistent.
  prefs: []
  type: TYPE_NORMAL
- en: 'NAPALM interacts with each device according to the most common API supported
    by this node, and the API that is widely adopted by the community. The following
    diagram outlines how NAPALM interacts with the most common network devices, as
    well as the libraries used in NAPALM to interact with the APIs on these devices:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/5b2f5635-b0ce-4775-bbf9-ecfb6f8b6664.png)'
  prefs: []
  type: TYPE_IMG
- en: Since NAPALM tries to provide a consistent method to interact with network equipment,
    it supports a specific set of vendor devices. NAPALM also supports the most common
    tasks that are carried out on these devices, such as device configuration, retrieving
    the operational state for interfaces, **Border Gate Protocol** (**BGP**) and **Link
    Layer Discovery Protocol** (**LLDP**), and many others. For more information regarding
    the supported devices, as well as the supported methods when interacting with
    these devices, please check the following link: [https://napalm.readthedocs.io/en/latest/support/index.html](https://napalm.readthedocs.io/en/latest/support/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will outline how to automate a multi-vendor network using
    NAPALM and Ansible. We will outline how to manage the configuration of these different
    vendor OSes, as well as how to retrieve the operational state from these devices.
    We will base our illustration on the following sample network diagram of a basic
    service provider network:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/15260437-25fd-4d1c-b43f-ff366996233c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following table outlines the devices in our sample topology and their respective
    management **Internet Protocols** (**IPs**):'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Device** | **Role** | **Vendor** | **Management (MGMT) Port** | **MGMT
    IP** |'
  prefs: []
  type: TYPE_TB
- en: '| `mxp01` | P Router | Juniper vMX 14.1 | `fxp0` | `172.20.1.2` |'
  prefs: []
  type: TYPE_TB
- en: '| `mxp02` | P Router | Juniper vMX 14.1 | `fxp0` | `172.20.1.3` |'
  prefs: []
  type: TYPE_TB
- en: '| `mxpe01` | PE Router | Juniper vMX 14.1 | `fxp0` | `172.20.1.4` |'
  prefs: []
  type: TYPE_TB
- en: '| `mxpe01` | PE Router | Juniper vMX 17.1 | `fxp0` | `172.20.1.5` |'
  prefs: []
  type: TYPE_TB
- en: '| `xrpe03` | PE Router | Cisco XRv 6.1.2 | `Mgmt0/0/CPU0/0` | `172.20.1.6`
    |'
  prefs: []
  type: TYPE_TB
- en: 'The main recipes covered in this chapter are shown in the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing NAPALM and integrating with Ansible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building an Ansible network inventory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting and authenticating to network devices using Ansible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building the device configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying configuration on network devices using NAPALM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collecting device facts with NAPALM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validating network reachability using NAPALM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validating and auditing networks with NAPALM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code files for this chapter can be found here: [https://github.com/PacktPublishing/Network-Automation-Cookbook/tree/master/ch6_napalm](https://github.com/PacktPublishing/Network-Automation-Cookbook/tree/master/ch6_napalm).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following software will be required in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Ansible machine running CentOS 7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ansible 2.9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Juniper **Virtual MX** (**vMX**) router running Junos OS 14.1R8 and Junos OS
    17.1R1 release
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cisco XRv router running IOS XR 6.1.2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Check out the following video to see the Code in Action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://bit.ly/2Veox8j](https://bit.ly/2Veox8j)'
  prefs: []
  type: TYPE_NORMAL
- en: Installing NAPALM and integrating with Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we outline how to install NAPALM and integrate it to work with
    Ansible. This task is mandatory since NAPALM Ansible modules are not part of the
    core modules that are shipped with Ansible by default. So, in order to start working
    with these modules, we need to install NAPALM and all of its Ansible modules.
    Then, we need to inform Ansible of where to find it and start working with the
    specific modules developed by the NAPALM team for Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible and Python 3 need to be installed on the machine, along with the `python3-pip`
    package, which we will use to install NAPALM.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Install the `napalm-ansible` Python package, as shown in the following code
    snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the `napalm-ansible` command, as shown in the following code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'To ensure Ansible can use the NAPALM modules you will have to add the following
    configurtion to your Ansible configuration file (`ansible.cfg`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: For more details on Ansible's configuration file, visit [https://docs.ansible.com/ansible/latest/intro_configuration.html](https://docs.ansible.com/ansible/latest/intro_configuration.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new folder called `ch6_napalm` and create the `ansible.cfg` file,
    updating it as shown in the following code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since the NAPALM package and corresponding NAPALM Ansible modules are not part
    of the core modules shipped and installed by default with Ansible, we need to
    install it on the system in order to start working with the NAPALM Ansible modules.
    The NAPALM team has shipped a specific Python package to install NAPALM along
    with all the Ansible modules and all the dependencies, in order to start working
    with NAPALM from inside Ansible. This package is `napalm-ansible`. We will use
    the `pip3` program to install this package since we are using Python 3.
  prefs: []
  type: TYPE_NORMAL
- en: In order to tell Ansible where the Ansible module is installed, we need to enter
    the path for these modules into Ansible. The NAPALM team also provides simple
    instruction on how to find the path where the NAPALM modules are installed, and
    how to integrate it with Ansible via the `napalm-ansible` program. We execute
    the `napalm-ansible` command, which outputs the required configuration that we
    need to include in the `ansible.cfg` file so that Ansible can find the NAPALM
    modules that we will be using.
  prefs: []
  type: TYPE_NORMAL
- en: We update the `ansible.cfg` file with the output that we obtained from the `napalm-ansible`
    command. We then update the library and action plugin options, which tell Ansible
    to include these folders in its path when it is searching for modules or action
    plugins. In the `ansible.cfg` file, we include the normal configuration that we
    used before in the previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Building an Ansible network inventory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will outline how to build and structure our Ansible inventory
    to describe our sample service provider network setup outlined in this chapter.
    Building an Ansible inventory is a mandatory step, in order to tell Ansible how
    to connect to the managed devices. In the case of NAPALM, we need to sort the
    different nodes in our network into the correct vendor types supported by NAPALM.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Inside the new folder (`ch6_napalm`), we create a `hosts` file with the following
    content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We built the Ansible inventory using the `hosts` file, and we defined multiple
    groups in order to segment our infrastructure, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We created the `PE` group, which references all the **Multiprotocol Label Switching**
    (**MPLS**) **Provider Edge** (**PE**) nodes in our topology.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We created the `P` group, which references all the MPLS **Provider** (**P**)
    nodes in our topology.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We created the `junos` group to reference all the Juniper devices in our topology.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We created the `iosxr` group to reference all the nodes running IOS-XR.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Segmenting and defining groups per vendor or per OS is a best practice when
    working with NAPALM since we use these groups to specify the required parameters
    needed by NAPALM to identify the vendor of the remotely managed node, and how
    to establish network connectivity with this remote node. In the next recipe, we
    will outline how we will employ these groups (`junos` and `iosxr`), and which
    parameters we will include in order for NAPALM to establish a connection to the
    remotely managed nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting and authenticating to network devices using Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will outline how to connect to both Juniper and IOS-XR nodes
    using Ansible, in order to start interacting with the devices.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to follow along with this recipe, an Ansible inventory file should
    be constructed as per the previous recipe. Also, IP reachability between the Ansible
    control machine and all the devices in the network must be configured.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'On the Juniper devices, configure the username and password, as shown in the
    following code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'On the Cisco IOS-XR devices, configure the username and password, as shown
    in the following code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Enable the **Network Configuration Protocol** (**NETCONF**) on the Juniper
    devices, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'On the IOS-XR devices, we need to enable **Secure Shell** (**SSH**), as well
    as enable `xml-agent`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'On the Ansible machine, create the `group_vars` directory in the `ch6_napalm` folder,
    and create the `junos.yml` and `iosxr.yml` files, as shown in the following code
    block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Under the `group_vars` folder, create the `all.yml` file with the following
    login details:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: NAPALM uses a specific transport API for each vendor equipment supported by
    NAPALM. It uses this API in order to connect to the device, so in our sample topology,
    we need NETCONF to be enabled on the Juniper devices. For Cisco IOS-XR devices,
    we need to enable SSH, as well as enabling the XML agent on the IOS-XR devices.
  prefs: []
  type: TYPE_NORMAL
- en: The username/password used on the Ansible control machine to authenticate with
    the devices must be configured on the remote nodes. We perform all these steps
    on the devices in order to make them ready for NAPALM to communicate with them.
  prefs: []
  type: TYPE_NORMAL
- en: Using the legacy `xml agent` on the IOS-XR devices in production is not recommended
    and needs to be evaluated as per the Cisco documentation. For further details,
    refer to [https://www.cisco.com/c/en/us/td/docs/routers/asr9000/software/asr9k_r5-3/sysman/command/reference/b-sysman-cr53xasr/b-sysman-cr53xasr_chapter_01010.html](https://www.cisco.com/c/en/us/td/docs/routers/asr9000/software/asr9k_r5-3/sysman/command/reference/b-sysman-cr53xasr/b-sysman-cr53xasr_chapter_01010.html).
  prefs: []
  type: TYPE_NORMAL
- en: On the Ansible machine, we set the `ansible_connection` parameter per each vendor
    ( `netconf` for `juniper` and `network_cli` for `iosxr`), and we specify the `ansible_network_os` parameter
    to designate the vendor OS. All these parameters are defined under the `group_vars`
    hierarchy in `junos.yml` and `iosxr.yml`, corresponding to the groups that we
    defined in our inventory for grouping the devices on vendor OS basics. Finally,
    we specify the username and password via `ansible_user` and `ansible_ssh_pass`
    in the `all.yml` file, since we are using the same user to authenticate to both
    Juniper and Cisco devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test and validate that, we can communicate with the devices from the Ansible
    control machine using the Ansible `ping` module, as shown in the following code
    block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Building the device configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: NAPALM doesn't provide declarative modules to configure the various system parameters
    on the managed devices, such as interfaces' BGP, **Quality of Service** (**QoS**),
    and so on. However, it provides a common API to push text-based configuration
    to all the devices, so it requires the configuration for the devices to be present
    in text format in order to push the required configuration. In this recipe, we
    will create the configuration for all our devices. This is the configuration that
    we will push to our devices using NAPALM, in the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a prerequisite for this recipe, an Ansible inventory file must be present.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a `roles` folder, and inside this folder, create a new role called `build_router_config`,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the exact same contents (Jinja2 templates and tasks) for the `build_router_config`
    role that we developed for Juniper devices in [Chapter 3](5e423ab2-1c5d-430d-a02d-7838c39c931a.xhtml),
    *Automating Juniper Devices in the Service Providers Using Ansible*, to generate
    the configuration for the devices. The directory layout should be as shown in
    the following code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new folder called `iosxr` under the `templates` folder and populate
    it with the Jinja2 templates for the different IOS-XR configuration sections,
    as shown in the following code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the `group_vars/all.yml` file with the required data to describe our
    network topology, as shown in the following code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a specific directory for each host in the `host_vars` directory, and
    in each directory, create the `bgp.yml` file with the following BGP peering content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new playbook called `pb_napalm_net_build.yml` that utilizes the `build_router_config`
    role in order to generate the device configuration, as shown in the following
    code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, our main goal is to create the device configuration that we
    will deploy on the devices in our sample topology. We are using the same Ansible
    role that we used to generate the configuration for Juniper devices in [Chapter
    3](5e423ab2-1c5d-430d-a02d-7838c39c931a.xhtml), *Automating Juniper Devices in
    the Service Providers Using Ansible*. The only addition to this role is that we
    are adding the required Jinja2 templates for IOS XR.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a quick explanation of the steps, as a quick review:'
  prefs: []
  type: TYPE_NORMAL
- en: Modeling the network via Ansible variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We describe the different aspects of our network topology, such as **Peer-to-Peer** (**P2P**)
    interface, loopback interfaces, and **Open Shortest Path First** (**OSPF**) parameters
    under different data structures in the `group_vars/all.yml` file. For any host-specific
    data, we use the `host_vars` directory to populate all variables/parameters that
    are specific to a specific node, and, in our case, we use this approach for BGP
    data to outline `bgp_peers` variable for each node. This provides us with all
    the required data to populate the Jinja2 templates needed to generate the final
    configuration for each device in our sample network.
  prefs: []
  type: TYPE_NORMAL
- en: Building the Jinja2 templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We place all our Jinja2 templates in the `templates` folder inside our role,
    and we segment our Jinja2 templates per the vendor OS, each in a separate folder.
    Next, we create a Jinja2 template for each section of the configuration. The following
    code snippet outlines the directory structure for the templates folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: For a detailed explanation of the different Jinja2 templates used in this recipe
    and how they use the defined Ansible variables to generate the final configuration,
    please refer to [Chapter 3](5e423ab2-1c5d-430d-a02d-7838c39c931a.xhtml) of this
    book, *Automating Juniper Devices in the Service Providers Using Ansible*, since
    we are using the exact same network topology and the same data structures for
    both JunOS and IOS-XR devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running this playbook will generate the configuration for all the devices in
    our Ansible inventory in the `configs` folder, as shown in the following code
    block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Deploying configuration on network devices using NAPALM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will outline how to push configurations on different vendor
    devices using Ansible and NAPALM. NAPALM provides a single Ansible module for
    configuration management, and this module allows us to use a single common method
    to push any configuration on any vendor equipment supported by NAPALM, greatly
    simplifying Ansible playbooks.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To follow along with this recipe, you will need to have an Ansible inventory
    already set up, with network reachability between the Ansible controller and the
    network devices established. The configuration that we will be pushing to the
    devices is the one we generated in the previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Update the `pb_napalm_net_build.yml` playbook file, and add the tasks shown
    in the following code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As previously outlined, NAPALM provides a single Ansible module to push configurations
    to the network devices. It requires the configuration to be present in a text
    file. When it connects to the network device, it pushes the configuration to the
    respective device.
  prefs: []
  type: TYPE_NORMAL
- en: Since we are using a single configuration module that can be used across all
    the vendor OS devices supported by NAPALM, and since NAPALM uses a different connection
    API to manage the device, we need to tell the module the vendor OS for the device.
    We also need to provide the other parameters, such as username/password, to log
    in and authenticate with the device.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `napalm_install_config` module requires the following mandatory parameters
    in order to correctly log in to the managed device and push the configuration
    to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '`hostname`: This is the IP address through which we can reach the device. We
    supply the value of `ansible_host` for this parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`username/password`: This is the username and password to connect to the device.
    We need to supply the `ansible_user` and `ansible_ssh_pass` attributes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dev_os`: This parameter provides the vendor OS name that NAPALM requires in
    order to choose the correct API and the correct library to communicate with the
    device. For this option, we provide the `ansible_network_os` parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `napalm_install_config` module uses the following parameters to manage
    the configuration on remote devices:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`config_file`: This provides the path of the configuration file containing
    the device configuration that needs to be pushed to the managed device.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`commit_changes`: This tells the device whether or not to commit the configuration.
    NAPALM provides a consistent method for configuration commits, even for devices
    that don''t support it by default (for instance, Cisco IOS devices).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`replace_config`: This parameter controls how to merge between the existing
    configuration on the device and the configuration in the `config_file` parameter.
    In our case, since we are generating the whole device configuration and all the
    configuration sections are managed under Ansible, we replace the entire configuration
    with the configuration that we generate. This will cause any configuration on
    the device not present in our configuration file to be removed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As per the configuration outlined in this recipe, when we run the playbook
    using the `deploy` tag, NAPALM will connect to the device and push the configuration.
    However, it will not commit the configuration on the remote device, since we have
    specified the default value for `commit_changes` to be `no`. In case we need to
    push and commit the configuration on the remote device, we can set the value for
    the `commit` parameter to `yes` when running the playbook, as shown in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: There's more…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `napalm_install_config` module provides extra options to control how to
    manage the configuration on the remote devices, such as the configuration diff.
    With this option, we can collect the differences between the running configuration
    on the device and the configuration that we will push via NAPALM. This option
    can be enabled as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a folder called `config_diff` to store the configuration diff captured
    by NAPALM, as shown in the following code block:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the `pb_napalm_net_build.yml` playbook, as shown in the following code
    block:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Next, we create a new folder to house all the configuration diff files that
    we will generate for each device, and add the `diff_file` parameter to the `napalm_install_config`
    module. This will collect the configuration diff for each device and save it to
    the `config_diff` directory for each device.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we run the playbook again with a modified configuration on the devices,
    we can see that the `config_diff` files for each device are generated, as shown
    in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Collecting device facts with NAPALM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will outline how to collect the operational state from network
    devices using the NAPALM fact-gathering Ansible module. This can be used to validate
    the network state across multi-vendor equipment since NAPALM Ansible's fact-gathering
    module returns a consistent data structure across all vendor OSes supported by
    NAPALM.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To follow along with this recipe, it is assumed that an Ansible inventory is
    already in place and network reachability between the Ansible controller and the
    network is already established. Finally, the network is configured as per the
    previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create an Ansible playbook named `pb_napalm_get_facts.yml` with the following
    content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the playbook with the following tasks to validate the data returned
    by the NAPALM facts module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We use the `napalm_get_facts` Ansible module to retrieve the operational state
    from the network devices. We supply the same parameters (`hostname`, `username/password`,
    and `dev_os`) that we used with `napalm_install_config` to be able to connect
    to the devices and collect the required operational state from these devices.
  prefs: []
  type: TYPE_NORMAL
- en: In order to control which information we retrieve using NAPALM, we use the `filter`
    parameter and supply the required information that we need to retrieve. In this
    example, we are limiting the data retrieved to `bgp_neighbors`.
  prefs: []
  type: TYPE_NORMAL
- en: The `napalm_get_facts` module returns the data retrieved from the nodes as Ansible
    facts. This data can be retrieved from the `napalm_bgp_neighbors` variable, which
    stores all the NAPALM BGP facts retrieved from the device.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following snippet outlines the output from `napalm_bgp_neighbors`, retrieved
    from a Junos OS device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The following snippet outlines the output from `napalm_bgp_neighbors`, retrieved
    from an IOS-XR device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the data returned from NAPALM for the BGP information from different
    network vendors is consistent between different network vendors. This simplifies
    parsing this data and allows us to run much simpler playbooks to validate the
    network state.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use the data returned by NAPALM to compare and validate the operational
    state of the network against our network design, which we defined using Ansible
    variables such as `bgp_peers`. We use the `assert` module to validate multiple
    BGP information, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Correct number of BGP peers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: BGP router ID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All BGP sessions are operational
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We use the `when` statement in the different `assert` modules in scenarios in
    which we have a router in our topology that doesn't run BGP (`mxp02` is an example).
    Consequently, we skip these checks on these nodes.
  prefs: []
  type: TYPE_NORMAL
- en: See also…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `napalm_get_fact` module can retrieve a huge range of information from the
    network devices based on the vendor equipment supported and the level of facts
    supported by this vendor. For example, it supports the retrieval of interfaces,
    IP addresses, and LLDP peers for almost all the known networking vendors.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the complete documentation for the `napalm_get_facts` module, please check
    the following URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://napalm.readthedocs.io/en/latest/integrations/ansible/modules/napalm_get_facts/index.html](https://napalm.readthedocs.io/en/latest/integrations/ansible/modules/napalm_get_facts/index.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'For complete facts/getters supported by NAPALM and their support matrix against
    vendor equipment, please consult the following URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://napalm.readthedocs.io/en/latest/support/](https://napalm.readthedocs.io/en/latest/support/).[ ](https://napalm.readthedocs.io/en/latest/support/)'
  prefs: []
  type: TYPE_NORMAL
- en: Validating network reachability using NAPALM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will outline how to utilize NAPALM and its Ansible modules
    to validate network reachability across the network. This validation performs
    pings from the managed devices to the destination that we specify, in order to
    make sure that the forwarding path across the network is working as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To follow along with this recipe, it is assumed that an Ansible inventory is
    already in place and network reachability between the Ansible controller and the
    network is established. The network in this recipe is assumed to be configured
    as per the relevant previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new playbook called `pb_napalm_ping.yml` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the playbook with the validation tasks shown in the following code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: NAPALM provides another Ansible module, `napalm_ping`, which connects to the
    remote managed device and executes pings from the remote managed device toward
    a destination that we specify. Using this module, we are able to validate the
    forwarding path between the managed devices and the specified destination.
  prefs: []
  type: TYPE_NORMAL
- en: This `napalm_ping` module does not currently support Cisco IOS-XR devices, which
    is why we only select all PE devices that are in the Junos OS group. In our playbook,
    we use the `junos:&pe` pattern in order to do this.
  prefs: []
  type: TYPE_NORMAL
- en: In our example, we create a new playbook and we specify the destination that
    we want to ping, along with the maximum delay for our ping packets within the
    playbook itself, using the `vars` parameter. Then, we use the `napalm_ping` module
    to connect to the MPLS PE devices (only Junos OS ones) in our topology to execute
    `ping` from all these PE nodes toward the destination that we specified (in our
    case, this is the loopback for our **route reflector** (**RR**) router). We store
    all this data in a variable called `rr_ping`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following snippet shows the output returned from `napalm_ping`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we use the `assert` module to validate and compare the results returned
    by NAPALM against our requirements (ping is successful, no packet loss, and delay
    less than `max_delay`).
  prefs: []
  type: TYPE_NORMAL
- en: Validating and auditing networks with NAPALM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will outline how we can validate the operational state of
    the network by defining the intended state of the network and letting NAPALM validate
    that the actual/operational state of the network matches our intended state. This
    is useful in network auditing and compliance reports for our network infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To follow along with this recipe, it is assumed that an Ansible inventory is
    already in place and network reachability between the Ansible controller and the
    network is established. Finally, the network is configured as per the previously
    outlined recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new folder called `napalm_validate` and create a YAML file for each
    device. We will validate its state, as shown in the following code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new `pb_napalm_validation.yml` playbook with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the playbook to create a folder that will store the compliance reports
    for each device, as shown in the following code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: NAPALM provides another module for network validation, which is the `napalm_validate`
    module. This module is mainly used to perform auditing and generate compliance
    reports for the network infrastructure. The main idea is to declare the intended
    state of the network and define it in a YAML document. This YAML file has a specific
    format, following the same structure with which the different NAPALM facts are
    generated. In this YAML file, we specify the NAPALM facts that we want to retrieve
    from the network, along with the network's expected output.
  prefs: []
  type: TYPE_NORMAL
- en: We supply these validation files to the `napalm_validate` module, and NAPALM
    will connect to the devices, retrieve the facts specified in these validation
    files, and compare the output retrieved from the network against the network state
    declared in these validation files.
  prefs: []
  type: TYPE_NORMAL
- en: Next, NAPALM generates a `compliance_report` object, which has the result of
    the comparison and whether the network complies with these validation files or
    not. We also set the `ignore_errors` parameter in order to continue with the other
    tasks in this playbook in case the device doesn't comply, so we can capture this
    compliance problem in the compliance report that we will generate.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we save the output in a separate folder called `compliance_folder`
    for each node, copy the contents of the `compliance_report` parameter, and format
    it using the `to_nice_yaml` filter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for a correct compliance report generated for a `mxpe01` device is
    shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: See also…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For further information on validating deployments and the other options available
    for `napalm_validate`, please check the following URLs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://napalm.readthedocs.io/en/latest/integrations/ansible/modules/napalm_validate/index.html](https://napalm.readthedocs.io/en/latest/integrations/ansible/modules/napalm_validate/index.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://napalm.readthedocs.io/en/latest/validate/index.html](https://napalm.readthedocs.io/en/latest/validate/index.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
