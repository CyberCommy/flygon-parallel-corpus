- en: Chapter 9. Packaging and the Windows Store
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The previous chapters discussed various details for building Windows Store
    apps: from the basic Windows Runtime concepts, through building a user interface,
    to using unique Windows 8 features (for example live tiles, contracts). All that''s
    left is to build your app and finally to submit it to the Store, so that everyone
    can enjoy it.'
  prefs: []
  type: TYPE_NORMAL
- en: The Store, however, has its own rules and guidelines. Applications go through
    a certification process, to ensure they are of high quality, and will benefit
    users. "High quality" here encompasses many details, some related directly to
    quality experience (performance, touch experience, fluidity, and more) and some
    more subtle (such as responding appropriately to network fluctuations and adhering
    to modern UI design guidelines).
  prefs: []
  type: TYPE_NORMAL
- en: 'Windows Store apps provide many opportunities for developers. The Store is
    not yet saturated (as iOS and Android stores are), and so applications have a
    better chance of being noticed. Monetization is possible—apps may cost money,
    but other models exist: the Store model supports trial applications (with various
    expiration mechanisms), in-app purchases can be provided, so that the app may
    be downloaded for free, but items or services can be sold from within the app;
    the app can show ads—and get paid just because users are running the app—although
    the app itself is free.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we'll take a look at application packaging for the Windows
    Store and discuss some of the issues that need to be considered for the application
    to pass certification successfully.
  prefs: []
  type: TYPE_NORMAL
- en: The application manifest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve already met the app manifest several times in previous chapters. This
    is the basic declarations the application makes, before it''s even executed. Some
    important things to consider:'
  prefs: []
  type: TYPE_NORMAL
- en: Image logos, other than the defaults, must be supplied—the default images will
    automatically cause certification to fail; all image logos must be provided, and
    the image sizes must be as required (no scaling).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the capabilities tab, only the required capabilities should be checked. It's
    easy to check just almost everything, but this makes the app less secure and may
    even fail certification—the user will have to authorize capabilities that may
    not actually be used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Supported orientations may be supplied, leaving out some orientations that may
    make no sense for the particular app. Games, as an extreme example, can usually
    run with a particular orientation (landscape or portrait) only.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For some capabilities, a privacy policy statement must be supplied as part of
    the app or through a web link. This should state what the app is doing with those
    capabilities. Examples that need a privacy statement are Internet (client, server)
    and Location (GPS).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The question of orientation brings up a more general issue—application views.
    Besides the obvious landscape and portrait, the application (in landscape mode)
    can also share the screen with another application, in snapped or filled mode.
  prefs: []
  type: TYPE_NORMAL
- en: The application view state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An application can be viewed in four different ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Landscape** – screen width is larger than its height.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Portrait** – screen height is larger than its width.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Snapped** – the application takes up 320 pixels in width, while another application
    takes the rest of the screen width. This is only possible if the horizontal display
    resolution is at least 1366 pixels.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Filled** – the "mirror" of snapped. The application takes most of the horizontal
    space, leaving 320 pixels for another app.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s a screenshot of two apps being in the snapped/filled states:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The application view state](img/5022_09_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Users expect the application to change its view accordingly when in snap mode.
    In the preceding screenshot, the News application is snapped, so news articles
    appear as small items and not full text as they do in other modes.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take the Flags app from the previous chapter and adapt it to display nicely,
    depending on its current view state.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing view state changes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are several ways to deal with view state changes. We''ll take a simple,
    pragmatic approach. Currently, our Flags application presents the same view irrespective
    of the orientation or "snappiness". To test orientations and views we can use
    the simulator that''s provided with the SDK (unless we happen to have a tablet-based
    device to do actual testing). Here''s what the application looks like in the snapped
    mode inside the simulator:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing view state changes](img/5022_09_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Clearly, this is not the best user experience. The text next to each flag is
    too long, so not many flags are visible at the same time, and the text maybe cut
    off. A better approach would be to show just the flag images, without the country
    names.
  prefs: []
  type: TYPE_NORMAL
- en: 'The system raises the `SizeChanged` event on the active page—this is something
    we can handle and make the necessary view changes. First, we''ll make the `ItemTemplate`
    of our `GridView` a bit more flexible by binding it to an additional property
    that we''ll change as needed when the view changes. Here''s the complete template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The change is in the topmost `Grid`—its `Width` is bound to a dependency property
    (`ColumnWidth`) on the `MainPage` object.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It would be more elegant to implement this in a separate `ViewModel` that implements
    `INotifyPropertyChanged`, as discussed in [Chapter 5](ch05.html "Chapter 5. Data
    Binding"), *Data Binding*. The approach shown here is quicker, and is enough for
    demonstration purposes.
  prefs: []
  type: TYPE_NORMAL
- en: This `ColumnWidth` property would change, depending on the current view state.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This page's markup sustains both landscape and portrait orientations equally
    well. Sometimes, more drastic changes are required for good orientation support.
    Some layout panels are better suited for both orientations, such as the `StackPanel`.
    `Grid` is not suited for this, unless it's a very simple one. A complex `Grid`
    may have to undergo significant changes when switching orientations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `SizeChanged` event is registered in the `MainPage` constructor like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The handler just calls a helper method, `HandleSizeChanges`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This same helper is called from the `OnNavigatedTo` override to make sure the
    view is adjusted when the page first loads. The basic idea is to inspect the `Windows::UI::ViewManagement::ApplicationView::Value`
    static property, and take appropriate actions based on the possible values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The code changes the `ColumnWidth` bound property as appropriate, based on
    the view state. The Filled and Landscape views are treated in the same way, but
    they could have been a bit different. In the Portrait mode the column width is
    narrower, so that more flags can be shown in a single screen. In the snapped view,
    the text portion is eliminated entirely, leaving the image only. This is the result
    in the snapped view:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing view state changes](img/5022_09_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Another common approach to deal with view state changes is using the `ViewStateManager`
    class. This allows for making changes in XAML and not requiring code, except the
    change to the correct view state, done with the `VisualStateManager::GoToState`
    static method. This approach is beyond the scope of this book, but many such examples
    can be found on the web.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If nothing else makes sense, at the very least, an application should show some
    logo image or text when in the snapped view. Otherwise, the app may fail certification
    if the view is unprepared for the snap view.
  prefs: []
  type: TYPE_NORMAL
- en: Packaging and validating
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once the application is done (or at least considered done by the developers),
    it's time to package and upload it to the Store. The first step should be testing
    the application for some types of errors that would fail certification, so these
    can be fixed right away.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started, we can use Visual Studio''s **Project** | **Store** submenu:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Packaging and validating](img/5022_09_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The menu allows opening a developer account, reserving an app name (must be
    unique, and will be reserved for one year) and do some other stuff (such as capture
    a screenshot—at least one is required); you can find information on these options
    in the developer portal for Windows Store apps. We'll now take a look at the **Create
    App Packages** option.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first question the dialog asks is whether we want to create a package to
    upload to the Store. If **Yes** is selected, the developer must sign with his/her
    Microsoft ID, and then the packages will be built and later uploaded. We''ll take
    the **No** answer route for now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Packaging and validating](img/5022_09_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Clicking on **Next** shows a dialog that allows selecting the configurations
    to build (and to test):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Packaging and validating](img/5022_09_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We must select a Release configuration for package creation and testing. Testing
    a Debug configuration would fail, no matter what. Uploads to the Store must be
    Release builds only, otherwise the app would fail certification. We can select
    the required architectures that we want to create packages for. x86 and ARM are
    recommended—ARM is the only architecture available on Windows RT machines, so
    should be supported. x86 is a good choice for Intel/AMD-based architectures.
  prefs: []
  type: TYPE_NORMAL
- en: 'Clicking on **Create** builds the project in the selected configurations and
    shows the following dialog:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Packaging and validating](img/5022_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This shows the location of the created packages, where all the required files
    to be uploaded reside. The dialog further suggests to launch the **Windows App
    Certification Kit** (**WACK**) to do some automatic validation testing on the
    app.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Windows App Certification Kit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Running the WACK is one of the first steps done in the Store; this means if
    the app fails the local WACK test, it will certainly fail certification in the
    Store. Once selected, the following dialog appears:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the Windows App Certification Kit](img/5022_09_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The validation process takes a few minutes, in which the application will be
    started and terminated automatically. Finally, the results will be shown with
    a "Passed" or "Failed" notification and a link to a report that was created for
    the test (warnings may appear as well, but they are not considered a failure).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Flags app fails the WACK test because it did not replace the default image
    logos.
  prefs: []
  type: TYPE_NORMAL
- en: If the application passes the WACK test, we can go ahead and upload the app
    to the Store. Passing WACK does not mean that the app is sure to pass Store certification.
    The Store does a lot more testing than WACK, including manual testing with a live
    person; but passing the WACK test is a good first step. You should never upload
    a package without passing the local WACK test.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The complete requirement list for Store apps can be found at [http://msdn.microsoft.com/en-us/library/windows/apps/hh694083.aspx](http://msdn.microsoft.com/en-us/library/windows/apps/hh694083.aspx).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we saw the basic procedure of packaging and uploading an app
    to the Store and discussed some of the issues that must be addressed for the app
    to pass certification successfully. The reader is encouraged to consult the official
    Microsoft certification guidelines to get the full details.
  prefs: []
  type: TYPE_NORMAL
- en: Since the certification process can take a few days, it's better if the app
    is as tested as possible before actual submission. Using the Windows App Certification
    Kit is a must to improve chances of successful certification.
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft wants apps in the Store that are high quality and provide real value
    to users. This means the app has to behave "nicely", for sure, but that's not
    nearly enough; the content should be compelling and fun, so users return to the
    app again and again—and that's a challenge for a different book.
  prefs: []
  type: TYPE_NORMAL
