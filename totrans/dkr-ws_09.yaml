- en: 9\. Docker Swarm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will work with Docker Swarm from the command line to manage
    running nodes, deploy services, and perform rolling updates on your services when
    needed. You will learn how to troubleshoot your Swarm nodes and deploy entire
    stacks using your existing Docker Compose files, as well as learning how you can
    use Swarm to manage your service configuration and secrets. The final part of
    this chapter will provide you with the knowledge you need to get started using
    Swarmpit, which is a web-based interface for running and managing your Docker
    Swarm services and clusters.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far in this book, we've run our Docker containers and controlled the way
    they run from the command line using direct commands such as `docker run` to launch
    containers. Our next step is to automate things with the use of Docker Compose,
    which allows an entire environment of containers to work together. Docker Swarm
    is the next step in managing our Docker environments. **Docker Swarm** allows
    you to orchestrate how your containers can scale and work together to provide
    a more reliable service to your end-users.
  prefs: []
  type: TYPE_NORMAL
- en: Docker Swarm allows you to set up multiple servers running Docker Engine and
    organize them as a cluster. Docker Swarm can then run commands to coordinate your
    containers across the cluster instead of just one server. Swarm will configure
    your cluster to make sure your services are balanced across your cluster, ensuring
    higher reliability for your services. It will also decide for you which service
    will be assigned to which server depending on the load across your cluster. Docker
    Swarm is a step up in terms of managing the way you run your containers and is
    provided by default with Docker.
  prefs: []
  type: TYPE_NORMAL
- en: Docker Swarm allows you to configure redundancy and failover for your services
    while scaling the number of containers up and down depending on the load. You
    can perform rolling updates across your services to reduce the chances of an outage,
    meaning new versions of your container applications can be applied to the cluster
    without these changes causing an outage for your customers. It will allow you
    to orchestrate your container workloads through the swarm instead of manually
    managing containers one by one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Swarm also introduces some new terms and concepts when it comes to managing
    your environment, defined in the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Swarm**: Multiple Docker hosts run in swarm mode to act as managers and workers.
    Having multiple nodes and workers is not compulsory as part of Docker Swarm. You
    can run your services as a single node swarm, which is the way we will be working
    in this chapter, even though a production cluster may have multiple nodes available
    to make sure your services are as fault-tolerant as possible.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Task**: The manager distributes the tasks to run inside the nodes. A task
    consists of a Docker container and the commands that will run inside the container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Service**: This defines the tasks to execute on the manager or worker. The
    difference between services and a standalone container is that you can modify
    a service''s configuration without restarting the service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Node**: An individual system running Docker Engine and participating in the
    swarm is a node. More than one node can run on a single physical computer at one
    time through the use of virtualization.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: We will only be using one node on our system.
  prefs: []
  type: TYPE_NORMAL
- en: '**Manager**: The manager dispatches tasks to worker nodes. The manager carries
    out orchestration and cluster management. It also hosts services on the cluster.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Leader node**: The manager node in the swarm elects a single primary leader
    node to conduct the orchestration tasks across the cluster.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Worker nodes**: Worker nodes execute the tasks assigned by the manager node.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that you are familiar with the key terms, let's explore how Docker Swarm
    works in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: How Docker Swarm Works?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The swarm manager nodes handle cluster management, and the main objective is
    to maintain a consistent state of both the swarm and the services running on it.
    This includes ensuring that the cluster is running at all times and that services
    are run and scheduled when needed.
  prefs: []
  type: TYPE_NORMAL
- en: As there are multiple managers running at the same time, this means there is
    fault tolerance, especially in a production environment. That is, if one manager
    is shut down, the cluster will still have another manager to coordinate services
    on the cluster. The sole purpose of worker nodes is to run Docker containers.
    They require at least one manager to function, but worker nodes can be promoted
    to being a manager, if needed.
  prefs: []
  type: TYPE_NORMAL
- en: Services permit you to deploy an application image to a Docker swarm. These
    are the containers to run and the commands to execute inside the running container.
    Service options are provided when you create a service, where you can specify
    the ports the application can publish on, CPU and memory restrictions, the rolling
    update policy, and the number of replicas of an image that can run.
  prefs: []
  type: TYPE_NORMAL
- en: The desired state is set for the service, and the manager's responsibility is
    to monitor the service. If the service is not in the desired state, it will correct
    any issues. If a task fails, the orchestrator simply removes the container related
    to the failed task and replaces it.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know how Docker Swarm works, the next section will get you started
    with the basic commands and guide you through a hands-on exercise to further demonstrate
    its operation.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Docker Swarm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous section of this chapter has shown you that Swarm uses similar concepts
    to what you have already learned so far in this book. You'll see that the use
    of Swarm takes the Docker commands you are so familiar with and expands them to
    allow you to create your clusters, manage services, and configure your nodes.
    Docker Swarm takes a lot of the hard work out of running your services, as Swarm
    will work out where it is best to place your services, take care of scheduling
    your containers, and decide which node it is best to place it on. For example,
    if there are already three services running on one node and only one service on
    your second node, Swarm will know that it should distribute the services evenly
    across your system.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, Docker Swarm is disabled, so to run Docker in swarm mode, you will
    need to either join an existing cluster or create a new swarm. To create a new
    swarm and activate it in your system, you use the `swarm init` command shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This will create a new single-node swarm cluster on the node you are currently
    working on. Your system will become the manager node for the swarm you have just
    created. When you run the `init` command, you'll also be provided with the details
    on the commands needed to allow other nodes to join your swarm.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a node to join a swarm, it requires a secret token, and the token for a
    worker node is different from that of a manager node. The manager tokens need
    to be strongly protected so you don''t allow your swarm cluster to become vulnerable.
    Once you have the token, IP address, and port of the swarm that your node needs
    to join, you run a command similar to the one shown here, using the `--token`
    option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If for some reason you need to change the tokens (possibly for security reasons),
    you can run the `join-token --rotate` option to generate new tokens as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'From the swarm manager node, the following `node ls` command will allow you
    to see the nodes available in your swarm and provide details on the status of
    the node, whether it is a manager or a worker, and whether there are any issues
    with the node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Once your swarm is available and ready to start hosting services, you can create
    a service with the `service create` command, providing the name of the service,
    the container image, and the commands needed for the service to run correctlyâ€”for
    example, if you need to expose ports or mount volumes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Changes can then be made to the service configuration, or you can change the
    way the service is running by using the `update` command, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, if you need to remove or stop the service from running, you simply
    use the `service remove` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We've provided a lot of theory on Docker Swarm here, and we hope it has provided
    you with a clear understanding of how it works and how you can use Swarm to launch
    your services and scale to provide a stable service when there is high demand.
    The following exercise will take what we have learned so far and show you how
    to implement it in your projects.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Please use `touch` command to create files and `vim` command to work on the
    file using vim editor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 9.01: Running Services with Docker Swarm'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This exercise is designed to help you become familiar with using the Docker
    Swarm commands to manage your services and containers. In the exercise, you will
    activate a cluster, set up a new service, test scaling up the service, and then
    remove the service from the cluster using Docker Swarm:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Although Swarm is included by default with your Docker installation, you still
    need to activate it on your system. Use the `docker swarm init` command to put
    your local system into Docker Swarm mode:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Your output might be a little different from what you see here, but as you
    can see, once the swarm is created, the output provides details on how you can
    add extra nodes to your cluster with the `docker swarm join` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now list the nodes you have in your cluster, using the `node ls` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'You should have one node you are currently working on and its status should
    be `Ready`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: For clarity here, we have removed the `Engine Version` column from our output.
  prefs: []
  type: TYPE_NORMAL
- en: 'From your node, check the status of your swarm using the `docker info` command,
    providing further details of your Swarm cluster and how the node is interacting
    with it. It will also give you extra information if you need to troubleshoot issues
    later:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from the output, you get all the specific details of your Docker
    Swarm cluster, including `NodeID` and `ClusterID`. If you don''t have Swarm set
    up correctly on your system, all you will see is an output of `Swarm: inactive`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Start your first service on your newly created swarm. Create a service named
    `web` using the `docker service create` command and the `--replicas` option to
    set two instances of the container running:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see that the two instances are successfully created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar to the `docker ps` command, you can see a listing of the services running
    on your cluster with the `docker service ls` command. Execute the `docker service
    ls` command to view the details of the `web` service created in the *step 4*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The command will return the details of the `web` service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'To view the containers currently running on your swarm, use the `docker service
    ps` command with the name of your service, `web`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, you now have a list of the containers running our service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The service will only run the default `Welcome to nginx!` page. Use the node
    IP address to view the page. In this instance, it will be your localhost IP, `0.0.0.0`:![Figure
    9.1: The nginx service from Docker Swarm'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/B15021_09_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.1: The nginx service from Docker Swarm'
  prefs: []
  type: TYPE_NORMAL
- en: 'Scaling the number of containers running your service is easy with Docker Swarm.
    Simply provide the `scale` option with the number of total containers you want
    to have running, and the swarm will do the work for you. Perform the command shown
    here to scale your running web containers to `3`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The following output shows that the `web` service is now scaled to `3` containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'As in *step 5* of this exercise, run the `service ls` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'You should now see three `web` services running on your cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The following change is more suited to a cluster with more than one node, but
    you can run it anyway to see what happens. Run the following `node update` command
    to set the availability to `drain` and use your node ID number or name. This will
    remove all the containers running on this node as it is no longer available on
    your cluster. You will be provided with the node ID as an output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'If you were to run the `docker service ps web` command, you would see each
    of your `web` services shut down while trying to start up new `web` services.
    As you only have one node running, the services would be sitting in a pending
    state with `no suitable node` error. Run the `docker service ps web` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The output has been reduced to only show the second, third, fifth, and sixth
    columns, but you can see that the service is unable to start. The `CURRENT STATE`
    column has both `Pending` and `Shutdown` states:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the `docker node ls` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This shows that your node is ready but in an `AVAILABILITY` state of `Drain`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Stop the service from running. Use the `service rm` command, followed by the
    service name (in this instance, `web`) to stop the service from running:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The only output shown will be the name of the service you are removing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'You don''t want to leave your node in a `Drain` state as you want to keep using
    it through the rest of the exercises. To get the node out of a `Drain` state and
    prepare to start managing swarm, set the availability to `active` with the following
    command using your node ID:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The command will return the hash value of the node, which will be different
    for every user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the `node ls` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'It will now show the availability of our node as `Active` and ready your services
    to run again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `docker node inspect` command with the `--format` option and search
    for the `ManagerStatus.Reachability` status to ensure that your node is reachable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'If the node is available and can be contacted, you should see a result of `reachable`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Search for `Status.State` to ensure that the node is ready:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'This should produce `ready`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This exercise should have given you a good indication of how Docker Swarm is
    able to simplify your work, especially when you start to think about deploying
    your work into a production environment. We used the Docker Hub NGINX image, but
    we could easily use any service we have created as a Docker image that is available
    to our Swarm node.
  prefs: []
  type: TYPE_NORMAL
- en: The next section will take a quick sidestep to discuss some actions you need
    to take if you find yourself in trouble with your Swarm nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Troubleshooting Swarm Nodes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For the work we will be doing in this chapter, we will be using only a single-node
    swarm to host our services. Docker Swarm has been providing production-level environments
    for years now. However, this doesn''t mean there will never be any issues with
    your environment, especially when you start hosting services in a multi-node swarm.
    If you need to troubleshoot any of the nodes running on your cluster, there are
    a number of steps you can take to make sure you are correcting any issues they
    may have:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Reboot**: Usually the easiest option is to either reboot or restart the node
    system to see whether this resolves the issues you may be experiencing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Demote the node**: If the node is a manager on your cluster, try demoting
    the node using the `node demote` command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: If this node is the leader, it will allow one of the other manager nodes to
    become the leader of the swarm and hopefully resolve any issues you may be experiencing.
  prefs: []
  type: TYPE_NORMAL
- en: '**Remove the node from the cluster**: Using the `node rm` command, you can
    remove the node from the cluster:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'This can also be an issue if the node is not communicating correctly with the
    rest of the swarm, and you may need to use the `--force` option to remove the
    node from the cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '**Join back to the cluster**: If the preceding has worked correctly, you may
    be able to successfully join the node back onto the cluster with the `swarm join`
    command. Remember to use the token that you used before when joining the swarm:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If your services are still having issues running on Docker Swarm and you have
    corrected all issues with the Swarm nodes, Swarm is simply using Docker to run
    and deploy your services onto the nodes in your environment. Any issues may come
    down to basic troubleshooting with the container image you are trying to run on
    Swarm and not the Swarm environment itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'A cluster of managers is known as a **quorum**, and a majority of the managers
    need to agree on the proposed updates to the swarm, such as adding new nodes or
    scaling back the number of containers. As we saw in the previous section, you
    can monitor swarm managers'' or nodes'' health by running the `docker node ls`
    command, using the ID of the manager to then use the `docker node inspect` command
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: One final note on your Swarm node is to remember to deploy services to your
    nodes that have been created as Docker images. The container image itself needs
    to be available for download from a central Docker Registry, which is available
    for all the nodes to download from and not simply built on one of the Swarm nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Although we've taken a quick detour to discuss troubleshooting your Swarm nodes,
    this should not be a major aspect of running services on Swarm. The next part
    of this chapter moves a step further by showing you how you can use new or existing
    `docker-compose.yml` files to automate the deployment of your services into Docker
    Swarm.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying Swarm Deployments from Docker Compose
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Deploying a complete environment is easy with Docker Swarm; you'll see that
    most of the work is already done if you have been running your containers using
    Docker Compose. This means you won't need to manually start services one by one
    in Swarm as we did in the previous section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you already have a `docker-compose.yml` file available to bring up your
    services and applications, there is a good chance it will simply work without
    issues. Swarm will use the `stack deploy` command to deploy all your services
    across the Swarm nodes. All you need to do is provide the `compose` file and assign
    the stack a name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The stack creation is quick and seamless, but a lot is happening in the background
    to make sure all services are running correctlyâ€”including setting up networks
    between all the services and starting up each of the services in the order needed.
    Running the `stack ps` command with the `swarm_name` you provided at creation
    time will show you whether all the services in your deployment are running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'And once you are finished using the services on your swarm or you need to clean
    up everything that is deployed, you simply use the `stack rm` command, providing
    the `swarm_name` you provided when you created the stack deployment. This will
    automatically stop and clean up all the services running in your swarm and ready
    them for you to reassign to other services:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Now, since we know the commands used to deploy, run, and manage our Swarm stack,
    we can look at how to perform rolling updates for our services.
  prefs: []
  type: TYPE_NORMAL
- en: Swarm Service Rolling Updates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Swarm also has the ability to perform rolling updates on the services that are
    running. This means if you have a new update to an application running on your
    Swarm, you can create a new Docker image and update your service, and Swarm will
    make sure the new image is up and running successfully before it brings down the
    old version of your container image.
  prefs: []
  type: TYPE_NORMAL
- en: 'Performing a rolling update on a service you have running in Swarm is simply
    a matter of running the `service update` command. In the following command, you
    can see both the new container image name and the service you want to update.
    Swarm will handle the rest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: You'll get the chance very shortly to use all the commands we've explained here.
    In the following example, you will create a small test application using Django
    and PostgreSQL. The web application you will be setting up is very basic, so there
    is no real need to have a prior understanding of the Django web framework. Simply
    follow along and we will explain what is happening as we move through the exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 9.02: Deploying Your Swarm from Docker Compose'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the following exercise, you will use `docker-compose.yml` to create a basic
    web application using a PostgreSQL database and the Django web framework. You
    will then use this `compose` file to deploy your services into your swarm without
    the need to run your services manually:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create a directory to run your application in. Call the directory `swarm`
    and move into the directory using the `cd` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `Dockerfile` for your Django application in the new directory and,
    using your text editor, enter the details in the following code block. The `Dockerfile`
    will use the default `Python3` image, set environment variables relevant for Django,
    install relevant applications, and copy the code into the current directory of
    the container image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the `requirements.txt` file that your `Dockerfile` uses in the previous
    step to install all the relevant applications needed for it to run. Add in the
    following two lines with your text editor to install the version of `Django` and
    `Psycopg2` required by the Django application to communicate with the PostgreSQL
    database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `docker-compose.yml` file using your text editor. Add in the first
    service for your database, as shown in the following code. The `db` service will
    use the latest `postgres` image from Docker Hub, exposing port `5432`, and also
    set the environment variable for `POSTGRES_PASSWORD`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The second half of the `docker-compose.yml` file builds and deploys your web
    application. Build your `Dockerfile` in *line 10*, expose port `8000` to access
    it from your web browser, and set the database password to match your `db` service.
    You will also notice a Python command in *line 13* that will start the development
    web server for the Django application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following command to pull and build the `db` and `web` services in
    your `docker-compose.yml`. The command will then run `django-admin startproject`,
    which will create your basic Django project, named `chapter_nine`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The command should return the following output, in which you see the containers
    being pulled and built:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The `startproject` command you ran in the previous step should have created
    some extra files and directories in your swarm directory. Run the `ls` command
    to list all the files and directories in the swarm directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'You previously created the `Dockerfile`, `docker-compose.yml` file, and `requirements.txt`
    file, but now the build of the container has added the `chapter_nine` Django directory
    and the `manage.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'To get your basic application running, you need to make some minor changes
    to the Django project settings. Open the `chapter_nine/settings.py` file with
    your text editor and locate the entry that starts with `DATABASES`. This controls
    how Django will connect to your database, and by default, Django is set up to
    work with an SQLite database. The `DATABASES` entry should look like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'You have a PostgreSQL database to deploy to Swarm as a part of our installation,
    so edit the `DATABASES` settings with the following eight lines so that Django
    will access this PostgreSQL database instead:'
  prefs: []
  type: TYPE_NORMAL
- en: settings.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The complete code for this step can be found at [https://packt.live/2DWP9ov](https://packt.live/2DWP9ov).
  prefs: []
  type: TYPE_NORMAL
- en: 'At *line 28* of our `settings.py` file, we also need to add the IP address
    we are going to use as the `ALLOWED_HOSTS` configuration. We will configure our
    application to be accessible from the IP address `0.0.0.0`. Make the relevant
    changes to the settings file at *line 28* so that it now looks like the code below:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Now test to see whether your basic project is working as expected. From the
    command line, deploy your services to Swarm with the `stack deploy` command. In
    the following command, specify the `docker-compose.yml` file to use with the `--compose-file`
    option and name the stack `test_swarm`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The command should set up the swarm network, the database, and the web services:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the `docker service ls` command, and you should be able to see the status
    for both the `test_swarm_db` and `test_swarm_web` services:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the following output, they are both showing a `REPLICAS`
    value of `1/1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'If your work has been successful, test it by opening a web browser and going
    to `http://0.0.0.0:8000`. If everything has worked, you should see the following
    Django test page displayed on your web browser:![Figure 9.2: Deploying a service
    to Swarm with Docker Compose file'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/B15021_09_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.2: Deploying a service to Swarm with Docker Compose file'
  prefs: []
  type: TYPE_NORMAL
- en: 'To view the stacks currently running on your system, use the `stack ls` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following output, which shows two services running under
    the name of `test_swarm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `stack ps` command with the name of your swarm to view the services
    running and check whether there are any issues:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ID`, `DESIRED STATE`, and `ERROR` columns are not included in the following
    reduced output. Also, it can be seen that the `test_swarm_web.1` and `test_swarm_db.1`
    services are running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Just as you were able to start up all your services at once with the `deploy`
    command, you can stop the services all at once, as well. Use the `stack rm` command
    with the name of your swarm to stop all of your services from running and remove
    the stack:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that all the services are stopped in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'You still want to perform some extra work on your swarm as part of this exercise,
    but first, make a minor change to the `compose` file. Open the `docker-compose.yml`
    file with your text editor and add the following lines to your web service to
    now have two replica web services created when deployed to the swarm:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'The complete `docker-compose.yml` file should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Deploy the swarm again with the changes you have made using the same command,
    as you did earlier in *step 8*. Even if the `test_swarm` stack was still running,
    it would note and make the relevant changes to the services:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the `docker ps` command as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Only the first two columns are printed in the output shown here. You can now
    see that there are two `swarm_web` services running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'To deploy a new version of the `swarm_web` service to your swarm without stopping
    the services, first, build a new Docker image of our web service. Don''t make
    any changes to the image, but this time tag the image with the `patch1` tag to
    demonstrate a change while the service is running:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'To perform a rolling update, use the `service update` command, providing details
    of the image you wish to update to and the service name. Run the following command,
    which uses the image you have just created with the `patch1` tag, on the `test_swarm_web`
    service:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Swarm will manage the update to make sure one of the services is always running
    before the update is applied to the rest of the images:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You'll notice the output shows the image was not available on a repository.
    As we only have one node running our swarm, the update will use the image built
    on the node. In a real-world scenario, we would need to push this image to a central
    repository that all our nodes have access to so they can pull it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the `docker ps` command given here, which pipes its output to an `awk`
    command to only print the first two columns of `CONTAINER` and `ID`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'The command will return the output such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'What if you wanted to control the way the rolling updates occur? Run the following
    command to perform a new rolling update to your `test_swarm_web` services. Revert
    the changes you made to deploy the image with the `latest` tag, but this time,
    make sure there is a `30`-second delay in performing the update as this will give
    your web service extra time to start up before the second update is run:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the `docker ps` command again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the containers are now running the `swarm_web:latest` image again
    after you have performed the rolling update:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: By now, you should see the benefit of using a swarm, especially when we start
    to scale out our applications using Docker Compose. In this exercise, we have
    demonstrated how to easily deploy and manage a group of services onto your swarm
    using Docker Compose and upgrade services with rolling updates.
  prefs: []
  type: TYPE_NORMAL
- en: The next section of this chapter will expand your knowledge further to show
    how you can use Swarm to manage your configurations and secret values used within
    your environment.
  prefs: []
  type: TYPE_NORMAL
- en: Managing Secrets and Configurations with Docker Swarm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far in this chapter, we have observed Docker Swarm's proficiency at orchestrating
    our services and applications. It also provides functionality to allow us to define
    configurations within our environment and then use these values. Why do we need
    this functionality, though?
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, the way we have been storing details such as our secrets has not been
    very secure, especially when we are typing them in plain text in our `docker-compose.yml`
    file or including them as part of our built Docker image. For our secrets, Swarm
    allows us to store encrypted values that are then used by our services.
  prefs: []
  type: TYPE_NORMAL
- en: Secondly, by using these features, we can start to move away from setting up
    configurations in our `Dockerfile`. This means we can create and build our application
    as a container image. Then, we can run our application on any environment, be
    it a development system on a laptop or a test environment. We can also run the
    application on a production environment, where we assign it with a separate configuration
    or secrets value to use in that environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating a Swarm `config` is simple, especially if you already have an existing
    file to use. The following code shows how we can create a new `config` using the
    `config create` command by providing our `config_name` and the name of our `configuration_file`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'This command creates a `config` stored as part of the swarm and is available
    to all the nodes in your cluster. To view the available configs on your system
    and the swarm, run the `ls` option with the `config` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also view the details in the configuration using the `config inspect`
    command. Make sure you are using the `--pretty` option since the output is presented
    as a long JSON output that would be almost unreadable without it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Using secrets within Swarm provides a secure way to create and store sensitive
    information in our environments, such as usernames and passwords, in an encrypted
    state so it can then be used by our services.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a secret that is only holding a single value, such as a username
    or password, we can simply create the secret from the command line, where we pipe
    the secret value into the `secret create` command. The following sample command
    provides an example of how to do this. Remember to name the secret when you create
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'You can make a secret from a file. For example, say you would like to set up
    a certificates file as a secret. The following command shows how to do this using
    the `secret create` command by providing the name of the secret and the name of
    the file you need to create the secret from:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Once created, your secret will be available on all the nodes you have running
    on your swarm. Just as you were able to view your `config`, you can use the `secret
    ls` command to see a listing of all the available secrets in your swarm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: We can see that Swarm provides us with flexible options to implement configurations
    and secrets in our orchestration, instead of needing to have it set up as part
    of our Docker images.
  prefs: []
  type: TYPE_NORMAL
- en: The following exercise will demonstrate how to use both configurations and secrets
    in your current Docker Swarm environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 9.03: Implementing Configurations and Secrets in Your Swarm'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you will expand your Docker Swarm environment further. You
    will add a service to your environment that will help NGINX to route the requests
    through the proxy, before moving into your web service. You will set this up using
    traditional methods but then use the `config` and `secret` functions as part of
    your environment to observe their operations within Swarm and help users deploy
    and configure services more efficiently:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Currently, the web service is using the Django development web server via the
    `runserver` command to provide web requests. NGINX will not be able to route traffic
    requests through to this development server, and instead, you will need to install
    the `gunicorn` application onto our Django web service for traffic to be routed
    via NGINX. Start by opening your `requirements.txt` file with your text editor
    and add the application as in the highlighted third line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Gunicorn is short for **Green Unicorn** and is used as a **Web Service Gateway
    Interface** (**WSGI**) for Python applications. Gunicorn is widely used for production
    environments as it is seen to be one of the most stable WSGI applications available.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run Gunicorn as part of your web application, adjust your `docker-compose.yml`
    file. Open the `docker-compose.yml` file with your text editor and change *line
    13* to run the `gunicorn` application, instead of the Django `manage.py runserver`
    command. The following `gunicorn` command runs the `chapter_nine` Django project
    via its WSGI service and binds to IP address and port `0.0.0.0:8000`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Rebuild your web service to make sure the Gunicorn application is installed
    on the container and available to run. Run the `docker-compose build` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Gunicorn can also run without the need of the NGINX proxy, so test the changes
    you have made by running the `stack deploy` command again. If you already have
    your services deployed, don''t worry, you can still run this command again. It
    will simply make the relevant changes to your swarm and match the changes in your
    `docker-compose.yml`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'The command will return the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: To ensure the changes have taken effect, make sure you open your web browser
    and verify that the Django test page is still being provided by your web service
    before moving on to the next step. As per your changes, the page should still
    be displayed at `http://0.0.0.0:8000`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To start your implementation of NGINX, open the `docker-compose.yml` file again
    and change *lines 16 and 17* to expose port `8000` from the original `ports` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Keeping the `docker-compose.yml` file open, add your `nginx` service at the
    end of the `compose` file. All of the information here should be familiar to you
    by now. *Line 25* provides the location of a new NGINX directory, the `Dockerfile`
    you will create shortly, and the name of the image to be used when the service
    is deployed. *Lines* *27* and *28* expose port `1337` to port `80` and *lines*
    *29* and *30* show that NGINX needs to depend on the `web` service to run:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, set up the NGINX `Dockerfile` and configurations for the service. Start
    by creating a directory called `nginx`, as in the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new `Dockerfile` in the `nginx` directory, open the file with your
    text editor, and add in the details shown here. The `Dockerfile` is created from
    the latest `nginx` image available on Docker Hub. It removes the default configuration
    `nginx` file in *line 3* and then adds a new configuration that you need to set
    up shortly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the `nginx.conf` file that the `Dockerfile` will use to create your
    new image. Create a new file called `nginx.conf` in the `nginx` directory and
    use your text editor to add the following configuration details:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: If you're unfamiliar with NGINX configurations, the preceding details are simply
    looking for requests to the web service and will route requests through to the
    `chapter_nine` Django application.
  prefs: []
  type: TYPE_NORMAL
- en: 'With all the details now in place, build your new image for the NGINX service
    now set up in your `docker-compose.yml` file. Run the following command to build
    the image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the `stack deploy` command again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, you will notice that your output shows that the `test_swarm_nginx`
    service has been created and should be running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'Verify that all the services are running as part of your swarm with the `stack
    ps` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting output has been reduced to show only four of the eight columns.
    You can see that the `test_swarm_nginx` service is now running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: To prove that requests are routing through the NGINX proxy, use port `1337`
    instead of port `8000`. Make sure that a web page is still being provided from
    your web browser by using the new URL of `http://0.0.0.0:1337`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This has been a great addition to the services running on Swarm but is not
    using the correct configuration management features. You already have an NGINX
    configuration created previously in this exercise. Create a Swarm configuration
    by using the `config create` command with the name of the new configuration and
    the file you are going to create the configuration from. Run the following command
    to create the new configuration from your `nginx/nginx.conf` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'The output from the command will provide you with the created configuration
    ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'Swarm also gives you a way to list all the configurations created as part of
    your Swarm, using the `config ls` command. Make sure the new `nginx_config` file
    has been created in the previous step and run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: '`nginx_config` has been created in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'View the full details of the configuration you have created using the `docker
    config inspect` command. Run the following command with the `--pretty` option
    to make sure the configuration output is in a readable form:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should look similar to what you see here, showing details of the
    NGINX configuration you have just created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'As you have now set up the configuration in Swarm, make sure the configuration
    is no longer built into the container image. Instead, it will be provided when
    the Swarm is deployed. Open the `Dockerfile` in the `nginx` directory and remove
    the fourth line of the `Dockerfile`. It should now look similar to the details
    given here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Remember that the change we are making here will make sure that we don't need
    to build a new NGINX image every time the configuration changes. This means we
    can use the same image and deploy it to a development swarm or a production swarm.
    All we would do is change the configuration to make the environment. We do need
    to create the image that can use the config we have created and stored in Swarm,
    though.
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous step in this exercise made a change to the `nginx` `Dockerfile`,
    so now rebuild the image to make sure it is up to date:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the `docker-compose.yml` file with your text editor to update the `compose`
    file so that our `nginx` service will now use the newly created Swarm `config`.
    At the bottom of the `nginx` service, add in the configuration details with the
    source name of the `nginx_cof` configuration you created earlier. Be sure to add
    it to the running `nginx` service so it can be used by the container. Then, set
    up a separate configuration for the file. Even though you have created it manually
    in the previous steps, your swarm needs to know about it when it is deployed.
    Add the following into your `docker-compose.yml`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'Deploy your swarm again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following output, you should now see an extra line showing `Creating
    config test_swarm_nginx_conf`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'There is still more you can do to take advantage of Swarm, and one extra feature
    not used yet is the secrets function. Just as you created a configuration earlier
    in this exercise, you can create a `secret` with a similar command. The command
    shown here first uses `echo` to output the password you want as your secret value,
    and then, using the `secret create` command, it uses this output to create the
    secret named `pg_password`. Run the following command to name your new secret
    `pg_password`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'The command will output the ID of the secret created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'View the secrets in your swarm using the `secret ls` command. Run this command
    now:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see that your secret has been created successfully with the name of
    `pg_password`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, make the relevant changes to your `docker-compose.yml` file. Previously,
    you simply entered the password you wanted for your `postgres` user. As you can
    see in the following code, here, you will point the environment variable to the
    secret you created earlier as `/run/secrets/pg_password`. This means it will search
    through the available secrets in your swarm and assign the secret stored in `pg_password`.
    You also need to refer to the secret in the `db` service to allow it access. Open
    the file with your text editor and make the following changes to the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'The `web` service uses the same secret to access the PostgreSQL database. Move
    into the `web` service section of the `docker-compose.yml` and change *line 21*
    to resemble the following, as it will now use the secret you have created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, just as you have done with your configuration, define the secret at
    the end of `docker-compose.yml`. Add in the following lines at the end of your
    `compose` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'Before deploying your changes, you have made a lot of changes to the `compose`
    file, so your `docker-compose.yml` file should look similar to what is shown in
    the following code block. You have three services running with the `db`, `web`,
    and `nginx` services set up, and we now have one `config` instance and one `secret`
    instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: docker-compose.yml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'command: gunicorn chapter_nine.wsgi:application --bind  0.0.0.0:8000'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: The complete code for this step can be found at [https://packt.live/3miUJD8](https://packt.live/3miUJD8).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: There are a few changes to our service, and if there are any issues in deploying
    the changes to Swarm, it may be worth deleting the services and then re-deploying
    to make sure all the changes take effect correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the final run of your Swarm deployment for this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the deployment and make sure the services are running and deployed successfully:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: In this exercise, you have practiced using Swarm to deploy a complete set of
    services using your `docker-compose.yml` file and have them running in a matter
    of minutes. This part of the chapter has also demonstrated some extra functionality
    of Swarm using `config` and `secret` instances to help us reduce the amount of
    work needed to move services to different environments. Now that you know how
    to manage Swarm from the command line, you can further explore Swarm cluster management
    in the following section using a web interface with Swarmpit.
  prefs: []
  type: TYPE_NORMAL
- en: Managing Swarm with Swarmpit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The command line provides an efficient and useful way for users to control their
    Swarm. This can get a little confusing for some users if your services and nodes
    multiply as need increases. One way to help with managing and monitoring your
    Swarm is by using a web interface such as the one provided by Swarmpit to help
    you administer your different environments.
  prefs: []
  type: TYPE_NORMAL
- en: As you'll see shortly, Swarmpit provides an easy-to-use web interface that allows
    you to manage most aspects of your Docker Swarm instances, including the stacks,
    secrets, services, volumes networks, and configurations.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will only touch on the use of Swarmpit, but if you would like
    more information on the application, the following site should provide you with
    further details: [https://swarmpit.io](https://swarmpit.io).'
  prefs: []
  type: TYPE_NORMAL
- en: Swarmpit is a simple-to-use installation Docker image that, when run on your
    system, creates its swarm of services deployed in your environment to run the
    management and web interface. Once installed, the web interface is accessible
    from `http://0.0.0.0:888`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run the installer on your system to get Swarm running, execute the following
    `docker run` command. With this, you name the container `swampit-installer` and
    mount the container volume on `/var/run/docker.sock` so it can manage other containers
    on our system, using the `swarmpit/install:1.8` image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: The installer will set up a swarm with a database, an agent, a web application,
    and the network to link it all together. It will also guide you through setting
    up an administrative user to log on to the interface for the first time. Once
    you log in to the web application, the interface is intuitive and easy to navigate.
  prefs: []
  type: TYPE_NORMAL
- en: The following exercise will show you how to install and run Swarmpit on your
    running system and start to manage your installed services.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 9.04: Installing Swarmpit and Managing Your Stacks'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you will install and run Swarmpit, briefly explore the web
    interface, and begin managing your services from your web browser:'
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s not completely necessary to do so, but if you have stopped your `test_swarm`
    stack from running, start it up again. This will provide you with some extra services
    to monitor from Swarmpit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you are worried that there will be too many services running on your system
    at once, feel free to skip this `test_swarm` stack restart. The exercise can be
    performed as follows on the Swarmpit stack that is created as part of the installation
    process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following `docker run` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: 'It pulls the `install:1.8` image from the `swarmpit` repository and then runs
    through the process of setting up your environment details, allowing the user
    to make changes to the stack name, ports, administrator username, and password.
    It then creates the relevant services needed to run the applications:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'On the command line, run the `stack ls` command to ensure that you have the
    Swarmpit swarm deployed to your node:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: 'The following output confirms that Swarmpit is deployed to our node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `service ls` command to verify that the services needed by Swarmpit
    are running:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: 'For clarity, the output shown here only displays the first four columns. The
    output also shows that the `REPLICAS` value for each service is `1/1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s time to log in to the Swarmpit web interface. Open your web browser and
    use `http://0.0.0.0:888` to open the Swarmpit login page and enter the admin username
    and password you set during the installation process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.3: The Swarmpit login screen'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15021_09_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.3: The Swarmpit login screen'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you log in, you''re presented with the Swarmpit welcome screen, showing
    your dashboard of all your services running on the node, as well as details of
    the resources being used on the node. The left of the screen provides a menu of
    all the different aspects of the Swarm stack you can monitor and manage, including
    the stacks themselves, `Services`, `Tasks`, `Networks`, `Nodes`, `Volumes`, `Secrets`,
    `Configs`, and `Users`. Click on the `Stacks` option in the left-hand menu and
    select the `test_swarm` stack:![Figure 9.4: The Swarmpit welcome dashboard'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/B15021_09_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.4: The Swarmpit welcome dashboard'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should be presented with a screen similar to the following. The size of
    the screen has been reduced for clarity, but as you can see, it provides all the
    details of the interacting components of the stackâ€”including the services available
    and the secrets and configs being used. If you click on the menu next to the stack
    name, as shown here, you can edit the stack. Click `Edit Stack` now:![Figure 9.5:
    Managing your swarm with Swarmpit'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/B15021_09_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.5: Managing your swarm with Swarmpit'
  prefs: []
  type: TYPE_NORMAL
- en: 'Editing the stack brings up a page where you can make changes directly to the
    stack as if you were making changes to `docker-compose.yml`. Move down to the
    file, find the replicas entry for the web service, and change it to `3` from `2`:![Figure
    9.6: Editing your swarm with Swarmpit'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/B15021_09_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.6: Editing your swarm with Swarmpit'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the `Deploy` button at the bottom of the screen. This will deploy
    the changes to your `test_swarm` stack into the environment and return you to
    the `test_swarm` stack screen, where you should now see `3/3` replicas of the
    web service running:![Figure 9.7: Increased number of web services in Swarmpit'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/B15021_09_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.7: Increased number of web services in Swarmpit'
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that most of the options in Swarmpit are linked. On the `test_swarm`
    stack page, if you click on the web service from the `services` panel, you will
    open the `Service` page for the `test_swarm_web` service. If you click the menu,
    you should see the following page:![Figure 9.8: Managing services with Swarmpit'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/B15021_09_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.8: Managing services with Swarmpit'
  prefs: []
  type: TYPE_NORMAL
- en: Select `Rollback Service` from the menu, and you will see the number of replicas
    of the `test_swarm_web` service roll back to two replicas.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, return to the `Stacks` menu and select the `test_swarm` again. With
    the `test_swarm` stack open, you have the option to delete the stack by clicking
    on the trash can icon toward the top of the screen. Confirm that you would like
    to delete the stack, and this will bring `test_swarm` down again and it will no
    longer be running on your node:![Figure 9.9: Deleting a web service in Swarmpit'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/B15021_09_09.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.9: Deleting a web service in Swarmpit'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Note that Swarmpit will allow you to delete the `swarmpit` stack. You will see
    an error, but when you try to reload the page, it will simply not come up again
    as all the services will have been stopped from running.
  prefs: []
  type: TYPE_NORMAL
- en: Although this has been only a quick introduction to Swarmpit, using your prior
    knowledge from this chapter, the interface will allow you to intuitively deploy
    and make changes to your services and stacks. Almost anything that you can do
    from the command line, you can also do from the Swarmpit web interface. This brings
    us to the end of this exercise and the end of the chapter. The activities in the
    next section of this chapter are designed to help expand your knowledge further.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 9.01: Deploying the Panoramic Trekking App to a Single-Node Docker
    Swarm'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You are required to use Docker Swarm to deploy web and database services in
    the Panoramic Trekking App. You will gather configurations to create a compose
    file for the application and deploy them to a single node Swarm using a `docker-compose.yml`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The steps you will need to take to complete this activity are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Gather all the applications and build the Docker images needed for the services
    of your swarm.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `docker-compose.yml` file that will allow the services to be deployed
    to Docker Swarm.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create any supporting images needed for the services to use once deployed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Deploy your services onto Swarm and verify that all services are able to run
    successfully.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Your running services should look similar to the output shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution for this activity can be found via [this link](B15021_Solution_Final_SMP.xhtml#_idTextAnchor342).
  prefs: []
  type: TYPE_NORMAL
- en: Continue with the next activity as this will work to solidify some of the information
    you have already learned in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 9.02: Performing an Update to the App While the Swarm Is Running'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this activity, you need to make a minor change to the Panoramic Trekking
    App that will allow you to build a new image and deploy the image to the running
    Swarm. In this activity, you will perform a rolling update to deploy these changes
    to your Swarm cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'The steps you''ll need to complete this activity are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: If you do not have the Swarm from *Activity 9.01, Deploying the Panoramic Trekking
    App to a Single Node Docker Swarm* still running, deploy the swarm again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make a minor change to the code in the Panoramic Trekking Appâ€”something small
    that can be tested to verify that you have made a change in your environment.
    The change you are making is not important, so it can be something as basic as
    a configuration change. The main focus of this activity is on performing the rolling
    update to the service.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build a new image to be deployed into the running environment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Perform an update to the environment and verify that the changes were successful.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution for this activity can be found via [this link](B15021_Solution_Final_SMP.xhtml#_idTextAnchor343).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter has done a lot of work in moving our Docker environments from manually
    starting single-image services to a more production-ready and complete environment
    with Docker Swarm. We started this chapter with an in-depth discussion of Docker
    Swarm and how you can manage your services and nodes from the command line, providing
    a list of commands and their use, and later implementing them as part of a new
    environment running a test Django web application.
  prefs: []
  type: TYPE_NORMAL
- en: We then expanded this application further with an NGINX proxy and utilized Swarm
    functionality to store configuration and secrets data so they no longer need to
    be included as part of our Docker image and can instead be included in the Swarm
    we are deploying. We then showed you how to manage your swarm using your web browser
    with Swarmpit, providing a rundown of the work we previously did on the command
    line and making a lot of these changes from a web browser. Swarm is not the only
    way you can orchestrate your environments when using Docker.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will introduce Kubernetes, which is another orchestration
    tool used to manage Docker environments and applications. Here, you will see how
    you can use Kubernetes as part of your projects to help reduce the time you are
    managing services and improve the updating of your applications.
  prefs: []
  type: TYPE_NORMAL
