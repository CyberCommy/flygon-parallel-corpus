- en: Chapter 7. An Advanced Example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By now, you should be able to develop web applications with PDO. However, our
    example application is manageable when it has been kept rather small with limited
    functionality. Soon you will realize that mixing all the data access, user input,
    and display logic in one file can become a hassle to manage.
  prefs: []
  type: TYPE_NORMAL
- en: To write a more manageable code and to allow more than one developer to work
    on a project, the data access user input processing, and page rendering should
    be separated. You have probably heard of the **Model-View-Controller** programming
    paradigm (MVC), which is widely used for big web applications. The idea is to
    keep the data access and modification modules, which is the **Model**, separate
    from data presentation, which is the **View**. The view can be very complex, so
    a template engine is usually used. Finally, the **controller** is a PHP script
    that receives user input, accesses the model, and prepares the view.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to making the code base more manageable, such division allows us
    to access the functionality of the model from other applications (using maintenance
    scripts running on either the application’s own server or on other servers, which
    are accessed via RPC or SOAP calls).
  prefs: []
  type: TYPE_NORMAL
- en: As PDO is object-oriented and can return instances of classes from calls to
    the `PDOStatement::fetch()` method, we will use object-oriented programming to
    model our data entities (books, authors, and borrowed book records).
  prefs: []
  type: TYPE_NORMAL
- en: Designing the Model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Model is usually comprised of a static class (methods of which are called statically),
    and several classes that emulate data entities. Calls to the methods of this Model
    class either return instances of other model classes, or `PDOStatement` instances
    that return instances of model classes in calls to the `fetch()` method.
  prefs: []
  type: TYPE_NORMAL
- en: For our application, the classes will be `Model, Book, Author`, and `Borrower`.
    These classes reflect the tables in our example database and allow us to perform
    simple operations on the underlying data. (The main idea is to isolate SQL from
    the controller scripts into relevant model classes.) For example, the `Book` class
    may have a method to return an `Author` class instance that would represent the
    author for that book. On the other hand, the `Author` class might have a method
    to return a list of `Book` class instances representing each book written by that
    author.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will develop our own static `Model` class along with the
    `Book, Author`, and `Borrower` classes. Before we begin, we should clearly define
    what methods (functionality) every class will have. Let's define the functionality
    of the model.
  prefs: []
  type: TYPE_NORMAL
- en: '`Model` class should contain static methods that will act as *entry points*
    to the data stored in the database. Such methods should do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Get all the books.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get all the authors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get all the book borrowers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get the number of books.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get the number of authors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get the number of book borrowers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get a book by ID.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get an author by ID.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get a borrower by ID.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the other hand, the `Model` class will not contain methods that are performed
    on a book or on an author. To lend a book, we will use a method defined in the
    `Book` class, and to return a book, we will use a method in the `Borrower` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now plan the methods for the `Book` class:'
  prefs: []
  type: TYPE_NORMAL
- en: Get the author.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get a list of the book's borrowers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lend a book.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `Author` class is even simpler for our example application:'
  prefs: []
  type: TYPE_NORMAL
- en: Get all the books.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get the number of books by this author.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, there is the `Borrower` class that represents a record in the borrowers
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: Get the book.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Return the book.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The properties of every data entity will be accessible as instance variables
    of the relevant class. Also, the methods in these classes will contain PDO calls
    that we have already written in `books.php` and other files. We will move these
    methods to the relevant classes, and these files will just act as controllers
    that process user input. Form validation will still be the task of the controller
    scripts. However, we are not going to separate the display logic from the business
    logic, since our application is very simple, and there is no need to use any template
    engine or even to move the page rendering code into a separate **include** file.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to that, we will not be using the global `$conn` variable any more.
    The `Model` class will have a private static variable of the same name and a method
    to retrieve the connection object. This method will follow the singleton pattern
    and create the object on demand if it's not yet created or simply return it if
    it's already intitialized (For more information on the singleton pattern and an
    example implementation in PHP5 you can visit [http://en.wikipedia.org/wiki/Singleton_pattern](http://en.wikipedia.org/wiki/Singleton_pattern).
  prefs: []
  type: TYPE_NORMAL
- en: We will keep all the classes in a separate file, `classes.inc.php`, which will
    then be included from `common.inc.php`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s begin with the central `Model` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this class defines the `getConn()` method that is used to retrieve
    the PDO connection object, as well as nine more methods—three methods for every
    data entity (book, author, and borrower). The methods to get all the data entities
    (`getBooks()`, `getAuthors()`, and `getBorrowers())` return a `PDOStatement` pre-configured
    to fetch instances of relevant classes. The methods to return the number of every
    data entity, fetch an integer, while the method to return a single data entity,
    fetch an instance of the data entity model class. Note how we close cursors in
    these methods—this functionality has been transferred from the controller files.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now look at the three model classes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here we have just two methods. One is used to get the book's author. (Note how
    we reuse the `Model::getAuthor()` method here.) Another method provides the *lend
    book* functionality. Note how we reread the copies column from the database rather
    than rely on the `$this->copies` variable. As we have seen in the previous chapter,
    this is done to ensure data integrity. The `$this->copies` variable gets assigned
    long before the transaction begins, and by the time that the `Book::lend()` method
    is called, the actual count of copies in the database might have changed.
  prefs: []
  type: TYPE_NORMAL
- en: That's why we reread that value inside the transaction again. Also, this method
    returns null if the operation fails or an instance of `Borrower` class if the
    operation is successful. If an error occurs, an exception gets thrown that is
    handled by the exception handler defined in `common.inc.php` (just as it did previously).
  prefs: []
  type: TYPE_NORMAL
- en: 'Another `model` class is `Author`. It''s very simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: These two methods just return the list of books written by this author and the
    number of books in this list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the `Borrower` class represents a record in the borrower''s table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Essentially, the body of the `returnBook()` method is transferred from the `returnBook.php`
    file (just as the `Book::lend()` method was transferred with a slight modification
    from the `lendBook.php` file).
  prefs: []
  type: TYPE_NORMAL
- en: Modifying the Frontend to Use the Model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have removed the data access logic from the files that generate
    frontend pages, let''s see how we should modify them. Let''s start with the `books.php`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we have removed the SQL commands and the calls to the PDO class
    instance methods, and replaced them with corresponding calls to the methods of
    the `Model` class. (Note the highlighted lines.)
  prefs: []
  type: TYPE_NORMAL
- en: Another important change is that the instances of the `Book` class returned
    in the `while` loop (starting on line 30) don't have the variables for the author's
    first or last names. To get these variables, we call the `Book::getAuthor()` method
    for every book that we display. Then, later in the loop, we reference either the
    `$b` variable to access the book's properties or the `$a` variable to access the
    author's details. Note how we access these details as the object variables rather
    than array elements here.
  prefs: []
  type: TYPE_NORMAL
- en: This happened because the `Model::getBooks()` method does not employ table joins
    any more, so the instances of the `Book` class won't contain author details. Instead,
    the `Book` class defines a method to get the `Author` object for that book. This
    means that, for every book that we display, we will execute an extra SQL query
    to get the author's details.
  prefs: []
  type: TYPE_NORMAL
- en: On the first sight this may seem too expensive, performance-wise. But on the
    other hand, in real life application, we would show just one page (say, 20 books)
    from a table of several thousand records. In this case, a `SELECT` statement without
    `JOIN` on the `books` table selecting the rows to be displayed in the current
    page and followed by some simple queries for every row to be displayed may be
    more performance-effective.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if this approach is inappropriate, then the `Model` class can be extended
    with another method, for example, `Model::getBooksWithAuthors()`, that would return
    instances of the `Book` class where the `lastName` and `firstName` variables would
    be present. This method might look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Developing the model part may constrain us in terms of flexibility, but this
    is the price to pay for code manageability. However, this can be overcome with
    additional methods in the model classes or, if this is really necessary, with
    direct communication with PDO. The above method is possible because PDO does not
    care what variables were defined in the class; it just dynamically creates variables
    for every column returned by the query.
  prefs: []
  type: TYPE_NORMAL
- en: This is a very powerful feature when used responsibly. If not used with care,
    you may end up with hard-to-track logical errors. For example, if in the above
    method you selected the `ID` column from the authors table, then its value would
    overwrite the `ID` column value selected from the books table. Other methods in
    the `Book` class rely on the value in the `id` field being correct and may lead
    to severe data corruption if this value is incorrect.
  prefs: []
  type: TYPE_NORMAL
- en: Another file that we should now modify is `authors.php:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here, we just replaced the direct communication with PDO with the call to the
    `Model` class as well as rewrote the loop to use object variables rather than
    array elements.
  prefs: []
  type: TYPE_NORMAL
- en: The changes made to the application also allow us to remove SQL-related code
    bits from `author.php:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The changes here are rather cosmetic, as it just removes the direct communication
    with PDO and changes to the *object* syntax from the *array* syntax on highlighted
    lines.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the last page that shows a list from `borrowers.php:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In this file, we have the same problem as we had with `books.php` page—the `Model`
    class returns instances of the `Borrower` class without the book title and the
    author name, which we want to display on this page. Because of that, we get the
    `Book` class instance for each `Borrower` class instance on every iteration, and
    then use that object to get author details.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we will modify two more pages to make use of our newly created data
    model. These two are `lendBook.php` and `returnBook.php`. They probably contained
    the longest bit of code that interfaced with PDO. From `lendBook.php` we remove
    all the code wrapped within the transaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note how we changed the part that *lends* the book—the `Bool::lend()` method
    returns `null` in case of failure, so we will display a message that there are
    no more books left to lend. If the operation is successful, then `Book::lend()`
    method returns the `Borrower` class instance (which evaluates to `true` in the
    `if` statement) and the page redirects to `books.php`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, we remove the PDO-related code from `returnBook.php` and replace
    it with the corresponding call to the `Borrower::returnBook()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Advantages of Separating the Model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, almost all of the files that generate front-end pages don't contain
    data access logic and are easier to manage. On the other hand, the model classes
    can be used from outside our application, and additional pages can be quickly
    created to represent the information in the database in other formats such as
    XML.
  prefs: []
  type: TYPE_NORMAL
- en: For example, consider the following page (which we will call `books.xml.php):`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This file allows us to export the list of books in XML format for another application.
    As you can see, the changes to the original `books.php` file are only in the display
    logic. If you now navigate to the page, you should see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Advantages of Separating the Model](graphics/2660_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: With a slight modification, we were able to create new representation of our
    data (The second and third books have been collapsed to fit everything on the
    screenshot).
  prefs: []
  type: TYPE_NORMAL
- en: Another advantage of defining `model` classes is that these classes become the
    central point for data access and manipulation. For example, if you change the
    SQL for representing data from several tables (using joins) or find a way to optimize
    a query, you just have to update the relevant model class, and the scripts (controllers)
    that were using that query don't have to get updated. This is a major manageability
    advantage.
  prefs: []
  type: TYPE_NORMAL
- en: You may extend abstract model classes to imitate extended functionality for
    real subclasses in a common data model. For example, in a content management system
    you can create an abstract base class called `Item`, which will have common properties
    for all the subclasses (item types) such as author, keywords, and creation date.
    Then the model can perform some operations for all possible subclasses without
    further coding so that the existing code is extensively reused.
  prefs: []
  type: TYPE_NORMAL
- en: There are tools called **object-relational mappers** (**ORMs**) that make use
    of the ideas described in this chapter. ORMs are used to create powerful object-oriented
    applications where you have virtually no SQL code in you model. (In fact, these
    tools after some configuring play the role of the model in your application.)
    You can read more about ORMs at [http://en.wikipedia.org/wiki/Object-relational_mapping](http://en.wikipedia.org/wiki/Object-relational_mapping).
    Propel ([http://propel.phpdb.org/](http://propel.phpdb.org/)) is a popular ORM
    tool for PHP5.
  prefs: []
  type: TYPE_NORMAL
- en: Further Thoughts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The model developed in this chapter, needs some improvements in at least two
    areas, if you want to use it in a real-life application. We didn''t create methods
    in the model that would provide the functionality of the `editBook.php` and `editAuthor.php`
    files. However, you should now be ready to add this functionality by yourself.
    We will provide you with some tips:'
  prefs: []
  type: TYPE_NORMAL
- en: Create the `Book::update()` and `Author::update()` methods. These methods should
    accept parameters that reflect the properties of each object (for the `Author`
    class, this should be first name, last name, and biography).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These methods should use prepared statements to update the corresponding records
    in the database (based on the `$this->id` value).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `Model` class should be extended with two more methods, `Model::createBook()`
    and `Model::createAuthor()`. These methods should accept the same list of parameters
    as `Book::update()` and `Author::update()`. Both should insert a row based on
    the passed parameters, into the relevant table. This can be done with the following
    code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The idea here is to concentrate entity updating in a single place, namely `Author::update()`.
    We employ a transaction here to ensure that, if anything happens, the empty row
    is not stored in the database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The form processing code should detect whether it's editing an existing entity
    or creating a new one and call `Model::createAuthor()` or `Author::update()` on
    an already existing instance appropriately.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another problem is that, the methods of the model classes do not validate accepted
    parameters. They should provide validation of every parameter passed to the database
    if you are going to expose your data model to third-party applications. If accessed
    via web browser, our data model is protected by the form validation code. However,
    direct access to the model classes is not as secure.
  prefs: []
  type: TYPE_NORMAL
- en: It is advisable to throw an exception from the model methods that accept user-supplied
    parameters in case the validation fails. Also, web form validation and method
    parameter validation should use common code. (For example, you might develop a
    `Validation` class that could be used to validate values regardless of where they
    come from.) This code should be used from within the form validation code and
    model methods. By doing this, so you will assure code reuse and a single place
    for the validation rules.
  prefs: []
  type: TYPE_NORMAL
- en: Finishing Up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PHP Data Objects is a great and easy-to-use technology. However, it's still
    in its infancy and many improvements and other changes are yet to come. Be sure
    to keep yourself updated with the latest news from PHP developers and from the
    large community of PHP fans and users.
  prefs: []
  type: TYPE_NORMAL
- en: Effective use of PDO and PHP in general, is possible only with a sound understanding
    of security threats and how to protect against them. Using PDO's prepared statements
    diminishes the risk of SQL injection attacks, but you, the developer, are still
    responsible for securing your application. Make sure that you keep track of the
    latest developments in the security field.
  prefs: []
  type: TYPE_NORMAL
- en: Happy PHP-ing!
  prefs: []
  type: TYPE_NORMAL
