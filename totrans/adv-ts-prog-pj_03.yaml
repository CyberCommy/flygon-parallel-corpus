- en: A React Bootstrap Personal Contacts Manager
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个React Bootstrap个人联系人管理器
- en: In this chapter, we are going to learn how to build a personal contacts manager
    using React, which is a library for building **user interfaces** (**UIs**) out
    of small components. By learning React, you will gain the ability to use one of
    the most popular libraries currently in use, as well as begin to understand how
    and when to use the power of binding to simplify your code.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何使用React构建个人联系人管理器，它是一个用于构建**用户界面**（**UI**）的小组件库。通过学习React，您将获得使用当前最流行的库之一的能力，并开始了解何时以及如何使用绑定的力量来简化您的代码。
- en: Exploring React will help us to understand how to write a modern application
    for the client side and also study its requirements.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 探索React将帮助我们了解如何为客户端编写现代应用程序，并研究其要求。
- en: 'To help us to develop the application, the following topics will be covered
    in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助我们开发应用程序，本章将涵盖以下主题：
- en: Creating a mock layout to check our layouts
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个模拟布局来检查我们的布局
- en: Creating our React application
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建我们的React应用程序
- en: Analyzing and formatting code with `tslint`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`tslint`分析和格式化代码
- en: Adding Bootstrap support
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加Bootstrap支持
- en: Using tsx components in React
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在React中使用tsx组件
- en: The `App` component in React
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React中的`App`组件
- en: Displaying our personal details UI
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 展示我们的个人详细信息UI
- en: Using binding to simplify our updates
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用绑定简化我们的更新
- en: Creating validators and applying them as validation
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建验证器并将它们应用为验证
- en: Applying validation in a React component
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在React组件中应用验证
- en: Creating and sending data to an IndexedDB database
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建并将数据发送到IndexedDB数据库
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: As we are using an IndexedDB database to store data, a modern web browser such
    as Chrome (version 11 or later) or Firefox (version 4 or later) will be required.
    The finished project can be downloaded from [https://github.com/PacktPublishing/Advanced-TypeScript-3-Programming-Projects/tree/master/chapter03](https://github.com/PacktPublishing/Advanced-TypeScript-3-Programming-Projects/tree/master/chapter03).
    After downloading the project, you will have to install the package requirements
    using `npm install`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用IndexedDB数据库来存储数据，将需要一个现代的网络浏览器，如Chrome（11版或更高版本）或Firefox（4版或更高版本）。完成的项目可以从[https://github.com/PacktPublishing/Advanced-TypeScript-3-Programming-Projects/tree/master/chapter03](https://github.com/PacktPublishing/Advanced-TypeScript-3-Programming-Projects/tree/master/chapter03)下载。下载项目后，您将需要使用`npm
    install`安装软件包要求。
- en: Understanding the project overview
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解项目概述
- en: 'We are going to build a personal contacts manager database using React. The
    data is stored locally on the client using the standard IndexedDB database. When
    we have finished, our application will look like the following:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用React构建一个个人联系人管理器数据库。数据存储在客户端上，使用标准的IndexedDB数据库。完成后，我们的应用程序将如下所示：
- en: '![](assets/d5353a60-f978-4180-bf0b-a86ad7ce205c.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/d5353a60-f978-4180-bf0b-a86ad7ce205c.png)'
- en: You should be able to complete the steps in this chapter, working alongside
    the code in the GitHub repository, in approximately two hours.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该能够在本章中完成这些步骤，与GitHub存储库中的代码一起工作，大约需要两个小时。
- en: Getting started with the components
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用组件
- en: 'This chapter relies on Node.js, which is available at [https://nodejs.org/](https://nodejs.org/).
    As we progress through the chapter, we will install the following components:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 本章依赖于Node.js，可在[https://nodejs.org/](https://nodejs.org/)上获得。随着我们在本章中的进展，我们将安装以下组件：
- en: '`@types/bootstrap` (4.1.2 or later)'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@types/bootstrap`（4.1.2或更高版本）'
- en: '`@types/reactstrap` (6.4.3 or later)'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@types/reactstrap`（6.4.3或更高版本）'
- en: '`bootstrap` (4.1.3 or later)'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bootstrap`（4.1.3或更高版本）'
- en: '`react` (16.6.3 or later)'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`react`（16.6.3或更高版本）'
- en: '`react-dom` (16.6.3 or later)'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`react-dom`（16.6.3或更高版本）'
- en: '`react-script-ts` (3.1.0 or later)'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`react-script-ts`（3.1.0或更高版本）'
- en: '`reactstrap` (6.5.0 or later)'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reactstrap`（6.5.0或更高版本）'
- en: '`create-react-app` (2.1.2 or later)'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`create-react-app`（2.1.2或更高版本）'
- en: Creating a React Bootstrap project with TypeScript support
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个带有TypeScript支持的React Bootstrap项目
- en: 'As we discussed in [Chapter 2](3593e33f-7490-47b6-b129-ab5e08aef1b0.xhtml),
    *Creating a Markdown Editor with TypeScript,* it is a good idea to start off by
    gathering the requirements of the application that we are going to write. Here are
    the requirements for this chapter:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第2章](3593e33f-7490-47b6-b129-ab5e08aef1b0.xhtml)中讨论的*使用TypeScript创建Markdown编辑器*，最好的方法是首先收集我们将要编写的应用程序的需求。以下是本章的要求：
- en: The user will be able to create new details of a person or edit them
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户将能够创建一个人的新详细信息或编辑它们
- en: These details will be saved to a client-side database
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些详细信息将保存到客户端数据库
- en: The user will be able to load the list of all people
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户将能够加载所有人的列表
- en: The user will be able to delete the personal details of a person
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户将能够删除一个人的个人详细信息
- en: The personal details will consist of the first and last names, the address (made
    up of two address lines, the town, the county, and the zip code), the phone number,
    and the date of birth
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 个人详细信息将包括名字和姓氏、地址（由两个地址行、城镇、县和邮政编码组成）、电话号码和出生日期。
- en: The personal details will be saved to the database
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 个人详细信息将保存到数据库中
- en: The first name will be at least one character and the last name will be at least
    two characters
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名字至少为一个字符，姓氏至少为两个字符
- en: Address line 1, town, and county will be at least five characters
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 地址行1、城镇和县至少为五个字符
- en: The zip code will conform to the American standard for most zip codes
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 邮政编码将符合大多数邮政编码的美国标准
- en: The phone number will conform to the standard American phone format
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电话号码将符合标准的美国电话格式
- en: The user can clear details with the click of a button
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户可以通过点击按钮清除详细信息
- en: Creating our mock layout
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们的模拟布局
- en: Once we have our requirements, it is normally a good idea to draw up some rough
    drafts of what we think the layout of our application should be. What we want
    to do is to create a layout that shows we are using a web browser layout in a
    sketch format. The reason we want it to look as though it is sketched is because
    of the way we interact with our clients. We want them to get an idea about the
    rough layout of our application without getting caught up in details such as exactly
    how wide a particular button is.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了我们的要求，通常最好草拟一些我们认为应用程序布局应该是什么样的草图。我们想做的是创建一个布局，显示我们正在使用网页浏览器布局的草图格式。我们希望它看起来像是草绘的，因为我们与客户互动的方式。我们希望他们能够了解我们应用程序的大致布局，而不会陷入诸如特定按钮有多宽等细节中。
- en: 'What is particularly useful is the ability to use a tool such as [https://ninjamock.com](https://ninjamock.com)/
    to create a wireframe sketch of our interface. These sketches can be shared online
    with clients or other team members who can directly add comments. The following
    sketch diagram demonstrates what we want our interface to look like when we are
    finished:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 特别有用的是使用诸如[https://ninjamock.com](https://ninjamock.com)这样的工具来创建我们界面的线框草图。这些草图可以在线与客户或其他团队成员共享，并直接添加评论。以下草图示意了我们完成后希望我们的界面看起来的样子：
- en: '![](assets/22334fc2-a57c-47ec-88b6-7ea1a5f928cc.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/22334fc2-a57c-47ec-88b6-7ea1a5f928cc.png)'
- en: Creating our application
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们的应用程序
- en: 'Before we can begin writing our code, we need to install React. While it is
    possible to create the infrastructure we need for React manually, most people
    use the `create-react-app` command to create a React application. We aren''t going
    to do this any differently, so we are also going to use the `create-react-app` command. React
    does not use TypeScript by default so we are going to add a little bit extra to
    the command we use to create our application to give us all the TypeScript capacity
    that we need. We use `create-react-app`, giving it the name of our application
    and an extra `scripts-version` parameter that hooks in TypeScript for us:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编写代码之前，我们需要安装React。虽然可以手动创建我们需要的React基础设施，但大多数人使用`create-react-app`命令来创建React应用程序。我们不会做任何不同的事情，所以我们也将使用`create-react-app`命令。React默认不使用TypeScript，因此我们将在用于创建应用程序的命令中添加一些额外的内容，以为我们提供所有需要的TypeScript功能。我们使用`create-react-app`，给它我们应用程序的名称和一个额外的`scripts-version`参数，为我们挂接TypeScript：
- en: '[PRE0]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If you have installed Node.js packages before, you may think that there is a
    mistake in the preceding command and that we should be using `npm` to install
    `create-react-app`. However, we are using `npx` in place of `npm` because `npx`
    is an enhanced version of the **Node Package Manager** (**NPM**). With `npx`,
    we missed out the need to run `npm install create-react-app` to install the `create-react-app`
    package before manually running `create-react-app` to start the process. The use
    of `npx` does help to speed up our development workflow.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您以前安装过Node.js包，您可能会认为在前面的命令中有一个错误，并且我们应该使用`npm`来安装`create-react-app`。但是，我们使用`npx`代替`npm`，因为`npx`是**Node
    Package Manager**（**NPM**）的增强版本。使用`npx`，我们省去了运行`npm install create-react-app`来安装`create-react-app`包，然后手动运行`create-react-app`来启动进程的步骤。使用`npx`确实有助于加快我们的开发工作流程。
- en: 'Once our application has been created, we open the `Chapter03` directory and
    run the following command:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 创建完我们的应用程序后，我们打开`Chapter03`目录并运行以下命令：
- en: '[PRE1]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Assuming that we have a default browser set, it should be opened to `http://localhost:3000`,
    which is the default web page for this application. This will serve up a standard
    web page that just happens to contain a default React sample. What we are going
    to do now is edit the `public/index.html` file and set a title for it. We are
    going to set our title to `Advanced TypeScript - Personal Contacts Manager`. While
    the contents of this file appear to be sparse, they contain everything that we
    need on our HTML side, namely, a `div` element called `root`. This is the hook that
    our React code will hang off, as we will discuss later. We can live edit our application
    so that any changes we make will be compiled and served back to the browser automatically:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们已经设置了默认浏览器，它应该打开到`http://localhost:3000`，这是该应用程序的默认网页。这将提供一个包含默认React示例的标准网页。现在我们要做的是编辑`public/index.html`文件并为其设置一个标题。我们将把我们的标题设置为`Advanced
    TypeScript - Personal Contacts Manager`。虽然这个文件的内容看起来很少，但它包含了我们在HTML方面所需要的一切，即一个名为`root`的`div`元素。这是我们的React代码将依附的挂钩，我们稍后会讨论。我们可以实时编辑我们的应用程序，以便我们所做的任何更改都将被编译并自动返回到浏览器：
- en: '[PRE2]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Formatting our code using tslint
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用tslint格式化我们的代码
- en: 'Once we have created our application, we are using something called `tslint`,
    which analyzes our code by looking for potential problems. Note that support for
    this was automatically added when we created our application. The `tslint` version
    that runs applies a very aggressive set of rules against which we check our code.
    I have gone with the full set of `tslint` rules in my code base; however, if you
    want to relax the rules a bit, you just need to change the `tslint.json` file
    to something like the following:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建了我们的应用程序，我们使用了一个叫做`tslint`的东西，它通过查找潜在问题来分析我们的代码。请注意，当我们创建我们的应用程序时，对此的支持已经自动添加。运行的`tslint`版本应用了一套非常激进的规则，我们检查我们的代码是否符合这些规则。我在我的代码库中使用了完整的`tslint`规则集；但是，如果您想放松规则，只需将`tslint.json`文件更改为以下内容：
- en: '[PRE3]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Adding Bootstrap support
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加Bootstrap支持
- en: 'One of the things we need to do with our application is bring in support for
    Bootstrap. This is not something that is provided *out of the box* with React,
    so we need to add this capacity using other packages:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序需要做的一件事是引入对Bootstrap的支持。这不是React默认提供的功能，因此我们需要使用其他包添加这个功能：
- en: 'Install Bootstrap as follows:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装Bootstrap如下：
- en: '[PRE4]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'With this in place, we are now free to use a React-ready Bootstrap component.
    We are going to use the `reactstrap` package because this package targets Bootstrap
    4 in a React-friendly fashion:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有了这个，我们现在可以自由地使用一个React-ready的Bootstrap组件。我们将使用`reactstrap`包，因为这个包以React友好的方式针对Bootstrap
    4：
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`reactstrap` is not a TypeScript component, so we need to install the `DefinitelyTyped`
    definition for this and for Bootstrap:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`reactstrap`不是一个TypeScript组件，所以我们需要安装这个和Bootstrap的`DefinitelyTyped`定义：'
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'With this in place, we can now add the Bootstrap CSS files. To do this, we
    are going to update the `index.tsx` file by adding a reference to our locally
    installed Bootstrap CSS file, by adding the following `import` to the very top
    of the file:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有了这个，我们现在可以添加Bootstrap CSS文件。为了做到这一点，我们将通过在`index.tsx`文件中添加对我们本地安装的Bootstrap
    CSS文件的引用，添加以下`import`到文件的顶部：
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, we are using the local Bootstrap file for convenience. As we discussed
    in [Chapter 1](56be9c18-a050-4794-bbd6-c51cd62f8f35.xhtml), *Advanced TypeScript
    Features,* we want to change this to use a CDN source for the production version
    of this application.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用本地的Bootstrap文件是为了方便。正如我们在[第1章](56be9c18-a050-4794-bbd6-c51cd62f8f35.xhtml)中讨论的*高级TypeScript特性*，我们希望将其更改为在生产版本中使用CDN源。
- en: 'To tidy up, remove the following line from `src/index.tsx` and then remove
    the matching `.css` file from the disk:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了整理一下，从`src/index.tsx`中删除以下行，然后从磁盘中删除匹配的`.css`文件：
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: React using tsx components
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React使用tsx组件
- en: One question that you might have right now is why does the index file have a
    different extension? That is, why is it `.tsx` and not `.ts`? To answer these
    questions, we have to change our mental image of the extension slightly and talk
    about why React uses `.jsx` files and not `.js` (the `.tsx` version is the TypeScript
    equivalent of `.jsx`).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可能会问一个问题，为什么索引文件有不同的扩展名？也就是说，为什么是`.tsx`而不是`.ts`？要回答这些问题，我们必须稍微改变我们对扩展的心智形象，并谈谈为什么React使用`.jsx`文件而不是`.js`（`.tsx`版本是`.jsx`的TypeScript等价物）。
- en: These JSX files are extensions of JavaScript that get transpiled to JavaScript.
    If you were to try and run them *as is* in JavaScript, then you would get runtime
    errors if they contained any of these extensions. In traditional React, there
    is a transpilation phase that takes the JSX file and converts it to JavaScript
    by expanding out the code to standard JavaScript. Effectively, this is a form
    of the compilation phase that we get from TypeScript anyway. With TypeScript React,
    we get the same end result where the TSX file ultimately ends up as a JavaScript
    file.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这些JSX文件是JavaScript的扩展，会被转译成JavaScript。如果你试图在JavaScript中直接运行它们，那么如果它们包含任何这些扩展，你将会得到运行时错误。在传统的React中，有一个转译阶段，它会将JSX文件转换为JavaScript，通过将代码扩展为标准的JavaScript。实际上，这是一种我们从TypeScript中得到的编译阶段。使用TypeScript
    React，我们得到了相同的结果，TSX文件最终会成为JavaScript文件。
- en: 'So, the question now is why do we actually need these extensions? To answer
    this, we are going to analyze the `index.tsx` file. This is what the file looks
    like with our Bootstrap CSS file added:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，现在的问题是为什么我们实际上需要这些扩展？为了回答这个问题，我们将分析`index.tsx`文件。这是我们添加了Bootstrap CSS文件后文件的样子：
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `import` statements should be familiar to us by now and `registerServiceWorker`
    is the behavior that is added to the code to provide a faster production application
    by serving assets from a cache, rather than reloading them time and time again.
    One of the key tenets of React is that it should be as fast as possible and that's
    where `ReactDOM.render` comes in. If we read this piece of code, things should
    become clear. What it is doing is looking for the element marked as root in the
    HTML page we serve up—we saw this in the `index.html` file. The reason we use
    the `as HTMLElement` syntax here is that we want to let TypeScript know what type
    this is (this parameter either has to derive from an element or be null—yes, that
    does mean that underlying this is a union type).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`import`语句现在应该对我们来说很熟悉，`registerServiceWorker`是添加到代码中的行为，通过从缓存中提供资产，而不是一次又一次地重新加载它们，来提供更快的生产应用程序。React的一个关键原则是它应该尽可能快，这就是`ReactDOM.render`的作用所在。如果我们阅读这段代码，事情应该变得清晰。它正在寻找在我们提供的HTML页面中标记为根的元素——我们在`index.html`文件中看到了这一点。我们在这里使用`as
    HTMLElement`语法的原因是我们想让TypeScript知道这是什么类型（这个参数要么派生自一个元素，要么为空——是的，这意味着底层是一个联合类型）。'
- en: Now, the reason we need a special extension is because of the piece of code
    that says `<App />`. What we are doing here is inlining a piece of XML code into
    our statement. In this particular instance, we are telling our `render` method
    to render out a component called `App`, that has been defined in the `App.tsx` file.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要一个特殊的扩展的原因是因为代码中有一个说`<App />`的部分。我们在这里所做的是将一段XML代码嵌入到我们的语句中。在这个特定的例子中，我们告诉我们的`render`方法渲染一个名为`App`的组件，这个组件在`App.tsx`文件中被定义。
- en: How React uses a virtual DOM to be more responsive
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React如何使用虚拟DOM来提高响应性
- en: I glossed over why the `render` method is used, so now is the time to address
    React's secret weapon, that is, the virtual **Document Object Model** (**DOM**).
    If you've been developing web applications for a while, you are probably aware
    of the DOM.  If you have never encountered this, the DOM is an entity that describes
    exactly what a web page will look like. Web browsers rely very heavily on the
    DOM, and, as it has grown organically over the years, it can be pretty unwieldy.
    There is only so much that browser manufacturers can do to try and speed up the
    DOM. If they want to be able to serve up old web pages, then they have to support
    the full DOM.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我略过了为什么使用`render`方法，现在是时候解释一下React的秘密武器，也就是虚拟**文档对象模型**（**DOM**）。如果你已经开发了一段时间的Web应用程序，你可能已经了解了DOM。如果你从未遇到过这个，DOM是一个描述网页将会是什么样子的实体。Web浏览器非常依赖DOM，并且随着多年的发展，它可能变得相当笨重。浏览器制造商只能尽力加快DOM的速度。如果他们想要能够提供旧的网页，那么他们必须支持完整的DOM。
- en: The virtual DOM is a light weight copy of the standard DOM. The reason it is
    lighter in weight is that it misses out a major feature of the standard DOM; that
    is, it doesn't have to render out to the screen. When React runs the `render`
    method, it traverses each `.tsx` (or `.jsx` in JavaScript) file and executes the
    rendering code there. It then compares this rendered code to a copy of the last
    render that was run to work out exactly what has changed. Only those changed elements
    are updated on the screen. This comparison stage is the reason we have to use
    a virtual DOM. It's much faster to tell what elements need updating using this
    approach, and only those elements that get changed need to be updated.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟DOM是标准DOM的轻量级副本。它之所以轻量级是因为它缺少标准DOM的一个重要特性；也就是说，它不必呈现到屏幕上。当React运行`render`方法时，它遍历每个`.tsx`（或JavaScript中的`.jsx`）文件并在那里执行渲染代码。然后将此渲染代码与上次运行的渲染的副本进行比较，以确定确切发生了什么变化。只有那些发生变化的元素才会在屏幕上更新。这个比较阶段是我们必须使用虚拟DOM的原因。使用这种方法更快地告诉哪些元素需要更新，只有那些发生变化的元素才需要更新。
- en: Our React App component
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们的React App组件
- en: 'We have already touched on the use of components in React. By default, we will
    always have an `App` component. This is the component that will be rendered to
    the root element in our HTML. Our components derive from `React.Component`, so
    the start of our `App` component looks like the following:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经提到了React中组件的使用。默认情况下，我们将始终有一个`App`组件。这是将呈现到我们HTML根元素的组件。我们的组件源自`React.Component`，因此我们的`App`组件的开头看起来像下面这样：
- en: '[PRE10]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Of course, our component requires a well-known method to trigger the rendering
    of the component. It will not come as much of a surprise to learn that the method
    is called `render`. As we are using Bootstrap to display our UI, we want to be
    rendering out a component that relates to our `Container` div. To do this, we
    are going to use a `Container` component from `reactstrap` (and introduce the
    core component that we are going to use to display our interface):'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们的组件需要一个常用的方法来触发组件的渲染。毫不奇怪，这个方法被称为`render`。由于我们正在使用Bootstrap来显示我们的UI，我们希望呈现一个与我们的`Container`
    div相关的组件。为此，我们将使用`reactstrap`中的`Container`组件（并引入我们将用于显示界面的核心组件）：
- en: '[PRE11]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Displaying the personal details interface
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示个人详细信息界面
- en: 'We are going to create a class called `PersonalDetails`. This class is going
    to render out the core of our interface inside the `render` method. Again, we
    are using `reactstrap` to lay out the various parts of the interface. Before we
    break down the intricacies of what our `render` method does, let''s take a look
    at what this all looks like:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个名为`PersonalDetails`的类。这个类将在`render`方法中呈现出我们界面的核心。同样，我们使用`reactstrap`来布置界面的各个部分。在我们分解`render`方法的复杂性之前，让我们先看看这一切是什么样子：
- en: '[PRE12]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'As you can see, there''s a lot going on in this method; however, the vast majority
    of it is repeated code used to replicate the row and column Bootstrap elements.
    If we take a look at the layout for the `postcode` and `phoneNumber` elements,
    for instance, we can see that we are laying out two rows with two explicit columns
    in each. In Bootstrap terms, one of these `Col` elements is a large size of three
    and the other one is a large size of four (we will leave it to Bootstrap to factor
    in the empty column that remains):'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，这个方法中有很多事情要做；然而，其中绝大部分是重复的代码，用于复制行和列的Bootstrap元素。例如，如果我们看一下`postcode`和`phoneNumber`元素的布局，我们会发现我们正在布置两行，每行有两个显式的列。在Bootstrap术语中，其中一个`Col`元素是三个大尺寸，另一个是四个大尺寸（我们将留给Bootstrap来考虑剩下的空列）：
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Looking at the label and input elements, we can see that there are two unfamiliar
    elements. Surely, the correct key in a label is `for` and we should use `class`
    to refer to a CSS class in our input? The reason we have replacement keys here
    is that `for` and `class` are JavaScript keywords. As React allows us to mix the
    code and markup language inside a render, React has to use different keywords.
    This means that we use `htmlFor` to replace `for` and `className` to replace `class`.
    Going back to when we talked about the virtual DOM, this gives us a major hint
    that these HTML elements are copies that serve a similar purpose, rather than
    the elements themselves.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 看着标签和输入元素，我们可以看到有两个不熟悉的元素。当然，在标签中正确的键是`for`，我们应该在输入中使用`class`来引用CSS类？我们在这里使用替代键的原因是`for`和`class`是JavaScript关键字。由于React允许我们在渲染中混合代码和标记语言，React必须使用不同的关键字。这意味着我们使用`htmlFor`来替换`for`，使用`className`来替换`class`。回到我们谈论虚拟DOM时，这给了我们一个重要的提示，即这些HTML元素是用于类似目的的副本，而不是元素本身。
- en: Simplify updating values with binding
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用绑定简化更新值
- en: One feature of many modern frameworks is the use of binding to remove the need
    to manually update inputs or trigger events. The idea behind using a binding is
    that the framework establishes a connection between a UI element and the code,
    such as a property, watches for changes to the underlying values, and then triggers
    updates when it detects a change. When done correctly, this removes a lot of drudgery
    from writing our code and, more importantly, helps to reduce errors.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 许多现代框架的一个特性是使用绑定来消除手动更新输入或触发事件的需要。使用绑定的想法是，框架在UI元素和代码之间建立连接，例如属性，监视基础值的变化，然后在检测到变化时触发更新。正确使用时，这可以减少我们编写代码的繁琐工作，更重要的是有助于减少错误。
- en: Supplying state to bind against
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提供要绑定的状态
- en: 'The idea behind binding with React is that we have a state that we need to
    bind to. In the case of creating data that we want to display on the screen, our
    state can be as simple as an interface describing the properties that we want
    to use. For a single contact, this translates to our state looking like this:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 使用React进行绑定的想法是我们有一个需要绑定的状态。对于创建要在屏幕上显示的数据，我们的状态可以简单地是描述我们要使用的属性的接口。对于单个联系人，这将转化为我们的状态看起来像这样：
- en: '[PRE14]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Note that we have created a union type called `StringOrNull` as a convenience.
    We will place this in a file called `Types.tsx` so that it looks like this:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们创建了一个名为`StringOrNull`的联合类型作为一种便利。我们将把它放在一个名为`Types.tsx`的文件中，使其看起来像这样：
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'What we want to do now is tell our component what state it is going to use.
    The first thing to do is update our class definition so that it looks like this:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们要做的是告诉我们的组件它将使用什么状态。首先要做的是更新我们的类定义，使其看起来像这样：
- en: '[PRE16]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This follows the convention where the properties are passed into our class from
    the parent and the state comes from our local component. This separation of properties
    and state is important to us because it provides us with a way for the parent
    to communicate with the component (and for the component to communicate back with
    the parent), while still being able to manage the data and behaviors that our
    component wants as the state.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这遵循了一个惯例，即属性从父级传递到我们的类中，而状态来自我们的本地组件。这种属性和状态的分离对我们很重要，因为它为父组件与子组件之间的通信提供了一种方式（以及子组件与父组件之间的回传），同时仍然能够管理组件作为状态所需的数据和行为。
- en: Here, our properties are defined in an interface called `IProps`. Now that we
    have told React what the *shape* of our state is going to be internally, React
    and TypeScript use this to create a `ReadOnly<IPersonState>` property. Therefore,
    it is important to ensure that we are using the right state. If we use the wrong
    type for our state, TypeScript will inform us of this.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们的属性在一个名为`IProps`的接口中定义。现在我们已经告诉React我们的状态的*形状*将会是什么，React和TypeScript会用这个信息创建一个`ReadOnly<IPersonState>`属性。因此，确保我们使用正确的状态是很重要的。如果我们对状态使用了错误的类型，TypeScript会通知我们这一点。
- en: Note that there is a caveat to that preceding statement. If we have two interfaces
    of exactly the same shape, then TypeScript treats them as equivalent to each other.
    So, even though TypeScript is expecting `IState`, if we supply something called
    `IMyOtherState` that has exactly the same properties, then TypeScript will happily
    let us use that in its place. The question, of course, is why would we want to
    duplicate the interface in the first place? I cannot think of many cases where
    we would want to do that, so the idea of using the right state is accurate for
    almost all the cases we are ever likely to encounter.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，前面的陈述有一个警告。如果我们有两个完全相同形状的接口，那么TypeScript会将它们视为等价的。因此，即使TypeScript期望`IState`，如果我们提供了一个名为`IMyOtherState`的东西，它具有完全相同的属性，那么TypeScript也会乐意让我们使用它。当然，问题是，为什么我们要首先复制接口呢？我想不出很多情况下我们会这样做，所以使用正确的状态的想法几乎适用于我们可能遇到的所有情况。
- en: 'Our `app.tsx` file is going to create a default for the state and pass this
    to our component as its property. The default state is the one that will be applied
    when the user presses clear to clear the currently edited entry, or New Person
    to start adding a new person. Our `IProps` interface looks like this:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`app.tsx`文件将会为状态创建一个默认值，并将其作为属性传递给我们的组件。默认状态是当用户按下清除按钮清除当前编辑的条目，或者按下新建人员按钮开始添加新人员时将会应用的状态。我们的`IProps`接口看起来是这样的：
- en: '[PRE17]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Something that may seem slightly confusing at first is a potential contradiction
    between my earlier statement the idea that the properties and state are different—with
    state being something that is local to the component and yet we are passing state
    down as part of the properties. I deliberately use state as part of the name to
    reinforce the fact that this represents the state. The values that we are passing
    in can be called anything at all. They do not have to represent any state; they
    could simply be functions that the component calls to trigger some response in
    the parent. Our component will receive this property and it will be its responsibility
    to convert any part that it needs into state.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 一开始可能会有些令人困惑的是，我之前的陈述和属性和状态是不同的这个想法之间存在潜在的矛盾——状态是组件本地的东西，但我们将状态作为属性的一部分传递下去。我故意在名称中使用状态的一部分来强调这一点。我们传递的值可以是任何东西。它们不必代表任何状态；它们可以只是组件调用以触发父级响应的函数。我们的组件将接收这个属性，并且它将负责将其需要的任何部分转换为状态。
- en: 'With this in place, we are ready to change our `App.tsx` file to create our
    default state and to pass this into our `PersonalDetails` component. As we can
    see in the following code, the property from the `IProps` interface becomes a
    parameter in the `<PersonalDetails ..` line. The more items we add to our properties
    interface, the more parameters we will have to add to this line:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们就可以准备改变我们的`App.tsx`文件，创建我们的默认状态，并将其传递给我们的`PersonalDetails`组件。正如我们在下面的代码中所看到的，`IProps`接口中的属性成为了`<PersonalDetails
    ..`行中的一个参数。我们向我们的属性接口添加更多的项目，我们就需要在这一行中添加更多的参数：
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Date handling with JavaScript can be off-putting when we want to hook the date
    into a date picker component. The date picker expects to receive the date in the
    format of YYYY-MM-DD. So, we use the `new Date().toISOString().substring(0,10)` syntax
    to get today's date, which includes a time component, and only retrieve the YYYY-MM-DD
    portion from this. Even though the date picker expects the date to be in this
    format, it does not say that this is the format that will be displayed on the
    screen. The format on your screen should respect the local settings of the user.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要将日期挂接到日期选择器组件时，使用JavaScript处理日期可能会让人望而却步。日期选择器期望以YYYY-MM-DD的格式接收日期。因此，我们使用`new
    Date().toISOString().substring(0,10)`语法来获取今天的日期，其中包括一个时间组件，并且只从中检索YYYY-MM-DD部分。尽管日期选择器期望日期以这种格式呈现，但它并没有规定这是屏幕上显示的格式。屏幕上的格式应该遵守用户的本地设置。
- en: What was interesting about the changes we made to support passing in properties
    is that we have already seen binding in action here. Inside the `render` method,
    where we set `Default={this.defaultPerson}`, we are using binding. With the use
    of `{ }` here, we are telling React that we want to bind to something, whether
    it's to a property or an event. We will encounter binding a lot in React.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，我们对支持传递属性所做的更改已经在这里看到了绑定的作用。在`render`方法中，我们设置`Default={this.defaultPerson}`时，我们正在使用绑定。在这里使用`{}`，我们告诉React我们想要绑定到某些东西，无论是属性还是事件。我们在React中会经常遇到绑定。
- en: 'Now we are going to add a constructor to `PersonalDetails.tsx` to support the
    property that is being passed in from `App.tsx`:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将在`PersonalDetails.tsx`中添加一个构造函数，以支持从`App.tsx`传入的属性：
- en: '[PRE19]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We are doing two things here. First, we are setting up a default state to go
    back to if we need to, which we received from our parent; second, we are setting
    up the state for this page. We didn't have to create a state property in our code
    as this is provided for us by `React.Component`. This is the final part of learning
    how we have tied our property from the parent to the state.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里做两件事。首先，我们正在设置一个默认状态，以便在需要时返回到我们从父级那里收到的状态；其次，我们正在为此页面设置状态。我们不必在我们的代码中创建一个状态属性，因为这是由`React.Component`为我们提供的。这是学习如何将我们的属性从父级绑定到状态的最后一部分。
- en: Changes to state will not be reflected back in the parent props. If we wanted
    to explicitly set a value back in the parent component, this would require us
    to trigger a change to `props.DefaultState`. I advise against doing this directly
    if you can possibly avoid it.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 对状态的更改不会反映在父级props中。如果我们想要明确地将一个值设置回父组件，这将要求我们触发对`props.DefaultState`的更改。如果可能的话，我建议不要直接这样做。
- en: 'Right. Let''s set up our first name and last name elements to work with the
    binding from our state. The idea here is that if we update the state of the first
    or last names in our code, this will automatically be updated in our UI. So, let''s
    change the entries as required:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。让我们设置我们的名字和姓氏元素，使其与我们状态的绑定一起工作。这里的想法是，如果我们在代码中更新名字或姓氏的状态，这将自动在我们的UI中更新。因此，让我们根据需要更改条目：
- en: '[PRE20]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, if we run our application, we have entries that are bound to the underlying
    state. There is, however, an issue with this code. If we try to type into either
    textbox, we will see that nothing happens. The actual text entry is rejected.
    That does not mean we have done anything wrong, rather we only have part of the
    overall picture here. What we need to understand is that React provides us with
    a read-only version of the state. If we want our UI to update our state, we have
    to explicitly opt into this by reacting to changes and then setting the state
    as appropriate. First, we are going to write an event handler to handle setting
    the state when the text changes:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们运行我们的应用程序，我们会发现条目已绑定到底层状态。然而，这段代码存在一个问题。如果我们尝试在任一文本框中输入，我们会发现没有任何反应。实际的文本输入被拒绝了。这并不意味着我们做错了什么，而是我们只是在这里看到了整体图片的一部分。我们需要理解的是，React为我们提供了一个只读版本的状态。如果我们希望我们的UI更新我们的状态，我们必须通过对变化做出反应，然后适当地设置状态来明确地选择这一点。首先，我们将编写一个事件处理程序来处理文本更改时的状态设置：
- en: '[PRE21]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'With this in place, we can now update our input to trigger this update using
    the `onChange` attribute. Again, we are going to use binding to match the `onChange`
    event to the code that is triggered as a result:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个设置，我们现在可以使用`onChange`属性更新我们的输入以触发此更新。同样，我们将使用绑定将`onChange`事件与作为结果触发的代码匹配：
- en: '[PRE22]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'From this code, we can clearly see that `this.state` provides us with access
    to the underlying state that we set up in our component and that we need to change
    it using `this.setState`. The syntax of `this.setState` should look familiar as
    it matches the key to the value, which we have encountered many times before in
    TypeScript. At this stage, we can now update the rest of our entry components
    to support this two-way binding. First, we expand our `updateBinding` code as
    follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 从这段代码中，我们可以清楚地看到`this.state`为我们提供了对我们在组件中设置的底层状态的访问，并且我们需要使用`this.setState`来更改它。`this.setState`的语法应该看起来很熟悉，因为它与我们在TypeScript中多次遇到的键值匹配。在这个阶段，我们现在可以更新我们的其余输入组件以支持这种双向绑定。首先，我们将扩展我们的`updateBinding`代码如下：
- en: '[PRE23]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We aren't going to code dump all of the changes that we need to make to our
    actual inputs. We just need to update each input to match the value to the appropriate
    state element, and then add the same `onChange` handler in each case.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不打算将我们需要对实际输入进行的所有更改都进行代码转储。我们只需要更新每个输入以将值与相应的状态元素匹配，并在每种情况下添加相同的`onChange`处理程序。
- en: As `Address2` can be null, we are using the `!` operator on our binding so that
    it looks slightly different: `value={this.state.Address2!}`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`Address2`可能为空，我们在绑定上使用`!`运算符，使其看起来略有不同：`value={this.state.Address2!}`。
- en: Validating user inputs and the use of validators
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证用户输入和验证器的使用
- en: At this stage, we really should think about validating inputs from the user.
    We are going to introduce two types of validation in our code. The first is the
    minimum length validation. In other words, we are going to ensure that some of
    the entries have to have a minimum number of entries before they can be considered
    to be valid. The second type of validation uses something called a regular expression
    to validate it. What this means is that it takes the input and compares it against
    a set of rules to see whether there is a match; the expressions can look a little
    bit odd if you are new to regular expressions, so we will break them down to see
    exactly what rules we are applying.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们真的应该考虑验证用户的输入。我们将在我们的代码中引入两种类型的验证。第一种是最小长度验证。换句话说，我们将确保一些条目在被视为有效之前必须具有最少数量的条目。第二种验证类型使用称为正则表达式的东西来验证它。这意味着它接受输入并将其与一组规则进行比较，以查看是否有匹配；如果您对正则表达式不熟悉，这些表达式可能看起来有点奇怪，因此我们将对它们进行分解，以确切了解我们正在应用的规则。
- en: 'We are going to break our validation down into three parts:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把我们的验证分解为三个部分：
- en: The classes that provide the checking features, such as applying a regular expression.
    We will call these validators.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供检查功能的类，比如应用正则表达式。我们将称这些为验证器。
- en: The classes that apply the validation items to the different parts of the state.
    We will call these classes validations.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将验证项目应用到状态的不同部分的类。我们将称这些类为验证。
- en: The component that will call the validation items and update the UI with the
    details of a failed validation. This will be a new component called `FormValidation.tsx`.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将调用验证项目并使用失败验证的详细信息更新UI的组件。这将是一个名为`FormValidation.tsx`的新组件。
- en: 'We will start by creating an interface called `IValidator`. This interface
    is going to accept a generic parameter so that we can apply it to pretty much
    anything that we want. As a validation will tell us whether the input is valid,
    it will have a single method called `IsValid` that accepts the relevant input
    and then returns a `boolean` value:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建一个名为`IValidator`的接口。这个接口将接受一个通用参数，以便我们可以将它应用到几乎任何我们想要的东西上。由于验证将告诉我们输入是否有效，它将有一个名为`IsValid`的单一方法，该方法接受相关输入，然后返回一个`boolean`值：
- en: '[PRE24]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The first validator that we are going to write checks to see whether a string
    has a minimum number of characters, which we will set through the constructor.
    We will also guard against situations where the user fails to supply an input,
    by returning `false` from `IsValid` when the input is null:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要编写的第一个验证器是检查字符串是否具有最小数量的字符，我们将通过构造函数设置。我们还将防范用户未提供输入的情况，通过在输入为null时从`IsValid`返回`false`：
- en: '[PRE25]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The other validator that we are going to create is slightly more complicated.
    This validator accepts a string, which it uses to create something called a regular
    expression. A regular expression is effectively a mini language that provides
    a set of rules to test our input string against. In this case, the rules that
    form our regular expression are passed into our constructor. The constructor will
    then instantiate an instance of the JavaScript regular expression engine (`RegExp`).
    In a similar way to the minimum length validation, we ensure that we return `false`
    if there is no input. If we have an input, then we return the result of our regular
    expression test:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要创建的另一个验证器稍微复杂一些。这个验证器接受一个字符串，用它来创建一个叫做正则表达式的东西。正则表达式实际上是一种提供一组规则来测试我们的输入字符串的迷你语言。在这种情况下，构成我们正则表达式的规则被传递到我们的构造函数中。构造函数将实例化JavaScript正则表达式引擎（`RegExp`）的一个实例。与最小长度验证类似，我们确保如果没有输入则返回`false`。如果有输入，我们返回我们正则表达式测试的结果：
- en: '[PRE26]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now that we have our validators, we are going to examine how we are going to
    apply them. It probably will not come as a surprise that the first thing that
    we are going to do is define an interface that forms the *contract* of what we
    want our validation to do. Our `Validate` method is going to accept the `IPersonState`
    state from our component, validate items from this, and then return an array of
    validation failures:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了验证器，我们将研究如何应用它们。也许不会让人感到意外的是，我们要做的第一件事是定义一个接口，形成我们希望验证做的*合同*。我们的`Validate`方法将接受来自我们组件的`IPersonState`状态，验证其中的项目，然后返回一个验证失败的数组。
- en: '[PRE27]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'I have decided to break the validation down into the following three areas:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我决定将验证分解为以下三个领域：
- en: Validating the address
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证地址
- en: Validating the name
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证姓名
- en: Validating the phone number
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证电话号码
- en: Validating the address
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证地址
- en: 'Our address validation is going to use the `MinLengthValidator` and `RegularExpressionValidator`
    validators:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的地址验证将使用`MinLengthValidator`和`RegularExpressionValidator`验证器：
- en: '[PRE28]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The minimum length validation is simple enough, but the regular expression can
    be intimidating if you have never seen this type of syntax before. Before we look
    at our validation code, we will break down what the regular expression is doing.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 最小长度验证足够简单，但如果你以前从未见过这种类型的语法，正则表达式可能会让人望而生畏。在查看我们的验证代码之前，我们将分解正则表达式的工作。
- en: The first character, `^`, tells us that our validation is going to start at
    the very beginning of the string. If we left this character out, it would mean
    that our match could occur anywhere in the text. The use of `[0-9]` tells the
    regular expression engine that we want to match against a number. Strictly speaking,
    as US zip codes start with five numbers, we need to tell the validator that we
    want to match against five numbers, which we do by telling the engine how many
    we want: `[0-9]{5}`. If we only wanted to match against major area codes such
    as 10023, we could almost end our expression here. Zip codes, however, have an
    optional four-digit portion as well that is separated from the main part by a
    hyphen. Therefore, we have to tell the regular expression engine that we have
    an optional part that we want to apply.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个字符`^`告诉我们验证将从字符串的开头开始。如果我们省略这个字符，那么意味着我们的匹配可以出现在文本的任何地方。使用`[0-9]`告诉正则表达式引擎我们要匹配一个数字。严格来说，由于美国邮政编码以五个数字开头，我们需要告诉验证器我们要匹配五个数字，我们通过告诉引擎我们需要多少个来做到这一点：`[0-9]{5}`。如果我们只想匹配主要区号，比如10023，我们几乎可以在这里结束我们的表达式。然而，邮政编码还有一个可选的四位数字部分，它与主要部分由一个连字符分隔。因此，我们必须告诉正则表达式引擎我们有一个可选的部分要应用。
- en: We know that the format of the optional part of the zip code is a hyphen with
    four digits. This means that the next part of the regular expression has to consider
    the test as being one test. This means that we cannot test for a hyphen and then
    separately test for the numbers; we either have the -1234 format or we don't have
    anything. This tells us that we want to group the items we want to test together.
    The way that we group things together in a regular expression is to put the expression
    inside brackets. So, if we apply the same logic that we had before, we would probably
    think that this part of the validation was `(-[0-9]{4})`. As a first pass, that
    is pretty close to what we want. The rule, here, is to treat this as a group where
    the first character must be a hyphen and then there must be four numbers. There
    are two things that we need to sort out with this part of the expression. The
    first thing is that this test is not optional at the moment. In other words, the
    input 10012-1234 is valid, while 10012 is no longer valid. The second problem
    is that we have created something called a capture group in our expression, which
    we do not need.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '我们知道邮政编码可选部分的格式是一个连字符和四位数字。这意味着正则表达式的下一部分必须将测试视为一个测试。这意味着我们不能测试连字符，然后分别测试数字；我们要么有-1234格式，要么什么都没有。这告诉我们我们想要将要测试的项目分组。在正则表达式中将事物分组的方法是将表达式放在括号内。因此，如果我们应用之前的逻辑，我们可能会认为验证的这部分是
    `(-[0-9]{4})`。首次尝试，这与我们想要的非常接近。这里的规则是将其视为一个组，其中第一个字符必须是连字符，然后必须有四个数字。这个表达式的一部分有两件事情需要解决。第一件事是目前这个测试是不可选的。换句话说，输入10012-1234是有效的，而10012不再有效。第二个问题是我们在表达式中创建了一个捕获组，而我们并不需要。 '
- en: A capture group is a numbered group that represents the number of the match.
    This can be useful if we want to match the same text in a number of places in
    a document; however, as we only want one match, it is something we can avoid.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 捕获组是一个编号组，代表匹配的次数。如果我们想在文档的多个地方匹配相同的文本，这可能很有用；然而，由于我们只想要一个匹配，这是可以避免的。
- en: We will fix both issues with the optional part of the validation now. The first
    thing we are going to do is remove the capture group. This is done by using an
    `?:` operator that tells the engine that this group is a non-capture group. The
    next thing we are going to take care of is applying a `?` operator that says that
    we want this match to happen zero times or one time only. In other words, we have
    made this an optional test. At this point, we can successfully test both 10012
    and 10012-1234, but we do have one more thing that we need to take care of. We
    need to make sure that the input only matches this input. In other words, we don't
    want to allow any stray characters at the end; otherwise, the user would be able
    to type in 10012-12345 and the engine would think that we had a valid input. What
    we need to do is add the `$` operator at the end of the expression, which states
    that the expression is expecting the end of the line at that point. At this point,
    our regular expression is `^[0-9]{5}(?:-[0-9]{4})?$`, which matches the validation
    that we are expecting to apply to the zip code.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将解决验证的可选部分的两个问题。我们要做的第一件事是删除捕获组。这是通过使用 `?:` 运算符来完成的，告诉引擎这个组是一个非捕获组。接下来我们要处理的是应用
    `?` 运算符，表示我们希望此匹配发生零次或一次。换句话说，我们已经将其设置为可选测试。此时，我们可以成功测试10012和10012-1234，但我们还有一件事需要处理。我们需要确保输入只匹配此输入。换句话说，我们不希望在结尾允许任何杂乱的字符；否则，用户可以输入10012-12345，引擎会认为我们有一个有效的输入。我们需要做的是在表达式的结尾添加
    `$` 运算符，表示表达式在那一点处期望行的结束。此时，我们的正则表达式是 `^[0-9]{5}(?:-[0-9]{4})?$`，它匹配我们期望应用于邮政编码的验证。
- en: I have chosen to explicitly specify that a number is represented as `[0-9]`
    because it is a clear indicator for someone new to regular expressions that this
    represents a number between 0 and 9\. There is an equivalent shorthand that can
    be used to represent a single digit, and that is to use `\d` in its place. With
    this, we can rewrite this rule to `^\d{5}(?:-\d{4})?$`. The use of `\d` in this
    represents a single **American Standard Code for Information Interchange** (**ASCII**)
    digit.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我选择明确指定数字表示为 `[0-9]`，因为这对于新接触正则表达式的人来说是一个清晰的指示，表示0到9之间的数字。有一个等效的速记可以用来表示单个数字，那就是使用
    `\d` 代替。有了这个，我们可以将这个规则重写为 `^\d{5}(?:-\d{4})?$`。在这里使用 `\d` 代表一个**美国信息交换标准代码**（**ASCII**）数字。
- en: 'Going back to our address validation, the actual validation itself is extremely
    straightforward because we took the time to write validators that did the hard
    work for us. All we need to do is apply the minimum length validator against the
    first line of the address, the town, and the county, and the regular expression
    validator is applied to the zip code. Each failing validation item is added to
    the list of errors:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的地址验证，实际验证本身非常简单，因为我们花时间编写了为我们做了艰苦工作的验证器。我们所需要做的就是对地址的第一行、城镇和县区应用最小长度验证器，对邮政编码应用正则表达式验证器。每个失败的验证项目都会添加到错误列表中：
- en: '[PRE29]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Validating the name
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证姓名
- en: 'The name validation is the simplest piece of validation we are going to write.
    This validation assumes that we have a minimum of one letter for the first name
    and two letters for the last name:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 姓名验证是我们将要编写的最简单的验证部分。此验证假定我们的名字至少有一个字母，姓氏至少有两个字母：
- en: '[PRE30]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Validating the phone number
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证电话号码
- en: 'The phone number validation is going to be broken down into two parts. First,
    we validate that there is an entry for the phone number. Then, we validate to
    ensure that it is in the correct format using a regular expression. Before we
    analyze the regular expression, let''s see what this validation class looks like:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 电话号码验证将分为两部分。首先，我们验证电话号码是否有输入。然后，我们验证以正确格式输入，使用正则表达式。在分析正则表达式之前，让我们看看这个验证类是什么样子的：
- en: '[PRE31]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The regular expression initially looks more complicated than the zip code validation;
    however, once we break it down, we will see that it has lots of familiar elements.
    It uses `^` to capture from the start of the line, `$` to capture right to the
    end, and `?:` to create non-capture groups. We also see that we have set number
    matches such as `[0-9]{3}` to represent three numbers. If we break this down section
    by section, we will see that this really is a straightforward piece of validation.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: The first part of our phone number either takes the format of (555) or 555 optionally
    followed by a hyphen, period, or space. At first glance, `(?:\\((?:[0-9]{3})\\)|(?:[0-9]{3}))[-.
    ]?` is the most intimidating part of the expression. As we know, the first part
    either has to be something such as (555) or 555; that means that we have either
    *this expression* or *this expression* test. We have already seen that `(` and
    `)` mean something special to the regular expression engine so we must have some
    mechanism available to us to say that we are looking at the actual brackets rather
    than the expression that the brackets represent. That is what the `\\` part means
    in the expression.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: The use of `\` in a regular expression escapes the next character so that it
    is treated literally, rather than as an expression that forms a rule that will
    be matched. Additionally, as TypeScript already treats `\` as an escape character,
    we have to escape the escape character as well so that the expression engine sees
    the correct value.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: When we want a regular expression to say a value must be this or that, we group
    the expression and then use `|` to break it apart. Looking at our expression there,
    we see that we are looking for the (*nnn*) part first and, if that is not matched,
    we look at the *nnn* part instead.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: We also said that this value could be followed by a hyphen, period, or space.
    We use `[-. ]` to match a single character from that list. To make this test optional,
    we put `?` at the end.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: With this knowledge, we see that the next part of the regular expression, `(?:[0-9]{3})[-.
    ]?`, is looking for three numbers optionally followed by a hyphen, period, or
    space. The final part, `(?:[0-9]{4})`, states that the number must end in four
    digits. We now know that we can match numbers such as (555) 123-4567, 123.456.7890,
    and (555) 543 9876.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: For our purpose, simple zip code and phone number validations such as these
    work perfectly. In larger-scale applications, we do not want to rely on these
    as validation. These only test the data that looks to be in a particular format;
    they don't actually check to see whether they belong to real addresses or phones.
    If we reached a stage with our application where we actually wanted to verify
    that these existed, we would have to hook up to the services that did these checks.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: Applying validation in a React component
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our mock layout, we identified that we wanted our validation to appear below
    the `Save` and `Clear` buttons. While we could do this inside our main component,
    we are going to separate our validation out into a separate validation component.
    The component will receive the current state of our main component, apply the
    validation whenever the state changes, and return whether we can save our data.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: 'In a similar way to how we created our `PersonalDetails` component, we are
    going to create properties to pass into our component:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We are going to create a component in `FormValidation.tsx`, that will apply
    the different `IValidation` classes that we have just created. The constructor
    simply adds the different validators into an array that we will shortly iterate
    over and apply the validation for:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In the `Validate` method, we apply each piece of validation inside `forEach`
    before we call the `CanSave` method from our properties.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we add our `render` method, we are going to revisit `PersonalDetails`
    and add our `FormValidation` component:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The `userCanSave` method looks like this:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: So, whenever the validation is updated, our `Validate` method calls back to
    `userCanSave`, which has been passed in as a property.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: 'The last thing we need to do to get our validation running is to call the `Validate`
    method from the `render` method. We do this because the render cycle is called
    whenever the state of the parent changes. When we have a list of validation failures,
    we need to add them into our DOM as elements that we want to render back to the
    interface. A simple way to do this is to create a map of all of the failures and
    provide an iterator as a function that will loop over each failure and write it
    back as a row to the interface:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: At this point, whenever we change the state inside the application, our validation
    will automatically be triggered and any failures will be written in the browser
    as a `label` tag.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: Creating and sending data to the IndexedDB database
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It would make for a very poor experience when using the application if we could
    not save details for use the next time we came back to it. Fortunately, newer
    web browsers provide support for something called IndexedDB, which is a web browser-based
    database. Using this as our data store means that the details will be available
    when we reopen the page.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: While we are working with the database, we have two distinct areas that we need
    to bear in mind. We require code to build the database table and we require code
    to save the records in a database. Before we start writing the database table,
    we are going to add the ability to describe what our database looks like, which
    will be used to build the database.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will create a fluent interface to add the information that `ITable`
    exposes:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The idea behind fluent interfaces is that they allow us to chain methods together
    so that they can be read in an easier fashion. They encourage the idea of keeping
    method operations together, making it easier to read what is happening to an instance
    because the operations are all grouped together. This interface is fluent because
    the methods return `ITableBuilder`. The implementations of these methods use `return
    this;` to allow the chaining of operations together.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: With fluent interfaces, not all methods need to be fluent. If you create a non-fluent
    method on an interface, that becomes the end of the call chain. This is sometimes
    used for classes that need to set some properties and then build an instance of
    a class that has those properties.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: 'The other side of building the table is the ability to get the values from
    the builder. As we want to keep our fluent interface purely dealing with adding
    the details, we are going to write a separate interface to retrieve these values
    and build our IndexedDB database:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'While both of these interfaces serve different purposes and will be used by
    classes in different ways, they both refer to the same underlying code. When we
    write the class that exposes these interfaces, we are going to implement both
    the interfaces in the same class. The reason for doing this is so that we can
    segregate how they behave depending on which interface our calling code sees.
    Our table building class definition looks as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Of course, if we tried to build this right now, it would fail because we haven''t
    implemented either of our interfaces. The code for the `ITableBuilder` portion
    of this class looks like this:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'For the most part, this is simple code. We have defined a number of member
    variables to hold the details, and each method is responsible for populating a
    single value. Where the code does get interesting is in the `return` statement.
    By returning this, we have the ability to chain each method together. Before we
    add our `ITable` support, let''s explore how we use this fluent interface by creating
    a class to add the personal details table definition:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: What this code does is create a table builder that sets the database name to
    `packt-advanced-typescript-ch3` and adds the `People` table to it, setting the
    primary field as `PersonId` and creating an index in this named `personId`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have seen the fluent interface in action, we need to complete the
    `TableBuilder` class by adding the missing `ITable` methods:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The `Build` method is the most interesting one in this part of the code. This
    is where we physically create the table using the methods from the underlying
    IndexedDB database. `IDBDatabase` is the connection to the actual IndexedDB database,
    which we are going to retrieve when we start writing the core database functionality.
    We use this to create the object store that we will use to store our people records.
    Setting `keyPath` allows us to give the object store a field that we want to search
    in, so it will match the name of a field. When we add indexes, we can tell the
    object store what fields we want to be able to search in.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: Adding active record support to our state
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we look at our actual database code, we need to introduce one last piece
    of the puzzle—the object that we are going to store. While we have been working
    with state, we have been using `IPersonState` to represent the state of a person
    and, as far as the `PersonalDetails` component goes, that is sufficient. While
    working with the database, we want to expand this state. We are going to introduce
    a new `IsActive` parameter that will determine whether a person is shown on the
    screen. We don''t need to change the implementation of `IPersonState` to add this
    capability; we are going to use an intersection type to handle this instead. The
    first thing we have to do is add a class that has this active flag and then create
    our intersection type:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Working with the database
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have the ability to build the table and a representation of the
    state that we want to save into the table, we can turn our attention to connecting
    to the database and actually manipulating data in it. The first thing that we
    are going to do is define our class as a generic type that can work with any type
    that extends the `RecordState` class we just implemented:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The reason we need to specify the type that we accept in this class is that
    most of the methods in it are going to either accept instances of that type as
    a parameter or return instances of that type to be worked with in the calling
    code.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: As IndexedDB has become the standard client-side database, it has become something
    that can be directly accessed from the window object. TypeScript provides strong
    interfaces to support the database, so it is exposed as an `IDBFactory` type.
    This is important to us because it gives us access to operations such as opening
    the database. Effectively, this is the route that our code has to begin at to
    start manipulating data.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: Whenever we want to open the database, we give it a name and version. If the
    database name does not exist, or we are attempting to open a newer version, then
    our application code needs to upgrade the database. This is where the `TableBuilder`
    code comes into play. As we have specified that `TableBuilder` implements an `ITable`
    interface to provide the ability to read values and build the underlying database
    table, we are going to use that (the table instance is passed into the constructor,
    as we will see shortly).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: Working with IndexedDB can seem slightly strange at first because it emphasizes
    the use of event handlers a lot. For instance, when we attempt to open the database,
    if the code decides that an upgrade is needed, it triggers the `upgradeneeded`
    event, which we handle using `onupgradeneeded`. This use of events allows our
    code to behave asynchronously because the execution continues without waiting
    for the operation to complete. Then, when the event handler is triggered, it takes
    over the processing. We will be seeing a lot of this when we add our data methods
    to this class.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: 'With this information in mind, we can write our `OpenDatabase` method to open
    the database with the value from the `Version` method. The first time we hit this
    code, we are going to need to write the database table. Even though this is a
    new table, it is treated as an upgrade so the `upgradeneeded` event is triggered.
    Again, we can see the benefit of having the ability to build the database in the
    `PersonalDetailsTableBuilder` class because we keep our database code free from
    knowing how to build the table. By doing this, we can reuse this class for writing
    other types to the database if we need to. When the database opens, the `onsuccess`
    handler will be triggered, and we will set an instance-level `database` member
    that we can use later on:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now that we have the ability to build and open the table that is in place,
    we are going to write a constructor that accepts the `ITable` instance, which
    we will use to build the table:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We have one last helper method to write for this class before we start writing
    the code that works with the data. In order to write data to the database, we
    have to create a transaction and retrieve an instance of the object store from
    it. Effectively, the object store represents a single table in our database. Essentially,
    we require an object store if we want to read or write data. As this is so common,
    we create a `GetObjectStore` method that returns the object store. For convenience,
    we are going to allow our transaction to treat every operation as read or write,
    which we specify when we call the transaction:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: As we go through the code, you will see that I have chosen to name the methods
    `Create`, `Read`, `Update`, and `Delete`. It is fairly common to name the first
    two methods `Load` and `Save`; however, I chose these method names deliberately,
    because when working with data in databases, we often use the term *CRUD operation*,
    where **CRUD** refers to **Create**, **Read**, **Update**, and **Delete**. By
    adopting this naming convention, I hope that this solidifies this connection for
    you.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: 'The first (and simplest) method that we are going to add will allow us to save
    a record to the database. The `Create` method takes in an individual record, gets
    the object store, and adds the record to the database:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'When I was originally writing the code for this chapter, I wrote the `Read`
    and `Write` methods to use callback methods. The idea behind the callback method
    was simply to accept a function that our methods could *call back to* when the
    `success` event handlers were triggered. When we look at a lot of IndexedDB samples,
    we can see that they tend to adopt this type of convention. Before we look at
    the finalized version, let''s take a look at what the `Read` method originally
    looked like:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The method opens by getting the object store and using it to open something
    called a cursor. A cursor provides us with the ability to read a record and move
    onto the next one; so, when the cursor is opened, the success event is triggered,
    which means that we enter the `onsuccess` event handler. As this happens asynchronously,
    the `Read` method completes, so we will rely on the callback to transfer the actual
    values back to the class that called it. The rather strange-looking `callback:
    (value: T[]) => void` is the actual callback that we will use to return the array
    of `T` items back to the calling code.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `success` event handler, we get the result from the event, which
    will be a cursor. Assuming that the cursor is not null, we get the result from
    the cursor and add the record to our array if the state of our record is active;
    this is why we apply the generic constraint to our class—so that we can access
    the `IsActive` property. We then call `continue` on the cursor, which moves on
    to the next record. The `continue` method results in `success` being fired again,
    which means that we re-enter the `onsuccess` handler, resulting in the same code
    happening for the next record. When there are no more records, the cursor will
    be null so the code will call back to the calling code with the array of items.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: 'I mentioned that this was the initial implementation of this code. While callbacks
    are useful, they don''t really take advantage of the power that TypeScript gives
    us. What this misses is the ability to use promises in our code base. As we are
    relying on a promise, we are going to gather all of the records together before
    we return them to the calling code. This means that we will have some minor structural
    differences to the logic inside our `success` handler:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: As this is returning a promise, we drop the callback from the method signature
    and return a promise of an array of `T`. One of the things we have to be aware
    of is that the scope of the array we are going to use to store the results in
    has to be outside the `success` event handler; otherwise, we would reallocate
    it every time we hit `onsuccess`. What is interesting about this code is how similar
    it is to the callback version. All we have done is change the return type while
    dropping the callback from the method signature. The response part of our promise
    acts in place of the callback.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: In general, if our code accepts a callback, we can convert it to a promise by
    returning a promise with the callback moved from the method signature into the
    promise itself.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: 'The logic for our cursor is the same as we rely on the cursor check to see
    whether we have a value, and, if we do, we push it onto our array. When there
    are no more records, we call the response on our promise so that the calling code
    can work with it in the `then` part of the promise. To illustrate this, let''s
    examine the `loadPeople` code in `PersonalDetails`:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The `Read` method is the most complicated part of our CRUD operation. The next
    method that we are going to write is the `Update` method. When the record has
    been updated, we want to reload the records in our list so that changes to the
    first or last names are updated on the screen. The object store operation that
    updates our record is `put`. If it completes successfully, it raises the success
    event, which leads our code to call the `resolve` property on our promise. As
    we are returning a `Promise<void>` type, we have the ability to use the `async`/`await`
    syntax when calling this:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Our final database method is the `Delete` method. The syntax of the `Delete`
    method is very similar to that of the `Update` method—the only real difference
    is that it just takes the index, which tells it what row to `delete` in the database:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Accessing the database from PersonalDetails
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can now add database support to our `PersonalDetails` class. The first thing
    we are going to do is update the member variables and constructor to bring in
    the database support and store the list of people we want to display:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we add the members:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Next, we update the constructor to hook up to the database and create `TableBuilder`
    using `PersonalDetailsTableBuilder`:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'One thing that we still have to do is add the ability to show people into our
    `render` method. In a similar way to displaying the validation failures using
    `map`, we are going to apply `map` to the `people` array:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'This is then rendered out with the following:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The Load button is one of a number of places that the `loadPeople` method is
    called from in this class. We will see it in use when we update and then delete
    the records.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: When working with database code, it is common to encounter situations where
    the deletion of a record should not physically delete the record from the database.
    We might not want to physically delete it because another record points to that
    one, and so deleting it will break the other record. Alternatively, we might have
    to keep it in place for auditing purposes. In those cases, it is common to do
    something called a soft delete (a hard delete being the one where the record is
    deleted from the database). With a soft delete, there is a flag on a record that
    indicates whether the record is active. While `IPersonState` does not provide
    this flag, the `PersonRecord` type does because it is an intersection of `IPersonState`
    and `RecordState`. Our `delete` method is going to change `IsActive` to `false`
    and update the database with that value. The code that loads the people already
    understands that it is retrieving records where `IsActive` is `true`, so these
    deleted records will disappear as soon as the list is reloaded. This means that,
    while we wrote a Delete method in our database code, we aren't actually going
    to be using it. It's there as a handy reference and you might want to change the
    code to do a hard delete but this isn't necessary for our purpose.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: 'The Delete button is going to trigger the delete operation. As there can be
    a number of items in this list, and we cannot assume that the user is going to
    select a person before deleting them, we need to find that person from the list
    of people before we attempt to delete them. Looking back at the code to render
    out the people, we can see that the ID of the person is passed across to the event
    handler. Before we write our event handler, we are going to write the method that
    asynchronously deletes the person from the database. The first thing we are going
    to do in this method is find the person using the `find` array method:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Assuming that we find the person from the array, we need to get the person
    into a state where we can set `IsActive` to `false`. We start off by creating
    a new instance of `RecordState`, as follows:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'We have an intersection type, `PersonRecord`, made up of the intersection of
    the person and record states. We are going to spread `foundPerson` and `personState`
    to give us our `PersonRecord` type. With this in place, we are going to call our
    `Update` database method. What we want to do, when our update has completed, is
    reload the list of people and clear the item currently in the editor—just in case
    it''s the one that we have just deleted; we don''t want the user to be able to
    reinstate the record simply because they save it again with `IsActive` set to
    `true`. We are going to use the fact that we can use `await` on code written as
    a promise to wait until the record has been updated before we carry on with the
    processing:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The `clear` method simply changes the state back to our default state. That''s
    the whole reason we passed it into this component, so that we can easily clear
    the values back to their default state:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Using our `delete` event handler, the full code for this is as follows:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The last database operations we need to hook up to are triggered from the Save
    button. What happens with the save depends on whether we have previously saved
    the record, which can be identified by whether `PersonId` is empty. Before we
    attempt to save the record, we have to determine whether it can be saved. This
    comes down to checking whether the validation says we can save or not. If there
    are outstanding validation failures, we are going to alert the users that they
    cannot save the record:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Similarly to how we used the deletion technique, we are going to create our
    `PersonRecord` type by bringing the state together with `RecordState`. This time,
    we set `IsActive` to `true` so that it is picked up as a live record:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'When we insert our record, we need to assign it a unique value for `PersonId`.
    For simplicity, we are just going to use it with the current date and time. When
    we add the person to the database, we reload the list of people and clear the
    current record from the editor so that the user cannot insert a duplicate just
    by clicking on Save again:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The code to update the person leverages the features of a promise so that the
    list of people is updated immediately after it has finished saving. We do not
    need to clear the current record in this case because if the user clicks on Save
    again, there is no possibility that we are going to create a new record—but we
    will simply update the current one:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The completed method for saving is as follows:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'There is one last method that we need to cover. What you may have noticed is
    that we have no way of selecting and displaying a user in the textboxes when we
    click on the Edit button. Logic dictates that pressing the button should trigger
    an event that passes `PersonId` to an event handler, which we can use to find
    the relevant person from the list; we have already seen this type of behavior
    when using the Delete button, so we have a good idea of what the selection portion
    of the code will look like. Once we have the person, we call `setState` to update
    the state, which will update the display through the power of binding:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: We now have all the code we need to build our contact manager with React. We
    have satisfied the requirements that we set out at the start of the chapter and
    our display looks close enough to our mock layout.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: Enhancements
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Create` method has a potential problem in that it assumes that it succeeds
    immediately. It does not handle the `success` event for the operation. Additionally,
    there is a further issue in that `add` operations have a `complete` event because
    the `success` event may fire before the record has been successfully written to
    the disk, and, if the transaction fails, the `complete` event is not raised. You
    can convert the `Create` method so that it uses a promise and resumes processing
    when the `success` event is raised. Then, update the insert portion of the component
    to reload once this has been completed.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: The deletion resets the state even if the user wasn't editing the record that
    was deleted. So, enhance the delete code to only reset the state if the record
    being edited is the same as the one that was deleted.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter introduced us to the popular React framework and discussed how
    we can use it with TypeScript to build a modern client side application to add
    contact information. We started by defining the requirements and creating a mock
    layout of our application before we created the basic implementation using `create-react-app`
    with the `react-scripts-ts` script version. To leverage Bootstrap 4 in a React-friendly
    way, we added in the `reactstrap` package.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: After discussing how React uses the special JSX and TSX formats to control the
    way it renders, we moved on to customizing the `App` component and adding our
    own custom TSX components. With these components, we looked at passing properties
    and setting up state, which we then used to create two-way bindings. With the
    bindings, we discussed how to validate user inputs by creating reusable validators
    that were then applied to validation classes. As part of the validation, we added
    two regular expressions, which we analyzed to understand how they were constructed.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we examined how to save personal information in the IndexedDB database.
    The first part of this was to understand how to build the database and tables
    using table builders, which was complemented by looking at how to work with the
    database. We looked at how to convert a callback-based method to use the promises
    API to provide asynchronous support as well as the difference between soft and
    hard deletes of data.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to move on to using Angular with MongoDB,
    Express, and Node.js, which are collectively known as the MEAN stack, to build
    a photo gallery application.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What gives React the ability to mix visual elements with code inside the `render`
    method?
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why does React use `className` and `htmlFor`?
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We saw that phone numbers can be validated using the regular expression `^(?:\\((?:[0-9]{3})\\)|(?:[0-9]{3}))[-.
    ]?(?:[0-9]{3})[-. ]?(?:[0-9]{4})$`. We also discussed that there was an alternative
    way of representing a single digit. How could we convert this expression to give
    exactly the same result with the alternative representation?
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why do we create validators separately from validation code?
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between a soft delete and a hard delete?
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React is a big topic. In order to find out more about the ideas behind it, I
    recommend *React and React Native* –* Second Edition *([https://www.packtpub.com/application-development/react-and-react-native-second-edition](https://www.packtpub.com/application-development/react-and-react-native-second-edition)).
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more information on using React with TypeScript, I recommend *Learn React
    with TypeScript 3* by Carl Rippon ([https://www.packtpub.com/web-development/learn-react-typescript-3](https://www.packtpub.com/web-development/learn-react-typescript-3)).
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Packt also publishes the excellent book *JavaScript Regular Expressions* by
    Loiane Groner and Gabriel Manricks ([https://www.packtpub.com/web-development/javascript-regular-expressions](https://www.packtpub.com/web-development/javascript-regular-expressions)), if
    you want to take your regular expression knowledge to the next level.
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
