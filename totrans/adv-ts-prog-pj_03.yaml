- en: A React Bootstrap Personal Contacts Manager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are going to learn how to build a personal contacts manager
    using React, which is a library for building **user interfaces** (**UIs**) out
    of small components. By learning React, you will gain the ability to use one of
    the most popular libraries currently in use, as well as begin to understand how
    and when to use the power of binding to simplify your code.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring React will help us to understand how to write a modern application
    for the client side and also study its requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 'To help us to develop the application, the following topics will be covered
    in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a mock layout to check our layouts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating our React application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analyzing and formatting code with `tslint`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding Bootstrap support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using tsx components in React
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `App` component in React
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying our personal details UI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using binding to simplify our updates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating validators and applying them as validation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying validation in a React component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating and sending data to an IndexedDB database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we are using an IndexedDB database to store data, a modern web browser such
    as Chrome (version 11 or later) or Firefox (version 4 or later) will be required.
    The finished project can be downloaded from [https://github.com/PacktPublishing/Advanced-TypeScript-3-Programming-Projects/tree/master/chapter03](https://github.com/PacktPublishing/Advanced-TypeScript-3-Programming-Projects/tree/master/chapter03).
    After downloading the project, you will have to install the package requirements
    using `npm install`.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the project overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to build a personal contacts manager database using React. The
    data is stored locally on the client using the standard IndexedDB database. When
    we have finished, our application will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/d5353a60-f978-4180-bf0b-a86ad7ce205c.png)'
  prefs: []
  type: TYPE_IMG
- en: You should be able to complete the steps in this chapter, working alongside
    the code in the GitHub repository, in approximately two hours.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with the components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter relies on Node.js, which is available at [https://nodejs.org/](https://nodejs.org/).
    As we progress through the chapter, we will install the following components:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@types/bootstrap` (4.1.2 or later)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@types/reactstrap` (6.4.3 or later)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bootstrap` (4.1.3 or later)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`react` (16.6.3 or later)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`react-dom` (16.6.3 or later)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`react-script-ts` (3.1.0 or later)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reactstrap` (6.5.0 or later)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`create-react-app` (2.1.2 or later)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a React Bootstrap project with TypeScript support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we discussed in [Chapter 2](3593e33f-7490-47b6-b129-ab5e08aef1b0.xhtml),
    *Creating a Markdown Editor with TypeScript,* it is a good idea to start off by
    gathering the requirements of the application that we are going to write. Here are
    the requirements for this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: The user will be able to create new details of a person or edit them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These details will be saved to a client-side database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The user will be able to load the list of all people
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The user will be able to delete the personal details of a person
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The personal details will consist of the first and last names, the address (made
    up of two address lines, the town, the county, and the zip code), the phone number,
    and the date of birth
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The personal details will be saved to the database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first name will be at least one character and the last name will be at least
    two characters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Address line 1, town, and county will be at least five characters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The zip code will conform to the American standard for most zip codes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The phone number will conform to the standard American phone format
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The user can clear details with the click of a button
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating our mock layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once we have our requirements, it is normally a good idea to draw up some rough
    drafts of what we think the layout of our application should be. What we want
    to do is to create a layout that shows we are using a web browser layout in a
    sketch format. The reason we want it to look as though it is sketched is because
    of the way we interact with our clients. We want them to get an idea about the
    rough layout of our application without getting caught up in details such as exactly
    how wide a particular button is.
  prefs: []
  type: TYPE_NORMAL
- en: 'What is particularly useful is the ability to use a tool such as [https://ninjamock.com](https://ninjamock.com)/
    to create a wireframe sketch of our interface. These sketches can be shared online
    with clients or other team members who can directly add comments. The following
    sketch diagram demonstrates what we want our interface to look like when we are
    finished:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/22334fc2-a57c-47ec-88b6-7ea1a5f928cc.png)'
  prefs: []
  type: TYPE_IMG
- en: Creating our application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we can begin writing our code, we need to install React. While it is
    possible to create the infrastructure we need for React manually, most people
    use the `create-react-app` command to create a React application. We aren''t going
    to do this any differently, so we are also going to use the `create-react-app` command. React
    does not use TypeScript by default so we are going to add a little bit extra to
    the command we use to create our application to give us all the TypeScript capacity
    that we need. We use `create-react-app`, giving it the name of our application
    and an extra `scripts-version` parameter that hooks in TypeScript for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If you have installed Node.js packages before, you may think that there is a
    mistake in the preceding command and that we should be using `npm` to install
    `create-react-app`. However, we are using `npx` in place of `npm` because `npx`
    is an enhanced version of the **Node Package Manager** (**NPM**). With `npx`,
    we missed out the need to run `npm install create-react-app` to install the `create-react-app`
    package before manually running `create-react-app` to start the process. The use
    of `npx` does help to speed up our development workflow.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once our application has been created, we open the `Chapter03` directory and
    run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Assuming that we have a default browser set, it should be opened to `http://localhost:3000`,
    which is the default web page for this application. This will serve up a standard
    web page that just happens to contain a default React sample. What we are going
    to do now is edit the `public/index.html` file and set a title for it. We are
    going to set our title to `Advanced TypeScript - Personal Contacts Manager`. While
    the contents of this file appear to be sparse, they contain everything that we
    need on our HTML side, namely, a `div` element called `root`. This is the hook that
    our React code will hang off, as we will discuss later. We can live edit our application
    so that any changes we make will be compiled and served back to the browser automatically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Formatting our code using tslint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once we have created our application, we are using something called `tslint`,
    which analyzes our code by looking for potential problems. Note that support for
    this was automatically added when we created our application. The `tslint` version
    that runs applies a very aggressive set of rules against which we check our code.
    I have gone with the full set of `tslint` rules in my code base; however, if you
    want to relax the rules a bit, you just need to change the `tslint.json` file
    to something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Adding Bootstrap support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the things we need to do with our application is bring in support for
    Bootstrap. This is not something that is provided *out of the box* with React,
    so we need to add this capacity using other packages:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install Bootstrap as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'With this in place, we are now free to use a React-ready Bootstrap component.
    We are going to use the `reactstrap` package because this package targets Bootstrap
    4 in a React-friendly fashion:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '`reactstrap` is not a TypeScript component, so we need to install the `DefinitelyTyped`
    definition for this and for Bootstrap:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'With this in place, we can now add the Bootstrap CSS files. To do this, we
    are going to update the `index.tsx` file by adding a reference to our locally
    installed Bootstrap CSS file, by adding the following `import` to the very top
    of the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are using the local Bootstrap file for convenience. As we discussed
    in [Chapter 1](56be9c18-a050-4794-bbd6-c51cd62f8f35.xhtml), *Advanced TypeScript
    Features,* we want to change this to use a CDN source for the production version
    of this application.
  prefs: []
  type: TYPE_NORMAL
- en: 'To tidy up, remove the following line from `src/index.tsx` and then remove
    the matching `.css` file from the disk:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: React using tsx components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One question that you might have right now is why does the index file have a
    different extension? That is, why is it `.tsx` and not `.ts`? To answer these
    questions, we have to change our mental image of the extension slightly and talk
    about why React uses `.jsx` files and not `.js` (the `.tsx` version is the TypeScript
    equivalent of `.jsx`).
  prefs: []
  type: TYPE_NORMAL
- en: These JSX files are extensions of JavaScript that get transpiled to JavaScript.
    If you were to try and run them *as is* in JavaScript, then you would get runtime
    errors if they contained any of these extensions. In traditional React, there
    is a transpilation phase that takes the JSX file and converts it to JavaScript
    by expanding out the code to standard JavaScript. Effectively, this is a form
    of the compilation phase that we get from TypeScript anyway. With TypeScript React,
    we get the same end result where the TSX file ultimately ends up as a JavaScript
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the question now is why do we actually need these extensions? To answer
    this, we are going to analyze the `index.tsx` file. This is what the file looks
    like with our Bootstrap CSS file added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `import` statements should be familiar to us by now and `registerServiceWorker`
    is the behavior that is added to the code to provide a faster production application
    by serving assets from a cache, rather than reloading them time and time again.
    One of the key tenets of React is that it should be as fast as possible and that's
    where `ReactDOM.render` comes in. If we read this piece of code, things should
    become clear. What it is doing is looking for the element marked as root in the
    HTML page we serve up—we saw this in the `index.html` file. The reason we use
    the `as HTMLElement` syntax here is that we want to let TypeScript know what type
    this is (this parameter either has to derive from an element or be null—yes, that
    does mean that underlying this is a union type).
  prefs: []
  type: TYPE_NORMAL
- en: Now, the reason we need a special extension is because of the piece of code
    that says `<App />`. What we are doing here is inlining a piece of XML code into
    our statement. In this particular instance, we are telling our `render` method
    to render out a component called `App`, that has been defined in the `App.tsx` file.
  prefs: []
  type: TYPE_NORMAL
- en: How React uses a virtual DOM to be more responsive
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I glossed over why the `render` method is used, so now is the time to address
    React's secret weapon, that is, the virtual **Document Object Model** (**DOM**).
    If you've been developing web applications for a while, you are probably aware
    of the DOM.  If you have never encountered this, the DOM is an entity that describes
    exactly what a web page will look like. Web browsers rely very heavily on the
    DOM, and, as it has grown organically over the years, it can be pretty unwieldy.
    There is only so much that browser manufacturers can do to try and speed up the
    DOM. If they want to be able to serve up old web pages, then they have to support
    the full DOM.
  prefs: []
  type: TYPE_NORMAL
- en: The virtual DOM is a light weight copy of the standard DOM. The reason it is
    lighter in weight is that it misses out a major feature of the standard DOM; that
    is, it doesn't have to render out to the screen. When React runs the `render`
    method, it traverses each `.tsx` (or `.jsx` in JavaScript) file and executes the
    rendering code there. It then compares this rendered code to a copy of the last
    render that was run to work out exactly what has changed. Only those changed elements
    are updated on the screen. This comparison stage is the reason we have to use
    a virtual DOM. It's much faster to tell what elements need updating using this
    approach, and only those elements that get changed need to be updated.
  prefs: []
  type: TYPE_NORMAL
- en: Our React App component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have already touched on the use of components in React. By default, we will
    always have an `App` component. This is the component that will be rendered to
    the root element in our HTML. Our components derive from `React.Component`, so
    the start of our `App` component looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, our component requires a well-known method to trigger the rendering
    of the component. It will not come as much of a surprise to learn that the method
    is called `render`. As we are using Bootstrap to display our UI, we want to be
    rendering out a component that relates to our `Container` div. To do this, we
    are going to use a `Container` component from `reactstrap` (and introduce the
    core component that we are going to use to display our interface):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Displaying the personal details interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to create a class called `PersonalDetails`. This class is going
    to render out the core of our interface inside the `render` method. Again, we
    are using `reactstrap` to lay out the various parts of the interface. Before we
    break down the intricacies of what our `render` method does, let''s take a look
    at what this all looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, there''s a lot going on in this method; however, the vast majority
    of it is repeated code used to replicate the row and column Bootstrap elements.
    If we take a look at the layout for the `postcode` and `phoneNumber` elements,
    for instance, we can see that we are laying out two rows with two explicit columns
    in each. In Bootstrap terms, one of these `Col` elements is a large size of three
    and the other one is a large size of four (we will leave it to Bootstrap to factor
    in the empty column that remains):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Looking at the label and input elements, we can see that there are two unfamiliar
    elements. Surely, the correct key in a label is `for` and we should use `class`
    to refer to a CSS class in our input? The reason we have replacement keys here
    is that `for` and `class` are JavaScript keywords. As React allows us to mix the
    code and markup language inside a render, React has to use different keywords.
    This means that we use `htmlFor` to replace `for` and `className` to replace `class`.
    Going back to when we talked about the virtual DOM, this gives us a major hint
    that these HTML elements are copies that serve a similar purpose, rather than
    the elements themselves.
  prefs: []
  type: TYPE_NORMAL
- en: Simplify updating values with binding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One feature of many modern frameworks is the use of binding to remove the need
    to manually update inputs or trigger events. The idea behind using a binding is
    that the framework establishes a connection between a UI element and the code,
    such as a property, watches for changes to the underlying values, and then triggers
    updates when it detects a change. When done correctly, this removes a lot of drudgery
    from writing our code and, more importantly, helps to reduce errors.
  prefs: []
  type: TYPE_NORMAL
- en: Supplying state to bind against
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The idea behind binding with React is that we have a state that we need to
    bind to. In the case of creating data that we want to display on the screen, our
    state can be as simple as an interface describing the properties that we want
    to use. For a single contact, this translates to our state looking like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we have created a union type called `StringOrNull` as a convenience.
    We will place this in a file called `Types.tsx` so that it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'What we want to do now is tell our component what state it is going to use.
    The first thing to do is update our class definition so that it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This follows the convention where the properties are passed into our class from
    the parent and the state comes from our local component. This separation of properties
    and state is important to us because it provides us with a way for the parent
    to communicate with the component (and for the component to communicate back with
    the parent), while still being able to manage the data and behaviors that our
    component wants as the state.
  prefs: []
  type: TYPE_NORMAL
- en: Here, our properties are defined in an interface called `IProps`. Now that we
    have told React what the *shape* of our state is going to be internally, React
    and TypeScript use this to create a `ReadOnly<IPersonState>` property. Therefore,
    it is important to ensure that we are using the right state. If we use the wrong
    type for our state, TypeScript will inform us of this.
  prefs: []
  type: TYPE_NORMAL
- en: Note that there is a caveat to that preceding statement. If we have two interfaces
    of exactly the same shape, then TypeScript treats them as equivalent to each other.
    So, even though TypeScript is expecting `IState`, if we supply something called
    `IMyOtherState` that has exactly the same properties, then TypeScript will happily
    let us use that in its place. The question, of course, is why would we want to
    duplicate the interface in the first place? I cannot think of many cases where
    we would want to do that, so the idea of using the right state is accurate for
    almost all the cases we are ever likely to encounter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `app.tsx` file is going to create a default for the state and pass this
    to our component as its property. The default state is the one that will be applied
    when the user presses clear to clear the currently edited entry, or New Person
    to start adding a new person. Our `IProps` interface looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Something that may seem slightly confusing at first is a potential contradiction
    between my earlier statement the idea that the properties and state are different—with
    state being something that is local to the component and yet we are passing state
    down as part of the properties. I deliberately use state as part of the name to
    reinforce the fact that this represents the state. The values that we are passing
    in can be called anything at all. They do not have to represent any state; they
    could simply be functions that the component calls to trigger some response in
    the parent. Our component will receive this property and it will be its responsibility
    to convert any part that it needs into state.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this in place, we are ready to change our `App.tsx` file to create our
    default state and to pass this into our `PersonalDetails` component. As we can
    see in the following code, the property from the `IProps` interface becomes a
    parameter in the `<PersonalDetails ..` line. The more items we add to our properties
    interface, the more parameters we will have to add to this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Date handling with JavaScript can be off-putting when we want to hook the date
    into a date picker component. The date picker expects to receive the date in the
    format of YYYY-MM-DD. So, we use the `new Date().toISOString().substring(0,10)` syntax
    to get today's date, which includes a time component, and only retrieve the YYYY-MM-DD
    portion from this. Even though the date picker expects the date to be in this
    format, it does not say that this is the format that will be displayed on the
    screen. The format on your screen should respect the local settings of the user.
  prefs: []
  type: TYPE_NORMAL
- en: What was interesting about the changes we made to support passing in properties
    is that we have already seen binding in action here. Inside the `render` method,
    where we set `Default={this.defaultPerson}`, we are using binding. With the use
    of `{ }` here, we are telling React that we want to bind to something, whether
    it's to a property or an event. We will encounter binding a lot in React.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we are going to add a constructor to `PersonalDetails.tsx` to support the
    property that is being passed in from `App.tsx`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We are doing two things here. First, we are setting up a default state to go
    back to if we need to, which we received from our parent; second, we are setting
    up the state for this page. We didn't have to create a state property in our code
    as this is provided for us by `React.Component`. This is the final part of learning
    how we have tied our property from the parent to the state.
  prefs: []
  type: TYPE_NORMAL
- en: Changes to state will not be reflected back in the parent props. If we wanted
    to explicitly set a value back in the parent component, this would require us
    to trigger a change to `props.DefaultState`. I advise against doing this directly
    if you can possibly avoid it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Right. Let''s set up our first name and last name elements to work with the
    binding from our state. The idea here is that if we update the state of the first
    or last names in our code, this will automatically be updated in our UI. So, let''s
    change the entries as required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we run our application, we have entries that are bound to the underlying
    state. There is, however, an issue with this code. If we try to type into either
    textbox, we will see that nothing happens. The actual text entry is rejected.
    That does not mean we have done anything wrong, rather we only have part of the
    overall picture here. What we need to understand is that React provides us with
    a read-only version of the state. If we want our UI to update our state, we have
    to explicitly opt into this by reacting to changes and then setting the state
    as appropriate. First, we are going to write an event handler to handle setting
    the state when the text changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'With this in place, we can now update our input to trigger this update using
    the `onChange` attribute. Again, we are going to use binding to match the `onChange`
    event to the code that is triggered as a result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'From this code, we can clearly see that `this.state` provides us with access
    to the underlying state that we set up in our component and that we need to change
    it using `this.setState`. The syntax of `this.setState` should look familiar as
    it matches the key to the value, which we have encountered many times before in
    TypeScript. At this stage, we can now update the rest of our entry components
    to support this two-way binding. First, we expand our `updateBinding` code as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We aren't going to code dump all of the changes that we need to make to our
    actual inputs. We just need to update each input to match the value to the appropriate
    state element, and then add the same `onChange` handler in each case.
  prefs: []
  type: TYPE_NORMAL
- en: As `Address2` can be null, we are using the `!` operator on our binding so that
    it looks slightly different: `value={this.state.Address2!}`.
  prefs: []
  type: TYPE_NORMAL
- en: Validating user inputs and the use of validators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this stage, we really should think about validating inputs from the user.
    We are going to introduce two types of validation in our code. The first is the
    minimum length validation. In other words, we are going to ensure that some of
    the entries have to have a minimum number of entries before they can be considered
    to be valid. The second type of validation uses something called a regular expression
    to validate it. What this means is that it takes the input and compares it against
    a set of rules to see whether there is a match; the expressions can look a little
    bit odd if you are new to regular expressions, so we will break them down to see
    exactly what rules we are applying.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to break our validation down into three parts:'
  prefs: []
  type: TYPE_NORMAL
- en: The classes that provide the checking features, such as applying a regular expression.
    We will call these validators.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The classes that apply the validation items to the different parts of the state.
    We will call these classes validations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The component that will call the validation items and update the UI with the
    details of a failed validation. This will be a new component called `FormValidation.tsx`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will start by creating an interface called `IValidator`. This interface
    is going to accept a generic parameter so that we can apply it to pretty much
    anything that we want. As a validation will tell us whether the input is valid,
    it will have a single method called `IsValid` that accepts the relevant input
    and then returns a `boolean` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The first validator that we are going to write checks to see whether a string
    has a minimum number of characters, which we will set through the constructor.
    We will also guard against situations where the user fails to supply an input,
    by returning `false` from `IsValid` when the input is null:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The other validator that we are going to create is slightly more complicated.
    This validator accepts a string, which it uses to create something called a regular
    expression. A regular expression is effectively a mini language that provides
    a set of rules to test our input string against. In this case, the rules that
    form our regular expression are passed into our constructor. The constructor will
    then instantiate an instance of the JavaScript regular expression engine (`RegExp`).
    In a similar way to the minimum length validation, we ensure that we return `false`
    if there is no input. If we have an input, then we return the result of our regular
    expression test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our validators, we are going to examine how we are going to
    apply them. It probably will not come as a surprise that the first thing that
    we are going to do is define an interface that forms the *contract* of what we
    want our validation to do. Our `Validate` method is going to accept the `IPersonState`
    state from our component, validate items from this, and then return an array of
    validation failures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'I have decided to break the validation down into the following three areas:'
  prefs: []
  type: TYPE_NORMAL
- en: Validating the address
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Validating the name
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Validating the phone number
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Validating the address
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our address validation is going to use the `MinLengthValidator` and `RegularExpressionValidator`
    validators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The minimum length validation is simple enough, but the regular expression can
    be intimidating if you have never seen this type of syntax before. Before we look
    at our validation code, we will break down what the regular expression is doing.
  prefs: []
  type: TYPE_NORMAL
- en: The first character, `^`, tells us that our validation is going to start at
    the very beginning of the string. If we left this character out, it would mean
    that our match could occur anywhere in the text. The use of `[0-9]` tells the
    regular expression engine that we want to match against a number. Strictly speaking,
    as US zip codes start with five numbers, we need to tell the validator that we
    want to match against five numbers, which we do by telling the engine how many
    we want: `[0-9]{5}`. If we only wanted to match against major area codes such
    as 10023, we could almost end our expression here. Zip codes, however, have an
    optional four-digit portion as well that is separated from the main part by a
    hyphen. Therefore, we have to tell the regular expression engine that we have
    an optional part that we want to apply.
  prefs: []
  type: TYPE_NORMAL
- en: We know that the format of the optional part of the zip code is a hyphen with
    four digits. This means that the next part of the regular expression has to consider
    the test as being one test. This means that we cannot test for a hyphen and then
    separately test for the numbers; we either have the -1234 format or we don't have
    anything. This tells us that we want to group the items we want to test together.
    The way that we group things together in a regular expression is to put the expression
    inside brackets. So, if we apply the same logic that we had before, we would probably
    think that this part of the validation was `(-[0-9]{4})`. As a first pass, that
    is pretty close to what we want. The rule, here, is to treat this as a group where
    the first character must be a hyphen and then there must be four numbers. There
    are two things that we need to sort out with this part of the expression. The
    first thing is that this test is not optional at the moment. In other words, the
    input 10012-1234 is valid, while 10012 is no longer valid. The second problem
    is that we have created something called a capture group in our expression, which
    we do not need.
  prefs: []
  type: TYPE_NORMAL
- en: A capture group is a numbered group that represents the number of the match.
    This can be useful if we want to match the same text in a number of places in
    a document; however, as we only want one match, it is something we can avoid.
  prefs: []
  type: TYPE_NORMAL
- en: We will fix both issues with the optional part of the validation now. The first
    thing we are going to do is remove the capture group. This is done by using an
    `?:` operator that tells the engine that this group is a non-capture group. The
    next thing we are going to take care of is applying a `?` operator that says that
    we want this match to happen zero times or one time only. In other words, we have
    made this an optional test. At this point, we can successfully test both 10012
    and 10012-1234, but we do have one more thing that we need to take care of. We
    need to make sure that the input only matches this input. In other words, we don't
    want to allow any stray characters at the end; otherwise, the user would be able
    to type in 10012-12345 and the engine would think that we had a valid input. What
    we need to do is add the `$` operator at the end of the expression, which states
    that the expression is expecting the end of the line at that point. At this point,
    our regular expression is `^[0-9]{5}(?:-[0-9]{4})?$`, which matches the validation
    that we are expecting to apply to the zip code.
  prefs: []
  type: TYPE_NORMAL
- en: I have chosen to explicitly specify that a number is represented as `[0-9]`
    because it is a clear indicator for someone new to regular expressions that this
    represents a number between 0 and 9\. There is an equivalent shorthand that can
    be used to represent a single digit, and that is to use `\d` in its place. With
    this, we can rewrite this rule to `^\d{5}(?:-\d{4})?$`. The use of `\d` in this
    represents a single **American Standard Code for Information Interchange** (**ASCII**)
    digit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Going back to our address validation, the actual validation itself is extremely
    straightforward because we took the time to write validators that did the hard
    work for us. All we need to do is apply the minimum length validator against the
    first line of the address, the town, and the county, and the regular expression
    validator is applied to the zip code. Each failing validation item is added to
    the list of errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Validating the name
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The name validation is the simplest piece of validation we are going to write.
    This validation assumes that we have a minimum of one letter for the first name
    and two letters for the last name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Validating the phone number
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The phone number validation is going to be broken down into two parts. First,
    we validate that there is an entry for the phone number. Then, we validate to
    ensure that it is in the correct format using a regular expression. Before we
    analyze the regular expression, let''s see what this validation class looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The regular expression initially looks more complicated than the zip code validation;
    however, once we break it down, we will see that it has lots of familiar elements.
    It uses `^` to capture from the start of the line, `$` to capture right to the
    end, and `?:` to create non-capture groups. We also see that we have set number
    matches such as `[0-9]{3}` to represent three numbers. If we break this down section
    by section, we will see that this really is a straightforward piece of validation.
  prefs: []
  type: TYPE_NORMAL
- en: The first part of our phone number either takes the format of (555) or 555 optionally
    followed by a hyphen, period, or space. At first glance, `(?:\\((?:[0-9]{3})\\)|(?:[0-9]{3}))[-.
    ]?` is the most intimidating part of the expression. As we know, the first part
    either has to be something such as (555) or 555; that means that we have either
    *this expression* or *this expression* test. We have already seen that `(` and
    `)` mean something special to the regular expression engine so we must have some
    mechanism available to us to say that we are looking at the actual brackets rather
    than the expression that the brackets represent. That is what the `\\` part means
    in the expression.
  prefs: []
  type: TYPE_NORMAL
- en: The use of `\` in a regular expression escapes the next character so that it
    is treated literally, rather than as an expression that forms a rule that will
    be matched. Additionally, as TypeScript already treats `\` as an escape character,
    we have to escape the escape character as well so that the expression engine sees
    the correct value.
  prefs: []
  type: TYPE_NORMAL
- en: When we want a regular expression to say a value must be this or that, we group
    the expression and then use `|` to break it apart. Looking at our expression there,
    we see that we are looking for the (*nnn*) part first and, if that is not matched,
    we look at the *nnn* part instead.
  prefs: []
  type: TYPE_NORMAL
- en: We also said that this value could be followed by a hyphen, period, or space.
    We use `[-. ]` to match a single character from that list. To make this test optional,
    we put `?` at the end.
  prefs: []
  type: TYPE_NORMAL
- en: With this knowledge, we see that the next part of the regular expression, `(?:[0-9]{3})[-.
    ]?`, is looking for three numbers optionally followed by a hyphen, period, or
    space. The final part, `(?:[0-9]{4})`, states that the number must end in four
    digits. We now know that we can match numbers such as (555) 123-4567, 123.456.7890,
    and (555) 543 9876.
  prefs: []
  type: TYPE_NORMAL
- en: For our purpose, simple zip code and phone number validations such as these
    work perfectly. In larger-scale applications, we do not want to rely on these
    as validation. These only test the data that looks to be in a particular format;
    they don't actually check to see whether they belong to real addresses or phones.
    If we reached a stage with our application where we actually wanted to verify
    that these existed, we would have to hook up to the services that did these checks.
  prefs: []
  type: TYPE_NORMAL
- en: Applying validation in a React component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our mock layout, we identified that we wanted our validation to appear below
    the `Save` and `Clear` buttons. While we could do this inside our main component,
    we are going to separate our validation out into a separate validation component.
    The component will receive the current state of our main component, apply the
    validation whenever the state changes, and return whether we can save our data.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a similar way to how we created our `PersonalDetails` component, we are
    going to create properties to pass into our component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We are going to create a component in `FormValidation.tsx`, that will apply
    the different `IValidation` classes that we have just created. The constructor
    simply adds the different validators into an array that we will shortly iterate
    over and apply the validation for:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In the `Validate` method, we apply each piece of validation inside `forEach`
    before we call the `CanSave` method from our properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we add our `render` method, we are going to revisit `PersonalDetails`
    and add our `FormValidation` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The `userCanSave` method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: So, whenever the validation is updated, our `Validate` method calls back to
    `userCanSave`, which has been passed in as a property.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last thing we need to do to get our validation running is to call the `Validate`
    method from the `render` method. We do this because the render cycle is called
    whenever the state of the parent changes. When we have a list of validation failures,
    we need to add them into our DOM as elements that we want to render back to the
    interface. A simple way to do this is to create a map of all of the failures and
    provide an iterator as a function that will loop over each failure and write it
    back as a row to the interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: At this point, whenever we change the state inside the application, our validation
    will automatically be triggered and any failures will be written in the browser
    as a `label` tag.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and sending data to the IndexedDB database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It would make for a very poor experience when using the application if we could
    not save details for use the next time we came back to it. Fortunately, newer
    web browsers provide support for something called IndexedDB, which is a web browser-based
    database. Using this as our data store means that the details will be available
    when we reopen the page.
  prefs: []
  type: TYPE_NORMAL
- en: While we are working with the database, we have two distinct areas that we need
    to bear in mind. We require code to build the database table and we require code
    to save the records in a database. Before we start writing the database table,
    we are going to add the ability to describe what our database looks like, which
    will be used to build the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will create a fluent interface to add the information that `ITable`
    exposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The idea behind fluent interfaces is that they allow us to chain methods together
    so that they can be read in an easier fashion. They encourage the idea of keeping
    method operations together, making it easier to read what is happening to an instance
    because the operations are all grouped together. This interface is fluent because
    the methods return `ITableBuilder`. The implementations of these methods use `return
    this;` to allow the chaining of operations together.
  prefs: []
  type: TYPE_NORMAL
- en: With fluent interfaces, not all methods need to be fluent. If you create a non-fluent
    method on an interface, that becomes the end of the call chain. This is sometimes
    used for classes that need to set some properties and then build an instance of
    a class that has those properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other side of building the table is the ability to get the values from
    the builder. As we want to keep our fluent interface purely dealing with adding
    the details, we are going to write a separate interface to retrieve these values
    and build our IndexedDB database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'While both of these interfaces serve different purposes and will be used by
    classes in different ways, they both refer to the same underlying code. When we
    write the class that exposes these interfaces, we are going to implement both
    the interfaces in the same class. The reason for doing this is so that we can
    segregate how they behave depending on which interface our calling code sees.
    Our table building class definition looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, if we tried to build this right now, it would fail because we haven''t
    implemented either of our interfaces. The code for the `ITableBuilder` portion
    of this class looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'For the most part, this is simple code. We have defined a number of member
    variables to hold the details, and each method is responsible for populating a
    single value. Where the code does get interesting is in the `return` statement.
    By returning this, we have the ability to chain each method together. Before we
    add our `ITable` support, let''s explore how we use this fluent interface by creating
    a class to add the personal details table definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: What this code does is create a table builder that sets the database name to
    `packt-advanced-typescript-ch3` and adds the `People` table to it, setting the
    primary field as `PersonId` and creating an index in this named `personId`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have seen the fluent interface in action, we need to complete the
    `TableBuilder` class by adding the missing `ITable` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The `Build` method is the most interesting one in this part of the code. This
    is where we physically create the table using the methods from the underlying
    IndexedDB database. `IDBDatabase` is the connection to the actual IndexedDB database,
    which we are going to retrieve when we start writing the core database functionality.
    We use this to create the object store that we will use to store our people records.
    Setting `keyPath` allows us to give the object store a field that we want to search
    in, so it will match the name of a field. When we add indexes, we can tell the
    object store what fields we want to be able to search in.
  prefs: []
  type: TYPE_NORMAL
- en: Adding active record support to our state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we look at our actual database code, we need to introduce one last piece
    of the puzzle—the object that we are going to store. While we have been working
    with state, we have been using `IPersonState` to represent the state of a person
    and, as far as the `PersonalDetails` component goes, that is sufficient. While
    working with the database, we want to expand this state. We are going to introduce
    a new `IsActive` parameter that will determine whether a person is shown on the
    screen. We don''t need to change the implementation of `IPersonState` to add this
    capability; we are going to use an intersection type to handle this instead. The
    first thing we have to do is add a class that has this active flag and then create
    our intersection type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Working with the database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have the ability to build the table and a representation of the
    state that we want to save into the table, we can turn our attention to connecting
    to the database and actually manipulating data in it. The first thing that we
    are going to do is define our class as a generic type that can work with any type
    that extends the `RecordState` class we just implemented:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The reason we need to specify the type that we accept in this class is that
    most of the methods in it are going to either accept instances of that type as
    a parameter or return instances of that type to be worked with in the calling
    code.
  prefs: []
  type: TYPE_NORMAL
- en: As IndexedDB has become the standard client-side database, it has become something
    that can be directly accessed from the window object. TypeScript provides strong
    interfaces to support the database, so it is exposed as an `IDBFactory` type.
    This is important to us because it gives us access to operations such as opening
    the database. Effectively, this is the route that our code has to begin at to
    start manipulating data.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever we want to open the database, we give it a name and version. If the
    database name does not exist, or we are attempting to open a newer version, then
    our application code needs to upgrade the database. This is where the `TableBuilder`
    code comes into play. As we have specified that `TableBuilder` implements an `ITable`
    interface to provide the ability to read values and build the underlying database
    table, we are going to use that (the table instance is passed into the constructor,
    as we will see shortly).
  prefs: []
  type: TYPE_NORMAL
- en: Working with IndexedDB can seem slightly strange at first because it emphasizes
    the use of event handlers a lot. For instance, when we attempt to open the database,
    if the code decides that an upgrade is needed, it triggers the `upgradeneeded`
    event, which we handle using `onupgradeneeded`. This use of events allows our
    code to behave asynchronously because the execution continues without waiting
    for the operation to complete. Then, when the event handler is triggered, it takes
    over the processing. We will be seeing a lot of this when we add our data methods
    to this class.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this information in mind, we can write our `OpenDatabase` method to open
    the database with the value from the `Version` method. The first time we hit this
    code, we are going to need to write the database table. Even though this is a
    new table, it is treated as an upgrade so the `upgradeneeded` event is triggered.
    Again, we can see the benefit of having the ability to build the database in the
    `PersonalDetailsTableBuilder` class because we keep our database code free from
    knowing how to build the table. By doing this, we can reuse this class for writing
    other types to the database if we need to. When the database opens, the `onsuccess`
    handler will be triggered, and we will set an instance-level `database` member
    that we can use later on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have the ability to build and open the table that is in place,
    we are going to write a constructor that accepts the `ITable` instance, which
    we will use to build the table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'We have one last helper method to write for this class before we start writing
    the code that works with the data. In order to write data to the database, we
    have to create a transaction and retrieve an instance of the object store from
    it. Effectively, the object store represents a single table in our database. Essentially,
    we require an object store if we want to read or write data. As this is so common,
    we create a `GetObjectStore` method that returns the object store. For convenience,
    we are going to allow our transaction to treat every operation as read or write,
    which we specify when we call the transaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: As we go through the code, you will see that I have chosen to name the methods
    `Create`, `Read`, `Update`, and `Delete`. It is fairly common to name the first
    two methods `Load` and `Save`; however, I chose these method names deliberately,
    because when working with data in databases, we often use the term *CRUD operation*,
    where **CRUD** refers to **Create**, **Read**, **Update**, and **Delete**. By
    adopting this naming convention, I hope that this solidifies this connection for
    you.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first (and simplest) method that we are going to add will allow us to save
    a record to the database. The `Create` method takes in an individual record, gets
    the object store, and adds the record to the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'When I was originally writing the code for this chapter, I wrote the `Read`
    and `Write` methods to use callback methods. The idea behind the callback method
    was simply to accept a function that our methods could *call back to* when the
    `success` event handlers were triggered. When we look at a lot of IndexedDB samples,
    we can see that they tend to adopt this type of convention. Before we look at
    the finalized version, let''s take a look at what the `Read` method originally
    looked like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The method opens by getting the object store and using it to open something
    called a cursor. A cursor provides us with the ability to read a record and move
    onto the next one; so, when the cursor is opened, the success event is triggered,
    which means that we enter the `onsuccess` event handler. As this happens asynchronously,
    the `Read` method completes, so we will rely on the callback to transfer the actual
    values back to the class that called it. The rather strange-looking `callback:
    (value: T[]) => void` is the actual callback that we will use to return the array
    of `T` items back to the calling code.'
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `success` event handler, we get the result from the event, which
    will be a cursor. Assuming that the cursor is not null, we get the result from
    the cursor and add the record to our array if the state of our record is active;
    this is why we apply the generic constraint to our class—so that we can access
    the `IsActive` property. We then call `continue` on the cursor, which moves on
    to the next record. The `continue` method results in `success` being fired again,
    which means that we re-enter the `onsuccess` handler, resulting in the same code
    happening for the next record. When there are no more records, the cursor will
    be null so the code will call back to the calling code with the array of items.
  prefs: []
  type: TYPE_NORMAL
- en: 'I mentioned that this was the initial implementation of this code. While callbacks
    are useful, they don''t really take advantage of the power that TypeScript gives
    us. What this misses is the ability to use promises in our code base. As we are
    relying on a promise, we are going to gather all of the records together before
    we return them to the calling code. This means that we will have some minor structural
    differences to the logic inside our `success` handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: As this is returning a promise, we drop the callback from the method signature
    and return a promise of an array of `T`. One of the things we have to be aware
    of is that the scope of the array we are going to use to store the results in
    has to be outside the `success` event handler; otherwise, we would reallocate
    it every time we hit `onsuccess`. What is interesting about this code is how similar
    it is to the callback version. All we have done is change the return type while
    dropping the callback from the method signature. The response part of our promise
    acts in place of the callback.
  prefs: []
  type: TYPE_NORMAL
- en: In general, if our code accepts a callback, we can convert it to a promise by
    returning a promise with the callback moved from the method signature into the
    promise itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'The logic for our cursor is the same as we rely on the cursor check to see
    whether we have a value, and, if we do, we push it onto our array. When there
    are no more records, we call the response on our promise so that the calling code
    can work with it in the `then` part of the promise. To illustrate this, let''s
    examine the `loadPeople` code in `PersonalDetails`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Read` method is the most complicated part of our CRUD operation. The next
    method that we are going to write is the `Update` method. When the record has
    been updated, we want to reload the records in our list so that changes to the
    first or last names are updated on the screen. The object store operation that
    updates our record is `put`. If it completes successfully, it raises the success
    event, which leads our code to call the `resolve` property on our promise. As
    we are returning a `Promise<void>` type, we have the ability to use the `async`/`await`
    syntax when calling this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Our final database method is the `Delete` method. The syntax of the `Delete`
    method is very similar to that of the `Update` method—the only real difference
    is that it just takes the index, which tells it what row to `delete` in the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Accessing the database from PersonalDetails
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can now add database support to our `PersonalDetails` class. The first thing
    we are going to do is update the member variables and constructor to bring in
    the database support and store the list of people we want to display:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we add the members:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we update the constructor to hook up to the database and create `TableBuilder`
    using `PersonalDetailsTableBuilder`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'One thing that we still have to do is add the ability to show people into our
    `render` method. In a similar way to displaying the validation failures using
    `map`, we are going to apply `map` to the `people` array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'This is then rendered out with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The Load button is one of a number of places that the `loadPeople` method is
    called from in this class. We will see it in use when we update and then delete
    the records.
  prefs: []
  type: TYPE_NORMAL
- en: When working with database code, it is common to encounter situations where
    the deletion of a record should not physically delete the record from the database.
    We might not want to physically delete it because another record points to that
    one, and so deleting it will break the other record. Alternatively, we might have
    to keep it in place for auditing purposes. In those cases, it is common to do
    something called a soft delete (a hard delete being the one where the record is
    deleted from the database). With a soft delete, there is a flag on a record that
    indicates whether the record is active. While `IPersonState` does not provide
    this flag, the `PersonRecord` type does because it is an intersection of `IPersonState`
    and `RecordState`. Our `delete` method is going to change `IsActive` to `false`
    and update the database with that value. The code that loads the people already
    understands that it is retrieving records where `IsActive` is `true`, so these
    deleted records will disappear as soon as the list is reloaded. This means that,
    while we wrote a Delete method in our database code, we aren't actually going
    to be using it. It's there as a handy reference and you might want to change the
    code to do a hard delete but this isn't necessary for our purpose.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Delete button is going to trigger the delete operation. As there can be
    a number of items in this list, and we cannot assume that the user is going to
    select a person before deleting them, we need to find that person from the list
    of people before we attempt to delete them. Looking back at the code to render
    out the people, we can see that the ID of the person is passed across to the event
    handler. Before we write our event handler, we are going to write the method that
    asynchronously deletes the person from the database. The first thing we are going
    to do in this method is find the person using the `find` array method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Assuming that we find the person from the array, we need to get the person
    into a state where we can set `IsActive` to `false`. We start off by creating
    a new instance of `RecordState`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'We have an intersection type, `PersonRecord`, made up of the intersection of
    the person and record states. We are going to spread `foundPerson` and `personState`
    to give us our `PersonRecord` type. With this in place, we are going to call our
    `Update` database method. What we want to do, when our update has completed, is
    reload the list of people and clear the item currently in the editor—just in case
    it''s the one that we have just deleted; we don''t want the user to be able to
    reinstate the record simply because they save it again with `IsActive` set to
    `true`. We are going to use the fact that we can use `await` on code written as
    a promise to wait until the record has been updated before we carry on with the
    processing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The `clear` method simply changes the state back to our default state. That''s
    the whole reason we passed it into this component, so that we can easily clear
    the values back to their default state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Using our `delete` event handler, the full code for this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The last database operations we need to hook up to are triggered from the Save
    button. What happens with the save depends on whether we have previously saved
    the record, which can be identified by whether `PersonId` is empty. Before we
    attempt to save the record, we have to determine whether it can be saved. This
    comes down to checking whether the validation says we can save or not. If there
    are outstanding validation failures, we are going to alert the users that they
    cannot save the record:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly to how we used the deletion technique, we are going to create our
    `PersonRecord` type by bringing the state together with `RecordState`. This time,
    we set `IsActive` to `true` so that it is picked up as a live record:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'When we insert our record, we need to assign it a unique value for `PersonId`.
    For simplicity, we are just going to use it with the current date and time. When
    we add the person to the database, we reload the list of people and clear the
    current record from the editor so that the user cannot insert a duplicate just
    by clicking on Save again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The code to update the person leverages the features of a promise so that the
    list of people is updated immediately after it has finished saving. We do not
    need to clear the current record in this case because if the user clicks on Save
    again, there is no possibility that we are going to create a new record—but we
    will simply update the current one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The completed method for saving is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'There is one last method that we need to cover. What you may have noticed is
    that we have no way of selecting and displaying a user in the textboxes when we
    click on the Edit button. Logic dictates that pressing the button should trigger
    an event that passes `PersonId` to an event handler, which we can use to find
    the relevant person from the list; we have already seen this type of behavior
    when using the Delete button, so we have a good idea of what the selection portion
    of the code will look like. Once we have the person, we call `setState` to update
    the state, which will update the display through the power of binding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: We now have all the code we need to build our contact manager with React. We
    have satisfied the requirements that we set out at the start of the chapter and
    our display looks close enough to our mock layout.
  prefs: []
  type: TYPE_NORMAL
- en: Enhancements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Create` method has a potential problem in that it assumes that it succeeds
    immediately. It does not handle the `success` event for the operation. Additionally,
    there is a further issue in that `add` operations have a `complete` event because
    the `success` event may fire before the record has been successfully written to
    the disk, and, if the transaction fails, the `complete` event is not raised. You
    can convert the `Create` method so that it uses a promise and resumes processing
    when the `success` event is raised. Then, update the insert portion of the component
    to reload once this has been completed.
  prefs: []
  type: TYPE_NORMAL
- en: The deletion resets the state even if the user wasn't editing the record that
    was deleted. So, enhance the delete code to only reset the state if the record
    being edited is the same as the one that was deleted.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter introduced us to the popular React framework and discussed how
    we can use it with TypeScript to build a modern client side application to add
    contact information. We started by defining the requirements and creating a mock
    layout of our application before we created the basic implementation using `create-react-app`
    with the `react-scripts-ts` script version. To leverage Bootstrap 4 in a React-friendly
    way, we added in the `reactstrap` package.
  prefs: []
  type: TYPE_NORMAL
- en: After discussing how React uses the special JSX and TSX formats to control the
    way it renders, we moved on to customizing the `App` component and adding our
    own custom TSX components. With these components, we looked at passing properties
    and setting up state, which we then used to create two-way bindings. With the
    bindings, we discussed how to validate user inputs by creating reusable validators
    that were then applied to validation classes. As part of the validation, we added
    two regular expressions, which we analyzed to understand how they were constructed.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we examined how to save personal information in the IndexedDB database.
    The first part of this was to understand how to build the database and tables
    using table builders, which was complemented by looking at how to work with the
    database. We looked at how to convert a callback-based method to use the promises
    API to provide asynchronous support as well as the difference between soft and
    hard deletes of data.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to move on to using Angular with MongoDB,
    Express, and Node.js, which are collectively known as the MEAN stack, to build
    a photo gallery application.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What gives React the ability to mix visual elements with code inside the `render`
    method?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why does React use `className` and `htmlFor`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We saw that phone numbers can be validated using the regular expression `^(?:\\((?:[0-9]{3})\\)|(?:[0-9]{3}))[-.
    ]?(?:[0-9]{3})[-. ]?(?:[0-9]{4})$`. We also discussed that there was an alternative
    way of representing a single digit. How could we convert this expression to give
    exactly the same result with the alternative representation?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why do we create validators separately from validation code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between a soft delete and a hard delete?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React is a big topic. In order to find out more about the ideas behind it, I
    recommend *React and React Native* –* Second Edition *([https://www.packtpub.com/application-development/react-and-react-native-second-edition](https://www.packtpub.com/application-development/react-and-react-native-second-edition)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more information on using React with TypeScript, I recommend *Learn React
    with TypeScript 3* by Carl Rippon ([https://www.packtpub.com/web-development/learn-react-typescript-3](https://www.packtpub.com/web-development/learn-react-typescript-3)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Packt also publishes the excellent book *JavaScript Regular Expressions* by
    Loiane Groner and Gabriel Manricks ([https://www.packtpub.com/web-development/javascript-regular-expressions](https://www.packtpub.com/web-development/javascript-regular-expressions)), if
    you want to take your regular expression knowledge to the next level.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
