- en: Immutability versus Mutability - The Balance between Safety and Speed
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In recent years, development practices have moved to a more functional style
    of programming. This means less focus on mutable programming (changing variables
    instead of creating new ones when we want to modify something). Mutability happens
    when we change a variable from one thing to another. This could be updating a
    number, changing what the message says, or even changing the item from a string
    to a number. A mutable state leads to quite a few areas of programming pitfalls,
    such as undetermined state, deadlocking in multithreaded environments, and even
    the changing of data types when we did not mean to (also known as side effects).
    Now, we have many libraries and languages that help us curtail this behavior.
  prefs: []
  type: TYPE_NORMAL
- en: All of this has caused a push toward the use of immutable data structures and
    functions that create new objects based on the input. While this leads to fewer
    errors in terms of mutable state, it presents a host of other issues, predominantly,
    higher memory usage and lower speeds. Most JavaScript runtimes do not have optimizations
    that allow for this style of programming. When we are concerned with memory and
    speed, we need to have as much of an advantage as possible, and this is the advantage
    mutable programming gives us.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to focus on the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Current trends with immutability on the web
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing safe mutable code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functional-like programming on the web
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are prerequisites for this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: A web browser, preferably Chrome
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An editor; VS Code is preferred
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Knowledge of current state libraries such as Redux or Vuex
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The relevant code can be found at [https://github.com/PacktPublishing/Hands-On-High-Performance-Web-Development-with-JavaScript/tree/master/Chapter02](https://github.com/PacktPublishing/Hands-On-High-Performance-Web-Development-with-JavaScript/tree/master/Chapter02).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The current fascination with immutability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A look at current web trends shows the fascination with utilizing immutability.
    Libraries such as React can be used without their immutable state counterparts,
    but they are usually used along with Redux or Facebook's Flow library. Any of
    these libraries will showcase how immutability can lead to safer code and fewer
    bugs.
  prefs: []
  type: TYPE_NORMAL
- en: For those of you who do not know, immutability means that we cannot change the
    variable once it has been set with data. This means that once we assign something
    to a variable, we can no longer change that variable. This helps prevent unwanted
    changes from happening, and can also lead to a concept called **pure functions**.
    We will not be going into what pure functions are, but just be aware that it is
    a concept that many functional programmers have been bringing to JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: But, does that mean we need it and does it lead to a faster system? In the case
    of JavaScript, it can depend. A well-managed project with documentation and testing
    can easily showcase how we would possibly not need these libraries. On top of
    this, we may need to actually mutate the state of an object. We may write to an
    object in one location, but have many other parts read from that object.
  prefs: []
  type: TYPE_NORMAL
- en: There are many patterns of development that can give us similar benefits to
    what immutability can without the overhead of creating a lot of temporary objects
    or even going into a fully pure functional style of programming. We can utilize
    systems such as **Resource Acquisition Is Initialization** (**RAII**). We may
    find that we want to use some immutability, and in this case, we can utilize built-in
    browser tools such as `Object.freeze()` or `Object.seal()`.
  prefs: []
  type: TYPE_NORMAL
- en: However, we are getting ahead of ourselves. Let's take a look at a couple of
    the libraries mentioned and see how they handle immutable states and how it could
    potentially lead to problems when we are coding.
  prefs: []
  type: TYPE_NORMAL
- en: A dive into Redux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Redux** is a great state management system. When we are developing complex
    systems such as Google Docs or a reporting system that lets us look up various
    user statistics in real time, it can manage the state of our application. However,
    it can lead to some overly complicated systems that may not need the state management
    that it represents.'
  prefs: []
  type: TYPE_NORMAL
- en: Redux takes the philosophy that no one object should be able to mutate the state
    of an application. All of that state needs to be hosted in a single location and
    there should be functions that handle state changes. This would mean a single
    location for writes, and multiple locations able to read the data. This is similar
    to some concepts that we will want to utilize later.
  prefs: []
  type: TYPE_NORMAL
- en: However, it does take things a step further and many articles will want us to
    pass back brand-new objects. There is a reason for this. Many objects, especially
    those that have multiple layers, are not easy to copy off. Simple copy operations,
    such as using `Object.assign({}, obj)` or utilizing the spread operator for arrays,
    will just copy the references that they hold inside. Let's take a look at an example
    of this before we write a Redux-based application.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we open up `not_deep_copy.html` from our repository, we will see that the
    console prints the same thing. If we take a look at the code, we will see a very
    common case of copying objects and arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If we make this only a single layer deep, we will see that it actually executes
    a copy. The following code will showcase this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We will go into more detail regarding this case and how to truly execute a
    deep copy, but we can begin to see how Redux may hide problems that are still
    in our system. Let''s build out a simple Todo application to at least showcase
    Redux and what it is capable of. So, let''s begin:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we will need to pull down Redux. We can do this by utilizing **Node Package
    Manager** (**npm**) and installing it in our system. It is as simple as `npm install
    redux`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will now go into the newly created folder and grab the `redux.min.js` file
    and put it into our working directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We now will create a file called `todo_redux.html`. This will house all of our
    main logic.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the top of it, we will add the Redux library as a dependency.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will then add in the actions that we are going to perform on our store.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will then set up the reducers that we want to use for our application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will then set up the store and prepare it for data changes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will then subscribe to those data changes and make updates to the UI.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The example that we are working on is a slightly modified version of the Todo
    application from the Redux example. The one nice thing is that we will be utilizing
    the vanilla DOM and not utilizing another library such as React, so we can see
    how Redux can fit into any application if the need arises.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, our actions are going to be adding a `todo` element, toggling a `todo`
    element to complete or not complete, and setting the `todo` elements that we want
    to see. This code appears as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Next, the reducers will be separated, with one for our visibility filter and
    another for the actual `todo` elements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The visibility reducer is quite simple. It checks the type of action and, if
    it is a type of `SET_VISIBILITY_FILTER`*,* we will handle it, otherwise, we just
    pass the state object on. For our `todo` reducer, if we see an action of `ADD_TODO`,
    we will return a new list of items with our item at the bottom. If we toggle one
    of the items, we return a new list with that item set to the opposite of what
    it was set to. Otherwise, we just pass the state object on. All of this looks
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: After this, we put both reducers into a single reducer and set up the `state`
    object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The heart of our logic lies in UI implementation. Notice that we set this up
    to work off the data. This means that data could be passed into our function and
    the UI would update accordingly. We could make it the other way around, but making
    the UI be driven by data is a good paradigm to live by. We first have a previous
    state store. We can utilize this further by only updating what was actually updated,
    but we only use it for the first check. We grab the current state and check the
    differences between the two. If we see that the length has changed, we know that
    we should add a `todo` item. If we see that the visibility filter was changed,
    we will update the UI accordingly. Finally, if neither of these is true, we will
    go through and check which item was checked or unchecked. The code looks like
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run this, we should get a simple UI that we can interact with in the
    following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Add `todo` items.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mark existing `todo` items as complete.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are also able to have a different view of it by clicking on one of the three
    buttons at the bottom as seen in the following screenshot. If we only want to
    see all of our completed tasks, we can click the Update button.
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a46cdc61-ccb1-453c-a5e8-ed9318b16997.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, we are able to save the state for offline storage if we wanted to, or
    we could send the state back to a server for constant updates. This is what makes
    Redux quite nice. However, there are some caveats when working with Redux that
    relate to what we stated previously:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we are going to need to add something to our Todo application to be
    able to handle nested objects in our state. A piece of information that has been
    left out of this Todo application is setting a date by when we want to complete
    that item. So, let''s add some fields for us to fill out to set a completion date.
    We will add in three new number inputs like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we will add in another filter type of `Overdue`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Make sure to add this to the `visibilityFilters` object. Now, we need to update
    our `addTodo` action. We are also going to pass on a `Date` object. This also
    means we will need to update our `ADD_TODO` case to add the `action.date` to our
    new `todo` object. We will then update our `onclick` handler for our Add button
    and adjust it with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We could hold the date as a `Date` object (this would make more sense), but
    to showcase the issue that can arise, we are just going to hold a new object with
    `year`, `month`, and `day` fields. We will then showcase this date on the Todo
    application by adding another `span` element and populating it with the values
    from these fields. Finally, we will need to update our `setVisibility` method
    with the logic to show our overdue items. It should look like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'With all of this, we should now have a working Todo application, along with
    showcasing our overdue items. Now, this is where it can get messy working with
    state management systems such as Redux. What happens when we want to make modifications
    to an already created item and it is not a simple flat object? Well, we could
    just get that item and update it in the state system. Let''s add the code for
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we are going to create a new button and input that will change the year
    of the last entry. We will add a click handler for the Update button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We will then add in this new action handler for the `todo` system:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we run our code with our system, we will notice something. Our code
    is not getting past the check object condition in our subscription:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We updated the state directly, and so Redux never created a new object because
    it did not detect a change (we updated an object''s value that we do not have
    a reducer on directly). Now, we could create another reducer specifically for
    the date, but we can also just recreate the array and pass it through:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Now, our system detects that there was a change and we are able to go through
    our methods to update the code.
  prefs: []
  type: TYPE_NORMAL
- en: The better implementation would be to split out our `todo` reducer into two
    separate reducers. But, since we are working on an example, it was made as simple
    as possible.
  prefs: []
  type: TYPE_NORMAL
- en: With all of this, we can see how we need to play by the rules that Redux has
    laid out for us. While this tool can be of great benefit for us in large-scale
    applications, for smaller state systems or even componentized systems, we may
    find it better to have a true mutable state and work on it directly. As long as
    we control access to that mutable state, then we are able to fully utilize a mutable
    state to our advantage.
  prefs: []
  type: TYPE_NORMAL
- en: This is not to take anything away from Redux. It is a wonderful library and
    it performs well even under heavier loads. But, there are times when we want to
    work directly with a dataset and mutate it directly. Redux can do this and gives
    us its event system, but we are able to build this ourselves without all of the
    other pieces that Redux gives us. Remember that we want to slim the codebase down
    as much as possible and make it as efficient as possible. Extra methods and extra
    calls can add up when we are working with tens to hundreds of thousands of data
    items.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this introduction into Redux and state management systems complete, we
    should also take a look at a library that makes immutable systems a requirement:
    Immutable.js.'
  prefs: []
  type: TYPE_NORMAL
- en: Immutable.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Again, utilizing immutability, we can code in an easier-to-understand fashion.
    However, it will usually mean we can't scale to the levels that we need for truly
    high-performance applications.
  prefs: []
  type: TYPE_NORMAL
- en: First, Immutable.js takes a great stab at the functional-style data structures
    and methods needed to create a functional system in JavaScript. This usually leads
    to cleaner code and cleaner architecture. But, what we get in terms of these advantages
    leads to a decrease in speed and/or an increase in memory.
  prefs: []
  type: TYPE_NORMAL
- en: Remember, when we're working with JavaScript, we have a single-threaded environment.
    This means that we do not really have deadlocks, race conditions, or read/write
    access problems.
  prefs: []
  type: TYPE_NORMAL
- en: We can actually run into these issues when utilizing something like `SharedArrayBuffers`
    between workers or different tabs, but that is a discussion for later chapters.
    For now, we are working in a single-threaded environment where the issues of multi-core
    systems do not really crop up.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a real-world example of a use case that can come up. We want to
    turn a list of lists into a list of objects (think of a CSV). What might the code
    look like to build this data structure in plain old JavaScript, and another one
    utilizing the Immutable.js library? Our Vanilla JavaScript version may appear
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We construct a new array of the size of the input list minus one (the first
    row is the keys). We then store the row size instead of computing that each time
    for the inner loop later. Then, we create another array to hold the keys and we
    grab those from the first index of the input array. Next, we loop through the
    rest of the entries in the input and create objects. We then loop through each
    inner array and set the key to the value and location `j`, and set the value to
    the input's `i` and `j` values.
  prefs: []
  type: TYPE_NORMAL
- en: Reading in data through nested arrays and loops can be confusing, but results
    in fast read times. On a dual-core processor with 8 GB of RAM, this code took
    83 ms.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s build something similar in Immutable.js. It should look like the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This is much easier to interpret if we understand functional concepts. First,
    we want to create a list based on our input. We then create another temporary
    list for the keys called `_k`*.* For our temporary final list, we utilize the
    `map` function. If we are at the `0` index, we just `return` from the function
    (since this is the keys). Otherwise, we return a new map that is created by zipping
    the keys list with the current value. Finally, we remove the front of the final
    list since it will be undefined.
  prefs: []
  type: TYPE_NORMAL
- en: This code is wonderful in terms of readability, but what are the performance
    characteristics of this? On a current machine, this ran in around 1 second. This
    is a big difference in terms of speed. Let's see how they compare in terms of
    memory usage.
  prefs: []
  type: TYPE_NORMAL
- en: Settled memory (what the memory goes back to after running the code) appears
    to be the same, settling back to around 1.2 MB. However, the peak memory for the
    immutable version is around 110 MB, whereas the Vanilla JavaScript version only
    gets to 48 MB, so a little under half the memory usage. Let's take a look at another
    example and see the results that transpire.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to create an array of values, except we want one of the values
    to be incorrect. So, we will set the 50,000th index to be `wrong` with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we will loop over a new array with a simple `for` loop like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We will also test the built-in `map` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, here''s the immutable version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run these instances, we will see that the fastest will go between the
    basic `for` loop and the built-in `map` function. The immutable version is still
    eight times slower than the others. What happens when we increase the number of
    incorrect values? Let''s add a random number generator for building our temporary
    array to give a random number of errors and see how they perform. The code should
    appear as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Running the same test, we get roughly an average of a tenfold slowdown with
    the immutable version. Now, this is not to say that the immutable version will
    not run faster in certain cases since we only touched on the map and list features
    of it, but it does bring up the point that immutability comes at a cost in terms
    of memory and speed when applying it to JavaScript libraries.
  prefs: []
  type: TYPE_NORMAL
- en: We will look in the next section at why mutability can lead to some issues,
    but also at how we can handle it by utilizing similar ideas to how Redux works
    with data.
  prefs: []
  type: TYPE_NORMAL
- en: There is always a time and a place for different libraries, and this is not
    to say that Immutable.js or libraries like it are bad. If we find that our datasets
    are small or other considerations come into play, Immutable.js might work for
    us. But, when we are working on high-performance applications, this usually means
    two things. One, we will get a large amount of data in a single hit or second,
    and second, we will get a bunch of events that lead to a lot of data build-up.
    We need to use the most efficient means possible and these are usually built into
    the runtime that we are utilizing.
  prefs: []
  type: TYPE_NORMAL
- en: Writing safe mutable code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we move on to writing safe mutable code, we need to discuss references
    and values. A value can be considered anything that is a primitive type. Primitive
    types, in JavaScript, are anything that are not considered objects. To put it
    simply, numbers, strings, Booleans, null, and undefined are values. This means
    that if you create a new variable and assign it to the original, it will actually
    give it a new value. What does this mean for our code then? Well, we saw earlier
    with Redux that it was not able to see that we updated a property in our state
    system, so our previous state and current state showed they were the same. This
    is due to a shallow equality test. This basic test tests whether the two variables
    that were passed in are pointing to the same object. A simple example of this
    is seen with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We will see that the first version says that the two items are equal. But, when
    we create a copy of the object, it states that they are not equal. `y` now has
    a brand-new object and this means that it points to a new location in memory.
    While a deeper understanding of *pass by value* and *pass by reference* can be
    good, this should be sufficient to move on to mutable code.
  prefs: []
  type: TYPE_NORMAL
- en: When writing safe mutable code, we want to give the illusion that we are writing
    immutable code. In other words, the interface should look like we are utilizing
    immutable systems, but we are instead utilizing mutable systems internally. Hence,
    there is a separation of the interface from the implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can make the implementation very fast by writing in a mutable way but give
    an interface that looks immutable. An example of this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We have written a `_map` function on the array prototype so that every array
    gets it and we write a simple `map` function. If we now test run this code, we
    will see that some browsers perform better with this, while others perform better
    with the built-in option. As stated before, the built-ins will eventually get
    faster, but, more often than not, a simple loop is going to be faster. Let''s
    now look at another example of a mutable implementation, but with an immutable
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We wrote a `reduce` function that performs better in every browser. Now, it
    does not have the same amount of type checking, which could lead to better performance,
    but it does showcase how we can write functions that can perform better but give
    the same type of interface that a user of our system expects.
  prefs: []
  type: TYPE_NORMAL
- en: What we have talked about so far is if we were writing a library for someone
    to use to make their lives easier. What happens if we are writing something that
    we or an internal team is going to utilize, as is the case for most application
    developers?
  prefs: []
  type: TYPE_NORMAL
- en: We have two options in this case. First, we may find that we are working on
    a legacy system and that we are going to have to try to program in a similar style
    to what has already been done, or we are developing something rather new and we
    are able to start off from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: Writing legacy code is a hard job and most people will usually get it wrong.
    While we should be aiming to improve on the code base, we are also trying to match
    the style. It is especially difficult for developers to walk through the code
    and see 10 different code choices used because 10 different developers have worked
    on the project over its lifespan. If we are working on something that someone
    else has written, it is usually better to match the code style than to come up
    with something completely different.
  prefs: []
  type: TYPE_NORMAL
- en: With a new system, we are able to write how we want and, with proper documentation,
    we can write something that is quite fast but is also easy for someone else to
    pick up. In this case, we can write mutable code that may have side effects in
    the functions, but we are able to document these cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'Side effects are conditions that occur when a function does not just return
    a new variable or even a reference that the variable passed in. It is when we
    update another variable that we do not have current scope over that this constitutes
    a side effect. An example of this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We have a global variable called `glob` that we are changing inside our function.
    Technically, this function has scope over `glob`, but we should try to define
    the scope of implement to be only what was passed into it and the temporary variables
    that implement have defined inside. Since we are mutating `glob`, we have introduced
    a side effect into our code base.
  prefs: []
  type: TYPE_NORMAL
- en: Now, in some situations, side effects are needed. We may need to update a single
    point, or we may need to store something in a single location, but we should try
    to implement an interface that does this for us instead of us directly affecting
    the global item (this should start to sound a lot like Redux). By writing a function
    or two to affect the out-of-scope items, we can now diagnose where an issue may
    come in because we have those single points of entry.
  prefs: []
  type: TYPE_NORMAL
- en: 'So what might this look like? We could create a state object just as a plain
    old object. Then, we could write a function on the global scope called `updateState`
    that would look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, while this may be good, we are still vulnerable to someone updating our
    state object through the actual global property. Luckily, by making our state
    object and our function `const`, we can make sure that erroneous code cannot touch
    these actual names. Let''s update our code so our state is protected from being
    updated directly. There are two ways that we could do this. The first approach
    would be to code with modules and then our state objects which will be scoped
    to that module. We will look at modules and the import syntax further in the book.
    Instead, on this occasion, we are going to use the second method, code the **Immediately
    Invoked Function Expression** (**IIFE**) way. The following showcases this implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: First, we create a constant state. We then IIFE and pass in the state object,
    setting a bunch of functions on it. It works on an internally `scoped _state`
    variable. We then have all the basic functions that we would expect for an internal
    state system. We also freeze the external state object so it can no longer be
    messed with. One question that may arise is why we are passing back a new object
    instead of a reference. If we are trying to make sure that we don't want anyone
    able to touch the internal state, then we cannot pass a reference out; we have
    to pass a new object.
  prefs: []
  type: TYPE_NORMAL
- en: We still have a problem. What happens if we want to update more than one layer
    deep? We will start running into reference issues again. That means that we will
    need to update our update function to perform a deep update. We can do this in
    a variety of ways, but one way would be to pass the value in as a string and we
    will split on the decimal point.
  prefs: []
  type: TYPE_NORMAL
- en: This is not the best way to handle this since we could technically have a property
    of an object be named with decimal points, but it will allow us to write something
    quickly. Balancing between writing something that is functional, and what is considered
    a complete solution, are two different things and they have to be balanced when
    writing high-performance code bases.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we will have a method that will now look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: What we are doing is breaking the key upon the decimal character. We are also
    grabbing a reference to the internal state object. While we still have items in
    the list, we move one level down in the object. If we find that it is undefined,
    then we will throw an error. Otherwise, once we are one level above where we want
    to be, we return an object with that reference and the final key. We will then
    use this in the getter and setter to replace those values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we still have a problem. What if we want to make a reference type be the
    property value for our internal state system? Well, we will run into the same
    issues that we saw before. We will have references outside the single state object.
    This means we will have to clone each step of the way to make sure that the external
    reference does not point to anything in the internal copy. We can create this
    system by adding a bunch of checks and making sure that when we get to a reference
    type, we clone it in a way that is efficient. This looks like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: What we have done is write a simple clone system. Our `update` function will
    go through the keys and run the update. We will then check for various conditions,
    such as if we are a primitive type. If we are, we just copy the value, otherwise,
    we need to figure out the complex type we are. We first search to see whether
    we are a function; if we are, we just bind the value. If we are an array, we will
    run through all of the values and make sure that none of them are complex types.
    Finally, if we are an object, we will run through all of the keys and try to update
    these running the same checks.
  prefs: []
  type: TYPE_NORMAL
- en: However, we have just done what we have been avoiding; we have created an immutable
    state system. We can add more bells and whistles to this centralized state system,
    such as eventing, or we can implement a coding standard that has been around for
    quite some time, called **Resource Allocation Is Initialization** (**RAII**).
  prefs: []
  type: TYPE_NORMAL
- en: There is a really nice built-in web API called **proxies**. These are essentially
    systems where we are able to do something when something happens on an object.
    At the time of writing, these are still quite slow and should not really be used
    unless it is on an object that we are not worried about for time-sensitive activities.
    We are not going to talk about them extensively, but they are available for those
    readers who want to check them out.
  prefs: []
  type: TYPE_NORMAL
- en: Resource allocation is initialization (RAII)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The idea of RAII comes from C++, where we have no such thing as a memory manager.
    We encapsulate logic where we potentially want to share resources that need to
    be freed after their use. This makes sure that we do not have memory leaks, and
    that objects that are utilizing the item are doing so in a safe manner. Another
    name for this is **scope-bound resource management** (**SBRM**), and is also utilized
    in another recent language called Rust.
  prefs: []
  type: TYPE_NORMAL
- en: We can apply the same types of ideas that C++ and Rust do in terms of RAII in
    our JavaScript code. There are a couple of ways that we can handle this and we
    are going to look at them. The first is the idea that when we pass an object into
    a function, we can then `null` out that object from our calling function.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will have to use `let` instead of `const` in most cases for this to
    work, but it is a useful paradigm to make sure that we are only holding on to
    objects that we need.
  prefs: []
  type: TYPE_NORMAL
- en: 'This concept can be seen in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run the following code, we will notice that we are trying to append to
    a `null`. This is where this design can get us into a bit of trouble. We have
    an asynchronous method and we are trying to use a value that we have nullified
    even though we still need it. What is the best way to handle this situation? One
    way is to `null` it out once we are done using it. Hence, we can change the code
    to look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We still have a problem. Before the next part of the `Promise` (the `then`
    method) runs, we could still modify the value. One final good idea would be to
    wrap this input to output in a new function. This will give us the safety that
    we are looking for, while also making sure we are following the principle behind
    RAII. The following code is what comes out of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We can also get rid of some of the preceding nulls since the functions will
    take care of those temporary variables. While this example is rather trivial,
    it does showcase one way of handling RAII inside JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: On top of this paradigm, we can also add properties to the item that we are
    passing to say that it is a read-only version. This would ensure that we are not
    modifying the item, but we also do not need to `null` out the element on the calling
    function if we still want to read from it. This gives us the benefit of making
    sure our objects can be utilized and maintained without the worry that they will
    be modified.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will take out the previous code example and update it to utilize this read-only
    property. We first define a function that will add it to any object that comes
    in like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, in our `onclick` method, we pass our output into this method. This has
    now attached the `readonly` property to it. Finally, in our `showHashData` function,
    when we try to access it, we have put a guard on the `readonly` property. If we
    notice that the object has it, we will not try to append to it, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We have also set this property to not be writable, so if a nefarious actor decided
    to manipulate our object's `readonly` property, they will still notice that we
    are no longer appending to the DOM. The `defineProperty` method is very powerful
    for writing APIs and libraries that cannot be easily manipulated. Another way
    of handling this is to freeze the object. With the `freeze` method, we are able
    to make sure that the shallow copy of an object is read-only. Remember that this
    is only for the shallow instance, not any other properties that hold reference
    types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we can utilize a counter to see whether we can set the data. We are
    essentially creating a read-side lock. This means that while we are reading the
    data, we do not want to set the data. This means we have to take many precautions
    that we are properly releasing the data once we have read what we want. This can
    look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: What we have done is set up a constructor function. We hold the data, the number
    of readers, and a custom event as private variables. We then create three methods.
    First, `getData` will grab the data and also add a counter to someone that is
    utilizing it. Next, we have the `release` method. This will decrement the counter,
    and if we are at 0, we will dispatch an event to tell the `setData` event that
    it can finally write to the mutable state. Finally, we have the `setData` function.
    A promise will be the return value. If there is no one that is holding the data,
    we will set it and resolve it right away. Otherwise, we will set up an event listener
    for our custom event. Once it fires, we will set the data and resolve the promise.
  prefs: []
  type: TYPE_NORMAL
- en: Now, this final method of locking mutable data should not be utilized in most
    contexts. There may only be a handful of times when you will want to utilize this,
    such as a hot cache where we need to make sure that we do not overwrite something
    while a reader is reading from this (this can happen on the Node.js side of things
    especially).
  prefs: []
  type: TYPE_NORMAL
- en: All of these methods help create a safe mutable state. With each of these, we
    are able to mutate an object directly and share that memory space. Most of the
    time, good documentation and careful control over our data will make it so we
    do not need to go to the extremes that we have here, but it is good to have these
    methods of RAII in our back pocket when we find something crops up and we are
    mutating something that we should not be.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the time, the immutable and highly functional code will be more readable
    in the end and, if something does not need to be highly optimized, it is suggested
    to go for being readable. But, in high optimization cases, such as encoding and
    decoding or decorating columns in a table, we will need to squeeze out as much
    performance as we can. This will be seen later in the book where we utilize a
    mixture of programming techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Even though mutable programming can be fast, sometimes, we want to implement
    things in a functional manner. The following section will explore ways to implement
    programs in this functional manner.
  prefs: []
  type: TYPE_NORMAL
- en: Functional style programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even after all of this talk about functional concepts not being the best in
    terms of raw speed, it can still be quite helpful to utilize them in JavaScript.
    There are many languages out there that are not purely functional and all of these
    give us the ability to utilize the best ideas from many paradigms. Languages such
    as F# and Scala come to mind. There are a few ideas that are great when it comes
    to this style of programming and we can utilize them in JavaScript with built-in
    concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Lazy evaluation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In JavaScript, we can perform what is called lazy evaluation. Lazy evaluation
    means that the program does not run what it does not need to. One way of thinking
    about this is when someone is given a list of answers to a problem and they are
    told to put the correct answer to the problem. If they see that the answer was
    the second item that they looked at, they are not going to keep going through
    the rest of the answers they were given; they are going to stop at the second
    item. The way we use lazy evaluation in JavaScript is with generators.
  prefs: []
  type: TYPE_NORMAL
- en: 'Generators are functions that will pause execution until the `next` method
    is called on them. A simple example of this is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: First, we notice that `function` has a star next to it. This shows that this
    is a generator function. Next, we set up a simple variable to hold our value and
    then we have an infinite loop. Some may think that this will run continuously,
    but lazy evaluation shows that we will only run up to the `yield`. This `yield`
    means we will pause execution here and that we can grab the value that we send
    back.
  prefs: []
  type: TYPE_NORMAL
- en: So, we start the function up. We have nothing to pass to it so we just simply
    start it. Next, we call `next` on the generator and grab the value. This gives
    us a single iteration and returns whatever was on the `yield` statement. Finally,
    we call `return` to say that we are done with this generator. If we wanted to,
    we can grab the final value here.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will notice that when we call next and try to grab the value, it returns
    undefined. We can take a look at the generator and notice that it has a property
    called `done`. This can allow us to see with finite generators if they are finished.
    So, how can this be helpful when we want to do something? A rather trivial example
    is a timing function. What we will do is start off the timer before we want to
    time something and then we will call it another time to calculate the time it
    took for something to run (very similar to `console.time` and `timeEnd`, but it
    should showcase what is available with generators).
  prefs: []
  type: TYPE_NORMAL
- en: 'This generator could look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: We are now timing a simple summing function. All this does is seed the timing
    generator with the current time. Once the next function is called, it runs the
    statements up to the `yield` and returns the value held in the `yield`. This will
    give us a new time against the time that we passed in. We now have a simple function
    for timings. This can be especially useful for environments where we may not have
    access to the console and we are going to log this information somewhere else.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just as shown in the preceding code block, we can also work with many different
    types of lazy loading. One of the best types that utilize this interface is streams.
    Streams have been available inside Node.js for quite some time, but the stream
    interface for browsers has a basic standardization and certain parts are still
    under debate. A simple example of this type of lazy loading or lazy reading can
    be seen in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This example shows the concept of lazy evaluation along with a couple of concepts
    for streaming that we will see in a later chapter. First, we create a generator
    that can take in a function and can utilize it for our logic function in creating
    numbers. In our case, we are just going to use the default case and have it generate
    one number at a time. Next, we are going to run this through a `for/of` loop to
    generate numbers up to 101.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a `fakestream` generator that will chunk our data for us. This
    is similar to streams that allow us to work on a chunk of data at a time. We can
    transform this data if we want to (known as a `TransformStream`) or we can just
    let it pass through (a special type of `TransformStream` called a `PassThrough`).
    We create a fake chunk size at `10`. We then run another `for/of` loop over the
    data we had before and simply log it. However, we could decide to do something
    with this data if we wanted to.
  prefs: []
  type: TYPE_NORMAL
- en: This is not the exact interface that streams utilize, but it does showcase how
    we can have lazy evaluation inside our code with generators and that it is also
    built into certain concepts such as streaming. There are many other potential
    uses for generators and lazy evaluation techniques that will not be covered here,
    but they are available to developers who are looking for a more functional-style
    approach to list and map comprehensions.
  prefs: []
  type: TYPE_NORMAL
- en: Tail-end recursion optimization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is another concept that many functional languages have, but most JavaScript
    engines do not have (WebKit being the exception). Tail-end recursion optimizations
    allow recursive functions that are built in a certain way to run just like a simple
    loop. In pure functional languages, there is no such thing as a loop, so the only
    method of working over a collection is to recursively go through it. We can see
    that if we build a function as a tail-recursive function, it will break our stack.
    The following code illustrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We create an array of 100,000 items and assign them all the value that is at
    their index. We then try using a recursive function to sum all of the data in
    the array. Since the last call for the function is the function itself, some compilers
    are able to make an optimization here. If they notice that the last call is to
    the same function, they know that the current stack can be destroyed (there is
    nothing left for the function to do). However, non-optimized compilers (most JavaScript
    engines) will not make this optimization so we keep adding stacks to our call
    system. This leads to a call stack size exceedance and makes it so we cannot utilize
    this purely functional concept.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is hope for JavaScript, however. A concept called trampolining can be
    utilized to make tail-end recursion possible by modifying the function a bit and
    how we call it. The following is the modified code to utilize trampolining and
    give us what we want:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'What we are doing is wrapping our recursive function inside one that we run
    through in a simple loop. The `trampoline` function works like this:'
  prefs: []
  type: TYPE_NORMAL
- en: It takes in a function and returns a newly constructed function that will run
    our recursive function but loop through it, checking the return type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inside this inner function, it starts the loop up by executing a first run of
    the function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While we still see a function as our return type, it will continue looping.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once we finally do not get a function, we will return the results.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We are now able to utilize tail-end recursion to do some of the things that
    we would do in a purely functional world. An example of this was seen previously
    (which could be seen as a simple reduce function). Another example is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: With this function, we are simulating what a filter-based operation may look
    like in a pure functional language. Again, if there is no length, we are at the
    end of the array and we return our filtered array. Otherwise, we return a new
    function that recursively calls itself with a new list, the function that we are
    going to filter with, and then the filtered list. There is a bit of weird syntax
    here. We have to pass back a single array with the new item if we have an empty
    list, otherwise, it will give us an empty array with the number of items that
    we pass in.
  prefs: []
  type: TYPE_NORMAL
- en: We can see that both of these functions pass what is known as tail-end recursion
    and are also functions that could be written in a purely functional language.
    But, we will also see that these run a lot slower than simple `for` loops or even
    the built-in array methods for these types of functions. At the end of the day,
    if we wanted to write purely functional programming using tail-end recursion,
    we could, but it is wise not to do this in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Currying
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The final concept that we will be looking at is currying. Currying is the ability
    of a function that takes multiple arguments to actually be a series of functions
    that takes a single argument and returns either another function or the final
    value. Let''s take a look at a simple example to see this concept in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'What we are doing is taking a function that accepts multiple arguments, such
    as the `add` function. We then return a function that takes a single argument,
    in this case, `b`. This function then adds the numbers `a` and `b` together. What
    this allows us to do is either use the function as we normally would (except we
    run the function that comes back to us and pass in the second argument) or we
    get the return value from running it on a single argument and then use that function
    to add whatever values come next. Each of these concepts can be seen in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: There are a couple of uses for currying and they also show off a concept that
    can be used quite frequently. First, it shows off the idea of partial application.
    What this does is set some of our arguments for us and return a function. We can
    then pass this function along in the chain of statements and eventually use it
    to fill in the remaining functions.
  prefs: []
  type: TYPE_NORMAL
- en: Just remember that all currying functions are partially applied functions, but
    not all partially applied functions are currying functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of partial application can be seen in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: First, we create a function that takes three arguments. We then create a new
    temporary function that binds `2` to the first argument of that function. `Bind`
    is an interesting function. It takes the scope that we want as the first argument
    (what `this` points to) and then takes an arbitrary length of arguments to fill
    in for the arguments of the function we are working on. In our case, we only bind
    the first variable to the number `2`. We then create a second temporary function
    where we bind the first variables of the first temporary function to `3`. Finally,
    we create a third and final temporary function where we bind the first argument
    of the second function to the number `5`.
  prefs: []
  type: TYPE_NORMAL
- en: We can see at each run that we are able to run each of these functions and that
    they take a different number of arguments depending on which version of the function
    we have used. `bind` is a very powerful tool and allows us to pass functions around
    that may get arguments filled in from other functions before the final function
    is used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Currying is the idea that we will use partial application, but that we are
    going to compose a multi-argument function with multiple nested functions inside
    it. So what does currying give us that we cannot already do with other concepts?
    If we are in the pure functional world, we can actually get quite a bit. Take,
    for example, the `map` function on arrays. It wants a function definition of a
    single item (we are going to ignore the other parameters that we normally do not
    use) and wants the function to return a single item. What happens when we have
    a function such as the following one and it could be used inside the `map` function,
    but it has multiple arguments? The following code showcases what we are able to
    do with currying and this use case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: What we are doing is taking a generic function (an arbitrary one at that) and
    utilizing it in the map function by making it more specific, in this case by giving
    the precision two decimal places. This allows us to write very generic functions
    that can work over arbitrary data and make specific functions out of them.
  prefs: []
  type: TYPE_NORMAL
- en: We will utilize partial application a bit in our code and we may use currying.
    In general, however, we will not utilize currying as is seen in purely functional
    languages as this can lead to a slowdown and higher memory consumption. The main
    ideas to take away are partial application and the idea of how variables on the
    outer scope can be used in an inner scoped location.
  prefs: []
  type: TYPE_NORMAL
- en: 'These three concepts are quite crucial to the idea of pure functional programming,
    but we will not utilize most of them. In highly performant code, we need to squeeze
    out every ounce of speed and memory that we can and most of these constructs take
    up more than we care for. Certain concepts can be used to great lengths in high-performance
    code. The following will be used in later chapters: partial application, streaming/lazy
    evaluation, and possibly some recursion. Being comfortable with seeing functional
    code will help when working with libraries that utilize these concepts, but as
    we have talked about at length, they are not as performant as our iterative methods.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have looked at the ideas of mutability and immutability.
    We have seen how immutability can lead to slowdowns and higher memory consumption
    and can be an issue when we are writing high-performance code. We have taken a
    look at mutability and how to make sure we write code that utilizes it, but also
    makes it safe. On top of this, we have performed performance comparisons between
    mutable and immutable code and have seen where speed and memory consumption increases
    for the immutable types. Finally, we took a look at functional-style programming
    in JavaScript and how we can utilize these concepts. Functional programming can
    help with many issues, such as lock-free concurrency, but we also know that the
    JavaScript runtimes are single-threaded and so this does not give us an advantage.
    Overall, there are many concepts that we can borrow from the different paradigms
    of programming and having all of these in our toolkit can make us better programmers
    and help us write clean, safe, and high-performance code.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will take a look at how JavaScript has evolved as a
    language. We will also take a look at how browsers have changed to meet the demands
    of developers, with new APIs that cover everything from accessing the DOM to long-term
    storage.
  prefs: []
  type: TYPE_NORMAL
