- en: Angular ToDo App with GraphQL and Apollo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many different ways to communicate data backward and forward from
    the client to the server. In this chapter, we are going to look at how we can
    use GraphQL to pick data from a server, and then send and mutate data back from
    an Angular client. We will also look at how we can leverage calculated values
    from GraphQL. Building on the content of the previous chapter, we will once again
    be using Angular Material for our user interface to see how we can work with Angular
    routing to serve up different content.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the GraphQL-to-REST relationship
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a reusable database class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prefilling data and using singletons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a GraphQL schema
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up GraphQL types using `type-graphql`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a GraphQL resolver with queries and mutations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Apollo Server as our application server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a GraphQL Angular client application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding Apollo support to the client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using routing in Angular
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling input with Angular validation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending GraphQL mutations from the client to the server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending GraphQL queries from the client to the server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Switching between read-only and editable templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The finished project can be downloaded from [https://github.com/PacktPublishing/Advanced-TypeScript-3-Programming-Projects/tree/master/Chapter05](https://github.com/PacktPublishing/Advanced-TypeScript-3-Programming-Projects/tree/master/Chapter05).
  prefs: []
  type: TYPE_NORMAL
- en: After downloading the project, you will have to install the package requirements
    using the `npm install` command.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the GraphQL-to-REST relationship
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the great things about web-based technologies is the number of ways
    you can solve common problems that crop up. With REST, we used a simple, but powerful,
    way to communicate from the client to the server; however, that''s not the only
    way that we can do this. REST solved a set of problems, but also introduced new
    problems that newer techniques have come to the fore to fix. The three problems
    that need to be solved are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: In order to build up complex information, we may end up having to make multiple
    REST calls to the REST server. For a shopping application, for instance, we may
    use one REST call to pick up a person's name and another REST call to pick up
    their address, with a third call being needed to get their shopping basket details.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Over time, we may go through multiple versions of our REST API. Having our clients
    keep track of the versioning can be restrictive, which means that, right at the
    start of our API, we also have to define what our versioning experience is going
    to be like. Unless our APIs follow the same versioning standards, this can lead
    to confusing code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These REST calls could end up bringing far more information than we actually
    need. So, while we are making these detailed calls, we only actually need three
    or four items of information out of maybe 20 or 30 fields.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One of the things to understand about REST is that it isn't actually a technology.
    A good way to think about REST is that it's more of an agreed architectural standard
    that can use pretty much any transport mechanism as a means of communication.
    Okay, to clarify, while I said it was a standard, in practical terms, very few
    people actually follow the original concept of REST, which means that we also
    need to understand the intent of the developers. For instance, when we issue an
    update over REST, are we using the `PUT HTTP` verb or the `POST` verb? Knowing
    this level of detail is vital if we want to consume a third-party API.
  prefs: []
  type: TYPE_NORMAL
- en: Originally developed by Facebook, but now maintained by the GraphQL foundation
    ([https://foundation.graphql.org/](https://foundation.graphql.org/)), GraphQL
    is a great mechanism to use to address issues like these. Unlike pure REST, GraphQL
    is simply a query language with tooling support. GraphQL revolves around the idea
    that our code will interact with fields, and as long as there is a definition
    of how to get these fields, we can write arbitrarily complex queries to retrieve
    data from multiple locations in one hit, or mutate the data to update it. A properly
    designed GraphQL system takes care of versioning requirements as well as fields,
    which can be added and deprecated on demand.
  prefs: []
  type: TYPE_NORMAL
- en: With GraphQL, we can only retrieve the information that we need with a query.
    This saves us from oversubscribing for information at the client level. Similarly,
    our query can patch the result together from multiple locations for us so that
    we don't have to perform multiple round trips. We send our query from our client
    and let our GraphQL server retrieve the relevant data items. We also don't have
    to worry about REST endpoints in our client code. We simply communicate with our
    GraphQL server, letting the query take care of the data.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we are going to look at how we can use the Apollo GraphQL engine
    ([https://www.apollographql.com/](https://www.apollographql.com/)) and the incredibly
    useful `TypeGraphQL` library ([https://typegraphql.ml/](https://typegraphql.ml/)),
    which provides a convenient way to target GraphQL from TypeScript. With Apollo,
    we have a complete front-to-back infrastructure to completely manage our GraphQL
    behaviors. As well as providing client-side libraries, we can use Apollo on our
    servers, as well as for iOS and Android applications.
  prefs: []
  type: TYPE_NORMAL
- en: Note that GraphQL is not intended to completely replace RESTful services. There
    are many cases where we would want REST and GraphQL to work together, side by
    side. It could be that we have a REST service that communicates with our GraphQL
    implementation and caches information for us, for example. For the purposes of
    this chapter, however, we are going to be concentrating purely on creating a GraphQL
    implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Project overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, our project is going to introduce us to writing GraphQL applications,
    both on the server side and the client side. We are also going to start investigating
    features that were introduced in TypeScript 3 to create a ToDo application. We
    will be expanding on the Angular concepts from the previous chapter to introduce
    client-side routing, which will allow us to show different content and effectively
    navigate between pages. We will also introduce Angular validation.
  prefs: []
  type: TYPE_NORMAL
- en: Working alongside the GitHub code, the task in this chapter should take about
    four hours to complete.
  prefs: []
  type: TYPE_NORMAL
- en: 'When completed, the application should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/afdfcce2-295e-4a37-9db3-bd1916ce19a9.png)'
  prefs: []
  type: TYPE_IMG
- en: Getting started with the project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Just like in the previous chapter, this chapter will use Node.js (available
    from [https://nodejs.org](https://nodejs.org)). We will also be using the following
    components:'
  prefs: []
  type: TYPE_NORMAL
- en: The Angular CLI (I'm using version 7.2.2)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`express` (version 4.16.4 or greater)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mongoose` (version 5.4.8 or greater)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@types/cors` (version 2.8.4 or greater)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@types/body-parser` (version 1.17.0 or greater)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@types/express` (version 4.16.0 or greater)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@types/mongodb` (version 3.1.19 or greater)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@types/mongoose` (version 5.3.11 or greater)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`type-graphql` (version 0.16.0 or greater)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@types/graphql` (version 14.0.7 or greater)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`apollo-server` (version 2.4.0 or greater)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`apollo-server-express` (version 2.4.0 or greater)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`guid-typescript` (version 1.0.9 or greater)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reflect-metadata` (version 0.1.13 or greater)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`graphql` (version 14.1.1 or greater)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`apollo-angular` (version 1.5.0 or greater)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`apollo-angular-link-http` (version 1.5.0 or greater)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`apollo-cache-inmemory` (version 1.4.3 or greater)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`apollo-client` (version 2.4.13 or greater)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`graphql` (version 14.1.1 or greater)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`graphql-tag` (version 2.10.1 or greater)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As well as using MongoDB, we will be using Apollo to serve up our GraphQL data.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a ToDo application with GraphQL and Angular
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As is our custom now, we are going to start off by defining the requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: A user must be able to add a ToDo task consisting of a title, a description,
    and the date the task is due
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validation will ensure that these items are always set and that the due date
    cannot be before today
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The user will be able to see a list of all tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The user will be able to delete a task
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The user will be able to see overdue tasks (where an overdue task is one that
    has not been completed and the due date has passed)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The user will be able to edit a task
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data is transferred to the server, or from the server, using GraphQL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transferred data will be saved to a MongoDB database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating our application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For our ToDo application, we are going to start off with the server implementation.
    As in the previous chapter, we are going to create a separate client and server
    folder structure, with the Node.js code being added to the server code.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re going to start our journey into creating a GraphQL server with the database
    code. All the data for our client is going to come from the database, so it makes
    sense for us to put everything we need in place. As in the previous chapter, we
    are going to install the `mongoose` packages that we need to work with MongoDB:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Something to bear in mind when choosing which command to use to install packages
    relates to the use of `--save` versus `--save-dev`. These are both used to install
    packages, but there is a practical difference between them and how we would expect
    the application to be deployed based on them. When we use `--save`, we are stating
    that this package must be downloaded for the application to run, even if we install
    the application on another computer. This can be wasteful if we intend to deploy
    our application to a machine that already has the correct version of the package
    installed globally. The alternative case is to use `--save-dev` to download and
    install the package as something called a development dependency. In other words,
    the package is installed locally for the developer.
  prefs: []
  type: TYPE_NORMAL
- en: With this in place, we are going to start writing a variation of the `Mongo`
    class we introduced in the previous chapter. The reason that we aren't going to
    reuse that implementation is because we are going to start introducing TypeScript
    3-specific features before we move on to adding a generic database framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'The big change to our class is that we are going to change the signature to
    our `mongoose.connect` method. One of the changes tells Mongoose to use a new
    format URL parser, but the other change ties into the signature of the event that
    we use as a callback:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: From the previous chapter, we should remember that our callback had a signature
    of `e:any`. Now, we are changing it to use `e:unknown` instead. This is a new
    type—introduced to TypeScript 3—that allows us to add an extra level of type safety.
    To a large extent, we can think of the `unknown` type as being similar to `any`
    in that we can assign any type to it. What we can't do, however, is assign it
    to another type without a type assertion. We are going to start moving `any` types
    to `unknown` throughout our code.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we have been using a lot of interfaces to provide the shapes of types.
    We can apply the same technique to Mongo schemas as well so that we can describe
    the shape of our ToDo schema as a standard TypeScript interface, and then map
    it to a schema. Our interface is going to be straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We are going to create a `mongoose` schema that will be mapped into the database.
    A schema simply states what information will be stored using types that MongoDB
    expects. For instance, our `ITodoSchema` exposes `Id` as `string`, but this is
    not the type that MongoDB would expect; instead, it expects to see `String`. Knowing
    this, it''s simple enough to create a mapping from `ITodoSchema` to `TodoSchema`, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We now have a schema model that we can use to query, update, and more. Of course,
    Mongo doesn't limit us to just one schema. If we wanted to use more, there would
    be nothing stopping us from doing so.
  prefs: []
  type: TYPE_NORMAL
- en: A note about what our schema is going to contain—the `Title` and `Description`
    fields are fairly straightforward in that they contain details about what our
    todo item is about. `DueDate` simply tells us when our item is due and `CreationDate`
    tells us when we created this record. We have a `Completed` flag that the user
    will trigger to say when they have completed the task.
  prefs: []
  type: TYPE_NORMAL
- en: The interesting field is the `Id` field. This field differs from the Mongo `Id`
    field, which will still be internally generated. The schema `Id` field is assigned
    something called a **Globally Unique IDentifier** (**GUID**), which is a unique
    string identifier. The reason that we want the UI to add this field is because
    we are going to use it as a known field in our database queries, and we want the
    client to know the value of the `Id` before it needs to perform any round trips.
    When we cover the Angular side, we will see how this field gets populated.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to create a database model that maps the `mongoose.Document` instance
    of our `ITodoSchema` to our `TodoSchema`. This is a straightforward task when
    using `mongoose.model`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Case is very important when we create our `mongoose.model`. As well as `mongoose.model`,
    we also have `mongoose.Model` available, which we would have to instantiate with
    a `new` statement.
  prefs: []
  type: TYPE_NORMAL
- en: We are now in a position to write a relatively generic database class. We do,
    however, have a constraint—we are expecting our schema to have an `Id` field.
    This constraint is purely a convenience to let us concentrate on the logic for
    our demonstration application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we are going to do is create a generic base class that accepts `mongoose.Document`
    as the type. It will probably not come as a surprise to realize that the type
    we will ultimately use against this is `ITodoSchema`. The constructor is going
    to accept a model that we can use for our various database operations. Again,
    we have already created the model that we are going to use as `TodoModel`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Our concrete implementation of this class is very straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We are now going to start adding features to `DataAccessBase`. We will start
    off with a method to get all the records that match our schema. We should be happy
    enough with promises at this stage, so it should be natural for us to return a
    `Promise` type. In this case, the `Promise` type will be an array of `T`, which
    we know maps onto `ITodoSchema`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Internally, we call the `find` method on our model to retrieve all records
    and once the find completes, we call back the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding a record is just as simple. The only real differences are that we call
    the `model.create` method and return a `boolean` value to indicate that we succeeded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'As well as retrieving all records, we could choose to retrieve a single one.
    The big change between this and the `GetAll` method is that the `find` method
    is using search criteria:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have the ability to remove or update records. These are very similar
    in the way we write them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: With the actual database code in place, we can now turn our attention to accessing
    the database. Something that we are going to consider is that we may end up having
    a significant number of todo items building up over time and, if we attempt to
    read them from the database every time we need them, we are going to slow the
    system down as we add more and more todos. To this end, we are going to create
    a basic caching mechanism that will be populated as soon as the database finishes
    loading during the server startup process.
  prefs: []
  type: TYPE_NORMAL
- en: Since the cache is going to be pre-populated, we want to use the same instance
    of our class from GraphQL and from our server, so we are going to create something
    called a **singleton**. A singleton is just another way of saying that we will
    have only one instance of a class present in memory and each class will use the
    same instance. To prevent other classes from being able to create their own instances,
    we will make use of a couple of tricks.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we are going to do is create our class with a private constructor.
    A private constructor means that the only place we can instantiate our class from
    is inside the class itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'It might seem counter-intuitive that we can only create the class from itself.
    After all, if we cannot instantiate the class, how can we access any members?
    The trick to this is to add a field to hold a reference to the class instance,
    and then offer a public static property to access that instance. The public property
    will take care to instantiate the class if it''s not already available, so we
    will always be able to access an instance of the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We now have a way to access the methods we are going to write, so let''s start
    off by creating a method to populate a list of the available items. Since this
    could be a long-running operation, we are going to make it asynchronous:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This method works by calling `GetAll` to retrieve all the records from our MongoDB
    database. Once we have the records, we are going to iterate over them and create
    copies of them to push into our array.
  prefs: []
  type: TYPE_NORMAL
- en: The `TodoItem` class is a special class that we are going to use to map types
    to GraphQL. We will look at this class shortly when we start writing our GraphQL
    server functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s all very well populating the array of items, but if there is no way to
    access the items elsewhere in the code, this class would not be much help. Fortunately,
    accessing the elements is as simple as adding an `Items` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Creating our GraphQL schema
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With our database code in place, we are now ready to turn our attention to
    writing our GraphQL server. One of the earliest decisions I took when writing
    the sample code for this chapter was that we would simplify the process of writing
    our code as much as possible. If we look at a reference sample that Facebook posted,
    we will find that the code can be tediously long-winded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This example is from [https://github.com/graphql/graphql-js](https://github.com/graphql/graphql-js).
    We can see that we have a lot of reliance on special types that don't map one
    to one onto TypeScript types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we want to make our code that bit more TypeScript-friendly, we are going
    to use `type-graphql`. We will install it via `npm`, along with the `graphql`
    type definitions and `reflect-metadata`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'At this stage, we should also set our `tsconfig` file up to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The main thing worth mentioning in this `tsconfig` file relates to the fact
    that `type-graphql` uses features that are only found in ES7, so we need to use
    ES2016 in the lib (ES7 maps onto ES2016).
  prefs: []
  type: TYPE_NORMAL
- en: Setting up our GraphQL types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we just saw, GraphQL types can be a little bit complicated to set up. With
    the aid of `type-graphql` and some handy decorators, we are going to create a
    schema to represent a single item.
  prefs: []
  type: TYPE_NORMAL
- en: 'We don''t need to worry about creating a type to represent multiple items just
    yet. Our item will consist of the following fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Id` (defaulted to an empty string)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Title`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Description` (we are going to set this up as a nullable value for the moment.
    When we create the UI, we are going to add validation to make sure that we always
    supply a description.)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The date the task is due (again, this is nullable)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the task was created
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The number of days since the task was created (this will be automatically calculated
    when we query the data)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whether or not the task has been completed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we pay attention, we will see that the fields here map very closely to the
    ones we defined in our MongoDB schema. This is because we will be populating our
    GraphQL type from the database, as well as updating the database directly from
    these types.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we are used to doing now, we are going to start off with a simple class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'I mentioned that we are going to use decorators with this class. We are going
    to decorate the class definition with `@ObjectType`, which gives us the ability
    to create complex types. Being good developers, we will also supply a description
    so that consumers of our type have documentation about what it represents. Right
    now, our class definition looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We are going to add the fields to our type, one step at a time. First, we are
    going to add the `Id` field, which matches the `Id` field in the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Again, we have supplied a decorator to this field, which will tell `type-graphql`
    how to transform our class into a GraphQL type. By applying `type=>ID`, we are
    using the special GraphQL `ID` type. This type is a string that maps to a unique
    value. It is an identity field, after all, and convention states that identity
    fields must be unique.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to add three nullable fields next—the `Description`, `DueDate`,
    and `CreationDate` fields. We aren''t really going to be allowing null values
    in these, as we will see when we start adding Angular validation later on in this
    chapter, but it''s important for us to see how we can add nullable types for any
    future GraphQL types that we create:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We do have some more simple fields that we are going to make available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `TodoItem`, which represents the schema that makes up the entirety of our
    query type, now looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: As well as having a class for the query, we also need one to represent the data
    that we are going to use to mutate the state for subsequent queries, as well as
    for updating the database.
  prefs: []
  type: TYPE_NORMAL
- en: When we mutate state, we are changing it. We want those changes to be persisted
    across server restarts so they will update both the database and the state we
    are going to cache at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'The class we are going to use for the mutation looks very similar to our `TodoItem`
    class. The key differences are that we use `@InputType` in place of `@ObjectType`
    and the class implements a generic `Partial` type of `TodoItem`. The other difference
    is that this class does not have the `DaysCreated` field because that is going
    to be calculated by our query, so we don''t have to add any values to hold it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: If you don't know what `Partial` does, it simply makes all the properties of
    `TodoItem` optional. This lets us tie our new mutation class back to our old class
    without having to supply every property.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our GraphQL resolver
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `TodoItem` and `TodoItemInput` classes were aimed at giving us schemas that
    describe the fields, types, and arguments. While they are an important part of
    our GraphQL jigsaw, we have a missing piece—the ability to execute functions against
    our GraphQL server.
  prefs: []
  type: TYPE_NORMAL
- en: We need a way to resolve the fields of our types. With GraphQL, a resolver is
    something that represents a single field. It fetches the data that we need, effectively
    giving the GraphQL server detailed instructions on how to convert queries into
    data items (we can think of this as one of the reasons why we have separate schemas
    for mutating data over querying data—we cannot mutate fields using the same logic
    as querying fields). From this, we can work out that there is a one-to-one mapping
    between fields and resolvers.
  prefs: []
  type: TYPE_NORMAL
- en: With `type-graphql`, we can create complex resolver relationships and operations
    with ease. We are going to start off by defining our class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `@Resolver` decorator tells us that this class behaves in the same way
    that a controller class would in a REST type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Strictly speaking, `ResolverInterface` is not necessary for our class, but we
    will be using it as a safety net when we add a field resolver to our `DaysCreated`
    field. This field is going to return the difference between today's date and the
    day the task was created. Since we are creating a field resolver, `ResolverInterface`
    checks that our field has the  `@Root` decorator of the object type as a parameter
    and that the return type is the correct type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `DaysCreated` field resolver is decorated with `@FieldResolver` and looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: While these methods look complicated, they are actually very simple. Our `DaysCreated`
    method receives the current `TodoItem` and works out the difference between today
    and the `CreationDate` value using `GetDateDifference`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `type-graphql` resolver can also define the queries and mutations that
    we want to perform. What would be useful for us to define is a means to retrieve
    all the todo items. We will create a method decorated with `@Query` to identify
    that this will be a query operation. Since our query has the potential to return
    multiple items, we tell the resolver that the return type is an array of `TodoItem` types.
    Just like we did the hard work of creating our `Prefill` class earlier on, our
    method is as simple as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'One of the operations that we want to allow our users to do is only query the
    records that are overdue. We can leverage largely similar logic to the last query,
    but we are going to filter on those uncompleted records that have gone past their
    due date:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Strictly speaking, for an operation that was shaping data like this, I would
    normally delegate the filtering logic to the data layer so that it only returned
    appropriate records. In this case, I decided to filter in the resolver so that
    we could see that the same source of data could be shaped in whatever way we needed.
    After all, we might have retrieved this data from a source that wouldn't let us
    shape it in a suitable way.
  prefs: []
  type: TYPE_NORMAL
- en: One thing I must emphasize is that we must import reflect-metadata before we
    attempt to execute any queries or mutations. This has to happen because of the
    reliance of reflection when working with the decorators. Without reflect-metadata,
    we will not be able to use the decorators since they use reflection internally.
  prefs: []
  type: TYPE_NORMAL
- en: It's all very well having the ability to query data, but resolvers should also
    be able to perform mutations on the data. To this end, we are going to add resolvers
    to add, update, and remove new todo items, as well as set the `Completed` flag
    when the user decides that the task is complete. We're going to start off with
    the `Add` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since this is a mutation, `type-graphql` provides the `@Mutation` decorator.
    Our method will accept a `TodoItemInput` parameter. This is passed in with a matching
    `@Arg` decorator. The reason that we need to supply this explicit `@Arg` is because
    GraphQL expects mutations to have parameters as arguments. By using `@Arg`, we
    provide them with the needed context. While supplying the mutation, we have an
    expectation that we will also be supplying a return type, so it is important to
    get the mapping between the mutation and the actual return type of the method
    correct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: One of the features of our mutation methods is that, as well as updating the
    `Prefill` items, we are also going to be updating the database, meaning that we
    have to convert the input in our method into our `ITodoSchema` type.
  prefs: []
  type: TYPE_NORMAL
- en: 'To help us, we are going to use the following simple method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We accept both `TodoItem` and `TodoItemInput` because we are going to use the
    same method to create a record that will be acceptable to our database layer.
    Since the source of that record could come from either finding a particular record
    from the `Prefill` items, or having been passed over from our UI, we need to make
    sure that we can handle both cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part of our `Add` method involves creating a `TodoItem` item that
    will be stored in our `Prefill` collection. Once we have added the item to the
    collection, we are going to add the record to the database. Our full `Add` method
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we know how to add a record, we can turn our attention to using a
    mutation to update the record. We already have most of the code infrastructure
    in place, so the update becomes a lot more straightforward to code. The `Update`
    method starts off by retrieving the entry that is already cached by searching
    for the item with the matching `Id` we have amended. If we find this record, we
    update it with the related `Title`, `Description`, and `DueDate` before we update
    the matching database record:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Removing a record is no more complicated than the `Update` method. In order
    to remove the record, we only need to supply the `Id` value so our method signature
    moves from having a complex type as an input to having a simple type—in this case,
    a string. We search through the cached entries to find the index of the record
    that matches the `Id` and, when found, we remove the cached entry by using the
    splice method. When we use splice on an array, we are really saying remove the
    entry that starts at the relevant index and remove the number of entries we choose.
    So, to remove `1` record, we supply `1` as the second parameter to this method.
    We need to make sure that our database is consistent, so we remove the database
    entry as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The final mutation that we are interested in is the one that sets the `Completed`
    flag to `true`. This method is largely a combination of the `Remove` and `Update`
    methods in that it follows the same logic to identify a record and update it.
    However, like the `Remove` method, it only needs the `Id` as the input argument.
    As we only intend to update the `Completed` field, that is the only field that
    we are going to touch on in this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: We could have chosen to reuse the `Update` method and set `Completed` to true
    from our client code, but that would have used a more complex call to achieve
    a much simpler end. By using a separate method, we are ensuring that we have code
    that does one thing and one thing only. This keeps us to the principle of single
    responsibility that we are interested in.
  prefs: []
  type: TYPE_NORMAL
- en: With our resolver and schemas in place, we can now turn our attention to adding
    the code to actually serve up our GraphQL server.
  prefs: []
  type: TYPE_NORMAL
- en: Using Apollo Server as our server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are going to create a new server implementation for this project, rather
    than reusing any of the server infrastructure from the previous chapter. Apollo
    provides its own server implementation (called Apollo Server), which we are going
    to use in place of Express. As usual, we are going to start off by bringing in
    the necessary types, and then we will create our class with the class definition.
    In the constructor, we are going to bring in a reference to our `Mongo` database
    class.
  prefs: []
  type: TYPE_NORMAL
- en: Apollo Server is part of the overall Apollo GraphQL strategy for providing out-of-the-box
    GraphQL support. The server can either stand on its own or work with server frameworks
    such as Express for serving up self-documenting GraphQL data. The reason we are
    going to use Apollo Server is because it has built-in support for working with
    GraphQL schemas. If we were to try and add this support ourselves, we would end
    up redoing what we get for free from Apollo Server.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we are going to import our types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we are going to write our `server` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Our server is going to expose a `Start` method that will be responsible for
    connecting to the database and starting our Apollo Server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: When we create our Apollo Server instance, we indicate that we want to use `GraphQLSchema`,
    but we don't define anything about that schema. We use the `buildSchema` function,
    which takes a series of options and uses them to bring in the schema that Apollo
    Server will use. `resolvers` takes an array of GraphQL resolvers, so we are going
    to supply `TodoItemResolver` as the resolver we want to use. The implication here,
    of course, is that we can use multiple resolvers.
  prefs: []
  type: TYPE_NORMAL
- en: The `validate` flag states whether or not we want to validate objects that are
    passed into resolver parameters. Since we are using simple objects and types,
    we are going to set this to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Something I like to do to validate the GQL I am creating is to emit the schema
    using `emitSchemaFile`. This uses the path operation to build up a fully qualified
    path name. In this case, we will be resolving to the `dist` folder, where we will
    output the `apolloschema.gql` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have finished coding the server side up, we can add `new MyApp().Start();`
    to start and run our application. When we build and run our server side, it will
    start an instance of our Apollo-enabled GraphQL server on `http://localhost:3000`.
    We do have one little surprise left and it''s to do with the last parameter that
    we supply to the Apollo Server options, namely `playground: true`. The playground
    is a visual editor area that lets us run `graphql` queries and see what results
    they bring.'
  prefs: []
  type: TYPE_NORMAL
- en: I would recommend switching the playground off in production code. For testing
    purposes, however, it is an invaluable aid for trying out queries.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to check that we have everything wired up correctly, try entering
    a GraphQL query into the query window. While entering the query, remember that
    just because there is a superficial resemblance to a JavaScript object, there
    is no need to use separate entries. Here''s a sample query to get started with.
    This query exercises the `TodoItems` query we created in `TodoItemResolver`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The GraphQL Angular client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Just like we did in the previous chapter, we are going to create an Angular
    client that uses Angular Material as its UI. Again, we are going to use the `ng
    new` command to create a new application, and we will set the prefix to `atp`.
    Since we want to add support for routing to our application, we are going to add
    an extra `--routing` parameter to our command line. We are doing this because
    it adds the necessary `AppRoutingModule` entries to `app.module.ts` and creates
    the `app-routing.module.ts` routing file for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous chapter, even though we used Material, we didn''t take advantage
    of routing with it. We are going to use Material one last time before we get back
    to using Bootstrap for the rest of this book, so we need to add support for Material
    to our application (don''t forget to accept adding support for browser animations
    when prompted):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'At this stage, our `app.module.ts` file should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to add the Material module imports to our `imports` array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: We add `MatNativeDateModule` alongside `MatDatepickerModule` because of the
    way that the Material date-picker was built. It does not provide any hard assumptions
    about the way that dates will be implemented, so we need to import an appropriate
    date representation. While we could write our own date handling module implementation,
    we are going to have real success by bringing in `MatNativeDateModule`. If we
    failed to do this, we would end up with a runtime error telling us `No provider
    found for DateAdapter`.
  prefs: []
  type: TYPE_NORMAL
- en: Adding client-side Apollo support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we get around to creating our user interface, we are going to set up
    the client side of our Apollo integration. While we could install all the individual
    parts of Apollo using `npm`, we are going to use the power of `ng` again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Going back to `AppModule`, we are going to set up Apollo to interact with the
    server. The `AppModule` constructor is the perfect place for us to inject Apollo
    to create the connection to our server. Our constructor starts off looking like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The way that we create the connection to the server is through the `apollo.create`
    command. This accepts a number of options, but we''re just going to concentrate
    on three of them. We need a link, which establishes the link to our server; a
    cache, if we want to cache the results of our interactions; and an override of
    the default Apollo options where we set up the watch query to always fetch from
    the network. If we don''t fetch from the network, we can encounter issues where
    cached data becomes stale until a refresh:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Don't forget that injecting components requires us to add the relevant modules
    to the `imports` section of the `@NgModule` module. In this case, we need to add
    `HttpLinkModule` and `ApolloModule` if we want to be able to automatically use
    these elsewhere.
  prefs: []
  type: TYPE_NORMAL
- en: That is all the code that we need to put in place to have our client side communicate
    with a working Apollo Server. Of course, in a production system, we would pick
    up the address of the server elsewhere and use that instead of the hardcoded localhost.
    But for our example, this is all we need. We can now get on with the task of adding
    the screens and the ability to navigate to them using routing.
  prefs: []
  type: TYPE_NORMAL
- en: Adding routing support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The requirements that we have set for our application are such that we will
    have three main screens. Our main screen will show all todo tasks, including whether
    they have been completed or not. The second will show overdue tasks, and the last
    will let our users add new tasks. Each of these will be created as separate components.
    For now, we are going to add dummy implementations of them, which will allow us
    to set up our routing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Our routing is configured and controlled from the `app-routing.module.ts` file. Here, we
    are going to define a set of rules that we expect Angular to follow.
  prefs: []
  type: TYPE_NORMAL
- en: Before we start adding routes, we should actually work out what the term routing
    means here. The simple way to think of routing is to think of the URL. The route
    corresponds to the URL, or rather, to the part of the URL other than the base
    address. Since our page will be running on `localhost:4000`, our full URL is `http://localhost:4000/`.
    Now, if we wanted our `AllTasks` component to map onto `http://localhost:4000/all`,
    we would consider the route to be `all`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we know what a route is, we need to map these three components to
    their own routes. We start off by defining an array of routes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'We associate our routes with our routing module by supplying them in the module
    definition, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'We want to map the `AllTasks` component to `all`, so we add this as an array
    element inside our routes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, when we start our Angular application, we can show the `all`
    tasks page if we type in `http://localhost:4000/all`. While this is reasonably
    impressive, it''s going to annoy users if we don''t have the concept of a default
    landing page for our site. Our users are generally going to expect that they can
    enter the site without having to know details about any of our page names, and
    they should be able to navigate from there because we will direct them to an appropriate
    page. Fortunately, we can accomplish this really easily. We are going to add another
    route that contains an empty path. When we encounter the empty path, we are going
    to redirect the user to the `all` page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Now, when the user navigates to `http://localhost:4000/`, they are redirected
    to see all of our outstanding tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have two more components that we want the user to be able to navigate to:
    our `AddTask` page and our `OverdueTasks` page. Again, we will add support to
    navigate to these pages through new routes. Once we add these routes in, we can
    close this file since we have added all the core routing support that we need:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The routing user interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The final part of adding routing support to our application is to set up the
    contents of `app-component.html`. In here, we are going to add a toolbar that
    will contain links to our pages and a place to show the page components themselves.
    The toolbar simply contains three navigation list items. The interesting part
    of each link is `routerLink`, which ties our link back to the addresses we previously
    added in. Effectively, what this part is doing is telling the code that, when
    we link in that route, we want the content to be rendered into the special `router-outlet`
    tag, which is just a placeholder for the actual component content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Now, when we run our application, clicking the different links will show the
    appropriate page, albeit with very little actual content in them.
  prefs: []
  type: TYPE_NORMAL
- en: Adding content to our page components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have our routing all sorted, we are ready to start adding some functionality
    to our pages. As well as adding content, we are going to start adding some polish
    to our application by making use of Angular validation to provide instant feedback
    to our users. The component that we are going to start with is the `AddTask` component.
    Without the ability to add tasks, we aren't going to be able to display any, so
    let's give ourselves the opportunity to start adding some todo tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before I start adding in user interface elements, I like to make sure that
    I have as much of the logic in place behind the component as possible. Once this
    is in place, actually adding the user interface becomes straightforward. In some
    cases, this will mean that I have decided on UI constraints before I have even
    considered how the particular piece of display should be shown, or what control
    to use to show it. With this in mind, we know that one of the things that makes
    up our todo item is `DueDate`. If we think about this for a moment, we realize
    that it makes no sense for us to create a task that has a due date that has already
    passed. To that end, we are going to set the earliest date that a task can end
    as being today''s date. This will be used as a constraint against whatever control
    we use to choose the date:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'We have three things that we are going to be capturing from the user in order
    to create our todo task. We need to capture the title, the description, and the
    date the task is due. This tells us that we are going to need three items to act
    as our model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'This is all we need on the model side of our add task component, but we are
    missing the ability to actually save anything over to our GraphQL server. Before
    we can start talking to our server, we need to bring support for Apollo into our
    component. This is as simple as adding a reference to it in our constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The operation we are going to perform must match with what our resolver is
    expecting. This means that types must match exactly and our GraphQL must be well-formed.
    Since the task we are going to perform is an add operation, we are going to call
    the method that we use to add the data, `Add`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The add operation is going to trigger the `Add` mutation on the resolver we
    created on the server. We know that this accepts a `TodoItemInput` instance, so
    we need to transform our client-side model into a `TodoItemInput` instance, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: There is a bit in the preceding snippet that is unfamiliar to us, namely the `Guid.create.toString()` call. This
    command is responsible for creating a unique identifier known as a **Globally
    Unique Identifier** (**GUID**). A GUID is a 128-bit number that is externally
    represented in string and number format, which generally looks something like
    this—**a14abe8b-3d9b-4b14-9a66-62ad595d4582**. Since GUIDs are mathematically
    based to guarantee uniqueness, rather than having to call out to a central repository
    to get a unique value, they are quick to generate. Through the use of a GUID,
    we have given our todo item a unique value. We could have done this at the server
    if we needed to, but I chose to generate the entirety of the message on the client.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to use a GUID, we will use the `guid-typescript` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now put the code in place to transfer the data over to the GraphQL server.
    As I mentioned previously, we are going to be using the `Add` mutation, which
    tells us that we are going to be calling `mutate` on our `apollo` client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The mutation is a specialist form of string that is covered by `gql`. If we
    can see what the entirety of this code looks like, we will be able to break it
    down immediately after:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: We already knew that we were going to call a mutation, so our `mutate` method
    accepts a mutation as `MutationOption`.
  prefs: []
  type: TYPE_NORMAL
- en: One of the parameters we can supply to `MutationOption` is `FetchPolicy`, which
    we could use to override the default options we set up when we created our Apollo
    link earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'The mutation uses `gql` to create the specially formatted query. Our query
    is broken down into two parts: the string text that tells us what the query is
    and any variables that we need to apply. The variables section creates an input
    variable that maps onto `TodoItemInput`, which we created previously. This is
    represented by `$` inside our `gql` string, so any variable name must have a matching
    `$variable` in the query. When the mutation has completed, we tell it that we
    want the title back. We don''t actually have to bring any values back, but when
    I was debugging earlier on, I found it useful to use the title to check whether
    we were getting a response from the server.'
  prefs: []
  type: TYPE_NORMAL
- en: We are using the [PRE62]
  prefs: []
  type: TYPE_NORMAL
- en: 'private Reset(): void {'
  prefs: []
  type: TYPE_NORMAL
- en: this.Title = ``;
  prefs: []
  type: TYPE_NORMAL
- en: this.Description = ``;
  prefs: []
  type: TYPE_NORMAL
- en: this.DueDate = null;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: .centerDiv{
  prefs: []
  type: TYPE_NORMAL
- en: 'height: 100vh;'
  prefs: []
  type: TYPE_NORMAL
- en: 'display: flex;'
  prefs: []
  type: TYPE_NORMAL
- en: 'justify-content: center;'
  prefs: []
  type: TYPE_NORMAL
- en: 'align-items: center;'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: .mat-card {
  prefs: []
  type: TYPE_NORMAL
- en: 'width: 400px;'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: .mat-form-field {
  prefs: []
  type: TYPE_NORMAL
- en: 'display: block;'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: textarea {
  prefs: []
  type: TYPE_NORMAL
- en: 'height: 100px;'
  prefs: []
  type: TYPE_NORMAL
- en: 'resize: vertical;'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: <div class="centerDiv" layout-fill layout="column" layout-align="center none">
  prefs: []
  type: TYPE_NORMAL
- en: '.... content here'
  prefs: []
  type: TYPE_NORMAL
- en: </div>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '<form name="form" (ngSubmit)="f.form.valid && Add()" #f="ngForm">'
  prefs: []
  type: TYPE_NORMAL
- en: '.... the form content goes here.'
  prefs: []
  type: TYPE_NORMAL
- en: </form>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: <div layout="row" layout-align="center none">
  prefs: []
  type: TYPE_NORMAL
- en: <mat-card>
  prefs: []
  type: TYPE_NORMAL
- en: <mat-card-title>
  prefs: []
  type: TYPE_NORMAL
- en: <span class="mat-headline">Add ToDo</span>
  prefs: []
  type: TYPE_NORMAL
- en: </mat-card-title>
  prefs: []
  type: TYPE_NORMAL
- en: <mat-card-content>
  prefs: []
  type: TYPE_NORMAL
- en: '.... content here.'
  prefs: []
  type: TYPE_NORMAL
- en: <mat-card-content>
  prefs: []
  type: TYPE_NORMAL
- en: <mat-card-actions>
  prefs: []
  type: TYPE_NORMAL
- en: <button mat-button class="btn btn-primary">Save</button>
  prefs: []
  type: TYPE_NORMAL
- en: </mat-card-actions>
  prefs: []
  type: TYPE_NORMAL
- en: </mat-card>
  prefs: []
  type: TYPE_NORMAL
- en: </div>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: <mat-form-field>
  prefs: []
  type: TYPE_NORMAL
- en: '<input type="text" matInput placeholder="Title" [(ngModel)]="Title" name="title"
    #title="ngModel" required />'
  prefs: []
  type: TYPE_NORMAL
- en: </mat-form-field>
  prefs: []
  type: TYPE_NORMAL
- en: <div *ngIf="title.invalid && (title.dirty || title.touched)" class="alert alert-danger">
  prefs: []
  type: TYPE_NORMAL
- en: <div *ngIf="title.errors.required">
  prefs: []
  type: TYPE_NORMAL
- en: You must add a title.
  prefs: []
  type: TYPE_NORMAL
- en: </div>
  prefs: []
  type: TYPE_NORMAL
- en: </div>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: <input matInput [min]="EarliestDate" [matDatepicker]="picker" name="datepicker"
    placeholder="Due date"
  prefs: []
  type: TYPE_NORMAL
- en: '#datepicker="ngModel" required [(ngModel)]="DueDate">'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '<mat-datepicker #picker></mat-datepicker>'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: <mat-datepicker-toggle matSuffix [for]="picker"></mat-datepicker-toggle>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: <mat-form-field>
  prefs: []
  type: TYPE_NORMAL
- en: <input matInput [min]="EarliestDate" [matDatepicker]="picker" name="datepicker"
    placeholder="Due date"
  prefs: []
  type: TYPE_NORMAL
- en: '#datepicker="ngModel" required [(ngModel)]="DueDate">'
  prefs: []
  type: TYPE_NORMAL
- en: <mat-datepicker-toggle matSuffix [for]="picker"></mat-datepicker-toggle>
  prefs: []
  type: TYPE_NORMAL
- en: '<mat-datepicker #picker></mat-datepicker>'
  prefs: []
  type: TYPE_NORMAL
- en: </mat-form-field>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: <div *ngIf="datepicker.invalid && (datepicker.dirty || datepicker.touched)"
    class="alert alert-danger">
  prefs: []
  type: TYPE_NORMAL
- en: <div *ngIf="datepicker.errors.required">
  prefs: []
  type: TYPE_NORMAL
- en: You must select a due date.
  prefs: []
  type: TYPE_NORMAL
- en: </div>
  prefs: []
  type: TYPE_NORMAL
- en: </div>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: ng g c components/Todo-Card
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'EarliestDate: Date;'
  prefs: []
  type: TYPE_NORMAL
- en: 'constructor(private apollo: Apollo) {'
  prefs: []
  type: TYPE_NORMAL
- en: this.EarliestDate = new Date();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '@Input() Todo: ITodoItem;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '@Output() deleted: EventEmitter<string> = new EventEmitter<string>();'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: <div fxLayout="row wrap" fxLayout.xs="column" fxLayoutWrap fxLayoutGap="20px
    grid" fxLayoutAlign="left">
  prefs: []
  type: TYPE_NORMAL
- en: <atp-todo-card
  prefs: []
  type: TYPE_NORMAL
- en: '*ngFor="let todo of todos"'
  prefs: []
  type: TYPE_NORMAL
- en: '[Todo]="todo"'
  prefs: []
  type: TYPE_NORMAL
- en: (deleted)="resubscribe($event)"></atp-todo-card>
  prefs: []
  type: TYPE_NORMAL
- en: </div>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'todos: ITodoItem[] = new Array<ITodoItem>();'
  prefs: []
  type: TYPE_NORMAL
- en: 'constructor(private apollo: Apollo) { }'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'protected Subscribe<T extends OverdueTodoItemQuery | TodoItemQuery>(gqlQuery:
    unknown): Observable<ApolloQueryResult<T>> {'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: return this.apollo.query<T>({
  prefs: []
  type: TYPE_NORMAL
- en: 'query: gqlQuery,'
  prefs: []
  type: TYPE_NORMAL
- en: 'fetch-policy: ''no-cache'''
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'resubscribe = (event: string) => {'
  prefs: []
  type: TYPE_NORMAL
- en: const index = this.todos.findIndex(x => x.Id === event);
  prefs: []
  type: TYPE_NORMAL
- en: this.todos.splice(index, 1);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: ngOnInit() {
  prefs: []
  type: TYPE_NORMAL
- en: this.Subscribe<OverdueTodoItemQuery>(gql`query ItemsQuery {
  prefs: []
  type: TYPE_NORMAL
- en: OverdueTodoItems {
  prefs: []
  type: TYPE_NORMAL
- en: Id,
  prefs: []
  type: TYPE_NORMAL
- en: Title,
  prefs: []
  type: TYPE_NORMAL
- en: Description,
  prefs: []
  type: TYPE_NORMAL
- en: DaysCreated,
  prefs: []
  type: TYPE_NORMAL
- en: DueDate,
  prefs: []
  type: TYPE_NORMAL
- en: Completed
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}`).subscribe(todo => {'
  prefs: []
  type: TYPE_NORMAL
- en: this.todos = new Array<ITodoItem>();
  prefs: []
  type: TYPE_NORMAL
- en: todo.data.OverdueTodoItems.forEach(x => {
  prefs: []
  type: TYPE_NORMAL
- en: this.todos.push(x);
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: <span>{{Todo.Title}}</span>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: <mat-form-field>
  prefs: []
  type: TYPE_NORMAL
- en: '<input type="text" name="Title" matInput placeholder="Title" [(ngModel)]="Todo.Title"
    #title="ngModel"'
  prefs: []
  type: TYPE_NORMAL
- en: required />
  prefs: []
  type: TYPE_NORMAL
- en: </mat-form-field>
  prefs: []
  type: TYPE_NORMAL
- en: <div *ngIf="title.invalid && (title.dirty || title.touched)" class="alert alert-danger">
  prefs: []
  type: TYPE_NORMAL
- en: <div *ngIf="title.errors.required">
  prefs: []
  type: TYPE_NORMAL
- en: You must add a title.
  prefs: []
  type: TYPE_NORMAL
- en: </div>
  prefs: []
  type: TYPE_NORMAL
- en: </div>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: <div *ngIf="!InEdit;else editTitle">
  prefs: []
  type: TYPE_NORMAL
- en: <span>{{Todo.Title}}</span>
  prefs: []
  type: TYPE_NORMAL
- en: </div>
  prefs: []
  type: TYPE_NORMAL
- en: '<ng-template #editTitle>'
  prefs: []
  type: TYPE_NORMAL
- en: <mat-form-field>
  prefs: []
  type: TYPE_NORMAL
- en: '<input type="text" name="Title" matInput placeholder="Title" [(ngModel)]="Todo.Title"
    #title="ngModel"'
  prefs: []
  type: TYPE_NORMAL
- en: required />
  prefs: []
  type: TYPE_NORMAL
- en: </mat-form-field>
  prefs: []
  type: TYPE_NORMAL
- en: <div *ngIf="title.invalid && (title.dirty || title.touched)" class="alert alert-danger">
  prefs: []
  type: TYPE_NORMAL
- en: <div *ngIf="title.errors.required">
  prefs: []
  type: TYPE_NORMAL
- en: You must add a title.
  prefs: []
  type: TYPE_NORMAL
- en: </div>
  prefs: []
  type: TYPE_NORMAL
- en: </div>
  prefs: []
  type: TYPE_NORMAL
- en: </ng-template>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '<p>Due: {{Todo.DueDate | date}}</p>'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Delete() {
  prefs: []
  type: TYPE_NORMAL
- en: this.apollo.mutate({
  prefs: []
  type: TYPE_NORMAL
- en: 'mutation: gql`'
  prefs: []
  type: TYPE_NORMAL
- en: 'mutation Remove($Id: String!) {'
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove(Id: $Id)'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '`, variables: {'
  prefs: []
  type: TYPE_NORMAL
- en: 'Id: this.Todo.Id'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}).subscribe();'
  prefs: []
  type: TYPE_NORMAL
- en: this.deleted.emit(this.Todo.Id);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: Complete() {
  prefs: []
  type: TYPE_NORMAL
- en: this.apollo.mutate({
  prefs: []
  type: TYPE_NORMAL
- en: 'mutation: gql`'
  prefs: []
  type: TYPE_NORMAL
- en: 'mutation Complete($input: String!) {'
  prefs: []
  type: TYPE_NORMAL
- en: 'Complete(Id: $input)'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '`, variables: {'
  prefs: []
  type: TYPE_NORMAL
- en: 'input: this.Todo.Id'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}).subscribe();'
  prefs: []
  type: TYPE_NORMAL
- en: this.Edit(false);
  prefs: []
  type: TYPE_NORMAL
- en: this.Todo.Completed = true;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: Save() {
  prefs: []
  type: TYPE_NORMAL
- en: 'const todo: ITodoItemInput = new TodoItemInput();'
  prefs: []
  type: TYPE_NORMAL
- en: todo.Completed = false;
  prefs: []
  type: TYPE_NORMAL
- en: todo.CreationDate = new Date();
  prefs: []
  type: TYPE_NORMAL
- en: todo.Title = this.Todo.Title;
  prefs: []
  type: TYPE_NORMAL
- en: todo.Description = this.Todo.Description;
  prefs: []
  type: TYPE_NORMAL
- en: todo.DueDate = this.Todo.DueDate;
  prefs: []
  type: TYPE_NORMAL
- en: todo.Id = this.Todo.Id;
  prefs: []
  type: TYPE_NORMAL
- en: this.apollo.mutate({
  prefs: []
  type: TYPE_NORMAL
- en: 'mutation: gql`'
  prefs: []
  type: TYPE_NORMAL
- en: 'mutation Update($input: TodoItemInput!) {'
  prefs: []
  type: TYPE_NORMAL
- en: 'Update(TodoItem: $input)'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '`, variables: {'
  prefs: []
  type: TYPE_NORMAL
- en: 'input: todo'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}).subscribe();'
  prefs: []
  type: TYPE_NORMAL
- en: this.Edit(false);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we have a fully functioning client- and server-based GraphQL
    system.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have investigated the benefits that GraphQL can bring to
    us by viewing it as an alternative to REST services for retrieving and updating
    data. We investigated setting up Apollo as a server-side GraphQL engine and added
    Apollo to an Angular client to interact with the server, as well as look at the
    specialist GQL query language. In order to leverage the full power of TypeScript,
    we brought in the `type-graphql` package to simplify the creation of GraphQL schemas
    and resolvers.
  prefs: []
  type: TYPE_NORMAL
- en: Building on our experiences from the previous chapter, we saw how we could begin
    to build a reusable MongoDB data access layer; while there is some way to go with
    this, we have made a good start with it, leaving room to remove application constraints
    such as needing to use an `Id` to find records.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter also introduced us to Angular routing to serve up different views,
    depending on the route the user chooses. We kept using Material so that we could
    see how we could apply this logic to the navigation content we covered in [Chapter
    4](23db6d37-1947-4f7b-9b25-3195c2df7274.xhtml), *The MEAN Stack – Building a Photo
    Gallery*. We also looked at how to prevent the user from making mistakes with
    their input by looking at what Angular provides in terms of validation, and how
    we can use it alongside inline templates to provide consistent feedback to the
    user about any problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we are going to look at another way of communicating with
    a server by using Socket.IO to maintain an open connection between the client
    and server. We will build an Angular chat application that will automatically
    forward conversations to all open connections to the application. As an added
    bonus, we will see how we can integrate Bootstrap into Angular in place of Material
    and still use features such as routing. We will also introduce a feature that
    most professional applications rely on: user authentication.'
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Does GraphQL intend to fully replace REST clients?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What purpose do mutations serve in GraphQL? What type of operations would we
    expect to see with them?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do we pass a parameter into a subcomponent in Angular?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between a schema and a resolver?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do we create a singleton?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The complete function does not remove a completed task from the overdue items
    page. Enhance the code to remove the item from the page after the user clicks
    complete.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to delve further into the mysteries of GraphQL, I would recommend Brian
    Kimokoti's excellent *Beginning GraphQL* ([https://www.packtpub.com/in/application-development/beginning-graphql](https://www.packtpub.com/in/application-development/beginning-graphql)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To see GraphQL in use in React, Sebastian Grebe has written *Hands-on Full-Stack
    Web Development with GraphQL and React* ([https://www.packtpub.com/in/web-development/hands-full-stack-web-development-graphql-and-react](https://www.packtpub.com/in/web-development/hands-full-stack-web-development-graphql-and-react)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
