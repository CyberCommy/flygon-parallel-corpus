- en: Microservices Architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Microservices application development is growing at a rapid pace in the software
    industry. It is widely used for developing performant applications that are resilient,
    scalable, distributed, and cloud-ready. Many organizations and software companies
    are transforming their applications into the microservices architecture style.
    Amazon, eBay, and Uber are good examples of companies that have transformed their
    applications into microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Microservices split the application horizontally and vertically into smaller
    components, where the components are independent of one another and communicate
    through an endpoint. With the recent development in the industry of containers,
    we can use containers to deploy/run microservices that can scale up or scale out
    independently without any dependency on other components of the application and
    are leveraged with the pay-as-you-go model.
  prefs: []
  type: TYPE_NORMAL
- en: Today, we can use **Azure Container Service **(**ACS**) or Service Fabric to
    deploy .NET Core applications in the cloud and provide a containerization model
    with the consortium of Docker, Kubernetes, and other third-party components.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will learn the fundamentals of microservices architecture
    and its challenges, and create a basic application following microservices principles
    and practices.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the topics we will learn in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Microservices architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Benefits and standard practices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stateless versus stateful microservices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decomposing databases and its challenges
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing microservices in .NET Core
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running .NET Core microservices on Docker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microservices architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Microservices architecture is an architectural style in which the application
    is loosely coupled; it is divided into components based on business capability
    or domain, and scales independently without affecting other services or components
    of the application. This contrasts with the monolithic architecture, where a full
    application is deployed on a server or a **Virtual Machine** (**VM**) and scaling
    out is not a cost-effective or easy solution. For each scale-out operation, a
    new VM instance has to be cloned and the application needs to be deployed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the architecture of a monolithic application, where
    most of the functionality is isolated within a single process and scaling out
    to multiple servers requires the full deployment of the application on the other
    server:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00092.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following is a representation of microservices architecture, which separates
    an application into smaller services and, based on the workload, scales independently:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00093.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In microservices architecture, the application is divided into loosely coupled
    services, each of which exposes an endpoint and is deployed on a separate server
    or, most likely, container. Each service communicates with the other services
    through some endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: Benefits of microservices architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are various benefits of microservices architecture, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Microservices are autonomous and expose a self-contained unit of functionality
    with loosely coupled dependencies on other services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It exposes features to a caller via a well-defined API contract
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It degrades gracefully if any service fails
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It scales up and scales out independently
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is best suited for containerized deployment, which is a cost-effective solution
    when compared to VMs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each component can be reused through an endpoint and modifying any service does
    not affect other services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Development is faster when compared to monolithic architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As each microservice provides a particular business capability, it is easily
    reusable and composable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As each service is independent, using old architecture or technology is not
    a concern.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is resilient and eliminates monolith failover scenarios
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Standard practice when developing microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As standard practice, microservices are designed and decomposed based on business
    capability or business domain. Business domain decomposition follows a **Domain-Driven
    Design** (**DDD**) pattern, where each service is developed to provide specific
    functionality of the business domain. This contrasts with a layered architecture
    approach, in which the application is divided into multiple layers, where each
    layer is dependent on another layer and has tight dependencies on it, and removing
    any layer breaks the whole application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram illustrates the difference between layered architecture
    and microservices architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00094.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Types of microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Microservices are divided into two categories, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Stateless microservices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stateful microservices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stateless microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A stateless service has either no state or the state can be retrieved from an
    external data store. As the state is stored separately, multiple instances can
    run at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: Stateful microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A stateful service maintains the state within its own context. Only a single
    instance is active at a time. However, the state is replicated to other inactive
    instances as well.
  prefs: []
  type: TYPE_NORMAL
- en: DDD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: DDD is a pattern that emphasizes the business domain of the application. When
    building the application following a DDD pattern, we divide the application based
    on business domains, where each domain has one or more bounded contexts and the
    bounded context represents the business requirement. In technical terms, each
    bounded context has its own code and persistence mechanism and is independent
    of the others. Consider a vendor-management system where a vendor registers with
    the website, logs into the website, updates their profile, and attaches quotations.
    Each type of action will be termed the bounded context and is independent of the
    others. A set of vendor-operations can be termed a vendor domain.
  prefs: []
  type: TYPE_NORMAL
- en: DDD splits the requirement into domain-specific chunks known as bounded contexts,
    where each bounded context has its own model, logic, and data. There are chances
    that a single service is used by many services because of the core functionality
    it provides. For example, a vendor registration service uses an identity service
    to create a new user and the same identity service may be used by some other service
    to log into the system.
  prefs: []
  type: TYPE_NORMAL
- en: Data manipulation with microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As a general practice, each service provides specific business functionality
    to the user and involves **Create**, **Read**, **Update**, and **Delete** (**CRUD**) operations.
    In enterprise applications, we have one or more databases that have a number of
    tables. Following the DDD pattern, we can design each service that focuses on
    the specific domain. However, there are conditions where we need to extract the
    data from some other databases or tables that are out of scope from the service''s
    domain. However, there are two options to address this challenge:'
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping microservices behind an API gateway
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decomposing data into a flat schema for read/query purposes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wrapping microservices behind an API gateway
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An enterprise application that is based on microservices architecture contains
    many services. An **Entity Resource Planning** (**ERP**) system contains many
    modules, such as **Human Resources** (**HR**), financial, purchase requisition,
    and others. Each module may have a number of services providing specific business
    features. For example, the HR module may contain the following three services:'
  prefs: []
  type: TYPE_NORMAL
- en: Personal record management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Appraisal management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recruitment management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The personal record management service exposes certain methods to create, update,
    or delete an employee's basic information. The appraisal-management service exposes
    certain methods to create appraisal requests for an employee, and the recruitment-management
    service performs new hiring decisions. Suppose we need to develop a web page that
    contains the basic employee information and the total number of appraisals done
    in the last five years. In this case, we will be calling two services, namely
    personal-record management and appraisal management, and two separate calls will
    be made by the caller to these services. Alternatively, we can wrap these two
    calls into a single call using an API gateway. The technique to address this scenario
    is known as **API composition** and is discussed in the *What is API composition?*
    section later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Denormalizing data into a flat schema for read/query purposes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is another technique where we want to consume a service to read data from
    heterogeneous sources. It could be from multiple tables or databases. To transform
    multiple service calls into a single call, we can design each service and use
    patterns such as publisher/subscriber or mediator that listen for any CRUD operation
    to be performed on any service, save the data into a flat schema, and develop
    a service that only reads the data from that table(s). The technique to address
    this scenario is known as  **Command Query Responsibility Segregation** (**CQRS**)
    and is discussed in the CQRS section later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Consistency across business scenarios
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we understand that each service is designed to serve a specific business
    functionality, let''s take an example of an order-management system where a customer
    comes to the website and places an order. Once the order is placed, it is reflected
    in the inventory. In this scenario, we can have two microservices: one that places
    an order and creates a database record into the order database and an inventory
    service that performs CRUD on the inventory-related tables:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00095.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The important practice to follow when implementing an end-to-end business scenario
    and bringing consistency across multiple microservices is to keep the data and
    model specific to their domain. Considering the preceding example, the order placement
    service should not access or perform CRUD operations other than order tables,
    and if it is necessary to access any data which is out of the domain of that service,
    it should call that service directly.
  prefs: []
  type: TYPE_NORMAL
- en: An **Atomicity, Consistency, Integrity, and Durability** (**ACID**) transaction
    is another challenge. We may have multiple services serving one complete transaction,
    where each transaction is behind and operated by a separate service. To accommodate
    ACID transactions with the microservices architecture style, we can implement
    **asynchronous event-driven communication**, which is discussed later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Communication with microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In microservices architecture, each microservice is hosted at some server, most
    likely a container, and exposes an endpoint. These endpoints can be used to communicate
    to that service. There are many protocols that we can use but REST-based HTTP
    endpoints are most widely used due to their accessibility support on many platforms.
    In ASP.NET Core, we can create microservices using the ASP.NET Core MVC framework
    and use them through a RESTful endpoint. There are microservices that use other
    microservices as well to complete a particular operation and this can easily be
    done using the `HttpClient` class in .NET Core. However, we should design in such
    a way that our service offers resiliency and handles transient faults.
  prefs: []
  type: TYPE_NORMAL
- en: Database architecture in microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With microservices architecture, each service provides a certain functionality
    and has minimal dependencies on other services. However, porting the relational
    database into the smaller sets is a challenge, where each set represents a particular
    domain and contains tables related to that domain. Segregating tables based on
    domain and making them individual databases needs proper consideration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider the vendor management system that provides **Business-to-Consumer**
    (**B2C**) and **B****usiness-to-Business** (**B2B**) processes and involves the
    following operations:'
  prefs: []
  type: TYPE_NORMAL
- en: Vendor registers with the website
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vendor adds products that can be purchased by other vendors or customers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vendor places orders to purchase products
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To implement the preceding scenario, we can decompose the database based on
    the following two patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: Tables per service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Database per service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tables per service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With this design, each service is designed to use specific tables in the database.
    In this scenario, the database is centralized and hosted at one place. Other microservices
    also connect to the same database but deal with their own domain-specific tables:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00096.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This helps us to use the central database but any modification in the schema
    may break or require an update for one or many microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Database per service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With this design, each service has its own database and the application is
    loosely coupled. Modifications in the database do not harm or break any other
    service and offer complete isolation. This design is good for deployment scenarios,
    as each service contains its own database deployed in its own container:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00097.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Challenges in segregating tables or databases per service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Segregating tables or databases as per business capability or business domain
    is recommended to limit dependencies and keep it intact with the domain model.
    But it also comes with some challenges. For example, we have two services: a vendor
    service and an order service. The vendor service is used to create a vendor record
    in its own vendor database, and the order service to place orders for a particular
    vendor. The challenge comes when we need to return the aggregated record of both
    the vendor and their orders to the user. To solve this problem, we can use either
    of the following two approaches:'
  prefs: []
  type: TYPE_NORMAL
- en: API composition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CQRS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is API composition?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: API composition is a technique in which multiple microservices are composed
    to expose one endpoint to the user and provides an aggregated view. In a single
    database, this is easily possible by making a SQL query join and getting the data
    from different tables.
  prefs: []
  type: TYPE_NORMAL
- en: Let's consider the vendor management system, where we have two services. One
    is used to register a new vendor and has a corresponding database to persist vendor
    demographics, address, and other information. The other service is the order service,
    which is used to store the transactional data of the vendor and contains order
    information such as order number, quantity, and so on. Suppose we have a requirement
    to display the list of vendors with all the orders that are completed. With this
    scenario, we can provide a method in the vendor registration service that first
    loads the vendor details from its own data store, then loads their orders by calling
    the order service, and finally returns the aggregated data.
  prefs: []
  type: TYPE_NORMAL
- en: CQRS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CQRS is a principle in which application commands such as create, update, and
    delete are segregated by read operations. It works on the event-based model and
    when any create, update, or delete action is taken on the API, the event handler
    is invoked and stores that information into its own corresponding data store.
    We can implement CQRS in the previous vendor registration example, which will
    facilitate querying the vendor and their orders from a single service. When any
    command (create, update, delete) operation is performed on the vendor or order
    service, it will invoke the handler that invokes the query service to save the
    updated data into its store.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can keep the data in a flat schema or used NoSQL database to hold all the
    information about the vendor and their orders and read them when required:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00098.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding diagram represents three services: vendor service, order service,
    and query service. When any create, update, or delete operation is performed on
    the vendor service, the event is raised and the corresponding handler is invoked
    that makes the HTTP POST, PUT, or DELETE request on the query service to save
    or update its data store. The same goes for the order service, which calls the
    query service and stores the information related to orders. Finally, the query
    service is used to read the cumulative data of independent services in a single
    call.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The benefits of this approach are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We can make optimize the query database by defining cluster and non-cluster
    indexes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can use some other database model, such as NoSQL, MongoDB, or Elasticsearch,
    to provide a faster retrieval and search experience to the user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each service has its own data store but, with this approach, we can aggregate
    the data in one place
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can use the query data for reporting purposes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CQRS can be implemented using the mediator pattern, which we will discuss later
    in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Developing microservices architecture with .NET Core
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have learned the fundamentals of microservices and the importance
    of DDD. In this section, we will develop a microservices architecture for a sample
    application that contains the following features:'
  prefs: []
  type: TYPE_NORMAL
- en: Identity service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vendor service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a sample app in .NET Core using microservices architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will create a sample app in .NET Core and define services
    that include the authorization server, a vendor service, and an order service.
    To start with, we can use either Visual Studio 2017 or Visual Studio Code and
    create projects using dotnet **Command-Line Interface** (**CLI**) tools. The advantage
    of choosing Visual Studio 2017 is that it provides an option while creating the
    project to enable Docker support, add the Docker-related files, and make Docker
    the startup project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00099.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Solution structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The structure of the solution will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00100.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding structure, we have root folders, namely `Core`, `Microservices`,
    and `WebFront`. The common and core components reside in `Core`, all the microservices
    reside in the `Microservices` folder, and `WebFront` contains the frontend projects,
    most likely the ASP.NET MVC Core project, mobile application, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Creating projects inside designated folders gives proper meaning to the solution
    and makes it easy to understand the overall picture of the solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table shows the projects created inside each folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Folder** | **Project name** | **Project type** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `Core` | `Infrastructure` | .NET Standard 2.0 | Contains repository classes,
    `UnitOfWork` and `BaseEntity` |'
  prefs: []
  type: TYPE_TB
- en: '| `Core` | `APIComponents` | .NET Standard 2.0 | Contains `BaseController`,
    `LoggingActionFilter` and `ResilientHttpClient`  |'
  prefs: []
  type: TYPE_TB
- en: '| `Microservices > AuthServer` | `Identity.AuthServer` | ASP.NET Core 2.0 web
    API | Authorization server using OpenIddict and ASP.NET Core Identity |'
  prefs: []
  type: TYPE_TB
- en: '| `Microservices >``Vendor` | `Vendor.API` | ASP.NET Core 2.0 web API | Contains
    vendor API controllers |'
  prefs: []
  type: TYPE_TB
- en: '| `Microservices >``Vendor` | `Vendor.Domain` | .NET Standard 2.0 | Contains
    domain models specific to the vendor domain |'
  prefs: []
  type: TYPE_TB
- en: '| `Microservices >``Vendor` | `Vendor.Infrastructure` | .NET Standard 2.0 |
    Contains vendor-specific repository and database context |'
  prefs: []
  type: TYPE_TB
- en: '| `WebFront` | `FraymsWebApp` | ASP.NET Core 2.0 web app | Contains frontend
    views, pages, and client-side framework |'
  prefs: []
  type: TYPE_TB
- en: Logical architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The logical architecture of the sample application represents two microservices,
    namely the identity service and vendor service. The identity service is used to
    perform user authentication and authorization, whereas the vendor service is used
    to perform vendor registration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00101.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We will be using the DDD approach to articulate the data model, where each service
    will have its own corresponding tables.
  prefs: []
  type: TYPE_NORMAL
- en: The vendor service is based on business domain and is divided into three layers,
    namely the API that exposes HTTP endpoints and is used by the client, the domain
    that contains domain entities, aggregates, and DDD patterns, and the infrastructure
    layer that contains all common classes that include repository, **Entity Framework**
    (**EF**), Core context, and other helper classes.
  prefs: []
  type: TYPE_NORMAL
- en: The domain layer is the actual layer that defines the business logic and the
    entities, usually **Plain Old CLR Object** (**POCO**), for a particular business
    scenario. It should not have any direct dependency on any database framework or
    **Object Relationship Mapping** (**ORM**) such as EF, Hibernate, and others. However,
    with EF Core, we have a provision to keep entities separate from other assemblies
    and define them as POCO entities, removing dependencies from EF Core libraries.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a request comes to an API, it uses the domain layer to execute a particular
    business scenario and pass the data it receives. The domain layer executes the
    business logic and uses the infrastructure layer to perform CRUD on the database.
    Finally, the response is sent back to the caller from an API:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00102.gif)'
  prefs: []
  type: TYPE_IMG
- en: Developing a Core infrastructure project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This project contains the core classes and components used by the application.
    It will contain some generic or base classes, façade, and other helper classes
    that are common throughout the application.
  prefs: []
  type: TYPE_NORMAL
- en: We will create the following classes and discuss how they are useful for other
    projects specific to microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the BaseEntity class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Any property being annotated with the `NotMapped` attribute does not create
    corresponding fields in the backend database.
  prefs: []
  type: TYPE_NORMAL
- en: The UnitOfWork pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will implement the `UnitOfWork` pattern to save the context changes in a
    single call to the backend database. Updating the database on each object state
    change is not good practice and reduces the application performance. Consider
    an example of a form that contains a table where each row is editable. Committing
    a change in a database on each row update reduces application performance. The
    better way is to keep each row state in memory and update the database once the
    form is posted. With the Unit of Work pattern, we can define an interface that
    contains the following four methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The interface contains transaction-related methods, namely `BeginTransaction`,
    `RollbackTransaction`, and `CommitTransaction`, where `SaveChangesAsync` is used
    to save the changes to the database. Each service has its own database context
    implementation and implements the `IUnitOfWork` interface to provide transaction
    handling and save changes to a backend database.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a repository interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will create a generic repository interface that will be implemented by each
    service''s repository class, as each service will be following a DDD approach
    and has its own repository to give meaningful information to the developer based
    on the business domain. In this interface, we can keep generic methods such as `All`
    and `Contains` and a property to return `UnitOfWork`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Logging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Logging is an essential part of any enterprise application. Through logging,
    we can trace or troubleshoot actual errors when the application is running. In
    any good product, we usually see that each error has an error code. Defining error
    codes and then using them while logging exceptions intuitively tells the developers
    or the support team to troubleshoot and reach the point where the actual error
    occurred and provide a solution. For all application-level errors, we can create
    a `LoggingEvents` class and specify the constant values that can be further used
    during development. Here is the `LoggingEvents` class that contains a few `GET`,
    `CREATE`, `UPDATE`, and other event codes. We can create this class under a `Façade`
    folder inside the `Infrastructure` project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Creating the APIComponents infrastructure project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '`BaseController` takes `ILogger` in a parametrized constructor that will be
    injected through the built-in **Dependency Injection** (**DI**) component of ASP.NET
    Core.'
  prefs: []
  type: TYPE_NORMAL
- en: The `LogException` method is used to log the exception and returns the `HttpResponseMessage`
    that will be returned by the derived controller to the user in case of any error.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In this project, we also have `ResilientHttpClient` that we learned in [Chapter
    7](part0173.html#54VHA0-84c100e6bea3438e8844d99ae7f5dfa9), *Securing and Implementing
    Resilience in .NET Core Applications*.
  prefs: []
  type: TYPE_NORMAL
- en: Developing an identity service for user authorization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In ASP.NET Core, we have a choice of authenticating applications from various
    authentication providers. In microservices architecture, services are deployed
    and hosted separately in different containers. We can use ASP.NET Core Identity
    and add it as middleware in the service itself, or we can use IdentityServer and
    develop a central authentication server to perform authentication and authorization
    centrally, access all the services that are registered with the **Central Authentication
    Server** (**CAS**), and access protected resources by passing tokens.
  prefs: []
  type: TYPE_NORMAL
- en: The identity service basically acts as a CAS that registers all the services
    in the enterprise. When the request comes to the service, it asks for the token
    that can be obtained from the authorization server. Once the token is obtained,
    it can be used to access the resource service.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are various libraries to build the authentication server, which are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**IdentityServer4**: IdentityServer4 is an OpenID Connect and OAuth 2.0 framework
    for ASP.NET Core'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**OpenIddict**: Easy to plug in solution to implement OpenID Connect server
    in ASP.NET Core project'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ASOS (AspNet.Security.OpenIdConnect.Server)**: ASOS is an advanced OpenID
    Connect server designed to offer a low-level protocol-first approach'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will be using OpenIddict in our identity service.
  prefs: []
  type: TYPE_NORMAL
- en: OpenIddict connect flows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OpenIddict offers various types of flows, including authorization code flow,
    password flow, client credentials flow, and others. However, we have used implicit
    flow in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In implicit flow, the tokens are retrieved through the authorization endpoint
    by passing a username and password. All communication is done with the authorization
    server in a single round trip. Once the authentication is done, the token is added
    in the redirect URI and can be later used by passing in the request header for
    subsequent requests. The following diagram depicts how implicit flow works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00103.gif)'
  prefs: []
  type: TYPE_IMG
- en: Implicit flow is widely used with **Single-Page Applications** (**SPAs**). The
    process starts when an SPA web application wants to access the protected web API
    from the resource server. As the web API is protected, it needs a token to authenticate
    the request and validate the caller. To obtain the token (commonly known as a
    bearer token), the SPA web app first proceeds to the authorization server and
    enters the username and password. After successful authentication, the authorization
    server returns the token and appends it to the redirect URI itself. The web application
    parses the **Uniform Resource Locator** (**URL**) and retrieves the token and
    further used to access the protected resources.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the identity service project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The identity service is an ASP.NET Core web API project. To use OpenIddict
    libraries, we have to add an `aspnet-contrib` reference to our Visual Studio package
    sources dialog. To add this source from Visual Studio, click on the NuGet Package
    Manager by right-clicking on the project and then hitting the settings button,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00104.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Then add the entry of `aspnet-contrib` with the source as [https://www.myget.org/F/aspnet-contrib/api/v3/index.json](https://www.myget.org/F/aspnet-contrib/api/v3/index.json):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00105.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Once this is added, we can now easily add OpenIddict packages from the NuGet
    Package Manager window.
  prefs: []
  type: TYPE_NORMAL
- en: Remember to check that the Include prerelease checkbox is selected.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the packages that we can add directly to our project file
    or from the NuGet Package Manager window in Visual Studio:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '**Add custom UserEntity and UserRole classes**'
  prefs: []
  type: TYPE_NORMAL
- en: ASP.NET Core Identity contains `IdentityUser` and `IdentityRole` classes and
    uses EF Core to create a backend database. However, if we want to customize the
    default tables, we can do so by inheriting from these base classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create a `Models` folder and customize `IdentityUser` by creating a
    custom `UserEntity` class and adding the following four fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We have added these fields so when a vendor registers, we will keep their first
    name, last name, and ID in this table. Next, we add another class, `UserRole`,
    which derives from `IdentityRole`, and add the parametrized constructor as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We will add the custom database context class that derives from `IdentityDbContext`
    and specify `UserEntity` and `UserRoleEntity` types as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We can run EF Core migrations to create ASP.NET Identity tables, and we can
    run migration using EF CLI tooling. Before running the migration, we add the following
    entries in the `ConfigureServices` method of our `Startup` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'You can run the EF migrations from the Visual Studio Package Manager Console
    window. To add migration, first run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '`Add-Migration` is the command of EF CLI toolset, where `Initial` is the name
    of the migration. Once we run this command, it will add the `Migrations` folder
    into our project and the `Initial` class containing `Up` and `Down` methods to
    apply or remove changes to the database. Next, we can run the `Update-Database`
    command that loads the `Initial` class and apply the changes to the backend database.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we add the configuration related to the OpenIddict implicit flow in our
    `Startup` class. Here is the modified `ConfigureServices` method that adds the
    OpenIddict implicit flow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding method, we first add the `UseOpenIddict` method in the `AddDbContext`
    options that will create the OpenIddict-related tables in the database. Then,
    we configure Identity to use the same **JSON Web Tokens (JWT****)** claims as
    OpenIddict by setting the `IdentityOptions` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we register the OpenIddict features and specify values by calling the
    `services.AddOpenIddict` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the `Configure` method that first enables** Cross-Origin Resource Sharing**
    (**CORS**), which allows requests from any header, origin, and method. Then, add
    authentication and call the `InitializeAsync` method to populate the OpenIddict
    tables with the application and resources (services) information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the `InitializeAsync` method shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding method, we have added the following three applications:'
  prefs: []
  type: TYPE_NORMAL
- en: '`bfrwebapp`: An ASP.NET Core web application. When the user hits the web application,
    it checks whether the user is authenticated based on whether the token is provided.
    If the user is not authenticated, it will redirect it to the authorization server.
    The user enters the credentials and, with successful authentication, it will redirect
    back to the `bfrwebapp`. The redirect URI specified within this scope is the URI
    of `bfrwebapp`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`vendor-api`: A vendor microservice with a unique client secret key.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The preceding configuration is the server-side configuration and we will see
    what configuration needs to be added on the client side.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '`AuthorizationController` exposes two methods, namely `authorize` and `logout`.
    The `authorize` method checks whether the user is authenticated and returns a
    challenge that shows the login page, where the user can enter their username and
    password. Once the correct credentials are entered and the user is validated from
    the identity tables, the authorization server creates a new authentication token
    and returns it to the client application based on the redirect URI specified for
    `bfrwebapp`. To see the working example, please refer to the code repository.'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the vendor service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The vendor service is a web API that exposes a method to perform vendor registration.
    This service implements the actual business domain of the vendor system where
    a vendor can register. As we learned in the previous section, we can decompose
    an application based on business capability or business domain. This service implements
    a DDD principle and decomposes based on business domain. It contains the following
    three projects:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Vendor.API`: An ASP.NET Core Web API project that exposes methods to register
    a vendor'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Vendor.Domain`: .NET Standard 2.0 class library that contains POCO models
    such as `VendorMaster` and `VendorDocument`, and an `IVendorRepository` interface
    to define methods essential for a vendor domain.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Vendor.Infrastructure`: .NET Standard 2.0 class library that contains a `VendorRepository`
    that implements the `IVendorRepository` interface and a `VendorDBContext` to perform
    database operations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a vendor domain
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create a new .NET Standard library project and name it `Vendor.Domain`. We will
    reference our `Infrastructure` project created previously to derive our POCO entities
    from the `BaseEntity` class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Creating the vendor infrastructure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This project is a .NET Standard 2.0 class library project that reference the
    core `Infrastructure` and `Vendor.Domain` projects. This contains the actual implementation
    of the `VendorRepository` and a database context to connect with the backend SQL
    Server database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the `VendorDBContext` class that derives from the `DbContext` class
    of EF Core and defines `DbSet` for the `VendorMaster` and `VendorDocument` entities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We will also implement the `IUnitOfWork` interface, so when the `VendorRepository`
    is injected in a controller, we can perform transaction handling and save the
    changes to the associated database in a single call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the `VendorRepository` that implements the `IVendorRepository` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Creating the vendor service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will now create a vendor-service project that will expose methods for use
    by client applications to register a vendor. To start with, let's create a new
    ASP.NET Core web API project and name it `Vendor.API`.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the mediator pattern in the vendor service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In microservices architecture, an application is split into multiple services,
    where each service connects to the other services through an endpoint. There are
    possibilities that one service may invoke or interact with multiple services when
    the event is invoked. Segregating the interaction between services is always a
    recommended approach and solves tight dependencies on other services. For example,
    an application invokes this service to register a vendor and then invoke the identity
    service to create its user account and send an email by calling the messaging
    service. We can implement the mediator pattern to solve this scenario.
  prefs: []
  type: TYPE_NORMAL
- en: The mediator pattern is based on the event-driven topology that works as a publisher/subscriber
    model. When any event is invoked, the registered handlers are called and execute
    the underlying logic. This encapsulates the logic of how services interact with
    one another, keeping the actual logic separate for each interaction. Moreover,
    the code is clean and easy to change.
  prefs: []
  type: TYPE_NORMAL
- en: In `Vendor.API`, we will implement the mediator pattern using the `MediatR`
    library of .NET. `MediatR` is the implementation of the mediator pattern that
    supports command handling and domain event publishing. In the following section,
    we will implement mediator when the user registers and invoke the identity service
    to create a new user and send an email.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use `MediatR`, we have to add the following two packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '`MediatR`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MediatR.Extensions.Microsoft.DependencyInjection`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After adding these packages, we can add it in the `ConfigureServices` method
    by calling the `services.AddMediatR` method. `MediatR` provides the following
    two types of messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Request/response**: Requests are commands that may or may not return a value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Notification**: Notifications are events that may not return a value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In our example, we will implement both request/response to save a vendor record
    into a database and, once it returns Boolean true as a response, we will invoke
    notification events to create a vendor user and send an email.
  prefs: []
  type: TYPE_NORMAL
- en: To implement request/response, we should define a class that implements the
    interface of `IRequestHandler`or `IRequestHandlet<TRequest, TResponse>`, where
    `TRequest` is the request object type and `TResponse` is the response object type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: It implements the `IRequest` class that returns a Boolean value as a response.
    We have also specified our `VendorViewModel` that will be injected by the `MediatR`
    library when we pass them while calling the `send` method in the `VendorController`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: When this handler is invoked, it will call the `Handle` method and pass the
    command and the cancellation token. From the command object, we can get the object
    we have passed while calling the `Send` method of the `IMediator` object in the
    `VendorController` class. This method calls the `Add` method of the `VendorRepository`
    and saves the information into the database. With the request/response approach,
    only one command handler is executed even if you have multiple handlers defined
    for the command. To call all the handlers, we can use notifications. We will extend
    the preceding example and add notification events and corresponding handlers that
    will be invoked once the command is executed successfully.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: We can add more notification handlers based on the requirements. For example,
    if we want to initiate a workflow notification once the vendor record is saved
    into the database, we can create a vendor workflow notification handler, and so
    on.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have a `Post` method that will be called by the client
    application to create a new vendor. It first calls the `Send` method, which invokes
    the `CreateVendorCommandHandler` and saves the record in the database, and, once
    the record is created and the response is true, it will invoke the `SendEmailHandler`
    to send an email.
  prefs: []
  type: TYPE_NORMAL
- en: You can access the complete sample application from the GitHub link provided
    with the book.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying microservices on Docker containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Microservices are best suited for containerization deployment. A container is
    a process that provides an isolated and controlled environment for an application
    to run without affecting the system or vice versa. Most of us have experienced
    hosting applications inside VMs, which provide an isolated space to install, configure,
    and run applications and use the dedicated resources without affecting the underlying
    system or application. In contrast to VMs, containers provide the same level of
    isolation but are more lightweight in terms of startup time and overhead. Unlike
    VMs, containers do not preallocate resources such as memory, disk, and CPU usage.
    We can run multiple containers on the same machine, where the containers are isolated
    from each other but share the memory, disk, and CPU usage. This enables any application
    running in a container to use the maximum resources available without having any
    preallocated or assigned.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram depicts how VMs run on the host OS:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00106.gif)'
  prefs: []
  type: TYPE_IMG
- en: We run applications on the host OS and VMs on a guest OS. The virtualization
    is done at the hardware level, where VMs can talk to the host hardware using drivers
    available in the hypervisor virtualization system, as provided by the host OS.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how containers run on the host OS:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00107.gif)'
  prefs: []
  type: TYPE_IMG
- en: With containers, the kernel is shared between multiple containers. The kernel
    is a core component of the operating system that is responsible for interacting
    with different processes and hardware, and manages resources such as CPU cycles
    and virtual management. The kernel is the component that creates isolation between
    different containers.
  prefs: []
  type: TYPE_NORMAL
- en: What is Docker?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker is a software company that provides containers. Docker containers are
    very popular in the software industry to run microservices. They are best suited
    to microservices application development and provide a set of command-line tools
    that provide a unified way of building and maintaining different container images.
    We can create custom images or use existing ones from a registry such as Docker
    Hub ([http://hub.docker.com](http://hub.docker.com)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few benefits of Docker:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Benefit** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Simplicity | Provides a powerful tool for application creation and orchestration
    |'
  prefs: []
  type: TYPE_TB
- en: '| Openness | Built with open source technology and easy to integrate into existing
    environments |'
  prefs: []
  type: TYPE_TB
- en: '| Independence | Creates separation of concerns between application and infrastructure
    |'
  prefs: []
  type: TYPE_TB
- en: Using Docker with .NET Core
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: .NET Core is modular and faster when compared to the .NET framework and helps
    in running applications side by side, where each application is running its own
    set of CLR libraries and runtime. This makes it perfect for running on Docker
    containers. The image of .NET Core is far smaller when compared to the image having
    .NET framework installed. .NET Core uses a Windows Nano server or Linux image,
    which is a lot smaller than the Windows service core image. As .NET Core runs
    cross-platform, we can also create Docker images of other platforms and run applications
    on them.
  prefs: []
  type: TYPE_NORMAL
- en: 'With Visual Studio 2017, we can choose Docker while creating a .NET Core or
    ASP.NET Core project, and it auto scaffolds the Docker files and sets up the basic
    configuration to run applications on Docker. The following screenshot shows the
    Docker options available in Visual Studio 2017 to provision Docker containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00108.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Alternatively, if the project is already created, we can add Docker support
    by right-clicking on the .NET Core project and clicking on the Add | Docker Support
    option.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we create or enable Docker support in our application, it creates the
    Docker files in our project and also adds another project, named `docker-compose`*,*
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00109.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'The `docker-compose` project contains set of YAML (`.yml`) files that contain
    the configuration related to the application hosted in the container and a reference
    to the path of the Dockerfile created for the project when Docker support was
    added. Here is the sample `docker-compose.yml` file that contains two services
    having details such as the image name, `dockerfile` path, and so on. This file
    is from the sample application we discussed previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the content of the `Dockerfile` residing inside the `Vendor.API`
    project we created in the sample application above:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The preceding `Dockerfile` starts referencing a base image `microsoft/aspnetcore:2.0-nanoserver-1709`
    that will be used to create a Docker container. The `COPY` command is the actual
    path where the project files reside. It will then use dotnet CLI commands such
    as `dotnet restore` to restore all the NuGet packages inside the container, `dotnet
    build` to build the application, and `dotnet publish` to build and publishes the
    compiled output into a publish folder inside the container.
  prefs: []
  type: TYPE_NORMAL
- en: Running Docker images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can run Docker images either from the command line or from Visual Studio
    directly. As we saw in the previous section, a new `docker-compose` project is
    created on adding Docker support into our project. Running the `docker-compose`
    project reads the `docker-compose` YAML file and hooks up containers for the services
    defined. Docker is a first-class citizen in Visual Studio. It not only supports
    running the Docker containers but fully-fledged debugging capabilities are also
    provided.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, from the command line, we can run Docker containers by going
    to the root path where the `docker-compose.yml` file resides and running the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the containers are up, each application has its own IP assigned at runtime.
    To inspect the actual IP of each service running on a separate container, we can
    run the `docker inspect` command to retrieve it. However, the `docker inspect`
    command requires the container ID as a parameter. To get the list of the containers
    running, we can first call the `docker ps` command as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command displays the list of containers as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00110.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, we can use the container ID and execute `docker inspect` command to
    get its IP address as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command displays the IP address as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00111.gif)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about the microservices architecture for developing
    highly performant and scalable applications for the cloud-based on microservices.
    We learned some of the fundamentals of microservices, their benefits, and patterns
    and practices used when designing the architecture. We discussed certain challenges
    in decomposing the enterprise applications into the microservices architecture
    style and learned patterns such as API composition and CQRS to address them. Later
    in the chapter, we developed a basic application in .NET Core and discussed the
    solution structure and components of microservices, and developed identity and
    vendor services.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss securing and implementing resilience in
    .NET Core applications.
  prefs: []
  type: TYPE_NORMAL
