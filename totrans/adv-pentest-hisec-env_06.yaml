- en: Chapter 6. Exploits and Client-Side Attacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Client-side attacks characteristically require user interaction. A careless
    visit to a website can result in devastation. Generally speaking, a client-side
    attack will be focused on the "client" machine used by individuals at home or
    in the office. In a properly secured environment these hosts will be protected
    using a combination of security mechanisms and practices such as white listing,
    network segmentation, host-based firewalls, file integrity monitors, system configuration
    hardening, and antivirus.
  prefs: []
  type: TYPE_NORMAL
- en: With proper training, users are well aware that clicking on unknown links, opening
    e-mail attachments, or even plugging in an untrusted device may have the potential
    to be harmful. Unfortunately, convenience often supersedes common sense and as
    such, users will continue to repeat old mistakes. After all, shouldn't all of
    these protection mechanisms installed by the administrators protect the user from
    everything?
  prefs: []
  type: TYPE_NORMAL
- en: In large environments, desktops, workstations, and even printers are typically
    considered non-critical. The focus is on expensive servers and systems that are
    essential to keeping the business running. A skilled attacker will be well aware
    of this mentality. If unable to effortlessly penetrate the network using web application
    vulnerabilities, the attacker may often move on to using a blend of social engineering
    and client-side attacks. If successful, these attacks will cut through a perimeter
    as quickly as a hot knife cuts through butter. Additionally, a fully compromised
    client machine can then be set up as a gateway into the otherwise secured network.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will investigate methods that assist us in testing the effectiveness
    of a corporation's security awareness training, and client-side protection mechanisms.
    The research performed during the information gathering stages of your testing
    will finally be used to the fullest extent. Furthermore, we look at some of the
    techniques and tools used by security researchers and crafty attackers to bypass
    even those system controls that at first glance seem theoretically sound.
  prefs: []
  type: TYPE_NORMAL
- en: Buffer overflows — A refresher
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Buffer overflows are the bread and butter of attackers in the wild. When this
    type of vulnerability is properly exploited, an attack may lead to complete system
    compromise in mere seconds. Ideally, many of these vulnerabilities may be prevented
    by the proper implementation of a security development lifecycle. If your client
    does not have such practices, you may be required to perform steps above and beyond
    standard penetration testing and prove that there are flaws in the (often internally
    developed) applications being deployed across the enterprise.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Not all buffer overflow vulnerabilities can be used to create remote exploits.
    Also of note is that not all buffer overflows are exploitable.
  prefs: []
  type: TYPE_NORMAL
- en: More often than not, programming errors that allow for buffer overflows are
    not intentional, or due to lazy developers. Frequently, buffer overflow vulnerabilities
    are missed during the application development stages because of either the complexity
    of the application, or the fact that the original codebase is decades old and
    yet is still being built upon. Considering the fact that software developers are
    regularly faced with unreasonable deadlines and demands from their management
    chain, we should not be surprised that sometimes security flaws can be overlooked
    or missed during the software development lifecycle. It is not shocking for a
    developer to receive requirements based on eleventh-hour decisions. Logically,
    this is counterproductive to ensuring the security of the application being developed.
    As with any other technology, security needs to be built into the entire process
    and not added as an afterthought. The priority of the developer becomes pumping
    out code modifications rather than focusing on both stability and security.
  prefs: []
  type: TYPE_NORMAL
- en: To address these types of errors, code compilers and operating systems will
    include mechanisms that are meant to prevent the exploitation of this type of
    code. In order to fully understand how to bypass these mechanisms you will need
    to have at minimum a basic understanding of what buffer overflows are and how
    you can verify that your clients are fully protected against this type of attack.
  prefs: []
  type: TYPE_NORMAL
- en: '"C"ing is believing — Create a vulnerable program'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To fully comprehend just how simple it can be to overlook these errors we will
    be producing our own vulnerable program. Open up a 32-bit BackTrack virtual system
    and take the opportunity to connect to the Internet and perform your updates.
    After updating you will more than likely need to download the debugger we will
    be using. As of now it is not included as part of BackTrack 5 R1.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be using the GNU Debugger. You can learn additional information about
    this tool at: [http://www.gnu.org/s/gdb/](http://www.gnu.org/s/gdb/).'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The following examples use the 32-bit version of BackTrack.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get the GNU debugger you will need to install it using the `apt-get` install
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Once you have installed `gdb`, disconnect the Internet connection to your BackTrack
    virtual machine again.
  prefs: []
  type: TYPE_NORMAL
- en: The first order of business is to compile a small program that will be used
    to demonstrate a buffer overflow in action. We take advantage of a well known
    flaw in the `scanf` function for this purpose. Open up a terminal session in BackTrack
    and create a file named `bovrflow.c` in nano.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Be sure to save your work before exiting to the terminal. In this program,
    we have intentionally used `scanf()` with the `%s` conversions because `scanf()`
    does not sanitize the input to ensure that it does not exceed the size of the
    assigned buffer. More information about this vulnerability can be located at:
    [https://buildsecurityin.us-cert.gov/bsi/articles/knowledge/coding/816-BSI.html](http://https://buildsecurityin.us-cert.gov/bsi/articles/knowledge/coding/816-BSI.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Due to safety restricting built into the **GCC** compiler we must use `-fno-stack-protector`
    to compile this code. At the command prompt issue the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the previous command we have invoked the `gcc` compiler, chosen the output
    filename to be `bovrflow`, disabled the stack protector functionality of the compiler,
    and targeted the `bovrflow.c` source code.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Because we are running as root in BackTrack we do not have to worry about changing
    the file permissions to executable before attempting to run it.
  prefs: []
  type: TYPE_NORMAL
- en: Turning ASLR on and off in BackTrack
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Linux uses Address Space Layout Randomization (ASLR) by default. You should
    understand how to check to see if this is enabled, as well as having the ability
    to turn it on and off. Let''s take a look at the `ldd` command. This command will
    list a program''s shared library dependencies. If you have ASLR enabled, the memory
    addresses will change each time they are invoked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'On close inspection, it becomes obvious that the memory addresses are changing
    each time. Now let''s turn off ASLR (off is 0, on is 2) by changing the `randomize_va_space`
    value and compare the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For Linux distributions other than BackTrack, Exec-Shield can be enabled and
    disabled in the same manner. Example: `echo 0 > /proc/sys/kernel/exec-shield`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The memory addresses are identical regardless of how many times you attempt
    to run the command. This indicates that you have turned off the randomization
    produced by ASLR.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the basics of buffer overflows
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Assuming that `boverflow.c` compiled properly and ASLR is turned off, we can
    now execute our intentionally vulnerable program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Your output should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: At this prompt type a sequence of 21 characters such as `AAAA` and press *Enter:*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: By entering only four characters the program executed the instructions and exited
    properly after displaying the characters you had typed. Now let's overflow the
    buffer to analyze the result. This time run the program but type more than 21
    characters.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: By entering more data than the buffer could handle we have generated a **segmentation
    fault**. This is exactly what we are looking for. Let's take a look at what is
    occurring in memory space when this program is running. At the prompt invoke the
    `gdb` debugger.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The debugger will provide us with detailed memory information about the `bovrflow`
    program. Let''s take a look at what happens when we run the program from within
    `gdb` without overflowing the buffer. We type *r* at the gdb prompt to **run**
    the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Nothing interesting to see here, but this test is a good sanity check to ensure
    everything is working properly. Now we need to take a look at what occurs when
    we cause the segmentation error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Once again we run the program; this time however we use a sequence of 22 characters
    and intentionally cause a segmentation fault. When reviewing the results, it becomes
    obvious that something is not quite right. Take notice of the reference to the
    `SIGSEGV`, segmentation fault. We will need to take advantage of this error and
    exploit the evident vulnerability. Unfortunately, there is a bit more that we
    need to understand before moving on to creating our shellcode. After all, so far
    all we know is that we can cause the application to crash. To progress we must
    look at our register addresses to further comprehend what occurred in memory space
    during the crash. Type *i r* at the prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We can see our input at `ebp` as `0x41414141`. Let's run the program again and
    add a few more A's and see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you do not understand what we are looking at when we see `0x41414141`, perform
    a quick search on `google.com` for "ASCII conversion chart", find one that you
    are comfortable with and print it out.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Press *r* to restart the program within the debugger.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Press *y* to let the debugger know you would like to completely restart.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This time we need to type 24 *A's* and press *Enter*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Our segmentation fault is returning something strange now… When we typed only
    12 characters earlier our output indicated `0xb7e8bb00 in __libc_start_main ()`
    from `/lib/tls/i686/cmov/libc.so.6`, but now we return `0xb7004141 in ?? ()` instead.
    We can even see some of our *A''s* coming through now. Take a look at our information
    registers again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Take a look at `eip`. We can see that with 24 characters the address is `0xb7004141`
    whereas with only 12 A's we were looking at `0xb7e8bb00`. This is significant.
    We need to try one more thing to make this truly apparent. Run the program from
    within the debugger once more. This time use a total of 26 A's and completely
    overwrite EIP.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Now EIP is completely overridden with A's. We have demonstrated how a user could
    manipulate the stack. In the next section, we review and exploit a small sample
    program.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are up for a challenge, perform additional research and try to gain a
    root shell or open nano by exploiting `bovrflow`.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point we have covered the basic concept of how the stack can be manipulated.
    Advanced attackers will understand and take advantage of these flaws whenever
    possible. Under many circumstances you will not have time to fully check every
    single application for vulnerabilities such as buffer overflows, but it is good
    to understand the basic premise of the attacks we will be using as we move further
    into the chapter. If you find that you might enjoy vulnerability research I highly
    recommend that you check out the following resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Excellent resources to learn more about buffer overflow vulnerabilities
    and more:** |   |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| *Smashing The Stack For Fun And Profit* by Aleph One | [http://insecure.org/stf/smashstack.html](http://insecure.org/stf/smashstack.html)
    |'
  prefs: []
  type: TYPE_TB
- en: '| *Buffer Overflow Tutorial* by Mudge | [http://insecure.org/stf/mudge_buffer_overflow_tutorial.html](http://insecure.org/stf/mudge_buffer_overflow_tutorial.html)
    |'
  prefs: []
  type: TYPE_TB
- en: '| The Corelan Team''s website. This team is amazing. Check out their tutorials
    and forums! | [http://www.corelan.be/](http://www.corelan.be/) |'
  prefs: []
  type: TYPE_TB
- en: '| IHASOMGSECURITYSKILLS Blog by "sickn3ss" Impressive write ups that are easy
    to follow along with. Check out the tutorials. | [http://sickness.tor.hu/](http://sickness.tor.hu/)
    |'
  prefs: []
  type: TYPE_TB
- en: Introduction to fuzzing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Any time that an application allows for input, be it directly from the user
    such as when entering credentials, opening a file, or even from changing the data
    in RAM, there is a chance that the input can be used to cause havoc. Attackers
    will not spend hours, or days typing away (well, some might!) at a username and
    password prompt or an unknown connection to an obscure port. Instead, they will
    take advantage of tools that are focused on exactly this task welcome to the world
    of fuzzers.
  prefs: []
  type: TYPE_NORMAL
- en: A fuzzer will typically be used to generate and output data; this data could
    be manipulated and formatted in various ways and there are published algorithms
    that assist in making the job even easier.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Keep in mind that **input** is a very broad term. When thinking about input
    vectors be sure to consider every method of input available to the application
    being tested. Something as seemingly trivial as streaming a song or even reading
    a filename could provide possible attack vectors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Whenever a situation arises where a program allows for an uncontrolled input,
    there is probably a fuzzer waiting to handle the task. Let''s create a small program
    and take a look at what a fuzzer might do to assist in finding a vulnerability
    or abnormality in an application. We will use a well known and often demonstrated
    vulnerability in the `strcpy()` function. Open up the BackTrack instance and create
    the following program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: As mentioned previously, we are creating a scenario in which the `stuff` char
    buffer can be overloaded. `int main(int argc, char** argv)` instructs the program
    to accept the input after the file is invoked and before *Enter* is pressed and
    assigns it to `argv` which we can then copy to the `stuff` variable. If `stuff`
    is unable to contain the amount of data or the type of data presented, a segmentation
    fault will occur.
  prefs: []
  type: TYPE_NORMAL
- en: Be sure to compile it using the `-fno-stack-protector` argument.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Give the program a try with and without attempting to cause the segmentation
    fault:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to give it a try with enough input to cause a crash:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'As expected, at 208 chars we generate an intentional segmentation fault. Now
    assume that you did not know this in advance and it could possible take hundreds
    or thousands of characters to crash this program. This is why we would want to
    use a fuzzer to automate the attack. Let''s make a **very** basic proof of concept
    using shell scripting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'In this simplistic representation of a fuzzer we ask for the amount of letter
    A''s that we want to test against the program. We then run a loop that will iterate
    through each of the items until the counter is back down to 1 again. If we run
    the program and choose 10 we receive the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Try to see what happens when you choose 208 A's. The program is not sophisticated
    and will not exit cleanly. Nor will you have any indicator as to what happened,
    or why any A's after 207 did not display.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Challenge yourself to modify this simple program, or to recreate it in a more
    appropriate scripting or programming language such as Python or Ruby.
  prefs: []
  type: TYPE_NORMAL
- en: The basic concept of fuzzing should be apparent after these exercises. There
    are books dedicated to just this subject, and as such we will only be able to
    scratch the surface of the true art form that fuzzing can be.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing vulnserver
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will be using vulnserver ([http://grey-corner.blogspot.com/2010/12/introducing-vulnserver.html](http://grey-corner.blogspot.com/2010/12/introducing-vulnserver.html))
    as our target during several of the following exercises. This intentionally vulnerable
    application was created by Stephen Bradshaw to provide himself and the security
    community with an application that can be used to practice various security-related
    tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Ideally, the program is to be run on a Windows-based machine; as we are trying
    to keep the book focused on open source and freely available programs we will
    run the server on our BackTrack machine. This will be sufficient to learn about
    more about the fuzzing tools available in BackTrack.
  prefs: []
  type: TYPE_NORMAL
- en: 'Download the vulnserver application to your BackTrack machine, unzip it, review
    the LICENSE and README files carefully, and after disconnecting the BackTrack
    instance from the Internet again, start `vulnserver.exe` up using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'This command will use `wine` to run your `vulnserver.exe` application on port
    4444\. To test that the server is working properly open up a terminal session
    and connect to the server using `netcat` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'You will be presented with an introduction screen from vulnserver:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'As mentioned by the prompt you may enter HELP to receive information about
    available inputs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'We will be using different fuzzers that come preinstalled on BackTrack 5 R1
    to inject malformed, random, or mutated data into these inputs. To get more familiar
    with the server feel free to poke around. Here is an example of a valid input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: The application expected an input which we provided as LTER AAAAAA. As there
    is not a problem with this input the application returns back to the normal state.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For detailed information about the vulnserver application, please visit Stephen
    Bradshaw's blog. While there you will also find that it contains several great
    tutorials relating to his vulnserver application and more that are well written
    and easy to follow.
  prefs: []
  type: TYPE_NORMAL
- en: Fuzzing tools included in BackTrack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Luckily, for us it is not necessary for the typical penetration tester to spend
    months and years preparing the perfect fuzzer. The community has already provided
    us with an abundance of these wonderful tools and compared to writing them, their
    usage is a breeze!
  prefs: []
  type: TYPE_NORMAL
- en: Bruteforce Exploit Detector (BED)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Bruteforce Exploit Detector (BED)** does exactly what the name implies.
    The program will allow you to send data to the target application in hopes that
    a crash will occur. Although this method does work in certain situations, at times
    more control is needed when trying to find vulnerable applications. BackTrack
    5 R1 has BED preinstalled at `/pentest/fuzzers/bed`. BED provides the ability
    to fuzz several, often used protocols without modification.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Besides the plugins provided by the developers of the Bruteforce Exploit Detector,
    you may also easily create your own plugins. Take a look at the `/pentest/fuzzers/bed/docs`
    directory `dummy.pm` file. This skeleton provides you with a skeleton that can
    be modified to suite our needs. Change directory to `/pentesting/fuzzers/bed/bedmod`
    and `cat` a couple of the files that you see such as `ftp.pm` to get a better
    idea of what a fully functional plugins looks like. When you are comfortable with
    the format, create a new file in the `bedmod` folder and name it `vserver.pm`.
    The following code has been created using the `dummy.pm` example template. Enter
    this code into `vserver.pm:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'At first glance this code may seem complicated. If you take a look at the highlighted
    code you will see the most important aspect of our particular plugin. We have
    instructed BED to send data to each of the inputs that were provided to us by
    the HELP command. The default port is set to 4444 and the login is blank because
    it is not required for this type of application. There is one more modification
    that needs to occur before we can use the `vserver.pm` plugin. Open up the `/pentest/fuzzers/bed/bed.pl`
    file for editing and add `vserver` to the `@plugins` variable on line #14:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Save the changes you have made to `bed.pl` and exit your editor. Assuming you
    have already started `vulnserver.exe` on port 4444, let''s give our new plugin
    a try:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '`Bed.pl` is definitely doing something, but we do not really get any feedback
    on precisely what is occurring. If you wait long enough you will receive notice
    of a crash.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Bruteforce Exploit Detector (BED)](img/7744OS_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Unfortunately, the vulnserver application is still receiving connections and
    thus `bed.pl` will continue the brute forcing process. Also, at this point we
    do not know what caused the crash. When we click on **Close** we are rewarded
    with some debugging information from the vulnserver console, but this behavior
    should not always be expected when working with client modified or created applications.
    Often debugging will be disabled on production applications to avoid giving potential
    attackers too much information.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We did not code in anything that would stop the program if certain statements
    (such as GOODBYE) did not appear after the `EXIT` command was initiated. Because
    of this the Bruteforce Exploit Detector did not detect that there was an issue!
    Challenge yourself to add this functionality to your plugin!
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at the terminal that is providing usage feedback from `stdout:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: It is of note that EIP has been overwritten with `41414141`. This is a good
    indicator that an exploit of this stack overflow is likely to be possible. Also
    notice that the server output indicates that connectivity requests are occurring.
    The server did not completely crash, only this connection. This can be used to
    your advantage if you need to create your own exploit later.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know there is an issue with the application we need to get an idea
    of what was sent to cause the crash. Usually your fuzzer would provide this information
    for you, but in this case `bed.pl` just keeps on chugging.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Wait until the Wireshark GUI has completely loaded and select the option that
    captures `lo` (this will allow you to witness the local traffic) from the middle
    of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '![Bruteforce Exploit Detector (BED)](img/7744OS_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Let's reproduce the error, but this time we will watch the packets in **Wireshark**
    as they traverse the local loopback interface. Restart the `vulnserver`, and then
    start `bed.pl` again using the `vserver` plugin. Once everything has started click
    over to Wireshark and take a look at the packets that are being passed. You can
    right-click on any of the messages in Wireshark and select **Follow TCP Stream**
    to see the messages in an easy to read format.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you wait until the crash occurs you can search the stream in Wireshark that
    looks to be the most obvious cause of the crash. Keep in mind that we do not have
    any delays in the code so the last connection made is not necessarily the connection
    that caused the error to occur. In this particular case it was noted in the `vulnserver`
    console that the last connection to be made before the crash was:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: If you go to Wireshark and enter `tcp.stream eq 41041` into the **Filter** menu
    you will be presented with only those packets that make up the messages we are
    interested in. Pick one of the filtered messages, right-click on it, and take
    a look at the TCP stream.
  prefs: []
  type: TYPE_NORMAL
- en: '![Bruteforce Exploit Detector (BED)](img/7744OS_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'It looks like the last message to be sent to vulnserver was:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Reviewing previous messages without using the filter we can determine that
    `KSTET` typically sends a response **(KSTET** `SUCCESSFUL)` upon successful acceptance
    of input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: We can test this input to see if we can manually replicate the error. Stop and
    restart the vulnserver and manually `netcat` to `127.0.0.1` port 4444.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: At this point the application will crash and the **Program Error** pop up will
    appear once more. Click on **Close** in the **Program Error** window. Once again
    we can review the output from the debugger and note that EIP (the current instruction
    being processed) has been overwritten by 41414141.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These are the type of repeatable errors we should be looking for when attempting
    to ensure the security posture of the environments being tested. Depending on
    the scope of the test, at this point the business may only require the details
    of the potential vulnerability. If the scope allows, an exploit for the application
    could be created to prove that the vulnerability could lead to loss of important
    data, assets, or revenue.
  prefs: []
  type: TYPE_NORMAL
- en: 'SFUZZ: Simple fuzzer'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Simple fuzzer known as SFUZZ created by Aaron Conole is a great tool if you
    want to start taking the fuzzing business seriously. SFUZZ is powerful and useful
    to someone who is not ready to expend the time needed to properly learn how to
    fully use SPIKE. Also, there are times when using a smaller, simpler tool is just
    more efficient.
  prefs: []
  type: TYPE_NORMAL
- en: If you are still learning about exploit development then SFUZZ makes a great
    stepping stone and will definitely continue to be a valuable addition to your
    penetration testing knowledge base throughout the years ahead; at times it is
    very convenient to have tools that are quick and easy to configure!
  prefs: []
  type: TYPE_NORMAL
- en: 'Browse to the `/pentest/fuzzers/sfuzz` directory and familiarize yourself with
    the directory structure. If sfuzz is invoked without arguments you will be presented
    with the available startup switches:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Although there are example scripts available we will need to create our own
    if we would like to be able to fuzz the vulnserver application. Create the following
    script named `basic.verserver` in the `sfuzz-sample` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'In this script we instruct sfuzz to use the `basic-fuzz-strings.list` when
    performing the fuzzing activity. We then add a delay of 200 milliseconds and restrict
    the sequence length to 2010\. This fuzzer is so simple that we then list the commands
    to be sent followed by the FUZZ variable which is replaced by the application
    with fuzzed output. We must save the file, ensure that the vulnserver is running
    on port 4444, and then proceed with starting the sfuzz script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: This will start the fuzzing process and will also let you see the data that
    is being passed. One technique that could be used is to perform a very fast scan
    to see if any crashes occur and then rerun the scan again using more refined parameters
    and at a slower pace. This will ensure that the exception is caught easily.
  prefs: []
  type: TYPE_NORMAL
- en: 'As expected, our fuzzer script was able to crash the vulnserver with the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Once again, the test did not catch the failure and sfuzz continued to send data
    to the application.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Remember the exploitable program "fuzzme" that we wrote earlier in the chapter?
    Challenge yourself to use sfuzz to fuzz the fuzzme program! HINT: Use `basic.cmd`
    as a guide on how to write your script.'
  prefs: []
  type: TYPE_NORMAL
- en: As previously stated, the art of fuzzing can be extremely useful, but the path
    to mastering it will take dedication and continual practice.
  prefs: []
  type: TYPE_NORMAL
- en: Fast-Track
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Penetration testing is often restricted to particular timeframes. This is a
    chief complaint of many penetration testers because after all, the attackers in
    the wild are not restricted by these business imposed timeframes at all. Thankfully,
    we can rely on tools such as Metasploit, SET, or Fast-Track to assist us in covering
    ground as quickly as possible. Fast-Track was developed by David Kennedy aka ReL1K,
    and Joey Furr aka j0fer, to automate many of the attacks that a penetration tester
    will need to perform frequently.
  prefs: []
  type: TYPE_NORMAL
- en: Menu driven and sleek in design, Fast-Track enables you to quickly perform tasks
    such as generating payloads, quickly set up client-side attacks, or even convert
    payloads from binary to hex.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Fast-Track can be used from the command line (-c) , a browser GUI (-g), or an
    interactive menu driven console (-i) by adding the appropriate argument when invoking
    the program. As with any penetration testing tool, please read the license files
    and warnings before using Fast-Track. Penetration testing tools should ONLY be
    used against systems that you have proper and legal authority to test.
  prefs: []
  type: TYPE_NORMAL
- en: We will be using only a portion of this great tool, but understanding all of
    its features is a valuable addition to anyone's penetration testing arsenal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fast-Track can be found in BackTrack 5 R1 at `/pentesting/exploits/fastrack`
    . To start the program in web GUI mode simply type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: This command has initiated the Fast-Track Web GUI written by David Kennedy.
    Open up Firefox and browse to `http://127.0.0.1:44444` as instructed.
  prefs: []
  type: TYPE_NORMAL
- en: The sidebar menu includes many of the options we will be discussing while using
    the menu driven user interface. Browse around the menu and familiarize yourself
    with the application.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Be sure not to launch any attacks unless you fully understand what you are doing
    and the BackTrack machine is segmented and not on the Internet or a production
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exit out of your browser and cancel out of the Fast-Track. At the command line
    type the following to open up the menu-driven Fast-Track interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Updating Fast-Track
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As with any other tool, we should update everything before we begin. Type *1*
    to select Fast-Track Updates and press *Enter:*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: Use the Update Fast-Track, Metasploit 3 Update and Exploit-DB Exploits in sequence
    from 1-3\. Once the updates are complete use *q* to exit back to the main menu.
  prefs: []
  type: TYPE_NORMAL
- en: Client-side attacks with Fast-Track
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Fast-Track includes an option to set up a web page that will exploit any known
    vulnerabilities that the client machine is susceptible to. All of the work is
    done for you except getting someone to visit your machine. If the scope of your
    testing includes phishing, you could craft a specific message in e-mail and have
    the user follow a link back to the page that Fast-Track will set up for you.
  prefs: []
  type: TYPE_NORMAL
- en: Select option **5\. Mass Client-Side Attack** from the menu and press *Enter*.
  prefs: []
  type: TYPE_NORMAL
- en: You will be required to type the IP address that you would like to listen on.
    The BackTrack machine I am using is listening on `VLAN1` at `192.168.1.205`. You
    will need to know what your IP address is and enter it here.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: When prompted to enter the payload that you would like to use, select **2\.
    Generic Bind Shell** and press *Enter*.
  prefs: []
  type: TYPE_NORMAL
- en: Type `no` to ARP poison the host. Unless you know what you are doing and fully
    understand ARP poisoning and all of its inherent risks, use of this option is
    not advised. If you are in a segmented lab environment is it incredible to witness
    how this function works though, so you should definitely look into it!
  prefs: []
  type: TYPE_NORMAL
- en: 'You will be presented with a new pop-up command prompt that resembles the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Client-side attacks with Fast-Track](img/7744OS_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now any system that connects to this server will encounter the following web
    page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Client-side attacks with Fast-Track](img/7744OS_06_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If the system that connects to this website is vulnerable to any of the exploits
    that Fast-Track attempts, you will be presented with a generic bind shell to that
    system.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will revisit this function during our post-exploitation chapter where we
    fully exploit a unit and follow up with the post-exploitation stages. At this
    point it is most important to understand the types of tools that are available
    not only to penetration testers, but to the public in general. If a business you
    are testing is susceptible to the exploits targeted by the Mass Client Attack
    Web Server, then it is extremely important that affected systems are updated and
    hardened ASAP.
  prefs: []
  type: TYPE_NORMAL
- en: The options in Fast-Track are well documented and the web features give great
    walkthroughs of this tool. Use your lab to try some of the exploits out, especially
    if you have Windows XP licenses laying around.
  prefs: []
  type: TYPE_NORMAL
- en: Social Engineering Toolkit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Social Engineering Toolkit (SET)** was created by David Kennedy [ReL1K]
    and the SET development team of JR DePre [pr1me], Joey Furr [j0fer], and Thomas
    Werth. With a wide variety of attacks available, this toolkit is an absolute "must
    have" for anyone who is serious about performing penetration testing. We will
    only provide a brief introduction to the Social Engineering Toolkit. SET is simple
    to use and the SET development team has created excellent documentation that is
    freely available at [http://www.social-engineer.org/framework/Computer_Based_Social_Engineering_Tools:_Social_Engineer_Toolkit_(SET)](http://www.social-engineer.org/framework/Computer_Based_Social_Engineering_Tools:_Social_Engineer_Toolkit_(SET)).
  prefs: []
  type: TYPE_NORMAL
- en: 'SET comes preinstalled on BackTrack and can be invoked at the command line
    using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before you may use the software you must read and accept the BSD license AND
    that you will not use this tool for any unlawful practice. This agreement covers
    any future usage as well, and you will not be prompted again after accepting by
    pressing *Y(es)* at the prompt.
  prefs: []
  type: TYPE_NORMAL
- en: '![Social Engineering Toolkit](img/7744OS_06_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'After updating the framework (remember to disconnect from the Internet again
    after performing your upgrades!) choose **1) Social-Engineering Attacks** to receive
    a listing of possible attacks that can be performed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: We will start with the Website Vectors. Enter *2* to move to the next menu.
    For this example, we will take a look at the first option on the list.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'The following menu provides three options. We will be using one of the provided
    templates for this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: At the next menu select option **1\. Java Required** as your template.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: When asked which payload you want to use, review the options carefully and select
    option 3 which is the reverse TCP VNC server.
  prefs: []
  type: TYPE_NORMAL
- en: '![Social Engineering Toolkit](img/7744OS_06_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We will select the Backdoored Executable for our payload. The development team
    has provided a rating for each encoder type. At times you may need to try different
    types before you find one that suits your testing needs. These encoders will assist
    you in bypassing an antivirus that is present on the host machine.
  prefs: []
  type: TYPE_NORMAL
- en: Antivirus is typically signature based, so if you are able to change the signature
    of the file enough, the antivirus protection will be unable to detect your payload.
  prefs: []
  type: TYPE_NORMAL
- en: '![Social Engineering Toolkit](img/7744OS_06_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Select the default listener port at 443 and press *Enter* to continue. That''s
    it! All you have to do now is wait for someone to connect to your web server.
    If you have an available Window machine and browse to the site you will see the
    following website:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Social Engineering Toolkit](img/7744OS_06_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We will revisit this exercise in the post exploitation chapter where we fully
    exploit the target system and take control of the network from within.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Client-side attacks are often the easiest method of getting into a secured environment.
    We understand that through the clever use of different attack vectors an attacker
    is able to take advantage of the inexperience or kindness of our users in order
    to gain access to client-side computers. Developers are often unable to check
    for every possible flaw in their programs in the timeframes they are allotted
    and as such many of these vulnerabilities remain undiscovered by the quality assurance
    teams and developers.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we have had a chance to not only learn about buffer overflow
    vulnerabilities, but actually create our own vulnerable application. We then took
    advantage of this vulnerability using manual techniques as well as automated fuzzing
    tools such as sfuzz and bed. We learned how to create our own modules and also
    how to modify existing modules to fit our specific needs.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, we discussed Fast-Track and the Social Engineering Toolkit and
    walked through setting up a mass web attack in Fast-Track and a Java applet attack
    in SET. Using the knowledge gained during these walkthroughs you should be able
    to review and test the other options in your home lab to the point that you become
    comfortable using these tools in a production testing environment. When reviewing
    SET we also touched upon antivirus avoidance and repackaging our payloads. In
    future chapters we will revisit these tools to completely exploit and take control
    of a controlled networking environment.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we learn the steps necessary to locate and gather information
    from compromised hosts. This stage includes learning about the most commonly used
    commands needed to perform post exploitation as well as steps on escalating privilege
    and adding persistent access to the compromised machines and more.
  prefs: []
  type: TYPE_NORMAL
