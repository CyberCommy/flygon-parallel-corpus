- en: Chapter 9. Creating an Intro
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The goal of this project is to create an intro, a non-interactive animation
    that uses text and visual effects to present something such as a product, a concept,
    or whatever. This project gives us the opportunity to explore some advanced animation
    and 3D topics and to extend our knowledge of Compass while creating some ad hoc
    functions to handle this complexity.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The new flexbox model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating keyframe animations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Concatenate animations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Animation of CSS 3D properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Project description
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We want to place some elements in a 3D scene and then move through them. To
    do so, we first have to create an HTML structure to hold each of these elements,
    and then we have to find a clever way to obtain the desired effect. But, before
    doing anything else, we have to define the folder structure and initiate the essential
    files of the project.
  prefs: []
  type: TYPE_NORMAL
- en: 'As in the previous project, we''ll use SASS and Compass, so we need to install
    Ruby ([http://www.ruby-lang.org/en/downloads/](http://www.ruby-lang.org/en/downloads/))
    and then enter `gem install compass` (or `sudo gem install compass`) in the terminal
    window. After that, we need a `config.rb` file in the root folder of the project
    containing the Compass configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Well done! The next step is to create the folders required by the project, that
    is, `css`, `scss`, `img`, and `js` and to define an empty `scss/application.scss`
    file. We then need to launch `compass watch .` from the project's root folder
    and finally create the main HTML document, `index.html`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an HTML structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What we''re going to create is basically a slideshow where each slide is placed
    in a 3D space and the animation moves from one slide to the other. A basic slide
    structure can be as simple as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We need two nested `div` tags to define this structure; the first one will cover
    100 percent of the window area, and the second `div` tag will have the necessary
    properties to hold its content in the center of the screen. Plus, we need to set
    up each slide so that they will be piled up one above the other because we need
    them all in the center before we start to move them in the 3D space.
  prefs: []
  type: TYPE_NORMAL
- en: We can use the `flexbox` CSS property to achieve this result. In fact, flexbox
    has properties to define both vertical and horizontal alignment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s define a basic HTML structure based on what we have seen so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s what the slides would look like without any CSS:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating an HTML structure](img/3264OT_09_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Creating the slide
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First of all, let''s set each slide''s `position` property to `absolute` and
    `width` and `height` to `100%` by writing a few lines of codes in `scss/application.scss`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Flexbox is pretty handy, thanks to the `box-pack` and `box-align` properties
    that basically set the alignment both on the main flexbox direction (horizontal
    by default, but can be changed with the `box-orient` attribute) and on its perpendicular.
  prefs: []
  type: TYPE_NORMAL
- en: Due to the fact that this project currently works only on Chrome and Firefox
    (IE10 seems to have some problems using nested 3D transformations), we're ok with
    these properties; otherwise, we should keep in mind that the old Flexbox syntax
    (the one from 2009 that we're using) is not supported by Internet Explorer 10.
  prefs: []
  type: TYPE_NORMAL
- en: The latest browser from Microsoft includes support only for the newest Flexbox
    implementation, which has a rather different syntax and unfortunately doesn't
    work yet on Gecko-based browsers.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 4](ch04.html "Chapter 4. Zooming User Interface"), *Zooming User
    Interface*, we developed a project that also worked pretty well in IE10 although
    we used the unsupported Flexbox syntax. This was because, in that case, we included
    Flexie, a polyfill that simulates the Flexbox behavior when the old Flexbox syntax
    is not supported.
  prefs: []
  type: TYPE_NORMAL
- en: Let's dive a bit into the details of this new Flexbox syntax and, for the sake
    of completeness, let's add both syntaxes to this project.
  prefs: []
  type: TYPE_NORMAL
- en: The new Flexible Box Model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The new flexible layout model (from here onwards, and throughout this chapter,
    known as Flexbox) is designed, as its previous version, to give the developers
    a new way of aligning elements on a page.
  prefs: []
  type: TYPE_NORMAL
- en: Elements using this new box model can be laid down vertically or horizontally
    and can have their order swapped dynamically, plus they can "flex" their sizes
    and positions to respond to the available spaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example (to test on Internet Explorer 10):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'And here''s the resulting page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The new Flexible Box Model](img/3264OT_09_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'With the previous properties we defined a Flexbox with `display: -ms-flexbox`
    (the W3C value is `flex`, but every browser alters this value a bit, either by
    adding a custom prefix or by changing it slightly). We used `-ms-flex-direction:
    row-reverse` to reverse the visualization order; this property is also used to
    specify whether we want a horizontal or vertical disposition. The available values
    are: `row`, `column`, `row-reverse`, and `column-reverse`. The `-ms-flex-pack`
    and `-ms-flex-align` properties determine the alignment of the Flexbox child elements
    for both their main and perpendicular axes (as specified with `-ms-flex-direction`).'
  prefs: []
  type: TYPE_NORMAL
- en: These properties are still part of the Flexbox IE10 implementation but have
    recently been replaced by `align-items` and `justify-content`, so we'll also have
    to take care of this when putting things together.
  prefs: []
  type: TYPE_NORMAL
- en: 'We used `-ms-flex-wrap: wrap` to ask the browser to dispose the elements on
    multiple lines if the space on the main axis is not enough to hold them all.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we used `-ms-flex: 1 0 200px` on each element to indicate that each
    child has a positive flex factor of `1`, so they will cover empty spaces all at
    the same speed, keeping their size equal among them, a negative flex factor of
    `0`, and a preferred size of `200px`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This, with the `-ms-flex-wrap` property that we specified before, creates an
    interesting responsive effect, where the elements move to new lines if the browser''s
    window is too small to hold them in a single line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The new Flexible Box Model](img/3264OT_09_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Creating a sample layout
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can benefit from this property to create a three-column layout, where the
    two lateral columns move under and over the central column if there isn''t enough
    space, such as in a mobile device. Here''s the code to create such a layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'And here''s the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a sample layout](img/3264OT_09_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If we now resize the browser window, we''ll notice how the `nav` and `aside`
    element moves over and under the main content, creating a nice layout for mobile
    devices:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a sample layout](img/3264OT_09_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s step back to our project; we can easily add support for this new version
    of Flexbox with a few lines of CSS, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'And here''s the much-awaited result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a sample layout](img/3264OT_09_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Disposing the slides
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can now use some 3D `transform` properties to move and rotate each of these
    slides in a 3D scene. These transformations are absolutely arbitrary and can be
    chosen to suit the movie trailer''s overall effect; here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to set some 3D standard properties such as `transform-style` and
    `perspective` on the slide''s parent elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If we now run the project in Chrome, we will notice that the slides are not
    piled up like in the Previous screenshot; rather, they are now placed all around
    the 3D scene (most of them are not visible after the transformations):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Disposing the slides](img/3264OT_09_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Moving the camera
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we'll learn to create the effect of a camera that moves through the slides;
    due to the fact that we cannot move the user's viewport, we'll need to simulate
    this feeling by moving the elements on the scene; this can be achieved by applying
    some transformations to `#container`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To move the camera close to a slide, we need to apply the exact transformations
    we used on that slide, but with opposite values and in the reverse order. So,
    for example, if we want to view the frame whose `data-sequence` property is `3`,
    we can write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Moving the camera](img/3264OT_09_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The animation has to focus on a slide, stay still for some time, and then move
    to the next slide. When creating this kind of effect, we usually face the following
    two main problems:'
  prefs: []
  type: TYPE_NORMAL
- en: CSS `keyframes` accepts only percentage values, but we'd rather prefer to use
    seconds as a measurement unit (for example, to say "move to the next slide in
    2 seconds and then stay still for 1 second")
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need to handle two `keyframes` rules for each slide (moving and still); it
    would be better to have a function that handles this for us
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can easily solve both these problems by using SASS. First, we can create
    a function that converts seconds to a percentage value by accepting the total
    length of the animation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This function takes two arguments—the value we want to convert from seconds
    to percentage and the total length of the animation. If this argument is not provided,
    the value is then set equal to the `$total_animation_duration` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second function that we can create for this project takes the `move` time
    and `still` time as arguments and prints the necessary keyframes as well as keeping
    track of the percentage of advancement of the animation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: What this function does is to basically transform the `$move` parameter in percentage
    and add this value to the `$current_percentage` global variable that keeps track
    of the advancements in the animation.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then print a keyframe, using the percentage that we just computed, containing
    the value of the `@content` variable that SASS fills for us with the contents
    we put between the curly brackets after a function call, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: If `$still` is equal to `end`, we want the still phase to last until the end
    of the animation, so we set the `$current_percentage` variable to `100%`; otherwise,
    we treat this variable the same as we treated the `$move` variable and then print
    another keyframe.
  prefs: []
  type: TYPE_NORMAL
- en: Fun with animations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To handle all the experimental prefixes that come with CSS3 animation properties,
    we can again use the Compass animation plugin (`gem install animation` from the
    command-line terminal, and then relaunch Compass using `compass watch . -r animation`
    from the project's root folder).
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to include `animation` in `application.scss`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'And we also need to write a small function that wraps the function provided
    by the animation plugin and reset `$current_percentage` each time it switches
    from one experimental prefix to the other:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Good! We''re now ready to put things together and define our animation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we have to add the appropriate animation property to `#container`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Done! A last reload in the browser is enough to fully appreciate the animation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Fun with animations](img/3264OT_09_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Step animations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll now create a special animation that switches the background color of our
    project synchronously with each slide change. Since we don't want any fading between
    colors, we'll introduce step animation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step animations let us specify how many frames must be placed between each
    declared keyframe; here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'If we now run this small example in a browser, we''ll see that the movement
    of the `div` element is not fluid, but composed of only five frames. We can add
    a special keyword `start` or `end` to the step declaration (for example, `step(5,
    end)` ) to ask the browser to skip the initial or the final keyframe during each
    step. Good! Now, we can apply the same concept to our intro project. First of
    all, we need to define an animation that changes the `background-color` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Please note how we used the `sec_to_per` function in order to use seconds instead
    of percentages; next, we just need to add `bg` to `#viewport` using the `animation`
    property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'And here''s the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step animations](img/3264OT_09_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Final touches
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have a basic structure defined and have learned how to create a
    fluid animation that moves through the slides placed in a 3D scene, the next step,
    obviously, is to enrich each of these slides with images, videos, graphs, and
    everything we might need to fulfill our purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, we can use the knowledge already accumulated during the previous
    chapters of this book; for example, we can easily define a fade-in animation for
    the first slide, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also add custom fonts to our slides:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Final touches](img/3264OT_09_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CSS animations and 3D transformations can be combined to create interesting
    results; of course, when we move to these types of features, we have to accept
    the fact that some browsers may not be able to support the project. However, we
    can always use some feature detection library, such as Modernizr, to address this
    issue by providing some alternative visualization when these features are not
    supported.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll create a nice graph library entirely with CSS3!
  prefs: []
  type: TYPE_NORMAL
