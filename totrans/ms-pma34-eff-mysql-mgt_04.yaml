- en: Chapter 4. Creating and Browsing Tables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having seen the overall layout of phpMyAdmin, we are ready to create a database,
    create our first table, insert some data into it, and browse it. These first steps
    are intentionally simple, but they will give you the foundation on which more
    complex operations will be achieved later. At the end of the chapter, we will
    have at our disposal the two basic tables on which the remaining exercises are
    based.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before creating a table, we must ensure that we have a database for which the
    MySQL server''s administrator has given us the `CREATE` privilege. The following
    possibilities exist:'
  prefs: []
  type: TYPE_NORMAL
- en: The administrator has already created a database for us, and we see its name
    in the navigation panel; we don't have the right to create an additional database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have the right to create databases from phpMyAdmin.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are on a shared host, and the host provider has installed a general web interface
    (for example, cPanel) to create MySQL databases and accounts; in this case, we
    should visit this web interface now and ensure we have created at least one database
    and one MySQL account.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Databases** panel in `Server` view is the place to go to find the database
    creation dialog. Note that a configuration parameter, `$cfg['ShowCreateDb']`,
    controls the display of the **Create new database** dialog. By default, it is
    set to `true`, which shows the dialog.
  prefs: []
  type: TYPE_NORMAL
- en: No privileges
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you do not have the privilege to create a database, the panel displays a
    **No privileges** message under the **Create new database** label. This means
    that you must work with the databases already created for you, or ask the MySQL
    server's administrator to give you the necessary `CREATE` privilege.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are the MySQL server's administrator, refer to [Chapter 19](ch19.html
    "Chapter 19. Administrating the MySQL Server").
  prefs: []
  type: TYPE_NORMAL
- en: First database creation is authorized
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If phpMyAdmin detects that we have the right to create a database, the dialog
    appears as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![First database creation is authorized](img/7782_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the input field, a suggested database name appears if the `$cfg['SuggestDBName']`
    parameter is set to `TRUE`, which is the default setting. The suggested database
    name is built according to the privileges we possess.
  prefs: []
  type: TYPE_NORMAL
- en: If we are restricted to the use of a prefix, the prefix might be suggested in
    the input field. (A popular choice for this prefix is the username, which might
    or might not be followed by an underscore character.) Note that, in this case,
    the prefix is followed by an ellipsis mark, added by phpMyAdmin. We should remove
    this ellipsis mark and complete the input field with an appropriate name.
  prefs: []
  type: TYPE_NORMAL
- en: '![First database creation is authorized](img/7782_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The **Collation** choice can be left unchanged for now. With this dialog, we
    could pick a default character set and collation for this database. This setting
    can be changed later (refer to [Chapter 9](ch09.html "Chapter 9. Performing Table
    and Database Operations") for more information on this).
  prefs: []
  type: TYPE_NORMAL
- en: 'We will assume here that we have the right to create a database named **marc_book**.
    We enter **marc_book** in the input field and click on **Create**. Once the database
    has been created, we will see the following screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![First database creation is authorized](img/7782_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Notice the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The title of the main panel has changed to reflect the fact that we are now
    located in this database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A confirmation message regarding the creation is displayed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The navigation panel has been updated; we see **marc_book**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By default, the SQL query sent to the server by phpMyAdmin to create the database
    is displayed in color
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: phpMyAdmin displays the query it generated, because `$cfg['ShowSQL']` is set
    to `TRUE`. Looking at the generated queries can be a good way of learning SQL.
  prefs: []
  type: TYPE_NORMAL
- en: As the generated queries could be large and take much of the on-screen room,
    the `$cfg['MaxCharactersInDisplayedSQL']` acts as a limit. Its default value of
    `1000` should be a good balance between seeing too few and seeing too many of
    the queries, especially when doing large imports.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to examine the phpMyAdmin feedback to ascertain the validity
    of the operations we make through the interface. This way, we can detect errors
    like typos in the names, or creation of a table in the wrong database. phpMyAdmin
    retrieves error messages from the MySQL server and displays them on the interface.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our first table
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have a new database, it's time to create a table in it. The example
    table we will create is named **book**.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing the columns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before creating a table, we should plan the information we want to store. This
    is usually done during database design. In our case, a simple analysis leads us
    to the following book-related data we want to keep:'
  prefs: []
  type: TYPE_NORMAL
- en: International Standard Book Number (ISBN)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Title
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Number of pages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Author identification
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For now, it is not important to have the complete list of columns for our **book**
    table. We will modify it by prototyping the structure now and refining it later.
    At the end of the chapter, we will add a second table, `author`, containing information
    about each author.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a table
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have chosen our table name and we know the number of columns. We enter this
    information in the **Create table** dialog and click on **Go** to start creating
    the table. At this point, it does not matter if the number of columns is exactly
    known, as a subsequent panel will permit us to add columns while creating the
    table.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a table](img/7782_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We then see a panel specifying column information. As we asked for four columns,
    we get four input rows. Each row refers to information specific to one column.
    The following screenshot represents the left side of this panel:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a table](img/7782_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And the next one represents the right side:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a table](img/7782_04_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The MySQL documentation explains valid characters for the table and column names
    (if we search for "Legal names"). This may vary depending on the MySQL version.
    Usually, any character that is allowed in a file name (except the dot and the
    slash) is acceptable in a table name, and the length of the name must not exceed
    64 characters. The 64-character limit exists for column names as well, but we
    can use any character.
  prefs: []
  type: TYPE_NORMAL
- en: We enter our column names under the **Column** column. Each column has a type,
    and the most commonly used types are located at the beginning of the drop-down
    list.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **VARCHAR** (variable character) type is widely used when the column content
    is alphanumeric, because the contents will occupy only the space needed for it.
    This type requires a maximum length, which we specify. If we forget to do so,
    a small pop-up message reminds us later when we save. For the page count and the
    author identification, we have chosen **INT** type (integer), as depicted in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a table](img/7782_04_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There are other attributes for columns, but we will leave them empty in this
    example. You might notice the **Add 1 column(s)** dialog at the bottom of the
    screen. We can use it to add some columns to this table-creation panel by entering
    the appropriate value and hitting **Go**. The number of input rows would change
    according to the new number of columns, leaving intact the information already
    entered about the first four columns. Before saving the page, let us define some
    keys.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing keys
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A table should normally have a primary key (a column with unique content that
    represents each row). Having a primary key is recommended for row identification,
    better performance, and possible cross-table relations. A good value here is the
    ISBN; so, in the **Index** dialog we select **PRIMARY** for the **isbn** column.
    Other possibilities for index type include **INDEX, UNIQUE**, and **FULLTEXT**
    (more on this in [Chapter 5)](ch05.html "Chapter 5. Changing Data and Structure").
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Index management** (also referred to as Key management) can be done at initial
    table creation, or later in the **Structure** page of `Table` view.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To improve the speed of the queries that we will make by **author_id**, we
    should add an index on this column. The right part of our screen now looks as
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Choosing keys](img/7782_04_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At this point, we could pick a different **Storage Engine** from the corresponding
    drop-down menu. However, for the time being, we will just accept the default storage
    engine.
  prefs: []
  type: TYPE_NORMAL
- en: Now we are ready to create the table by clicking on **Save**. If all goes well,
    the next screen confirms that the table has been created; we are now in the **Structure**
    page of the current database.
  prefs: []
  type: TYPE_NORMAL
- en: '![Choosing keys](img/7782_04_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Of the various links shown for the **book** table, some are not active, because
    it would not make sense to browse or search a table if there are no rows in it.
  prefs: []
  type: TYPE_NORMAL
- en: Inserting data manually
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have a table, let us put some data in it manually. Before we do
    that, here are some useful references on data manipulation within this book:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 5](ch05.html "Chapter 5. Changing Data and Structure") explains how
    to change data and structure, including how to use the **Function** selector'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Chapter 7](ch07.html "Chapter 7. Importing Structure and Data") explains how
    to import data from existing files'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Chapter 9](ch09.html "Chapter 9. Performing Table and Database Operations")
    explains how to copy data from other tables'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Chapter 10](ch10.html "Chapter 10. Benefiting from the Relational System")
    explains the relational system (in our case, we will want to link to the `author`
    table)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For now, click on the **Insert** link, which will lead us to the data-entry
    (or edit) panel. This screen has room to enter information for two rows, that
    is, two books in our example. This is because the default value of `$cfg['InsertRows']`
    is `2`. In the lower part of the screen, the dialog **Continue insertion with
    2 rows** can be used if the default number of rows does not suit our needs. By
    default, the **Ignore** checkbox is ticked, which means that the second group
    of input fields will be ignored. As soon as we enter some information in one field
    of this group and exit the field, the **Ignore** box is automatically unchecked
    if JavaScript is enabled in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can enter the following sample information for two books:'
  prefs: []
  type: TYPE_NORMAL
- en: 'ISBN: 1-234567-89-0, title: A hundred years of cinema (volume 1), 600 pages,
    author ID: 1'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ISBN: 1-234567-22-0, title: Future souvenirs, 200 pages, author ID: 2'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Value** column width obeys the maximum length for the character columns.
    For this example, we keep the lower drop-down selector to its default value of
    **Insert as new row**. We then click on **Go** to insert the data. There is a
    **Go** button after each set of columns that represent a row, and another one
    on the lower part of the screen. All these have the same effect of saving the
    entered data but are provided for convenience.
  prefs: []
  type: TYPE_NORMAL
- en: '![Inserting data manually](img/7782_04_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If our intention had been to enter data for more books after these two, we would
    have selected **Insert another new row** from the second drop-down before clicking
    on **Go**. This would then insert the data we have provided and reload the screen
    to insert more.
  prefs: []
  type: TYPE_NORMAL
- en: Data entry panel tuning for CHAR and VARCHAR
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By default, phpMyAdmin displays an input field on a single line for the column
    types `CHAR` and `VARCHAR`. This is controlled by setting `$cfg[''CharEditing'']`
    to`''input''`. Sometimes, we may want to insert line breaks (new lines) within
    the field. This can be done by setting `$cfg[''CharEditing'']` to`''textarea''`.
    This is a global setting, and will apply to all the columns of all the tables,
    for all users of this copy of phpMyAdmin. In this mode, insertion of line breaks
    may be done manually with the *Enter* key, or by copying and pasting lines of
    text from another on-screen source. Applying this setting would generate a different
    **Insert** screen, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Data entry panel tuning for CHAR and VARCHAR](img/7782_04_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: With this entry mode, the maximum length of each column no longer applies visually.
    It would be enforced by MySQL at insert time.
  prefs: []
  type: TYPE_NORMAL
- en: Browse mode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many ways to enter this mode. In fact, it is used each time the query
    results are displayed. We can enter this mode by clicking on the table name on
    the navigation panel, or by clicking **Browse** when we are in `Table` view for
    a specific table.
  prefs: []
  type: TYPE_NORMAL
- en: '![Browse mode](img/7782_04_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: SQL query links
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the **Browse** results, the first part displayed is the query itself, along
    with a few links. The displayed links may vary depending on our actions and some
    configuration parameters.
  prefs: []
  type: TYPE_NORMAL
- en: '![SQL query links](img/7782_04_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following points describe the function of each link:'
  prefs: []
  type: TYPE_NORMAL
- en: The **Profiling** checkbox is covered in the *Profiling queries* section of
    this chapter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Inline** link permits to put the query inside a text area without reloading
    the page; then the query may be edited and the new query may be executed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Edit** link appears if `$cfg['SQLQuery']['Edit']` is set to `TRUE`. Its
    purpose is to open the **Query window** so that you can edit this query (refer
    to [Chapter 11](ch11.html "Chapter 11. Entering SQL Statements") for more details).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Explain SQL** is displayed if `$cfg[''SQLQuery''][''Explain'']` is set to
    `TRUE`. We will see in [Chapter 5](ch05.html "Chapter 5. Changing Data and Structure")
    what this link can be used for.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Create PHP Code** link can be clicked to reformat the query to the syntax
    expected in a PHP script. It can then be copied and pasted directly at the place
    where we need the query in the PHP script we are working on. Note that after a
    click, this link changes to **Without PHP Code** (as shown in the following screenshot),
    which would bring back the normal query display. This link is available if `$cfg['SQLQuery']['ShowAsPHP']`
    is set to `TRUE`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![SQL query links](img/7782_04_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Refresh** is used to execute the same query again. The results might change,
    as a MySQL server is a multi-user server, and other users or processes might be
    modifying the same tables. This link is shown if `$cfg[''SQLQuery''][''Refresh'']`
    is set to `TRUE`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Navigation bar
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Navigation bar is displayed at the top of results and also at the bottom.
    Column headers can be repeated at certain intervals among results depending on
    the value entered in **repeat headers after** field.
  prefs: []
  type: TYPE_NORMAL
- en: '![Navigation bar](img/7782_04_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The bar enables us to navigate from page to page, displaying an arbitrary number
    of rows, starting at some point in the results. As we entered browse mode by clicking
    **Browse**, the underlying query that generated the results includes the whole
    table. However, this is not always the case.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are currently using a table containing a small number of rows. With larger
    tables, we could see a more complete set of navigation buttons. To simulate this,
    let us use the **Show** dialog to change the default number of rows from **30**
    to **1**; we then click on **Show**. We can see that the navigation bar adapts
    itself as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Navigation bar](img/7782_04_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This time, there are buttons labeled**<<, <, >**, and**>>** for easy access
    to the first page, previous page, next page, and the last page of the results
    respectively. The buttons appear only when necessary; for example, the **first
    page** button is not displayed if we already are on the first page. These symbols
    are displayed in this manner as the default setting of `$cfg['NavigationBarIconic']`
    is `TRUE`. A `FALSE` here would produce buttons such as **Next** and **End**,
    whereas a value of`'both'` would display**> Next** and**>> End**.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that the `$cfg['NavigationBarIconic']` directive controls only the behavior
    of these navigation buttons; other buttons and links such as **Edit** are controlled
    by other configuration directives.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is also a **Page number** drop-down menu, to go directly to one of the
    pages located near the current page. As there can be hundreds or thousands of
    pages, this menu is kept small and contains the commonly requested pages: a few
    page numbers before and after the current page, a few pages at the beginning and
    at the end plus a sample of page numbers based on a computed interval.'
  prefs: []
  type: TYPE_NORMAL
- en: By design, phpMyAdmin always tries to give quick results, and one way to achieve
    this result is to add a `LIMIT` clause in `SELECT`. If a `LIMIT` clause is already
    there in the original query, phpMyAdmin will respect it. The default limit is
    30 rows, set in `$cfg['MaxRows']`. If there are many users on the server, limiting
    the number of rows returned helps keeping the server load to a minimum.
  prefs: []
  type: TYPE_NORMAL
- en: Another button is available on the navigation bar, but must be activated by
    setting `$cfg['ShowAll']` to `TRUE`. It would be very tempting for users to use
    this button often. Hence, on a multi-user installation of phpMyAdmin, it is recommended
    that the button be left to its default value of disabled (FALSE). When enabled,
    the navigation bar is augmented with a **Show all** button. Clicking on this button
    retrieves all the rows of the current results set, which might hit the execution
    time limit in PHP or a memory limit in the server; most browsers would also crash
    when asked to display thousands of rows. The exact number of rows that can be
    safely displayed cannot be predicted as it depends on the actual data present
    in columns and on the browser's capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If we enter a big number in the **Show __ rows** dialog, the same results will
    be achieved (and we may face the same problems).
  prefs: []
  type: TYPE_NORMAL
- en: Query results operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A section labeled **Query results operations** is located under the results.
    It contains links to print the results (with or without the `FULL TEXT` columns),
    to export these results (refer to *Exporting partial query results* section in
    [Chapter 6)](ch06.html "Chapter 6. Exporting Structure and Data (Backup)"), or
    to create a view from this query (more on this in [Chapter 17)](ch17.html "Chapter 17. Supporting
    Features Added in MySQL 5").
  prefs: []
  type: TYPE_NORMAL
- en: Displaying data as a chart
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Another operation available is **Display chart**. To practice this, we will
    use a different query that selects only two columns. For this we can use the **Inline**
    link shown next to the query and change the query to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Clicking on **Go** produces a result set with only those two columns; next
    we click on **Display chart**, which generates the following panel:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Displaying data as a chart](img/7782_04_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: More details are available at [http://wiki.phpmyadmin.net/pma/Charts](http://wiki.phpmyadmin.net/pma/Charts).
  prefs: []
  type: TYPE_NORMAL
- en: Sorting results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In SQL, we can never be sure of the order in which the data is retrieved, unless
    we explicitly sort the data. Some implementations of the retrieving engine may
    show results in the same order as the one in which data was entered, or according
    to a primary key. However, a sure way to get results in the order we want is by
    sorting them explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: When browsing results are displayed, any column header can be clicked to sort
    on this column, even if it is not part of an index. Let us click on the **author_id**
    column header.
  prefs: []
  type: TYPE_NORMAL
- en: '![Sorting results](img/7782_04_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We can confirm that the sorting has occurred, by watching the SQL query at the
    top of screen; it contains an **ORDER BY** clause.
  prefs: []
  type: TYPE_NORMAL
- en: We now see a small triangle pointing upwards beside the **author_id** header.
    This means that the current sort order is 'ascending'. Hovering the mouse over
    the **author_id** header makes the triangle change direction, to indicate what
    will happen if we click on the header again—a sort by descending **author_id**
    values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to sort is by key. The **Sort** dialog shows all the keys already
    defined. Here we see a key named **PRIMARY—the** name given to our primary key
    on the **isbn** column when we checked **Primary** for this column at creation
    time:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Sorting results](img/7782_04_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This might be the only way to sort on multiple columns at once (for multi-columns
    indexes).
  prefs: []
  type: TYPE_NORMAL
- en: The initial sort order is defined in `$cfg['Order']` with `ASC` for ascending,
    `DESC` for descending, or `SMART`; the latter is the default sort order, which
    means that columns of type `DATE, TIME, DATETIME`, and `TIMESTAMP` would be sorted
    in descending order, whereas other column types will be sorted in ascending order.
  prefs: []
  type: TYPE_NORMAL
- en: Headwords
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Because we can change the number of rows displayed on a page, it is quite possible
    that we do not see the whole data. In this case, it would help to see **headwords**
    —indications about the first and last row of displayed data. This way, you can
    click on **Next** or **Previous** without scrolling to the bottom of the window.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, which column should phpMyAdmin base his headwords generation on? A
    simple assumption has been made: if you click on a column''s header to indicate
    your intention of sorting on this column, phpMyAdmin uses this column''s data
    as a headword. For our current **book** table, we do not have enough data to clearly
    notice the benefits of this technique. However, we can nonetheless see that after
    a sort, the top part of the screen now contains this message:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Showing rows 0 - 1 (2 total, Query took 0.0006 sec) [author_id: 1 - 2]**'
  prefs: []
  type: TYPE_NORMAL
- en: Here, the message between square brackets means that **author_id** number **1**
    is on the first displayed row and number **2** is on the last one.
  prefs: []
  type: TYPE_NORMAL
- en: Color-marking rows or columns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When moving the mouse between rows (or between column headers), the row (or
    column) background color may change to the color defined in `$cfg['BrowsePointerColor']`.
    This parameter can be found in `themes/<themename>/layout.inc.php`. To enable
    this, browse pointer for all themes`—$cfg['BrowsePointerEnable']—`must be set
    to `TRUE` (the default) in `config.inc.php`.
  prefs: []
  type: TYPE_NORMAL
- en: It may be interesting to visually mark some rows when we have many columns in
    the table and must constantly scroll left and right to read data. Another usage
    is to highlight the importance of some rows for personal comparison of data, or
    when showing data to people. Highlighting is done by clicking on the row. Clicking
    again removes the mark on the row. The chosen color is defined by `$cfg['BrowseMarkerColor']`
    (see `themes/<themename>/layout.inc.php)`. This feature must be enabled by setting
    `$cfg['BrowseMarkerEnable']` to `TRUE`, this time in `config.inc.php`. This sets
    the feature for all the themes. We can mark more than one row. Marking the row
    also activates the checkbox for this row.
  prefs: []
  type: TYPE_NORMAL
- en: '![Color-marking rows or columns](img/7782_04_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Marking a column is done by clicking on the column header, but not on the column
    name itself.
  prefs: []
  type: TYPE_NORMAL
- en: Limiting the length of each column
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous examples, we always saw the full contents of each column, as
    each column had the number of characters within the limit defined by `$cfg[''LimitChars'']`.
    This is a limit enforced on all non-numeric columns. If this limit was low (say
    `10)`, the display would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Limiting the length of each column](img/7782_04_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This would help us see more columns at the same time (at the expense of seeing
    less of each column).
  prefs: []
  type: TYPE_NORMAL
- en: Display options
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In order to see the full texts, we will now make use of the **Options** slider,
    which reveals some display options. All these options will be explained in the
    chapters that cover the corresponding notions. The option that concerns us at
    the moment is the **Partial Texts/Full Texts** pair; we can choose **Full Texts**
    to see all of the text that was truncated. Even if we elect not to change the
    `$cfg['LimitChars']` parameter, there will be a time when asking for full texts
    will be useful (when we work with `TEXT` column type—more on this in [Chapter
    5)](ch05.html "Chapter 5. Changing Data and Structure").
  prefs: []
  type: TYPE_NORMAL
- en: A quicker way of seeing the full texts is to click on the big **T** which is
    located just on top of the **Edit** and **Delete** icons. Another click on this
    **T** toggles the display from full to partial.
  prefs: []
  type: TYPE_NORMAL
- en: Browsing distinct values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is a quick way to display all distinct values and the number of occurrences
    for each value of a column. This feature is available on the **Structure** page
    of a table. For example, we want to know how many different authors we have in
    our book table and how many books each one wrote. On the line describing the column
    we want to browse (here **author_id)**, we open the **More** menu and click on
    the **Browse distinct values** link.
  prefs: []
  type: TYPE_NORMAL
- en: '![Browsing distinct values](img/7782_04_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We have a limited test set, but can nonetheless see the results.
  prefs: []
  type: TYPE_NORMAL
- en: '![Browsing distinct values](img/7782_04_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Profiling queries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Profiling support has been added in the MySQL versions 5.0.37 and 5.1.28\. We
    have previously seen the **Profiling** checkbox appear in query results.
  prefs: []
  type: TYPE_NORMAL
- en: 'When this box is checked, phpMyAdmin will analyze every query (including the
    current one), and a report about the execution time of each MySQL internal operation
    is displayed as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Profiling queries](img/7782_04_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Although the profiling system can report additional information about operations
    (such as the CPU time, and even the internal server's function names), phpMyAdmin
    currently displays only the name of the operation and its duration.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an additional table
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In our (simple) design, we know that we need another table—the **author** table.
    The **author** table will contain:'
  prefs: []
  type: TYPE_NORMAL
- en: Author identification
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Full name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Phone number
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To create this table, we go back to the `Database` view for **marc_book** and
    request the creation of another table with three columns as indicated in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating an additional table](img/7782_04_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Using the same techniques used when creating the first table, we type this
    in:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating an additional table](img/7782_04_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As we have three columns or less, the display is now in vertical mode (refer
    to the *Vertical mode* section in [Chapter 5](ch05.html "Chapter 5. Changing Data
    and Structure") for more details).
  prefs: []
  type: TYPE_NORMAL
- en: The column name **id**, which is our primary key in this new table, relates
    to the `author_id` column from the `book` table. After saving the table structure,
    we enter some data for authors 1 and 2\. Use your imagination for this!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter explained how to create a database and tables, and how to enter
    data manually in the tables. It also covered how to confirm the presence of data
    by using the browse mode, which includes the SQL query links, navigation bar,
    sorting options, and row marking.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter explains how to edit data rows and covers the various aspects
    of deletion of rows, tables, and databases.
  prefs: []
  type: TYPE_NORMAL
