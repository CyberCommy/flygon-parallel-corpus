- en: Chapter 1. The Powers of JavaScript's Functional Side – a Demonstration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For decades, functional programming has been the darling of computer science
    aficionados, prized for its mathematical purity and puzzling nature that kept
    it hidden in dusty computer labs occupied by data scientists and PhD hopefuls.
    But now, it is going through a resurgence, thanks to modern languages such as
    **Python**, **Julia**, **Ruby**, **Clojure** and—last but not least—**JavaScipt**.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript, you say? The web's scripting language? Yes!
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript has proven to be an important technology that isn't going away for
    quite a while. This is largely due to the fact that it is capable of being reborn
    and extended with new frameworks and libraries, such as **backbone.js**, **jQuery**,
    **Dojo**, **underscore.js**, and many more. *This is directly related to JavaScript's
    true identity as a functional programming language*. An understanding of functional
    programming with JavaScript will be welcome and useful for a long time for programmers
    of any skill level.
  prefs: []
  type: TYPE_NORMAL
- en: Why so? Functional programming is very powerful, robust, and elegant. It is
    useful and efficient on large data structures. It can be very advantageous to
    use JavaScript—a client-side scripting language, as a functional means to manipulate
    the DOM, sort API responses or perform other tasks on increasingly complex websites.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this book, you will learn everything you need to know about functional programming
    with JavaScript: how to empower your JavaScript web applications with functional
    programming, how to unlock JavaScript''s hidden powers, and how to write better
    code that is both more powerful and—because it is smaller—easier to maintain,
    faster to download, and takes less overhead. You will also learn the core concepts
    of functional programming, how to apply them to JavaScript, how to side-step the
    caveats and issues that may arise when using JavaScript as a functional language,
    and how to mix functional programming with object-oriented programming in JavaScript.'
  prefs: []
  type: TYPE_NORMAL
- en: But before we begin, let's perform an experiment.
  prefs: []
  type: TYPE_NORMAL
- en: The demonstration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Perhaps a quick demonstration will be the best way to introduce functional programming
    with JavaScript. We will perform the same task using JavaScript—once using traditional,
    native methods, and once with functional programming. Then, we will compare the
    two methods.
  prefs: []
  type: TYPE_NORMAL
- en: The application – an e-commerce website
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In pursuit of a real-world application, let's say we need an e-commerce web
    application for a mail-order coffee bean company. They sell several types of coffee
    and in different quantities, both of which affect the price.
  prefs: []
  type: TYPE_NORMAL
- en: Imperative methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, let''s go with the procedural route. To keep this demonstration down
    to earth, we''ll have to create objects that hold the data. This allows the ability
    to fetch the values from a database if we need to. But for now, we''ll assume
    they''re statically defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Downloading the example code**'
  prefs: []
  type: TYPE_NORMAL
- en: You can download example code files for all Packt books you have purchased from
    your account at [http://www.packtpub.com](http://www.packtpub.com). If you purchased
    this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, this code is very basic. What if there were many more coffee
    styles than just the three we have here? What if there were 20? 50? What if, in
    addition to size, there were organic and non-organic options. That could increase
    the lines of code extremely quickly!
  prefs: []
  type: TYPE_NORMAL
- en: Using this method, we are telling the machine what to print for each coffee
    type and for each size. This is fundamentally what is wrong with imperative code.
  prefs: []
  type: TYPE_NORMAL
- en: Functional programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While imperative code tells the machine, step-by-step, what it needs to do to
    solve the problem, functional programming instead seeks to describe the problem
    mathematically so that the machine can do the rest.
  prefs: []
  type: TYPE_NORMAL
- en: 'With a more functional approach, the same application can be written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing that should be obvious is that it is much more modular. This
    makes adding a new size or a new coffee type as simple as shown in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Arrays of coffee objects and size objects are "mixed" together,—that is, their
    methods and member variables are combined—with a custom function called `plusMixin`
    (see [Chapter 7](part0041_split_000.html#page "Chapter 7. Functional and Object-oriented
    Programming in JavaScript"), *Functional and Object-oriented Programming in JavaScript*).
    The coffee type classes contain the member variables and the sizes contain methods
    to calculate the name and price. The "mixing" happens within a `map` operation,
    which applies a pure function to each element in an array and returns a new function
    inside a `reduce()` operation—another higher-order function similar to the `map`
    function, except that all the elements in the array are combined into one. Finally,
    the new array of all possible combinations of types and sizes is iterated through
    with the `forEach()` method The `forEach()` method is yet another higher-order
    function that applies a callback function to each object in an array. In this
    example, we provide it as an anonymous function that instantiates the objects
    and calls the `printPrice()` function with the object's `getPrice()` and `getLabel()`
    methods as arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Actually, we could make this example even more functional by removing the `coffees`
    variable and chaining the functions together—another little trick in functional
    programming.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Also, the control flow is not as top-to-bottom as the imperative code was. In
    functional programming, the `map()` function and other higher-order functions
    take the place of `for` and `while` loops and very little importance is placed
    on the order of execution. This makes it a little trickier for newcomers to the
    paradigm to read the code but, once you get the hang of it, it's not hard at all
    to follow and you'll see that it is much better.
  prefs: []
  type: TYPE_NORMAL
- en: This example barely touched on what functional programming can do in JavaScript.
    Throughout this book, you will see even more powerful examples of the functional
    approach.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, the benefits of adopting a functional style are clear.
  prefs: []
  type: TYPE_NORMAL
- en: Second, don't be scared of functional programming. Yes, it is often thought
    of as pure logic in the form of computer language, but we don't need to understand
    **Lambda calculus** to be able to apply it to everyday tasks. The fact is, by
    allowing our programs to be broken down into smaller pieces, they're easier to
    understand, simpler to maintain, and more reliable. `map()` and `reduce()` function's
    are lesser-known built-in functions in JavaScript, but we'll look at them.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript is a scripting language, interactive and approachable. No compiling
    is necessary. We don't even need to download any development software, your favorite
    browser works as the interpreter and as the development environment.
  prefs: []
  type: TYPE_NORMAL
- en: Interested? Alright, let's get started!
  prefs: []
  type: TYPE_NORMAL
