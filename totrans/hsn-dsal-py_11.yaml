- en: Selection Algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One interesting set of algorithms related to finding elements in an unordered
    list of items is selection algorithms. Given a list of elements, selection algorithms
    are used to find the `ith` smallest element from the list. In doing so, we shall
    be answering questions that have to do with selecting the median of a set of numbers
    and selecting the `i^(th)` smallest or largest element in a list.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Selection by sorting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Randomized selection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deterministic selection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All of the source code that''s used in this chapter is provided in the given
    GitHub link: [https://github.com/PacktPublishing/Hands-On-Data-Structures-and-Algorithms-with-Python-Second-Edition/tree/master/Chapter11](https://github.com/PacktPublishing/Hands-On-Data-Structures-and-Algorithms-with-Python-Second-Edition/tree/master/Chapter11).'
  prefs: []
  type: TYPE_NORMAL
- en: Selection by sorting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Items in a list may undergo statistical inquiries such as finding the mean,
    median, and mode values. Finding the mean and mode values does not require the
    list to be ordered. However, to find the median in a list of numbers, the list
    must first be ordered. Finding the median requires you to find the element in
    the middle position of the ordered list. In addition, this can be used when we
    want to find the last-smallest item in the list or the first-smallest item in
    the list. In such situations, selection algorithms can be useful.
  prefs: []
  type: TYPE_NORMAL
- en: To find the `i^(th)` smallest number in an unordered list of items, the index
    of where that item occurs is important to obtain. Since the elements of the list
    are not sorted, it is difficult to know whether the element at index 0 in a list
    is really the first-smallest number.
  prefs: []
  type: TYPE_NORMAL
- en: A pragmatic and obvious thing to do when dealing with unordered lists is to
    first sort the list. After the list is sorted, you can rest assured that the element
    at the 0 index will hold the first-smallest element in the list. Likewise, the
    last element in the list will hold the last-smallest element in the list. However,
    it is not a good solution to apply a sorting algorithm on a long list of elements
    to obtain the minimum or maximum value from the list as sorting is quite an expensive
    operation.
  prefs: []
  type: TYPE_NORMAL
- en: Let's discuss if it's possible to find the `i^(th)` smallest element without
    having to sort the list in the first place.
  prefs: []
  type: TYPE_NORMAL
- en: Randomized selection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we discussed the quicksort algorithm. The quicksort
    algorithm allows us to sort an unordered list of items, but has a way of preserving
    the index of elements as the sorting algorithm runs. Generally speaking, the quicksort
    algorithm does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Selects a pivot
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Partitions the unsorted list around the pivot
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Recursively sorts the two halves of the partitioned list using *steps 1* and
    *2*
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: One interesting and important fact is that after every partitioning step the
    index of the pivot will not change, even after the list has become sorted. This
    means that after each iteration the selected pivot value will be placed at its
    correct position in the list. It is this property that enables us to be able to
    work with a not-so-fully sorted list to obtain the `i^(th)` smallest number. Because
    randomized selection is based on the quicksort algorithm, it is generally referred
    to as quick select.
  prefs: []
  type: TYPE_NORMAL
- en: Quick select
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The quickselect algorithm is used to obtain the `k^(th)` smallest element in
    an unordered list of items, and is based on the quicksort algorithm. In quicksort,
    we recursively sort the elements of both the sublists from the pivot point. In quicksort,
    in each iteration, we know that the pivot value reaches its correct position in
    the list with two sublists (left and right sublists), having all of their elements
    set to be unordered.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, in the case of the quickselect algorithm, we recursively call the
    function exclusively for the sublist that has the `k^(th)` smallest element. In
    the quickselect algorithm, we compare the index of the pivot point with the `k` value
    to obtain the `k^(th)` smallest element from the given unordered list. There will
    be three cases in the quickselect algorithm, and they are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: If the index of the pivot point is smaller than `k`, then we are sure that the
    `k^(th)` smallest value will be present in the right sublist from the pivot point.
    So, we only recursively call the quickselect function for the right sublist.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the index of the pivot point is greater than `k`, then it is obvious that
    the `k^(th)` smallest element will be present in the left side from the pivot
    point. So, we only recursively look for the `i^(th)` element in the left sublist.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the index of the pivot point is equal to `k`, then it means that we have
    found out the `k^(th)` smallest value, and we return it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's understand how the quickselect algorithm work by looking at an example.
    Let's consider a list of elements, `{45, 23, 87, 12, 72, 4, 54, 32, 52}`, where
    want to find out the 3^(rd) smallest element from this list—we do this by using
    the quicksort algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: We start the algorithm by selecting a pivot value, that is, 45\. After the first
    iteration of the algorithm, we place the pivot value to its correct position in
    the list, that is, at index 4 (the index is starting from 0). Now, we compare
    the index of the pivot value (that is, 4 ) with the value of `k` (that is, 3^(rd)
    position, or at index 2). Since this is at the `k<pivot` point (that is, 2<4),
    we only consider the left sublist, and recursively call the function.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we take the left sublist and select the pivot point (that is, **4**). After
    the run, the **4** is placed at its correct position (that is, the 0^(th) index).
    As the index of the pivot is less than the value of `k`, we consider the right
    sublist. Similarly, we take **23** as the pivot point, which is also placed at its
    correct position. Now, when we compare the index of the pivot point and the value
    of `k`, they are equal, which means we have found the 3^(rd) smallest element,
    and it will be returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'This process is also shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/15c61235-c781-4d49-aff5-38a00a946718.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To implement the quickselect algorithm, we first need to understand the main
    function, where we have three possible conditions. We declare the main method
    of the algorithm as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `quick_select` function takes the index of the first element in the list—as
    well as the last —as parameters. The `i^(th)` element is specified by the third
    parameter, `k`. The value of `k` should always be positive; the values greater
    or equal to zero (`0`) are only allowed in such a way that when `k` is `0`, we
    know to search for the first-smallest item in the list. Others like to treat the
    `k` parameter so that it maps directly with the index that the user is searching
    for, so that the first-smallest number maps to the `0` index of a sorted list.
  prefs: []
  type: TYPE_NORMAL
- en: A method call to the partition function, `split = partition(array_list, left,
    right)`, returns the `split` index. This index of the `split` array is the position
    in the unordered list where all elements between `right` to `split-1` are less
    than the element contained in the `split` array, while all elements between `split+1`
    to `left` are greater.
  prefs: []
  type: TYPE_NORMAL
- en: When the `partition` function returns the `split` value, we compare it with
    `k` to find out if the `split` corresponds to the `k^(th)` items.
  prefs: []
  type: TYPE_NORMAL
- en: 'If `split` is less than `k`, then it means that the `k^(th)` smallest item
    should exist or be found between `split+1` and `right`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/b609a32d-9262-441a-9e70-12d26502cff8.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding example, a split within an imaginary unordered list occurs
    at index **5**, while we are searching for the second-smallest number. Since 5<2
    yields `false`, a recursive call to return `quick_select(array_list, left, split-1,
    k)` is made so that the other half of the list is searched.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the `split` index was less than `k`, then we would make a call to `quick_select`,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/46160450-f11f-4a78-9139-0ceb47a7e1e3.png)'
  prefs: []
  type: TYPE_IMG
- en: Understanding the partition step
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The partition step is similar to what we had in the quicksort algorithm. There
    are a couple of things that are worth noting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: An `if` statement has been inserted at the beginning of the function definition
    to cater for situations where `first_index` is equal to `last_index`. In such
    cases, it means that there is only one element in our sublist. Therefore, we simply
    return any of the function parameters, in this case, `first_index`.
  prefs: []
  type: TYPE_NORMAL
- en: The first element is always chosen as the pivot. This choice to make the first
    element the pivot is a random decision. It often does not yield a good split—and
    subsequently—a good partition. However, the `i^(th)` element will eventually be
    found, even though the pivot is chosen at random.
  prefs: []
  type: TYPE_NORMAL
- en: The `partition` function returns the pivot index pointed to by `less_than_pivot_index`,
    as we saw in the preceding chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Deterministic selection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The worst-case performance of a randomized selection algorithm is `O(n²)`. It
    is possible to improve the section of an element of the randomized selection algorithm
    to obtain a worst-case performance of `O(n)`. We can obtain the performance of
    `O(n)` by using an algorithm, that is, **deterministic selection**.
  prefs: []
  type: TYPE_NORMAL
- en: Median of the median is an algorithm that provides us with the approximate median
    value, that is, a value close to the actual median for a given unsorted list of
    elements. This approximate median is often used as a pivot point in the quickselect
    algorithm for selecting the `i^(th)` smallest element from a list. It is due to
    the fact that the median of median algorithm finds out the estimated median in
    a linear time, and when this estimated median is used as a pivot point in the
    quickselect algorithm, the worst-case running time's complexity drastically improves
    from `O(n²)` to the linear `O(n)`. Therefore, the median of the median algorithm
    helps the quickselect algorithm to perform significantly better because of the
    choice of a good pivot value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The general approach to the deterministic algorithm to select the `i^(th)`
    smallest element is listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Select a pivot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Split a list of unordered items into groups of five elements each.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sort and find the median of all the groups.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat *steps 1* and* 2* recursively to obtain the true median of the list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the true median to partition the list of unordered items.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Recurse into the part of the partitioned list that may contain the `i^(th)` smallest
    element.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's consider an example list of 15 elements to understand the working of the
    deterministic approach to determine the third smallest element from the list.
    First, you need to divide the lists that have 5 elements each, and then we sort
    the sublists. Once we have sorted the lists, we find out the median of the sublists,
    that is, items **23**, **52**, and **34** are the medians of these three sublists.
    We prepare a list of medians of all the sublists, and then we sort the list of
    medians. Next, we determine the median of this list, that is, the median of the
    median, which is **34**. This value is the estimated median of the whole list,
    and is used to select the partition/pivot point for the whole list. Since the
    index of the pivot value is 7, which is greater than the `i^(th)` value, we recursively
    consider the left sublist.
  prefs: []
  type: TYPE_NORMAL
- en: 'The functionality of the algorithm is shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/b894d148-b32e-4111-88f6-9d397cbc815b.png)'
  prefs: []
  type: TYPE_IMG
- en: Pivot selection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To implement the deterministic algorithm to efficiently determine the `i^(th)`
    smallest value from the list, we start by implementing the pivot selection method.
    Previously, in the random selection algorithm, we selected the first element as
    the pivot. We shall replace that step with a sequence of steps that enables us
    to obtain the approximate median. This will improve the partitioning of the list
    regarding the pivot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now understand the code for the `partition` function. The `nearest_median`
    variable stores the true or approximate median of a given list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: If the `unsorted_array` parameter has only one element, `first_index` and `last_index`
    will be equal. Therefore, `first_index` is, returned anyway.
  prefs: []
  type: TYPE_NORMAL
- en: However, if the list size is greater than one, we call the `median_of_medians`
    function with the section of the array, demarcated by `first_index` and `last_index`.
    The return value is yet again stored in `nearest_median`.
  prefs: []
  type: TYPE_NORMAL
- en: Median of medians
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `median_of_medians` function is responsible for finding the approximate
    median of any given list of items. The function uses recursion to return the true
    median:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The function begins by splitting the list, `elems`, into groups of five elements
    each. This means that if `elems` contains 100 items, there will be 20 groups that
    are created by the `sublists = [elems[j:j+5] for j in range(0, len(elems), 5)]` statement,
    with each containing exactly five elements or fewer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: An empty array is created and assigned to `medians`, which stores the medians
    in each of the five element arrays assigned to `sublists`.
  prefs: []
  type: TYPE_NORMAL
- en: The for loop iterates over the list of lists inside `sublists`. Each sublist
    is sorted, the median is found, and is stored in the `medians` list.
  prefs: []
  type: TYPE_NORMAL
- en: The `medians.append(sorted(sublist)[len(sublist)//2])` statement will sort the
    list and obtain the element stored in its middle index. This becomes the median
    of the five-element list. The use of an existing sorting function will not impact
    the performance of the algorithm due to the list's small size.
  prefs: []
  type: TYPE_NORMAL
- en: We understood from the outset that we would not sort the list in order to find
    the `i^(th)` smallest element, so why employ Python's sorted method? Well, since
    we are sorting a very small list of five elements or fewer, the impact of that
    operation on the overall performance of the algorithm is considered negligible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thereafter, if the list now contains five or fewer elements, we shall sort
    the `medians` list and return the element located in its middle index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: If, on the other hand, the size of the list is greater than five, we recursively
    call the `median_of_medians` function again, supplying it with the list of the
    medians stored in `medians`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take, for instance, another example to better understand the concept of the
    median of median algorithm, with the following list of numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '*[2, 3, 5, 4, 1, 12, 11, 13, 16, 7, 8, 6, 10, 9, 17, 15, 19, 20, 18, 23, 21,
    22, 25, 24, 14]*'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can break this list into groups of five elements each with the `sublists
    = [elems[j:j+5] for j in range(0, len(elems), 5)]` code statement in order to
    obtain the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: '*[[2, 3, 5, 4, 1], [12, 11, 13, 16, 7], [8, 6, 10, 9, 17], [15, 19, 20, 18,
    23], [21, 22, 25, 24, 14]]*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Sorting each of the five-element lists and obtaining their medians produces
    the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: '*[3, 12, 9, 19, 22]*'
  prefs: []
  type: TYPE_NORMAL
- en: Since the list is five elements in size, we only return the median of the sorted
    list; otherwise, we would have made another call to the `median_of_median` function.
  prefs: []
  type: TYPE_NORMAL
- en: The median of medians algorithm can also be used to choose a pivot point in
    the quicksort algorithm for sorting a list of elements. This significantly improves
    the worst-case performance of the quicksort algorithm from `O(n²)` to a complexity
    of `O(n log n)`.
  prefs: []
  type: TYPE_NORMAL
- en: Partitioning step
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have obtained the approximate median, the `get_index_of_nearest_median`
    function takes the bounds of the list indicated by the `first` and `last` parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Once again, we only return the first index if there is only one element in
    the list. However, `arraylist[first:second]` returns an array with an index of
    `0` up to the size of the `list -1`. When we find the index of the median, we
    lose the portion in the list where it occurs because of the new range indexing
    that the `[first:second]` code returns. Therefore, we must add whatever index
    is returned by `arraylist[first:second]` to `first` to obtain the true index where
    the median was found:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We then swap the first element in `unsorted_array` with `index_of_nearest_median`,
    using the `swap` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `utility` function to swap two array elements is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Our approximate median is now stored at `first_index` of the unsorted list.
  prefs: []
  type: TYPE_NORMAL
- en: 'The partition function continues as it would in the code of the quickselect
    algorithm. After the partitioning step, the array looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/ae12fc42-27b4-4a09-b4ad-561e164c2163.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As you will have already observed, the main function of the deterministic selection
    algorithm looks exactly the same as its random selection counterpart. After the
    initial `array_list` has been partitioned for the approximate median, a comparison
    with the `k^(th)` element is made.
  prefs: []
  type: TYPE_NORMAL
- en: If `split` is less than `k`, then a recursive call to `deterministic_select(array_list,
    split + 1, right, k)` is made. This will look for the `k^(th)` element in that
    half of the array. Otherwise, the function call to `deterministic_select(array_list,
    left, split-1, k)` is made.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed various ways to answer the question of how to
    find the `i^(th)` smallest element in a list. The trivial solution of simply sorting
    a list to perform the operation of finding the `i^(th)` smallest element was explored.
  prefs: []
  type: TYPE_NORMAL
- en: There is also the possibility of not necessarily sorting the list before we
    can determine the `i^(th)` smallest element. The random selection algorithm allows
    us to modify the quicksort algorithm to determine the `i^(th)` smallest element.
  prefs: []
  type: TYPE_NORMAL
- en: To further improve upon the random selection algorithm so that we can obtain
    a time complexity of `O(n)`, we embarked on finding the median of medians to enable
    us to find a good split during partitioning.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore the world of strings. We will learn how
    to efficiently store and manipulate large amounts of text. Data structures and
    common string operations will be covered too.
  prefs: []
  type: TYPE_NORMAL
