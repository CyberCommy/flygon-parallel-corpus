- en: Keyboard Input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have sprites and animations, and can move these sprites around our
    canvas, we will need to add some interaction into our game. There are a few ways
    we can get keyboard input for our game. One way is through JavaScript, making
    calls to different functions in our WebAssembly module based on that input. The
    first section of our code will do just that. We will add some functions inside
    the WebAssembly module for us to wrap in JavaScript wrappers. We will also set
    up some JavaScript keyboard event handlers that we will use to make calls into
    our WebAssembly module whenever the keyboard events are triggered.
  prefs: []
  type: TYPE_NORMAL
- en: The other way we can get input into our WebAssembly module is to allow SDL to
    do all the heavy lifting for us. That involves adding C code into our WebAssembly
    module that captures the `SDL_KEYDOWN` and `SDL_KEYUP` events. The module will
    then look at the event keycode to determine what key triggered the event. There
    are costs and benefits to writing our code using either method. Generally speaking,
    having SDL managing our keyboard input costs us some of the flexibility of writing
    our keyboard input manager inside the JavaScript, while, at the same time, we
    gain the benefit of more straightforward code.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will need to include several images in your build to make this project
    work. Make sure you include the `/Chapter05/sprites/` folder from the project''s
    GitHub. If you haven''t yet downloaded the GitHub project, you can get it online
    at: [https://github.com/PacktPublishing/Hands-On-Game-Development-with-WebAssembly](https://github.com/PacktPublishing/Hands-On-Game-Development-with-WebAssembly).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Learn how to use JavaScript keyboard events to make calls into our WebAssembly
    module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn how to use SDL events to manage keyboard input from inside our WebAssembly
    module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Demonstrate what we have learned by using keyboard input to move a spaceship
    sprite around the canvas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaScript keyboard input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first thing we will do is learn how to listen for JavaScript keyboard events
    and make calls into our WebAssembly module based on those events. We will be reusing
    a lot of the code we wrote for [Chapter 2](0c9c09be-1e03-4074-9718-7bc3bf9e70e2.xhtml),
    *HTML5 and WebAssembly*, so the first thing we should do is grab that code from
    the `Chapter02` folder and copy it into our new `Chapter05` folder. Copy the `new_shell.html`
    file from inside the `Chapter02` directory to the `Chapter05` directory, then
    rename that file `jskey_shell.html`. Next, copy `shell.c` from the `Chapter02`
    directory to the `Chapter05` directory and rename that file `jskey.c`. Finally,
    copy the `shell.css` file from the `Chapter02` directory into the `Chapter05`
    directory, but do not rename it. These three files will give us a starting point
    for writing the JavaScript keyboard input code.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s take a look at the `jskey.c` file that we have just created from
    `shell.c`. We can get rid of most of the code inside this file right at the beginning.
    Delete all of the code after the end of the `main` function. That means you will
    be deleting all of the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will modify the `main` function. We no longer want to use `EM_ASM`
    inside our `main` function to call our JavaScript wrapper initialization function,
    so delete the following two lines of code from the `main` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The only thing left in our `main` function is a single `printf` statement.
    We will change that line to let us know that the `main` function has run. You
    can change this code to say anything you like, or remove the `printf` statement
    entirely. The following code shows what we have for the `main` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have modified the `main` function, and removed all of the functions
    we no longer need, let''s put in some functions called when a JavaScript `keyboard`
    event is triggered. We will add a function for a `keypress` event when the user
    presses one of the arrow keys on the keyboard. The following code will be called
    by those `keypress` events:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We would also like to know when the user releases a key. So,to do this, we
    will add four `release` functions into the C module, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our new C file, we can change our shell file. Open up `jskey_shell.html`.
    We do not need to change anything in the `head` tag, but inside the `body`, we
    will want to remove a lot of the HTML elements that we will no longer be using.
    Go ahead and delete all of the elements except the `textarea` element. We want
    to keep our `textarea` element around so that we can see the output of the `printf`
    statements inside our module. We need to delete the following HTML from the `jskey_shell.html`
    before our `textarea` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, after the `textarea` element, we need to delete the following `div` and
    its contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we have the `script` tag that contains all of our JavaScript code.
    We will need to add some global variables into that `script` tag. First, let''s
    add some Boolean variables that will tell us if the player is pressing any of
    our arrow keys. Initialize all of these values to `false`, as per the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Following our `key_press` flags, we will have all of the `wrapper` variables
    that will be used to hold the `wrapper` functions that call functions within our
    WebAssembly module. We will initialize all of these wrappers to `null`. Later,
    we will only call these functions if they are not `null`. The following code shows
    our wrappers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have defined all of our global variables, we need to add functions
    triggered on the `key_press` and `key_release` events. The first of these functions
    is `keyPress`. The code we have for this function is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The first line of this function is `event.preventDefault();`. This line prevents
    the web browser from doing what it would normally do when the user presses the
    key in question. For instance, if you are playing a game, and you press the down
    arrow key to have your spaceship move down, you would not want the web page also
    to scroll down. Placing this `preventDefault` call at the beginning of the `keyPress`
    function will disable the default behavior for all key presses. In other projects,
    this may not be what you want. If you only wanted to disable the default behavior
    when pressing the down arrow key, you would place that call inside of the `if`
    block that manages the down arrow key press. The following block of code checks
    to see if the event is a repeat event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: That would be true if you held down one of the keys. For example, if you held
    down the up arrow key, you would initially get one up arrow key press event, but,
    after a delay, you would start getting a repeat event for the up arrow key. You
    may have noticed that behavior inside a word processor if you have ever held down
    a single key, like the *F* key for instance. You would start with a single f that
    appears inside your word processor, but, after a second or so you would start
    to get ffffffffffffff, and you would continue to see f repeated into your word
    processor for as long as you held down the *F* key. Generally speaking, this behavior
    may be helpful when you are using a word processor, but is detrimental when you
    are playing a game. The preceding `if` block causes us to exit the function when
    we are receiving repeat key events.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next several `if` blocks in our function check the various JavaScript keycodes
    and make calls to our WebAssembly module based on those keycodes. Let''s take
    a quick look at what happens when the player presses the up arrow key, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The `if` statement is checking the event''s keycode against the value `38`,
    which is the keycode value for the up arrow. You can find a list of HTML5 keycodes
    at: [https://www.embed.com/typescript-games/html-keycodes.html](https://www.embed.com/typescript-games/html-keycodes.html).
    If the triggering event was an up arrow key press, we set the `up_key_press` variable
    to `true`. If our `up_press_wrapper` is initialized, we call it, which in turn
    will call the `press_up` function inside our WebAssembly module. After the `if`
    block that checks against the up arrow keycode, we will need more `if` blocks
    to check against the other arrow keys, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'After the `keyUp` function, we need to create a very similar function: `keyRelease`.
    This function is pretty much the same as `keyUp`, except it will be calling the
    key release functions in the WebAssembly module. The following code shows what
    the `keyRelease()` function looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'After we have defined these functions, we need to make them event listeners
    with the following two lines of JavaScript code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The next thing we need to do is modify our `InitWrappers` function to wrap
    the functions we created earlier. We do this using the `Module.cwrap` function.
    The new version of our `InitWrappers` function is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We have two functions that are no longer needed that we can remove. These are
    the `runbefore` and `runafter` functions. These functions were used in our shell
    in chapter 2, *HTML5 and WebAssembly,* to demonstrate the `preRun` and `postRun`
    module functionality. All they do is log a line out to the console, so please
    remove the following code from the `jskey_shell.html` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have deleted these lines, we can remove the call to these functions
    from our module''s `preRun` and `postRun` arrays. Because we had earlier removed
    the call to `EM_ASM( InitWrappers() );` inside our WebAssembly module''s `main`
    function, we will need to run `InitWrappers` from the module''s `postRun` array.
    The following code shows what the beginning of the `Module` object definition
    looks like after these changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we should build and test our new JavaScript keyboard handler. Run the following
    `emcc` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: You will notice that we have used the `-s EXPORT_FUNCTIONS` flag to export all
    of our key press and key release functions. Because we are not using the default
    shell, we have used the `--shell-file jskey_shell.html` flag. The `-s NO_EXIT_RUNTIME=1`
    flag prevents the browser from exiting the WebAssembly module if there is no emscripten
    main loop. We also exported `cwrap` and `ccall` with `-s EXTRA_EXPORTED_RUNTIME_METHODS="['cwrap',
    'ccall']"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a screenshot of the app:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e34de0b2-9525-4a1b-9cad-5e851c5e1368.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.1: Screenshot of jskey.html'
  prefs: []
  type: TYPE_NORMAL
- en: It is important to remember that the app must be run from a web server, or using
    `emrun`. If you do not run the app from a web server, or use `emrun`, you will
    receive a variety of errors when the JavaScript glue code attempts to download
    the WASM and data files. You should also know that IIS requires additional configuration
    in order to set the proper MIME types for the `.wasm` and `.data` file extensions.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will be using the SDL event handler and the default
    WebAssembly shell to capture and process keyboard events.
  prefs: []
  type: TYPE_NORMAL
- en: Adding SDL keyboard input to WebAssembly
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SDL allows us to poll for keyboard input. Whenever the user presses a key, a
    call to `SDL_PollEvent( &event )` will return us an `SDK_KEYDOWN SDL_Event`. When
    a key is released, it will return an `SDK_KEYUP` event. We can look into the values
    in such a case to figure out which key has been pressed or released. We can use
    this information to set flags in our game to let us know when to move our spaceship,
    and in what direction. Later, we can add code that detects a space bar press that
    will fire our ship's weapons.
  prefs: []
  type: TYPE_NORMAL
- en: For now, we are going to go back to using the default Emscripten shell. For
    the rest of this section, we will be able to do everything from within the WebAssembly
    C code. I will walk you through creating a new `keyboard.c` file from scratch,
    which will handle keyboard events and print to the `textarea` in our default shell.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by creating a new `keyboard.c` file, and add the following `#include`
    directives at the top of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we need to add our global `SDL` objects. The first two, `SDL_Window`
    and `SDL_Renderer`, should look familiar by now. The third one, `SDL_Event`, is
    new. We will be populating this event object using a call to `SDL_PollEvent` later
    in our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Like the JavaScript version of this code, we will be using global variables
    to keep track of which arrow keys we are currently pressing. These will all be
    Boolean variables, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The first function we are going to define is `input_loop`, but before we can
    define that function, we need to declare two functions that `input_loop` will
    be calling, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This will allow us to define the `input_loop` function before actually defining
    what happens when `input_loop` calls those functions. The `input_loop` function
    will call `SDL_PollEvent` to get an event object. We can then look at the type
    of event, and, if it is an `SDL_KEYDOWN` or `SDL_KEYUP` event, we can call the
    appropriate function to handle those events, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The first of these functions that we will define will be the `key_press()`
    function. Inside this function, we will look at the keyboard event in a switch
    and compare the value to the different arrow key SDLK events. If the key had been
    previously up, it prints out a message that lets us know the key the user pressed.
    Then we should set the `keypress` flag to `true`. The following example shows
    the `key_press()` function in its entirety:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The first line inside the `key_press` function is a switch statement, `switch(event.key.keysym.sym)`.
    These are structures within structures. Inside the `input_loop` function, we called
    `SDL_PollEvent`, passing a reference to an `SDL_Event` structure. This structure
    contains event data for any possible event that may be returned to us, as well
    as a type that tells us what kind of event this is. If the type is `SDL_KEYDOWN`
    or `SDL_KEYUP`, that means the internal `key` structure, which is a structure
    of type `SDL_KeyboardEvent`, is populated. If you would like to see the full definition
    of the `SDL_Event` structure, you can find it on the SDL website, at: [https://wiki.libsdl.org/SDL_Event](https://wiki.libsdl.org/SDL_Event).
    Looking at the key variable inside of `SDL_Event`, you will notice it is a structure
    of type `SDL_KeyboardEvent`. This structure has a lot of data in it that we will
    not be using yet. It includes information such as timestamp, whether this key
    is a repeat press, or whether this key is being pressed or released; but what
    we are looking at in our switch is they `keysym` variable, which is a structure
    of type `SDL_Keysym`. For more information on the `SDL_KeyboardEvent`, you can
    find its definition on the SDL website, at: [https://wiki.libsdl.org/SDL_KeyboardEvent](https://wiki.libsdl.org/SDL_KeyboardEvent).
    The `keysym` variable in the `SDL_KeyboardEvent` structure is where you will find
    the `SDL_Keycode` in the `sym` variable. This keycode is what we must look at
    to determine which key the player pressed. That is why we have the switch statement
    built around `switch( event.key.keysym.sym )`. A link to all of the possible values
    for the SDL keycodes is available at: [https://wiki.libsdl.org/SDL_Keycode](https://wiki.libsdl.org/SDL_Keycode).'
  prefs: []
  type: TYPE_NORMAL
- en: 'All of the case statements inside our switch look pretty similar: if a given
    SDLK keycode is pressed, we check to see if that key was pressed in the previous
    cycle, and we only print out the value if it has not. Then we set the `keypress`
    flag to `true`. The following example shows the code where we detect the press
    of the left arrow key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Our application calls the `key_release` function when the event type is `SDL_KEYUP`
    . That is very similar to the `key_down` function. The primary difference is that
    it is looking to see if the user pressed the key, and only prints out a message
    when the state changes to unpressed. The following example shows that function
    in its entirety:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Our last function is a new version of the `main` function, called when our
    `Module` is loaded. We still need to use `emscripten_set_main_loop` to prevent
    our code from tying up the JavaScript engine. We have created an `input_loop`
    which we defined earlier. It uses SDL to poll for keyboard events. But, before
    that, we still need to do our SDL initialization. We are using the Emscripten
    default shell, so the call to `SDL_CreateWindowAndRenderer` will set the width
    and height of our `canvas` element. We will not be rendering to the `canvas` element
    inside our `input_loop`, but we still want to have it initialized here because,
    in the next section, we will be adapting this code to render a spaceship image
    to the canvas and to move it around with key presses. The following code shows
    what the new version of our `main` function will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have all the code inside our `keyboard.c` file, we can compile
    our `keyboard.c` file with the following `emcc` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: When you run `keyboard.html` in the browser, you will notice that pressing the
    arrow keys results in a message printed to the Emscripten default shell's textarea.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/41a1b5c7-89b9-4b88-ae20-16283cad1c8e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.2: Screenshot of keyboard.html'
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will learn how to use this keyboard input to move a
    sprite around our canvas.
  prefs: []
  type: TYPE_NORMAL
- en: Using keyboard input to move a sprite
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we know how to get keyboard input and use it in our WebAssembly module,
    let''s figure out how we can take that keyboard input and use it to move our spaceship
    sprite around the HTML canvas. Let''s begin by copying `sprite_move.c` from the
    `Chapter04` directory into the `Chapter05` directory. That will give us a good
    starting point. Now we can start modifying the code. We will need to add a single
    `#include` to the beginning of our `.c` file. Because we need Boolean variables,
    we must add `#include <stdbool.h>`. The new start of our `.c` file will now look
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, all the `#define` directives will remain unchanged from what they
    were in the `sprite_move.c` file, as can be seen in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The `sprite_move.c` file had several global variables that we will continue
    to use in `keyboard_move.c`. Do not remove any of these variables; we will only
    be adding to them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to bring in some variables from the `keyboard.c` file that we used
    in the previous section. We need the `SDL_Event` global variable so that we have
    something to pass into our call to `SDL_PollEvent`, and we need our Boolean key
    press flags, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We then have the function declarations, which allow us to define the `key_press`
    and `key_release` functions after we have defined our `input_loop` function, as
    shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will bring in the `input_loop` function from our `keyboard.c` file.
    This is the function that we use to call `SDL_PollEvent`, and, based on the event
    type returned, either calls `key_press` or `key_release`. This function remains
    unchanged from the version we had in `keyboard.c`, as can be seen in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The `key_press` and `key_release` functions follow the `input_loop` function
    and remain unchanged from the `keyboard.c` version. The primary purpose of these
    functions is to set the keypress flags. The `printf` statements are now unnecessary,
    but we will leave them there. This is not a good thing for performance because
    continuing to add lines to our `textarea` with every key press and release will
    eventually slow our game down, but, at this point, I feel it is better to leave
    these statements in for demonstration purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The next function in the `keyboard_move.c` file will be `show_animation`. This
    function will need to be changed significantly from the version that appears in
    `sprite_move.c`, to allow the player to control the spaceship and move it around
    the canvas. The following example shows you the new function in its entirety before
    we go through it a piece at a time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We added the very first line in `show_animation` to this new version of the
    function. The call to `input_loop` is used to set the key press flags every frame.
    After the call to `input_loop`, there is a chunk of the code that we have not
    changed from the `sprite_move.c` file, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This code calls `SDL_GetTicks()` to get the current time, and then subtracts
    the current time from the last time the current frame changed, to get the number
    of milliseconds it has been since we last had a frame change. If the number of
    milliseconds since the last frame change is greater than the number of milliseconds
    that we want to stay on any given frame, we need to advance the current frame.
    Once we have figured out whether or not we have advanced the current frame, we
    need to make sure that the current frame is not more than our frame count. If
    it is, we need to reset it to `0`. After that, we need to clear out our renderer
    and set the texture we are using to the texture in our animation array that corresponds
    with the current frame.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `sprite_move.c`, we moved the `y` coordinates of our spaceship up one pixel
    per frame with the following few lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'In the new keyboard app, we only want to change our `y` coordinate when the
    player presses the up arrow key. To do this, we must enclose the code that changes
    the `y` coordinate in an `if` block that checks the `up_key_press` flag. Here
    is the new version of that code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to add code that moves the spaceship when the player presses the
    other arrow keys. The following code moves the spaceship down, left or right based
    on what keys the player is currently pressing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have to render the texture and present it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The `main` function will not change from the version inside `sprite_move.c`
    because none of the initialization has changed. The following code shows the `main`
    function as it appears in `keyboard_move.c`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: As I said earlier, this code is a combination of the last application we wrote
    in [Chapter 4](f14c80d0-2d87-45b1-96ab-a3305ad35c50.xhtml), *Sprite Animations
    in WebAssembly with SDL*, and the code we wrote in the section *Adding SDL keyboard
    input to WebAssembly* where we were taking input from the keyboard and logging
    our keys with the `printf` statement. We kept our `input_loop` function and added
    a call to it from the beginning of our `show_animation` function. Inside `show_animation`,
    we no longer move the ship one pixel up every frame, but only move the ship up
    if we are pressing the up arrow key. Likewise, we move the ship left when the
    user presses the left arrow key, right when the right arrow key is pressed and
    down when the user presses the down arrow key.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have our new `keyboard_move.c` file, let''s compile it and try
    out our new moving spaceship. Run the following `emcc` command to compile the
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to add the `--preload-file sprites` flag to indicate that we want a
    virtual file system with the sprites folder included. We also need to add the
    `-s USE_SDL=2` and `-s USE_SDL_IMAGE=2 -s SDL2_IMAGE_FORMATS=["png"]` flags to
    allow us to load `.png` files from the virtual file system. Once you have compiled
    `keyboard_move.html`, load it into a browser and use the arrow keys to move the
    spaceship around the canvas. See the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cb33d02f-3e01-4378-a984-a4a408df6e4b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.3: Screenshot of keyboard_move.html'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to get keyboard input for use with WebAssembly.
    There are two primary methods. We could either take in keyboard input on the JavaScript
    side and communicate with WebAssembly through a wrapper made with `Module.cwrap`,
    or by calling WebAssembly functions directly with `Module.ccall`. The other way
    to accept keyboard input in WebAssembly is by using SDL keyboard input events.
    When we use this method, we can use the default Emscripten shell. This second
    method, using SDL events, will be our preferred method throughout the rest of
    this book.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn more about the game loop and how we will
    use it in our game, as well as games in general.
  prefs: []
  type: TYPE_NORMAL
