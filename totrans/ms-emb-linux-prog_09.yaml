- en: Chapter 9. Starting up - the init Program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I looked at how the kernel boots up to the point that it launches the first
    program, `init`, in [Chapter 4](ch04.html "Chapter 4. Porting and Configuring
    the Kernel"), *Porting and Configuring the Kernel* and in [Chapter 5](ch05.html
    "Chapter 5. Building a Root Filesystem"), *Building a Root Filesystem* and [Chapter
    6](ch06.html "Chapter 6. Selecting a Build System"), *Selecting a Build System*,
    I looked at creating root filesystems of varying complexity, all of which contained
    an `init` program. Now it is time to look at the `init` program in more detail
    and discover why it is so important to the rest of the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many possible implementations of `init`. I will describe the three
    main ones in this chapter: BusyBox `init`, System V `init`, and `systemd`. For
    each one, I will give an overview of how it works and the types of system it suits
    best. Part of that is balancing the trade-off between complexity and flexibility.'
  prefs: []
  type: TYPE_NORMAL
- en: After the kernel has booted
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We saw in [Chapter 4](ch04.html "Chapter 4. Porting and Configuring the Kernel"),
    *Porting and Configuring the Kernel*, how the kernel bootstrap code seeks to find
    a root filesystem, either `initramfs` or a filesystem specified by `root=` on
    the kernel command line, and then to execute a program which, by default, is `/init`
    for `initramfs`, and `/sbin/init` for a regular filesystem. The `init` program
    has root privilege and since it is the first process to run, it has a process
    ID (`PID`) of 1\. If, for some reason, `init` cannot be started, the kernel will
    panic.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `init` program is the ancestor of all other processes, as shown here by
    the `pstree` command, which is part of the `psmisc` package in most distrubutions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The job of the `init` program is to take control of the system and set it running.
    It may be as simple as a shell command running a shell script – there is an example
    at the start of [Chapter 5](ch05.html "Chapter 5. Building a Root Filesystem"),
    *Building a Root Filesystem*—but, in the majority of cases, you will be using
    a dedicated `init` daemon. The tasks it has to perform are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: At boot, it starts daemon programs, configures system parameters and the other
    things needed to get the system into a working state.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optionally, it launches daemons, such as `getty` on terminals which allow a
    login shell.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It adopts processes that become orphaned as a result of their immediate parent
    terminating and there being no other processes in the thread group.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It responds to any of `init`'s immediate children terminating by catching the
    signal `SIGCHLD` and collecting the return value to prevent them becoming zombie
    processes. I will talk more about zombies in [Chapter 10](ch10.html "Chapter 10. Learning
    About Processes and Threads"), *Learning About Processes and Threads*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optionally, it restarts those daemons that have terminated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It handles system shutdown.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In other words, `init` manages the lifecycle of the system, from boot up to
    shutdown. The current thinking is that `init` is well placed to handle other runtime
    events such as new hardware and the loading and unloading of modules. This is
    what `systemd` does.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the init programs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The three `init` programs that you are most likely to encounter in embedded
    devices are BusyBox `init`, System V `init`, and `systemd`. Buildroot has options
    to build all three with BusyBox `init` as the default. The Yocto Project allows
    you to choose between System V `init` and `systemd`, with System `V init` the
    default.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table gives some metrics to compare the three:'
  prefs: []
  type: TYPE_NORMAL
- en: '|   | BusyBox init | System V init | systemd |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Complexity | Low | Medium | High |'
  prefs: []
  type: TYPE_TB
- en: '| Boot-up speed | Fast | Slow | Medium |'
  prefs: []
  type: TYPE_TB
- en: '| Required shell | ash | ash or bash | None |'
  prefs: []
  type: TYPE_TB
- en: '| Number of executables | 0 | 4 | 50(*) |'
  prefs: []
  type: TYPE_TB
- en: '| libc | Any | Any | glibc |'
  prefs: []
  type: TYPE_TB
- en: '| Size (MiB) | 0 | 0.1 | 34(*) |'
  prefs: []
  type: TYPE_TB
- en: (*) Based on the Buildroot configuration of `system`.
  prefs: []
  type: TYPE_NORMAL
- en: Broadly speaking, there is an increase in flexibility and complexity as you
    go from BusyBox `init` to `systemd`.
  prefs: []
  type: TYPE_NORMAL
- en: BusyBox init
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: BusyBox has a minimal `init` program that uses a configuration file, `/etc/inittab`,
    to define rules to start programs at boot up and to stop them at shutdown. Usually,
    the actual work is done by shell scripts which, by convention, are placed in the
    `/etc/init.d` directory.
  prefs: []
  type: TYPE_NORMAL
- en: '`init` begins by reading the configuration file, `/etc/inittab`. This contains
    a list of programs to run, one per line, with this format:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<id>::<action>:<program>`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The role of these parameters is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`id`: The controlling terminal for the command'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`action`: The conditions to run this command, as shown in the following paragraph'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`program`: The program to run'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The actions are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sysinit`: Run the program when `init` starts, before any of the other types
    of actions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`respawn`: Run the program and restart it if it terminates. It is used to run
    a program as a daemon.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`askfirst`: This is the same as `respawn`, but prints the message **Please
    press Enter to activate this console** to the console and runs the program after
    *Enter* has been pressed. It is used to start an interactive shell on a terminal
    without prompting for a user name or password.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`once`: Run the program once but do not attempt to restart it if it terminates.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`wait`: Run the program and wait for it to complete.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`restart`: Run the program when `init` receives the signal `SIGHUP`, indicating
    that it should reload the `inittab` file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ctrlaltdel`: Run the program when `init` receives the signal `SIGINT`, usually
    as a result of pressing *Ctrl* + *Alt* + *Del* on the console.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`shutdown`: Run the program when `init` shuts down.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is a small example that mounts `proc` and `sysfs` and runs a shell on
    a serial interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: For simple projects in which you want to launch a small number of daemons and
    perhaps start a login shell on a serial terminal, it is easy to write the scripts
    manually, and this is appropriate if you are creating a **RYO** (**roll your own**)
    embedded Linux. However, you will find that hand-written `init` scripts rapidly
    become unmaintainable as the number of things to be configured increases. They
    tend not to be very modular and so need updating each time a new component is
    added.
  prefs: []
  type: TYPE_NORMAL
- en: Buildroot init scripts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Buildroot has been making effective use of BusyBox `init` for many years. Buildroot
    has two scripts in `/etc/init.d` named `rcS` and `rcK`. The first one starts at
    boot-up and iterates over all the scripts beginning with a capital `S` followed
    by two digits, and runs them in numerical order. These are the start scripts.
    The `rcK` script is run at shutdown and iterates over all the scripts beginning
    with a capital `K` followed by two digits, and runs them in numerical order. These
    are the kill scripts.
  prefs: []
  type: TYPE_NORMAL
- en: With this in place, it becomes easy for Buildroot packages to supply their own
    start and kill scripts, using the two digit number to impose the order in which
    they should be run, and so the system becomes extensible. If you are using Buildroot,this
    is transparent. If not, you could use it as a model for writing your own BusyBox
    `init` scripts.
  prefs: []
  type: TYPE_NORMAL
- en: System V init
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This `init` program was inspired by the one from UNIX System V, and so dates
    back to the mid 1980s. The version most often found in Linux distributions was
    written initially by Miquel van Smoorenburg. Until recently, it was considered
    the way to boot Linux, obviously including embedded systems, and BusyBox `init`
    is a trimmed down version of System V `init`.
  prefs: []
  type: TYPE_NORMAL
- en: Compared to BusyBox `init`, System V `init` has two advantages. Firstly, the
    boot scripts are written in a well-known, modular format, making it easy to add
    new packages at build time or runtime. Secondly, it has the concept of runlevels,
    which allow a collection of programs to be started or stopped in one go, by switching
    from one runlevel to another.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are 8 runlevels numbered from 0 to 6, plus S:'
  prefs: []
  type: TYPE_NORMAL
- en: '**S**: Single user mode'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**0**: Halt the system'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**1 to 5**: General use'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**6**: Reboot the system'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Levels 1 to 5 can be used as you please. On desktop Linux distributions, they
    are conventionally assigned as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**1**: Single user'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**2**: Multi-user with no network configuration'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**3**: Multi-user with network configuration'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**4**: Not used'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**5**: Multi-user with graphical login'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `init` program starts the default `runlevel` given by the `initdefault`
    line in `/etc/inittab`. You can change the runlevel at runtime using the command
    `telinit [runlevel]` which sends a message to `init`. You can find the current
    runlevel, and the previous one, by using the `runlevel` command. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'On the first line, the output from `runlevel` is `N 5`, meaning that there
    is no previous runlevel because the `runlevel` has not changed since booting,
    and the current `runlevel` is `5`. After changing the `runlevel`, the output is
    `5 3` showing that there has been a transition from `5` to `3`. The `halt` and
    `reboot` commands switch to runlevels of `0` and `6` respectively. You can override
    the default `runlevel` by giving a different one on the kernel command line as
    a single digit from `0` to `6`, or `S` for single user mode. For example, to force
    the `runlevel` to be for a single user, you would append `S` to the kernel command
    line and it would look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Each runlevel has a number of scripts that stop things, called `kill` scripts,
    and another group that starts things, the `start` scripts. When entering a new
    `runlevel`, `init` first runs the `kill` scripts and then the `start` scripts.
    Running daemons which have neither a `start` script nor a `kill` script in the
    new `runlevel` are sent a `SIGTERM` signal. In other words, the default action
    on switching `runlevel` is to terminate the daemons unless told to do otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: 'In truth, runlevels are not used that much in embedded Linux: most devices
    simply boot to the default `runlevel` and stay there. I have a feeling that it
    is partly because most people are not aware of them.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Runlevels are a simple and convenient way to switch between modes, for example,
    from production to maintenance mode.
  prefs: []
  type: TYPE_NORMAL
- en: System V `init` is an option in Buildroot and the Yocto Project. In both cases,
    the init scripts have been stripped of any bash specifics, so they work with the
    BusyBox ash shell. However, Buildroot cheats by replacing the BusyBox `init` program
    with SystemV `init` and adding `inittab` that mimics the behavior of BusyBox.
    Buildroot does not implement runlevels except that switching to levels 0 or 6
    halts or reboots the system.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's look at some of the details. The following examples are taken from
    the fido version of the Yocto Project. Other distributions may implement the `init`
    scripts a little differently.
  prefs: []
  type: TYPE_NORMAL
- en: inittab
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `init` program begins by reading `/etc/inttab`, which contains entries that
    define what happens at each `runlevel`. The format is an extended version of the
    BusyBox `inittab` that I described in the preceding section, which is not surprising
    because BusyBox borrowed it from System V in the first place!
  prefs: []
  type: TYPE_NORMAL
- en: 'The format of each line in `inittab` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The fields are shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`id`: A unique identifier of up to four characters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`runlevels`: The runlevels for which this entry should be executed. (This was
    left blank in the BusyBox `inittab`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`action`: One of the keywords given as follows.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`process`: The command to run.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The actions are the same as for BusyBox `init`: `sysinit`, `respawn`, `once`,
    `wait`, `restart`, `ctrlaltdel`, and `shutdown`. However, System V `init` does
    not have `askfirst`, which is specific to BusyBox.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, this is the complete `inttab` supplied by the Yocto Project
    target core-image-minimal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The fist entry, `id:5:initdefault`, sets the default `runlevel` to `5`. The
    next entry, `si::sysinit:/etc/init.d/rcS`, runs the script `rcS` at boot up. There
    will be more about this later. A little further on, there is a group of six entries
    beginning with `l0:0:wait:/etc/init.d/rc 0`. They run the script `/etc/init.d/rc`
    each time there is a change in the runlevel: this script is responsible for processing
    the `start` and `kill` scripts. There is an entry for runlevel `S` which runs
    the single-user login program.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Towards the end of `inittab`, there are two entries that run a `getty` daemon
    to generate a login prompt on the devices `/dev/ttyAMA0` and `/dev/tty1` when
    entering runlevels 1 through to 5, thereby allowing you to log on and get an interactive
    shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The device `ttyAMA0` is the serial console on the ARM Versatile board we are
    emulating with QEMU, it will be different for other development boards. Tty1 is
    a virtual console which is often mapped to a graphical screen if you have built
    your kernel with `CONFIG_FRAMEBUFFER_CONSOLE or VGA_CONSOLE`. Desktop Linux usually
    spawns six `getty` processes on virtual terminals 1 to 6, which you can select
    with the key combination *Ctrl* + *Alt* + *F1* through *Ctrl* + *Alt* + *F6*,
    with virtual terminal 7 reserved for the graphical screen. Virtual terminals are
    seldom used on embedded devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'The script `/etc/init.d/rcS` that is run by the `sysinit` entry does little
    more than enter runlevel `S`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Hence, the first run level entered is `S`, followed by the default `runlevel`
    of `5`. Note that `runlevel` `S` is not recorded and is never displayed as a prior
    runlevel by the `runlevel` command.
  prefs: []
  type: TYPE_NORMAL
- en: The init.d scripts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Each component that needs to respond to a `runlevel` change has a script in
    `/etc/init.d` to perform that change. The script should expect two parameters:
    `start` and `stop`. I will give an example of this later.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `runlevel` handling script, `/etc/init.d/rc`, takes the `runlevel` it is
    switching to as a parameter. For each `runlevel`, there is a directory named `rc<runlevel>.d`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'There you will find a set of scripts beginning with a capital `S` followed
    by two digits and you may also find scripts beginning with a capital `K`. These
    are `start` and `kill` scripts: Buildroot uses the same idea, borrowed from here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: These are in fact symbolic links back to the appropriate script in `init.d`.
    The `rc` script runs all the scripts beginning with a `K` first, adding the `stop`
    parameter , and then runs those beginning with an `S` adding the `start` parameter
    . Once again, the two digit code is there to impart the order in which the scripts
    should run.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a new daemon
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Imagine that you have a program named `simpleserver` which is written as a
    traditional Unix daemon, in other words, it forks and runs in the background.
    You will need an `init.d` script like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '`Start-stop-daemon` is a helper function that makes it easier to manipulate
    background processes such as this. It originally came from the Debian installer
    package, `dpkg`, but most embedded systems use the one from BusyBox. It starts
    the daemon with the `-S` parameter, making sure that there is never more than
    one instance running at any one time and it finds the daemon by name with `-K`
    and sends a signal, `SIGTERM`, by default. Place this script in `/etc/init.d/simpleserver`
    and make it executable.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, add `symlinks` from each of the run levels that you want to run this
    program from, in this case, only the default `runlevel`, `5`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The number `99` means that this will be one of the last programs to be started.
    Bear in mind that there may be other links beginning `S99`, in which case the
    `rc` script will just run them in lexical order.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is rare in embedded devices to have to worry too much about shutdown operations,
    but if there is something that needs to be done, add `kill symlinks` to levels
    0 and 6:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Starting and stopping services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can interact with the scripts in `/etc/init.d` by calling them directly
    with, for example, the `syslog` script which controls the `syslogd` and `klogd`
    daemons:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: All scripts implement `start` and `stop` and should implement `help`. Some implement
    `status` as well, which will tell you whether the service is running or not. Mainstream
    distributions that still use System V `init` have a command named service to start
    and stop services and hide the details of calling the scripts directly.
  prefs: []
  type: TYPE_NORMAL
- en: systemd
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`systemd` defines itself as a system and service manager. The project was initiated
    in 2010 by Lennart Poettering and Kay Sievers to create an integrated set of tools
    for managing a Linux system including an `init` daemon. It also includes device
    management (`udev`) and logging, among other things. Some would say that it is
    not just an `init` program, it is a way of life. It is state of the art, and still
    evolving rapidly. `systemd` is common on desktop and server Linux distributions,
    and is becoming popular on embedded Linux systems too, especially on more complex
    devices. So, how is it better than System V `init` for embedded systems?'
  prefs: []
  type: TYPE_NORMAL
- en: Configuration is simpler and more logical (once you understand it), rather than
    the sometimes convoluted shell scripts of System V `init`, `systemd` has unit
    configuration files to set parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are explicit dependencies between services rather than a two digit code
    that merely sets the sequence in which the scripts are run
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is easy to set the permissions and resource limits for each service, which
    is important for security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`systemd` can monitor services and restart them if needed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are watchdogs for each service and for s`ystemd` itself
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Services are started in parallel, reducing boot time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A complete description of `systemd` is neither possible nor appropriate here.
    As with System V `init`, I will focus on embedded use-cases, with examples based
    on the configuration produced by Yocto Fido, which has `systemd` version 219\.
    I will give a quick overview and then show you some specific examples.
  prefs: []
  type: TYPE_NORMAL
- en: Building systemd with the Yocto Project and Buildroot
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The default `init` in Yocto Fido is System V. To select `systemd`, add these
    lines to your configuration, for example, in `conf/local.conf`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Note that the leading space is important! Then rebuild.
  prefs: []
  type: TYPE_NORMAL
- en: Buildroot has `systemd` as the third `init` option. It requires glibc as the
    C library, and kernel version 3.7 or later with a particular set of configuration
    options enabled. There is a complete list of dependencies in the `README` file
    in the top level of the `systemd` source code.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing targets, services, and units
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before I describe how `systemd init` works, I need to introduce these three
    key concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, a target is a group of services, similar to, but more general than,
    a SystemV `runlevel`. There is a default target which is the group of services
    that are started at boot time.
  prefs: []
  type: TYPE_NORMAL
- en: Secondly, a service is a daemon that can be started and stopped, very much like
    a SystemV `service`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a unit is a configuration file that describes a `target`, a `service`,
    and several other things. Units are text files that contain properties and values.
  prefs: []
  type: TYPE_NORMAL
- en: You can change states and find out what is going on by using the `systemctl`
    command.
  prefs: []
  type: TYPE_NORMAL
- en: Units
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The basic item of configuration is the unit file. Unit files are found in three
    different places:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/etc/systemd/system`: Local configuration'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/run/systemd/system`: Runtime configuration'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/lib/systemd/system`: Distribution-wide configuration'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When looking for a unit, `systemd` searches the directories in that order, stopping
    as soon as it finds a match, allowing you to override the behavior of a distribution-wide
    unit by placing a unit of the same name in `/etc/systemd/system`. You can disable
    a unit completely by creating a local file that is empty or linked to `/dev/null`.
  prefs: []
  type: TYPE_NORMAL
- en: 'All unit files begin with a section marked `[Unit]` which contains basic information
    and dependencies, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Unit dependencies are expressed though `Requires`, `Wants`, and `Conflicts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Requires`: A list of units that this unit depends on, which is started when
    this unit is started'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Wants`: A weaker form of `Requires`: the units listed are started but the
    current unit is not stopped if any of them fail'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Conflicts`: A negative dependency: the units listed are stopped when this
    one is started and, conversely, if one of them is started, this one is stopped'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Processing the dependencies produces a list of units that should be started
    (or stopped). The keywords `Before` and `After` determine the order in which they
    are started. The order of stopping is just the reverse of the start order:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Before`: This unit should be started before the units listed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`After`: This unit should be started after the units listed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following example, the `After` directive makes sure that the web server
    is started after the network:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In the absence of `Before` or `After` directives, the units will be started
    or stopped in parallel with no particular ordering.
  prefs: []
  type: TYPE_NORMAL
- en: Services
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A service is a daemon that can be started and stopped, equivalent to a System
    V `service`. A service is a type of unit file with a name ending in `.service`,
    for example, `lighttpd.service`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A service unit has a `[Service]` section that describes how it should be run.
    Here is the relevant section from `lighttpd.service`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: These are the commands to run when starting the service and restarting it. There
    are many more configuration points you can add in here, so refer to the man page
    for `systemd.service`.
  prefs: []
  type: TYPE_NORMAL
- en: Targets
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A target is another type of unit which groups services (or other types of unit).
    It is a type of unit that only has dependencies. Targets have names ending in
    `.target`, for example, `multi-user.target`. A target is a desired state, which
    performs the same role as System V runlevels.
  prefs: []
  type: TYPE_NORMAL
- en: How systemd boots the system
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now we can see how `systemd` implements the bootstrap. `systemd` is run by
    the kernel as a result of `/sbin/init` being symbolically linked to `/lib/systemd/systemd`.
    It runs the default target, `default.target`, which is always a link to a desired
    target such as `multi-user.target` for a text login or `graphical.target` for
    a graphical environment. For example, if the default target is `multi-user.target`,
    you will find this symbolic link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The default target may be overridden by passing `system.unit=<new target>`
    on the kernel command line. You can use `systemctl` to find out the default target,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Starting a target such as `multi-user.target` creates a tree of dependencies
    that bring the system into a working state. In a typical system, `multi-user.target`
    depends on `basic.target`, which depends on `sysinit.target`, which depends on
    the services that need to be started early. You can print a graph using `systemctl
    list-dependencies`.
  prefs: []
  type: TYPE_NORMAL
- en: You can also list all the services and their current state using `systemctl
    list-units --type service`, and the same for targets using `systemctl list-units
    --type target`.
  prefs: []
  type: TYPE_NORMAL
- en: Adding your own service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using the same `simpleserver` example as before, here is a service unit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `[Unit]` section only contains a description so that it shows up correctly
    when listed using `systemctl` and other commands. There are no dependencies; as
    I said, it is very simple.
  prefs: []
  type: TYPE_NORMAL
- en: The `[Service]` section points to the executable, and has a flag to indicate
    that it forks. If it were even simpler and ran in the foreground, `systemd` would
    do the daemonizing for us and `Type=forking` would not be needed.
  prefs: []
  type: TYPE_NORMAL
- en: The `[Install]` section makes it dependent on `multi-user.target` so that our
    server is started when the system goes into multi-user mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the unit is saved in `/etc/systemd/system/simpleserver.service`, you can
    start and stop it using the `systemctl start simpleserver` and s`ystemctl stop
    simpleserver` commands. You can use this command to find its current status:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, it will only start and stop on command, as shown. To make it
    persistent, you need to add a permanent dependency to a target. That is the purpose
    of the `[Install]` section in the unit, it says that when this service is enabled
    it will become dependent on `multi-user.target`, and so will be started at boot
    time. You enable it using `systemctl enable`, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can see how dependencies are added at runtime without having to edit
    any unit files. A target can have a directory named `<target_name>.target.wants`
    which can contain links to services. This is exactly the same as adding the dependent
    unit to the `[Wants]` list in the target. In this case, you will find that this
    link has been created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'If this is were an important service you might want to restart if it failed.
    You can accomplish that by adding this flag to the `[Service]` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Restart=on-abort`'
  prefs: []
  type: TYPE_NORMAL
- en: Other options for `Restart` are `on-success`, `on-failure`, `on-abnormal`, `on-watchdog`,
    `on-abort`, or `always`.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a watchdog
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Watchdogs are a common requirement in embedded devices: you need to take action
    if a critical service stops working, usually by resetting the system. On most
    embedded SoCs, there is a hardware watchdog which can be accessed via the `/dev/watchdog`
    device node. The watchdog is initialized with a timeout at boot and then must
    be reset within that period, otherwise the watchdog will be triggered and the
    system will reboot. The interface with the watchdog driver is described in the
    kernel source in `Documentation/watchdog`, and the code for the drivers is in
    `drivers/watchdog`.'
  prefs: []
  type: TYPE_NORMAL
- en: A problem arises if there are two or more critical services that need to be
    protected by a watchdog. `systemd` has a useful feature that distributes the watchdog
    between multiple services.
  prefs: []
  type: TYPE_NORMAL
- en: '`systemd` can be configured to expect a regular keepalive call from a service
    and take action if it is not received, in other words, a per-service software
    watchdog. For this to work, you have to add code to the daemon to send the keepalive
    messages. It needs to check for a non-zero value in the `WATCHDOG_USEC` environment
    variable and then call `sd_notify(false, "WATCHDOG=1")` within that time (a period
    of half of the watchdog timeout is recommended). There are examples in the `systemd`
    source code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To enable the watchdog in the service unit, add something like this to the
    `[Service]` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the service expects a keepalive every 30 seconds. If it fails
    to be delivered, the service will be restarted, but if it is restarted more than
    four times in five minutes, `systemd` will force an immediate reboot. Once again,
    there is a full description of these settings in the `systemd` manual.
  prefs: []
  type: TYPE_NORMAL
- en: 'A watchdog like this takes care of individual services, but what if `systemd`
    itself fails, or the kernel crashes, or the hardware locks up. In those cases,
    we need to tell `systemd` to use the watchdog driver: just add `RuntimeWatchdogSec=NN`
    to `/etc/systemd/system.conf`. `systemd` will reset the watchdog within that period,
    and so the system will reset if `systemd` fails for some reason.'
  prefs: []
  type: TYPE_NORMAL
- en: Implications for embedded Linux
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`systemd` has a lot of features that are useful in embedded Linux, including
    many that I have not mentioned in this brief description such as resource control
    using slices (see the man page for `systemd.slice(5)` and `systemd.resource-control(5)`),
    device management (`udev(7)`) and system logging facilities (`journald(5)`).'
  prefs: []
  type: TYPE_NORMAL
- en: 'You have to balance that with its size: even with a minimal build of just the
    core components, `systemd`, `udevd`, and `journald`, it is approaching 10 MiB
    of storage, including the shared libraries.'
  prefs: []
  type: TYPE_NORMAL
- en: You also have to keep in mind that `systemd` development follows the kernel
    closely, so it will not work on a kernel more than a year or two older than the
    release of `systemd`.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following resource has further information about topics introduced in this
    chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '*systemd system and Service Manager*: [http://www.freedesktop.org/wiki/Software/systemd/](http://www.freedesktop.org/wiki/Software/systemd/)
    (there are a lot of useful links at the bottom of that page)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every Linux device needs an `init` program of some kind. If you are designing
    a system which only has to launch a small number of daemons at startup and remains
    fairly static after that, then BusyBox `init` is sufficient for your needs. It
    is usually a good choice if you are using Buildroot as the build system.
  prefs: []
  type: TYPE_NORMAL
- en: If, on the other hand, you have a system that has complex dependencies between
    services at boot time or runtime, and you have the storage space, then `systemd`
    would be the best choice. Even without the complexity, `systemd` has some useful
    features in the way it handles watchdogs, remote logging, and so on, so you should
    certainly give it a serious thought.
  prefs: []
  type: TYPE_NORMAL
- en: It is hard to make a case for System V `init` on its own merits, since it has
    few advantages over the simple BusyBox `init`. It will live on for a long time
    nevertheless, just because it is there. For example, if you are building using
    the Yocto Project and you decide against `systemd` then System V `init` is the
    alternative.
  prefs: []
  type: TYPE_NORMAL
- en: In terms of reducing boot time, `systemd` is faster than System V `init` for
    a similar workload. However, if you are looking for a very fast boot, nothing
    can beat a simple BusyBox `init` with minimal boot scripts.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter is about one very important process, `init`. In the next chapter,
    I will describe what a process really is, how it relates to threads, how they
    cooperate, and how they are scheduled. Understanding these things is important
    if you want to create a robust and maintainable embedded system.
  prefs: []
  type: TYPE_NORMAL
