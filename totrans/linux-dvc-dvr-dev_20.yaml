- en: Regulator Framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A regulator is an electronic device that supplies power to other devices. Devices
    powered by regulators are called consumers. One said they consume power provided
    by regulators. Most regulators can enable and disable their output and some can
    also control their output voltage or current. The driver should expose those capabilities
    to consumers by means of specific functions and data structures, which we will
    discuss in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The chip that physically provides regulators is called a **Power Management
    Integrated Circuit** (**PMIC** ):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00042.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The Linux regulator framework has been designed to interface and control voltage
    and current regulators. It is divided into four separate interfaces as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A regulator drivers interface for regulator PMIC drivers. The structure of this
    interface can be found in `include/linux/regulator/driver.h` .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A consumer interface for device drivers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A machine interface for board configuration.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A sysfs interface for user space.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the PMIC/producer driver interface, driver methods and data structures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A case study with ISL6271A MIC driver, as well as a dummy regulator for testing
    purpose
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A regulator consumer interface along with its API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regulator (producer/consumer) binding in DT
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PMIC/producer driver interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The producer is the device generating the regulated voltage or current. The
    name of such a device is PMIC and it can be used for power sequencing, battery
    management, DC-to-DC conversion, or simple power switches (on/off). It regulates
    the output power from the input power, with the help of (and under) software control.
  prefs: []
  type: TYPE_NORMAL
- en: 'It deals with regulator drivers, and especially the producer PMIC side, which
    requires a few headers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Driver data structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will start with a short walkthrough of data structures used by the regulator
    framework. Only the producer interface is described in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Description structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The kernel describes every regulator provided by a PMIC by means of a `struct
    regulator_desc` structure, which characterizes a regulator. By regulator, I mean
    any independent regulated output. For example, the ISL6271A from Intersil is a
    PMIC with three independent regulated outputs. There should then be three instances
    of `regulator_desc` in its driver. This structure, which contains the fixed properties
    of a regulator, looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us omit some fields for simplicity reasons. Full structure definition is
    available in `include/linux/regulator/driver.h` :'
  prefs: []
  type: TYPE_NORMAL
- en: '`name` holds the name of the regulator.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`of_match` holds the name used to identify the regulator in DT.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`id` is a numerical identifier for the regulator.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`owner` represents the module providing the regulator. Set this field to `THIS_MODULE`
    .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`type` indicates if the regulator is a voltage regulator or a current regulator.
    It can either be `REGULATOR_VOLTAGE` or `REGULATOR_CURRENT` . Any other value
    will result in a regulator registering failure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`n_voltages` indicates the number of selectors available for this regulator.
    It represents the numerical value that the regulator can output. For fixed output
    voltage, `n_voltages` should be set to 1.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`min_uV` indicates the minimum voltage value this regulator can provide. It
    is the voltage given by the lowest selector.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`uV_step` represents the voltage increase with each selector.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ops` represents the regulator operations table. It is a structure pointing
    to a set of operation callbacks that the regulator can support. This field is
    discussed later.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`irq` is the interrupt number of the regulator.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constraints structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When a PMIC exposes a regulator to consumers, it has to impose some nominal
    limits for this regulator with the help of the `struct regulation_constraints`
    structure. It is a structure gathering security limit of the regulator and defines
    boundaries the consumers cannot cross. It is a kind of a contract between the
    regulator driver and the consumer driver:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us describe each element in the structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '`min_uV` , `min_uA` , `max_uA` , and `max_uV` are the smallest voltage/current
    values that the consumers may set.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`uV_offset` is the offset applied to voltages from the consumer to compensate
    for voltage drops.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`valid_modes_mask` and `valid_ops_mask` respectively are masks of modes/operations
    which may be configured/performed by consumers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`always_on` should be set if the regulator should never be disabled.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boot_on` should be set if the regulator is enabled when the system is initially
    started. If the regulator is not enabled by the hardware or bootloader then it
    will be enabled when the constraints are applied.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`name` is a descriptive name for the constraints used for display purposes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`apply_uV` applies the voltage constraint when initializing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`input_uV` represents the input voltage for this regulator when it is supplied
    by another regulator.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`state_disk` , `state_mem` , and `state_standby` define the state for the regulator
    when the system is suspended in the disk mode, mem mode, or in standby.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`initial_state` indicates the suspended state is set by default.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`initial_mode` is the mode to set at startup.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: init data structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two ways to pass `regulator_init_data` to a driver; this can be done
    by platform data in the board initialization file or by a node in the device tree
    using the `of_get_regulator_init_data` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are the meanings of elements in the structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '`constraints` represents the regulator constraints'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`regulator_init` is an optional callback invoked at a given moment when the
    core registers the regulator'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`driver_data` represents the data passed to `regulator_init`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As one can see, the `struct constraints` structure is part of the `init data`
    . This is explained by the fact that at the initialization of the regulator, its
    constraint is directly applied to it, far before any consumer can use it.
  prefs: []
  type: TYPE_NORMAL
- en: Feeding init data into a board file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This method consists of filling an array of constraints, either from within
    the driver, or in the board file, and using it as part of the platform data. The
    following is the sample based on the device from the case study, the ISL6271A
    from Intersil:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This method is now depreciated, though it is presented here for your information.
    The new and recommended approach is the DT, which is described in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Feeding init data into the DT
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to extract init data passed from within the DT, there is a new data
    type that we need to introduce, `struct of_regulator_match` , which looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Prior to making any use of this data structure, we need to figure out how to
    achieve the regulator binding of a DT file.
  prefs: []
  type: TYPE_NORMAL
- en: Every PMIC node in the DT should have a sub-node named `regulators` , in which
    we have to declare each of the regulators this PMIC provides as a dedicated sub-node.
    In other words, every regulator of a PMIC is defined as a sub-node of the `regulators`
    node, which in turn is a child of the PMIC node in the DT.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are standardized properties you can define in a regulator node:'
  prefs: []
  type: TYPE_NORMAL
- en: '`regulator-name` : This is a string used as a descriptive name for regulator
    outputs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`regulator-min-microvolt` : This is the smallest voltage that consumers may
    set'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`regulator-max-microvolt` : This is the largest voltage consumers may set'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`regulator-microvolt-offset` : This is the offset applied to voltages to compensate
    for voltage drops'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`regulator-min-microamp` : This is the smallest current consumers may set'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`regulator-max-microamp` : This is the largest current consumers may set'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`regulator-always-on` : This is a Boolean value, indicated if the regulator
    should never be disabled'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`regulator-boot-on` : This is a bootloader/firmware enabled regulator'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<name>-supply` : This is a phandle to the parent supply/regulator node'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`regulator-ramp-delay` : This is the ramp delay for the regulator (in uV/uS)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Those properties really look like fields in `struct regulator_init_data` .
    Back with the `ISL6271A` driver, its DT entry could look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Using the kernel helper function `of_regulator_match()` , given the `regulators`
    sub-node as the parameter, the function will walk through each regulator device
    node and build a `struct init_data` structure for each of them. There is an example
    in the `probe()` function, discussed in the driver methods section.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Regulator devices are configured by means of the `struct regulator_config`
    structure, which holds variable elements of the regulator description. This structure
    is passed to the framework when it comes to registering a regulator with the core:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '`dev` represents the struct device structure the regulator belongs to.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`init_data` is the most important field of the structure, since it contains
    an element holding the regulator constraints (a machine specific structure).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`driver_data` holds the regulator''s private data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`of_node` is for DT capable drivers. It is the node to parse for DT bindings.
    It is up to the developer to set this field. It may be `NULL` also.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Device operation structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `struct regulator_ops` structure is a list of callbacks representing all
    operations a regulator can perform. These callbacks are helpers and are wrapped
    by generic kernel functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Callback names explain quite well what they do. There are other callbacks that
    are not listed here, for which you must enable the appropriate mask in `valid_ops_mask`
    or `valid_modes_mask` of the regulator's constraints before the consumer can use
    them. Available operation mask flags are defined in `include/linux/regulator/machine.h`
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, given a `struct regulator_dev` structure, one can get the ID of
    the corresponding regulator by calling the `rdev_get_id()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Driver methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Driver methods consist of `probe()` and `remove()` functions. Please refer to
    the preceding data structure if this section seems unclear to you.
  prefs: []
  type: TYPE_NORMAL
- en: Probe function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `probe` function of a PMIC driver can be split into a few steps, enumerated
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Define an array of `struct regulator_desc` objects for all the regulators provided
    by this PMIC. In this step, you should have defined a valid `struct regulator_ops`
    to be linked to the appropriate `regulator_desc` . It could be the same `regulator_ops`
    for all, assuming they all support the same operations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now in the `probe` function, for each regulator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fetch the appropriate `struct regulator_init_data` either from the platform
    data, which must already contain a valid `struct regulation_constraints` or build
    a `struct regulation_constraints` from DT, in order to build a new `struct regulator_init_data`
    object.
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the previous `struct regulator_init_data` to set up a `struct regulator_config`
    structure. If the driver supports DT, one can make `regulator_config.of_node`
    point to the node used to extract the regulator properties.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Call `regulator_register()` (or the managed version `devm_regulator_register()`
    ) to register the regulator with the core, giving the previous `regulator_desc`
    and `regulator_config` as parameters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A regulator is registered with the kernel using the `regulator_register()`
    function, or `devm_regulator_register()` , which is the managed version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This function returns a data type we have not discussed so far: a `struct regulator_dev`
    object, defined in `include/linux/regulator/driver.h.` That structure represents
    an instance of a regulator device from the producer side (it is different in the
    consumer side). Instances of the `struct regulator_dev` structure should not be
    used directly by anything except the regulator core and notification injection
    (which should take the mutex and not other direct access). That being said, to
    keep track of the registered regulator from within the driver, one should hold
    references for each `regulator_dev` object returned by the registering function.'
  prefs: []
  type: TYPE_NORMAL
- en: Remove function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `remove()` function is where every operation performed earlier during the
    `probe` . Therefore, the essential function you should keep in mind is `regulator_unregister()`
    , when it comes to removing a regulator from the system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This function accepts a pointer to a `struct regulator_dev` structure as a
    parameter. This is another reason a reference for each registered regulator should
    be kept. The following is the `remove` function of the ISL6271A driver:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Case study: Intersil ISL6271A voltage regulator'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As a recall, this PMIC provides three regulator''s devices, among which only
    one can have its output value changed. The two others provide fixed voltages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'First we define ops callbacks, to set up a `struct regulator_desc` :'
  prefs: []
  type: TYPE_NORMAL
- en: 'Callback to handle a `get_voltage_sel` operation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the callback to handle a `set_voltage_sel` operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we are done with the callback definition, we can build a `struct regulator_ops`
    :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: You can ask yourself where the `regulator_list_voltage_linear` and `regulator_list_voltage_linear`
    functions come from. As with many other regulator helper functions, they are also
    defined in `drivers/regulator/helpers.c` . The kernel provides helper functions
    for linear output regulators, as is the case for the ISL6271A.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is time to build an array of `struct regulator_desc` for all regulators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '`LDO1` and `LDO2` have a fixed output voltage. It is why their `n_voltages`
    properties are set to 1, and their ops only provide `regulator_list_voltage_linear`
    mapping.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we are in the `probe` function, the place where we need to build our `struct
    init_data` structures. If you remember, we will use the `struct of_regulator_match`
    introduced previously. We should declare an array of that type, in which we should
    set the `.name` property of each regulator, for which we need to fetch `init_data`
    :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Looking a bit closer, you will notice that the `.name` property is set with
    exactly the same value as the label of the regulator in the device tree. This
    is a rule you should care about and respect.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let us look at the probe function. The ISL6271A provides three regulator
    outputs, which means that the `regulator_register()` function should be called
    three times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '`init_data` can be `NULL` for a fixed regulator. It means that for the ISL6271A,
    only the regulator whose voltage output may change may be assigned an `init_data`
    .'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The preceding driver does not fill every field of the `struct regulator_desc`
    . It greatly depends on the type of device for which we write a driver. Some drivers
    leave the whole job to the regulator core, and only provide the chip's register
    address, which the regulator core needs to work with. Such drivers use **regmap**
    API, which is a generic I2C and SPI register map library. `drivers/regulator/max8649.c`
    is an example.
  prefs: []
  type: TYPE_NORMAL
- en: Driver example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s summarize things discussed previously in a real driver, for a dummy
    PMIC with two regulators, where the first one has a voltage range of 850000 µV
    to 1600000 µV with a step of 50000 µV, and the second regulator has a fixed voltage
    of 1300000 µV:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the module is loaded and the device matched, the kernel will print something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'One can then check what happened under the hood:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '`regulator.13` and `regulator.14` have been added by our driver. Let us now
    check their properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Regulators consumer interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The consumer interface only requires the driver to include one header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'A consumer can be static or dynamic. A static one requires only a fixed supply,
    whereas a dynamic one requires active management of the regulator at runtime.
    From the consumer point side, a regulator device is represented in the kernel
    as an instance of a `struct regulator` structure, defined in `drivers/regulator/internal.h`
    and shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This structure is meaningful enough and does not need us to add any comments.
    To see how easy it is to consume a regulator, here is a little example of how
    a consumer acquires a regulator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Regulator device requesting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Prior to gaining access to a regulator, the consumer has to request the kernel
    by means of the `regulator_get()` function. It is also possible to use the managed
    version, the `devm_regulator_get()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'An example of using this function is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The consumer passes in its `struct device` pointer and power supply ID. The
    core will try to find the correct regulator by consulting the DT or a machine-specific
    lookup table. If we focus only on the device tree, `*id` should match the `<name>`
    pattern of the regulator supply in the device tree. If the lookup is successful
    then this call will return a pointer to the `struct regulator` that supplies this
    consumer.
  prefs: []
  type: TYPE_NORMAL
- en: 'To release the regulator, the consumer driver should call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Prior to calling this function, the driver should ensure that all `regulator_enable()`
    calls made on this regulator source are balanced by `regulator_disable()` calls.
  prefs: []
  type: TYPE_NORMAL
- en: 'More than one regulator can supply a consumer, for example, codec consumers
    with analog and digital supplies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Consumer `probe()` and `remove()` functions are an appropriate place to grab
    and release regulators.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling the regulator device
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Regulator control consists of enabling, disabling, and setting output values
    for a regulator.
  prefs: []
  type: TYPE_NORMAL
- en: Regulator output enable and disable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A consumer can enable its power supply by calling the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This function returns 0 on success. The reverse operation consists of disabling
    the power supply, by calling this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'To check whether a regulator is already enabled or not, the consumer should
    call this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This function returns a value greater than 0 if the regulator is enabled. Since
    the regulator may be enabled early by the bootloader or shared with another consumer,
    one can use the `regulator_is_enabled()` function to check the regulator state.
  prefs: []
  type: TYPE_NORMAL
- en: Here is an example,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'For a shared regulator, `regulator_disable()` will actually disable the regulator
    only when the enabled reference count is zero. That said, you can force disabling
    in case of an emergency, for example, by calling `regulator_force_disable()` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Each of the functions that we will discuss in the sections that follows is actually
    a wrapper around a `regulator_ops` operation. For example, `regulator_set_voltage()`
    internally calls `regulator_ops.set_voltage` after checking the corresponding
    mask allowing this operation is set, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Voltage control and status
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For consumers that need to adapt their power supplies according to their operating
    modes, the kernel provides this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '`min_uV` and `max_uV` are the minimum and maximum acceptable voltages in microvolts.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If called when the regulator is disabled, this function will change the voltage
    configuration so that the voltage is physically set when the regulator is next
    enabled. That said, consumers can get the regulator configured voltage output
    by calling `regulator_get_voltage()` , which will return the configured output
    voltage whether the regulator is enabled or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Here is an example,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Current limit control and status
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What we have discussed in the voltage section also applies here. For example,
    USB drivers may want to set the limit to 500 mA when supplying power.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consumers can control their supply current limit by calling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '`min_uA` and `max_uA` are the minimum and maximum acceptable current limits
    in microamps.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the same way, consumers can get the regulator configured to the current
    limit by calling `regulator_get_current_limit()` , which will return the current
    limit whether the regulator is enabled or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Operating mode control and status
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For efficient power management, some consumers may change the operating mode
    of their supply when their (consumers) operating state changes. Consumer drivers
    can request a change in their supply regulator operating mode by calling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Consumers should use `regulator_set_mode()` on a regulator only when it knows
    about the regulator and does not share the regulator with other consumers. This
    is known as **direct mode** . `regulator_set_uptimum_mode()` causes the core to
    undertake some background work in order to determine what operating mode is best
    for the requested current. This is called the **indirect mode** .
  prefs: []
  type: TYPE_NORMAL
- en: Regulator binding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section only deals with consumer interface binding. Because PMIC binding
    consists of providing `init data` for regulators that this PMIC provides, you
    should refer to the section *Feeding init data into the DT* to understand producer
    binding.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consumer nodes can reference one or more of its supplies/regulators using the
    following bindings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'It is the same principle as PWM consumer binding. `<name>` should be meaningful
    enough, so that the driver can easily refer to it when requesting the regulator.
    That said, `<name>` must match the `*id` parameter of the `regulator_get()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The consumer code (which is the MMC driver) that actually requests its supplies
    could look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the wide range of devices that need to be smartly and smoothly supplied,
    this chapter can be relied on to take care of their power supply management. PMIC
    devices usually sit on SPI or I2C buses. Having already dealt with these buses
    in previous chapters, you should be able to write any PMIC driver. Let's now jump
    to the next chapter, which deals with framebuffer drivers, which is a completely
    different and no less interesting topic.
  prefs: []
  type: TYPE_NORMAL
