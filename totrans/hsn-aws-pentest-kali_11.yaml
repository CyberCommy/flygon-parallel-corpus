- en: Exploiting Permissive S3 Buckets for Fun and Profit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Exploiting S3 buckets doesn't end at reading sensitive information. For instance,
    JavaScript contained in an S3 bucket can be backdoored to affect all users of
    a web application that load an infected JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter goes through the process of exploiting a vulnerable S3 bucket to
    identify JS files that are being loaded by a web application and backdooring them
    to gain pan-user compromise. In addition to this, there is also a focus on identifying
    sensitive credentials and other data secrets stored within the vulnerable S3 buckets
    and using these for achieving further compromise in connected applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Extracting sensitive data from exposed S3 buckets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Injecting malicious code into S3 buckets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Backdooring S3 buckets for persistent access
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extracting sensitive data from exposed S3 buckets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous [Chapter 7](82076ae5-9ec1-4870-9743-3240bc641844.xhtml), *Reconnaissance-Identifying
    Vulnerable S3 Buckets*, we learned how to create a vulnerable bucket by making
    it publicly available. In this chapter, we are going to learn how to identify
    vulnerable buckets and try to extract data from each bucket.
  prefs: []
  type: TYPE_NORMAL
- en: So, once the bucket is set up, we are going to try to attack the vulnerable
    bucket from an outsider's perspective. To achieve this, we will be using the `AWSBucketDump`
    tool. It is a very handy tool that is used to identify vulnerable S3 buckets.
    The `AWSBucketDump` tool is available at the GitHub page [https://github.com/jordanpotti/AWSBucketDump](https://github.com/jordanpotti/AWSBucketDump).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how we can extract sensitive data using `AWSBucketDump`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Git clone the tool and `cd` it into the folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Next, we will have to configure the tool to use a dictionary to brute-force
    and find vulnerable S3 buckets.
  prefs: []
  type: TYPE_NORMAL
- en: Open the `BucketNames.txt` file in any text editor. This file contains a limited
    word list to identify open buckets. However, you can use larger word lists to
    increase your chances of hitting an open bucket.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For demonstration purposes, we will add the `bucket` keyword to the word list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The words here are pretty common, so how do we identify the buckets specific
    to our target organization? We will add the name of the organization as a prefix
    to these words. Since our bucket is named `kirit-bucket`, we will add the word `kirit`as
    a prefix to each word in the word list. To that end, we will use `vim` to make
    our work easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `BucketNames.txt` file in `vim`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'To add the prefix to each word, while inside `vim`, issue the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Save the text file using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an empty file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we run `AWSBucketDump`, we need to ensure all Python dependencies are
    met. For that, there is a text file, `requirements.txt`, which has a list of all
    required Python modules. We simply need to install them. Use the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, it''s time to run `AWSBucketDump`. Issue the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The script will take in the word list and then try to brute-force and find public
    S3 buckets. Any open buckets listed will then be searched for objects using keywords
    in `interesting_Keywords.txt`.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the script output, we can see the open bucket was found by `AWSBucketDump`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e0fb3e95-1399-4a2d-8337-7e121f6c5a0a.png)'
  prefs: []
  type: TYPE_IMG
- en: In the next section, we will see how we can backdoor a vulnerable S3 bucket
    and inject malicious code.
  prefs: []
  type: TYPE_NORMAL
- en: Injecting malicious code into S3 buckets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What happens if a web application is fetching its contents from an S3 bucket
    that has been made publicly writeable? Let's consider a scenario where you have
    a web application that loads all its contents (images, scripts, and so on) from
    an S3 bucket. If incidentally, this bucket has been made public to the world,
    an attacker can upload his malicious `.js` file to the S3 bucket, which will then be rendered
    by the web application.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the purpose of demonstration, we will set up a very basic HTML page that
    links to a JavaScript file hosted on an S3 bucket:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the page calls a `.js` file that is hosted on S3 ([https://s3.us-east-2.amazonaws.com/kirit-bucket/vulnscript.js](https://s3.us-east-2.amazonaws.com/kirit-bucket/vulnscript.js)).
    We already found out how to identify vulnerable S3 buckets. If this bucket is
    vulnerable as well, we can upload our own malicious `vulnscript.js` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the webpage loads next time, it will automatically run our malicious `.js`
    script:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by creating a malicious `.js` script that will pop up an alert, similar
    to an `XSS` attack. For this demonstration, we will use the following Javascript
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Put this in a file and save it with the same name as the file identified earlier
    in the HTML code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the last chapter, we learned how to upload a file using the AWS CLI. Similarly,
    upload your `js` file to the vulnerable bucket:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, visit the web application again, and it will load and render the vulnerable
    script. You should get a typical XSS pop-up alert:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b166bf40-e631-4067-bd09-2cef18bc093c.png)'
  prefs: []
  type: TYPE_IMG
- en: In the next section, we will see how an S3 bucket can be backdoored to compromise
    a user machine.
  prefs: []
  type: TYPE_NORMAL
- en: Backdooring S3 buckets for persistent access
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: S3 buckets can sometimes be left unclaimed. That is, there may be applications
    and/or scripts that make requests to S3 buckets that do not exist.
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate such a scenario, let's assume an S3 bucket URL *(*[http://s3bucket](http://storage.example.com.s3-website.ap-south-1.amazonaws.com/)*.*[example.com.s3-website.ap-south-1.amazonaws.com](http://example.com.s3-website.ap-south-1.amazonaws.com/)).
  prefs: []
  type: TYPE_NORMAL
- en: This URL may be bound to a subdomain (for example, [https://data.example.net](https://storage.example.net/))
    belonging to the organization to obfuscate the AWS S3 URL. This is done by adding
    an alternate domain name (CNAMEs).
  prefs: []
  type: TYPE_NORMAL
- en: However, in the course of time, the bucket bound to the URL, [https://data.example.net](https://data.example.net),
    might be deleted but the CNAMEs record would remain. As a result, an attacker
    could create an S3 bucket with the same name as the unclaimed bucket and upload
    malicious files to be served. When a victim visited the URL, he would be served
    with malicious content.
  prefs: []
  type: TYPE_NORMAL
- en: How do you identify this vulnerability?
  prefs: []
  type: TYPE_NORMAL
- en: 'Look for an error page, which has the message 404 Not Found and has the `NoSuchBucket` message.
    To accomplish that, we can enumerate the subdomains of a particular host and look
    for error pages that say the bucket is not found, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1151afbf-0b19-41a7-be7a-af4edc4699ea.png)'
  prefs: []
  type: TYPE_IMG
- en: Once such an unclaimed bucket has been found, create an S3 bucket with the same
    name and in the same region which had the URL.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Deploy malicious content on the newly created S3 bucket.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When any users of the site try to access the vulnerable URL, malicious content
    from the attacker's bucket is rendered on the victim's site. An attacker can upload
    malware to the bucket that will then be served to the users.
  prefs: []
  type: TYPE_NORMAL
- en: Let's assume a scenario where an application is making calls to an unclaimed
    S3 bucket. The application makes a request for installer files, downloads them,
    and then executes the scripts. If the bucket is left unclaimed, an attacker can
    hijack the bucket and upload malware that will provide him with persistent access.
  prefs: []
  type: TYPE_NORMAL
- en: One such case study can be found in the HackerOne bug bounty program at [https://hackerone.com/reports/399166](https://hackerone.com/reports/399166).
  prefs: []
  type: TYPE_NORMAL
- en: 'As we can see, the script fetches a `.tgz` file from the S3 bucket, extracts
    it, and then executes the file on the victim''s device. An attacker can take advantage
    of this vulnerability and upload a persistent backdoor to the S3 bucket:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/12295081-951b-4f5d-acd9-db61b1ebdc57.png)'
  prefs: []
  type: TYPE_IMG
- en: When a victim runs the script, it will download the `.tgz` file containing the
    malicious script, extract it, and then execute the malware on the victim's computer.
  prefs: []
  type: TYPE_NORMAL
- en: However, it is to be noted that such a vulnerability is highly dependent on
    the script making calls to an unclaimed S3 bucket.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In continuation from the previous chapter, we learned how we can exploit a vulnerable
    S3 bucket. We had a walk-through of `AWSBucketDump` and how it can be used to
    dump data from vulnerable S3 buckets. Further more, we learned how we can exploit
    unclaimed S3 buckets, as well as how we can backdoor and inject malicious code
    in a vulnerable and/or unclaimed S3 bucket.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to pentest AWS Lambda. We will look at
    exploiting vulnerable Lambda instances and learn pots exploitation methods, like
    pivoting from a compromised AWS Lambda.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[https://aws.amazon.com/premiumsupport/knowledge-center/secure-s3-resources/](https://aws.amazon.com/premiumsupport/knowledge-center/secure-s3-resources/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/jordanpotti/AWSBucketDump](https://github.com/jordanpotti/AWSBucketDump)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://hackerone.com/reports/172549](https://hackerone.com/reports/172549)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
