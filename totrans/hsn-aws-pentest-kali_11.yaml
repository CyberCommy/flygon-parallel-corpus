- en: Exploiting Permissive S3 Buckets for Fun and Profit
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Exploiting S3 buckets doesn't end at reading sensitive information. For instance,
    JavaScript contained in an S3 bucket can be backdoored to affect all users of
    a web application that load an infected JavaScript.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: This chapter goes through the process of exploiting a vulnerable S3 bucket to
    identify JS files that are being loaded by a web application and backdooring them
    to gain pan-user compromise. In addition to this, there is also a focus on identifying
    sensitive credentials and other data secrets stored within the vulnerable S3 buckets
    and using these for achieving further compromise in connected applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Extracting sensitive data from exposed S3 buckets
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Injecting malicious code into S3 buckets
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Backdooring S3 buckets for persistent access
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extracting sensitive data from exposed S3 buckets
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous [Chapter 7](82076ae5-9ec1-4870-9743-3240bc641844.xhtml), *Reconnaissance-Identifying
    Vulnerable S3 Buckets*, we learned how to create a vulnerable bucket by making
    it publicly available. In this chapter, we are going to learn how to identify
    vulnerable buckets and try to extract data from each bucket.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: So, once the bucket is set up, we are going to try to attack the vulnerable
    bucket from an outsider's perspective. To achieve this, we will be using the `AWSBucketDump`
    tool. It is a very handy tool that is used to identify vulnerable S3 buckets.
    The `AWSBucketDump` tool is available at the GitHub page [https://github.com/jordanpotti/AWSBucketDump](https://github.com/jordanpotti/AWSBucketDump).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how we can extract sensitive data using `AWSBucketDump`:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: 'Git clone the tool and `cd` it into the folder:'
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Next, we will have to configure the tool to use a dictionary to brute-force
    and find vulnerable S3 buckets.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Open the `BucketNames.txt` file in any text editor. This file contains a limited
    word list to identify open buckets. However, you can use larger word lists to
    increase your chances of hitting an open bucket.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For demonstration purposes, we will add the `bucket` keyword to the word list.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The words here are pretty common, so how do we identify the buckets specific
    to our target organization? We will add the name of the organization as a prefix
    to these words. Since our bucket is named `kirit-bucket`, we will add the word `kirit`as
    a prefix to each word in the word list. To that end, we will use `vim` to make
    our work easier.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `BucketNames.txt` file in `vim`:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To add the prefix to each word, while inside `vim`, issue the following command:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Save the text file using the following command:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Create an empty file:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Before we run `AWSBucketDump`, we need to ensure all Python dependencies are
    met. For that, there is a text file, `requirements.txt`, which has a list of all
    required Python modules. We simply need to install them. Use the following command:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, it''s time to run `AWSBucketDump`. Issue the following command:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The script will take in the word list and then try to brute-force and find public
    S3 buckets. Any open buckets listed will then be searched for objects using keywords
    in `interesting_Keywords.txt`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: 'From the script output, we can see the open bucket was found by `AWSBucketDump`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e0fb3e95-1399-4a2d-8337-7e121f6c5a0a.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
- en: In the next section, we will see how we can backdoor a vulnerable S3 bucket
    and inject malicious code.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Injecting malicious code into S3 buckets
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What happens if a web application is fetching its contents from an S3 bucket
    that has been made publicly writeable? Let's consider a scenario where you have
    a web application that loads all its contents (images, scripts, and so on) from
    an S3 bucket. If incidentally, this bucket has been made public to the world,
    an attacker can upload his malicious `.js` file to the S3 bucket, which will then be rendered
    by the web application.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: 'For the purpose of demonstration, we will set up a very basic HTML page that
    links to a JavaScript file hosted on an S3 bucket:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示目的，我们将设置一个非常基本的HTML页面，链接到托管在S3存储桶上的JavaScript文件：
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you can see, the page calls a `.js` file that is hosted on S3 ([https://s3.us-east-2.amazonaws.com/kirit-bucket/vulnscript.js](https://s3.us-east-2.amazonaws.com/kirit-bucket/vulnscript.js)).
    We already found out how to identify vulnerable S3 buckets. If this bucket is
    vulnerable as well, we can upload our own malicious `vulnscript.js` file.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，页面调用了托管在S3上的.js文件（[https://s3.us-east-2.amazonaws.com/kirit-bucket/vulnscript.js](https://s3.us-east-2.amazonaws.com/kirit-bucket/vulnscript.js)）。我们已经找出了如何识别有漏洞的S3存储桶。如果这个存储桶也有漏洞，我们可以上传我们自己的恶意vulnscript.js文件。
- en: 'When the webpage loads next time, it will automatically run our malicious `.js`
    script:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当下次网页加载时，它将自动运行我们的恶意.js脚本：
- en: 'Start by creating a malicious `.js` script that will pop up an alert, similar
    to an `XSS` attack. For this demonstration, we will use the following Javascript
    code:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先创建一个恶意的.js脚本，弹出一个警报，类似于XSS攻击。为了演示，我们将使用以下Javascript代码：
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Put this in a file and save it with the same name as the file identified earlier
    in the HTML code.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 把它放在一个文件中，并以与在HTML代码中找到的文件相同的名称保存。
- en: 'In the last chapter, we learned how to upload a file using the AWS CLI. Similarly,
    upload your `js` file to the vulnerable bucket:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在最后一章中，我们学习了如何使用AWS CLI上传文件。同样地，将你的js文件上传到有漏洞的存储桶：
- en: '[PRE9]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, visit the web application again, and it will load and render the vulnerable
    script. You should get a typical XSS pop-up alert:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，再次访问Web应用程序，它将加载和呈现有漏洞的脚本。你应该会得到一个典型的XSS弹出警报：
- en: '![](img/b166bf40-e631-4067-bd09-2cef18bc093c.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b166bf40-e631-4067-bd09-2cef18bc093c.png)'
- en: In the next section, we will see how an S3 bucket can be backdoored to compromise
    a user machine.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我们将看到如何在S3存储桶中设置后门，以侵害用户的计算机。
- en: Backdooring S3 buckets for persistent access
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为了持久访问后门S3存储桶
- en: S3 buckets can sometimes be left unclaimed. That is, there may be applications
    and/or scripts that make requests to S3 buckets that do not exist.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: S3存储桶有时可能被遗弃。也就是说，可能存在应用程序和/或脚本向不存在的S3存储桶发出请求。
- en: To demonstrate such a scenario, let's assume an S3 bucket URL *(*[http://s3bucket](http://storage.example.com.s3-website.ap-south-1.amazonaws.com/)*.*[example.com.s3-website.ap-south-1.amazonaws.com](http://example.com.s3-website.ap-south-1.amazonaws.com/)).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这样的情况，让我们假设一个S3存储桶的URL是[http://s3bucket](http://storage.example.com.s3-website.ap-south-1.amazonaws.com/)*.*[example.com.s3-website.ap-south-1.amazonaws.com](http://example.com.s3-website.ap-south-1.amazonaws.com/)。
- en: This URL may be bound to a subdomain (for example, [https://data.example.net](https://storage.example.net/))
    belonging to the organization to obfuscate the AWS S3 URL. This is done by adding
    an alternate domain name (CNAMEs).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这个URL可能绑定到组织的子域（例如[https://data.example.net](https://storage.example.net/)），以混淆AWS
    S3 URL。这是通过添加替代域名（CNAMEs）来实现的。
- en: However, in the course of time, the bucket bound to the URL, [https://data.example.net](https://data.example.net),
    might be deleted but the CNAMEs record would remain. As a result, an attacker
    could create an S3 bucket with the same name as the unclaimed bucket and upload
    malicious files to be served. When a victim visited the URL, he would be served
    with malicious content.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，随着时间的推移，绑定到URL的存储桶[https://data.example.net](https://data.example.net)可能被删除，但CNAME记录仍然存在。因此，攻击者可以创建一个与未认领存储桶同名的S3存储桶，并上传恶意文件以提供服务。当受害者访问URL时，他将得到恶意内容。
- en: How do you identify this vulnerability?
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何识别这个漏洞？
- en: 'Look for an error page, which has the message 404 Not Found and has the `NoSuchBucket` message.
    To accomplish that, we can enumerate the subdomains of a particular host and look
    for error pages that say the bucket is not found, as shown in the following screenshot:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 寻找一个错误页面，上面显示404 Not Found的消息和NoSuchBucket消息。为了实现这一点，我们可以枚举特定主机的子域，并寻找说存储桶未找到的错误页面，如下面的截图所示：
- en: '![](img/1151afbf-0b19-41a7-be7a-af4edc4699ea.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1151afbf-0b19-41a7-be7a-af4edc4699ea.png)'
- en: Once such an unclaimed bucket has been found, create an S3 bucket with the same
    name and in the same region which had the URL.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦发现了这样一个未认领的存储桶，就在与URL相同的地区创建一个同名的S3存储桶。
- en: Deploy malicious content on the newly created S3 bucket.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新创建的S3存储桶上部署恶意内容。
- en: When any users of the site try to access the vulnerable URL, malicious content
    from the attacker's bucket is rendered on the victim's site. An attacker can upload
    malware to the bucket that will then be served to the users.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当网站的任何用户尝试访问有漏洞的URL时，攻击者存储桶中的恶意内容将呈现在受害者的网站上。攻击者可以上传恶意软件到存储桶，然后提供给用户。
- en: Let's assume a scenario where an application is making calls to an unclaimed
    S3 bucket. The application makes a request for installer files, downloads them,
    and then executes the scripts. If the bucket is left unclaimed, an attacker can
    hijack the bucket and upload malware that will provide him with persistent access.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设一个应用程序正在调用一个未被认领的S3存储桶。该应用程序请求安装程序文件，下载它们，然后执行脚本。如果存储桶被遗弃，攻击者可以劫持存储桶并上传恶意软件，从而提供持久访问。
- en: One such case study can be found in the HackerOne bug bounty program at [https://hackerone.com/reports/399166](https://hackerone.com/reports/399166).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在HackerOne的漏洞赏金计划中可以找到这样的案例研究[https://hackerone.com/reports/399166](https://hackerone.com/reports/399166)。
- en: 'As we can see, the script fetches a `.tgz` file from the S3 bucket, extracts
    it, and then executes the file on the victim''s device. An attacker can take advantage
    of this vulnerability and upload a persistent backdoor to the S3 bucket:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，脚本从S3存储桶中获取.tgz文件，解压并在受害者的设备上执行文件。攻击者可以利用这个漏洞上传一个持久的后门到S3存储桶中：
- en: '![](img/12295081-951b-4f5d-acd9-db61b1ebdc57.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12295081-951b-4f5d-acd9-db61b1ebdc57.png)'
- en: When a victim runs the script, it will download the `.tgz` file containing the
    malicious script, extract it, and then execute the malware on the victim's computer.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当受害者运行脚本时，它将下载包含恶意脚本的.tgz文件，解压并在受害者的计算机上执行恶意软件。
- en: However, it is to be noted that such a vulnerability is highly dependent on
    the script making calls to an unclaimed S3 bucket.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: Summary
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[https://github.com/jordanpotti/AWSBucketDump](https://github.com/jordanpotti/AWSBucketDump)'
- en: In continuation from the previous chapter, we learned how we can exploit a vulnerable
    S3 bucket. We had a walk-through of `AWSBucketDump` and how it can be used to
    dump data from vulnerable S3 buckets. Further more, we learned how we can exploit
    unclaimed S3 buckets, as well as how we can backdoor and inject malicious code
    in a vulnerable and/or unclaimed S3 bucket.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，需要注意的是，这种漏洞高度依赖于调用未声明的S3存储桶的脚本。
- en: In the next chapter, we will learn how to pentest AWS Lambda. We will look at
    exploiting vulnerable Lambda instances and learn pots exploitation methods, like
    pivoting from a compromised AWS Lambda.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何对AWS Lambda进行渗透测试。我们将研究如何利用有漏洞的Lambda实例，并学习端口利用方法，比如从受损的AWS Lambda中进行枢轴攻击。
- en: Further reading
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[https://hackerone.com/reports/172549](https://hackerone.com/reports/172549)'
- en: '[https://aws.amazon.com/premiumsupport/knowledge-center/secure-s3-resources/](https://aws.amazon.com/premiumsupport/knowledge-center/secure-s3-resources/)'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在上一章的延续中，我们学习了如何利用有漏洞的S3存储桶。我们进行了`AWSBucketDump`的演示，以及如何使用它来从有漏洞的S3存储桶中转储数据。此外，我们还学习了如何利用未声明的S3存储桶，以及如何在有漏洞和/或未声明的S3存储桶中植入后门和注入恶意代码。
- en: '[https://github.com/jordanpotti/AWSBucketDump](https://github.com/jordanpotti/AWSBucketDump)'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总结
- en: '[https://hackerone.com/reports/172549](https://hackerone.com/reports/172549)'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://aws.amazon.com/premiumsupport/knowledge-center/secure-s3-resources/](https://aws.amazon.com/premiumsupport/knowledge-center/secure-s3-resources/)'
