- en: Collaborating and Communicating across Teams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we discussed previously, the main characteristic of microservices is the
    ability to develop them in parallel. To ensure maximum efficiency, we need to
    coordinate our teams successfully to avoid clashes. In this chapter, we will talk
    about the different elements we need to understand to ensure that the different
    teams work together successfully.
  prefs: []
  type: TYPE_NORMAL
- en: First, we will cover how to get a consistent vision across different microservices,
    how the different communication structures shape communication in the software
    elements, and how to ensure that we don't accumulate cruft in the software. Then,
    we will talk about how to ensure that teams coordinate themselves on releases
    and refine their processes and tools to make them more and more reliable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Keeping a consistent architectural vision
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dividing the workload and Conway's Law
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Balancing new features and maintenance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing a broader release process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, we will know how to structure and coordinate different
    teams that work independently so that we can get the most out of them.
  prefs: []
  type: TYPE_NORMAL
- en: Keeping a consistent architectural vision
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a system structured on microservices, each team is able to perform most of
    the tasks on their own, independently from other teams. Designing the services
    so that they are as independent as possible and with minimal dependencies is key
    to achieving a good development speed.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, microservice separation allows teams to work independently and in
    parallel, while with monoliths, most of the people working on it keep track of
    what goes on, even to the point of being distracted with work out of the field
    of focus of a particular developer. They'll know when a new version is released
    and see new code being added to the same code base they are working on. However,
    that's not the case in the microservices architecture. Here, teams focus on their
    services and are not distracted by other features. This brings clarity and productivity.
  prefs: []
  type: TYPE_NORMAL
- en: However, a global vision of the system is still required. There's a need for
    a long-term view on how the architecture of the system should change over time
    so that it can be adapted. This vision (in monolithic systems) is implicit. Microservices
    need to have a better understanding of these changes so that they can work effectively,
    so a leading architect who can unify this global vision is very important.
  prefs: []
  type: TYPE_NORMAL
- en: The architect's role is a position in the software industry that isn't defined
    consistently.
  prefs: []
  type: TYPE_NORMAL
- en: In this book, we will define it as a role that deals with the structure of APIs
    and services as a whole. Their main objective is to coordinate teams when it comes
    to technical issues, rather than dealing with code directly.
  prefs: []
  type: TYPE_NORMAL
- en: Explicitly naming someone who's responsible for the global architecture of the
    system helps us keep a long-term vision of how the system should evolve.
  prefs: []
  type: TYPE_NORMAL
- en: In small companies, Chief Technical Officers may fulfill the architect's role,
    though they will also be busy handling elements that are related to managerial
    processes and costs.
  prefs: []
  type: TYPE_NORMAL
- en: The main responsibility of a leading architect is to ensure that the microservices
    division keeps making sense as it evolves and that the APIs that communicate between
    services are consistent. They should also try to facilitate the generation of
    standards across teams and share knowledge across the organization.
  prefs: []
  type: TYPE_NORMAL
- en: The architect should also be the final decision maker when it comes to any questions
    regarding what feature goes with what microservice, as well as any other conflicts
    that may arise that involve several teams. This role is of great help during the
    transition from a monolith to a microservice architecture, but after that process
    is completed, they can also ensure that the organization can adapt to new challenges
    and keep technical debt under control. A system working in a microservices architecture
    aims to create independent teams, but they all truly benefit from a shared global
    vision that's created by an external person.
  prefs: []
  type: TYPE_NORMAL
- en: To allow for better coordination, how the teams are divided is highly important.
    Let's learn about some of the challenges that arise when we divide the development
    of a system into different teams.
  prefs: []
  type: TYPE_NORMAL
- en: Dividing the workload and Conway's Law
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Microservice architecture systems are adequate for big software systems, though
    companies tend to start with monolithic applications. This makes sense for any
    system that has small teams. As the system is explored and pivoted, it grows over
    time.
  prefs: []
  type: TYPE_NORMAL
- en: But when monolith systems grow to a certain size, they become difficult to handle
    and develop. The internals become intertwined for historical reasons, and with
    increased complexity, the reliability of the system can become compromised. Finding
    the balance between flexibility and redundancy can be difficult.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that microservices are useful when the development team is big. For
    small teams, a monolith is easier to develop and maintain. It's only when many
    developers work on the same system that dividing the work and accepting the overheads
    of a microservice architecture makes sense.
  prefs: []
  type: TYPE_NORMAL
- en: Scaling the development team can become difficult as there will be too much
    old code there, and learning how to navigate through it is difficult and takes
    a lot of time. The developers (the ones who have been around for a long time)
    know what caveats can help, but they become bottlenecks. Increasing the size of
    the team doesn't help because making any change can become complicated. Therefore,
    every new developer needs a lot of training before they can get up to speed and
    be able to successfully work on bug fixes and new features.
  prefs: []
  type: TYPE_NORMAL
- en: Teams also have a natural size limit. Growing beyond that limit can mean having
    to split them into smaller ones.
  prefs: []
  type: TYPE_NORMAL
- en: The size of a team is highly variable, but normally, the 7±2 components are
    considered as a rule of thumb for the ideal number of people who should be in
    a team.
  prefs: []
  type: TYPE_NORMAL
- en: Bigger groups tend to generate smaller groups on their own, but this means there
    will be too many to manage and some may not have a clear focus. It's difficult
    to know what the rest of the team is doing.
  prefs: []
  type: TYPE_NORMAL
- en: Smaller teams tend to create overhead in terms of management and inter-team
    communication. They'll develop faster with more members.
  prefs: []
  type: TYPE_NORMAL
- en: In a big monolith system, multiple independent teams will tend to mess around
    without a clear long-term view. This may be alleviated by designing a robust internal
    structure, but it will require huge up-front planning and strong policing to ensure
    it is being followed.
  prefs: []
  type: TYPE_NORMAL
- en: The microservice architecture is a design that tackles these problems as it
    makes very strict boundaries between parts of the system. However, doing so requires
    the development team to be of a certain size so that they can work as several
    small teams working mostly independently. This is the main characteristic of a
    microservice architecture system. Each of the microservices that form it is an
    independent service that can be developed and released independently.
  prefs: []
  type: TYPE_NORMAL
- en: This way of working allows teams to work in parallel, without any interference.
    Their realm of action is clear, and any dependency is explicitly set. Due to this,
    the borders between the microservices are strong.
  prefs: []
  type: TYPE_NORMAL
- en: Just because a microservice is released independently doesn't imply that a single
    release is enough to release a full feature. As we've already seen, sometimes,
    a feature in a microservice requires that another microservice is worked on before
    it can be deployed. In this case, several microservices need to be worked on.
  prefs: []
  type: TYPE_NORMAL
- en: The most important idea to keep in mind when planning on how to divide teams
    is how the team's structure is reflected in software. This is described by Conway's
    Law.
  prefs: []
  type: TYPE_NORMAL
- en: Describing Conway's Law
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Conway''s Law is a software adage ([https://www.nagarro.com/en/blog/post/76/microservices-revisiting-conway-s-law](https://www.nagarro.com/en/blog/post/76/microservices-revisiting-conway-s-law)).
    In other words, in any organization that produces software, the software will
    replicate the communication structure of the organization. For example, in a very
    simplified way, an organization is divided in two departments: purchases and sales.
    This will generate two software blocks: one that''s focused on buying and another
    that''s focused on selling. They will communicate when required.'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will talk about *software units*. This is a generic term
    that describes any software that's treated as a single cohesive element. It can
    be a module, a package, or a microservice.
  prefs: []
  type: TYPE_NORMAL
- en: In the microservice architecture, these software units are mainly microservices,
    but in some cases, there can be other types. We will see examples of this in the
    *Dividing the software into different kinds of software units* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'This may be unsurprising. It''s only natural that communication levels are
    different between teams, as well as within the same team. However, the implications
    of teamwork are enormous, some of which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Inter-team APIs are more expensive than intra-team APIs, both in terms of operating
    them as well as developing them since their communication is more complicated.
    It makes sense to make them generic and flexible so that they can be reused.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the communication structures replicate the human organization, it makes sense
    to be explicit. Inter-team APIs should be more visible, public, and documented
    than intra-team APIs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When designing systems, dividing them across the lines of the layered team structure
    is the path of least resistance. Engineering them any other way would require
    organizational changes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the other hand, changing the structure of an organization is a difficult
    and painful process. Anyone that has gone through a reorg knows this. The change
    will be reflected in the software, so plan accordingly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Having two teams working on the same software unit will create problems because
    each one will try to pull it to their own goals.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The owner of a software unit should be a single team. This shows everyone who's
    responsible for who has the final say on any change and helps us focus on our
    vision and reduce technical debt.
  prefs: []
  type: TYPE_NORMAL
- en: Different physical locations impose communications restrictions, such as time
    differences, which will produce barriers when we're developing software across
    them. It is common to split teams by location, which creates the need to structure
    the communication (and therefore the APIs) between these teams.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that the DevOps movement is related to Conway's Law. The traditional way
    of dividing the work was to separate the software being developed from how it's
    run. This created a gap between both teams, as described by Conway's Law, which
    generates problems related to a lack of understanding between the two teams.
  prefs: []
  type: TYPE_NORMAL
- en: The reaction to this problem was to create teams that could develop and operate
    their own software, as well as deploy it. This is called DevOps. It shifted the
    operational problems to the development team with the aim of creating a feedback
    loop to incentivize, understand, and fix them.
  prefs: []
  type: TYPE_NORMAL
- en: Conway's Law is not a bad thing to overcome. It's a reflection that any organizational
    structure has an impact on the structure of software.
  prefs: []
  type: TYPE_NORMAL
- en: Remembering this may help us design the system so that the communication flow
    makes sense for the organization and existing software.
  prefs: []
  type: TYPE_NORMAL
- en: One of the key components of the DevOps movement was advancing the technology
    that built systems in order to simplify how production environments operated so
    that the deployment process was simpler. This allows us to structure teams in
    new ways, thereby leading to multiple teams being able to take control of releases.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's talk about how the software can be structured into different divisions.
  prefs: []
  type: TYPE_NORMAL
- en: Dividing the software into different kinds of software units
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While the main objective of this book is to talk about the division of software
    in microservices, this isn't the only possible division. Other divisions can include
    modules inside a microservice or a shared package.
  prefs: []
  type: TYPE_NORMAL
- en: The main characteristic of a microservice is that it is independent in terms
    of development and deployment, so full parallelization can be achieved. Other
    divisions may reduce this and introduce dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Ensure that you justify these changes.
  prefs: []
  type: TYPE_NORMAL
- en: In the example system that we introduced in this book, we introduced a module
    that verifies that a request is signed by a user. The Users Backend generates
    a signed header and the Thoughts Backend and Frontend verify it independently
    through the `token_validation.py` module.
  prefs: []
  type: TYPE_NORMAL
- en: This module should be owned by the same team that owns the Users Backend since
    it's a natural extension of it. We need to verify that it generates the same tokens
    that the Users Backend generates.
  prefs: []
  type: TYPE_NORMAL
- en: The best way to avoid duplication and to keep it always in sync is to generate
    a Python package that can be installed on the dependent microservices. Then, the
    packages can be treated like any other external dependency in the `requirements.txt`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: To package a library in Python, we can use several tools, including those in
    the official *Python Packaging User Guide* ([https://packaging.python.org/](https://packaging.python.org/))
    to newer tools such as Poetry ([https://poetry.eustace.io](https://poetry.eustace.io)),
    which are easier to use for a new project.
  prefs: []
  type: TYPE_NORMAL
- en: The package can be uploaded to PyPI if we want it to be publicly available.
    Alternatively, we can upload it to a private repository either using a tool such
    as Gemfury or by hosting our own repository if required. This makes an explicit
    division between the package and its maintainers, as well as the teams that are
    using it as a dependency.
  prefs: []
  type: TYPE_NORMAL
- en: Dividing the software units has implications in terms of team division. Now,
    let's take a look at how to structure teams.
  prefs: []
  type: TYPE_NORMAL
- en: Designing working structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Taking Conway's Law into account, dividing the software should reflect how the
    organization is structured. This is very relevant when we're migrating from a
    monolith to a microservice architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Remember, moving from a monolith to a microservice is a big change in terms
    of how we operate. It is as much an organizational change as it is a technology
    change. The main risks are in the human component, including challenges such as
    training people to use the new technologies and keeping the developers happy with
    the new area they'll be working in.
  prefs: []
  type: TYPE_NORMAL
- en: Making a radical change to the organization's structure can be very difficult,
    but small tweaks will be required. When making a big change when migrating from
    a monolith to a microservice, the teams will need to be restructured.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that a big reorg has the potential of getting people angry and
    causing political problems. Humans don't like change, and any decision needs to
    make sense. Expect to have to explain and clarify this move. Having clear objectives
    regarding what to achieve with the new structure will help give it purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at some examples of team divisions, as well as their pros
    and cons.
  prefs: []
  type: TYPE_NORMAL
- en: Structuring teams around technologies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In some cases, different skills related to technology may be relevant. Some
    parts of the system may deal with a technology that's totally different from anything
    else.
  prefs: []
  type: TYPE_NORMAL
- en: A very good example is mobile applications since they are restrictive in terms
    of the languages they use (Java for Android and Objective-C or Swift for iOS).
    An application with a website and a mobile app may require a specific team to
    work on the mobile app's code.
  prefs: []
  type: TYPE_NORMAL
- en: A more traditional example is the database team, which was built around **Database
    Administrators** (**DBAs**). They would control access to databases and operate
    them to keep them in good shape. This structure is disappearing, though, since
    database operations are now easier and typically handled by most developers, and
    the infrastructure management for databases has been greatly simplified in recent
    years.
  prefs: []
  type: TYPE_NORMAL
- en: This may allow us to justify creating specific teams around certain areas. The
    technology's barriers ensure that the communication between systems is structured.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram is an example of the kinds of teams we''ll come across.
    They''re grouped by technology and how they''ll communicate. The database team
    will communicate with the team that''s creating the web service backend, and they
    will communicate with the web and mobile teams:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f2a3000e-94ae-4c8a-8744-f1ba624daa79.png)'
  prefs: []
  type: TYPE_IMG
- en: The main disadvantage of this model is that new features are likely to require
    multiple teams to work on them. Any change that's made to customer-facing code
    so that we can store a new value in the database requires work input from every
    team. These features require extra coordination, which can limit the speed of
    development.
  prefs: []
  type: TYPE_NORMAL
- en: Structuring teams around domains
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another structure is the one that surrounds different knowledge domains and
    is typically related to business areas in the company. Each knowledge domain has
    its own self-contained system, but they communicate with each other. Some parts
    may have an externally accessible interface, while others may not.
  prefs: []
  type: TYPE_NORMAL
- en: This kind of structure is typically found in established organizations that
    have different areas that they have been working successfully for years.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, an online retailer may be structured in three areas:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sales**: Handles the external website and marketing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Inventory**: Purchases the merchandise so that it can be sold, and also handles
    stock.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Shipping**: Delivers the product to the customers. The tracking information
    is displayed on the website.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this case, each area has its own database so that it can store the relevant
    data and its service. They communicate with each other with defined APIs, and
    the most frequent changes happen within a domain. This allows for quick releases
    and development within the domains.
  prefs: []
  type: TYPE_NORMAL
- en: Having new features across domains is also possible. For example, a change in
    the tracking information for shipping may require us to match the changes that
    are produced by sales. However, these changes should happen less often.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, each of the teams will communicate with each other, as shown
    in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fb8f03de-ec6a-4a07-a0d0-d80b85237018.png)'
  prefs: []
  type: TYPE_IMG
- en: The main inconvenience of this structure is the possibility of creating isolated
    teams and a silo mentality. Each system has its own way of doing things, so they
    can diverge to the point of not sharing the same basic language. When a cross-domain
    feature is required, it can lead to discussion and friction.
  prefs: []
  type: TYPE_NORMAL
- en: Structuring teams around customers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In some organizations, the main objective is to create custom work for customers.
    Maybe the customers need to integrate with the product in custom B2B ways. Being
    able to develop and run custom code is critical in this scenario.
  prefs: []
  type: TYPE_NORMAL
- en: The structure is focused on customers. Three teams (called red, gold, and blue)
    are assigned to customers and maintain a special service for each of them, including
    their custom code. Each customer team handles a couple of customers. Another team
    handles the product's backend, which contains the common code and infrastructure
    for the system. This team works separately from the customers but adds features
    from the customer teams when they are shared so that they're included in the product.
    General improvements are also shared.
  prefs: []
  type: TYPE_NORMAL
- en: This creates two speeds in the organization. The customer teams are focused
    on the short-term demands of customers, while the product team is focused on the
    long-term demands of customers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, the product team will talk to the customer teams, but the customer teams
    won''t talk to each other that much. This is shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b45dc095-4b93-4176-8c33-1f04b767ad87.png)'
  prefs: []
  type: TYPE_IMG
- en: This structure works well for highly customized services so that they can contain
    the code that's been generated for a single customer that could make them lose
    focus on the general product. The main problem here is the high pressure that
    the customer teams may face as they are exposed to demanding customers, and that
    can be taxing for developers. The product team needs to ensure that they are making
    useful additions to the product and reducing their long-term problems as much
    as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Structuring teams around a mix
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous three examples are synthetic use cases. Real life is more complicated
    and may require a mix of all of them, or a new structure altogether.
  prefs: []
  type: TYPE_NORMAL
- en: If the organization is big enough, there may be dozens of different teams and
    software units. Remember that a single team can handle more than one software
    unit if it is big enough. However, two teams shouldn't own the same software unit
    in order to avoid ownership and a lack of focus.
  prefs: []
  type: TYPE_NORMAL
- en: Analyze the flow of communication in your organization in order to understand
    the pain points to address when you're moving to microservices and be sure that
    the human structure is taking designing the microservices and software units into
    account.
  prefs: []
  type: TYPE_NORMAL
- en: Another important element for teams is to find a proper balance between time
    that's spent on adding new features and time maintaining the existing code.
  prefs: []
  type: TYPE_NORMAL
- en: Balancing new features and maintenance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Every software service requires maintenance so that it stays in good shape,
    but don''t add evident external value. Maintenance tasks are critical for good
    operation, though, and can be divided into two categories: regular maintenance
    and managing technical debt.'
  prefs: []
  type: TYPE_NORMAL
- en: Technical debt is the one that will use most of the time and requires further
    discussion, but before that, let's take a look at regular maintenance.
  prefs: []
  type: TYPE_NORMAL
- en: Regular maintenance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This kind of maintenance comes in the shape of tasks that are inherent to the
    nature of a software service. By running a service that depends on other components,
    such as underlying operative systems or the Python interpreter, we need to keep
    them up to date and upgrade them to new versions.
  prefs: []
  type: TYPE_NORMAL
- en: In the context of using containers and Kubernetes, there are two systems that
    act as operating systems that we need to take into account. One is the OS from
    the containers; here, we used Alpine. The other is the OS that handles the Kubernetes
    nodes, in which AWS EKS is handled automatically, but needs to be upgraded to
    the Kubernetes version.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main reasons to keep the dependencies up to date are as follows, in their
    order of importance:'
  prefs: []
  type: TYPE_NORMAL
- en: New versions fix security problems.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: General performance improvements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New features can be added that enable new functionality.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These kinds of tasks can be mitigated if we plan for them. For example, using
    a version of the operative system labeled **Long-Term Support** (**LTS**) can
    reduce problems when it comes to updating the system.
  prefs: []
  type: TYPE_NORMAL
- en: An LTS version of an OS is a version that receives support and critical updates
    during a long cycle. For example, a regular Ubuntu version is released every 6
    months and receives updates (including critical security updates) for 9 months.
    LTS versions are released every 2 years and receive support for 5 years.
  prefs: []
  type: TYPE_NORMAL
- en: When running services, it is recommended to use LTS versions in order to minimize
    required maintenance work.
  prefs: []
  type: TYPE_NORMAL
- en: All of these packages and dependencies need to be updated to ensure that the
    OS works well. The alternative is to have open security holes or be left with
    an outdated system.
  prefs: []
  type: TYPE_NORMAL
- en: Updating dependencies could require us to adapt the code, depending on whether
    parts of it become deprecated or are removed. This can be costly in some cases.
    At the time of writing, the most famous migration has been the upgrade from Python
    2 to Python 3 by the Python community, a task that is taking multiple years.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the upgrades are normally pretty routine and require minimal work, though.
    Try to generate an upgrade plan that keeps pace in a sensible manner and produces
    solid guidelines; for example, rules such as *when a new operative system LTS
    version is released *and *all systems should be migrated in the following 3 months*.
    This produces predictability and gives everyone a clear objective that can be
    followed up and enforced.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous integration tools can help in this process. For example, GitHub automatically
    detects dependencies in files such as `requirements.txt` and notifies us when
    a vulnerability is detected. It's even possible to automatically generate pull
    requests when updating modules. Check out the documentation for more information: [https://help.github.com/en/github/managing-security-vulnerabilities/configuring-automated-security-fixes](https://help.github.com/en/github/managing-security-vulnerabilities/configuring-automated-security-fixes).
  prefs: []
  type: TYPE_NORMAL
- en: 'Upgrading dependencies is probably the most common regular maintenance task,
    but there are other possibilities:'
  prefs: []
  type: TYPE_NORMAL
- en: To clean up or archive old data. These operations can normally be automated,
    saving a lot of time and reducing problems.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To fix operations that are dependent on business processes, such as generating
    monthly reports, and so on. These should be automated when possible, or tools
    should be designed so that users can produce them automatically instead of relying
    on technical staff doing bespoke operations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To fix permanent problems that are produced by bugs or other errors. Bugs sometimes
    leave the system in a bad state; for example, there may be a corrupted entry in
    the database. While the bug is being fixed, we may need to resolve the situation
    by unblocking a process or a user.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These processes can be annoying, especially if they are repetitive, but are
    normally well understood.
  prefs: []
  type: TYPE_NORMAL
- en: The other form of maintenance, which deals with technical debt, is more complicated,
    as it is introduced more gradually and is more difficult to detect clearly. Properly
    addressing technical debt is the most challenging maintenance task, but before
    we can do anything, we need to understand it.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding technical debt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Technical debt is a concept that's used in software development to describe
    additional costs that will be added in the future when a non-optimal solution
    is implemented. In other words, choosing the quick or easy choice means later
    features take longer and are more difficult to develop.
  prefs: []
  type: TYPE_NORMAL
- en: As a metaphor, technical debt has been around since the early 90s, but the concept
    has been described before then.
  prefs: []
  type: TYPE_NORMAL
- en: Like any metaphor, it is useful, but it has limits. In particular, non-technical
    people tend to associate it with financial debt, even though they have different
    implications. For example, most technical debt is created without us even noticing
    it. Make sure that you don't take the metaphor too far.
  prefs: []
  type: TYPE_NORMAL
- en: Technical debt is unavoidable to a certain degree. There's no infinite time
    to research all the possibilities before implementing a feature and there's no
    perfect information at the time of making any decision. It is also a consequence
    of entropy growth in any complex system.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from being unavoidable, it can also be a deliberate choice. Development
    is constrained by time, so an imperfect quick solution to market may be preferable
    to missing a deadline.
  prefs: []
  type: TYPE_NORMAL
- en: Another sign of technical debt is concentrating on certain knowledge. In any
    case, technical debt keeps piling up over time, and this creates friction for
    new features. Complexity increases can also create reliability problems as bugs
    will be more and more difficult to understand and fix.
  prefs: []
  type: TYPE_NORMAL
- en: Simplicity is the best friend of reliable systems. Simple code is easy to understand
    and correct and makes bugs either obvious or quick to detect. The microservice
    architecture aims to reduce the inherent complexity of a monolith by creating
    independent services that are smaller and have clear responsibilities assigned
    to them and that create explicit interfaces across them.
  prefs: []
  type: TYPE_NORMAL
- en: Technical debt can grow to a point where a big architecture is required. We've
    seen how moving from a monolith into a microservices architecture could be one
    of these moments.
  prefs: []
  type: TYPE_NORMAL
- en: An architectural migration such as this is a big effort and will require time
    to deliver. New microservices that are reproducing the features that already exist
    in the monolith may conflict with new features being introduced.
  prefs: []
  type: TYPE_NORMAL
- en: This creates a moving target effect that can be very disruptive. Ensure that
    you identify these conflicting points and try to minimize them in your migration
    plan. Some new features may be able to be delayed until the new microservice is
    ready, for example.
  prefs: []
  type: TYPE_NORMAL
- en: However, instead of waiting until the technical debt is so big that only radical
    changes are good enough to address it, we need to be able to tackle technical
    debt earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Continuously addressing technical debt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Decreasing technical debt needs to be a continuous process and one that's introduced
    into the day-to-day operation of things. Agile techniques, which focus on continuous
    improvement, try to introduce this kind of mentality.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting technical debt will typically come from within the development team
    since they are the ones closer to the code. Teams should be thinking about where
    operations could be smoother and have reserved time to perform those improvements.
  prefs: []
  type: TYPE_NORMAL
- en: A great source of information that allows us to detect technical debt is metrics,
    such as the ones we set up in [Chapter 10](ca9b0606-730a-4006-a575-de8e897a19ba.xhtml),
    *Monitoring Logs and Metrics*.
  prefs: []
  type: TYPE_NORMAL
- en: The risk of neglecting to fix these issues is to fall into software rot when
    already existing features are slowly getting slower and less reliable. Over time,
    they'll be more and more obvious to customers and external partners. Way before
    that, working in this kind of environment will make a developer's life difficult,
    and there's a risk of burnout. Delays in new developments will also be common
    as code will be inherently difficult to work with.
  prefs: []
  type: TYPE_NORMAL
- en: To avoid getting into this situation, time needs to be allocated to reduce technical
    debt in a continuous fashion, intercalated with new features and other work. A
    balance should be found between maintenance and technical debt reduction and new
    features.
  prefs: []
  type: TYPE_NORMAL
- en: A lot of the techniques we've talked about in this book help us improve the
    system in a continuous fashion, from the continuous integration techniques we
    described in [Chapter 4](872309f3-42ba-493c-8595-af1e610af61a.xhtml), *Creating
    a Pipeline and Workflow*, to the code reviews and approvals that we described
    in [Chapter 8](9a5c53a2-9131-4233-9e4f-992af51d8321.xhtml), *Using GitOps Principles*.
  prefs: []
  type: TYPE_NORMAL
- en: Distribution may be highly dependent on the current shape of the system, but
    it really helps that it is explicit and enforced. Something such as a specific
    time percentage to be spent on technical debt reduction could be helpful.
  prefs: []
  type: TYPE_NORMAL
- en: Reducing technical debt is costly and difficult, so introducing as little as
    possible makes sense.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding technical debt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The best way to deal with technical debt is to not introduce it in the first
    place. However, this is easier said than done. There are multiple elements that
    can affect the quality of the decisions that lead to technical debt.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most common causes are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Lack of a strategic, high-level plan to give direction**: This produces inconsistent
    results because each time the same problem is found, it will be resolved in a
    different way. We talked about how coordination across teams needs to address
    standards across the organization and ensure they are followed. Having someone
    acting as a software architect, looking for creating consistent guidelines across
    the board, should greatly improve this case.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Not having the proper knowledge to choose the right option**: This is quite
    common. Sometimes, the people that need to make a decision don''t have all the
    relevant pieces of information due to miscommunication or simply lack of experience.
    This problem is typical of structures that lack experience in the problems at
    hand. Ensuring that you have a highly trained team and are creating a culture
    where more experienced members help and mentor junior members will reduce these
    cases. Documentation that keeps track of previous decisions and simplifies how
    to use other microservices will help us coordinate teams so that they have all
    the relevant parts of the puzzle. This helps them avoid making mistakes due to
    incorrect assumptions. Another important element is to ensure that teams have
    proper training in the tools they''re using so that they are fully aware of their
    capacities. This should be the case for external tools, such as being skilled
    in Python or SQL, and in any internal tool that requires training materials, documentation,
    and appointed points of contact.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Not spending enough time investigating different options or planning**: This
    problem is created by pressure and by the need to make quick progress. This can
    be ingrained in the organization culture, and slowing down decision-making could
    be a challenging task when the organization grows since smaller organizations
    tend to require a faster process. Documenting the decision process and requiring
    it to be peer-reviewed or approved can help slow this down and ensure that work
    is thorough. It''s important to find a balance in terms of what decisions require
    more scrutiny and which ones don''t. For example, everything that fits neatly
    inside a microservice can be reviewed inside the team, but features that require
    multiple microservices and teams should be reviewed and approved externally. In
    this scenario, finding the proper balance between gathering information and making
    a decision is important. Document the decisions and the inputs so that you understand
    the process that got them there and refine your process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The best way to avoid these problems is to reflect on previous errors and learn
    from mistakes.
  prefs: []
  type: TYPE_NORMAL
- en: Designing a broader release process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While the ability to deploy each microservice independently is really a key
    element of the system, this doesn't mean that no coordination should be required.
  prefs: []
  type: TYPE_NORMAL
- en: First, there are still some features that need to be deployed in multiple microservices.
    We've already looked at how we can work on the development process, including
    details such as handle versioning and checking dependencies explicitly. So what
    now?
  prefs: []
  type: TYPE_NORMAL
- en: In these situations, coordination between teams is required to ensure that the
    dependencies are implemented and that the different deployments are executed in
    an adequate order.
  prefs: []
  type: TYPE_NORMAL
- en: While some coordination can be helped by the leading architect, the architecture
    role should be focused on long-term goals and not short-term releases. A good
    tool to allow self-coordination by teams is to inform the other teams in a meeting
    about releases.
  prefs: []
  type: TYPE_NORMAL
- en: Planning in the weekly release meeting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When the release process is new and migrating from the monolith is still underway,
    it is a good idea to provide insight into every team is doing. A weekly release
    meeting that is attended by representatives of every team can be an excellent
    way of distributing knowledge regarding what is going on in other teams.
  prefs: []
  type: TYPE_NORMAL
- en: 'The objectives for the release meeting should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Planned releases for the next 7 days and rough times for when; for example,we
    plan to release a new version of the Users Backend on Wednesday.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You should provide a heads-up for any important new feature, especially if other
    teams can use it. For example, if the new version improves authentication, make
    sure that you redirect your teams to the new API so that they can get these improvements
    as well.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: State any blockers. For example, we can't release this version until the Thoughts
    Backend releases their version with feature A.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Raise any flags if there's critical maintenance or any changes that could affect
    the releases. For example, on Thursday morning, we need to do database maintenance,
    so please don't release anything until 12 o'clock. We will send an email when
    the work is done.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Review the release problems that happened the week prior. We'll talk about this
    in more detail later.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is similar to the usual standup meetings that are present in many agile
    practices, such as SCRUM, but focused on releases. To be able to do this, we need
    to specify when the release is happening in advance.
  prefs: []
  type: TYPE_NORMAL
- en: Given the asynchronous nature of microservices releases, and as continuous integration
    practices are implemented and speed up this process, there will be a lot of routine
    releases that won't be planned with that much time in advance. This is fine and
    means that the release process is being refined.
  prefs: []
  type: TYPE_NORMAL
- en: Try to plan a bit in advance when it comes to riskier releases and use the release
    meeting to communicate with the rest of the teams effectively. The meeting is
    a tool that keeps the conversation open.
  prefs: []
  type: TYPE_NORMAL
- en: Over time, as continuous integration practices become more and more established
    and the releases become quicker and quicker, the weekly release meeting will slowly
    become less and less important, to the point that it may not need to be done anymore –
    at least not as regularly. This is part of reflecting on practices for continuous
    improvement, which is also achieved by identifying release problems.
  prefs: []
  type: TYPE_NORMAL
- en: Reflecting on release problems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Not every release will go perfectly fine. Some will fail due to problems in
    the tools or infrastructure, or maybe because there's a mistake in the process
    that's easy to make. The fact is that some releases will have issues. Unfortunately,
    it's not possible to avoid these situations.
  prefs: []
  type: TYPE_NORMAL
- en: To reduce and minimize release issues over time, each time a problem is found,
    it needs to be documented and brought up in the weekly release meeting or in an
    equivalent forum.
  prefs: []
  type: TYPE_NORMAL
- en: Some problems will be minor and require only a bit of extra work for the release
    to be successful; for example, a misconfiguration that avoids the new release
    from being started until it's fixed or a coordination problem where one service
    is deployed before its dependency.
  prefs: []
  type: TYPE_NORMAL
- en: Other problems will be greater, maybe even causing an outage due to a problem.
    Here, rollbacks will be useful so that we can quickly go back to a known state
    and plan again.
  prefs: []
  type: TYPE_NORMAL
- en: In any case, they should be properly documented, even if this is just briefly,
    and then shared so that the process can be refined. Analyzing what went wrong
    is key to keep improving your releases so that they're faster and less complicated.
  prefs: []
  type: TYPE_NORMAL
- en: Be open about these problems. Creating a culture where problems are openly debated
    and acknowledged is important if you wish to detect every single problem and quickly
    assess solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Capturing problems is not, and should never be, about assigning blame. It's
    the organization's responsibility to detect and correct problems.
  prefs: []
  type: TYPE_NORMAL
- en: If this happens, not only will the environment become less attractive to work
    in, but problems will be hidden by teams so that they don't get blamed.
  prefs: []
  type: TYPE_NORMAL
- en: Unaddressed problems tend to be multiplicative, so reliability will suffer greatly.
  prefs: []
  type: TYPE_NORMAL
- en: Being able to release uneventfully is critical for quick deployments and to
    increase speed. Only light documentation is required when we're dealing with these
    kinds of problems since they are normally mild and, in the worst case, delay a
    release for a day or two.
  prefs: []
  type: TYPE_NORMAL
- en: For bigger problems, when the external service is disrupted, it's better to
    have a more formal process to ensure that the problem is fixed properly.
  prefs: []
  type: TYPE_NORMAL
- en: Another way we can improve the process is to properly understand the causes
    of problems that interrupt the service in live systems. The most effective tools
    for this are post-mortem meetings.
  prefs: []
  type: TYPE_NORMAL
- en: Running post-mortem meetings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Not limited to releases, sometimes, there will be big events that interrupt
    the service and need major work so that they can be fixed. In these emergency
    situations, the first objective is to recover the service as soon as possible.
  prefs: []
  type: TYPE_NORMAL
- en: After the service is stable again, to learn from this experience and to avoid
    it happening again, a post-mortem meeting should be attended by everyone that
    was involved in the incident. The objective of the post-mortem meeting is to create
    a series of follow-up tasks from the lessons that were learned during the emergency.
  prefs: []
  type: TYPE_NORMAL
- en: 'To document this, you need to create a template. This will be filled in during the
    post-mortem meeting. The template should capture the following information:'
  prefs: []
  type: TYPE_NORMAL
- en: '**What problem was detected?** Include how it was detected if this isn''t evident;
    for example, the website was down and was returning 500 errors. This shows that
    there was an increase in errors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**When did it start and finish?** A timeline of the incident; for example, Thursday
    from 3PM to 5PM.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Who was involved in remediating the incident?** Either detecting the problem
    or fixing it. This helps us collect information about what happened.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Why did it fail?** Go to the root cause and the chain of events leading to
    that; for example, the website was down because the application couldn''t connect
    to the database. The database was unresponsive because the hard drive was full.
    The hard drive was full because the local logs filled up the disk.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**How was it fixed?** Steps were taken to solve the incident; for example,
    logs older than a week were deleted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**What actions should follow up from this incident?** Actions that should remediate
    or fix the different issues. Ideally, they should include who will perform the
    action; for example, no local logs should be stored and they should be sent to
    the centralized log. The amount of hard disk space should be monitored and alert
    if less than 80% of the space is available.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some of these elements can be filled in immediately after the emergency, such
    as who was involved. However, it's good to schedule the post-mortem meeting one
    to three days after it happened to allow everyone to digest and process this data.
    The root cause can be different to what we initially thought, and spending some
    time thinking about what happened helps us come up with better solutions.
  prefs: []
  type: TYPE_NORMAL
- en: As we discussed in the *Reflecting on release problems* section, be sure to
    encourage open and candid discussion when you're dealing with service interruption
    incidents.
  prefs: []
  type: TYPE_NORMAL
- en: Post-mortem meetings are not there to blame anyone, but to improve the service
    and reduce risks when you're working as a team.
  prefs: []
  type: TYPE_NORMAL
- en: The follow-up actions should be decided in the meeting and prioritized accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Although detecting the root cause is very important, note that actions should
    be taken against other causes. Even if the root cause is one, there are also other
    preventive actions that can minimize the effect it has if it happens again.
  prefs: []
  type: TYPE_NORMAL
- en: Actions that come about from post-mortem meetings are typically high priority
    and should be done as soon as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we've looked at the different aspects of coordination across
    teams so that we can successfully manage an organization running a microservice
    architecture.
  prefs: []
  type: TYPE_NORMAL
- en: We started by talking about how keeping a global vision and coordination between
    parts is good. We talked about having an explicitly named leading architect that
    oversees the system and has a high-level view that allows them to ensure that
    teams aren't conflicting with each other.
  prefs: []
  type: TYPE_NORMAL
- en: We described Conway's Law and how the communication structure ends up shaping
    the software's structure so any change made to the software should be reflected
    somehow in the organization and vice versa. Then, we learned how to divide areas
    of responsibility and provided some examples of possible divisions, based on different
    organizations.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we introduced how technical debt slows down the ongoing development process
    and how it's important to introduce a mindset of continuously addressing it to
    avoid degrading the experience for the internal teams working on them and the
    customers who are using them.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we addressed some of the problems that releases may cause, both in
    terms of coordinating adequately between teams, especially in the early stages
    of working with GitOps, and making retrospective analysis when releases fail or
    when services are down.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Why is a leading architect convenient for a microservice-architecture system?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is Conway's Law?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why does technical debt get introduced?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is it important to create a culture where we can work continuously to reduce
    technical debt?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is it important to document problems in releases and share them with every
    team?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the main objective of a post-mortem meeting?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To learn more about the role of the architect, read *Software Architect's Handbook*
    ([https://www.packtpub.com/application-development/software-architects-handbook](https://www.packtpub.com/application-development/software-architects-handbook)),
    which includes chapters devoted to soft skills and architecture evolution. You
    can read more about Conway's Law and structuring digital businesses in *The New
    Engineering Game* ([https://www.packtpub.com/data/the-new-engineering-game](https://www.packtpub.com/data/the-new-engineering-game)).
  prefs: []
  type: TYPE_NORMAL
