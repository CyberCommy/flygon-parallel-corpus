- en: Managing Workflows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will bring the different processes we described in the previous
    chapters together into a general workflow so that we can make changes to a single
    microservice. We will move on from the process of getting a new feature request
    to developing it locally, reviewing it, testing it in a demo environment, and
    approving the changes and releasing them to the live cluster.
  prefs: []
  type: TYPE_NORMAL
- en: This is related to the pipeline concept we introduced in [Chapter 4](872309f3-42ba-493c-8595-af1e610af61a.xhtml),
    *Creating a Pipeline and Workflow*. In this chapter, however, we will talk about
    the processes of the task. The pipeline and build structures are there to ensure
    that any proposed change follows quality standards. In this chapter, we will focus
    on the teamwork aspects of the technology and how to allow smooth interaction
    while keeping track of the different changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the life cycle of a feature
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reviewing and approving a new feature
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up multiple environments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scaling the workflow and making it work
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, we will have a clear view of the different steps
    that are involved in setting up a new feature for one of our microservices, and
    how can we use multiple environments to test and ensure that the release is successful.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the life cycle of a feature
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Following on from agile principles, the main objective of any team is to be
    able to implement new features quickly, without compromising the quality or stability
    of the system. The first element of change comes in the shape of a** feature request**.
  prefs: []
  type: TYPE_NORMAL
- en: A feature request is a description of a change in the system in non-technical
    terms. Feature requests are normally generated by non-engineers (product owners,
    managers, and CEOs) who are looking to improve the system for business-related
    reasons, such as making a better product or increasing revenue.
  prefs: []
  type: TYPE_NORMAL
- en: Feature requests can be simple, such as *updating the logo of the company in
    the main page*, or big and complicated, such as *adding support to the new 5G
    network*. Feature requests may include bug reports. While they don't usually,
    they will for the purpose of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Complicated feature requests may need to be subdivided into smaller self-contained
    feature requests so that we can iterate in small increments.
  prefs: []
  type: TYPE_NORMAL
- en: Our focus is on the elements that need to be taken into account due to the microservices
    approaches and practices more than agile practices. Such practices deal with how
    to structure feature requests into tasks and estimations, but they are not specific
    to the underlying technologies.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at the *Further reading* section at the end of this chapter to find
    out more about agile practices and methodologies.
  prefs: []
  type: TYPE_NORMAL
- en: In a monolith, we have all the elements under the same code base. So, no matter
    how complicated a particular feature request is, only one system will be affected.
    There is only a single system in a monolith. However, this isn't the case once
    we migrate to microservices.
  prefs: []
  type: TYPE_NORMAL
- en: In a microservice architecture, we need to analyze any incoming feature request
    in terms of what microservice or microservices it affects. If we design our microservices properly,
    most of the requests will only affect a single microservice. However, eventually,
    some of the feature requests will be too big to fit neatly into a single microservice
    and will need to be divided into two or more steps, each changing a different
    microservice.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if we have a new feature request that allows us to mention a user in the
    text of a thought (similar to how a mention works on Twitter), then this mention will
    have to be stored in the Thoughts Backend and be displayed in the Frontend. This
    feature affects two microservices: the Frontend and the Thoughts Backend.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we are referring to concepts that we introduced in the previous
    chapters and are joining them together from a global point of view.
  prefs: []
  type: TYPE_NORMAL
- en: In the next subsection, we will look at the features that affect multiple microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Features that affect multiple microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For a multiple microservice feature request, you need to divide the feature
    into several technical features, with each one affecting a single microservice.
  prefs: []
  type: TYPE_NORMAL
- en: Each technical feature should cover an aspect that's relevant to the microservice
    it affects. If each microservice has a clear purpose and objective, the feature
    will be completed and generalized so that it can be used for later requests.
  prefs: []
  type: TYPE_NORMAL
- en: The basis for a successful microservice architecture is to have loosely coupled
    services. Ensuring that the API of each microservice makes sense on its own is
    important if we wish to avoid blurring the lines between services. Not doing so
    may mean that independent work and deployments aren't allowed.
  prefs: []
  type: TYPE_NORMAL
- en: The dependencies between the requests and microservices should also be considered
    so that the work can be arranged back to front. This means preparing the new feature
    that will add extra data or capabilities but keeping the old behavior by default.
    After doing this, a new feature that uses this extra data can be deployed. This
    way of working ensures backward compatibility at any given time.
  prefs: []
  type: TYPE_NORMAL
- en: We will look at the features that affect multiple microservices in more detail
    in [Chapter 11](06d0c451-77f1-4e4a-8d38-3abf112f79fa.xhtml), *Handling Change,
    Dependencies, and Secrets in the System*. We'll also learn how to coordinate work
    and dependencies in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Going back to our previous example, to add a user's mention to their thoughts,
    we need to make the Thoughts Backend capable of dealing with optional references
    to users. This is a self-contained task that won't affect the existing functionality.
    It can be deployed and tested.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we can make the corresponding changes in the Frontend to allow external
    users to interact with it through an HTML interface.
  prefs: []
  type: TYPE_NORMAL
- en: As we discussed in [Chapter 1](ddb0a00a-6c5b-4ffe-b403-0f5f9f7a7df2.xhtml),
    *Making the Move – Design, Plan, and Execute*, it is crucial for any microservice
    architecture that we can deploy services independently. This allows us to test
    services independently and avoid any overhead that requires complicated deployments
    that make it difficult for us to debug and roll back if errors occur.
  prefs: []
  type: TYPE_NORMAL
- en: If different teams work independently on different microservices, then they
    will also require coordination.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will learn how to implement a feature in a single microservice.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a feature
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once we have the definition of an independent technical feature, it can be implemented.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a technical feature in a clear manner can be challenging. Remember
    that a single feature may need to be further subdivided into smaller tasks. However,
    as we mentioned previously, the objective here is not to structure our tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Start your task by creating a new Git branch. The code can be changed to reflect
    the new feature in this branch. As we saw in [Chapter 2](8f5b60ee-fa8e-42ff-aa6c-fb27d4bd574a.xhtml), *Creating
    a REST Service with Python*, and [Chapter 3](05dd2141-e113-43a2-8bd9-26fb97057913.xhtml),
    *Build, Run, and Test Your Service Using Docker*, unit tests can be run to ensure
    that this work isn't breaking the build.
  prefs: []
  type: TYPE_NORMAL
- en: As we described in [Chapter 3](05dd2141-e113-43a2-8bd9-26fb97057913.xhtml), *Build,
    Run, and Test Your Service Using Docker*, in the *Operating with an immutable
    container* section, we can use `pytest` arguments to run subsets of tests to speed
    up development, thereby enabling quick feedback when running tests. Make sure
    you use it.
  prefs: []
  type: TYPE_NORMAL
- en: How this functionality works in relation to the whole system can be checked
    through the deployment of the local cluster. This starts other microservices that
    may be affected by the work in this branch, but it helps ensure that the current
    work is not breaking any existing calls that affect other microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Based on the pipeline, any commit that's pushed to Git will run all its tests.
    This will detect problems early and ensure that the build is correct before it's
    merged with the main branch.
  prefs: []
  type: TYPE_NORMAL
- en: While this is in progress, we can use a pull request to review the changes between
    the main branch and the new features. We can check our GitHub configuration to
    ensure that the code is in good shape before we merge it.
  prefs: []
  type: TYPE_NORMAL
- en: Once the feature is ready and has been merged with the main branch, a new tag
    should be created to allow for its deployment. As part of the configured pipeline,
    this tag will trigger a build that produces an image in the registry and label
    the image with the same tag. The tag and image are immutable, so we can be sure
    that the code won't change between the different environments. You can roll forward
    and back with confidence that the code will be the exact same code that was defined
    in the tag.
  prefs: []
  type: TYPE_NORMAL
- en: As we saw in [Chapter 8](9a5c53a2-9131-4233-9e4f-992af51d8321.xhtml), *Using
    GitOps Principles*, the tag can be deployed by following GitOps principles. The
    deployment is described in Kubernetes configuration files, under Git control,
    and is reviewed in a pull request that needs to be approved. Once the pull request
    has been merged with the main branch, it will be deployed by Flux automatically,
    as we described in [Chapter 8](9a5c53a2-9131-4233-9e4f-992af51d8321.xhtml), *Using
    GitOps Principles*, in the *Setting up Flux to control the Kubernetes cluster*
    section. At that time, the feature is available in the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s recap on this life cycle, from the description of the technical request
    to when it''s deployed into a cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: This is a more complete version of the Flow that we introduced in [Chapter 4](872309f3-42ba-493c-8595-af1e610af61a.xhtml), *Creating
    a Pipeline and Workflow*.
  prefs: []
  type: TYPE_NORMAL
- en: The technical request is ready to be implemented into a single microservice.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A new feature branch is created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The microservice's code is changed in this branch until the feature is ready.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A pull request, which is used to merge the feature branch into the main branch,
    is created. This, as described in [Chapter 4](872309f3-42ba-493c-8595-af1e610af61a.xhtml), *Creating
    a Pipeline and Workflow*, in the *Understanding the continuous integration practices*
    section, runs the CI process to ensure that it is of a high quality.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The pull request is reviewed, approved, and merged into the main branch.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A new tag is created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A deployment branch is created in the GitOps repository that changes the version
    of the microservice to the new tag.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A pull request, which is used to merge this deployment branch, is created. Then,
    it's reviewed and merged.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the code has been merged, the cluster automatically releases the new version
    of the microservice.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, the new feature is available in the cluster!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is a simplified version of the life cycle; in reality, it may be more complicated.
    Later in this chapter, we will look at a situation where the life cycle needs
    to be deployed to more than one cluster.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will look at some recommendations when it comes to reviewing
    and approving pull requests.
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing and approving a new feature
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As specified by the pipeline model we described in [Chapter 4](872309f3-42ba-493c-8595-af1e610af61a.xhtml), *Creating
    a Pipeline and Workflow*, the candidate code moves through a series of stages,
    stopping if there's a problem.
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned previously, reviewing using GitHub pull requests works if we
    wish to introduce new features to the code of our microservices, as well as if
    we wish to deploy those changes into clusters through GitOps practices.
  prefs: []
  type: TYPE_NORMAL
- en: 'In both cases, we can check this automatically through automated tests and
    processes. However, there''s a final step that requires manual intervention: knowledge
    transfer and an extra pair of eyes. Once the reviewer thinks the new feature is
    ready, they can approve it.'
  prefs: []
  type: TYPE_NORMAL
- en: The tools are the same, although the reviewing process works a little differently.
    This is because the objectives aren't the same. For feature code, the review is
    more open to discussion until it's approved and merged into the main branch. On
    the other hand, reviewing and approving a release is typically more straightforward
    and faster.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by learning how to review feature code.
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing feature code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Code reviews can be initiated while the feature is being developed and a request
    has been opened to merge it. As we've already seen, in GitHub, code can be reviewed
    while it's in the **pull request** stage.
  prefs: []
  type: TYPE_NORMAL
- en: A code review is basically a shaped discussion about the code and the new feature;
    that is, we're checking the code before it is introduced to the main branch. This
    presents us with the opportunity to improve the feature while it is in development,
    and before it becomes a component of the system.
  prefs: []
  type: TYPE_NORMAL
- en: Here, a member of the team may read the code that hasn't been merged and give
    the author some feedback. This can go back and forth until the reviewer thinks
    that the code is ready to be merged and approves it. In essence, someone else,
    other than the author of the feature, needs to agree that the new code meets the
    required standards.
  prefs: []
  type: TYPE_NORMAL
- en: Code bases grow over time and their components can help each other out. Merging
    code into the main branch states that you fully accept that the new code will
    be maintained by the team as part of the code base.
  prefs: []
  type: TYPE_NORMAL
- en: The code may need to be approved by one or more people, or by specific people.
  prefs: []
  type: TYPE_NORMAL
- en: In GitHub, you can enable code owners. These are engineers who are responsible
    for approving repositories, or parts of repositories. Check out the GitHub documentation
    for more information: [https://help.github.com/en/articles/about-code-owners](https://help.github.com/en/articles/about-code-owners).
  prefs: []
  type: TYPE_NORMAL
- en: Code reviewing is a quite common process these days, and the popularity and
    ease of using pull requests in GitHub has spread. Most developers are familiar
    with this process.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a good feedback culture is more difficult than it looks, though.
    Writing code is a deeply personal experience; no two people will write the same
    code. For developers, having your code criticized by others can be a difficult
    experience unless there are clear rules.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some suggestions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Tell your reviewers what they should look for. Make a point of following a
    checklist. This helps develop a culture within the team so that they care about
    shared core values. This also helps junior developers know what to look for. This
    may change from team to team, but here are some examples:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are new tests.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Error conditions are tested.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The documentation is properly updated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any new endpoints comply with standards.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Architectural diagrams are updated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reviewing code is not the same thing as writing the code. There will always
    be discrepancies (for example, this variable name could be changed), but what
    needs to be reviewed is whether such changes need to be implemented. Nitpicking
    will erode the trust between team members.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The bigger the code to review, the more difficult it is to do. It's better to
    work in small increments, which works well with the principles of continuous integration.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of the code should be reviewed on equal grounds. This includes the code
    of senior developers, and junior developers should be encouraged to leave honest
    feedback. This helps ownership of the code and its fairness to grow.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A code review is a conversation. A comment doesn't necessarily mean that the
    reviewer's feedback has to be implemented without you questioning it first. It
    opens a conversation about improving the code, and making clarifications and pushing
    back is totally fine. Sometimes, the proper way of handling a request, that is,
    to change a part of the code, is to leave a comment explaining why this was done
    in a particular way.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Reviews help spread knowledge about the code base. This isn''t a silver bullet,
    though. Code reviews tend to fall into tunnel vision, where only small issues
    such as typos, and local snippets of code, are looked at, and not the bigger elements.
    This is why it''s important to implement features in small increments: to help
    those around you digest change.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's important to leave appreciative comments. Create a culture that appreciates
    well-written code. Only highlighting what's bad makes the review process miserable
    for the author.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Criticism should be addressed to the code, not to the coder. Ensure that your
    review is civil. In this step, we want to ensure that the code is of a high quality;
    you don't want to make yourself, as the reviewer, look superior.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code reviews can be stressful for those who aren't used to them. Some companies
    are creating principles and ideas to make this process less painful. A good example
    can be found at [https://www.recurse.com/social-rules](https://www.recurse.com/social-rules).
    Don't be afraid to define and share your own principles.
  prefs: []
  type: TYPE_NORMAL
- en: It's important that code can be approved at all times, even when someone in
    the team is on holiday or sick. Ensure that you grant approval to multiple members
    of the team so that the approval process itself isn't a bottleneck.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you start producing code reviews, ensure that the team leaders keep these
    considerations in mind and emphasize why all the code is reviewed.
  prefs: []
  type: TYPE_NORMAL
- en: It is worth emphasizing how code reviews are not a technological solution, but
    a people-related one. As such, they can suffer from people-related problems such
    as big egos, adversarial discussions, or non-productive debates.
  prefs: []
  type: TYPE_NORMAL
- en: The microservice architecture is fit for big systems that have multiple people
    working on them. Teamwork is crucial. Part of that is ensuring that the code doesn't
    belong to a single person, but to a whole team. Code reviews are a great tool
    to that end, but be sure to actively look for healthy ones.
  prefs: []
  type: TYPE_NORMAL
- en: Over time, a consensus will develop and a lot of code will be developed consistently.
    In a healthy team, the amount of time that's spent on reviews should reduce.
  prefs: []
  type: TYPE_NORMAL
- en: Over time, the team will perform code reviews routinely, but setting these foundations
    may be complicated in the beginning. Ensure that you allow time to introduce them.
    As we mentioned previously, once the feature is ready, we need to go ahead and
    approve it. Approving code for a new feature and merging it into the main branch
    is the final stage of the feature review, but it still needs to be released. Releases
    are under code control, and they need to be reviewed as well.
  prefs: []
  type: TYPE_NORMAL
- en: Approving releases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using GitOps principles allows us to enable the same review and approval methods
    so that we can make changes in the Kubernetes infrastructure. As we mentioned
    previously, the fact that the infrastructure is defined by YAML files in Kubernetes
    allows us to control these changes.
  prefs: []
  type: TYPE_NORMAL
- en: Any change that's made over a Kubernetes cluster can be subjected to a pull
    request and review method. This makes approving a release to a cluster an easy
    process.
  prefs: []
  type: TYPE_NORMAL
- en: This helps in minimizing problems, since more members of the team are involved
    in the changes and the knowledge that they have of the infrastructure is better.
    This works well with the DevOps principles of allowing teams to take control over
    their own deployment and infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: However, infrastructure changes in GitOps tend to be easier to review than regular
    code reviews. In general terms, they are done in very small increments, and most
    changes will be so straightforward that the probability of generating debate is
    minimal.
  prefs: []
  type: TYPE_NORMAL
- en: As a general rule, try to make any infrastructure change as small as possible.
    Infrastructure changes are riskier as errors may bring down important parts of
    it. The smaller the change, the smaller the risk and the easier it is to diagnose
    any issues.
  prefs: []
  type: TYPE_NORMAL
- en: All the suggestions we made about code reviews have a role to play, too. The
    most important one is to include some guidelines that reference critical parts
    of the infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: Some sections of the infrastructure may be under the GitHub code owner's protection.
    This makes it mandatory for certain engineers to approve changes to critical parts
    of the infrastructure. Take a look at the documentation for more information: [https://help.github.com/en/articles/about-code-owners](https://help.github.com/en/articles/about-code-owners).
  prefs: []
  type: TYPE_NORMAL
- en: Since the infrastructure is defined as code stored in GitHub, this also makes
    it easy to copy the infrastructure, thereby greatly simplifying the generation
    of multiple environments.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up multiple environments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The ease of creating, copying, and removing namespaces under Kubernetes greatly
    reduces the previous burden of keeping multiple copies of environments to replicate
    the underlying infrastructure. You can use this to your advantage.
  prefs: []
  type: TYPE_NORMAL
- en: Based on the GitOps principles we mentioned earlier, we can define new namespaces
    to generate a new cluster. We can either use another branch (for example, use
    the `master` branch for the production cluster and `demo` for the demo cluster)
    or copy the files containing the cluster definition and change the namespaces.
  prefs: []
  type: TYPE_NORMAL
- en: You can use different physical Kubernetes clusters for different purposes. It's
    better to leave the production cluster as not being shared with any other environment
    to reduce risks. However, every other environment could live in the same cluster,
    which won't affect external customers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some feature requests are evidence enough that the development team will know
    exactly what to do, such as with bug reports. However, others may require a bit
    more of testing and communication while they''re in development to ensure that
    they fulfill a requirement. This may be the case when we''re checking that a new
    feature is actually useful to the intended external user, or could be a more explorative
    feature. In this case, we need to call an external party, that is, the ultimate
    approver of the feature: the *stakeholder*.'
  prefs: []
  type: TYPE_NORMAL
- en: A stakeholder is a term from project management that specifies a third party,
    that is, the final user of a product or a user who's impacted by it. Here, we
    use the term to specify someone who's interested in a feature but external to
    the team, so they can't define the feature requirements from within. A stakeholder
    can be, for example, a manager, a customer, the CEO of the company, or a user
    of an internal tool.
  prefs: []
  type: TYPE_NORMAL
- en: Any developer who has had to deal with a fuzzily defined request from a stakeholder,
    such as *allow search by name*, has had to tweak it: *no, not by the first name,
    by surname*.
  prefs: []
  type: TYPE_NORMAL
- en: Ensure that you define a proper end to these kinds of tasks. Stakeholder feedback
    can be endless if it's allowed to run without limits. Define what is and is not
    included in it, as well as any deadlines, beforehand.
  prefs: []
  type: TYPE_NORMAL
- en: To run tests and to ensure that the feature that's under development is going
    in the right direction, you can create one or more demo environments where you
    will deploy work in progress before it is merged into the main branch. This will
    help us share this work with stakeholders so that they can give us feedback before
    the feature is completed, without us having to release it in a production environment.
  prefs: []
  type: TYPE_NORMAL
- en: As we saw in the previous chapters, generating a new environment in Kubernetes
    is easy. We need to create a new namespace and then replicate the production definition
    of the cluster, thereby changing the namespace. This will create a copy of the
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the specific version of the microservice under development will allow
    us to create a working version of it. Newer versions can be deployed as usual
    in this demo environment.
  prefs: []
  type: TYPE_NORMAL
- en: This is a simplified version. You may need to make changes between the production
    environment and demo environments, such as the number of replicas, and database
    setup. In such cases, a *template environment* could be used as a reference so
    that it's ready to be copied.
  prefs: []
  type: TYPE_NORMAL
- en: Other environments, such as staging, can be created in a similar fashion, with
    the aim of creating tests that ensure that the code that's been deployed into
    production will work as expected. These tests can be automatic, but they can also
    be manual if we want to check that the user experience is adequate.
  prefs: []
  type: TYPE_NORMAL
- en: A staging environment is a setup that works as a replica that's as faithful
    as possible to the production environment, which means we can run tests to provide
    assurance that the deployment in production will work. Staging normally helps
    us verify that the deployment process will be correct, as well as any final tests.
  prefs: []
  type: TYPE_NORMAL
- en: Staging environments are typically very expensive to run. After all, they are
    a copy of a production environment. With Kubernetes, you can replicate the production
    environment easily and reduce the required physical infrastructure. You can even
    start and stop it when it is not in use to reduce costs.
  prefs: []
  type: TYPE_NORMAL
- en: You can use multiple environments to create a cascading structure of deployment
    in a similar fashion. This means that a tag needs to be deployed into the staging
    environment and be approved before it goes into the production environment.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now look at how we can deal with this structure from the point of view
    of the developers.
  prefs: []
  type: TYPE_NORMAL
- en: Scaling the workflow and making it work
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some of the challenges of implementing this way of working include creating
    a culture that provides an adequate feedback loop and checking new code carefully
    while reviewing it quickly. Waiting for a review is a blocked state that stops
    the developer from implementing the feature that's being reviewed.
  prefs: []
  type: TYPE_NORMAL
- en: While this waiting time can be used for other purposes, not being able to progress
    will quickly lower productivity. Either the developer will keep a few features
    in parallel, which is highly problematic from the context switch perspective,
    or they need to wait and roll their thumbs until the review is completed.
  prefs: []
  type: TYPE_NORMAL
- en: The context switch is probably the most serious killer of productivity. One
    of the keys to keeping your team's productivity high is being able to start and
    finish a task. If the task is small enough, it will be finished quickly, so swapping
    between projects is easier. However, working on two or more tasks at the same
    time is a very bad practice.
  prefs: []
  type: TYPE_NORMAL
- en: If this happens often, try to divide your tasks into smaller chunks.
  prefs: []
  type: TYPE_NORMAL
- en: To be able to balance thoroughly reviewing the code and reducing the blocking
    time, there are some elements to keep in mind.
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing and approving is done by the whole team
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There need to be sufficient reviewers available at all times. If just the developers
    are experienced, reviews may end up only being done by the single most senior
    person on the team, for example, the team lead. Though this person may be the
    better reviewer in principle, in the long run, this structure will compromise
    the team as the reviewer won't be able to do anything else. Making progress in
    the development and release stages will also be blocked if the reviewer is unavailable
    for any reason, such as due to illness or if they're on holiday.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, make the whole team capable of reviewing their peer's code. Even though
    a senior contributor takes a more proactive role in teaching the rest of the team
    on how to review, after a while, most reviews shouldn't require their assistance.
  prefs: []
  type: TYPE_NORMAL
- en: Initially, though implementing this process requires active mentoring, this
    will typically be lead by the senior members of the team. Reviewing code is a
    trainable ability with the objective that, after a period of time, everyone is
    capable of running a review and allowed to approve pull requests.
  prefs: []
  type: TYPE_NORMAL
- en: The same process is followed for deployment pull requests. Eventually, everyone
    in the team, or at least a significant number of members, should be able to deploy
    a release. The initial main reviewer could be someone different, though.
  prefs: []
  type: TYPE_NORMAL
- en: It is likely that the best candidate to review a release is an expert on how
    the Kubernetes infrastructure is configured, but not an expert on microservice
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding that not every approval is the same
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Remember that the different stages of a feature are not equally critical. The
    code review's early process is about ensuring that the code is readable and that
    it keeps the quality standards. In the early stages, the code will have a relatively
    high number of comments and there will be more to discuss since more elements will
    need to be tweaked.
  prefs: []
  type: TYPE_NORMAL
- en: A big part of reviews is creating code that is *understandable enough* that
    other members of the team understand it. Although some people claim that code
    reviews make everyone aware of the changes that other members of the team are
    implementing, in my experience, reviewers are not that aware of specific features.
  prefs: []
  type: TYPE_NORMAL
- en: A good review, however, will ensure that nothing cryptic is being introduced
    into the code base and that the core elements are respected (elements such as
    introducing tests, keeping documentation up to date, and keeping code readable).
    As we suggested previously in this chapter, try to create an explicit list of
    things to check. It will help you make the reviews and code more consistent.
  prefs: []
  type: TYPE_NORMAL
- en: The deployment stages of a new feature only require that we check that the version
    of the microservice changes and that the remainder of the infrastructure is intact.
    These will typically be very small; most of them double-check that there are no
    typos and that the microservice to be changed is the correct one.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a clear path for releases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Having a simple and clear process helps everyone involved have a clear understanding
    of how a feature moves from being developed to being released into the production
    environment. For example, based on the ideas we''ve discussed, we could end up
    with a deployment path that''s similar to the one shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/22480f67-8ebb-41fe-8395-f832aa7b5909.png)'
  prefs: []
  type: TYPE_IMG
- en: For each of these steps, we need to validate that the step is correct. As we
    saw in [Chapter 4](872309f3-42ba-493c-8595-af1e610af61a.xhtml), *Creating a Pipeline
    and Workflow*, automatic tests ensure that anything that's merged into the main
    branch doesn't break the existing builds. This covers the preceding diagram up
    to the **Create tag** step.
  prefs: []
  type: TYPE_NORMAL
- en: 'Equally, there could be a way of validating that a deployment has been successful
    after it''s been applied. The following are a few ideas regarding this:'
  prefs: []
  type: TYPE_NORMAL
- en: Manual tests, to check that the deployed microservice works as expected
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automated tests, such as the ones described in [Chapter 4](872309f3-42ba-493c-8595-af1e610af61a.xhtml), *Creating
    a Pipeline and Workflow*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check that the image to be deployed has been correctly deployed using Kubernetes
    tools or a version API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once one deployment stage has been successfully completed, the next can be started.
  prefs: []
  type: TYPE_NORMAL
- en: Performing a deployment in non-production environments minimizes the risk of
    breaking a production as it will ensure that the deployment process is correct. The
    process needs to be fast enough to allow quick deployments, thus making them as
    small as possible.
  prefs: []
  type: TYPE_NORMAL
- en: The full process from merging into the main branch until the new version is
    released into the production environment should take less than a few hours, but
    ideally less than that.
  prefs: []
  type: TYPE_NORMAL
- en: If more time is required, the process is probably too heavy.
  prefs: []
  type: TYPE_NORMAL
- en: Small, frequent deployments will minimize the risk of breaking the production
    environment. In some exceptional cases, the regular process may be slow, and an
    emergency procedure should be used.
  prefs: []
  type: TYPE_NORMAL
- en: Emergency releases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's imagine that there's a critical bug in production and that it needs to
    be addressed as fast as possible. For these exceptional cases, it is fine to define
    an emergency process beforehand.
  prefs: []
  type: TYPE_NORMAL
- en: This emergency process may involve speeding up reviews or even skipping them
    completely. This may include skipping intermediate releases (such as not deploying
    to a demo environment before hand). Ensure that you explicitly define when this
    process is required and ensure it's used in emergency situations only.
  prefs: []
  type: TYPE_NORMAL
- en: If your regular deployment process is fast enough, then there's no need for
    an emergency process. This is an excellent reason to try to increase deployment
    times.
  prefs: []
  type: TYPE_NORMAL
- en: A rollback is a good example of such a situation. To revert the deployment of
    a microservice that had a critical bug introduced to it in the last version, rolling
    back and returning to the previous version only in production, without affecting
    anything else, is a reasonable process.
  prefs: []
  type: TYPE_NORMAL
- en: Note how, here, we're reducing the risk of making a quick change with the assurance
    that the version that's been rolled back has already been deployed before. This
    is an excellent example of how an emergency procedure may work and reduce risks.
  prefs: []
  type: TYPE_NORMAL
- en: Use your common sense when it comes to detecting exceptional situations and
    discuss how to deal with them with your team beforehand. We will talk about retrospectives
    in [Chapter 12](d1a54332-1f4f-4ec7-a5a4-7ea81121bbea.xhtml), *Collaborating and
    Communicating across Teams.*
  prefs: []
  type: TYPE_NORMAL
- en: Releasing frequently and adding feature flags
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While rollbacks are possible, as we've just seen, the general consensus should
    be that each new deployment moves forward. The code for a new release contains
    the code from the previous release, plus some small changes. Following the Git
    way of operating, we work on a single branch (the main branch) that gets pushed
    forward.
  prefs: []
  type: TYPE_NORMAL
- en: This means having to avoid several active long-lived branches. This model is
    called *trunk-based development* and it's the recommended way of working to aim
    for continuous integration. In a trunk-based development, feature branches are
    short-lived and are always merged with the main branch (or trunk), which is normally
    called the `master` in Git.
  prefs: []
  type: TYPE_NORMAL
- en: Trunk-based development avoids issues when we have long-lived branches that
    diverge from the main one, thus making the integration of several components complicated.
    The basis for continuous integration is to be able to always have code that can
    be released in small increments. This model takes "trunk" as the reference for
    the releases.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following diagram, we can see how **feature A** was merged to the **master** branch
    and how **feature B** is still in progress. Any releases will come from the **master** branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/2dab7dbb-586a-4dea-a959-14ba5beea981.png)'
  prefs: []
  type: TYPE_IMG
- en: If **feature A** were to introduce a bug, a new bugfix branch will branch off
    from **master** and will be merged back. Note how the structure is to keep going
    forward.
  prefs: []
  type: TYPE_NORMAL
- en: For this system to work, feature branches need to be short-lived – typically
    for only a few days. This makes merges easy and allows for small incremental changes,
    which are the key to continuous integration.
  prefs: []
  type: TYPE_NORMAL
- en: Using feature flags
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, there are some features that, by design, require big/drastic changes
    to be made in one go, such as a new UI interface. The kind of short, quick iteration
    cycle of slowly adding small features that continuous integration advocates doesn't
    work in these frequent release situations. The new interface needs to include
    all the elements in one go, or it will look weird.
  prefs: []
  type: TYPE_NORMAL
- en: You can use feature flags when you want to keep working in a small incremental
    way and, at the same time, delay the activation of a feature until it's ready.
  prefs: []
  type: TYPE_NORMAL
- en: Feature flags are configuration elements that enable or disable a particular
    feature. This allows you to change the behavior of the microservice with a configuration
    change, which acts as a switch.
  prefs: []
  type: TYPE_NORMAL
- en: In Kubernetes, we use the `deployment.yaml` file to describe the environment
    variables, as well as ConfigMaps. We will discuss ConfigMaps in [Chapter 11](06d0c451-77f1-4e4a-8d38-3abf112f79fa.xhtml),
    *Handling Change, Dependencies, and Secrets in the System*.
  prefs: []
  type: TYPE_NORMAL
- en: The configuration is tied to each individual environment. This makes it possible
    for us to present a feature in a particular environment and not in another, while
    the code base remains the same.
  prefs: []
  type: TYPE_NORMAL
- en: For example, a new interface can be slowly developed and protected under a feature
    flag. Some environments, such as demo environments, can still be active so that
    internal feedback can be gathered, but this won't be displayed in the production
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: Once the new interface is ready, small changes can be made; for example, we
    can change the configuration parameter to enable it. This may look like a big
    change externally, but it can easily be reverted if we swap back to the parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Feature flags are useful when we're dealing with externally accessible services.
    Internal services can add more features without any issue since they'll only be
    called by other microservices in the system.
  prefs: []
  type: TYPE_NORMAL
- en: Internal microservices are normally okay with adding new features. Here, backward
    compatibility is respected. Externally accessible features sometimes require us
    to replace a feature with another for reasons including interface changes or the
    deprecation of products.
  prefs: []
  type: TYPE_NORMAL
- en: A related approach is to roll a feature to a subset of users. This can be a
    predefined set of users, such as users who have enrolled in a beta program to
    receive early access to features or a random sample so that they can detect problems
    early, ahead of a global release.
  prefs: []
  type: TYPE_NORMAL
- en: Some big companies use regional access as well, where some features are enabled
    in certain countries first.
  prefs: []
  type: TYPE_NORMAL
- en: Once the feature flag has been activated, any deprecated features can be removed
    and cleaned up, so there's no old code that's not going to be used.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with database migrations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Database migrations are changes that are made to the persistent data that's
    stored in a particular environment (normally, in one or more databases). Most
    of the time, this means changing the database schema, but there are others.
  prefs: []
  type: TYPE_NORMAL
- en: The data in a production environment is the most important asset in a running
    system. Extra care is advised for database migrations.
  prefs: []
  type: TYPE_NORMAL
- en: In certain cases, a migration may lock a table for a certain period of time,
    thereby rendering the system unusable. Ensure that you test your migrations properly
    in order to avoid or at least prepare for these cases.
  prefs: []
  type: TYPE_NORMAL
- en: Though database migrations may technically be reversible, doing so is very expensive
    in terms of development time. For example, adding and removing a column could
    be simple, but once the column is in operation, the column will contain data that
    shouldn't be removed.
  prefs: []
  type: TYPE_NORMAL
- en: 'To be able to work seamlessly in the event of data migration, you need to detach
    it from the code that is going to call it and follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Design a database migration in a way that doesn't interfere with the current
    code. For example, adding a table or column to the database is safe since the
    old code will ignore it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Perform database migration. This makes the required changes while the existing
    code keeps operating without interruption.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, the code can be deployed. Once it has been deployed, it will start using
    the advantages of the new database definition. If there's a problem, the code
    can be rolled back to a previous version.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This implies that we need to create two deployments:'
  prefs: []
  type: TYPE_NORMAL
- en: One for the migration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another for the code that uses this migration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Migration deployment may be similar to code deployment. Maybe there's a microservice
    running the migrations, or maybe it's a script doing all the work. Most frameworks
    will have a way of making migrations to ensure that a migration isn't applied
    twice.
  prefs: []
  type: TYPE_NORMAL
- en: For example, for SQLAlchemy, there's a tool called Alembic ([https://alembic.sqlalchemy.org/en/latest/](https://alembic.sqlalchemy.org/en/latest/))
    that we can use to generate and run migrations.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there is an alternative operation: try to apply the migrations to
    the microservice that will make use of them. When dealing with a production environment,
    this is a bad idea as this will slow start up times in all situations, regardless
    of whether a migration is occurring. Also, it won''t check that the code can be
    safely rolled back and works with the previous version of the database.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Working with two independent deployments is obviously a bit more restrictive
    than changing the database freely, but it ensures that each step forward is solid
    and that the service is uninterrupted. It''s more deliberate. For example, to
    rename a column, we would follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we would deploy a migration that creates a new column with the new column
    name, thereby copying the data from the old column. The code reads and writes
    from the old column.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we would deploy the new code that reads from the old column and writes
    to both. During the release process, any writes from the old code to the old column
    will be read correctly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After, we would create another migration that copies the data from the old one
    to the new one. This ensures that any transient copy is correctly applied. At
    this point, any new data still goes to both columns.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we would deploy code that reads and writes to the new column, ignoring
    the old one.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we would implement a migration to drop the old column. At this point,
    the old column doesn't contain relevant data and can be safely deleted. It won't
    affect the code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is a deliberate example of a long process, but in most cases, such a long
    process won't be required. However, at no point in any of these steps is there
    any inconsistency. If there's a problem in one of the stages, we can revert to
    the previous stage – it will still work until a fix is put in place.
  prefs: []
  type: TYPE_NORMAL
- en: The main objective is to avoid having transient states where the database won't
    work with the currently deployed code.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we talked about the flow of a team, from starting a new feature
    to deploying it into a production environment.
  prefs: []
  type: TYPE_NORMAL
- en: We started by talking about the key points of feature requests when we're working
    in a microservices architecture. We introduced requests that affect multiple microservices
    and learned how to structure the work so that the service isn't interrupted.
  prefs: []
  type: TYPE_NORMAL
- en: We talked about the elements that make a good review and approval process, as
    well as how GitHub pull requests help us do this. Using GitOps practices to control
    the infrastructure makes deployments to be reviewed straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we discussed how working with Kubernetes and GitOps helps us create multiple
    environments and how we can use them to our advantage when dealing with demo and
    staging environments to test deployments and to present features in a controlled
    environment before they go to production.
  prefs: []
  type: TYPE_NORMAL
- en: After this, we talked about how we can make a team have a global view of the
    entire life cycle, from feature request to deployment and being able to follow
    the full path quickly. We learned how to clarify these steps and how to make the
    team responsible for reviewing and approving its own code, which allows developers
    to take full ownership of the development cycle.
  prefs: []
  type: TYPE_NORMAL
- en: We also talked about the issues that may occur when we're dealing with database
    migrations and explained how to proceed with this special kind of deployment,
    which isn't easy to roll back.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will talk about live systems and how to enable elements
    such as metrics and logs so that we can detect problems and bugs that occur in
    a production environment and have enough information to remediate them as quickly
    and proactively as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a new business feature is received, what analysis do we need to perform in
    a system working under a microservice architecture?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If a feature requires two or more microservices to be changed, how do we decide
    which one should be changed first?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does Kubernetes help us set up multiple environments?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does a code review work?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the main bottleneck for code reviews?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under GitOps principles, are the reviews for deployment different from code
    reviews?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is it important to have a clear path to deployment once a feature is ready
    to be merged into the main branch?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why are database migrations different from regular code deployments?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To learn more about agile practices and introducing them to a team, take a
    look at the following books:'
  prefs: []
  type: TYPE_NORMAL
- en: '*The Agile Developer''s Handbook* ([https://www.packtpub.com/eu/web-development/agile-developers-handbook](https://www.packtpub.com/eu/web-development/agile-developers-handbook))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Agile Technical Practices Distilled* ([https://www.packtpub.com/eu/business-other/agile-technical-practices-distilled](https://www.packtpub.com/eu/business-other/agile-technical-practices-distilled))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you're using JIRA in your organization, reading *Hands-On Agile Software
    Development with JIRA* ([https://www.packtpub.com/eu/application-development/hands-agile-software-development-jira](https://www.packtpub.com/eu/application-development/hands-agile-software-development-jira)) can
    help you get better use out of the tool when you're working with agile practices.
  prefs: []
  type: TYPE_NORMAL
