- en: Process Creation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we learned how to handle a (fictional) application
    design and implementation requirement: getting our C program to execute (`exec`)
    another program altogether. However, the reality is that the discussion remains
    incomplete; this chapter on process creationwill fill in several gaps, and much
    more.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn about some core Unix/Linux systems programming
    concepts: the gory details required to correctly program the critical `fork(2)` system
    call to create a process. Along the journey, Unix aficionado terms such as blocking
    calls, orphans, and zombies are made clear as well. The material carefully brings
    out subtle points, turning the average developer into a proficient one. The reader
    will, in parallel, learn to write C code to implement the preceding key concepts
    in a Linux systems application. As usual, several code examples are used to clearly
    illustrate and harden the concepts taught.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The purpose of this chapter is to guide the Linux systems developer into the
    core system programming worlds of the Unix `fork-exec-wait` semantics and related
    areas. Briefly, we will focus upon the following areas, helping the reader learn:'
  prefs: []
  type: TYPE_NORMAL
- en: The Unix process creation model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The whys and the hows of it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Deeper details, including:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How the fork affects memory allocations, open files and so on, and security
    implications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The several forms of the `wait` APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How these APIs are made use of practically
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The rules of fork
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Orphan and zombie processes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Process creation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Unless a Unix/Linux systems programmer has been living under a rock somewhere,
    they''ve certainly heard of, if not directly worked with, the `fork(2)` system
    call. Why is it so well known and important? The reason is simple: Unix is a multitasking
    OS; programmers must exploit the OS''s capabilities. To have an application multitask,
    we need to create multiple tasks or processes; the fork is the Unix way to create
    a process. In fact, to the typical systems programmer, fork is the only way available
    to create a process.'
  prefs: []
  type: TYPE_NORMAL
- en: There is another system call to create a process or thread: `clone(2)`*.* It
    also creates, well, a custom process. It's not typically used by Linux application
    developers; library (typically the thread library) developers use it more. In
    this book, we do not explore `clone`; for one thing, it's very Linux-specific
    and non-portable; for another, it's more of a hidden API.
  prefs: []
  type: TYPE_NORMAL
- en: The other way to multitask is by multithreading of course, which will be covered
    in detail in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: How fork works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In theory, the job description of the `fork(2)` system call can be crystallized
    down to one simple statement: *create an identical copy of the calling process*.
    The terminology we shall repeatedly encounter is as follows: the process-calling *fork* is
    called the **parent **and the newly created, newborn process is called the **child**.'
  prefs: []
  type: TYPE_NORMAL
- en: Please note that, to begin with at least, we shall keep the discussion on how fork works
    purely conceptual and simple; later, we shall delve deeper and clarify how the
    OS performs several necessary optimizations.
  prefs: []
  type: TYPE_NORMAL
- en: Fork is a system call; thus, the real work of process creation is carried out
    by the OS under the hood. Recall from [Chapter 2](976fc2af-8bb4-4060-96cd-3b921682ed75.xhtml),
    *Virtual Memory*, that the **virtual address space** (**VAS**) of a process is
    built out of homogeneous regions called **segments** (or **mappings**). Thus,
    when a child process is created, the OS will copy the parent's text, data (three
    of them), library (and other mappings), plus the stack segment to the child.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hang on though; it does not stop there: There is more, much more, to a process
    than just its VAS. This includes open files, process credentials, scheduling information,
    filesystem structures, paging tables, namespaces (PIDs, and so on), audit information,
    locks, signal handling information, timers, alarms, resource limits, IPC structures,
    profiling (perf) information, security (LSM) pointers, seccomp, thread stacks
    and TLS, hardware context (CPU and other registers), and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: Many of the attributes mentioned earlier are well beyond the scope of this book,
    and we shall not attempt to delve into them. The idea is to show that there is
    much more to a process than just VAS.
  prefs: []
  type: TYPE_NORMAL
- en: Phew! So, performing a fork involves the kernel copying several things from
    the parent to the child process. But, think about it: not all attributes are directly
    inherited by the child from the parent (many are, but certainly not all are).
    For example, the process PID and PPID (parent PID) is not inherited (can you figure
    out why?).
  prefs: []
  type: TYPE_NORMAL
- en: 'As a first-level enumeration, the following process attributesare inherited
    by the child process upon fork (meaning, it-the new born child-gets a copy of
    the parent''s attributes with the same content):'
  prefs: []
  type: TYPE_NORMAL
- en: 'The **VAS**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Text
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Data:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initialized
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uninitialized (bss)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Heap
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Library segments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other mappings (for example, shared memory regions, mmap regions, and so on)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Open files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Process credentials
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scheduling information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filesystem (VFS) structures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Paging tables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Namespaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Signal dispositions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resource limits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IPC structures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Profiling (perf) information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Security information:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security (LSM) pointers
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: Seccomp
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thread stacks and TLS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hardware context
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following attributes of the parent process are not inherited by the child
    process upon forking:'
  prefs: []
  type: TYPE_NORMAL
- en: PID, PPID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Locks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pending and blocked signals (cleared for child)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Timers, alarms (cleared for child)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Audit information (CPU/time counters are reset for child)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Semaphore adjustments made via `semop(2)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Asynchronous IO** (**AIO**) ops and contexts'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It''s useful to see this in the form of a diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0db75d3e-d21d-4750-85a5-ecbc28056640.png)'
  prefs: []
  type: TYPE_IMG
- en: As can be seen, `fork(2)` is indeed a heavyweight operation!
  prefs: []
  type: TYPE_NORMAL
- en: If interested, you can find more detail on the inheritance/non-inheritance characteristics
    within the man page on `fork(2)`.
  prefs: []
  type: TYPE_NORMAL
- en: Using the fork system call
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The signature of the fork is simplicity itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This looks trivial, but you know the saying *the devil lies in the details!*
    Indeed, we shall bring out several subtle, and not-so-subtle, pointers regarding
    the correct usage of this system call.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin to understand how fork works, lets write a simple C program (`ch10/fork1.c`*)*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Build and run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The fork will, on success, have created a new child process.
  prefs: []
  type: TYPE_NORMAL
- en: '**A key programming rule: ****never assume an API succeeds, always check for
    the failure case !!!**'
  prefs: []
  type: TYPE_NORMAL
- en: This cannot be overstressed.
  prefs: []
  type: TYPE_NORMAL
- en: 'OK, let''s modify the code to check for the failure case; any and every system
    call (with perhaps just two exceptions out of around 380 syscalls) return `-1`
    on failure. Check for it; here is the relevant code snippet (`ch10/fork1.c`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is identical to what we saw previously (of course, since the fork did
    not fail). So, the `printf` seems to have been executed twice. Indeed it was:
    once by the parent process, and once by the new child process. This immediately
    teaches us something about the way fork works; here, we will attempt to codify
    these things as the rules of fork. In this book, we shall end up codifying seven
    rules of `fork(2)`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Fork rule #1'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Fork rule #1**: *After a successful fork, execution in both the parent and
    child process continues at the instruction following the fork*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Why does it happen this way? Well, think about it: the job of fork is to make
    a (pretty much) identical copy of the parent in the child; this includes the hardware
    context (mentioned earlier), which of course includes the **Instruction Pointer**
    (**IP**) register (sometimes called the **Program Counter** (**PC**)) itself!
    Hence, the child process too will execute the user mode code at the same location
    as the parent. As the fork is successful, control will not go the error handling
    code (the `FATAL()` macro); instead, it will go to the `printf` .* The key point
    is this: this will happen in both the (original) parent and the (new) child process.* Hence
    the output.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To reinforce the point, we write a third version of this same simple C program
    (`ch10/fork3.c`). Here, we just show the `printf `statement as it''s the only
    line of code that changes (from the  `ch10/fork3.c`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Build and run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Ah! Now we can actually see that two processes have run the `printf`! Probably
    (but not for sure), PID `25496` is the parent process, the other of course is
    the child. After this, both processes execute the `exit(3)` API, and thus both
    die.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fork rule #2 – the return'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s take a look at the code we''ve used so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: OK, we now understand from the first rule that the `printf` will be run twice
    and in parallel—once by the parent, and once by the child process.
  prefs: []
  type: TYPE_NORMAL
- en: 'But, think about it: is this really useful? Can a real-world application benefit
    from this? No. What we are really after, what would be useful, is a division of
    labor, that is to say, have the child perform some task or tasks, and the parent
    perform some other task(s), in parallel. That makes the fork attractive and useful.'
  prefs: []
  type: TYPE_NORMAL
- en: For example, after the fork, have the child run the code of some function `foo` and
    the parent run the code of some other function `bar` (of course, these functions
    can internally invoke any number of other functions as well). Now that would be
    interesting and useful.
  prefs: []
  type: TYPE_NORMAL
- en: 'To arrange for this, we would require some means of *distinguishing between
    the parent and child after* *the* *fork*. Again, at first glance, it might appear
    that querying their PIDs (via the `getpid(2)`) would be the way to do this. Well,
    you could, but that''s a crude way to do so. The proper way to distinguish between
    the processes is built into the framework itself: It''s—guess what—based on the
    value returned by the fork.'
  prefs: []
  type: TYPE_NORMAL
- en: In general, you might quite correctly state that if a function is called once,
    it returns once. Well, fork is special—when you call a `fork(3)`, it returns twice*.* How?
    Think about it, the job of the fork is to create a copy of the parent, the child;
    once done, both processes must now return to user space from kernel mode; thus
    fork is called once but returns twice; once in the parent and once in the child
    process context.
  prefs: []
  type: TYPE_NORMAL
- en: 'The key though, is that the kernel guarantees that the return values in parent
    and child differ; here are the rules regarding the return value of `fork`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'On success:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The return value in the child process is zero (`0`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The return value in the parent process is a positive integer, the PID of the
    new child
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On failure, `-1` is returned and `errno` is set accordingly (do check!)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, here we go:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Fork rule #2**: *To determine whether you are running in the parent or child
    process, use the fork return value: it''s always 0 in the child, and the PID of
    the child in the parent*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s another detail: look for a moment at the `fork`''s signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The return value''s data type is a `pid_t`, certainly a `typedef`. What is
    it? Lets find out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'There we are: it''s just an integer, after all. But that''s not the point.
    The point here is that when writing code, do not assume it''s integer; just declare
    the data type as per what the man page specifies; in the case of `fork`, as` pid_t`.
    This way, even if in future the library developers change `pid_t` to, say, `long`,
    our code will just require a re-compile. We future-proof our code, keeping it
    portable.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand three fork rules, let's write a small, but better, fork-based application
    to demonstrate the same. In our demo program, we will write two simple functions `foo `and `bar`;
    their code is identical, they will emit a print and have the process sleep for
    the number of seconds passed to them as a parameter. The sleep is to mimic the
    working of a real program (of course, we can do better, but for now we'll just
    keep it simple).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `main `function is as follows (as usual, find the full source code on the
    GitHub repository, `ch10/fork4.c`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'First, here is a number of points to note:'
  prefs: []
  type: TYPE_NORMAL
- en: The return variable has been declared as `pid_t`*.*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Rule #1—execution in both the parent and child process continues at the instruction
    following the fork. Here, the instruction following the fork is not the switch (as
    is commonly mistaken), but rather the initialization of the variable `ret`! Think
    about it: it will guarantee that `ret` is initialized twice*:* once in the parent
    and once in the child, but to different values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Rule #2—to determine whether you are running in the parent or child process,
    use the fork return value: it''s always `0` in the child, and the PID of the child
    in the parent. Ah, thus we see that the effect of both rules is to make sure that `ret `gets
    correctly initialized and, therefore, we can switch correctly'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A bit of an aside—the need for input validation. Have a look at the parameters
    we pass to the `fork4` program as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Need we say more (see the output)? This is a defect (a bug). As mentioned in
    the source code comment, we leave the validation of the two parameters as a small
    exercise to the reader.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of an `if `condition, we would prefer to use the switch-case syntax;
    in your author's opinion, it makes the code more readable and thus better maintainable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we learned in rule 2, fork returns 0 in the child and the PID of the child
    in the parent; we use this knowledge in the switch-case and we thus effectively,
    and very readably, distinguish between the child and parent in the code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When the child process ID is done, we do not have it call *break*; instead,
    we have it exit. The reason should be obvious: clarity. Have the child do whatever
    it requires within its business logic (`foo()`), and then simply have it go away.
    No fuss; clean code. (If we did use a break, we would require another `if` condition
    after the `switch `statement; this would be ugly and harder to understand.)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The parent process falls though the switch-case, it just emits a print, and
    exits.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Because the functions `foo` and `bar` are identical, we show the code for `foo` only
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'OK, let''s run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we chose to keep the child alive for three seconds and the
    parent alive for seven seconds respectively. Study the output: the return values
    from fork are as expected.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s run it again but in the background (Also, we give more sleep time,
    10 seconds and 20 seconds to the child and parent respectively.) Back on the shell,
    we shall use `ps(1)` to see the parent and child processes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ps -l` (l: long listing) reveals more details about each process. (For
    example, we can see both the PID as well as the PPID.)'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding output, did you notice how the PPID (parent process ID) of
    the `fork4` parent happens to be the value `32106` and the PID is `308` . Isn't
    this odd? You usually expect the PPID to be a smaller number than the PID. This
    is often true, but not always! The reality is that the kernel recycles PIDs from
    the earliest available value.
  prefs: []
  type: TYPE_NORMAL
- en: '**An experiment to simulate work in the child and parent processes**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s do this: We create a copy of the `fork4.c` program, calling it `ch10/fork4_prnum.c`.
    Then, we modify the code slightly: We eliminate the functions `foo` and `bar`*,* and,
    instead of just sleeping, we have the processes simulate some real work by invoking
    a simple macro `DELAY_LOOP`. (The code is in the header file `common.h` .) The
    macro prints a given character a given number of times, which we pass as input
    parameters to `fork4_prnum`. Here is a sample run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `DELAY_LOOP` macro is coded to print the character `p` (for parent) and `c` (for *c*hild);
    the number of times it's printed is passed along as parameters. You can quite
    literally see the scheduler context switching between the parent and child process!
    (the interleaved `p`'s and `c`'s demonstrate when each of them has the CPU).
  prefs: []
  type: TYPE_NORMAL
- en: 'To be pedantic, we should ensure both processes run on exactly one CPU; this
    can be easily achieved with the `taskset(1)` utility on Linux. We run `taskset`specifying
    a CPU mask of `0` implying that the job(s) should run only on the CPU `0` . (Again,
    we leave it as a simple look-up exercise for the reader: check out the man page
    on `taskset(1)`, and learn how to use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We recommend that you actually try out these programs on their system to get
    a feel for how they work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fork rule #3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Fork rule #3**: *After a successful fork, both the parent and child process
    execute code in parallel*.'
  prefs: []
  type: TYPE_NORMAL
- en: At first glance, this rule looks pretty much the same as the first rule. But
    no, what's being stressed here is parallelism. The parent's and child's execution
    paths run in parallel with each other.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might wonder how on a single (uni) processor system, this can be? Well,
    that''s right: a fundamental attribute of a modern processor is that exactly one
    machine instruction can run at any given point in time. So, if we''re on a uniprocessor
    box, it just means that the processes will be time-slicing (or timesharing) on
    the CPU. So, it''s pseudo-parallel; however, the speed of a modern CPU being what
    it is, a human user will perceive the execution as being in parallel. On a multicore
    (SMP) system, they would, or could, run truly in parallel. So, the detail regarding
    a uni-processor is just that: a detail. The key point is that we should visualize
    both the parent and child as executing code in parallel.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in the previous code example, this rule tells us that the entire code paths
    of the parent and child processes will run in parallel; visualizing this parallelism
    is really the initial difficulty of the fork for folks new to it! To help  with precisely
    that, see the following figures (though we only show the code of the switch-case for
    brevity): the parent''s code path is highlighted in one color (red), and the child''s
    code path in another color (blue):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/13eae568-7a7f-4c6c-8f7f-607316de7906.png)'
  prefs: []
  type: TYPE_IMG
- en: This is the key point: the code in blue and the code in red, the child and parent
    processes, run in parallel!
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/158ee1e0-301c-44d0-82e7-271c4a906d55.png)'
  prefs: []
  type: TYPE_IMG
- en: In the second diagram, the blue and red timeline arrows are used to again depict
    this parallelism.
  prefs: []
  type: TYPE_NORMAL
- en: Atomic execution?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While seeing the preceding code flow diagrams, you can be misled into believing
    that once the process starts executing its code, it continues undisturbed until
    it finishes. This is certainly not necessarily going to happen; in reality, the
    process will often get context switched out of and back into the CPU as they run.
  prefs: []
  type: TYPE_NORMAL
- en: 'This leads us to an important point: *atomic execution.* A piece of code is
    considered to be atomic IFF (if and only if) it always runs to completion without
    interruption. Atomicity, especially in userspace, is not guaranteed: often, the
    process (or thread) execution is interrupted or preempted (sources of interruption/preemption
    include hardware interrupts, faults, or exceptions, and scheduler context switching).
    Keeping a code section atomic within the kernel can be arranged, though.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Fork rule #4 – data'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When a parent process forks*,* we understand that the child is created; it
    is a copy of the parent. This will include the VAS, and, thus, the data and stack
    segments. Keeping this fact in mind, check out the following code snippet (`ch10/fork5.c`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The preceding program (`ch10/fork5`) has an initialized global variable `g` and
    an initialized local variable `loc`. The parent process, after fork, sleeps for
    two seconds thus more-or-less guaranteeing that the child process runs first (this
    kind of synchronization is incorrect in production quality code; we shall address
    this point in detail later in this chapter). Both the child and parent processes
    work on the global and local variables; the key question here is this*:* will
    the data get corrupted?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s just run it and see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Well, the data variables are not corrupted. Again, the key point here is this:
    as the child has a copy of the parent''s variables, all goes well. They change
    independently of one another; they do not step on each other''s toes. So, consider
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Fork rule #4**: *Data is copied across the fork, not shared*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Fork rule #5 – racing'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Notice the `#if 1` and `#endif` surrounding the `sleep(2);` statement in the
    previous code (`ch10/fork5.c`)? It of course implies that the code will be compiled
    and thus run.
  prefs: []
  type: TYPE_NORMAL
- en: 'What if we change the `#if 1` to `#if 0` ? It''s obvious, the `sleep(2);` statement
    is effectively compiled out. Let''s do this: rebuild and re-run the `fork5` program.
    What will now happen?'
  prefs: []
  type: TYPE_NORMAL
- en: 'Think about this: fork rule #4 tells us the story. After the fork, we will
    still have the child and parent processes working on separate copies of the data
    variables; hence, the values we saw earlier will not change.'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, this time, there is no sleep to crudely synchronize the parent and
    child; thus, the question arises, will the `printf `for the child or parent code
    (displaying the variable values) run first? In other words, the question we are
    really asking is this: in the absence of any kind of synchronization primitive,
    after the `fork(2)`, which process will get the processor first: parent or child? The
    short answer is the next rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Fork rule #5**: *After the fork, the order of execution between the parent
    and child process is indeterminate*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Indeterminate? Well, this is a fancy way to say *we really have no idea *or *it''s
    unpredictable*. So that is the deal: the systems developer should not try to predict
    the order of execution. Running the modified `fork5 `(`no sleep(2)` statement)
    now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Ah, the parent ran first. That does not really mean anything! The parent might
    run first the next 50,000 times you try it out, but on the 50,001st trial run,
    the child process may run first. Leave it alone: it''s unpredictable.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This leads us to another key point (common in software): We have what''s called
    a **race condition** here. A race is literally what it says: we cannot predict
    with certainty who will be the winner. In the previous program, we really don''t
    care whether the parent or child process wins the race (runs first): this is called
    a benign race condition. But often in software design we do actually care; in
    such cases, we need a way to guarantee the winner. In other words, to defeat the
    race. This is called synchronization. (As mentioned earlier, we shall address
    this point in detail later in this chapter.)'
  prefs: []
  type: TYPE_NORMAL
- en: The process and open files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To clearly understand the effect of fork on open files, we need to slightly
    digress and briefly understand some background information.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, for those readers very new to performing I/O on files within the Unix
    paradigm, it will be beneficial to first read through the [Appendix A](https://www.packtpub.com/sites/default/files/downloads/File_IO_Essentials.pdf),
    *File I/O Essentials*, before tackling this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'A Unix/Linux process, upon startup, will by default be assigned three open
    files; we''ve discussed these basic points earlier in the book. For convenience,
    the three open files are called the `stdin`*,* `stdout`*,* and `stderr `of the
    process; they auto-default to the keyboard, the monitor, and, again, the monitor
    for `stdin`*,* `stdout`*, *and `stderr` respectively. Not only that, real applications
    will certainly open other files as they perform their tasks. Recall the layered
    system architecture; if a Linux application opens a file using the `fopen(3)` library
    API, it will ultimately boil down to the `open(2)` system call, which returns
    a handle to the open file, called a** file descriptor**. (Think about it: consider
    a Java app running on Linux that opens a file: Ultimately, this time, via the
    JVM, the work will be done via the same `open(2)` system call!)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The point here is this: the kernel stores every process''s open files within
    a data structure (in classic Unix terminology, it''s called the **Open File Descriptor
    Table** (**OFDT**). We saw earlier in the section that talked about characteristics
    inherited by the child process upon fork, thatopen files are indeed inherited
    by the child. To facilitate this discussion, consider the following pseudo-code
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the file `myfile `is now available to both processes and can be worked
    upon via the file descriptor `fd`! But hang on: it should be clear that working
    on the same file simultaneously by both child and parent processes could certainly corrupt the
    file; or if not the file content, at least the application. To perceive this,
    consider the function `work_on_file` *(*pseudo-code):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Fork rule #6 – open files'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can see that without any synchronization, havoc would result! Hence the
    next fork rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Fork rule #6**: *Open files are (loosely) shared across the fork****.***'
  prefs: []
  type: TYPE_NORMAL
- en: 'The upshot of all that is this: the systems programmer must understand that,
    if the parent process has opened a file (or files), naively working on the file
    simultaneously (remember fork rule #3!) will likely cause bugs. A key reason is
    this: although the processes are distinct, the object they work upon, the open
    file, and, more precisely, its inode, is one distinct object and thus shared.
    In fact, the file''s *seek* *position* is an attribute of the inode; blindly re-positioning
    the seek pointer in parent and child without synchronization will pretty much
    guarantee problems.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are broadly two choices to keep things running smoothly:'
  prefs: []
  type: TYPE_NORMAL
- en: Have one of the process's close the file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Synchronize access to the open file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The first of them keeps things simple but is of limited use in real-world applications;
    they would usually require that the file remains open. Thus, the second choice:
    how exactly do you synchronize access to the open file?'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, the details are not covered in this book, but, very briefly, you can
    synchronize file I/O between processes like so:'
  prefs: []
  type: TYPE_NORMAL
- en: Via the SysV IPC or POSIX semaphore
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Via file locking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first one works, but crudely. It's not considered the right way. The second
    solution, using file locking, is definitely the preferred one. (File locking is
    not covered in detail here, please refer the *Further reading *section for a link
    to an excellent tutorial on the same on the GitHub repository.)
  prefs: []
  type: TYPE_NORMAL
- en: It's also important to realize that when either the parent or child process
    closes the open file, its access to the open file is closed; the file is still
    open in the other process. This is really what is meant by the phrase "loosely
    shared".
  prefs: []
  type: TYPE_NORMAL
- en: As a quick way to demo this issue, we write a simple program `ch10/fork_r6_of.c `
    (here, **of** stands for **open file**).We leave it to the reader to go through
    the source code; an explanation and sample output follows.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we have the process open a regular file tst; then, we have the child
    process do this: seek to offset 10, and write *numlines* (equal to 100) lines
    of `c`''s. In parallel, we have the parent process do this: seek to offset 10+(80*100),
    and write *numlines* lines of p''s. So when we have finished and we examine the
    file, we expect that we have 100 lines of `c`s and 100 lines of `p`s. But, hey,
    it does not actually happen that way. Here''s the actual run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the test file''s content after the run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The `p`s and `c`s interleave! Yes, indeed, because the processes ran in parallel without
    any form of synchronization. (By examining the file content, we can literally
    see how the kernel CPU scheduler context-switched between the parent and the child
    processes). By not using synchronization, we have set up a race. So how do we
    set this right? It was mentioned earlier: file locking is really the answer (Note:
    do not attempt to synchronize with the silly `sleep(2)` in the parent kind of
    code we''ve used; that''s just for demonstration; Also, we shall cover the proper
    way to synchronize the child and parent shortly.)'
  prefs: []
  type: TYPE_NORMAL
- en: Open files and security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A key point again regarding security, for both the exec and fork scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you perform an `exec `operation, the predecessor process''s VAS is essentially
    overwritten by that of the successor process. However, realize that the predecessor
    process''s open files (held within the OS in a per-process structure called the
    OFDT, mentioned earlier) remain intact and are, in effect, inherited by the successor
    process. This could pose a serious security threat. Think about it: what if a
    security-sensitive file being used by the predecessor is not closed and an exec performed?
    The successor now has access to it via its file descriptor, whether it exploits
    that knowledge or not.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The same argument holds true for the fork; if a parent process has a security-sensitive
    file open and then forks, the child too has access to the file (fork rule #6).'
  prefs: []
  type: TYPE_NORMAL
- en: To counter exactly this issue, from the Linux 2.6.23 kernel, the `open(2)` system
    call, includes a new flag: `O_CLOEXEC`. When this flag is specified within the `open(2)`,
    the corresponding file will be closed upon any future `exec `operation performed
    by that process. (In earlier kernels, developers had to perform an explicit `F_SETFD` via `fcntl(2)` to
    set the `FD_CLOEXEC` bit).
  prefs: []
  type: TYPE_NORMAL
- en: When working with fork, the programmer must include logic to close any security-sensitive
    files in the parent prior to the fork.
  prefs: []
  type: TYPE_NORMAL
- en: Malloc and the fork
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A common mistake that programmers might stumble upon or make, is this: consider
    a successful memory allocation done in a process, with say, `p = malloc(2048)`.
    Assume that the variable `p`is global. Some time later, the process forks. The
    developer now wants the parent process to communicate some information to the
    child; so, she says, lets just write into the shared buffer `p`, and the job will
    be done. No, it does not work! Let''s elaborate: the malloced buffer is visible
    to both processes, but not in the way they think. The mistaken assumption is that
    the malloced buffer is shared between the parent and child process; it is not
    shared, it''s copied to the child''s VAS. Please recall fork rule #4: Data is
    not shared; it''s copied across the fork.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We must test this case; have a look at the following code snippet (source file: `ch10/fork_malloc_test.c`):'
  prefs: []
  type: TYPE_NORMAL
- en: For readability, only the relevant parts of the code are displayed here; to
    view and run it, the entire source code is available here: [https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux](https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The `disp_few` function to display a few (16) bytes of the memory buffer is
    simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We build and run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Immediately, the first thing to notice is this: the pointer to the memory buffer
    (`0x1802260`) in both the parent and child process is the same leading one to
    the conclusion that it''s the same memory buffer being pointed at. Well, it''s
    not; it''s an easy mistake to make. Check out the *content* of the malloced buffer
    in the parent and child; it''s `p`s in the parent and `c`s in the child; if it
    were really the very same buffer, the content would be identical. So, then, what
    is going on?'
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned several times now, data is copied across the fork, not shared
    *(*our fork rule #4). OK, but then how come the address is the same? There are
    two reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: The address is a virtual address (not a physical address, as we should well
    know from the discussions in [Chapter 2](976fc2af-8bb4-4060-96cd-3b921682ed75.xhtml),
    *Virtual Memory*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is actually the same virtual address; modern OSes such as Linux do not, immediately
    on fork, make a copy of the data and stack segments; they use an optimized semantic
    called **copy-on-write** (**COW**).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: COW in a nutshell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This requires a bit of explanation. Until now, to keep the discussion conceptually
    simple, we have said that upon fork, the kernel copies all the parent's VAS segments
    (plus all the other inherited process attributes) to the new child process. This
    is an exaggeration; the reality is, attempting to do this would make the `fork(2)` untenable
    in practice as it would require too much RAM and too much time. (As it is, even
    with several optimizations, the fork is still considered heavyweight.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s digress: one of the optimizations, upon fork is that the kernel does
    not copy the text (code) segment into the child; it merely shares the parent''s
    text segment (virtual) pages with the child process. This works well, as text
    is in any case only readable and executable (r-x); thus, as it can never change,
    why make a copy?'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what about the data and stack segments? Their pages are read-write (rw-)
    after all so how can the OS just share them with the child? Ah, that''s where
    the COW semantics come in handy. To understand COW, consider a single virtual
    page that has been marked as COW by the OS. It essentially means this: As long
    as both processes (parent and child) treat the page as read-only, they can share
    it; no copy is necessary. But the moment one of them modifies (even a byte in)
    the page, the OS intervenes and creates a copy of the page, which is then handed
    off to the process that performed the write.'
  prefs: []
  type: TYPE_NORMAL
- en: So, if we have a global variable `g=5` and `fork(2)`, the page containing `g` is
    marked COW by the OS; the parent and child share it, until either writes to `g`.
    At that point, the OS creates a copy of the page containing the (updated) variable
    and hands it to the writer. Thus, the granularity of COW is a page.
  prefs: []
  type: TYPE_NORMAL
- en: As a matter of fact, COW is aggressively enforced by Linux to optimize to the
    maximum extent possible. Its not just the data and stack segments, most of the
    other inheritable process attributes we discussed earlier are actually not copied
    to the child, they are COW-shared, effectively making Linux's fork extremely efficient.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additional insight into these important points can be gained by noticing the
    same effect, the COW optimization, carried out on the data variables (globals
    and locals) as well; just run our test case program with any parameter and it
    internally runs a small test case on two variables: a global and a local:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice the addresses of the global `g` and the local `loc `are the same in
    the parent and child processes. But why? COW will have been performed as they
    have been written. Yes, but think: it''s all virtual addressing; the physical
    addresses will actually differ under the hood.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You sometimes gets the feeling that modern OSes go out of their way to confuse
    and confound the poor systems programmer! The two important points we made earlier
    seem to contradict each other:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Fork rule #4: Data is copied across the fork, not shared'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data/stack (and a lot else) is not actually copied upon fork, but rather COW-shared
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'How do we resolve this situation? It''s easy, actually: The first (our fork
    rule #4) is the correct way to think when working with the fork; the second statement
    is what really happens under the hood at the OS layer. It''s about optimization, that
    is all.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a suggestion: When wearing the hat of an application developer, do
    not get overly concerned with the  underlying OS''s COW optimization details;
    it''s more important to understand the intention rather than the optimization.
    Thus, as far as the Linux application developer using `fork(2)` is concerned,
    the key conceptual point that remains is fork rule #4: data is copied across the
    fork, not shared.'
  prefs: []
  type: TYPE_NORMAL
- en: Waiting and our simpsh project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Lets set ourselves an interesting learning exercise: a small project. We want
    to implement, using C on the Linux OS of course, a very simple shell of our own.
    Lets call it our `simpsh`—simple shell—project.'
  prefs: []
  type: TYPE_NORMAL
- en: Note: simpsh is a very small, minimally functioning shell. It works with only single-word commands.
    It does not support features such as redirection, piping, shell built-ins, and
    so on. It's meant to be a learning exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'The specification, for now at least is this: Display a prompt (say `>>`), accept
    a user command at the prompt, and execute it. This is the stopping condition:
    if the user enters `quit`, terminate (similar to typing `logout`, `exit`, or `Ctrl
    + D` on an actual shell process).'
  prefs: []
  type: TYPE_NORMAL
- en: 'It seems pretty straightforward: In our C program you get into a loop, display
    the required prompt, accept the user input (let''s use the `fgets(3)`to do this) into
    a `cmd `variable, and then use one of the exec family APIs (a simple `execl(3)`
    sounds promising) to execute it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, yes, except, how could you forget, the predecessor process is effectively
    lost after the exec operation succeeds! Our shell will be lost once we exec anything (just
    like our earlier experiment 1: on the CLI and experiment 2—demonstrated).'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if with the previous naive approach, we attempt to execute `ps(1)`with
    our shell simpsh, it would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3dd4bb45-0b97-4f6b-83a7-81d59fb769e3.png)'
  prefs: []
  type: TYPE_IMG
- en: The Unix fork-exec semantic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, that does not work. What we need, really, is a way for our simple shell simpsh to
    remain alive and well *after* the execoperation, but how can we achieve that?
  prefs: []
  type: TYPE_NORMAL
- en: 'The fork is the answer! Here''s what we''ll do: after the user supplies input
    (a command), we have our shell fork. We now have two identical shells alive: the
    original parent (let''s say it has PID x) and the brand new child shell (PID y). The
    child shell is used as the sacrificial lamb: We have it exec the user command. So,
    yes, the child is the predecessor process that is impossible to return to; but
    that''s OK as we have the parent shell process alive and well!'
  prefs: []
  type: TYPE_NORMAL
- en: 'This well-known technique is called the *fork-exec* semantic. It combines what
    several other OSes call a spawn into two discrete operations: a process creation
    (fork), and a process execution (exec). Once again, the brilliant Unix design
    is shown off:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d02c4005-7234-4da0-9e9b-8399cec8896c.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding diagram, visualize the timeline as the (horizontal) x-axis.
    Also, we use the color blue to show the child's execution path.
  prefs: []
  type: TYPE_NORMAL
- en: Once the parent shell detects that the execed child has completed, it displays
    the shell prompt again.
  prefs: []
  type: TYPE_NORMAL
- en: The need to wait
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The fork-execis really interesting, but hang on a second: While the child process
    performs an `exec` on the user command, and the successor is running (indicated
    by the dot-dash blue line in the preceding diagram), what should the parent process
    do? Obviously, it should wait, but for how long? Should we have it sleep? Well,
    no, as sleep takes the number of seconds to sleep as its argument. We do not know
    in advance how long the successor will take (it could be milliseconds, it could
    be months). The correct thing to do is this: have the parent process wait until
    the child (now the successor) dies.'
  prefs: []
  type: TYPE_NORMAL
- en: This is precisely what the `wait(2)` API is designed to do. When the parent
    process issues the `wait(2)` API, it is put to sleep; the moment its child dies,
    it's woken up!
  prefs: []
  type: TYPE_NORMAL
- en: Performing the wait
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `wait(2)` API is a classic example of a blocking call: The calling process
    is put into a sleep state until the event it is waiting (or blocking) upon occurs.
    When the event does occur, it is woken up and continues to run.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, think about it: a process forks; the parent process then issues the `wait
    (2)`API, and the event it is blocking upon is the death of the child! The child
    continues to run, of course; when the child does die, the kernel wakes up, or unblocks, the
    parent; it now continues to execute its code. Here is the signature of `wait(2)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: For now, we shall ignore the to `wait(2)`; we shall just pass NULL (or `0`)
    (of course, we shall cover it shortly).
  prefs: []
  type: TYPE_NORMAL
- en: Defeating the race after fork
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Recall the example code we saw earlier in chapter `ch10/fork5.c`.In this program,
    we artificially, and crudely, waited for the child process by introducing a `sleep(2);`statement
    in the parent''s code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This is not good enough: What if the child process takes longer than two seconds
    to complete its work? If it takes just a few milliseconds, then we unnecessarily
    waste time.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how we resolve the race: Who will run first, the parent or the child?
    Clearly, fork rule #5 tells us that it''s indeterminate. But, in real-world code,
    we need a way to guarantee that one of them indeed runs first—say, the child process.
    With the wait API, we now we have a proper solution! We change the preceding code
    snippet to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Think about how this works: After the fork, it''s a race: If the child process
    does run first, then no harm is done. However, at some point in the near future,
    the parent process will get the CPU; that''s fine as all it does is block upon
    the child by calling wait. If the parent does run first after the fork, the same
    thing occurs: it blocks upon the child by calling wait. We have effectively defeated
    the race! By issuing the wait as the first thing done in the parent process after
    fork, we effectively guarantee that the child runs first.'
  prefs: []
  type: TYPE_NORMAL
- en: Putting it together – our simpsh project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, now that we have all the bits and pieces in place—namely, the fork-execsemantic
    and the `wait`API—we can see how our simple shell should be designed.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the C program, get into a loop, display the required prompt, accept user
    input (let''s use the `fgets(3)`to do this—why? Please read the upcoming tip) into
    a `cmd` variable, and then fork. In the child code (use fork rule #2 to distinguish
    between the parent and child), use one of the many exec family APIs (a simple `execlp(3)` sounds
    promising here) to execute the user supplied command. In parallel (recall fork
    rule #3), have the parent process invoke the wait API; the parent now sleeps until the
    child dies. Now loop around again and repeat the whole thing until the user types `''quit''` to
    quit. Everyone''s happy!'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2992e6e4-fcea-4b60-8bee-81d7b9ebc4bb.png)'
  prefs: []
  type: TYPE_IMG
- en: In effect, we now have a `fork-exec-wait `semantic that is exploited!
  prefs: []
  type: TYPE_NORMAL
- en: '`fgets(3)`: For security reasons, do not use the traditionally taught APIs
    such as `gets(3)` or `scanf(3)` to receive user input; they are poorly implemented,
    and they do not provide any bounds-checking capabilities. The `fgets(3)` does;
    thus, using it, or `getline(3)`, is far superior security-wise. (Again, as mentioned
    earlier in this book, hackers exploit these vulnerabilities in commonly used APIs
    to perform stack-smashing, or other types of attacks.)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, our simpsh shell is rather limited in scope: it only works with *s*ingle-word
    commands (such as `ps`, `ls`, `vi`, `w`, and so on). Read the code and think about
    why this is the case.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here we go (source code: `ch10/simpsh_v1.c`):'
  prefs: []
  type: TYPE_NORMAL
- en: For readability, only the relevant parts of the code are displayed here; to view
    and run it, the entire source code is available here: [https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux](https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we enter the loop, accept the user's command via the `getcmd` function
    we wrote (the `fgets` is issued within it), and then check whether the user has
    typed `quit`, in which case we exit.
  prefs: []
  type: TYPE_NORMAL
- en: 'The real work, the `fork-exec-wait` semantic, happens here, within the loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: (The logic pertaining to argument passing—displaying the help screen, verbose
    switch, the actual `fgets`, the calloc/free, and so on, is not explicitly shown;
    please refer to the source file `simpsh_v1.c`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s give it a try:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We run the program in verbose mode; you can see the shell prompt string `>>` 
    as well as every verbose print; they are prefixed with `[v]:`. Notice how it works
    for single word commands; the moment we pass something unknown or with more than
    one word (for example `www` and `uname -a` ), the `execlp(3)` fails; we catch
    the failure and emit a warning message; the program continues until the user quits.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is another quick experiment: We can use our `simpsh_v1`program to spawn
    another shell (`/bin/sh`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: It works as expected (hey, you could even experiment with spawning the same
    process `simpsh_v1`). So, there we are, a first very simple but functioning shell.
  prefs: []
  type: TYPE_NORMAL
- en: Why exactly do commands that are more than one word long fail? The answer lies
    in how we're executing the successor, using the `execlp(3)` API. Recall, for execlp, we
    are to pass the program name (the PATH will be auto-searched of course) and all
    arguments, starting with `argv[0]`. Well, in our simple implementation, we just
    don't pass anything more than the first argument `argv[0]`; that's why.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, how do we make it work with commands with any number of arguments? Well,
    it really involves some amount of string-processing work: We will have to tokenize the
    arguments into individual strings, initializing an `argv`array of pointers to
    them, and using that `argv`via the `execv[pe]` API. We leave it as a slightly
    more challenging exercise to the reader! (Tip: the C library provides APIs for
    tokenizing strings; `strtok(3)`*,* `strtok_r(3)`*; *look them up).'
  prefs: []
  type: TYPE_NORMAL
- en: In effect, our simpsh project is a simplistic implementation of the `system(3)`library
    API. Note that from a security viewpoint, it's always recommended to use field-proven
    and tested APIs like `system(3)`rather than a home-grown` fork-exec-wait` piece
    of code. Here, of course, we code it for learning purposes.
  prefs: []
  type: TYPE_NORMAL
- en: The wait API – details
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In our simpsh program, we did use the `wait(2)` API, but have not really delved
    into details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The thing to understand is this: `wait(2)` is a blocking call; it causes the
    calling process to block until a child process dies.
  prefs: []
  type: TYPE_NORMAL
- en: 'To be technically correct, the `wait(2)` (and associated APIs that we shall
    see later) actually block upon the child process(es) undergoing a state change;
    well, the state change is the child''s death, right? Yes, but it''s really important
    to understand that it''s not just that: the possible state changes are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The child process terminates as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Normally (by falling off `main`, or calling `[_]exit()`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Abnormally (killed by a signal).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The child was sent a signal that stopped it (usually `SIGSTOP` or `SIGTSTP`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Having been stopped, it was delivered a signal that continued (resumed) it (usually `SIGCONT`;
    we shall cover signaling in detail in the next chapter).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The generic `wait(2)` system call, though, blocks upon the death (termination)
    of the child, not any of the other signal-related state changes mentioned earlier.
    (Can that be done? Yes, indeed, we cover the `waitpid(2)`system call later in
    this chapter).
  prefs: []
  type: TYPE_NORMAL
- en: 'The parameter to wait, is a pointer to an integer `wstatus`. In reality, it
    is treated as more of a return rather than a parameter to pass along; this is
    a pretty common C programming technique: Treat a parameter as a return value.
    System calls on Linux often use it; this technique is often referred to as a value-result or
    an in-out parameter. Think about this: We pass the address of the variable; the
    API internally, having the address, can update it (poke it).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The next thing regarding the parameter `wstatus` is this: The integer is treated
    as a bitmask,not as an absolute value. This, again, is a common C optimization
    trick that programmers employ: We can fit several pieces of information into an
    integer by treating it as a bitmask. So, how do you interpret this returned bitmask?
    For portability reasons, the C library provides predefined macros that help us
    interpret the bitmask (these are in `<sys/wait.h>`usually). The macros work in
    pairs: The first macro returns a Boolean value; if it returns true, look up the
    second macro''s result; if it returns false, disregard the second macro completely.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A digression: a process can die in one of two ways: normally or abnormally. Normal
    termination implies that the process died voluntarily; it just fell off `main()` or called `exit(3)` or `_exit(2)` passing
    the exit status as an argument (the convention for exit status: zero  implies
    success, non-zero implies failure and is treated as the failure code). On the
    other hand, abnormal termination implies that the process died involuntarily—it
    was killed, typically via a signal.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the wait macro pairs and their meaning:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **First macro** | **Second macro** | **Meaning** |'
  prefs: []
  type: TYPE_TB
- en: '| `WIFEXITED` | `WEXITSTATUS` | Child died normally: `WIFEXITED` is true; 
    then, `WEXITSTATUS`—exit status of child. Child died abnormally: `WIFEXITED` is
    false'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `WIFSIGNALED` | `WTERMSIG` | Child died due to signal: `WIFSIGNALED` is true;
    then, `WTERMSIG` is the signal that killed it. |'
  prefs: []
  type: TYPE_TB
- en: '|  | `WCOREDUMP` | True if, upon death, the child produced a core dump. |'
  prefs: []
  type: TYPE_TB
- en: '| `WIFSTOPPED` | `WSTOPSIG` | True if child was stopped by signal; then, `WSTOPSIG`
    is the signal that stopped it. |'
  prefs: []
  type: TYPE_TB
- en: '| `WIFCONTINUED` | - | True if child was stopped and later resumed (continued)
    by a signal (`SIGCONT`). |'
  prefs: []
  type: TYPE_TB
- en: (In the row containing `WCOREDUMP`, the indentation is intended to mean that
    you can tell that `WCOREDUMP` is only meaningful if `WIFSIGNALED` is true).
  prefs: []
  type: TYPE_NORMAL
- en: What about the actual return value itself of `wait(2)`? Clearly, `-1` indicates
    failure (and of course the kernel will set `errno` to reflect the cause of the
    failure); else, on success, it's the PID of the process that died, thus unblocking
    the parent's wait.
  prefs: []
  type: TYPE_NORMAL
- en: 'To try out the things we have just learned, we make a copy of the `simpsh_v1`program
    and call it `ch10/simpsh_v2.c`*. *Again, we only show the relevant snippets here;
    the complete source code files are on the book''s GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we now capture the return value of `wait (2)`(the PID of the
    child that changed state), and if we are running in verbose mode, we call our
    own function `interpret_wait`; it will provide output detailing what status change
    exactly occurred; here it is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The `VPRINT` macro is simple; it results in a `printf(3)`if the process is
    in verbose mode. We try the program (version 2) out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we run it in verbose mode; we can see that the child process `ps(1)` had
    a status change: It died normally, with an exit status of zero, indicating success.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Interesting: this is how bash knows whether the process that just ran succeeded
    or not; it plugs in the exit status—fetched via an API similar to `wait`*—*into
    the variable **`?`** (which you can access using  `$?` .)'
  prefs: []
  type: TYPE_NORMAL
- en: The scenarios of wait
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until now, we've covered the generic `wait(2)` API; however, we have only really
    discussed one possible scenario regarding the `wait`*; *there are several more.
    Let's check them out.
  prefs: []
  type: TYPE_NORMAL
- en: 'Wait scenario #1'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s the simple case (one we''ve already come across): a process forks, creating
    one child process. The parent subsequently issues the *wait *API; it now blocks on
    a status change in it''s child process; recall, the possible status changes the
    child can possibly go through are these:'
  prefs: []
  type: TYPE_NORMAL
- en: 'State transition from running (R): dead; that is to say, the child terminates
    (normally/abnormally)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: State transition from running/asleep (R|S|D) to stopped state (T); that is to
    say, it receives a signal causing it be stopped
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: State transition from stopped state (T) to ready-to-run (R); that is to say, from
    a stopped state to a ready-to-run state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (The state transitions and the letters representing the process state are covered
    in [Chapter 17](36229bac-c402-4d2f-b876-d1eb4aba8051.xhtml), *CPU Scheduling on
    Linux*, on scheduling). Whichever may occur, the fact is that the parent is unblocked and
    continues to execute its code path; the `wait(2) `API returns (along with which
    we receive the PID of the child that died or was signaled), as well as the detailed
    status bitmask.
  prefs: []
  type: TYPE_NORMAL
- en: 'Wait scenario #2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Consider this scenario: A process forks (creates) two children; let''s call
    the parent process P and the children C1 and C2\. Recall fork rule #3—the parent
    and the children processes will all continue to run in parallel. Now, P calls `wait`;
    what will happen?'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the answer: process P will remain blocked until one of the children
    dies (or stops), but which one? Any one; whichever one changes state first. So
    how will the systems programmer know which process dies or stopped? That''s easy:
    The return value is the PID of the process that died or stopped.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In other words, we devise a corollary: a wait blocks on a single child process;
    to block on n children requires n waits.'
  prefs: []
  type: TYPE_NORMAL
- en: An interesting exercise would be to construct the preceding scenario in code;
    ensure that the parent process indeed waits upon both children (this very exercise
    is mentioned as `fork2c` on the GitHub repository).
  prefs: []
  type: TYPE_NORMAL
- en: To have a parent wait upon all possible children, invoke the `wait`API as the
    condition of a while loop; as long as waitable children exist, it will block and
    return positive; the moment there are no waitable children, the `wait`returns
    `-1`; check for that as the condition to break out of the loop. Note though, that
    there are scenarios requiring a non-blocking wait to be set up; we shall cover
    these as well.
  prefs: []
  type: TYPE_NORMAL
- en: Fork bombs and creating more than one child
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Say we want to write code to create three children; would this, the code shown
    as follows, do it?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Of course not! (try it and see).
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall fork rule #1: Execution in both the parent and child process continues
    at the instruction following the fork. Thus, as you can see, after the first fork,
    both the parent and child run the second fork (so we''ll now have a total of four
    processes), and then all four will run the third fork (giving us a total of eight
    processes), and so on (havoc!).'
  prefs: []
  type: TYPE_NORMAL
- en: If fork is called in this uncontrolled manner—it ends up creating *2^3 = 8*
    children! In other words, it's exponential; n forks implies *2^n* children will
    be created in a runaway sprint.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine what damage can be done with this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: It's quite rightly called a fork bomb!—a type of **denial-of-service** (**DoS**)
    attack**. **
  prefs: []
  type: TYPE_NORMAL
- en: Interestingly, because of modern Unixes (including Linux of course) having COW-based
    copying semantics, the memory overhead incurred may not be that large. Of course,
    it still consumes huge amounts of CPU; also, a simple calloc within the while
    loop would cause memory to be eaten up as well.
  prefs: []
  type: TYPE_NORMAL
- en: By the way, carefully tuned resource limits (we studied this in an earlier chapter
    in detail) can help mitigate the fork bomb (and similar) DoS attack risks. Even
    better, would be careful tuning via cgroups for resource bandwidth control. Here
    is the fork bomb wikipedia link: [https://en.wikipedia.org/wiki/Fork_bomb](https://en.wikipedia.org/wiki/Fork_bomb).
  prefs: []
  type: TYPE_NORMAL
- en: OK, so, `fork(); fork();` is not the way to create two children. (Try out the
    exercise `Smallbomb` on the GitHub repository.)
  prefs: []
  type: TYPE_NORMAL
- en: 'How do you do so correctly? It''s straightforward: take into account the parent
    and child''s execution paths, distinguish between them (fork rule #2),and just
    have the parent create a second child process. This code snippet demonstrates
    the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Wait scenario #3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What if a process has no children, never had any children (a bachelor chap),
    and it issues the `wait(2)`API? At first glance, this seems to be a problem case,
    as perhaps it could cause deadlock; but, no, the kernel is smarter than that.
    The kernel code of `wait`checks, and upon finding that the calling process has
    no children (dead or alive or stopped or whatever), it simply *fails *the *wait.* (FYI, `errno`gets
    set to `ECHILD` implying the process had no unwaited-for children).
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, recall one of our golden rules: *never assume anything; always check
    for the failure case*.Importantly, our [Chapter 19](b6b41870-c02e-4379-af86-b5e501799c31.xhtml),
    *Troubleshooting and Best Practices*, covers such points.'
  prefs: []
  type: TYPE_NORMAL
- en: There is one more `wait` scenario; however, we need to cover more information
    first.
  prefs: []
  type: TYPE_NORMAL
- en: Variations on the wait  – APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a couple of additional system calls to perform the job of *waiting
    upon the child(ren) process(es)*; we cover them next.
  prefs: []
  type: TYPE_NORMAL
- en: The waitpid(2)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Consider that we have a process with three children; it is required that the
    parent waits (blocks) upon the termination of a particular child process. If we
    use the generic `wait` API, we have seen that it will get unblocked upon the state
    change of any of the children. The answer to this conundrum: the `waitpid(2)` system
    call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The first parameter `pid`is set to the PID of the child to wait upon. However,
    other values are possible; if `-1` is passed, it generically waits for any `waitable`
    child process. (There are other more arcane cases; we refer you to the man page
    for them). In other words, issuing this is equivalent to a generic `wait(&stat);` API
    call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The second parameter is the usual status integer bitmask that we saw in detail
    with the `wait` API.
  prefs: []
  type: TYPE_NORMAL
- en: 'The third parameter is called `options`; previously, we set it to zero, implying
    no special behavior. What other values can it take? Well, you can pass just zero
    or the bitwise OR of the following (it''s also a bitmask):'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Options parameter value** | **Meaning** |'
  prefs: []
  type: TYPE_TB
- en: '| `0` | Default, same as `wait(2)` |'
  prefs: []
  type: TYPE_TB
- en: '| `WNOHANG` | Only block upon live children; if there are none, return immediately
    |'
  prefs: []
  type: TYPE_TB
- en: '| `WUNTRACED` | Also unblock when a child process stops(and does not necessarily
    terminate) |'
  prefs: []
  type: TYPE_TB
- en: '| `WCONTINUED` | Also unblock when a stopped child process is resumed (via
    the `SIGCONT` signal being delivered to it) |'
  prefs: []
  type: TYPE_TB
- en: At first, the `WNOHANG` option might sound strange; how can you block upon anything
    but a live child? Well, with a little patience, we shall soon resolve this peculiarity.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test the `waitpid(2)`, we again  make a copy of our `simpsh_v2.c`and call
    it `ch10/simpsh_v3.c`; the only meaningful difference in the code is that we now
    use the `waitpid(2)`instead of the generic `wait`API, passing along options as
    required; from `ch10/simpsh_v3.c`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'We issue the `read`(a bash built-in) command, as it itself is a blocking call,
    so we know that the child process `read`will be alive and asleep. In another terminal
    window, we look up the PIDs of our `simpsh_v3`process and of the command we ran
    from within it (the `read`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: (The useful `pstree(1)`utility shows us the process tree's parent-child hierarchy.
    Look up it's man page for details).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we send `SIGTSTP` (the terminal stop signal) to the `read`process; it gets stopped:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Getting stopped is a status change that we are looking for! Recall, our waiting
    code now is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Thus, the moment the child stops the `WUNTRACED` option takes effect, and in
    the original terminal window we see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'We now continue the child by sending it the signal `SIGCONT`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'As our (parent) `waitpid(2)`is also using the `WIFCONTINUED` option, in the
    original Terminal window, we see this (though it does require the user to press
    the *Enter* key it seems):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: We have so much more control over the child(ren). (Young parents, please note!)
  prefs: []
  type: TYPE_NORMAL
- en: The `fork-exec-wait` Unixframework is powerful indeed.
  prefs: []
  type: TYPE_NORMAL
- en: The waitid (2)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For further fine tuning and control, there is the `waitid(2)`system call as
    well (from Linux 2.6.9):'
  prefs: []
  type: TYPE_NORMAL
- en: '`int **waitid**(idtype_t idtype, id_t id, siginfo_t *infop, int options);`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first two parameters will in effect specify the children to wait upon:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **waitid(2): 1st parameter: idtype** | **Second parameter: id ** |'
  prefs: []
  type: TYPE_TB
- en: '| `P_PID` | Set to the PID of the child to wait (block) upon |'
  prefs: []
  type: TYPE_TB
- en: '| `P_PGID` | Wait upon any child whose process group ID (PGID) matches this
    number |'
  prefs: []
  type: TYPE_TB
- en: '| `P_ALL` | Wait upon any child (this parameter is ignored) |'
  prefs: []
  type: TYPE_TB
- en: 'The fourth `options` parameter is similar to how it was used with the `waitpid(2)`,but
    not identical; there are some additional options that can be passed along; again,
    it''s a bitmask*,* not an absolute value: the `WNOHANG` and `WCONTINUED` options
    have the same meaning as with the `waitpid(2)` system call.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, the following options can be bitwise-ORed:'
  prefs: []
  type: TYPE_NORMAL
- en: '`WEXITED`: Block upon children that have (already) terminated (again, we shall
    soon make clear why this even exists)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WSTOPPED`: Block upon children that will enter the stopped state (similar
    to the `WUNTRACED `option)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WNOWAIT`: Block upon children, but once unblocked, leave them in a waitable
    state so that they can be waited-upon again with a later wait* API.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third parameter is a (large) data structure of type `siginfo_t`; (we shall
    cover details in [Chapter 11](99fafa09-8972-4d9f-b241-46caf9de98f3.xhtml), *Signaling
    - Part I*). On return of `waitid(2)`, this will get populated by the kernel. Various
    fields get set by the OS, among them, the PID of the child that changed state
    (`si_pid`), `si_signo` set to `SIGCHLD`, `si_status, si_code`. We intend to cover
    these in a later chapter (for now, please refer to the man page).
  prefs: []
  type: TYPE_NORMAL
- en: 'There are BSD variations of `wait`APIs too: the `wait3`and the` wait4`*. *However,
    these are nowadays considered outdated; use the `waitpid(2)`or `waitid(2)` APIs
    instead.'
  prefs: []
  type: TYPE_NORMAL
- en: The actual system call
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have seen several APIs that perform the work of having the parent process `wait `until
    the child changes state (dies, or stops, or resumes after stop):'
  prefs: []
  type: TYPE_NORMAL
- en: '`wait`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`waitpid`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`waitid`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`wait3`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`wait4`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Interestingly, and similar to the situation with the exec family APIs, the
    Linux implementation is such that most of the preceding APIs are library (`glibc`)
    wrappers: The fact is that, on the Linux OS, of all the preceding APIs, `wait4(2)`is
    the actual system call API.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Performing an `strace(1)`on a program that uses one of the `wait` APIs proves
    the point (we `strace`our `simpsh_v1`program, which calls `wait`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: This is the output of `strace`*:*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'While discussing performing an `strace`, another interesting question does
    arise: if you `strace`an application that calls `fork(2)`*, *after the `fork`API,
    will `strace`trace the execution path of the child process as well? By default,
    no, but just pass along the `-f` option, and it will!'
  prefs: []
  type: TYPE_NORMAL
- en: 'The man page on `strace(1)` says this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'In a similar vein, systems programmers are probably aware of the tremendously
    powerful GNU debugger—GDB. If one is debugging a multiprocess application with
    `gdb(1)`, how can one request GDB which process''s execution path to follow after
    encountering a fork in the instruction stream? The setting is called `follow-fork-mode`:
    in `gdb`; here, we show an example of setting the mode to `child`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'With respect to GDB: Debugging multi-process applications with GDB: Using the
    GDB `attach <PID>` command is useful to `attach` to another process (say, the
    child). GDB also provides a powerful `catch` command; see `help catch` in GDB
    for more details.'
  prefs: []
  type: TYPE_NORMAL
- en: A note on the vfork
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Decades ago, the BSD Unix developers came up with an efficient special case
    system call— the `vfork(2)`*. *The idea at the time, was to perform some optimizations
    where you performed a fork and almost immediately an exec in the child (the fork-exec, in
    other words). As we know, using the fork-exec is quite a common and useful semantic
    (the shell and network servers use it heavily). When the vfork is called instead
    of the fork, the kernel does not go through the heavy copying operations usually
    required; it optimizes things.
  prefs: []
  type: TYPE_NORMAL
- en: 'The bottom line is this: At the time, `vfork(2)` was useful on Unix; but today''s
    Linux `fork(2)` is as optimized as can be, rendering the `vfork` to the back door.
    It''s still there, for perhaps two reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: Compatibility—to aid the porting of BSD apps to Linux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is apparently useful on some arcane special Linuxes that run on MMU-less
    processors ( like uClinux)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On today's regular Linux platforms, it is not recommended to use the `vfork(2)`;
    just stick to the `fork(2)`.
  prefs: []
  type: TYPE_NORMAL
- en: More Unix weirdness
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'From fork rule #3, we understand that the parent and child processes run in
    parallel. What if one of them terminate? Will the other die too? Well, no, of
    course not; they are independent entities. However, there are side effects.'
  prefs: []
  type: TYPE_NORMAL
- en: Orphans
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Consider this scenario: A process forks, the parent and child are alive and
    running their individual code paths in parallel. Let''s say the parent''s PID
    is 100 and the child''s is 102, implying the child''s PPID is 100 of course.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The parent process, for whatever reason, dies. The child continues on without
    any trouble, except for a side effect: The moment the parent (PID 100) dies, the
    child''s PPID (100) is now invalid! Thus, the kernel intervenes, setting the child''s
    PPID to the overall mothership—the ancestor of all user space tasks, the root
    of the process tree—the init, or on recent Linux, the systemd, process! It''s
    PID is, by venerable Unix convention, always the number `1`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Terminology: the child that lost its immediate parent is now said to be re-parented
    by systemd (or init), and its PPID will thus be `1`; this child is now an orphan.'
  prefs: []
  type: TYPE_NORMAL
- en: There is a possibility that the overall ancestor process (init or systemd) does *not* have
    PID 1, and thus the orphan's PPID may not be 1; this can occur, for example, on
    Linux containersor custom namespaces.
  prefs: []
  type: TYPE_NORMAL
- en: We notice that the child's PPID value abruptly changed; thus, the systems programmer
    must ensure that they do *not *depend on the PPID value being the same (which
    can always be queried via the `getppid(2)`system call) for any reason!
  prefs: []
  type: TYPE_NORMAL
- en: Zombies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The orphaned process does not pose any problem; there is another scenario with
    the distinct possibility of a nasty problem arising out of it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this scenario: a process forks, the parent and child are alive and
    running their individual code paths in parallel. Let''s say the parent''s PID
    is 100 and the child''s is 102, implying the child''s PPID is 100 of course.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we delve into a further level of detail: the parent process is supposed
    to wait upon the termination of its children (via any of the available `wait*(2)`APIs
    of course); what if it does not? Ah, this is really the bad case.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine this scenario: the child process terminates, but the parent is not waiting
    (blocking) upon it; thus it continues to execute its code. The kernel, however,
    is not pleased: The Unix rule is that the parent process must block upon its children! As
    the parent isn''t, the kernel cannot afford to completely clean up the just-dead
    child; it does release the entire VAS freeing up all the memory, it does flush
    and close all open files, as well as other data structures, but it does not clear
    the child''s entry in the kernel''s process table. Thus, the dead child still
    has a perfectly valid PID and some miscellaneous information (it''s exit status,
    exit bitmask, and so on). The kernel keeps these details as this is the Unix way:
    the parent must wait upon its children and reap them, that is, fetch their termination
    status information, when they die. How does the parent process reap the child(ren)?
    Simple: by performing the wait!'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, think about it: The child has died; the parent has not bothered to *wait *for
    it; the kernel has cleaned up, to some extent, the child process. But it technically
    exists, as it''s half dead and half alive; it''s what we call a ***zombie process**.* In
    fact, this is a process state on Unix: Z for zombie (you can see this in the output
    of `ps -l`; additionally, the process is marked as *defunct*).'
  prefs: []
  type: TYPE_NORMAL
- en: 'So why not just kill off the zombie(s)? Well, they''re already dead; we cannot
    kill them. The reader might then query, well, so what? let them be. OK, there
    are two reasons that zombies cause real headaches on production systems:'
  prefs: []
  type: TYPE_NORMAL
- en: They take up a precious PID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The amount of kernel memory taken up by the zombie is not insignificant (and
    essentially is a waste)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, the bottom line is this: a couple of zombies might be OK, but dozens and
    hundreds, and more, are certainly not. You could reach a point where the system
    is so clogged with zombies that no other process can run—the `fork(2)` fails with `errno `set
    to `EAGAIN` (try again later) as no PIDs are available! It''s a dangerous situation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Linux kernel developers had the insight to provide a quick fix: if you
    notice zombies on the system, you can, at least temporarily, get rid of them by
    killing their parent process! (Once the parent is dead, of what use is it to have
    the zombies? The point was, they remained so that the parent could reap them by
    doing a wait). Note that this is merely a bandage, not a solution; the solution
    is to fix the code (see the following rule).'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a key point; in fact, what we call the wait scenario #4: the wait gets
    unblocked with children that already terminated, in effect, the zombies. In other
    words, you not only should, you must, wait upon all children; otherwise, zombies
    will occur (Note that the zombie is a valid process state on the Unix/Linux OS;
    every process, on the ''way'' to death will pass through the **zombie** (Z)  state.
    For most it''s transient; it should not remain in this state for any significant
    length of time).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Fork rule #7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All of this neatly brings us to our next rule of fork.
  prefs: []
  type: TYPE_NORMAL
- en: '**Fork rule #7**: *The parent process must wait (block) upon the termination
    (death) of every child, directly or indirectly*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The fact is that, just like the `malloc-free`, the `fork-wait` go together.
    There will be situations in real-world projects where it might look impossible
    for us to force the parent process to block on the wait  after the fork; we shall
    address how these seemingly difficult situations can be easily addressed (that''s
    why we refer to an indirect method as well; hint: it''s to do with signaling,
    the topic of the next chapter).'
  prefs: []
  type: TYPE_NORMAL
- en: The rules of fork – a summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For your convenience, this table summarizes the fork rules we have encoded
    in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Rule** | **The rule of fork** |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | After a successful fork, execution in both the parent and child process
    continues at the instruction following the fork |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | To determine whether you are running in the parent or child process,
    use the fork return value: it''s always `0` in the child, and the PID of the child
    in the parent |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | After a successful fork, both the parent and child process execute code
    in parallel |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | Data is copied across the fork, not shared |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | After the fork, the order of execution between the parent and child process
    is indeterminate |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | Open files are (loosely) shared across the fork |'
  prefs: []
  type: TYPE_TB
- en: '| 7 | The parent process must wait (block) upon the termination (death) of
    every child, directly or indirectly |'
  prefs: []
  type: TYPE_TB
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A core area of Unix/Linux systems programming is learning how to correctly handle
    the all-important `fork(2)`system call, to create a new process on the system.
    Using the `fork(2)`correctly takes a lot of deep insights. This chapter helped
    the systems developer by providing several key rules of fork. The concepts learned—the
    rules, working with data, open files, security issues, and so on—were revealed
    via several code examples. A lot of details on how to wait for your children processes
    correctly were discussed. What exactly are orphans and zombie processes, and why
    and how we should avoid zombies was dealt with too.
  prefs: []
  type: TYPE_NORMAL
