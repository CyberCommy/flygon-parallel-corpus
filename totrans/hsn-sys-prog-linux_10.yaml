- en: Process Creation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进程创建
- en: 'In the previous chapter, we learned how to handle a (fictional) application
    design and implementation requirement: getting our C program to execute (`exec`)
    another program altogether. However, the reality is that the discussion remains
    incomplete; this chapter on process creationwill fill in several gaps, and much
    more.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何处理（虚构的）应用程序设计和实现需求：让我们的C程序执行（`exec`）另一个完全不同的程序。然而，现实情况是讨论仍然不完整；这一章关于进程创建将填补一些空白，并且更多。
- en: 'In this chapter, you will learn about some core Unix/Linux systems programming
    concepts: the gory details required to correctly program the critical `fork(2)` system
    call to create a process. Along the journey, Unix aficionado terms such as blocking
    calls, orphans, and zombies are made clear as well. The material carefully brings
    out subtle points, turning the average developer into a proficient one. The reader
    will, in parallel, learn to write C code to implement the preceding key concepts
    in a Linux systems application. As usual, several code examples are used to clearly
    illustrate and harden the concepts taught.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习一些核心的Unix/Linux系统编程概念：正确编程关键的`fork(2)`系统调用所需的细节。在这个过程中，Unix爱好者术语如阻塞调用、孤儿和僵尸也将得到澄清。这些材料将仔细呈现出微妙的要点，将普通开发人员变成熟练的开发人员。同时，读者将学会编写C代码，以在Linux系统应用程序中实现前述关键概念。和往常一样，我们将使用多个代码示例来清楚地说明和巩固所教授的概念。
- en: 'The purpose of this chapter is to guide the Linux systems developer into the
    core system programming worlds of the Unix `fork-exec-wait` semantics and related
    areas. Briefly, we will focus upon the following areas, helping the reader learn:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目的是指导Linux系统开发人员进入Unix的核心系统编程世界，包括`fork-exec-wait`语义和相关领域。简而言之，我们将重点关注以下几个方面，帮助读者学习：
- en: The Unix process creation model
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unix进程创建模型
- en: The whys and the hows of it
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其中的原因和方法
- en: 'Deeper details, including:'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更深入的细节，包括：
- en: How the fork affects memory allocations, open files and so on, and security
    implications
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fork`如何影响内存分配、打开文件等，以及安全性影响'
- en: The several forms of the `wait` APIs
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wait` API的几种形式'
- en: How these APIs are made use of practically
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些API如何实际使用
- en: The rules of fork
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fork`的规则'
- en: Orphan and zombie processes
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 孤儿和僵尸进程
- en: Process creation
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进程创建
- en: 'Unless a Unix/Linux systems programmer has been living under a rock somewhere,
    they''ve certainly heard of, if not directly worked with, the `fork(2)` system
    call. Why is it so well known and important? The reason is simple: Unix is a multitasking
    OS; programmers must exploit the OS''s capabilities. To have an application multitask,
    we need to create multiple tasks or processes; the fork is the Unix way to create
    a process. In fact, to the typical systems programmer, fork is the only way available
    to create a process.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 除非Unix/Linux系统程序员一直生活在某个地方的岩石下，他们肯定听说过，如果不是直接使用过`fork(2)`系统调用。为什么它如此著名和重要？原因很简单：Unix是一个多任务操作系统；程序员必须利用操作系统的能力。要使应用程序多任务，我们需要创建多个任务或进程；`fork`是Unix创建进程的方式。事实上，对于典型的系统程序员来说，`fork`是创建进程的唯一可用方式。
- en: There is another system call to create a process or thread: `clone(2)`*.* It
    also creates, well, a custom process. It's not typically used by Linux application
    developers; library (typically the thread library) developers use it more. In
    this book, we do not explore `clone`; for one thing, it's very Linux-specific
    and non-portable; for another, it's more of a hidden API.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一个用于创建进程或线程的系统调用：`clone(2)`。它也创建一个自定义进程。它通常不被Linux应用程序开发人员使用；库（通常是线程库）开发人员更多地使用它。在本书中，我们不探讨`clone`；首先，它非常特定于Linux且不可移植；其次，它更像是一个隐藏的API。
- en: The other way to multitask is by multithreading of course, which will be covered
    in detail in later chapters.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种多任务的方式是通过多线程，当然，这将在后面的章节中详细介绍。
- en: How fork works
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`fork`的工作原理'
- en: 'In theory, the job description of the `fork(2)` system call can be crystallized
    down to one simple statement: *create an identical copy of the calling process*.
    The terminology we shall repeatedly encounter is as follows: the process-calling *fork* is
    called the **parent **and the newly created, newborn process is called the **child**.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，`fork(2)`系统调用的工作描述可以简化为一个简单的语句：*创建一个调用进程的相同副本*。我们将反复遇到的术语如下：调用`fork`的进程称为**父进程**，而新创建的、新生的进程称为**子进程**。
- en: Please note that, to begin with at least, we shall keep the discussion on how fork works
    purely conceptual and simple; later, we shall delve deeper and clarify how the
    OS performs several necessary optimizations.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，起初，我们将保持对`fork`工作方式的讨论纯粹概念化和简单；稍后，我们将深入探讨并澄清操作系统执行的几项必要优化。
- en: Fork is a system call; thus, the real work of process creation is carried out
    by the OS under the hood. Recall from [Chapter 2](976fc2af-8bb4-4060-96cd-3b921682ed75.xhtml),
    *Virtual Memory*, that the **virtual address space** (**VAS**) of a process is
    built out of homogeneous regions called **segments** (or **mappings**). Thus,
    when a child process is created, the OS will copy the parent's text, data (three
    of them), library (and other mappings), plus the stack segment to the child.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`fork`是一个系统调用；因此，进程创建的实际工作是由操作系统在后台完成的。回想一下[第2章](976fc2af-8bb4-4060-96cd-3b921682ed75.xhtml)中的*虚拟内存*，一个进程的**虚拟地址空间**（**VAS**）是由称为**段**（或**映射**）的同质区域构建而成。因此，当创建一个子进程时，操作系统将父进程的文本、数据（三个）、库（和其他映射），以及堆栈段复制到子进程中。'
- en: 'Hang on though; it does not stop there: There is more, much more, to a process
    than just its VAS. This includes open files, process credentials, scheduling information,
    filesystem structures, paging tables, namespaces (PIDs, and so on), audit information,
    locks, signal handling information, timers, alarms, resource limits, IPC structures,
    profiling (perf) information, security (LSM) pointers, seccomp, thread stacks
    and TLS, hardware context (CPU and other registers), and so on.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Many of the attributes mentioned earlier are well beyond the scope of this book,
    and we shall not attempt to delve into them. The idea is to show that there is
    much more to a process than just VAS.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Phew! So, performing a fork involves the kernel copying several things from
    the parent to the child process. But, think about it: not all attributes are directly
    inherited by the child from the parent (many are, but certainly not all are).
    For example, the process PID and PPID (parent PID) is not inherited (can you figure
    out why?).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: 'As a first-level enumeration, the following process attributesare inherited
    by the child process upon fork (meaning, it-the new born child-gets a copy of
    the parent''s attributes with the same content):'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: 'The **VAS**:'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Text
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Data:'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initialized
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uninitialized (bss)
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Heap
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Library segments
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other mappings (for example, shared memory regions, mmap regions, and so on)
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stack
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Open files
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Process credentials
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scheduling information
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filesystem (VFS) structures
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Paging tables
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Namespaces
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Signal dispositions
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resource limits
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IPC structures
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Profiling (perf) information
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Security information:'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security (LSM) pointers
  id: totrans-44
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: Seccomp
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thread stacks and TLS
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hardware context
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following attributes of the parent process are not inherited by the child
    process upon forking:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: PID, PPID
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Locks
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pending and blocked signals (cleared for child)
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Timers, alarms (cleared for child)
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Audit information (CPU/time counters are reset for child)
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Semaphore adjustments made via `semop(2)`
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Asynchronous IO** (**AIO**) ops and contexts'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It''s useful to see this in the form of a diagram:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0db75d3e-d21d-4750-85a5-ecbc28056640.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
- en: As can be seen, `fork(2)` is indeed a heavyweight operation!
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: If interested, you can find more detail on the inheritance/non-inheritance characteristics
    within the man page on `fork(2)`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: Using the fork system call
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The signature of the fork is simplicity itself:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This looks trivial, but you know the saying *the devil lies in the details!*
    Indeed, we shall bring out several subtle, and not-so-subtle, pointers regarding
    the correct usage of this system call.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin to understand how fork works, lets write a simple C program (`ch10/fork1.c`*)*:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Build and run it:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The fork will, on success, have created a new child process.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '**A key programming rule: ****never assume an API succeeds, always check for
    the failure case !!!**'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: This cannot be overstressed.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: 'OK, let''s modify the code to check for the failure case; any and every system
    call (with perhaps just two exceptions out of around 380 syscalls) return `-1`
    on failure. Check for it; here is the relevant code snippet (`ch10/fork1.c`):'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The output is identical to what we saw previously (of course, since the fork did
    not fail). So, the `printf` seems to have been executed twice. Indeed it was:
    once by the parent process, and once by the new child process. This immediately
    teaches us something about the way fork works; here, we will attempt to codify
    these things as the rules of fork. In this book, we shall end up codifying seven
    rules of `fork(2)`.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: 'Fork rule #1'
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Fork rule #1**: *After a successful fork, execution in both the parent and
    child process continues at the instruction following the fork*.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: 'Why does it happen this way? Well, think about it: the job of fork is to make
    a (pretty much) identical copy of the parent in the child; this includes the hardware
    context (mentioned earlier), which of course includes the **Instruction Pointer**
    (**IP**) register (sometimes called the **Program Counter** (**PC**)) itself!
    Hence, the child process too will execute the user mode code at the same location
    as the parent. As the fork is successful, control will not go the error handling
    code (the `FATAL()` macro); instead, it will go to the `printf` .* The key point
    is this: this will happen in both the (original) parent and the (new) child process.* Hence
    the output.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么会这样呢？嗯，想一想：`fork`的工作是在子进程中创建父进程的（几乎）相同的副本；这包括硬件上下文（前面提到的），当然也包括**指令指针**（**IP**）寄存器（有时称为**程序计数器**（**PC**））本身！因此，子进程也将在与父进程相同的位置执行用户模式代码。由于`fork`成功，控制不会转到错误处理代码（`FATAL()`宏）；相反，它将转到`printf`。*关键是：这将在（原始）父进程和（新的）子进程中都发生。*因此输出。
- en: 'To reinforce the point, we write a third version of this same simple C program
    (`ch10/fork3.c`). Here, we just show the `printf `statement as it''s the only
    line of code that changes (from the  `ch10/fork3.c`):'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 为了加强这一点，我们编写了这个简单的C程序的第三个版本（`ch10/fork3.c`）。在这里，我们只显示`printf`语句，因为这是唯一一行代码发生了变化（从`ch10/fork3.c`）：
- en: '[PRE4]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Build and run it:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 构建并运行它：
- en: '[PRE5]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Ah! Now we can actually see that two processes have run the `printf`! Probably
    (but not for sure), PID `25496` is the parent process, the other of course is
    the child. After this, both processes execute the `exit(3)` API, and thus both
    die.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 啊！现在我们实际上可以看到两个进程都运行了`printf`！可能（但不确定），PID `25496`是父进程，另一个当然是子进程。之后，两个进程都执行`exit(3)`API，因此都会终止。
- en: 'Fork rule #2 – the return'
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Fork规则＃2 - 返回
- en: 'Let''s take a look at the code we''ve used so far:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看我们迄今为止使用的代码：
- en: '[PRE6]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: OK, we now understand from the first rule that the `printf` will be run twice
    and in parallel—once by the parent, and once by the child process.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在我们从第一条规则中了解到`printf`将被父进程和子进程并行运行两次。
- en: 'But, think about it: is this really useful? Can a real-world application benefit
    from this? No. What we are really after, what would be useful, is a division of
    labor, that is to say, have the child perform some task or tasks, and the parent
    perform some other task(s), in parallel. That makes the fork attractive and useful.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，想一想：这真的有用吗？现实世界的应用程序能从中受益吗？不。我们真正追求的，有用的是分工，也就是说，让子进程执行一些任务，父进程执行一些其他任务，以并行方式。这使得`fork`变得有吸引力和有用。
- en: For example, after the fork, have the child run the code of some function `foo` and
    the parent run the code of some other function `bar` (of course, these functions
    can internally invoke any number of other functions as well). Now that would be
    interesting and useful.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在`fork`之后，让子进程运行某个函数`foo`的代码，父进程运行某个其他函数`bar`的代码（当然，这些函数也可以内部调用任意数量的其他函数）。那将是有趣和有用的。
- en: 'To arrange for this, we would require some means of *distinguishing between
    the parent and child after* *the* *fork*. Again, at first glance, it might appear
    that querying their PIDs (via the `getpid(2)`) would be the way to do this. Well,
    you could, but that''s a crude way to do so. The proper way to distinguish between
    the processes is built into the framework itself: It''s—guess what—based on the
    value returned by the fork.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为了安排这一点，我们需要一些方法在`fork`之后*区分父进程和子进程*。同样，乍一看，似乎查询它们的PID（通过`getpid(2)`）是这样做的方法。嗯，你可以，但这是一种粗糙的方法。区分进程的正确方法内置在框架本身中：它是——猜猜——基于`fork`返回的值。
- en: In general, you might quite correctly state that if a function is called once,
    it returns once. Well, fork is special—when you call a `fork(3)`, it returns twice*.* How?
    Think about it, the job of the fork is to create a copy of the parent, the child;
    once done, both processes must now return to user space from kernel mode; thus
    fork is called once but returns twice; once in the parent and once in the child
    process context.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，您可能会正确地说，如果一个函数被调用一次，它就会返回一次。嗯，`fork`是特殊的——当您调用`fork(3)`时，它会返回*两次*。怎么做？想一想，`fork`的工作是创建父进程的副本，子进程；一旦完成，两个进程现在都必须从内核模式返回到用户空间；因此`fork`只被调用一次，但返回两次；一次在父进程中，一次在子进程上下文中。
- en: 'The key though, is that the kernel guarantees that the return values in parent
    and child differ; here are the rules regarding the return value of `fork`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，关键是内核保证父进程和子进程的返回值不同；以下是关于`fork`返回值的规则：
- en: 'On success:'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成功时：
- en: The return value in the child process is zero (`0`)
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子进程中的返回值为零（`0`）
- en: The return value in the parent process is a positive integer, the PID of the
    new child
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 父进程中的返回值是一个正整数，新子进程的PID
- en: On failure, `-1` is returned and `errno` is set accordingly (do check!)
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 失败时，返回`-1`并相应地设置`errno`（请检查！）
- en: 'So, here we go:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们开始吧：
- en: '**Fork rule #2**: *To determine whether you are running in the parent or child
    process, use the fork return value: it''s always 0 in the child, and the PID of
    the child in the parent*.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '**Fork规则＃2**：*要确定您是在父进程还是子进程中运行，请使用fork返回值：在子进程中始终为0，在父进程中为子进程的PID*。'
- en: 'Here''s another detail: look for a moment at the `fork`''s signature:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个细节：暂时看一下`fork`的签名：
- en: '[PRE7]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The return value''s data type is a `pid_t`, certainly a `typedef`. What is
    it? Lets find out:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 返回值的数据类型是`pid_t`，肯定是一个`typedef`。它是什么？让我们找出来：
- en: '[PRE8]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'There we are: it''s just an integer, after all. But that''s not the point.
    The point here is that when writing code, do not assume it''s integer; just declare
    the data type as per what the man page specifies; in the case of `fork`, as` pid_t`.
    This way, even if in future the library developers change `pid_t` to, say, `long`,
    our code will just require a re-compile. We future-proof our code, keeping it
    portable.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们找到了：它只是一个整数。但这不是重点。这里的重点是，在编写代码时，不要假设它是整数；只需根据手册指定的数据类型声明数据类型；在`fork`的情况下，为`pid_t`。这样，即使在将来库开发人员将`pid_t`更改为，比如，`long`，我们的代码也只需要重新编译。我们未来证明了我们的代码，使其具有可移植性。
- en: Now that we understand three fork rules, let's write a small, but better, fork-based application
    to demonstrate the same. In our demo program, we will write two simple functions `foo `and `bar`;
    their code is identical, they will emit a print and have the process sleep for
    the number of seconds passed to them as a parameter. The sleep is to mimic the
    working of a real program (of course, we can do better, but for now we'll just
    keep it simple).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们了解了三个fork规则，让我们编写一个小巧但更好的基于fork的应用程序来演示相同的内容。在我们的演示程序中，我们将编写两个简单的函数`foo`和`bar`；它们的代码是相同的，它们将发出打印并使进程休眠传递给它们的秒数作为参数。睡眠是为了模拟真实程序的工作（当然，我们可以做得更好，但现在我们只是保持简单）。
- en: 'The `main `function is as follows (as usual, find the full source code on the
    GitHub repository, `ch10/fork4.c`):'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`函数如下（通常情况下，在GitHub存储库`ch10/fork4.c`上找到完整的源代码）：'
- en: '[PRE9]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'First, here is a number of points to note:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，有几点需要注意：
- en: The return variable has been declared as `pid_t`*.*
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回变量已声明为`pid_t`。
- en: 'Rule #1—execution in both the parent and child process continues at the instruction
    following the fork. Here, the instruction following the fork is not the switch (as
    is commonly mistaken), but rather the initialization of the variable `ret`! Think
    about it: it will guarantee that `ret` is initialized twice*:* once in the parent
    and once in the child, but to different values.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 规则＃1-父进程和子进程中的执行都在fork后的指令继续进行。在这里，跟在fork后的指令不是`switch`（通常被误解为），而是变量`ret`的初始化！想一想：这将保证`ret`被初始化两次：一次在父进程中，一次在子进程中，但值不同。
- en: 'Rule #2—to determine whether you are running in the parent or child process,
    use the fork return value: it''s always `0` in the child, and the PID of the child
    in the parent. Ah, thus we see that the effect of both rules is to make sure that `ret `gets
    correctly initialized and, therefore, we can switch correctly'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 规则＃2-要确定您是在父进程还是子进程中运行，请使用fork返回值：在子进程中始终为`0`，在父进程中为子进程的PID。啊，因此我们看到两条规则的效果都是确保`ret`得到正确初始化，因此我们可以正确地进行切换
- en: 'A bit of an aside—the need for input validation. Have a look at the parameters
    we pass to the `fork4` program as follows:'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有点不相关的事情-需要输入验证。看看我们传递给`fork4`程序的参数：
- en: '[PRE10]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Need we say more (see the output)? This is a defect (a bug). As mentioned in
    the source code comment, we leave the validation of the two parameters as a small
    exercise to the reader.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要说什么（看输出）？这是一个缺陷（一个错误）。如源代码注释中所述，我们将两个参数的验证留给读者作为一个小练习。
- en: Instead of an `if `condition, we would prefer to use the switch-case syntax;
    in your author's opinion, it makes the code more readable and thus better maintainable.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们更喜欢使用`switch-case`语法而不是`if`条件；在作者看来，这使得代码更易读，因此更易维护。
- en: As we learned in rule 2, fork returns 0 in the child and the PID of the child
    in the parent; we use this knowledge in the switch-case and we thus effectively,
    and very readably, distinguish between the child and parent in the code.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正如我们在规则2中学到的，fork在子进程中返回0，在父进程中返回子进程的PID；我们在`switch-case`中使用这个知识，因此在代码中有效地、非常易读地区分子进程和父进程。
- en: 'When the child process ID is done, we do not have it call *break*; instead,
    we have it exit. The reason should be obvious: clarity. Have the child do whatever
    it requires within its business logic (`foo()`), and then simply have it go away.
    No fuss; clean code. (If we did use a break, we would require another `if` condition
    after the `switch `statement; this would be ugly and harder to understand.)'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当子进程ID完成时，我们不让它调用`break`；相反，我们让它退出。原因显而易见：清晰。让子进程在其业务逻辑（`foo()`）中做它需要做的事情，然后简单地让它离开。不麻烦；清晰的代码。（如果我们使用`break`，我们将需要在`switch`语句之后再使用另一个`if`条件；这将很难理解，且难看。）
- en: The parent process falls though the switch-case, it just emits a print, and
    exits.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 父进程通过`switch-case`，只是发出打印并退出。
- en: 'Because the functions `foo` and `bar` are identical, we show the code for `foo` only
    here:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 因为函数`foo`和`bar`是相同的，所以我们只在这里展示`foo`的代码：
- en: '[PRE11]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'OK, let''s run it:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们运行它：
- en: '[PRE12]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'As you can see, we chose to keep the child alive for three seconds and the
    parent alive for seven seconds respectively. Study the output: the return values
    from fork are as expected.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们选择让子进程保持活动状态三秒，父进程分别保持活动状态七秒。研究输出：fork的返回值如预期的那样。
- en: 'Now let''s run it again but in the background (Also, we give more sleep time,
    10 seconds and 20 seconds to the child and parent respectively.) Back on the shell,
    we shall use `ps(1)` to see the parent and child processes:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们再次在后台运行它（此外，我们给子进程和父进程分别更多的睡眠时间，10秒和20秒）。回到shell上，我们将使用`ps(1)`来查看父进程和子进程：
- en: '[PRE13]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `ps -l` (l: long listing) reveals more details about each process. (For
    example, we can see both the PID as well as the PPID.)'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`ps -l`（l：长列表）显示了每个进程的更多细节。（例如，我们可以看到PID和PPID。）'
- en: In the preceding output, did you notice how the PPID (parent process ID) of
    the `fork4` parent happens to be the value `32106` and the PID is `308` . Isn't
    this odd? You usually expect the PPID to be a smaller number than the PID. This
    is often true, but not always! The reality is that the kernel recycles PIDs from
    the earliest available value.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输出中，您是否注意到`fork4`父进程的PPID（父进程ID）恰好是值`32106`，PID是`308`。这不奇怪吗？通常您期望PPID比PID小。这通常是正确的，但并非总是如此！事实是内核从最早可用的值开始回收PID。
- en: '**An experiment to simulate work in the child and parent processes**.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**模拟子进程和父进程中的工作的实验**。'
- en: 'Let''s do this: We create a copy of the `fork4.c` program, calling it `ch10/fork4_prnum.c`.
    Then, we modify the code slightly: We eliminate the functions `foo` and `bar`*,* and,
    instead of just sleeping, we have the processes simulate some real work by invoking
    a simple macro `DELAY_LOOP`. (The code is in the header file `common.h` .) The
    macro prints a given character a given number of times, which we pass as input
    parameters to `fork4_prnum`. Here is a sample run:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `DELAY_LOOP` macro is coded to print the character `p` (for parent) and `c` (for *c*hild);
    the number of times it's printed is passed along as parameters. You can quite
    literally see the scheduler context switching between the parent and child process!
    (the interleaved `p`'s and `c`'s demonstrate when each of them has the CPU).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: 'To be pedantic, we should ensure both processes run on exactly one CPU; this
    can be easily achieved with the `taskset(1)` utility on Linux. We run `taskset`specifying
    a CPU mask of `0` implying that the job(s) should run only on the CPU `0` . (Again,
    we leave it as a simple look-up exercise for the reader: check out the man page
    on `taskset(1)`, and learn how to use it:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We recommend that you actually try out these programs on their system to get
    a feel for how they work.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: 'Fork rule #3'
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Fork rule #3**: *After a successful fork, both the parent and child process
    execute code in parallel*.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: At first glance, this rule looks pretty much the same as the first rule. But
    no, what's being stressed here is parallelism. The parent's and child's execution
    paths run in parallel with each other.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: 'You might wonder how on a single (uni) processor system, this can be? Well,
    that''s right: a fundamental attribute of a modern processor is that exactly one
    machine instruction can run at any given point in time. So, if we''re on a uniprocessor
    box, it just means that the processes will be time-slicing (or timesharing) on
    the CPU. So, it''s pseudo-parallel; however, the speed of a modern CPU being what
    it is, a human user will perceive the execution as being in parallel. On a multicore
    (SMP) system, they would, or could, run truly in parallel. So, the detail regarding
    a uni-processor is just that: a detail. The key point is that we should visualize
    both the parent and child as executing code in parallel.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in the previous code example, this rule tells us that the entire code paths
    of the parent and child processes will run in parallel; visualizing this parallelism
    is really the initial difficulty of the fork for folks new to it! To help  with precisely
    that, see the following figures (though we only show the code of the switch-case for
    brevity): the parent''s code path is highlighted in one color (red), and the child''s
    code path in another color (blue):'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/13eae568-7a7f-4c6c-8f7f-607316de7906.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
- en: This is the key point: the code in blue and the code in red, the child and parent
    processes, run in parallel!
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/158ee1e0-301c-44d0-82e7-271c4a906d55.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
- en: In the second diagram, the blue and red timeline arrows are used to again depict
    this parallelism.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: Atomic execution?
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While seeing the preceding code flow diagrams, you can be misled into believing
    that once the process starts executing its code, it continues undisturbed until
    it finishes. This is certainly not necessarily going to happen; in reality, the
    process will often get context switched out of and back into the CPU as they run.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: 'This leads us to an important point: *atomic execution.* A piece of code is
    considered to be atomic IFF (if and only if) it always runs to completion without
    interruption. Atomicity, especially in userspace, is not guaranteed: often, the
    process (or thread) execution is interrupted or preempted (sources of interruption/preemption
    include hardware interrupts, faults, or exceptions, and scheduler context switching).
    Keeping a code section atomic within the kernel can be arranged, though.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: 'Fork rule #4 – data'
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When a parent process forks*,* we understand that the child is created; it
    is a copy of the parent. This will include the VAS, and, thus, the data and stack
    segments. Keeping this fact in mind, check out the following code snippet (`ch10/fork5.c`):'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当父进程*分叉*时，我们知道子进程被创建；它是父进程的副本。这将包括VAS，因此也包括数据和堆栈段。记住这个事实，看看下面的代码片段（`ch10/fork5.c`）：
- en: '[PRE16]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The preceding program (`ch10/fork5`) has an initialized global variable `g` and
    an initialized local variable `loc`. The parent process, after fork, sleeps for
    two seconds thus more-or-less guaranteeing that the child process runs first (this
    kind of synchronization is incorrect in production quality code; we shall address
    this point in detail later in this chapter). Both the child and parent processes
    work on the global and local variables; the key question here is this*:* will
    the data get corrupted?
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的程序（`ch10/fork5`）有一个初始化的全局变量`g`和一个初始化的局部变量`loc`。父进程在分叉后睡了两秒，因此更多或更少地保证了子进程先运行（这种同步在生产质量代码中是不正确的；我们将在本章后面详细讨论这一点）。子进程和父进程都在全局和局部变量上工作；这里的关键问题是这样的*：*数据会被破坏吗？
- en: 'Let''s just run it and see:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行一下看看：
- en: '[PRE17]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Well, the data variables are not corrupted. Again, the key point here is this:
    as the child has a copy of the parent''s variables, all goes well. They change
    independently of one another; they do not step on each other''s toes. So, consider
    this:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，数据变量没有被破坏。再次强调这里的关键点是：由于子进程有父进程变量的副本，一切都进行得很顺利。它们彼此独立地改变；它们不会互相干扰。所以，请考虑这一点：
- en: '**Fork rule #4**: *Data is copied across the fork, not shared*.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '**分叉规则＃4**：*数据在分叉时被复制，而不是共享*。'
- en: 'Fork rule #5 – racing'
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分叉规则＃5-赛车
- en: Notice the `#if 1` and `#endif` surrounding the `sleep(2);` statement in the
    previous code (`ch10/fork5.c`)? It of course implies that the code will be compiled
    and thus run.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 注意前面代码（`ch10/fork5.c`）中`sleep(2);`语句周围的`#if 1`和`#endif`？这当然意味着代码将被编译并运行。
- en: 'What if we change the `#if 1` to `#if 0` ? It''s obvious, the `sleep(2);` statement
    is effectively compiled out. Let''s do this: rebuild and re-run the `fork5` program.
    What will now happen?'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将`#if 1`改为`#if 0`？很明显，`sleep(2);`语句被有效地编译掉了。让我们这样做：重新构建和重新运行`fork5`程序。现在会发生什么？
- en: 'Think about this: fork rule #4 tells us the story. After the fork, we will
    still have the child and parent processes working on separate copies of the data
    variables; hence, the values we saw earlier will not change.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 想想这个：分叉规则＃4告诉了我们这个故事。在分叉后，我们仍然有子进程和父进程在数据变量的分开副本上工作；因此，我们之前看到的值不会改变。
- en: 'However, this time, there is no sleep to crudely synchronize the parent and
    child; thus, the question arises, will the `printf `for the child or parent code
    (displaying the variable values) run first? In other words, the question we are
    really asking is this: in the absence of any kind of synchronization primitive,
    after the `fork(2)`, which process will get the processor first: parent or child? The
    short answer is the next rule:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这一次没有`sleep`来粗略地同步父进程和子进程；因此，问题出现了，`printf`对于子进程还是父进程的代码（显示变量值）会先运行？换句话说，我们真正要问的问题是：在没有任何同步原语的情况下，在`fork(2)`之后，哪个进程会先获得处理器：父进程还是子进程？简短的答案是下一个规则：
- en: '**Fork rule #5**: *After the fork, the order of execution between the parent
    and child process is indeterminate*.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '**分叉规则＃5**：*分叉后，父进程和子进程之间的执行顺序是不确定的*。'
- en: 'Indeterminate? Well, this is a fancy way to say *we really have no idea *or *it''s
    unpredictable*. So that is the deal: the systems developer should not try to predict
    the order of execution. Running the modified `fork5 `(`no sleep(2)` statement)
    now:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 不确定？嗯，这是一种花哨的说法，意思是*我们真的不知道*或者*它是不可预测的*。所以问题就是这样：系统开发人员不应该试图预测执行顺序。现在运行修改后的`fork5`（`没有sleep(2)`语句）：
- en: '[PRE18]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Ah, the parent ran first. That does not really mean anything! The parent might
    run first the next 50,000 times you try it out, but on the 50,001st trial run,
    the child process may run first. Leave it alone: it''s unpredictable.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 啊，父进程先运行。这并不意味着什么！父进程可能在你尝试了下一次50,000次后仍然先运行，但在第50,001次试运行时，子进程可能会先运行。别管它：这是不可预测的。
- en: 'This leads us to another key point (common in software): We have what''s called
    a **race condition** here. A race is literally what it says: we cannot predict
    with certainty who will be the winner. In the previous program, we really don''t
    care whether the parent or child process wins the race (runs first): this is called
    a benign race condition. But often in software design we do actually care; in
    such cases, we need a way to guarantee the winner. In other words, to defeat the
    race. This is called synchronization. (As mentioned earlier, we shall address
    this point in detail later in this chapter.)'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这引出了另一个关键点（在软件中常见）：我们这里有一个叫做**竞争条件**的东西。竞争就是字面上的意思：我们无法确定谁会是赢家。在前面的程序中，我们真的不在乎父进程还是子进程赢得了比赛（先运行）：这被称为良性竞争条件。但在软件设计中经常我们确实在乎；在这种情况下，我们需要一种方法来保证赢家。换句话说，打败竞争。这就是所谓的同步。（正如前面提到的，我们将在本章后面详细讨论这一点。）
- en: The process and open files
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进程和打开的文件
- en: To clearly understand the effect of fork on open files, we need to slightly
    digress and briefly understand some background information.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 为了清楚地理解分叉对打开文件的影响，我们需要稍微偏离一下，并简要了解一些背景信息。
- en: In fact, for those readers very new to performing I/O on files within the Unix
    paradigm, it will be beneficial to first read through the [Appendix A](https://www.packtpub.com/sites/default/files/downloads/File_IO_Essentials.pdf),
    *File I/O Essentials*, before tackling this section.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，对于那些在Unix范式中对文件进行I/O非常新手的读者，最好先阅读[附录A](https://www.packtpub.com/sites/default/files/downloads/File_IO_Essentials.pdf)，*文件I/O基础*，然后再着手阅读本节。
- en: 'A Unix/Linux process, upon startup, will by default be assigned three open
    files; we''ve discussed these basic points earlier in the book. For convenience,
    the three open files are called the `stdin`*,* `stdout`*,* and `stderr `of the
    process; they auto-default to the keyboard, the monitor, and, again, the monitor
    for `stdin`*,* `stdout`*, *and `stderr` respectively. Not only that, real applications
    will certainly open other files as they perform their tasks. Recall the layered
    system architecture; if a Linux application opens a file using the `fopen(3)` library
    API, it will ultimately boil down to the `open(2)` system call, which returns
    a handle to the open file, called a** file descriptor**. (Think about it: consider
    a Java app running on Linux that opens a file: Ultimately, this time, via the
    JVM, the work will be done via the same `open(2)` system call!)'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: 'The point here is this: the kernel stores every process''s open files within
    a data structure (in classic Unix terminology, it''s called the **Open File Descriptor
    Table** (**OFDT**). We saw earlier in the section that talked about characteristics
    inherited by the child process upon fork, thatopen files are indeed inherited
    by the child. To facilitate this discussion, consider the following pseudo-code
    snippet:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Here, the file `myfile `is now available to both processes and can be worked
    upon via the file descriptor `fd`! But hang on: it should be clear that working
    on the same file simultaneously by both child and parent processes could certainly corrupt the
    file; or if not the file content, at least the application. To perceive this,
    consider the function `work_on_file` *(*pseudo-code):'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Fork rule #6 – open files'
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can see that without any synchronization, havoc would result! Hence the
    next fork rule:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '**Fork rule #6**: *Open files are (loosely) shared across the fork****.***'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: 'The upshot of all that is this: the systems programmer must understand that,
    if the parent process has opened a file (or files), naively working on the file
    simultaneously (remember fork rule #3!) will likely cause bugs. A key reason is
    this: although the processes are distinct, the object they work upon, the open
    file, and, more precisely, its inode, is one distinct object and thus shared.
    In fact, the file''s *seek* *position* is an attribute of the inode; blindly re-positioning
    the seek pointer in parent and child without synchronization will pretty much
    guarantee problems.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: 'There are broadly two choices to keep things running smoothly:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: Have one of the process's close the file
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Synchronize access to the open file
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The first of them keeps things simple but is of limited use in real-world applications;
    they would usually require that the file remains open. Thus, the second choice:
    how exactly do you synchronize access to the open file?'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, the details are not covered in this book, but, very briefly, you can
    synchronize file I/O between processes like so:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: Via the SysV IPC or POSIX semaphore
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Via file locking
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first one works, but crudely. It's not considered the right way. The second
    solution, using file locking, is definitely the preferred one. (File locking is
    not covered in detail here, please refer the *Further reading *section for a link
    to an excellent tutorial on the same on the GitHub repository.)
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: It's also important to realize that when either the parent or child process
    closes the open file, its access to the open file is closed; the file is still
    open in the other process. This is really what is meant by the phrase "loosely
    shared".
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: As a quick way to demo this issue, we write a simple program `ch10/fork_r6_of.c `
    (here, **of** stands for **open file**).We leave it to the reader to go through
    the source code; an explanation and sample output follows.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we have the process open a regular file tst; then, we have the child
    process do this: seek to offset 10, and write *numlines* (equal to 100) lines
    of `c`''s. In parallel, we have the parent process do this: seek to offset 10+(80*100),
    and write *numlines* lines of p''s. So when we have finished and we examine the
    file, we expect that we have 100 lines of `c`s and 100 lines of `p`s. But, hey,
    it does not actually happen that way. Here''s the actual run:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们让进程打开一个名为tst的常规文件；然后，我们让子进程执行这个操作：定位到偏移量10，并写入`numlines`（等于100）行的`c`。与此同时，我们让父进程执行这个操作：定位到偏移量10+(80*100)，并写入`numlines`行的p。因此，当我们完成并检查文件时，我们期望有100行`c`和100行`p`。但是，嘿，实际上并不是这样发生的。以下是实际运行的情况：
- en: '[PRE21]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This is the test file''s content after the run:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这是运行后测试文件的内容：
- en: '[PRE22]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `p`s and `c`s interleave! Yes, indeed, because the processes ran in parallel without
    any form of synchronization. (By examining the file content, we can literally
    see how the kernel CPU scheduler context-switched between the parent and the child
    processes). By not using synchronization, we have set up a race. So how do we
    set this right? It was mentioned earlier: file locking is really the answer (Note:
    do not attempt to synchronize with the silly `sleep(2)` in the parent kind of
    code we''ve used; that''s just for demonstration; Also, we shall cover the proper
    way to synchronize the child and parent shortly.)'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`p`和`c`交错！是的，确实，因为进程在并行运行时没有任何形式的同步。（通过检查文件内容，我们可以清楚地看到内核CPU调度程序在父进程和子进程之间进行了上下文切换）。通过不使用同步，我们设置了一个竞争。那么我们如何解决这个问题呢？前面提到过：文件锁定实际上是答案（注意：不要尝试使用我们使用的父进程中的愚蠢的`sleep(2)`进行同步；那只是为了演示；此外，我们将很快介绍正确的方法来同步子进程和父进程。）'
- en: Open files and security
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打开文件和安全性
- en: A key point again regarding security, for both the exec and fork scenarios.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 关于安全性的一个关键点，适用于exec和fork的情况。
- en: 'When you perform an `exec `operation, the predecessor process''s VAS is essentially
    overwritten by that of the successor process. However, realize that the predecessor
    process''s open files (held within the OS in a per-process structure called the
    OFDT, mentioned earlier) remain intact and are, in effect, inherited by the successor
    process. This could pose a serious security threat. Think about it: what if a
    security-sensitive file being used by the predecessor is not closed and an exec performed?
    The successor now has access to it via its file descriptor, whether it exploits
    that knowledge or not.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行`exec`操作时，前任进程的VAS实质上被继任进程的VAS覆盖。但是，请意识到，前任进程的打开文件（在先前提到的OS中的每个进程结构中称为OFDT）保持不变，并且实际上被继任进程继承。这可能构成严重的安全威胁。想一想：如果前任正在使用的安全敏感文件没有关闭并执行了`exec`，那么继任者现在可以通过其文件描述符访问它，无论它是否利用了这种知识。
- en: 'The same argument holds true for the fork; if a parent process has a security-sensitive
    file open and then forks, the child too has access to the file (fork rule #6).'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 对于fork，同样的论点也成立；如果父进程打开了一个安全敏感的文件，然后fork，子进程也可以访问该文件（fork规则＃6）。
- en: To counter exactly this issue, from the Linux 2.6.23 kernel, the `open(2)` system
    call, includes a new flag: `O_CLOEXEC`. When this flag is specified within the `open(2)`,
    the corresponding file will be closed upon any future `exec `operation performed
    by that process. (In earlier kernels, developers had to perform an explicit `F_SETFD` via `fcntl(2)` to
    set the `FD_CLOEXEC` bit).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 为了对抗这个问题，从Linux 2.6.23内核开始，`open(2)`系统调用包括一个新标志：`O_CLOEXEC`。当在`open(2)`中指定了这个标志时，相应的文件将在该进程执行的任何未来`exec`操作时关闭。（在早期内核中，开发人员必须通过`fcntl(2)`执行显式的`F_SETFD`来设置`FD_CLOEXEC`位）。
- en: When working with fork, the programmer must include logic to close any security-sensitive
    files in the parent prior to the fork.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用fork时，程序员必须包含逻辑，以在fork之前关闭父进程中的任何安全敏感文件。
- en: Malloc and the fork
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Malloc和fork
- en: 'A common mistake that programmers might stumble upon or make, is this: consider
    a successful memory allocation done in a process, with say, `p = malloc(2048)`.
    Assume that the variable `p`is global. Some time later, the process forks. The
    developer now wants the parent process to communicate some information to the
    child; so, she says, lets just write into the shared buffer `p`, and the job will
    be done. No, it does not work! Let''s elaborate: the malloced buffer is visible
    to both processes, but not in the way they think. The mistaken assumption is that
    the malloced buffer is shared between the parent and child process; it is not
    shared, it''s copied to the child''s VAS. Please recall fork rule #4: Data is
    not shared; it''s copied across the fork.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员可能会遇到或犯的一个常见错误是：考虑在进程中成功分配内存，比如，`p = malloc(2048)`。假设变量`p`是全局的。一段时间后，进程fork。开发人员现在希望父进程向子进程传递一些信息；所以，她说，让我们只是写入共享缓冲区`p`，工作就完成了。不，这不起作用！让我们详细说明一下：malloc的缓冲区对两个进程都是可见的，但不是以他们认为的方式。错误的假设是malloc的缓冲区在父进程和子进程之间是共享的；它不是共享的，它被复制到子进程的VAS。请回忆fork规则＃4：数据不共享；在fork中被复制。
- en: 'We must test this case; have a look at the following code snippet (source file: `ch10/fork_malloc_test.c`):'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须测试这种情况；看一下以下代码片段（源文件：`ch10/fork_malloc_test.c`）：
- en: For readability, only the relevant parts of the code are displayed here; to
    view and run it, the entire source code is available here: [https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux](https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 为了便于阅读，这里只显示了代码的相关部分；要查看并运行它，整个源代码在这里可用：[https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux](https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux)。
- en: '[PRE23]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `disp_few` function to display a few (16) bytes of the memory buffer is
    simple:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`disp_few`函数用于显示内存缓冲区的前几个（16）字节很简单：'
- en: '[PRE24]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We build and run it:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们构建并运行它：
- en: '[PRE25]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Immediately, the first thing to notice is this: the pointer to the memory buffer
    (`0x1802260`) in both the parent and child process is the same leading one to
    the conclusion that it''s the same memory buffer being pointed at. Well, it''s
    not; it''s an easy mistake to make. Check out the *content* of the malloced buffer
    in the parent and child; it''s `p`s in the parent and `c`s in the child; if it
    were really the very same buffer, the content would be identical. So, then, what
    is going on?'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned several times now, data is copied across the fork, not shared
    *(*our fork rule #4). OK, but then how come the address is the same? There are
    two reasons:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: The address is a virtual address (not a physical address, as we should well
    know from the discussions in [Chapter 2](976fc2af-8bb4-4060-96cd-3b921682ed75.xhtml),
    *Virtual Memory*)
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is actually the same virtual address; modern OSes such as Linux do not, immediately
    on fork, make a copy of the data and stack segments; they use an optimized semantic
    called **copy-on-write** (**COW**).
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: COW in a nutshell
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This requires a bit of explanation. Until now, to keep the discussion conceptually
    simple, we have said that upon fork, the kernel copies all the parent's VAS segments
    (plus all the other inherited process attributes) to the new child process. This
    is an exaggeration; the reality is, attempting to do this would make the `fork(2)` untenable
    in practice as it would require too much RAM and too much time. (As it is, even
    with several optimizations, the fork is still considered heavyweight.)
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s digress: one of the optimizations, upon fork is that the kernel does
    not copy the text (code) segment into the child; it merely shares the parent''s
    text segment (virtual) pages with the child process. This works well, as text
    is in any case only readable and executable (r-x); thus, as it can never change,
    why make a copy?'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: 'But what about the data and stack segments? Their pages are read-write (rw-)
    after all so how can the OS just share them with the child? Ah, that''s where
    the COW semantics come in handy. To understand COW, consider a single virtual
    page that has been marked as COW by the OS. It essentially means this: As long
    as both processes (parent and child) treat the page as read-only, they can share
    it; no copy is necessary. But the moment one of them modifies (even a byte in)
    the page, the OS intervenes and creates a copy of the page, which is then handed
    off to the process that performed the write.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: So, if we have a global variable `g=5` and `fork(2)`, the page containing `g` is
    marked COW by the OS; the parent and child share it, until either writes to `g`.
    At that point, the OS creates a copy of the page containing the (updated) variable
    and hands it to the writer. Thus, the granularity of COW is a page.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: As a matter of fact, COW is aggressively enforced by Linux to optimize to the
    maximum extent possible. Its not just the data and stack segments, most of the
    other inheritable process attributes we discussed earlier are actually not copied
    to the child, they are COW-shared, effectively making Linux's fork extremely efficient.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: 'Additional insight into these important points can be gained by noticing the
    same effect, the COW optimization, carried out on the data variables (globals
    and locals) as well; just run our test case program with any parameter and it
    internally runs a small test case on two variables: a global and a local:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Notice the addresses of the global `g` and the local `loc `are the same in
    the parent and child processes. But why? COW will have been performed as they
    have been written. Yes, but think: it''s all virtual addressing; the physical
    addresses will actually differ under the hood.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: 'You sometimes gets the feeling that modern OSes go out of their way to confuse
    and confound the poor systems programmer! The two important points we made earlier
    seem to contradict each other:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: 'Fork rule #4: Data is copied across the fork, not shared'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data/stack (and a lot else) is not actually copied upon fork, but rather COW-shared
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'How do we resolve this situation? It''s easy, actually: The first (our fork
    rule #4) is the correct way to think when working with the fork; the second statement
    is what really happens under the hood at the OS layer. It''s about optimization, that
    is all.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a suggestion: When wearing the hat of an application developer, do
    not get overly concerned with the  underlying OS''s COW optimization details;
    it''s more important to understand the intention rather than the optimization.
    Thus, as far as the Linux application developer using `fork(2)` is concerned,
    the key conceptual point that remains is fork rule #4: data is copied across the
    fork, not shared.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: Waiting and our simpsh project
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Lets set ourselves an interesting learning exercise: a small project. We want
    to implement, using C on the Linux OS of course, a very simple shell of our own.
    Lets call it our `simpsh`—simple shell—project.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: Note: simpsh is a very small, minimally functioning shell. It works with only single-word commands.
    It does not support features such as redirection, piping, shell built-ins, and
    so on. It's meant to be a learning exercise.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: 'The specification, for now at least is this: Display a prompt (say `>>`), accept
    a user command at the prompt, and execute it. This is the stopping condition:
    if the user enters `quit`, terminate (similar to typing `logout`, `exit`, or `Ctrl
    + D` on an actual shell process).'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: 'It seems pretty straightforward: In our C program you get into a loop, display
    the required prompt, accept the user input (let''s use the `fgets(3)`to do this) into
    a `cmd `variable, and then use one of the exec family APIs (a simple `execl(3)`
    sounds promising) to execute it.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, yes, except, how could you forget, the predecessor process is effectively
    lost after the exec operation succeeds! Our shell will be lost once we exec anything (just
    like our earlier experiment 1: on the CLI and experiment 2—demonstrated).'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if with the previous naive approach, we attempt to execute `ps(1)`with
    our shell simpsh, it would look like this:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3dd4bb45-0b97-4f6b-83a7-81d59fb769e3.png)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
- en: The Unix fork-exec semantic
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, that does not work. What we need, really, is a way for our simple shell simpsh to
    remain alive and well *after* the execoperation, but how can we achieve that?
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: 'The fork is the answer! Here''s what we''ll do: after the user supplies input
    (a command), we have our shell fork. We now have two identical shells alive: the
    original parent (let''s say it has PID x) and the brand new child shell (PID y). The
    child shell is used as the sacrificial lamb: We have it exec the user command. So,
    yes, the child is the predecessor process that is impossible to return to; but
    that''s OK as we have the parent shell process alive and well!'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: 'This well-known technique is called the *fork-exec* semantic. It combines what
    several other OSes call a spawn into two discrete operations: a process creation
    (fork), and a process execution (exec). Once again, the brilliant Unix design
    is shown off:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d02c4005-7234-4da0-9e9b-8399cec8896c.png)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
- en: In the preceding diagram, visualize the timeline as the (horizontal) x-axis.
    Also, we use the color blue to show the child's execution path.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: Once the parent shell detects that the execed child has completed, it displays
    the shell prompt again.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: The need to wait
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The fork-execis really interesting, but hang on a second: While the child process
    performs an `exec` on the user command, and the successor is running (indicated
    by the dot-dash blue line in the preceding diagram), what should the parent process
    do? Obviously, it should wait, but for how long? Should we have it sleep? Well,
    no, as sleep takes the number of seconds to sleep as its argument. We do not know
    in advance how long the successor will take (it could be milliseconds, it could
    be months). The correct thing to do is this: have the parent process wait until
    the child (now the successor) dies.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: This is precisely what the `wait(2)` API is designed to do. When the parent
    process issues the `wait(2)` API, it is put to sleep; the moment its child dies,
    it's woken up!
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: Performing the wait
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `wait(2)` API is a classic example of a blocking call: The calling process
    is put into a sleep state until the event it is waiting (or blocking) upon occurs.
    When the event does occur, it is woken up and continues to run.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: 'So, think about it: a process forks; the parent process then issues the `wait
    (2)`API, and the event it is blocking upon is the death of the child! The child
    continues to run, of course; when the child does die, the kernel wakes up, or unblocks, the
    parent; it now continues to execute its code. Here is the signature of `wait(2)`:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: For now, we shall ignore the to `wait(2)`; we shall just pass NULL (or `0`)
    (of course, we shall cover it shortly).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: Defeating the race after fork
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Recall the example code we saw earlier in chapter `ch10/fork5.c`.In this program,
    we artificially, and crudely, waited for the child process by introducing a `sleep(2);`statement
    in the parent''s code:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This is not good enough: What if the child process takes longer than two seconds
    to complete its work? If it takes just a few milliseconds, then we unnecessarily
    waste time.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how we resolve the race: Who will run first, the parent or the child?
    Clearly, fork rule #5 tells us that it''s indeterminate. But, in real-world code,
    we need a way to guarantee that one of them indeed runs first—say, the child process.
    With the wait API, we now we have a proper solution! We change the preceding code
    snippet to this:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Think about how this works: After the fork, it''s a race: If the child process
    does run first, then no harm is done. However, at some point in the near future,
    the parent process will get the CPU; that''s fine as all it does is block upon
    the child by calling wait. If the parent does run first after the fork, the same
    thing occurs: it blocks upon the child by calling wait. We have effectively defeated
    the race! By issuing the wait as the first thing done in the parent process after
    fork, we effectively guarantee that the child runs first.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: Putting it together – our simpsh project
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, now that we have all the bits and pieces in place—namely, the fork-execsemantic
    and the `wait`API—we can see how our simple shell should be designed.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: 'In the C program, get into a loop, display the required prompt, accept user
    input (let''s use the `fgets(3)`to do this—why? Please read the upcoming tip) into
    a `cmd` variable, and then fork. In the child code (use fork rule #2 to distinguish
    between the parent and child), use one of the many exec family APIs (a simple `execlp(3)` sounds
    promising here) to execute the user supplied command. In parallel (recall fork
    rule #3), have the parent process invoke the wait API; the parent now sleeps until the
    child dies. Now loop around again and repeat the whole thing until the user types `''quit''` to
    quit. Everyone''s happy!'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2992e6e4-fcea-4b60-8bee-81d7b9ebc4bb.png)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
- en: In effect, we now have a `fork-exec-wait `semantic that is exploited!
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '`fgets(3)`: For security reasons, do not use the traditionally taught APIs
    such as `gets(3)` or `scanf(3)` to receive user input; they are poorly implemented,
    and they do not provide any bounds-checking capabilities. The `fgets(3)` does;
    thus, using it, or `getline(3)`, is far superior security-wise. (Again, as mentioned
    earlier in this book, hackers exploit these vulnerabilities in commonly used APIs
    to perform stack-smashing, or other types of attacks.)'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, our simpsh shell is rather limited in scope: it only works with *s*ingle-word
    commands (such as `ps`, `ls`, `vi`, `w`, and so on). Read the code and think about
    why this is the case.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: 'Here we go (source code: `ch10/simpsh_v1.c`):'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: For readability, only the relevant parts of the code are displayed here; to view
    and run it, the entire source code is available here: [https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux](https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux).
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As you can see, we enter the loop, accept the user's command via the `getcmd` function
    we wrote (the `fgets` is issued within it), and then check whether the user has
    typed `quit`, in which case we exit.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: 'The real work, the `fork-exec-wait` semantic, happens here, within the loop:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: (The logic pertaining to argument passing—displaying the help screen, verbose
    switch, the actual `fgets`, the calloc/free, and so on, is not explicitly shown;
    please refer to the source file `simpsh_v1.c`).
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s give it a try:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We run the program in verbose mode; you can see the shell prompt string `>>` 
    as well as every verbose print; they are prefixed with `[v]:`. Notice how it works
    for single word commands; the moment we pass something unknown or with more than
    one word (for example `www` and `uname -a` ), the `execlp(3)` fails; we catch
    the failure and emit a warning message; the program continues until the user quits.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is another quick experiment: We can use our `simpsh_v1`program to spawn
    another shell (`/bin/sh`):'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: It works as expected (hey, you could even experiment with spawning the same
    process `simpsh_v1`). So, there we are, a first very simple but functioning shell.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: Why exactly do commands that are more than one word long fail? The answer lies
    in how we're executing the successor, using the `execlp(3)` API. Recall, for execlp, we
    are to pass the program name (the PATH will be auto-searched of course) and all
    arguments, starting with `argv[0]`. Well, in our simple implementation, we just
    don't pass anything more than the first argument `argv[0]`; that's why.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: 'So, how do we make it work with commands with any number of arguments? Well,
    it really involves some amount of string-processing work: We will have to tokenize the
    arguments into individual strings, initializing an `argv`array of pointers to
    them, and using that `argv`via the `execv[pe]` API. We leave it as a slightly
    more challenging exercise to the reader! (Tip: the C library provides APIs for
    tokenizing strings; `strtok(3)`*,* `strtok_r(3)`*; *look them up).'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: In effect, our simpsh project is a simplistic implementation of the `system(3)`library
    API. Note that from a security viewpoint, it's always recommended to use field-proven
    and tested APIs like `system(3)`rather than a home-grown` fork-exec-wait` piece
    of code. Here, of course, we code it for learning purposes.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: The wait API – details
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In our simpsh program, we did use the `wait(2)` API, but have not really delved
    into details:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The thing to understand is this: `wait(2)` is a blocking call; it causes the
    calling process to block until a child process dies.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: 'To be technically correct, the `wait(2)` (and associated APIs that we shall
    see later) actually block upon the child process(es) undergoing a state change;
    well, the state change is the child''s death, right? Yes, but it''s really important
    to understand that it''s not just that: the possible state changes are as follows:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: 'The child process terminates as follows:'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Normally (by falling off `main`, or calling `[_]exit()`)
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Abnormally (killed by a signal).
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The child was sent a signal that stopped it (usually `SIGSTOP` or `SIGTSTP`).
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Having been stopped, it was delivered a signal that continued (resumed) it (usually `SIGCONT`;
    we shall cover signaling in detail in the next chapter).
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The generic `wait(2)` system call, though, blocks upon the death (termination)
    of the child, not any of the other signal-related state changes mentioned earlier.
    (Can that be done? Yes, indeed, we cover the `waitpid(2)`system call later in
    this chapter).
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: 'The parameter to wait, is a pointer to an integer `wstatus`. In reality, it
    is treated as more of a return rather than a parameter to pass along; this is
    a pretty common C programming technique: Treat a parameter as a return value.
    System calls on Linux often use it; this technique is often referred to as a value-result or
    an in-out parameter. Think about this: We pass the address of the variable; the
    API internally, having the address, can update it (poke it).'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: 'The next thing regarding the parameter `wstatus` is this: The integer is treated
    as a bitmask,not as an absolute value. This, again, is a common C optimization
    trick that programmers employ: We can fit several pieces of information into an
    integer by treating it as a bitmask. So, how do you interpret this returned bitmask?
    For portability reasons, the C library provides predefined macros that help us
    interpret the bitmask (these are in `<sys/wait.h>`usually). The macros work in
    pairs: The first macro returns a Boolean value; if it returns true, look up the
    second macro''s result; if it returns false, disregard the second macro completely.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: 'A digression: a process can die in one of two ways: normally or abnormally. Normal
    termination implies that the process died voluntarily; it just fell off `main()` or called `exit(3)` or `_exit(2)` passing
    the exit status as an argument (the convention for exit status: zero  implies
    success, non-zero implies failure and is treated as the failure code). On the
    other hand, abnormal termination implies that the process died involuntarily—it
    was killed, typically via a signal.'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the wait macro pairs and their meaning:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '| **First macro** | **Second macro** | **Meaning** |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
- en: '| `WIFEXITED` | `WEXITSTATUS` | Child died normally: `WIFEXITED` is true; 
    then, `WEXITSTATUS`—exit status of child. Child died abnormally: `WIFEXITED` is
    false'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '| `WIFSIGNALED` | `WTERMSIG` | Child died due to signal: `WIFSIGNALED` is true;
    then, `WTERMSIG` is the signal that killed it. |'
  id: totrans-293
  prefs: []
  type: TYPE_TB
- en: '|  | `WCOREDUMP` | True if, upon death, the child produced a core dump. |'
  id: totrans-294
  prefs: []
  type: TYPE_TB
- en: '| `WIFSTOPPED` | `WSTOPSIG` | True if child was stopped by signal; then, `WSTOPSIG`
    is the signal that stopped it. |'
  id: totrans-295
  prefs: []
  type: TYPE_TB
- en: '| `WIFCONTINUED` | - | True if child was stopped and later resumed (continued)
    by a signal (`SIGCONT`). |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
- en: (In the row containing `WCOREDUMP`, the indentation is intended to mean that
    you can tell that `WCOREDUMP` is only meaningful if `WIFSIGNALED` is true).
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: What about the actual return value itself of `wait(2)`? Clearly, `-1` indicates
    failure (and of course the kernel will set `errno` to reflect the cause of the
    failure); else, on success, it's the PID of the process that died, thus unblocking
    the parent's wait.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: 'To try out the things we have just learned, we make a copy of the `simpsh_v1`program
    and call it `ch10/simpsh_v2.c`*. *Again, we only show the relevant snippets here;
    the complete source code files are on the book''s GitHub repository:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'As you can see, we now capture the return value of `wait (2)`(the PID of the
    child that changed state), and if we are running in verbose mode, we call our
    own function `interpret_wait`; it will provide output detailing what status change
    exactly occurred; here it is:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The `VPRINT` macro is simple; it results in a `printf(3)`if the process is
    in verbose mode. We try the program (version 2) out:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'As you can see, we run it in verbose mode; we can see that the child process `ps(1)` had
    a status change: It died normally, with an exit status of zero, indicating success.'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: 'Interesting: this is how bash knows whether the process that just ran succeeded
    or not; it plugs in the exit status—fetched via an API similar to `wait`*—*into
    the variable **`?`** (which you can access using  `$?` .)'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: The scenarios of wait
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until now, we've covered the generic `wait(2)` API; however, we have only really
    discussed one possible scenario regarding the `wait`*; *there are several more.
    Let's check them out.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: 'Wait scenario #1'
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s the simple case (one we''ve already come across): a process forks, creating
    one child process. The parent subsequently issues the *wait *API; it now blocks on
    a status change in it''s child process; recall, the possible status changes the
    child can possibly go through are these:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: 'State transition from running (R): dead; that is to say, the child terminates
    (normally/abnormally)'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: State transition from running/asleep (R|S|D) to stopped state (T); that is to
    say, it receives a signal causing it be stopped
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: State transition from stopped state (T) to ready-to-run (R); that is to say, from
    a stopped state to a ready-to-run state
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (The state transitions and the letters representing the process state are covered
    in [Chapter 17](36229bac-c402-4d2f-b876-d1eb4aba8051.xhtml), *CPU Scheduling on
    Linux*, on scheduling). Whichever may occur, the fact is that the parent is unblocked and
    continues to execute its code path; the `wait(2) `API returns (along with which
    we receive the PID of the child that died or was signaled), as well as the detailed
    status bitmask.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: 'Wait scenario #2'
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Consider this scenario: A process forks (creates) two children; let''s call
    the parent process P and the children C1 and C2\. Recall fork rule #3—the parent
    and the children processes will all continue to run in parallel. Now, P calls `wait`;
    what will happen?'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the answer: process P will remain blocked until one of the children
    dies (or stops), but which one? Any one; whichever one changes state first. So
    how will the systems programmer know which process dies or stopped? That''s easy:
    The return value is the PID of the process that died or stopped.'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: 'In other words, we devise a corollary: a wait blocks on a single child process;
    to block on n children requires n waits.'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: An interesting exercise would be to construct the preceding scenario in code;
    ensure that the parent process indeed waits upon both children (this very exercise
    is mentioned as `fork2c` on the GitHub repository).
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: To have a parent wait upon all possible children, invoke the `wait`API as the
    condition of a while loop; as long as waitable children exist, it will block and
    return positive; the moment there are no waitable children, the `wait`returns
    `-1`; check for that as the condition to break out of the loop. Note though, that
    there are scenarios requiring a non-blocking wait to be set up; we shall cover
    these as well.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: Fork bombs and creating more than one child
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Say we want to write code to create three children; would this, the code shown
    as follows, do it?
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Of course not! (try it and see).
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall fork rule #1: Execution in both the parent and child process continues
    at the instruction following the fork. Thus, as you can see, after the first fork,
    both the parent and child run the second fork (so we''ll now have a total of four
    processes), and then all four will run the third fork (giving us a total of eight
    processes), and so on (havoc!).'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: If fork is called in this uncontrolled manner—it ends up creating *2^3 = 8*
    children! In other words, it's exponential; n forks implies *2^n* children will
    be created in a runaway sprint.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine what damage can be done with this code:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: It's quite rightly called a fork bomb!—a type of **denial-of-service** (**DoS**)
    attack**. **
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: Interestingly, because of modern Unixes (including Linux of course) having COW-based
    copying semantics, the memory overhead incurred may not be that large. Of course,
    it still consumes huge amounts of CPU; also, a simple calloc within the while
    loop would cause memory to be eaten up as well.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: By the way, carefully tuned resource limits (we studied this in an earlier chapter
    in detail) can help mitigate the fork bomb (and similar) DoS attack risks. Even
    better, would be careful tuning via cgroups for resource bandwidth control. Here
    is the fork bomb wikipedia link: [https://en.wikipedia.org/wiki/Fork_bomb](https://en.wikipedia.org/wiki/Fork_bomb).
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: OK, so, `fork(); fork();` is not the way to create two children. (Try out the
    exercise `Smallbomb` on the GitHub repository.)
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: 'How do you do so correctly? It''s straightforward: take into account the parent
    and child''s execution paths, distinguish between them (fork rule #2),and just
    have the parent create a second child process. This code snippet demonstrates
    the same:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Wait scenario #3'
  id: totrans-335
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What if a process has no children, never had any children (a bachelor chap),
    and it issues the `wait(2)`API? At first glance, this seems to be a problem case,
    as perhaps it could cause deadlock; but, no, the kernel is smarter than that.
    The kernel code of `wait`checks, and upon finding that the calling process has
    no children (dead or alive or stopped or whatever), it simply *fails *the *wait.* (FYI, `errno`gets
    set to `ECHILD` implying the process had no unwaited-for children).
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, recall one of our golden rules: *never assume anything; always check
    for the failure case*.Importantly, our [Chapter 19](b6b41870-c02e-4379-af86-b5e501799c31.xhtml),
    *Troubleshooting and Best Practices*, covers such points.'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: There is one more `wait` scenario; however, we need to cover more information
    first.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: Variations on the wait  – APIs
  id: totrans-339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a couple of additional system calls to perform the job of *waiting
    upon the child(ren) process(es)*; we cover them next.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: The waitpid(2)
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Consider that we have a process with three children; it is required that the
    parent waits (blocks) upon the termination of a particular child process. If we
    use the generic `wait` API, we have seen that it will get unblocked upon the state
    change of any of the children. The answer to this conundrum: the `waitpid(2)` system
    call:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The first parameter `pid`is set to the PID of the child to wait upon. However,
    other values are possible; if `-1` is passed, it generically waits for any `waitable`
    child process. (There are other more arcane cases; we refer you to the man page
    for them). In other words, issuing this is equivalent to a generic `wait(&stat);` API
    call:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The second parameter is the usual status integer bitmask that we saw in detail
    with the `wait` API.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: 'The third parameter is called `options`; previously, we set it to zero, implying
    no special behavior. What other values can it take? Well, you can pass just zero
    or the bitwise OR of the following (it''s also a bitmask):'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: '| **Options parameter value** | **Meaning** |'
  id: totrans-348
  prefs: []
  type: TYPE_TB
- en: '| `0` | Default, same as `wait(2)` |'
  id: totrans-349
  prefs: []
  type: TYPE_TB
- en: '| `WNOHANG` | Only block upon live children; if there are none, return immediately
    |'
  id: totrans-350
  prefs: []
  type: TYPE_TB
- en: '| `WUNTRACED` | Also unblock when a child process stops(and does not necessarily
    terminate) |'
  id: totrans-351
  prefs: []
  type: TYPE_TB
- en: '| `WCONTINUED` | Also unblock when a stopped child process is resumed (via
    the `SIGCONT` signal being delivered to it) |'
  id: totrans-352
  prefs: []
  type: TYPE_TB
- en: At first, the `WNOHANG` option might sound strange; how can you block upon anything
    but a live child? Well, with a little patience, we shall soon resolve this peculiarity.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: 'To test the `waitpid(2)`, we again  make a copy of our `simpsh_v2.c`and call
    it `ch10/simpsh_v3.c`; the only meaningful difference in the code is that we now
    use the `waitpid(2)`instead of the generic `wait`API, passing along options as
    required; from `ch10/simpsh_v3.c`:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now we run it:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We issue the `read`(a bash built-in) command, as it itself is a blocking call,
    so we know that the child process `read`will be alive and asleep. In another terminal
    window, we look up the PIDs of our `simpsh_v3`process and of the command we ran
    from within it (the `read`):'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: (The useful `pstree(1)`utility shows us the process tree's parent-child hierarchy.
    Look up it's man page for details).
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we send `SIGTSTP` (the terminal stop signal) to the `read`process; it gets stopped:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Getting stopped is a status change that we are looking for! Recall, our waiting
    code now is this:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Thus, the moment the child stops the `WUNTRACED` option takes effect, and in
    the original terminal window we see this:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We now continue the child by sending it the signal `SIGCONT`:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'As our (parent) `waitpid(2)`is also using the `WIFCONTINUED` option, in the
    original Terminal window, we see this (though it does require the user to press
    the *Enter* key it seems):'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: We have so much more control over the child(ren). (Young parents, please note!)
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: The `fork-exec-wait` Unixframework is powerful indeed.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: The waitid (2)
  id: totrans-373
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For further fine tuning and control, there is the `waitid(2)`system call as
    well (from Linux 2.6.9):'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: '`int **waitid**(idtype_t idtype, id_t id, siginfo_t *infop, int options);`'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: 'The first two parameters will in effect specify the children to wait upon:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: '| **waitid(2): 1st parameter: idtype** | **Second parameter: id ** |'
  id: totrans-377
  prefs: []
  type: TYPE_TB
- en: '| `P_PID` | Set to the PID of the child to wait (block) upon |'
  id: totrans-378
  prefs: []
  type: TYPE_TB
- en: '| `P_PGID` | Wait upon any child whose process group ID (PGID) matches this
    number |'
  id: totrans-379
  prefs: []
  type: TYPE_TB
- en: '| `P_ALL` | Wait upon any child (this parameter is ignored) |'
  id: totrans-380
  prefs: []
  type: TYPE_TB
- en: 'The fourth `options` parameter is similar to how it was used with the `waitpid(2)`,but
    not identical; there are some additional options that can be passed along; again,
    it''s a bitmask*,* not an absolute value: the `WNOHANG` and `WCONTINUED` options
    have the same meaning as with the `waitpid(2)` system call.'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, the following options can be bitwise-ORed:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: '`WEXITED`: Block upon children that have (already) terminated (again, we shall
    soon make clear why this even exists)'
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WSTOPPED`: Block upon children that will enter the stopped state (similar
    to the `WUNTRACED `option)'
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WNOWAIT`: Block upon children, but once unblocked, leave them in a waitable
    state so that they can be waited-upon again with a later wait* API.'
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third parameter is a (large) data structure of type `siginfo_t`; (we shall
    cover details in [Chapter 11](99fafa09-8972-4d9f-b241-46caf9de98f3.xhtml), *Signaling
    - Part I*). On return of `waitid(2)`, this will get populated by the kernel. Various
    fields get set by the OS, among them, the PID of the child that changed state
    (`si_pid`), `si_signo` set to `SIGCHLD`, `si_status, si_code`. We intend to cover
    these in a later chapter (for now, please refer to the man page).
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: 'There are BSD variations of `wait`APIs too: the `wait3`and the` wait4`*. *However,
    these are nowadays considered outdated; use the `waitpid(2)`or `waitid(2)` APIs
    instead.'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: The actual system call
  id: totrans-388
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have seen several APIs that perform the work of having the parent process `wait `until
    the child changes state (dies, or stops, or resumes after stop):'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: '`wait`'
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`waitpid`'
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`waitid`'
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`wait3`'
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`wait4`'
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Interestingly, and similar to the situation with the exec family APIs, the
    Linux implementation is such that most of the preceding APIs are library (`glibc`)
    wrappers: The fact is that, on the Linux OS, of all the preceding APIs, `wait4(2)`is
    the actual system call API.'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: 'Performing an `strace(1)`on a program that uses one of the `wait` APIs proves
    the point (we `strace`our `simpsh_v1`program, which calls `wait`):'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This is the output of `strace`*:*
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'While discussing performing an `strace`, another interesting question does
    arise: if you `strace`an application that calls `fork(2)`*, *after the `fork`API,
    will `strace`trace the execution path of the child process as well? By default,
    no, but just pass along the `-f` option, and it will!'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: 'The man page on `strace(1)` says this:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'In a similar vein, systems programmers are probably aware of the tremendously
    powerful GNU debugger—GDB. If one is debugging a multiprocess application with
    `gdb(1)`, how can one request GDB which process''s execution path to follow after
    encountering a fork in the instruction stream? The setting is called `follow-fork-mode`:
    in `gdb`; here, we show an example of setting the mode to `child`:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'With respect to GDB: Debugging multi-process applications with GDB: Using the
    GDB `attach <PID>` command is useful to `attach` to another process (say, the
    child). GDB also provides a powerful `catch` command; see `help catch` in GDB
    for more details.'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: A note on the vfork
  id: totrans-406
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Decades ago, the BSD Unix developers came up with an efficient special case
    system call— the `vfork(2)`*. *The idea at the time, was to perform some optimizations
    where you performed a fork and almost immediately an exec in the child (the fork-exec, in
    other words). As we know, using the fork-exec is quite a common and useful semantic
    (the shell and network servers use it heavily). When the vfork is called instead
    of the fork, the kernel does not go through the heavy copying operations usually
    required; it optimizes things.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: 'The bottom line is this: At the time, `vfork(2)` was useful on Unix; but today''s
    Linux `fork(2)` is as optimized as can be, rendering the `vfork` to the back door.
    It''s still there, for perhaps two reasons:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: Compatibility—to aid the porting of BSD apps to Linux
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is apparently useful on some arcane special Linuxes that run on MMU-less
    processors ( like uClinux)
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On today's regular Linux platforms, it is not recommended to use the `vfork(2)`;
    just stick to the `fork(2)`.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: More Unix weirdness
  id: totrans-412
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'From fork rule #3, we understand that the parent and child processes run in
    parallel. What if one of them terminate? Will the other die too? Well, no, of
    course not; they are independent entities. However, there are side effects.'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: Orphans
  id: totrans-414
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Consider this scenario: A process forks, the parent and child are alive and
    running their individual code paths in parallel. Let''s say the parent''s PID
    is 100 and the child''s is 102, implying the child''s PPID is 100 of course.'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: 'The parent process, for whatever reason, dies. The child continues on without
    any trouble, except for a side effect: The moment the parent (PID 100) dies, the
    child''s PPID (100) is now invalid! Thus, the kernel intervenes, setting the child''s
    PPID to the overall mothership—the ancestor of all user space tasks, the root
    of the process tree—the init, or on recent Linux, the systemd, process! It''s
    PID is, by venerable Unix convention, always the number `1`.'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: 'Terminology: the child that lost its immediate parent is now said to be re-parented
    by systemd (or init), and its PPID will thus be `1`; this child is now an orphan.'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: There is a possibility that the overall ancestor process (init or systemd) does *not* have
    PID 1, and thus the orphan's PPID may not be 1; this can occur, for example, on
    Linux containersor custom namespaces.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: We notice that the child's PPID value abruptly changed; thus, the systems programmer
    must ensure that they do *not *depend on the PPID value being the same (which
    can always be queried via the `getppid(2)`system call) for any reason!
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: Zombies
  id: totrans-420
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The orphaned process does not pose any problem; there is another scenario with
    the distinct possibility of a nasty problem arising out of it.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this scenario: a process forks, the parent and child are alive and
    running their individual code paths in parallel. Let''s say the parent''s PID
    is 100 and the child''s is 102, implying the child''s PPID is 100 of course.'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we delve into a further level of detail: the parent process is supposed
    to wait upon the termination of its children (via any of the available `wait*(2)`APIs
    of course); what if it does not? Ah, this is really the bad case.'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine this scenario: the child process terminates, but the parent is not waiting
    (blocking) upon it; thus it continues to execute its code. The kernel, however,
    is not pleased: The Unix rule is that the parent process must block upon its children! As
    the parent isn''t, the kernel cannot afford to completely clean up the just-dead
    child; it does release the entire VAS freeing up all the memory, it does flush
    and close all open files, as well as other data structures, but it does not clear
    the child''s entry in the kernel''s process table. Thus, the dead child still
    has a perfectly valid PID and some miscellaneous information (it''s exit status,
    exit bitmask, and so on). The kernel keeps these details as this is the Unix way:
    the parent must wait upon its children and reap them, that is, fetch their termination
    status information, when they die. How does the parent process reap the child(ren)?
    Simple: by performing the wait!'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: 'So, think about it: The child has died; the parent has not bothered to *wait *for
    it; the kernel has cleaned up, to some extent, the child process. But it technically
    exists, as it''s half dead and half alive; it''s what we call a ***zombie process**.* In
    fact, this is a process state on Unix: Z for zombie (you can see this in the output
    of `ps -l`; additionally, the process is marked as *defunct*).'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: 'So why not just kill off the zombie(s)? Well, they''re already dead; we cannot
    kill them. The reader might then query, well, so what? let them be. OK, there
    are two reasons that zombies cause real headaches on production systems:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: They take up a precious PID
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The amount of kernel memory taken up by the zombie is not insignificant (and
    essentially is a waste)
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, the bottom line is this: a couple of zombies might be OK, but dozens and
    hundreds, and more, are certainly not. You could reach a point where the system
    is so clogged with zombies that no other process can run—the `fork(2)` fails with `errno `set
    to `EAGAIN` (try again later) as no PIDs are available! It''s a dangerous situation.'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: 'The Linux kernel developers had the insight to provide a quick fix: if you
    notice zombies on the system, you can, at least temporarily, get rid of them by
    killing their parent process! (Once the parent is dead, of what use is it to have
    the zombies? The point was, they remained so that the parent could reap them by
    doing a wait). Note that this is merely a bandage, not a solution; the solution
    is to fix the code (see the following rule).'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a key point; in fact, what we call the wait scenario #4: the wait gets
    unblocked with children that already terminated, in effect, the zombies. In other
    words, you not only should, you must, wait upon all children; otherwise, zombies
    will occur (Note that the zombie is a valid process state on the Unix/Linux OS;
    every process, on the ''way'' to death will pass through the **zombie** (Z)  state.
    For most it''s transient; it should not remain in this state for any significant
    length of time).'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: 'Fork rule #7'
  id: totrans-432
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All of this neatly brings us to our next rule of fork.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: '**Fork rule #7**: *The parent process must wait (block) upon the termination
    (death) of every child, directly or indirectly*.'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: 'The fact is that, just like the `malloc-free`, the `fork-wait` go together.
    There will be situations in real-world projects where it might look impossible
    for us to force the parent process to block on the wait  after the fork; we shall
    address how these seemingly difficult situations can be easily addressed (that''s
    why we refer to an indirect method as well; hint: it''s to do with signaling,
    the topic of the next chapter).'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: The rules of fork – a summary
  id: totrans-436
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For your convenience, this table summarizes the fork rules we have encoded
    in this chapter:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: '| **Rule** | **The rule of fork** |'
  id: totrans-438
  prefs: []
  type: TYPE_TB
- en: '| 1 | After a successful fork, execution in both the parent and child process
    continues at the instruction following the fork |'
  id: totrans-439
  prefs: []
  type: TYPE_TB
- en: '| 2 | To determine whether you are running in the parent or child process,
    use the fork return value: it''s always `0` in the child, and the PID of the child
    in the parent |'
  id: totrans-440
  prefs: []
  type: TYPE_TB
- en: '| 3 | After a successful fork, both the parent and child process execute code
    in parallel |'
  id: totrans-441
  prefs: []
  type: TYPE_TB
- en: '| 4 | Data is copied across the fork, not shared |'
  id: totrans-442
  prefs: []
  type: TYPE_TB
- en: '| 5 | After the fork, the order of execution between the parent and child process
    is indeterminate |'
  id: totrans-443
  prefs: []
  type: TYPE_TB
- en: '| 6 | Open files are (loosely) shared across the fork |'
  id: totrans-444
  prefs: []
  type: TYPE_TB
- en: '| 7 | The parent process must wait (block) upon the termination (death) of
    every child, directly or indirectly |'
  id: totrans-445
  prefs: []
  type: TYPE_TB
- en: Summary
  id: totrans-446
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A core area of Unix/Linux systems programming is learning how to correctly handle
    the all-important `fork(2)`system call, to create a new process on the system.
    Using the `fork(2)`correctly takes a lot of deep insights. This chapter helped
    the systems developer by providing several key rules of fork. The concepts learned—the
    rules, working with data, open files, security issues, and so on—were revealed
    via several code examples. A lot of details on how to wait for your children processes
    correctly were discussed. What exactly are orphans and zombie processes, and why
    and how we should avoid zombies was dealt with too.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
