- en: Table Maintenance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing Percona Toolkit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Altering tables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moving tables across databases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Altering tables using an online schema change tool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Archiving tables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cloning tables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Partitioning tables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Partition pruning and selection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Partition management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Partition information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Efficiently managing time to live and soft delete rows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the key aspects in maintaining a database is managing tables. Often,
    you need to alter a big table or clone a table. In this chapter, you will learn
    about managing big tables. Some open source third-party tools are used as MySQL
    does not support certain operations. The installation and usage of third-party
    tools are also covered in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Percona Toolkit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Percona Toolkit is a collection of advanced open source command-line tools,
    developed and used by Percona to perform a variety of tasks that are too difficult
    or complex to perform manually. The installation is covered in this section. In
    the later sections, you will learn how to use it.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let us see how to install Percona Toolkit on various operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: On Debian/Ubuntu
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Download the repository package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Install the repository package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Update local package list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Make sure that Percona packages are available:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Install the `percona-toolkit` package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'If you do not want to install a repository, you can also install directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: On CentOS/Red Hat/Fedora
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Install the repository package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following if successful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Make sure that Percona packages are available:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Install Percona Toolkit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If you do not want to install a repository, you can directly install using
    YUM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Altering tables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`ALTER TABLE` changes the structure of a table. For example, you can add or
    delete columns, create or destroy indexes, change the type of existing columns,
    or rename columns or the table itself.'
  prefs: []
  type: TYPE_NORMAL
- en: While performing certain alter operations such as changing a column data type,
    adding a `SPATIAL INDEX`, dropping a primary key, converting a character set,
    adding/removing encryption, and so on, DML operations on the table are blocked.
    If the table is big, it will take even more time to alter, and the application
    cannot access the table during that time, which is not desired. In those situations,
    a `pt-online-schema` change is helpful, where DML statements are allowed.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two algorithms for alter operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '**In-place** (default): Does not require copying whole table data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Copy**: Copies the data into a temporary disk file and renames it'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Only certain alter operations can be done in-place. The performance of an online
    DDL operation is largely determined by whether the operation is performed in-place,
    or requires copying and rebuilding the entire table. Refer to [https://dev.mysql.com/doc/refman/8.0/en/innodb-create-index-overview.html#innodb-online-ddl-summary-grid](https://dev.mysql.com/doc/refman/8.0/en/innodb-create-index-overview.html#innodb-online-ddl-summary-grid)
    to see what kinds of operations can be performed in-place, and any requirements
    for avoiding table-copy operations.
  prefs: []
  type: TYPE_NORMAL
- en: '*How copy algorithm works* (taken from the reference manual—[https://dev.mysql.com/doc/refman/8.0/en/alter-table.html](https://dev.mysql.com/doc/refman/8.0/en/alter-table.html))'
  prefs: []
  type: TYPE_NORMAL
- en: '`ALTER TABLE` operations that are not performed *in-place* make a temporary
    copy of the original table. MySQL waits for other operations that are modifying
    the table, then proceeds. It incorporates the alteration into the copy, deletes
    the original table, and renames the new one. While `ALTER TABLE` is executing,
    the original table is readable by other sessions. Updates and writes to the table
    that begin after the `ALTER TABLE` operation begins are stalled until the new
    table is ready, then are automatically redirected to the new table without any
    failed updates. The temporary copy of the original table is created in the database
    directory of the new table. This can differ from the database directory of the
    original table for `ALTER TABLE` operations that rename the table to a different
    database.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To get an idea on whether a DDL operation performs in-place or a table copy,
    look at the `rows affected` value displayed after the command finishes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Changing the default value of a column (superfast, does not affect the table
    data at all), the output would be some thing like this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding an index (takes time, but `0 rows affected` shows that the table is
    not copied), the output would be some thing like this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Query OK, 0 rows affected (21.42 sec)`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Changing the data type of a column (takes substantial time and does require
    rebuilding all the rows of the table), , the output would be some thing like this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Changing the data type of a column requires rebuilding all the rows of the table
    with the exception of changing the `VARCHAR` size, which may be performed using
    online `ALTER TABLE`. See the example mentioned in the *Altering tables using
    an online schema change tool* section, which shows how to modify column properties
    using `pt-online-schema`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you want to add a new column to the `employees` table, you can execute the
    `ADD COLUMN` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: You can see that the number of rows affected is `0`, which means that the table
    is not copied and the operation is done in-place.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to increase the length of the `varchar` column, you can execute
    the `MODIFY COLUMN` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'If you think that `varchar(255)` is not sufficient to store addresses, and
    you would like to change it to `tinytext`, you can use the `MODIFY COLUMN` statement.
    However, in this case, since you are modifying the data type of a column, all
    the rows of the existing table should be modified, which requires table copy,
    and DMLs are blocked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: You will notice that the rows affected are `300025`, which is the size of the
    table.
  prefs: []
  type: TYPE_NORMAL
- en: There are various other operations that you can do, such as renaming a column,
    changing the default value, reordering the column positions, and so on; refer
    to the manual at [https://dev.mysql.com/doc/refman/8.0/en/innodb-create-index-overview.html](https://dev.mysql.com/doc/refman/8.0/en/innodb-create-index-overview.html) for
    more details.
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding a virtual generated column is just a metadata change and is almost instantaneous:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'However, adding a `STORED GENERATED` column and modifying the `VIRTUAL GENERATED`
    column is not online:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Moving tables across databases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can rename a table by executing the `RENAME TABLE` statement.
  prefs: []
  type: TYPE_NORMAL
- en: For the following illustrations to work, create sample tables and databases
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For example, if you want to rename the `audit_log` table `audit_log_archive_2018`,
    you can execute the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to move the table from one database to an other, you can use dot
    notation to specify the database name. For example, if you want to move the `audit_log`
    table from the database named `prod` to the database named `archive`, execute
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Altering tables using an online schema change tool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you will learn about Percona's `pt-online-schema-change` (`pt-osc`)
    tool, which is used to perform `ALTER TABLE` operations without blocking DMLs.
  prefs: []
  type: TYPE_NORMAL
- en: '`pt-osc` comes along with Percona Toolkit. Installation of Percona Toolkit
    has already been described earlier in the chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: (Taken from [https://www.percona.com/doc/percona-toolkit/LATEST/pt-online-schema-change.html](https://www.percona.com/doc/percona-toolkit/LATEST/pt-online-schema-change.html).)
  prefs: []
  type: TYPE_NORMAL
- en: '`pt-online-schema-change` works by creating an empty copy of the table to alter,
    modifying it as desired, and then copying rows from the original table into the
    new table. When the copy is complete, it moves away the original table and replaces
    it with the new one. By default, it also drops the original table.'
  prefs: []
  type: TYPE_NORMAL
- en: The data copy process is performed in small chunks of data, which are varied
    to attempt to make them execute in a specific amount of time. Any modifications
    to data in the original tables during the copy will be reflected in the new table,
    because the tool creates triggers on the original table to update the corresponding
    rows in the new table. The use of triggers means that the tool will not work if
    any triggers are already defined on the table.
  prefs: []
  type: TYPE_NORMAL
- en: When the tool finishes copying data into the new table, it uses an atomic `RENAME
    TABLE` operation to simultaneously rename the original and new tables. After this
    is complete, the tool drops the original table.
  prefs: []
  type: TYPE_NORMAL
- en: Foreign keys complicate the tool's operation and introduce additional risk.
    The technique of atomically renaming the original and new tables does not work
    when foreign keys refer to the table. The tool must update foreign keys to refer
    to the new table after the schema change is complete. The tool supports two methods
    for accomplishing this. You can read more about this in the documentation for
    `--alter-foreign-keys-method`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Modifying the column data type can be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: You will have noticed that the tool has created a new table with a modified
    structure, created triggers on the table, copied the rows to a new table, and
    finally, renamed the new table.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to alter the `salaries` table, which already has triggers, you
    need to specify the `--preserver-triggers` option, otherwise you will end up with
    the error: `The table `employees`.`salaries` has triggers but --preserve-triggers
    was not specified.`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: If the server has slaves, this tool can create a slave lag while copying from
    an existing table to a new table. To avoid this, you can specify `--check-slave-lag`
    (enabled by default); it pauses the data copy until this replica's lag is less
    than `--max-lag`, which is 1 second by default. You can specify `--max-lag` by
    passing the `--max-lag` option.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to make sure that the slaves will not be lagged by more than 10
    seconds, pass `--max-lag=10`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: For more details and options, refer to the Percona documentation, at[ ](https://www.percona.com/doc/percona-toolkit/LATEST/pt-online-schema-change.html)[https://www.percona.com/doc/percona-toolkit/LATEST/pt-online-schema-change.html](https://www.percona.com/doc/percona-toolkit/LATEST/pt-online-schema-change.html)[.](https://www.percona.com/doc/percona-toolkit/LATEST/pt-online-schema-change.html)
  prefs: []
  type: TYPE_NORMAL
- en: '`pt-online-schema-change` works only when there is a primary key or unique
    key, otherwise it will fail with the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: So, if the table does not have any unique key, you cannot use `pt-online-schema-change`.
  prefs: []
  type: TYPE_NORMAL
- en: Archiving tables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, you do not want to keep older data and wish to delete it. If you
    want to delete all the rows which were last accessed over a month ago, if the
    table is small (<10k rows), you can straight away use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: What happens if the table is big? You know `InnoDB` creates an `UNDO` log to
    restore failed transactions. So all the deleted rows are saved in the `UNDO` log
    space to be used to restore in case the `DELETE` statement aborts in between.
    Unfortunately, if the `DELETE` statement is aborted in between, `InnoDB` copies
    the rows from the `UNDO` log space to table, which can make the table inaccessible.
  prefs: []
  type: TYPE_NORMAL
- en: To overcome this behavior, you can `LIMIT` the number of rows deleted and `COMMIT`
    the transaction, running the same thing in a loop until all the unwanted rows
    are deleted.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is an example pseudo code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: If there is no `INDEX` on `last_accessed`, it can lock the table. In that case,
    you need to find out the primary key for the deleted rows and delete based on
    `PRIMARY KEY`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the pseudo code, assuming `id` is the `PRIMARY KEY`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Instead of writing the code for deleting the rows, you can use Percona's `pt-archiver`
    tool, which essentially does the same and provides many other options, such as
    saving the rows into another table or file, fine control over the load and replication
    delay, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many options in `pt-archiver`, we will start with simple purging.
  prefs: []
  type: TYPE_NORMAL
- en: Purging data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you want to delete all the rows from the `employees` table for which `hire_date`
    is older than 30 years, you can execute the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: You can pass the hostname, database name, and table name through the `--source`
    option. You can limit the number of rows to delete in a batch using the `--limit`
    option.
  prefs: []
  type: TYPE_NORMAL
- en: If you specify `--progress`, the output is a header row, plus status output
    at intervals. Each row in the status output lists the current date and time, how
    many seconds `pt-archiver` has been running, and how many rows it has archived.
  prefs: []
  type: TYPE_NORMAL
- en: If you specify `--statistics`, `pt-archiver` outputs timing and other information
    to help you identify which part of your archiving process takes the most time.
  prefs: []
  type: TYPE_NORMAL
- en: If you specify `--check-slave-lag`, the tool will pause archiving until the
    slave lag is less than `--max-lag`.
  prefs: []
  type: TYPE_NORMAL
- en: Archiving data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you want to save the rows after deletion into a separate table or file, you
    can specify the `--dest` option.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose you want to move all the rows of the `employees` table from the `employees`
    database to the `employees_archive` table, you can execute the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: If you specify `--where="1=1"`, it copies all rows.
  prefs: []
  type: TYPE_NORMAL
- en: Copying data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you want to copy data from one table to another, you can either use `mysqldump`
    or `mysqlpump` to back up certain rows and then load them into the destination
    table. As an alternative, you can also use `pt-archive`. If you specify the `--no-delete`
    option, `pt-archiver` will not delete the rows from the source:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Refer to [https://www.percona.com/doc/percona-toolkit/LATEST/pt-archiver.html](https://www.percona.com/doc/percona-toolkit/LATEST/pt-archiver.html)
    for more details about and options for `pt-archiver`.
  prefs: []
  type: TYPE_NORMAL
- en: Cloning tables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you want to clone a table, there are many options.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Use the `INSERT INTO SELECT` statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Note that if there are any generated columns, the above statement would not
    work. In that case, you should give full insert statement excluding the generated
    columns.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: But the preceding statement is very slow and dangerous on big tables. Remember,
    if the statement fails, to restore the table state, `InnoDB` saves all the rows
    in `UNDO` logs.
  prefs: []
  type: TYPE_NORMAL
- en: Use `mysqldump` or `mysqlpump` and take a backup of a single table and restore
    it on destination. This can take very long time if the table is big.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use `Innobackupex` to take a backup of specific table and restore the data file
    onto destination.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use `pt-archiver` with the `--no-delete` option, which will copy the desired
    rows or all rows to the destination table.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can also clone tables by using transportable tablespaces, which are explained
    in the *Copying file-per-table tablespaces to another instance* section of [Chapter
    11](part0388.html#BI0Q80-faa69fe6f4c04957afca3568dcd9cd83), *Managing Tablespace.*
  prefs: []
  type: TYPE_NORMAL
- en: Partitioning tables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can distribute portions of individual tables across a filesystem using partitions.
    The user-selected rule by which the division of data is accomplished is known
    as a partitioning function, which can be modulus, simple matching against a set
    of ranges or value lists, an internal hashing function, or a linear hashing function.
  prefs: []
  type: TYPE_NORMAL
- en: Different rows of a table may be assigned to different physical partitions,
    which is called horizontal partitioning. MySQL does not have support for vertical
    partitioning, in which different columns of a table are assigned to different
    physical partitions.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many ways to partition a table:'
  prefs: []
  type: TYPE_NORMAL
- en: '`RANGE`: This type of partitioning assigns rows to partitions based on column
    values falling within a given range.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LIST`: Similar to partitioning by `RANGE`, except that the partition is selected
    based on columns matching one of a set of discrete values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HASH`: With this type of partitioning, a partition is selected based on the
    value returned by a user-defined expression that operates on column values in
    rows to be inserted into the table. The function may consist of any expression
    valid in MySQL that yields a non-negative integer value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`KEY`: This type of partitioning is similar to partitioning by `HASH`, except
    that only one or more columns to be evaluated are supplied, and the MySQL server
    provides its own hashing function. These columns can contain other than integer
    values, since the hashing function supplied by MySQL guarantees an integer result
    regardless of the column data type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of the preceding partition types have an extension. `RANGE` has `RANGE
    COLUMNS`, `LIST` has `LIST COLUMNS`, `HASH` has `LINEAR HASH`, and `KEY` has `LINEAR
    KEY`.
  prefs: []
  type: TYPE_NORMAL
- en: For `[LINEAR] KEY`, `RANGE COLUMNS`, and `LIST COLUMNS` partitioning, the partitioning
    expression consists of a list of one or more columns.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of `RANGE`, `LIST`, and `[LINEAR] HASH` partitioning, the value
    of the partitioning column is passed to the partitioning function, which returns
    an integer value representing the number of the partition in which that particular
    record should be stored. This function must be non-constant and non-random.
  prefs: []
  type: TYPE_NORMAL
- en: A very common use of database partitioning is to segregate data by date.
  prefs: []
  type: TYPE_NORMAL
- en: Refer to [https://dev.mysql.com/doc/refman/8.0/en/partitioning-overview.html](https://dev.mysql.com/doc/refman/8.0/en/partitioning-overview.html)
    for advantages and other details on partitioning.
  prefs: []
  type: TYPE_NORMAL
- en: Note that partitions work only for `InnoDB` tables, and foreign keys are not
    yet supported in conjunction with partitioning.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can specify the partitioning while creating the table or by executing the
    `ALTER TABLE` command. The partition column should be part of all the unique keys
    in the table.
  prefs: []
  type: TYPE_NORMAL
- en: If you defined partitions based on the `created_at` column and `id` is the primary
    key, you should include the `create_at` column as part of `PRIMARY KEY`, that
    is, (`id`, `created_at`).
  prefs: []
  type: TYPE_NORMAL
- en: The following example assumes that there are no foreign keys referenced to the
    table.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you wish to implement a partitioning scheme based on ranges or intervals
    of time in MySQL 8.0, you have two options:'
  prefs: []
  type: TYPE_NORMAL
- en: Partition the table by `RANGE`, and for the partitioning expression, employ
    a function operating on a `DATE`, `TIME`, or `DATETIME` column and returning an
    integer value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Partition the table by `RANGE COLUMNS`, using a `DATE` or `DATETIME` column
    as the partitioning column
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RANGE partitioning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you want to partition the `employees` table based on `emp_no` and you want
    to keep 100,000 employees in one partition, you can create it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: So, all the employees having `emp_no` less than 100,000 will go to partition
    `p0` and all the employees having the `emp_no` less than `200000` and greater
    than `100000` will go to partition `p1`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the employee number is above `500000`, since there is no partition defined
    for them, the insert will fail with error. To avoid this, you have to regularly
    check and add partitions or  create a `MAXVALUE` partition to catch all such exceptions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to partition based on `hire_date`, you can use the `YEAR(hire_date)`
    function as the partition expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Partitioning in MySQL is widely used on `date`, `datetime`, or `timestamp` columns.
    If you want to store some events on the database, and all the queries are based
    out of a time range, you can use partitioning like this.
  prefs: []
  type: TYPE_NORMAL
- en: 'The partitioning function `to_days()` returns the number of days since `0000-01-01`,
    which is a integer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to convert an existing table into a partitioned table, and if the
    partition key is not part of `PRIMARY KEY`, you need to drop `PRIMARY KEY` and
    add the partition key as part of `PRIMARY KEY` and all unique keys. Otherwise,
    you will get the error `ERROR 1503 (HY000): A PRIMARY KEY must include all columns
    in the table''s partitioning function.`. You can do that as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: For more details on `RANGE` partitioning, refer to [https://dev.mysql.com/doc/refman/8.0/en/partitioning-range.html](https://dev.mysql.com/doc/refman/8.0/en/partitioning-range.html).
  prefs: []
  type: TYPE_NORMAL
- en: Removing partitioning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you wish to remove partitioning, you can execute the `REMOVE PARTITIONING`
    statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: RANGE COLUMNS partitioning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`RANGE COLUMNS` partitioning is similar to `RANGE` partitioning, but enables
    you to define partitions using ranges based on multiple column values. In addition,
    you can define the ranges using columns of types other than integer types. `RANGE
    COLUMNS` partitioning differs significantly from `RANGE` partitioning in the following
    ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '`RANGE COLUMNS` does not accept expressions, only names of columns'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RANGE COLUMNS` accepts a list of one or more columns'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RANGE COLUMNS` partitioning columns are not restricted to integer columns;
    string, `DATE` and `DATETIME` columns can also be used as partitioning columns'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Instead of using the `to_days()` or `year()` function, you can directly use
    the column `hire_date` in `RANGE COLUMNS`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Or you can divide employees based on their `last_name`. This will not guarantee
    uniform distribution across the partitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Using `RANGE COLUMNS`, you can put multiple columns in the partition function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'If you insert values `a=10`, `b=20`, `c=100`, `d=100`, `e=100`, it goes to
    `p1`. When designing tables partitioned by `RANGE COLUMNS`, you can always test
    successive partition definitions by comparing the desired tuples using the `mysql`
    client, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the insert goes to `p1`.
  prefs: []
  type: TYPE_NORMAL
- en: LIST and LIST COLUMNS partitioning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`LIST` partitioning is similar to `RANGE` partitioning, where each partition
    is defined and selected based on the membership of a column value in one of a
    set of value lists, rather than in one of a set of contiguous ranges of values.'
  prefs: []
  type: TYPE_NORMAL
- en: You need to define it by `PARTITION BY LIST(<expr>)`, where `expr` is a column
    value or an expression based on a column value and returning an integer value.
  prefs: []
  type: TYPE_NORMAL
- en: Partition definition contains `VALUES IN (<value_list>)`, where `value_list`
    is a comma-separated list of integers rather than `VALUES LESS THAN (<value>)`.
  prefs: []
  type: TYPE_NORMAL
- en: If you wish to use data types other than integers, you can use `LIST COLUMNS`.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike the case with `RANGE` partitioning, there is no `catch-all` such as `MAXVALUE`;
    all expected values for the partitioning expression should be covered in the `PARTITION`
    expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose there is a customer table with a zip code and city. If, for example,
    you want to divide the customers with certain zip codes in a partition, you can
    use `LIST` partitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'If you wish to use the columns directly, rather than integers, you can use
    `LIST COLUMNS`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: HASH and LINEAR HASH partitioning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Partitioning by `HASH` is used primarily to ensure an even distribution of data
    among a predetermined number of partitions. With range or list partitioning, you
    must specify explicitly which partition a given column value or set of column
    values should be stored in; with hash partitioning, this decision is taken care
    of for you, and you need only specify a column value or expression based on a
    column value to be hashed and the number of partitions into which the partitioned
    table is to be divided.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to evenly distribute employees, instead of `RANGE` partitioning
    over `YEAR(hire_date)`, you can use `HASH of YEAR(hire_date)` and specify the
    number of partitions. When `PARTITION BY HASH` is used, the storage engine determines
    which partition to use based on the modulus of the result of the expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if the `hire_date` is `1987-11-28`, `YEAR(hire_date)` would be
    `1987` and `MOD(1987,8)` is `3`. So the row goes to third partition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The most efficient hashing function is one which operates upon a single table
    column and whose value increases or decreases consistently with the column value.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `LINEAR HASH` partitioning, you can use the same syntax, except for adding
    a `LINEAR` keyword. Instead of a `MODULUS` operation, MySQL uses a powers-of-two
    algorithm for determining the partition. Refer to [https://dev.mysql.com/doc/refman/8.0/en/partitioning-linear-hash.html](https://dev.mysql.com/doc/refman/8.0/en/partitioning-linear-hash.html)
    for more details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: KEY and LINEAR KEY partitioning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Partitioning by key is similar to partitioning by hash, except that, where hash
    partitioning employs a user-defined expression, the hashing function for key partitioning
    is supplied by the MySQL server. This internal hashing function is based on the
    same algorithm as the `PASSWORD()` function.
  prefs: []
  type: TYPE_NORMAL
- en: '`KEY` takes only a list of zero or more column names. Any columns used as the
    partitioning key must comprise part or all of the table''s primary key, if the
    table has one. Where no column name is specified as the partitioning key, the
    table''s primary key is used, if there is one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Subpartitioning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can further divide each partition into a partitioned table. This is called
    **subpartitioning** or **composite partitioning**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Partition pruning and selection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MySQL does not scan partitions where there are no matching values; this is automatic
    and is called partition pruning. The MySQL optimizer evaluates the partitioning
    expression for the value given, determines which partition contains that value,
    and scans only that partition.
  prefs: []
  type: TYPE_NORMAL
- en: '`SELECT`, `DELETE`, and `UPDATE` statements support partition pruning. `INSERT`
    statements currently cannot be pruned.'
  prefs: []
  type: TYPE_NORMAL
- en: You can also explicitly specify partitions and subpartitions for rows matching
    a given `WHERE` condition.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Partition pruning applies only to queries, but explicit selection of partitions
    is supported for both queries and a number of DML statements.
  prefs: []
  type: TYPE_NORMAL
- en: Partition pruning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Take the example of the `employees` table, which is partitioned based on `emp_no`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Suppose the following `SELECT` query is executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: MySQL optimizer detects that partitioned column is being used in the query and
    automatically determines the partition to scan.
  prefs: []
  type: TYPE_NORMAL
- en: In this query, it first calculates the `YEAR('1999-02-01')`, which is `1999`,
    and scans the `p2000` partition rather than the whole table. This dramatically
    reduces the query time.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of `hire_date='1999-02-01'`, if a range is given, such as `hire_date>='1999-02-01'`,
    then the partitions `p2000`, `p2010`, `p2020`, and `pmax` are scanned.
  prefs: []
  type: TYPE_NORMAL
- en: If the expression `hire_date='1999-02-01'` is not given in the `WHERE` clause,
    MySQL has to scan the whole table.
  prefs: []
  type: TYPE_NORMAL
- en: 'To know which partitions the optimizer scans, you can execute the `EXPLAIN`
    plan of the query, which is explained in the *Explain plan* section of [Chapter
    13](part0432.html#CRVJ00-faa69fe6f4c04957afca3568dcd9cd83), *Performance Tuning*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Partition selection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Partition pruning is automatic selection based on the `WHERE` clause. You can
    explicitly specify the partitions to scan in the query. The queries can be `SELECT`,
    `DELETE`, `INSERT`, `REPLACE`, `UPDATE`, `LOAD DATA`, and `LOAD XML`. The `PARTITION`
    option is used to select partitions from a given table, you should specify the
    keyword `PARTITION` <partition name> immediately following the name of the table,
    before all other options, including any table alias, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, we can delete:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Partition management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The most important thing when it comes to managing partitions is adding sufficient
    partitions in advance for time-based `RANGE` partitioning. Failure to do so leads
    to errors while inserting or, if the `MAXVALUE` partition is defined, all the
    inserts go into the `MAXVALUE` partition. For example, take the `event_history`
    table without the `pmax` partition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The table accepts the `INSERTS` till October 15, 2017; after that, the `INSERTS`
    fail.
  prefs: []
  type: TYPE_NORMAL
- en: Another important thing is to `DELETE` the data after it crosses retention.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To perform these operations, you need to execute the `ALTER` command.
  prefs: []
  type: TYPE_NORMAL
- en: ADD partitions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To add a new partition, execute the `ADD PARTITION (<PARTITION DEFINITION>)`
    statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: This statement locks the whole table for a very short time.
  prefs: []
  type: TYPE_NORMAL
- en: Reorganizing partitions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If the `MAXVALUE` partition is there, you cannot add a partition after `MAXVALUE`;
    in that case, you need to the `REORGANIZE MAXVALUE` partition into two partitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Remember MySQL has to substantially move the data while reorganizing partitions
    and the table will be locked during that period.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also reorganize multiple partitions into a single partition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: DROP partitions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If the data has crossed the retention, you can `DROP` the whole partition, which
    is superquick compared with conventional `DELETE FROM TABLE` statement. This is
    very helpful in archiving the data efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: 'If `p20170930` has crossed the retention, you can `DROP` the partition using
    the `ALTER TABLE ... DROP PARTITION` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Dropping the partition removes the `PARTITION DEFINITION` from the table.
  prefs: []
  type: TYPE_NORMAL
- en: TRUNCATE partitions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you wish to keep `PARTITION DEFINITION` in the table and remove only the
    data, you can execute the `TRUNCATE PARTITION` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Managing HASH and KEY partitions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The operations performed on `HASH` and `KEY` partitions are quite different.
    You can only reduce or increase the number of partitions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose the `employees` table is partitioned based on `HASH`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'To reduce the partitions from `8` to `6`, you can execute the `COALESCE PARTITION`
    statement and specify the number of partitions you want to reduce, that is, *8-6=2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'To increase the partitions from `6` to `16`, you can execute the `ADD PARTITION`
    statement and specify the number of partitions you want to increase, that is,
    *16-6=10*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Other operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can also perform other operations, such as `REBUILD`, `OPTIMIZE`, `ANALYZE`,
    and `REPAIR` statements, for a particular partition, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Partition information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section discusses obtaining information about existing partitions, which
    can be done in a number of ways.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's get into the details.
  prefs: []
  type: TYPE_NORMAL
- en: Using SHOW CREATE TABLE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To know whether a table is partitioned or not, you can execute the `SHOW CREATE
    TABLE\G` statement, which shows the table definition along with partitions, for
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Using SHOW TABLE STATUS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can execute the `SHOW TABLE STATUS` command and check `Create_options`
    in the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Using EXPLAIN
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `EXPLAIN` plan shows all the partitions scanned for a query. If you run
    the `EXPLAIN` plan for `SELECT * FROM <table>`, it lists all the partitions, for
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Querying the INFORMATION_SCHEMA.PARTITIONS table
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Compared to all the preceding methods, `INFORMATION_SCHEMA.PARTITIONS` gives
    more information about the partitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'To find out more details about a table partition, you can query the `INFORMATION_SCHEMA.PARTITIONS`
    table by specifying the database name through `TABLE_SCHEMA` and table name through
    `TABLE_NAME`, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'You can get details such as `PARTITION_METHOD`, `PARTITION_EXPRESSION`, `PARTITION_DESCRIPTION`,
    and `TABLE_ROWS` in that partition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: For more details, refer to [https://dev.mysql.com/doc/refman/8.0/en/partitions-table.html](https://dev.mysql.com/doc/refman/8.0/en/partitions-table.html).
  prefs: []
  type: TYPE_NORMAL
- en: Efficiently managing time to live and soft delete rows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`RANGE COLUMNS` is highly useful in managing time to live and soft delete rows.
    Suppose you have a application which specifies the expiry time of row (row to
    be deleted after it crosses the expiry time) and the expiry is varying.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose the application can do the following types of inserts:'
  prefs: []
  type: TYPE_NORMAL
- en: Insert persistent data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Insert with expiry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the expiry is constant i.e all the rows inserted will be deleted after certain
    time, we can go with RANGE partitioning. But if the expiry is varying i.e some
    rows will be deleted in a week, some in a month, some in a year and some have
    no expiry, it is not possible to create partitions. In that case, you can use
    the `RANGE COLUMNS` partitioning explained below.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We introduce a column called `soft_delete` which will be set by trigger. The
    `soft_delete` column will be part of range column partitioning.
  prefs: []
  type: TYPE_NORMAL
- en: Partitioning will be like (`soft_delete`, expires). The `soft_delete` and expires
    together controls which partition a row should go. soft_delete column decides
    the retention of the row. If the expires is 0, the trigger sets the `soft_delete`
    value to 0 which puts the row in a `no_retention` partition and if the value of
    expires is out of partition bounds, trigger sets the `soft_delete` value to 1
    and the row will be put into a `long_retention` partition. If the value of expires
    is with in the partition bounds, trigger sets the `soft_delete` value to `2`.
    Depending on the value of the expires, the row will be put in respective partition.
  prefs: []
  type: TYPE_NORMAL
- en: 'To summarize, `soft_delete` will be :'
  prefs: []
  type: TYPE_NORMAL
- en: '`0`: If the value of expires is 0'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`1`: If the expires is more than 30 days away from the timestamp'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`2`: If the expires is less than or equal to 30 days away from the timestamp'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We create
  prefs: []
  type: TYPE_NORMAL
- en: 1 `no_retention` partition (`soft_delete = 0`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 `long_retention` partition (`soft_delete = 1`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 8 daily partitions (`soft_delete = 2`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can create a table like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: There will be a buffer weekly partition which will be 42 days away and will
    be always empty so that we can split and 7+2 daily partitions with 2 buffer.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Suppose the client inserts a row with timestamp of 1508265000 (2017-10-17 18:30:00)
    and expiry value of 1508351400 (2017-10-18 18:30:00), the soft_delete will be
    2 which makes it into partition pd20171019
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Suppose the client does not set expiry, expires column will be 0 which makes
    the `soft_delete` to `0` and it will go to `no_retention` partition.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Suppose the client wants to have expiry (assume 2017-10-19 06:30:00), expiry
    column can be updated which moves the row from `no_retention` partition to the
    respective partition (this has some performance impact because the row has to
    be moved across partitions)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Suppose the client sets a expiry which is beyond our partitions, it will automatically
    go into `long_retention` partition.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Movement of rows across partitions is slow, if you update the `soft_delete`,
    the row will be moved from default partition to other partition which will be
    slow.
  prefs: []
  type: TYPE_NORMAL
- en: '**Extending the logic**'
  prefs: []
  type: TYPE_NORMAL
- en: We can extend the logic and increase the value of `soft_delete` to accommodate
    more types of partitions.
  prefs: []
  type: TYPE_NORMAL
- en: '`0`: If the value of expires is 0'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`3`: If the expires is less than or equal to 7 days away from the timestamp'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`2`: If the expires is less than or equal to 60 days away from the timestamp'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`1`: If the expires is more than 60 days away from the timestamp'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `soft_delete` column will be part of partitioning. We create
  prefs: []
  type: TYPE_NORMAL
- en: Single `no_retention` partition if value of `soft_delete` is `0`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Single `long_retention` partition if the value of `soft_delete 1`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Weekly partitions if the value of `soft_delete 2`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Daily partitions if the value of `soft_delete 3`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Example partitioned table structure**'
  prefs: []
  type: TYPE_NORMAL
- en: There will be a buffer weekly partition which will be 42 days away and will
    be always empty so that we can split and 7+2 daily partitions with 2 buffer.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '**Managing partitions**'
  prefs: []
  type: TYPE_NORMAL
- en: You can create a `CRON` in Linux or `EVENT` in mysql to manage the partitions.
    As the retention approaches, the partition management tool should reorganize the
    buffer partition into one usable partition and a buffer partition and also drop
    the partitions which crossed the retention.
  prefs: []
  type: TYPE_NORMAL
- en: For example, take the `customer_data` table mentioned previously.
  prefs: []
  type: TYPE_NORMAL
- en: '**On 20171203, you have to split the partition pw20171210 into pw20171210 and
    pw20171217.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**On 20171017, you have to split the pd20171024 into pd20171024 and pd20171025.**'
  prefs: []
  type: TYPE_NORMAL
- en: Splitting(reorganizing) partitions would be very quick (~milli seconds if there
    are no queries locking the table) only if there is no (or very less) data. So
    we should aim to keep the partition empty by reorganizing it before the data enters
    the partition.
  prefs: []
  type: TYPE_NORMAL
