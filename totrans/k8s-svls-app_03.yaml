- en: Installing Kubernetes Locally
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will look at how to get a local Kubernetes installation
    up and running using Minikube. Once we have our local Kubernetes installation
    running, we will work through some of the basic functionality and discuss the
    limitations of running Kubernetes locally. We will work through installing Kubernetes
    on:'
  prefs: []
  type: TYPE_NORMAL
- en: macOS 10.13 High Sierra
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Windows 10 Professional
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ubuntu 17.04
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before we start the installation, let's quickly take a look at the tool we will
    be using to deploy our local Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: About Minikube
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the things you may have been thinking to yourself when reading the previous
    chapter is that Kubernetes seems complex. There are a lot of moving parts, which
    not only need to be configured but also monitored and managed.
  prefs: []
  type: TYPE_NORMAL
- en: I remember when I originally looked at Kubernetes when it was first released
    before the stable version, and the installation instructions were very long and
    also things were a little delicate.
  prefs: []
  type: TYPE_NORMAL
- en: Misread a step at the beginning of the installation process and you could find
    yourself in a lot of trouble later in the installationâ€”it reminded me of when
    magazines used to contain type in listings for games. If you made a typo anywhere
    then things would either flat-out not work or crash unexpectedly.
  prefs: []
  type: TYPE_NORMAL
- en: As Kubernetes matured, so did the installation process. Quite quickly a number
    of helper scripts were developed to aid in launching Kubernetes across various
    platforms; Minikube is one of these tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'It has one job, to create a local Kubernetes node. Considering the breadth
    of features supported by Kubernetes, it has a surprising number of features, such
    as:'
  prefs: []
  type: TYPE_NORMAL
- en: DNS, NodePorts, and Ingress
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ConfigMaps and Secrets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A choice of container runtimes; you can use either Docker or rkt
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Persistent Volumes via `hostPath`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dashboards
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Kubernetes features that would typically require a public cloud provider, such
    as AWS, Microsoft Azure, or Google Cloud, or multiple hosts, are not supported.
    Some of these features are:'
  prefs: []
  type: TYPE_NORMAL
- en: LoadBalancers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced scheduling policies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is because Minikube only launches a single node on a virtual machine on
    your local PC. This shouldn't limit you though; remember that you would only ever
    want to use Minikube for development and you should never build production services
    using it. There are a lot more tools, which will be covered in [Chapter 6](7f8f30b3-66f0-474e-9c0e-7cb3741e5eab.xhtml),
    *Installing Kubernetes in the Cloud*, more suited to launching production-ready
    Kubernetes clusters in public clouds or other vendors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Minikube is made up of two core components:'
  prefs: []
  type: TYPE_NORMAL
- en: '**libmachine**: This library from Docker is used to provision virtual machines
    on your host machine. It is a core component of Docker Machine as well as Docker
    for macOS and Docker for Windows.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**localkube**: This library, developed and donated to the Minikube project
    by Redspread (which is now a part of CoreOS), is responsible for deploying and
    maintaining the Kubernetes node once the virtual machine has been launched.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rather than talking about what Minikube can do any more, we should look at installing
    it and then discuss how we can interact with it.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Minikube
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will be looking at installing Minikube on the three different operating systems
    mentioned in the introduction. Once installed, the process for interacting with
    Minikube is mostly consistent, meaning that, while I will be using macOS in the
    examples, the same commands will work on both Windows and Linux. Given the complexities
    of the early Kubernetes installation and configuration procedure, you will be
    pleasantly surprised how simple the process now is.
  prefs: []
  type: TYPE_NORMAL
- en: macOS 10.13 High Sierra
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To install Minikube on macOS, you will first have to have Homebrew and Cask
    installed.
  prefs: []
  type: TYPE_NORMAL
- en: Homebrew is a command-line-based package manager for macOS. Homebrew is used
    to install both command-line tools and Cask, which is an add-on used to manage
    desktop applications. It is extremely useful for managing software that is not
    available in the macOS App Store, as well as saving you from having to manually
    compile software on your machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have not already got Homebrew installed, you can install it by running
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Once installed, you will need to install Cask by running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If you have Homebrew and Cask installed, then you should ensure that everything
    is up-to-date and ready to run using the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Once Homebrew and Cask are ready, you can install Minikube by running the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This will first of all download the dependencies and then install Minikube:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/464c27fa-0f16-4e69-ad1e-b1199b8d33ab.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The process takes less than a minute and, once installed, you should be able
    to perform the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This will display the current version; in my case, this was `v0.22.2`. We now
    have Minikube installed and ready to go.
  prefs: []
  type: TYPE_NORMAL
- en: Windows 10 Professional
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similarly to how we installed Minikube on macOS, we will be using a package
    manager; this time it is called Chocolatey.
  prefs: []
  type: TYPE_NORMAL
- en: Chocolatey is a package manager for Windows, similar to Homebrew on macOS. It
    enables you to install software from the command line, and supports both PowerShell
    and `cmd.exe`. We will be using PowerShell.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you do not have Chocolatey installed, you can run the following command
    in a PowerShell console that has been launched with administrator privileges:'
  prefs: []
  type: TYPE_NORMAL
- en: The following command is a single line and not multiple lines. Also, as we are
    running the install command using `Set-ExecutionPolicy Bypass`, you will be asked
    if you are sure. As we are running the script directly from the Chocolatey site
    over HTTPS, you should be able to trust the script and answer yes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Once Chocolatey is installed, you can install Minikube by running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This will download and install the dependencies, and then install Minikube.
    When you are asked to confirm if you would like to run the script, respond with
    yes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/7bee2b97-fc9e-4958-8396-3d9f9622162c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once installed, you will be able to run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This will return the version of Minikube installed; for me, this was `v0.22.2`.
  prefs: []
  type: TYPE_NORMAL
- en: Ubuntu 17.04
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Unlike the macOS and Windows version, we will not be using a package manager
    to install Minikube on Ubuntu 17.04\. Instead, we will just be downloading the
    binaries directly from the project page. To do this, simply run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Minikube will be downloaded, will have execute permissions set, and will be
    moved to `/usr/local/bin/` so it is in a system path.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that Minikube is installed, we need to download `kubectl`. During the macOS
    and Windows installation, this was taken care of by the package manager; luckily,
    the process is pretty much the same as the command we just ran to install Minikube:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Once installed, you should again be able to run the following command to confirm
    the version of Minikube installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'When I ran the command, it returned `v0.22.2`, as seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a69b796f-ae90-4574-929c-81543ba288e1.png)'
  prefs: []
  type: TYPE_IMG
- en: Hypervisors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A number of different hypervisors are supported by Minikube. A hypervisor is
    a process that is used to launch the virtual machine; it isolates the virtual
    machine's operating system from your own while allowing it to share resources
    such as CPU, RAM, and drive space.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following hypervisors are supported out-of-the-box by Minikube:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Hyper-V (Windows 10)**: This is the native hypervisor; it is available in
    Windows 10 Professional and Windows Servers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**KVM (Ubuntu 17.04)**: This is the native Linux hypervisor, which operates
    inside the Linux kernel on most modern distributions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**VirtualBox (macOS, Windows 10, and Ubuntu 17.04)**: Released by Oracle, VirtualBox
    is an open source x86 hypervisor which can be run on a large number of operating
    systems'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**VMware Fusion (macOS)**: Fusion provides a macOS-optimized hypervisor whose
    biggest strength is its ability to run and expose Windows applications on macOS'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**xhyve (macOS)**: This is the native hypervisor on macOS; like KVM on Linux,
    it is built into the kernel'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can tell from the list, only VirtualBox is supported across all three
    of the operating systems we are covering in this chapter. Because of this, it
    is the default hypervisor supported by Minikube. If you have already got VirtualBox
    installed, you can run the following commands, which are relevant to your choice
    of operating system.
  prefs: []
  type: TYPE_NORMAL
- en: 'For macOS, we can use Homebrew and Cask to install VirtualBox by running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Likewise, for Windows 10 you can use Chocolatey to install VirtualBox:'
  prefs: []
  type: TYPE_NORMAL
- en: You cannot use VirtualBox on Windows 10 if Hyper-V is enabled. If you wish to
    follow along, please disable Hyper-V before proceeding.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, for Ubuntu 17.04 you will need to run the following commands to add
    the repository and key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'And then run the following commands to load the repository we added previously
    and install the package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: You should now be able to see Virtualbox in your listed software programs.
  prefs: []
  type: TYPE_NORMAL
- en: Starting Minikube
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To complete our installation, we need to start Minikube. To do this, run the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'On macOS, you should see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/d38cb49c-8985-428f-b2aa-1050efa97202.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the ISO used to create the virtual machine has been downloaded.
    The virtual machine starts, the certificates that we will be using to authenticate
    against our one node cluster are generated, and then finally `kubectl` is configured
    with the details of our local Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the same command on Windows 10 results in exactly the same set of steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/f674dbe4-9477-4a5f-b435-8cc7595b4028.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Also, as you may have already guessed, running on Ubuntu 17.04 gives the same
    results. Run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'You will receive a message confirming that everything is running and that `kubectl`
    has been correctly configured to communicate with your Kubernetes cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/9d82313e-556f-4a63-acd5-9a313debb3fa.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you were to open VirtualBox, you should see your Minikube virtual machine
    running; for example, this is what I see when opening VirtualBox on Windows 10:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/9f35164d-8dc0-4b4d-b7ce-c0e8f17eb985.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Even though we have launched Minikube on three different operating systems,
    other than the initial installation, you can already experience what we discussed
    in [Chapter 2](494a207a-b5ff-4ee2-ae3c-c2abc8cbc108.xhtml), *An Introduction to
    Kubernetes*: there is no vendor lock-in and a consistent experience, and this
    is before we have started to use our newly installed Kubernetes cluster.'
  prefs: []
  type: TYPE_NORMAL
- en: Minikube commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have used the `minikube start` and `minikube status` commands to
    launch our single-node Kubernetes cluster and check that everything is running
    as expected. Before we look at interacting with Kubernetes, there are a few more
    basic Minikube commands I would like to cover.
  prefs: []
  type: TYPE_NORMAL
- en: Stop and delete
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we are running our single-node Kubernetes cluster as a virtual machine on
    your host, you may not want it running all of the time, using resources.
  prefs: []
  type: TYPE_NORMAL
- en: There are two options to achieve this, the first of which is `minikube stop`.
    This command will stop your node and keep the virtual machine intact. You should
    use this command if you plan on picking up where you left off when you next start
    your node by running `minikube start`.
  prefs: []
  type: TYPE_NORMAL
- en: While the `minikube stop` command stops your virtual machine from using CPU
    and RAM resources on the host machine, the hard disk image used to host the virtual
    machine will still be present on your machine. While a freshly launched cluster
    does not take much space on the host hard drive, on my macOS installation it is
    around 650 MB; as soon as you start to use the cluster, you may find that this
    space will at least double.
  prefs: []
  type: TYPE_NORMAL
- en: This is where our next command comes in. The `minikube delete` command will
    remove the cluster completely, including all of the virtual machine files, freeing
    the space used on the host machine.
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing, running `minikube delete` will immediately remove your
    machine, running or not. There is no prompt asking if you are sure, or any way
    back from the command (unless you have backups), so please ensure that you use
    this command with caution.
  prefs: []
  type: TYPE_NORMAL
- en: When you run `minikube start` again, your cluster will be started from scratch
    again, as we first experienced in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: Environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Next up, we have a few commands that display information about the virtual machine
    and also the environment that Minikube has configured on your device.
  prefs: []
  type: TYPE_NORMAL
- en: First, we have quite a simple command, `minikube ip`. All this command does
    is return the IP address of the virtual machine. This is useful if you want to
    interact with your cluster through a script. You can include the output of the
    command to reference your cluster's current IP address without having to hardcode
    the actual IP address into your scripts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next command we are going to look at is `minikube docker-env`. Running
    this command should print something like the following output to your screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'What that output does is allow you (if you have it installed) to configure
    your local Docker client to communicate with the Docker installation on our Minikube
    virtual machine. There is, however, a downside to doing this. The version of Docker
    that is currently being distributed as part of the Minikube virtual machine image
    is a little behind the current release. You can see this by running `eval $(minikube
    docker-env)` and then `docker version`. When I ran the two commands, I got the
    following results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the output, at the time of writing the version of Docker
    that Minikube is using is presently two versions behind my local installation
    of Docker for macOS, which is running the latest stable release. In the context
    of what we are covering in this book, running an older version of Docker is not
    a problem and nothing to worry about, as we will not be interacting with it directly.
  prefs: []
  type: TYPE_NORMAL
- en: Virtual machine access and logs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You are able to SSH into the Minikube virtual machine. As part of the installation,
    an SSH key was generated and shared with the virtual machine when it launched.
    You can check the location of this key by running `minikube ssh-key`. This returns
    the path of the private part of the key. You can use this in combination with
    other commands to SSH into your virtual machine by running the following on macOS
    or Ubuntu:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This generates the IP address of the virtual machine and path to the private
    key on-the-fly:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a0e42ee1-c47f-44a0-ba3f-1d2b969475e3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'However, Minikube also has a command that will run this for you and it is also  supported
    on all platforms. Running `minikube ssh` will log you straight in to the virtual
    machine as the Docker user, as is shown by the following Terminal output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/69225215-9ba9-4975-b5bc-1f538d51071e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The final command we are going to quickly look at is `minikube logs`. This
    displays all of the logs being generated by the `localkube` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/1956e512-f65d-4800-842d-f1273ce6aaee.png)'
  prefs: []
  type: TYPE_IMG
- en: These logs are used to help debug problems with your Minikube installation.
    They do not contain any user data, meaning that you cannot use them to help track
    down any problems with the services or pods you have launched.
  prefs: []
  type: TYPE_NORMAL
- en: Hello world
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we have our single node Kubernetes cluster up and running, using Minikube
    we can look at launching a service. We will start off using the dashboard before
    moving on to the command-line client.
  prefs: []
  type: TYPE_NORMAL
- en: The dashboard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Each installation of Minikube comes with a web-based dashboard. This can be
    accessed by running `minikube dashboard`, which immediately opens the dashboard
    in your default browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/37f69f3b-f34e-44b7-9570-875ab2ca69ae.png)'
  prefs: []
  type: TYPE_IMG
- en: Clicking on the + CREATE button, which can be found on the top-left of the page,
    will take you to a form that will let you deploy a containerized application.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the Deploy a Containerized App page, you will find several options. Keeping
    the Specify app details below option enabled, fill them in as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**App name**: `dashboard-hello-world`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Container image**: `nginx:latest`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Number of pods**: `1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Service**: External'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Port**: `8080`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Target port**: `80`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Protocol**: TCP'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For our purposes, we do not need to fill in any of the options that can be
    found under SHOW ADVANCED OPTIONS. Just click on the DEPLOY button at the bottom
    of the form. After a short while, your dashboard should show that you have a deployment,
    pod, ReplicaSet, and service, all with `dashboard-hello-world` in the Name:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/0d41bef9-a797-4ac8-8f1c-da8812423e57.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can view the service by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This will return the following message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Open your browser, where you should see the default NGINX page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/43019ac6-951f-4e28-8783-8e0e48aba3da.png)'
  prefs: []
  type: TYPE_IMG
- en: While this is a very basic example, it does show just how simple it is to launch
    a simple application using the dashboard. Now let's look at moving on to the command
    line.
  prefs: []
  type: TYPE_NORMAL
- en: The command line
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we briefly touched upon how you can use YAML or JSON
    files to define your pods, ReplicaSets, and services. Let's use `kubectl` to launch
    to an application that is to the preceding one.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we need a file to launch; you can find a copy of the following
    one, which is called `cli-hello-world.yml`, in the `Chapter03` folder of the code
    bundle and GitHub repository that accompany this title:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: As you may have noticed, while this is a single file we actually have two different
    sections. The first launches the external service, exposing it on port `8000`
    so that there isn't a clash with the external service we launched using the dashboard
    in the previous section. The second section defines the pod and replication set;
    this is pretty similar to what we launched using the dashboard.
  prefs: []
  type: TYPE_NORMAL
- en: 'To launch the application, we simply need to run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'You will almost immediately receive confirmation that a service and deployment
    have been created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Once created, you should then be able to run the following command to open
    the application in the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Again, you should be greeted by the default NGINX page.
  prefs: []
  type: TYPE_NORMAL
- en: I am sure that when we opened the dashboard you clicked around the menu items
    that can be found on the left of the page. All of this information can also be
    found on the command line, so let's briefly take a look at some of the commands
    we can use to find out more information about our cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the more common commands you will be running is `kubectl get`. This
    fetches lists of the pods, ReplicaSets, and services, as well as much more. Running
    the following commands should give us a similar view to the dashboard overview:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from the following Terminal output, everything is listed along
    with its current status:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/64c2e209-fa24-4d47-8db3-6b99d1cfa9e7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'There are plenty of options you can get; for example, try running this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Running just `kubectl get` will list all of the different parameters you can
    use. Now that have our full pod name, which in my case is `cli-hello-world-3678853705-f41d2`,
    we can find out more details about it by running the `kubectl describe` command.
    For example, I ran this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: When you run the command locally, please update the pod name to reflect your
    own. Kubernetes adds a unique ID to each pod when launched to ensure that you
    can run multiples of the same pod on any given host.
  prefs: []
  type: TYPE_NORMAL
- en: 'I had the following information returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use `kubectl describe` to find information on pretty much everything
    you can list using `kubectl get`, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Again, you can find out more by running just `kubectl describe` on its own.
    We will be introducing more commands throughout the following chapters so that,
    by the end of the book, you will be able to use `kubectl` to its fullest.
  prefs: []
  type: TYPE_NORMAL
- en: Before we finish this chapter, I want us to take a very quick look at how we
    can mount storage from our local machine inside the Minikube virtual machine and
    then inside our pods.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will find a folder called `html` in the `Chapter03` folder. This contains
    a single file called `index.html`. Running the following command in the `Chapter03`
    folder will mount the HTML inside the virtual machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see this from the message that is displayed after the command has run:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/393608e8-b7ce-4f2f-9d89-eb992e934f2e.png)At the time of writing
    there was a known bug using the `minikube mount` command on Windows 10 hosts,
    please see the following GitHub issues for more information [https://github.com/kubernetes/minikube/issues/1473](https://github.com/kubernetes/minikube/issues/1473)
    and [https://github.com/kubernetes/minikube/issues/2072](https://github.com/kubernetes/minikube/issues/2072).'
  prefs: []
  type: TYPE_NORMAL
- en: You will need to keep this process running, so open a new Terminal or PowerShell
    window for use in the remainder of this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'These will log you in to the Minikube virtual machine, get a directory listing
    of `/data/html/`, and then `exit` out of the virtual machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/bb20fd7e-b2c3-481b-ace5-9d98ee7191b6.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, our `index.html` file is available on the cluster node in `/data/html/`.
    Moving back to the `Chapter03` folder, you should see a file called `cli-hello-world-storage.yml`.
    This contains the service and deployment information that uses this mounted folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'The service section looks pretty similar to the one we used earlier in this
    section; however, there is an addition to the deployment section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, in the `spec` part of the deployment we are now defining a `volume`
    named `html`, then in the container part we are taking the volume named `html`
    and using the `mountPath` option to tell Kubernetes that we want the volume to
    be mounted at `/usr/share/nginx/html`, which is the default web root for the NGINX
    container image we are using within the container.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the `kubectl apply` command to launch your application, and then the `minikube
    service` command to open the service in your browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/eddcda5f-6a0b-4d40-aaeb-e07d3e1d3fe1.png)'
  prefs: []
  type: TYPE_IMG
- en: If you edit `index.html` in the `html` folder on your local machine, the changes
    will be immediately reflected when you refresh your browser window.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we move on to the next chapter, we should remove the Minikube machine
    we have used in this chapter so that we are starting with a clean slate. First
    of all, we have the process that is keeping the `html` folder from our host machine
    mounted. To terminate this process, go back to the Terminal or PowerShell and
    press *Ctrl* + *C*; this will send a termination signal to the process and return
    you to the command line. We can then run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This will remove the current virtual machine, meaning that, when we next start
    Minikube, it will be from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'More information on the tools we have used in this chapter can be found at
    their project pages:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Minikube**: [https://github.com/kubernetes/minikube](https://github.com/kubernetes/minikube)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**kubectl**: [https://kubernetes.io/docs/user-guide/kubectl-overview/](https://kubernetes.io/docs/user-guide/kubectl-overview/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Homebrew**: [https://brew.sh/](https://brew.sh)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cask**: [https://caskroom.github.io/](https://caskroom.github.io/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Chocolatey**: [https://chocolatey.org/](https://chocolatey.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**VirtualBox**: [https://www.virtualbox.org/](https://www.virtualbox.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we installed a single-node Kubernetes cluster on our local
    machine using Minikube; we looked at how to achieve this on macOS, Windows 10,
    and Ubuntu Linux. Once installed, we discovered that we can interact with our
    single-node Kubernetes cluster in exactly the same way, no matter which operating
    system our local machine is running.
  prefs: []
  type: TYPE_NORMAL
- en: We then took our first steps in launching pods, ReplicaSets, and services using
    both the Kubernetes dashboard and the Kubernetes command-line client called `kubectl`.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to be launching our first serverless tool,
    which is called Kubeless, on top of the single-node Kubernetes cluster we now
    have running locally.
  prefs: []
  type: TYPE_NORMAL
