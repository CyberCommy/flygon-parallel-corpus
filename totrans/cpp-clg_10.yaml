- en: Archives, Images, and Databases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 79\. Finding files in a ZIP archive
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Write a program that can search for and print all the files in a ZIP archive
    whose name matches a user-provided regular expression (for instance, use `^.*\.jpg$`
    to find all files with the extension `.jpg`).
  prefs: []
  type: TYPE_NORMAL
- en: 80\. Compressing and decompressing files to/from a ZIP archive
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Write a program that can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Compress either a file or the contents of a user-specified directory, recursively,
    to a ZIP archive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decompress the contents of a ZIP archive to a user-specified destination directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 81\. Compressing and decompressing files to/from a ZIP archive with a password
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Write a program that can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Compress either a file or the contents of a user-specified directory, recursively,
    to a password-protected ZIP archive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decompress the content of a password-protected ZIP archive to a user-specified
    destination directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 82\. Creating a PNG that represents a national flag
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Write a program that generates a PNG file that represents the national flag
    of Romania, shown here. The size of the image in pixels, as well as the path to
    the destination file, should be provided by the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ef91c3bc-5e8e-4106-ad7a-77429c9d7572.png)'
  prefs: []
  type: TYPE_IMG
- en: 83\. Creating verification text PNG images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Write a program that can create Captcha-like PNG images for verifying human
    users to a system. Such an image should have:'
  prefs: []
  type: TYPE_NORMAL
- en: A gradient-colored background
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A series of random letters displayed at different angles both to the right and
    left
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Several random lines of different colors across the image (on top of the text)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is an example of such an image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/28add9ea-14fe-40eb-9fb9-dee3ae6e6407.png)'
  prefs: []
  type: TYPE_IMG
- en: 84\. EAN-13 barcode generator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Write a program that can generate a PNG image with an EAN-13 barcode for any
    international article number in version 13 of the standard. For simplicity, the
    image should only contain the barcode and can skip the EAN-13 number printed under
    the barcode. Here is an example of the expected output for the number `5901234123457`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c20e3077-983f-4cfe-b624-c8a09acd28c8.png)'
  prefs: []
  type: TYPE_IMG
- en: 85\. Reading movies from an SQLite database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Write a program that reads movies from an SQLite database and displays them
    on the console. Each movie must have a numerical identifier, a title, release
    year, length in minutes, list of directors, list of writers, and a cast that includes
    both the actor and the character names. The following is a diagram of the database
    that should be used for this purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3033e8b2-df86-4975-9c79-73b0ddce1fbc.png)'
  prefs: []
  type: TYPE_IMG
- en: 86\. Inserting movies into an SQLite database transactionally
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Extended the program written for the previous problem so that it can add new
    movies to the database. The movies could be read from the console, or alternatively
    from a text file. The insertion of movie data into several tables in the database
    must be performed transactionally.
  prefs: []
  type: TYPE_NORMAL
- en: 87\. Handling movie images in an SQLite database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Modify the program written for the previous problem to support adding media
    files (such as images, but also videos) to a movie. These files must be stored
    in a separate table in the database and have a unique numerical identifier, the
    movie identifier, a name (typically the filename), an optional description, and
    the actual media content, stored as a blob. The following is a diagram with the
    structure of the table that must be added to the existing database:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/057eaf49-6131-4f69-bb61-cc9b04f3362f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The program written for this problem must support several commands:'
  prefs: []
  type: TYPE_NORMAL
- en: Listing all movies that match a search criterion (notably the title) ...
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Solutions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 79\. Finding files in a ZIP archive
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a variety of libraries that provide support for working with ZIP archives.
    Among the ones available for free, the most used ones include *ZipLib*, *Info-Zip*,
    *MiniZip*, and *LZMA SDK* from 7z. And then, there are also commercial implementations. For
    the problems regarding ZIP archives in this book, I have chosen `ZipLib`. This
    is a lightweight, open source cross-platform C++11 library built around standard
    library streams, with no additional dependencies. The library, along with its
    documentation, is available at [https://bitbucket.org/wbenny/ziplib](https://bitbucket.org/wbenny/ziplib).
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement the required functionality, you have to:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the ZIP archive using `ZipFile::Open()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enumerate all the entries in the archive using `ZipArchive::GetEntry() ...`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 80\. Compressing and decompressing files to/from a ZIP archive
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To solve this two-part problem, we will use the same `ZipLib` library we saw
    for the solution of the previous problem. The solution to this problem consists
    of two functions, one that is able to perform the compression to a ZIP archive
    and one that is able to perform decompression from a ZIP archive.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to perform the requested compression, we should do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: If the source path represents a regular file, then add that file to the ZIP
    archive using `ZipFile::AddFile()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If the source path represents a recursive directory, then:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Iterate recursively through all the entries in the directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If an entry is a directory, then create a directory entry in the ZIP archive
    with ...
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 81\. Compressing and decompressing files to/from a ZIP archive with password
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This problem is very similar to the previous one with the addition that the
    files must be encrypted. The `ZipLib` library supports PKWare encryption only.
    Should you need to use another method for encryption, then you have to use another
    library. The `compress()` and `decompress()` functions, shown in the following, are
    similar to the implementation from the previous problem, but have a few differences,
    apart from the extra parameter that represents the password for the encryption/decryption
    of files:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding encrypted files to the archive is done with `ZipFile::AddEncryptedFile()`
    instead of `ZipFile::AddFile()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When decompressing, the password must be set with `ZipArchiveEntry::SetPassword()
    ...`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 82\. Creating a PNG that represents a national flag
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most feature-rich library for working with PNG files is *libpng*, a platform-independent,
    open source library written in C. There are also C++ libraries, some of which
    are wrappers for *libpng*, such as *png++*, *lodepng*, or *PNGWriter*. For the
    problems in this book, we will use the last one, *PNGWriter*. It is an open source
    library that works on Linux, Unix, macOS, and Windows. Its supported features
    include opening existing PNG images; plotting and reading pixels in the RGB, HSV,
    and CMYK color spaces; basic shapes; scaling; bilinear interpolation; full TrueType
    antialiased and rotated text support; and Bezier curves. It is a wrapper for *libpng*
    and also requires the `FreeType2` library for text ...
  prefs: []
  type: TYPE_NORMAL
- en: 83\. Creating verification text PNG images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This problem can be solved in a similar manner to the previous one with the
    national flag. If you haven’t done that one first, I recommend that you do so
    before continuing with this one.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are basically three elements that the image must have:'
  prefs: []
  type: TYPE_NORMAL
- en: A gradient-color background. This can be achieved by drawing lines (vertically
    or horizontally) of a different color from one side to the other of the image.
    Drawing lines can be done with the `pngwriter::line()` function. There are several
    overloads available; the one used in the following code takes the start and end
    position and three values for the red, green, and blue channels of the RGB color
    space.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A random text with letters displayed at various random ...
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 84\. EAN-13 barcode generator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The *International Article Number* (aka *European Article Number* or *EAN*),
    as described on Wikipedia, is a standard describing a barcode symbology and numbering
    system that is used in global trade to identify a specific retail product type,
    in a specific packaging configuration, from a specific manufacturer. The most
    commonly used EAN standard is the 13-digit EAN-13\. A description of the standard,
    including information on how the barcode should be generated, can be found on
    Wikipedia at [https://en.wikipedia.org/wiki/International_Article_Number](https://en.wikipedia.org/wiki/International_Article_Number)
    and will not be detailed in this book. The following is the EAN-13 barcode for
    the number 5901234123457, given as an example in the problem’s description (source:
    Wikipedia): ...'
  prefs: []
  type: TYPE_NORMAL
- en: 85\. Reading movies from an SQLite database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SQLite is an in-process relational database management library written in C
    (although a large number of programming languages provide bindings to it). SQLite
    is not a client-server database engine, but one embedded into the application.
    The entire database, including tables, indexes, triggers, and views, is contained
    within a single disk file. Because accessing the database means accessing a local
    disk file, without any inter-process communication, SQLite has a better performance
    compared to other relational database engines. SQLite, as the name implies, uses
    SQL, although it does not implement all the features (such as `RIGHT OUTER JOIN`).
    SQLite is used in not just web browsers (several major ones ...
  prefs: []
  type: TYPE_NORMAL
- en: 86\. Inserting movies into an SQLite database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The solution to this problem builds upon the previous one. You must solve that
    one before continuing here. Also, the function `split()` that is used in the code
    here is the same from problem 27, *Splitting a string into tokens with a list
    of possible delimiters*, from [Chapter 3](e9df2028-62cc-41c0-9834-d2cff13346dd.xhtml),
    *Strings and Regular Expressions*. For this reason, it will not be listed here
    again. In the source code for this book, you will find a database file called
    `cppchallenger86.db` that is prepared with several records for this problem.
  prefs: []
  type: TYPE_NORMAL
- en: The following function, `read_movie()`, reads information about a movie from
    the console (title, release year, length in minutes, directors, writers, and cast),
    creates a `movie` object, and returns it. ...
  prefs: []
  type: TYPE_NORMAL
- en: 87\. Handling movie images in an SQLite database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have not done so already, you must complete the previous two problems
    before continuing with this one. For this problem, we must extend the database
    model with an additional table to store images and possibly other media files,
    such as videos. The actual content of the media files must be stored in a blob
    field, but other attributes, such as description and filename, should also be
    stored.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you are using large objects you have two options: either store them directly
    in the database as blobs or keep them in separate files and store only the file
    paths in the database. According to the tests performed by the developers of SQLite,
    for objects smaller than 100KB, reads are faster when ...'
  prefs: []
  type: TYPE_NORMAL
