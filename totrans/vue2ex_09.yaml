- en: Using Vue-Router Dynamic Routes to Load Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 8](part0135.html#40NRU0-985bf4ae118d4f62b18ae64204cb251c), *Introducing
    Vue-Router and Loading URL-Based Components*, we explored Vue-router and its capabilities
    and functionality. With that knowledge, we can now progress on to making our shop
    with Vue. Before we jump into the code and start creating, we should first plan
    how our shop is going to work, what URLs we need, and what components we need
    to make. Once we've planned our app we can move on to creating a product page.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to:'
  prefs: []
  type: TYPE_NORMAL
- en: Outline our components and routes, and create placeholder files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Load a product CSV file, process it, and cache in Vuex
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create an individual product page with images and product variations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Outline and plan your app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, let's think about the overall app and the user flow.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to be creating a shop without a payment processing gateway. The
    shop homepage will display a hand-picked list of products. The user will be able
    to browse the products using categories and narrow down the selection using filters
    we've made. They will be able to select a product and view more details about
    it. The product will have variations (size, color, and such) and may have several
    product images. The user will be able to add a variation to their basket. From
    there, they can either continue browsing the products and add more to their basket,
    or proceed to checkout, where they will be asked for their name and address, and
    to pay. An order confirmation screen will be shown.
  prefs: []
  type: TYPE_NORMAL
- en: The whole shop app will be created in Vue and will run client-side. This will
    not cover any server-side code needed for payment, user accounts, stock management,
    or validation.
  prefs: []
  type: TYPE_NORMAL
- en: The app will use Vue-router for handling URLs and Vuex for storing products,
    basket contents, and user details.
  prefs: []
  type: TYPE_NORMAL
- en: Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With a user flow outlined, we need to plan which components we need to make
    for our shop and what they will be called. This helps with developing the app,
    as we have a clear idea of what components we need to create.  We will also decide
    on the component names. Following the Vue style guide ([https://vuejs.org/v2/style-guide/index.html](https://vuejs.org/v2/style-guide/index.html)),
    all our components will consist of two names.
  prefs: []
  type: TYPE_NORMAL
- en: Route components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following components will be used in conjunction with Vue-router to form
    the pages for our app:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Shop homepage**—`HomePage`: The shop homepage will display a list of products
    that are curated by the shop owner. This will use a pre-selected list of product
    handles to display.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Category page**—`CategoryPage`: This will list the products from a specific
    category. The category listing page will also have filters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Product page**—`ProductPage`: The product page will display product details,
    images, and variations of the product.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Basket**—`OrderBasket`: In the basket, the user will be able to review the
    products they''ve added, remove unwanted items, and alter the quantity of each
    item. It will also show the overall cost of the order.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Checkout**—`OrderCheckout`: The checkout will lock down the basket – taking
    away the ability to remove and update products, and will have a form for the user
    to enter their address.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Order confirmation**—`OrderConfirmation`: This component will be displayed
    after the order has been placed, confirming the products purchased, the delivery
    address, and the total price.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`404` **page**—`PageNotFound`: An error page when an incorrect URL is entered.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTML components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The HTML components will be used within the page components to help reduce
    repetition in our code for recurring layouts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Product in a list**—`ListProducts`: This will display a paginated list of
    products when viewing in a list view – such as in the `HomePage` or `CategoryPage`
    components.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Category listing**—`ListCategories`: This will create a list of categories
    for navigation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**List of Purchases**—`ListPurchases`: This component will appear in the basket,
    checkout, and order confirmation page; it will list the products in a table form
    – detailing the variation, price, and quantity. It will also feature the total
    price of all the products in the basket.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Filtering**—`ProductFiltering`: A component used on the side of a category
    page will offer the user the ability to filter and will update the URL, using
    the GET parameters we covered in [Chapter 8](https://cdp.packtpub.com/vue_js_by_example/wp-admin/post.php?post=103&action=edit#post_93), *Introducing
    Vue-Router and Loading URL-Based Components.*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Paths
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With our components outlined, we can plan the paths and URLs to our shop, and
    which components or actions they are going to take. We also need to consider erroneous
    URLs and whether we should redirect the user to a suitable place or display an
    error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/`: `Home`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/category/:slug`: `CategoryPage`, using the `:slug` unique identifier to identify
    which products to show'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/category`: This will redirect to `/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/product/:slug`: `ProductPage` – once again, using the `:slug` to identify
    the product'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/product`: This will redirect to `/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/basket`: `OrderBasket`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/checkout`: `OrderCheckout` – if there are no products, however, it will redirect
    the user to `/basket`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/complete`: `OrderConfirmation` – if the user did not come from the `OrderCheckout`
    component, then they will be redirected to ``/basket``'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*`: `PageNotFound` – this will catch any unspecified routes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With our routes and components decided upon, we can begin to create our app.
  prefs: []
  type: TYPE_NORMAL
- en: Create initial files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the app outlined in the preceding section, we can create the skeletons
    for our file structure and components. With this app being a large-scale app,
    we are going to split our files into individual files for each component. This
    means our files are much more manageable and our main app JavaScript file does
    not grow out of control.
  prefs: []
  type: TYPE_NORMAL
- en: Although acceptable for development, deploying an app with this number of files
    could potentially increase your load times depending on how your server is set
    up. With the traditional HTTP/1.1, browsers have to request and load each file
    – which is a hindrance if there are multiple files. However, with HTTP/2, you
    are able to push several files to the user at the same time – in which case, multiple
    files can somewhat improve the performance of your app.
  prefs: []
  type: TYPE_NORMAL
- en: 'Whichever method you choose to use with your deployment, it is highly advised
    you minify your JavaScript when deploying the code to a production environment.
    This ensures your code is as small as possible when being served up to your user:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00018.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Create a file for each component, view, and library, such as Vue, Vuex, and
    Vue-router. Then, create a folder for each type of file. Finally, add an `app.js`—which
    is where the libraries will be initialized.
  prefs: []
  type: TYPE_NORMAL
- en: You may also consider using the vue-cli [(https://github.com/vuejs/vue-cli)](https://github.com/vuejs/vue-cli)
    for building your app. Beyond the scope of this book, as we only cover building
    a Vue app using the included JavaScript files, the vue-cli application allows
    you to develop your app in a more modular way and, once developed, deploy it in
    a similar fashion to how we have been developing the app.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an `index.html` and include your JavaScript files, ensuring Vue is loaded
    first and your app''s JavaScript last. Add a container for your app to form the
    view of our shop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Ensure the `PageNotFound` component is loaded first, as we are going to be utilizing
    it within other components, as well as specifying it as the 404 page in our routes.
  prefs: []
  type: TYPE_NORMAL
- en: Within each file, initialize the type of component it's going to be by either
    declaring a variable or using `Vue.component`. For the views, add a `name` attribute
    too – to help with debugging later on.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, all of the files located in the `js/components/` folder should
    be initialized like the following. Make sure these components are lowercase and
    are hyphenated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Whereas the components for the routes and views, located in `js/views`, should
    look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The last step is to initialize our Vuex store, Vue-router, and Vue application.
    Open `app.js` and initialize the libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: With the Vue components and routes ready to go, our store, route, and app initialized,
    let's look at setting up a server (if required) and loading in data.
  prefs: []
  type: TYPE_NORMAL
- en: Server setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With our shop, we are going to be loading in a CSV of products on page load.
    This will simulate gathering stock and product data from a database or API from
    a point-of-sale system, something online shops with a physical shop might have
    to deal with.
  prefs: []
  type: TYPE_NORMAL
- en: In a similar way to our Dropbox app earlier in the book, we will be loading
    external data and saving it into the Vuex store. The issue we will face, however,
    is when loading a resource via JavaScript; the browsers demand the protocol for
    the file being requested is via HTTP, HTTPS, or is a CORS request.
  prefs: []
  type: TYPE_NORMAL
- en: This means that we are unable to load a *local* file using the `fetch()` technique
    we used with the Dropbox API as, when viewing our app in the browser, we are loading
    local assets over the `file://` protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can resolve this issue in a few different ways – which one you choose depends
    on your circumstance. We are going to be loading a CSV file and, using two plugins,
    converting it into a useable JSON object. The three options you have are:'
  prefs: []
  type: TYPE_NORMAL
- en: Storing the file locally
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using a remote server or
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using a local server
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's run through each option, with the advantages and disadvantages for each.
  prefs: []
  type: TYPE_NORMAL
- en: Storing the file locally
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first option is to convert the CSV to JSON appropriately once, and then
    save the output in a file. You''ll need to assign it to a variable in the file
    and load the JSON before your libraries. An example might be creating a `data.json`
    and updating it to be assigned to a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then load the JSON file in your HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: You then have the `products` variable available to you in your `app.js`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: Less load in your code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No need to load the extra files required for processing the CSV
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No extra steps required
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Disadvantages:'
  prefs: []
  type: TYPE_NORMAL
- en: Does not simulate the real world
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want to update the CSV data, you need to convert, save, and assign to
    a variable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a remote server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another option is to upload the files to a remote, existing server and develop
    your app there.
  prefs: []
  type: TYPE_NORMAL
- en: 'Advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: Simulates real-world development of loading CSV
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can be developed anywhere, with any machine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Disadvantages:'
  prefs: []
  type: TYPE_NORMAL
- en: Can be slow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Needs to be connected to the internet
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Needs to either set up a deployment process or edit files on a live server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up local server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last option is to set up a local server on your machine. There are several
    small, lightweight, zero configuration modules, and applications, or there are
    bigger, beefier applications too. If you have npm installed on your machine, the
    node HTTP server is recommended. If not, there are other options available.
  prefs: []
  type: TYPE_NORMAL
- en: The other option would be to use a more heavyweight application, which can provide
    you with an SQL database and the ability to run PHP applications. An example of
    this would be MAMP or XAMPP.
  prefs: []
  type: TYPE_NORMAL
- en: 'Advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: Simulates real-world development of loading CSV
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Quick, instant updates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can be developed offline
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Disadvantages:'
  prefs: []
  type: TYPE_NORMAL
- en: Requires installing software
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: May require some configuration and/or command-line knowledge
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The option we are going to choose is the last one, using an HTTP server. Let's
    load and process the CSV so we can start creating our shop.
  prefs: []
  type: TYPE_NORMAL
- en: Loading CSV
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To simulate gathering data from a shop database or point-of-sale, our app is
    going to load product data from a CSV. CSV, or Comma Separated Values, is a file
    format often used for sharing data in a database-style way. Think of how you would
    lay out a list of products in excel or numbers: that is how a CSV file is formatted.'
  prefs: []
  type: TYPE_NORMAL
- en: This next step is going to require downloading and including a couple more JavaScript
    files. If you chose option 1 in the *Server setup* section – to have your files
    stored in a JSON file locally – you can skip this step.
  prefs: []
  type: TYPE_NORMAL
- en: The data we're going to be using is example shop data from Shopify. These CSVs
    have a wide selection of product types and different data, which will test our
    Vue skills. Shopify has made their example data available for download from a
    GitHub repository ([https://github.com/shopifypartners/shopify-product-csvs-and-images](https://github.com/shopifypartners/shopify-product-csvs-and-images)).
    Download any CSV file that takes your interest and save it in a `data/` folder
    in your file system. For this app, I will be using the `bicycles.csv` file.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript cannot natively load and process CSV files without a significant
    amount of coding and processing of comma-separated and quote-encapsulated values.
    To save this book digressing into how to load, parse, and process CSV files, we
    are going to use a library to do the heavy lifting for us. There are two noteworthy
    libraries, CSV Parser ([https://github.com/okfn/csv.js](https://github.com/okfn/csv.js))
    and d3 ([https://d3js.org/](https://d3js.org/)). CSV Parser simply does CSV parsing
    and nothing else, while d3 has the ability to generate charts and data visualizations.
  prefs: []
  type: TYPE_NORMAL
- en: It is worth considering which one suits you best; CSV Parser only adds just
    over 3 KB of weight to your app, whereas d3 is around 60 KB. Unless you anticipate
    adding visualizations later, it is recommended you go to the smaller library –
    especially as they execute the same function. However, we'll run through examples
    for both libraries.
  prefs: []
  type: TYPE_NORMAL
- en: We want to load our product data when the app loads, so our CSV will be loaded
    and parsed by the time our components require the data. Because of this, we will
    be loading our data in the `created()` method of Vue.
  prefs: []
  type: TYPE_NORMAL
- en: Loading a CSV with d3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Both plugins load the data in a very similar way, but the data returned varies
    somewhat – however, we'll deal with that once we have loaded our data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Load the d3 library – if you want to try it out, you can use the hosted version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Using d3, we use a function on the `d3` object of `csv()`, which accepts one
    parameter – the path to the CSV file. Add the `created()` function to your Vue
    instance and initialize the CSV loader:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Remember the path to your file is relative to the HTML file which is including
    your JavaScript file – in this case, `index.html`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Opening the file in your browser will not render any output. However, if you
    open the Javascript console and expand the object being output, you will see something
    similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00019.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'This gives you a breakdown of all of the properties available on each product
    in a `key: value` format. This allows us to access each `value` in red, using
    a consistent `key` found on each product. For example, if we wanted `15mm-combo-wrench`
    from the product above, we could use the `Handle` key. More on this will be covered
    later'
  prefs: []
  type: TYPE_NORMAL
- en: Loading a CSV with CSV Parser
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'CSV Parser works in a slightly different way, in that it can accept many different
    parameters and the library contains several different methods and functions. The
    data output is also in a different format, providing a table/CSV style structure
    in return, with a `headers` and `fields` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Viewing the output this time will reveal a much different structure and will
    require matching up the `key` of the fields, with the index of the `headers` object.
  prefs: []
  type: TYPE_NORMAL
- en: Unifying Shopify CSV data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we can save and utilize the Shopify data, we need to unify the data and
    manipulate it into a more manageable state. If you inspect the data being output
    by either library, you will notice there is an entry for each variation or additional
    image of a product, with the handle being the linking factor between each entry.
    For example, there are around 12 entries with the handle of `pure-fix-bar-tape`,
    each one a different color. Ideally, we would like each variation grouped under
    the same item, also showing the images as a list of one product.
  prefs: []
  type: TYPE_NORMAL
- en: The other issue with the Shopify CSV data is that the punctuation and grammar
    of the field headings do not make great object keys. Ideally object keys would
    be like URL slugs, lowercase and contain no spaces. For example, `Variant Inventory
    Qty` should ideally be `variant-inventory-qty`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To save manually processing the data ourselves and updating the keys, we can
    use a Vue plugin to process the output from either loading library and return
    an object of products formatted exactly how we want. The plugin is `vue-shopify-products`
    and is available from unpkg:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Download and include the library into your `index.html` file. The next step
    is to tell Vue to use this plugin – at the top of your `app.js` file, include
    the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This now exposes a new method on the Vue instance of `$formatProducts()`, which
    allows us to pass in the output of our CSV loading library and get a more useful
    collection of objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Inspecting the output now reveals a collection grouped by `handle`, with variations
    and images as objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00020.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: With our products grouped more effectively, we can proceed with storing and
    recalling as desired.
  prefs: []
  type: TYPE_NORMAL
- en: Storing the products
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once we have retrieved and formatted the CSV data, we can cache the contents
    in the Vuex store. This will be done via a simple mutation that takes a payload
    and stores it without any modifications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `state` and `mutations` object in your store. Add a key of `products` as
    an object in the `state`, and create a function in the `mutations` object, also
    titled `products`. The mutation should accept two parameters – the state and a
    payload:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the `state.products` object to the contents of the `payload`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace the `console.log` in the main Vue instance with a commit function,
    calling the new mutation and passing in the formatted product data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This can be reduced somewhat, by passing the `$formatProducts` function directly
    into the store `commit()` function, rather than storing it as a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Displaying a single product
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With our data stored, we can now begin making our components and displaying
    content on the frontend. We're going to start by making a product view – displaying
    product details, variations, and images. We'll move on to creating the category listing
    page in [Chapter 10](part0185.html#5GDO20-985bf4ae118d4f62b18ae64204cb251c), *Building
    an E-Commerce Store – Browsing Products*.
  prefs: []
  type: TYPE_NORMAL
- en: The first step in making our product view is to create the route, to allow the
    component to be displayed via a URL. Referring back to our notes at the beginning
    of the chapter, the product component is to be loaded on the `/product/:slug`
    path.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `routes` array in your Vue-router, with the path and component specified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: With the layout of the `products` object explained, we can start to understand
    how the route and products link. We will pass the handle of the product into the
    URL. This will select the product with that handle and display the data. This
    means we do not need to explicitly link `slug` with `products`.
  prefs: []
  type: TYPE_NORMAL
- en: Page Not Found
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With our first route created, we should also create our `PageNotFound` route,
    to catch any URLs that are non-existent. We can also redirect to this page when
    there is no product that matches.
  prefs: []
  type: TYPE_NORMAL
- en: We're going to create the `PageNotFound` component in a slightly different way
    than we did before. Rather than having the component on `*`, we're going to create
    a `/404` path as a named route. This allows us to alias and redirect several different
    routes as required.
  prefs: []
  type: TYPE_NORMAL
- en: Add a new object to the routes array, with  `/404` as the path, the `PageNotFound`
    component as the specified component. Add a name to your route, so we can utilize
    if required, and lastly, add an `alias` attribute, which contains our global,
    catchall route.
  prefs: []
  type: TYPE_NORMAL
- en: 'Don''t forget to put this *at the end* of the routes array – to catch any previously
    unspecified route. When adding new routes, always remember to put them before
    the `PageNotFound` route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a template to your `PageNotFound` component. For now, give it some basic
    content – we can improve it later, once we have the rest of our app set out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Note the use of the router link in the content. The last thing we need to do
    to get our app started is to add the `<router-view>` element inside our app. Head
    to the view, and include it in the app space:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Load up the app in your browser, not forgetting to start the HTTP server if
    required. You should be, at first, presented with your `PageNotFound` component
    contents. Navigating to the following product URL should result in a JavaScript
    error instead of the `404` page. This shows the route is correctly picking up
    the URL but the error is because our `ProductPage` component does not contain
    a template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: If you are presented with the `PageNotFound` component, check your route's code,
    as it means the `ProductPage` route is not being picked up.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting the right product
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With our initial routes set up, we can now proceed with loading the desired
    product and displaying the information from the store. Open `views/Product.js`
    and create a template key. To begin with, create a simple `<div>` container that
    displays the title of the product:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Viewing this in the browser will instantly throw a JavaScript error as Vue is
    expecting the `product` variable to be an object – but it is currently undefined
    as we have yet to declare it. Although the fix for this seems fairly simple at
    the moment, we need to consider the case where the product is not yet defined.
  prefs: []
  type: TYPE_NORMAL
- en: Our shop app loads the data CSV asynchronously. This means that the execution
    of the rest of the app does not stop while the products are being loaded. Overall,
    this increases the speed of our app at the moment we have the products, we can
    start manipulating and displaying the list, without waiting for the rest of the
    app to start.
  prefs: []
  type: TYPE_NORMAL
- en: Because of this, there is a distinct possibility that the user could visit the
    product details page, be it from a link that was shared or a search result, without
    the product list being loaded. To prevent the app trying to display the product
    data without being fully initialized, add a conditional attribute to the template
    to check if the product variable exists before trying to display any of its attributes.
  prefs: []
  type: TYPE_NORMAL
- en: 'When loading our product data, we can then ensure the product variable is set
    to `false`, until everything is fully loaded. Add the `v-if` attribute to the
    containing element in your template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We can now start loading the correct product from the store and assign it to
    a variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `computed` object with a `product()` function inside. Within that,
    create a blank variable of the product, and return it afterward. This now defaults
    to returning `false`, which means our template will not generate the `<div>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Selecting the product is now a fairly simple procedure, thanks to our helpfully-formatted
    product store and the `slug` variable, available to us within the `Product` component.
    The `products` object in the store is formatted with the handle as the key and
    the `product details` object as the value. With this in mind, we can select the
    desired product using the square bracket format. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the router `params` object, load the desired product from the store and
    assign it to the `product` variable to be returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The reason we don't assign the value of `product` straightaway is so we can
    add some conditional statements. To ensure we are only loading the product if
    the store has the data available, we can add an `if()` statement to make sure
    the product's object has keys available; in other words, has the data loaded?
  prefs: []
  type: TYPE_NORMAL
- en: 'Add an `if` statement checking the length of the store product keys. If they
    exist, assign the data from the store to the `product` variable to be returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Viewing the app in the browser now, you will be presented with the title of
    the product – once the data has loaded. This should only take a split second to
    load and should be gracefully handled by our `if` statement.
  prefs: []
  type: TYPE_NORMAL
- en: Before proceeding with displaying all our product data, we need to handle the
    situation where a product does not exist with the handle in the URL. Because our
    `ProductPage` route is picking up anything after `/product` in the URL, the `PageNotFound`
    wildcard path will not be able to be used – as it is our `ProductPage` component
    that is loading the data and determining whether the product exists.
  prefs: []
  type: TYPE_NORMAL
- en: Catching products not found
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to show the `PageNotFound` page when a product is not available, we
    are going to load the component with our `ProductPage` component and display it
    conditionally.
  prefs: []
  type: TYPE_NORMAL
- en: To do this, we need to register the component so we can use it in our template.
    We need to register it since our `PageNotFound` component currently lives as an
    object and not a Vue component (for example, when we use `Vue.component`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a `components` object to your `ProductPage` component and include `PageNotFound`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This now gives us a new HTML element to use in the form of `<page-not-found>`.
    Add this element to your template after the existing `<div>`. As our templates
    need a single root element, wrap both of them in an extra container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Viewing this in the browser will render the `404`page template and, once the
    data has loaded, the product title above that. We now need to update the component
    to only show the `PageNotFound` component when there is no data to show. We could
    use the existing product variable with a `v-if` attribute and, if false, show
    the error message like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: However, this would mean that if the user visited the product page without the
    product data loading yet, they would see a flash of the 404 information before
    being replaced with the product information. This isn't a very good user experience,
    so we should only show the error if we are sure the product data has loaded and
    that there isn't a matching item.
  prefs: []
  type: TYPE_NORMAL
- en: 'To combat this, we will create a new variable which will determine if the component
    displays. Create a data function in the `ProductPage` component that returns an
    object with a key of `productNotFound`, set to false. Add a `v-if` condition to
    the `<page-not-found>` element, checking against the new `productNotFound` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The last step is to set the variable to `true` if a product doesn''t exist.
    As we only want to do this once the data has loaded, add the code to the `$store.state.products`
    check. We are already assigning the data to the `product` variable, so we can
    add a check to see if this variable exists – if not, change the polarity of our
    `productNotFound` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Try entering an erroneous string at the end of the URL – you should be faced
    with our, now familiar, `404`error page.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying product information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With our product loading, filtering, and error-catching in place, we can proceed
    with displaying the information we need for our product. Each product could contain
    one or many images, and one or many variations and any combination in-between
    – so we need to make sure we cater for each of these scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see the data available to us, add a `console.log(product)` just before the
    `return`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Open up the JavaScript console and inspect the object that should now be there.
    Familiarize yourself with the keys and values available to you. Take note that
    the `images` key is an array and the `variations` an object, containing a string
    and a further array.
  prefs: []
  type: TYPE_NORMAL
- en: Before we tackle the variations and images – let's output the simple stuff.
    What we need to remember is that every field we output might not exist on every
    product – so it's best to wrap it in conditional tags where necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Output the `body`, `type`, and `vendor.title` from the product details. Prepend
    both the `vendor.title` and `type` with a description of what they are, but make
    sure you only render that text if it exists in the product details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Notice we've got the flexibility to prepend the type and vendor with more user-friendly
    names. Once we have our categories and filtering set up, we can link both the
    vendor and type to appropriate product listing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Viewing this in the browser will reveal the body outputting all HTML tags as
    text – meaning we can see them on the page. If you cast your mind back to the
    beginning of the book where we were discussing output types, we need to use `v-html`
    to tell Vue to render the block as raw HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Product images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next step is to output the images for our product. If you are using the bicycles
    CSV file, a good product to test with is `650c-micro-wheelset` – navigate to this
    product as it has four images. Don't forget to go back to your original product
    to check that it works with one image.
  prefs: []
  type: TYPE_NORMAL
- en: The images value will always be an array, whether there is one image or 100,
    so to display them, we will always need to do a `v-for`. Add a new container and
    loop through the images. Add a width to each image so it doesn't take over your
    page.
  prefs: []
  type: TYPE_NORMAL
- en: 'The images array contains an object for each image. This has an `alt` and `source`
    key that can be input directly into your HTML. There are some instances, however,
    where the `alt` value is missing – if it is, insert the product title instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: With our images displaying, it would be a nice addition to create a gallery.
    Shops often show one big image, with a set of thumbnails underneath. Clicking
    each thumbnail then replaces the main image so the user can get a better look
    at the bigger image. Let's recreate that functionality. We also need to ensure
    we don't show the thumbnails if there is only one image.
  prefs: []
  type: TYPE_NORMAL
- en: We do this, by setting an image variable to the first image in the images array,
    this is the one that will form the big image. If there is more than one image
    in the array, we will show the thumbnails. We will then create a click method
    that updates the image variable with the selected image.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new variable in your data object and update it with the first item
    from the images array when the product has loaded. It''s good practice to ensure
    the `images` key is, in fact, an array of items before trying to assign a value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, update your existing images loop in your template to only display when
    there is more than one image in the array. Also, add the first image as the main
    image in your template – not forgetting to check whether it exists first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The last step is to add a click handler to each of the thumbnail images, to
    update the image variable when interacted with. As the images will not natively
    have the `cursor: pointer` CSS attribute, it might be worth considering adding
    this.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The click handler will be a method that accepts each image in the thumbnail
    loop as a parameter. On click, it will simply update the image variable with the
    object passed through:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Load the product up in your browser and try clicking on any of the thumbnails
    - you should be able to update the main image. Don't forget to validate your code
    on a product with one image or even zero images, to make sure the user isn't going
    to encounter any errors.
  prefs: []
  type: TYPE_NORMAL
- en: Don't be afraid of whitespace and adding new lines for readability. Being able
    to easily understand your code is better than the few bytes you would have saved
    on file load. When deploying to production, files should be minified, but during
    development white space takes precedence.
  prefs: []
  type: TYPE_NORMAL
- en: Product variations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With this particular dataset, each of our products contains at least one variation
    but can contain several. This normally goes hand-in-hand with the number of images
    but does not always correlate. Variations can be things such as color or size.
  prefs: []
  type: TYPE_NORMAL
- en: On our `Product` object, we have two keys which are going to help us display
    the variations. These are `variationTypes`, which list the names of the variations
    such as size and color, and `variationProducts`,which contains all of the variations.
    Each product within the `variationProducts` object has a further object of `variant`,
    which lists all of the changeable properties. For example, if a jacket came in
    two colors and each color had three sizes, there would be six `variationProducts`,
    each with two `variant` properties.
  prefs: []
  type: TYPE_NORMAL
- en: Every product will contain at least one variation, although if there is only
    one variation, we may need to consider the UX of the product page.  We are going
    to display our product variations in both a table and drop-down, so you can experience
    creating both elements.
  prefs: []
  type: TYPE_NORMAL
- en: Variations display table
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create a new container in your product template that will display the variations.
    Within this container, we can create a table to display the different variations
    of the product. This will be achieved with a `v-for` declaration. However, now
    that you are more familiar with the functionality, we can introduce a new attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Using a key with loops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When using loops in Vue, it is advised you use an extra attribute to identify
    each item, `:key`. This helps Vue identify the elements of the array when re-ordering,
    sorting, or filtering. An example of `:key` use would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The key attribute should be a unique attribute of the item itself and not the
    index of the item in the array, to help Vue identify the specific object. More
    information about using a key with a loop is available in the [official Vue documentation](https://vuejs.org/v2/guide/list.html#key).
  prefs: []
  type: TYPE_NORMAL
- en: We'll be utilizing the `key` attribute when displaying our variations, but using
    the `barcode` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying the variations in a table
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Add a table element to your variations container and loop through the `items`
    array. For now, display the `title`, `quantity` and `price`. Add an additional
    cell that contains a button with the value of Add to basket. We'll configure that
    in [Chapter 11](part0216.html#6DVPG0-985bf4ae118d4f62b18ae64204cb251c), *Building
    an E-commerce Store – Adding a Checkout.* Don't forget to add a `$` currency symbol
    in front of your price, as it's currently just a "raw" number.
  prefs: []
  type: TYPE_NORMAL
- en: 'Watch out – when using the `$` sign within the template literals, JavaScript
    will try and interpret it, along with the curly brackets, as a JavaScript variable.
    To counteract this, prepend the currency with a backslash – this tells JavaScript
    that the next character is literal, and should not be interpreted in any other
    way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Although we're displaying the price and quantity, we aren't outputting the actual
    variant properties of the variation (such as color). To do this, we are going
    to need to do some processing on our variation with a method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The variant object contains a child object for each variation type, with a
    name and a value for each type. They are also stored with a slug-converted key
    within the object. See the following screenshot for more details:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00021.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Add a new cell at the beginning of the table that passes the variation to a
    method titled `variantTitle()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the new method within your `methods` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: We now need to construct a string with the title of the variant, displaying
    all available options. To do this, we are going to construct an array of each
    of the types and then join them into a string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Store the `variants` as a variable and create an empty array. We can now loop
    through the keys available within the `variants` object and create a string to
    output. If you decide to add HTML into the string, as shown in the following example,
    we will need to update our template to output HTML instead of a raw string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Our output array will have an item for each variant, formatted like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now join each one together, which transforms the output from an array
    to a string. The character, string, or HTML you choose to join it with is up to
    you. For now, use a `/` with spaces on either side. Alternatively, you could use
    `</td><td>` tags to create a new table cell. Add the `join()` function and update
    the template to use `v-html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Attach a click event to the Add to basket button and create a new method on
    the component. This method will require the `variation` object to be passed in,
    so the correct one could be added to the basket. For now, add a JavaScript `alert()` to
    confirm you have the right one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Note the template literals used within the alert box – this allows us to use
    Javascript variables without having to use string concatenation techniques. Clicking
    on the Add to basket button will now generate a popup listing of the name of the
    product and the variation clicked.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying variations in a select box
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A more common interface pattern on product pages is to have a drop-down list,
    or select box, with your variations displayed and available for selecting.
  prefs: []
  type: TYPE_NORMAL
- en: When using a select box, we will have a variation which has either been selected
    by default or that the user has interacted with and chosen specifically. Because
    of this, we can change the image when the user changes the select box and display
    other pieces of information about the variant on the product page, including price
    and quantity.
  prefs: []
  type: TYPE_NORMAL
- en: We won't be relying on passing through the variant to the `addToBasket` method,
    as it will exist as an object on the product component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update your `<table>` element to be a `<select>`,  and the `<tr>` to an `<option>`.
    Move the button *outside* of this element and remove the parameter from the `click`
    event. Remove any HTML from the `variantTitle()` method. Because it is now inside
    a select box it is not required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The next step is to create a new variable available to use on the component.
    In a similar vein to the images, this will be completed with the first item of
    the `variationProducts` array and updated when the select box changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new item in the data object, titled `variation`. Populate this variable
    when the data is loaded into the `product` computed variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the `addToBasket` method to use the `variation` variable of the `ProductPage`
    component and not rely on a parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Try clicking the Add to basket button – it should add the first variation, regardless
    of what is selected in the dropdown. To update the variable on change, we can
    bind the `variations` variable to the select box – in the same way, that we did
    our textbox filtering at the beginning of this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a `v-model` attribute to the `select` element. We will also need to tell
    Vue what to bind to this variable when selecting. By default, it will do the contents
    of the `<option>`, which is currently our custom variant title. However, we want
    to bind the whole `variation` object. Add a `:value` property to the `<option>`
    element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Changing the select box and clicking the Add to basket button will now produce
    the correct variation. This method gives us much more flexibility over displaying
    the variations in a table.
  prefs: []
  type: TYPE_NORMAL
- en: 'It allows us to display variation data in other places on the product. Try
    adding the price next to the product title and the quantity within the `meta`
    container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'These two new attributes will update when changing the variation. We can also
    update the image to the selected variation if it has one. To do this, add a `watch`
    object to your component, which watches the variation variable. When updated,
    we can check if the variation has an image and, if so, update the image variable
    with this property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: When using `watch`, the function passes the new item as the first parameter.
    Rather than referring to the one on the component, we can use this to gather the
    image information.
  prefs: []
  type: TYPE_NORMAL
- en: Another enhancement we can make is to disable the Add to basket button and add
    a note in the dropdown if the variation is out of stock. This information is gathered
    from the variation `quantity` key.
  prefs: []
  type: TYPE_NORMAL
- en: 'Check the quantity and, if less than one, display an out of stock message in
    the select box and disable the Add to basket button using the `disabled` HTML
    attribute. We can also update the value of the button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: If using the `bicycles.csv` dataset, the Keirin Pro Track Frameset product (`/#/product/keirin-pro-track-frame`)
    contains several variations, some without stock. This allows you to test the `out
    of stock` functionality along with the image changing.
  prefs: []
  type: TYPE_NORMAL
- en: Another thing we can do to the product page is only show the dropdown when there
    is more than one variation. An example of a product with only one is the 15 mm
    Combo Wrench (`#/product/15mm-combo-wrench`). In this instance, it is not worth
    showing the `<select>` box. As we are setting the `variation` variable on the
    `Product` component on load, we are not relying on the selection to initially
    set the variable. Because of this, we can completely remove the select box with
    a `v-if=""` when there is only one alternate product.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like we did with the images, check if the length of the array is more than
    one, this time the `variationProducts` array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: By removing elements when they are not needed, we now have a less cluttered
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the product details when switching URLs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While navigating through the different product URLs to check variations, you
    may have noticed that clicking back and forward doesn't update the product data
    on the page.
  prefs: []
  type: TYPE_NORMAL
- en: This is because `Vue-router` realizes the same component is being used between
    the pages, and so, rather than destroying and creating a new instance, it reuses
    the component. The downside to this is that the data does not get updated; we
    need to trigger a function to include the new product data. The upside is that
    the code is more efficient.
  prefs: []
  type: TYPE_NORMAL
- en: To tell Vue to retrieve the new data, we need to create a `watch` function;
    instead of watching a variable, we are going to watch the `$route` variable. When
    this gets updated, we can load new data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new variable in the data instance of `slug`, and set the default to
    be the route parameter. Update the `product` computed function to use this variable
    instead of the route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: We can now create a `watch` function, keeping an eye on the `$route` variable.
    When this changes, we can update the `slug` variable, which in turn will update
    the data being displayed.
  prefs: []
  type: TYPE_NORMAL
- en: When watching a route, the function has two parameters passed to it: `to` and
    `from`. The `to` variable contains everything about the route we are going to,
    including parameters and the component used. The `from` variable contains everything
    about the current route.
  prefs: []
  type: TYPE_NORMAL
- en: 'By updating the `slug` variable to the new parameter when the route changes,
    we are forcing the component to redraw with new data from the store:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: With our product page completed, we can move on to creating a category listing
    for both the `type` and `vendor` variables. Remove any `console.log()` calls you
    have in your code, too, to keep it clean.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter has covered a lot. We loaded and stored a CSV file of products
    into our Vuex store. From there, we created a product detail page that used a
    dynamic variable in the URL to load a specific product. We have created a product
    detail view that allows the user to look through a gallery of images and choose
    a variation from a drop-down list. If the variation has an associated image, the
    main image updates.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 10](part0185.html#5GDO20-985bf4ae118d4f62b18ae64204cb251c), *Building
    an E-Commerce Store – Browsing Products*,
  prefs: []
  type: TYPE_NORMAL
- en: we will create a category page, creating filtering and ordering functions –
    helping the user to find the product they want.
  prefs: []
  type: TYPE_NORMAL
