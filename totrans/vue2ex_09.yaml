- en: Using Vue-Router Dynamic Routes to Load Data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Vue-Router动态路由加载数据
- en: In [Chapter 8](part0135.html#40NRU0-985bf4ae118d4f62b18ae64204cb251c), *Introducing
    Vue-Router and Loading URL-Based Components*, we explored Vue-router and its capabilities
    and functionality. With that knowledge, we can now progress on to making our shop
    with Vue. Before we jump into the code and start creating, we should first plan
    how our shop is going to work, what URLs we need, and what components we need
    to make. Once we've planned our app we can move on to creating a product page.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](part0135.html#40NRU0-985bf4ae118d4f62b18ae64204cb251c)中，我们介绍了Vue-router及其功能和功能。有了这些知识，我们现在可以继续使用Vue来创建我们的商店。在我们开始编写代码和创建之前，我们应该首先计划我们的商店将如何工作，我们需要哪些URL和组件。一旦我们计划好我们的应用程序，我们就可以继续创建产品页面。
- en: 'In this chapter, we are going to:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将：
- en: Outline our components and routes, and create placeholder files
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 概述我们的组件和路由，并创建占位符文件
- en: Load a product CSV file, process it, and cache in Vuex
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载产品CSV文件，处理并缓存在Vuex中
- en: Create an individual product page with images and product variations
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个包含图片和产品变体的单独产品页面
- en: Outline and plan your app
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述和计划您的应用程序
- en: First, let's think about the overall app and the user flow.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们考虑整个应用程序和用户流程。
- en: We are going to be creating a shop without a payment processing gateway. The
    shop homepage will display a hand-picked list of products. The user will be able
    to browse the products using categories and narrow down the selection using filters
    we've made. They will be able to select a product and view more details about
    it. The product will have variations (size, color, and such) and may have several
    product images. The user will be able to add a variation to their basket. From
    there, they can either continue browsing the products and add more to their basket,
    or proceed to checkout, where they will be asked for their name and address, and
    to pay. An order confirmation screen will be shown.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个没有支付处理网关的商店。商店首页将显示一个精选产品列表。用户将能够使用类别浏览产品，并使用我们创建的筛选器缩小选择范围。他们将能够选择一个产品并查看更多详细信息。产品将具有变体（大小、颜色等），并且可能有多个产品图片。用户将能够将变体添加到购物篮中。从那里，他们可以继续浏览产品并添加更多产品到购物篮，或者进入结账流程，在那里他们将被要求提供姓名和地址，并进行支付。将显示订单确认屏幕。
- en: The whole shop app will be created in Vue and will run client-side. This will
    not cover any server-side code needed for payment, user accounts, stock management,
    or validation.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 整个商店应用程序将在Vue中创建并在客户端运行。这不涵盖支付、用户帐户、库存管理或验证所需的任何服务器端代码。
- en: The app will use Vue-router for handling URLs and Vuex for storing products,
    basket contents, and user details.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序将使用Vue-router处理URL和Vuex存储产品、购物篮内容和用户详细信息。
- en: Components
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件
- en: With a user flow outlined, we need to plan which components we need to make
    for our shop and what they will be called. This helps with developing the app,
    as we have a clear idea of what components we need to create.  We will also decide
    on the component names. Following the Vue style guide ([https://vuejs.org/v2/style-guide/index.html](https://vuejs.org/v2/style-guide/index.html)),
    all our components will consist of two names.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在确定用户流程后，我们需要计划我们的商店需要创建哪些组件以及它们的名称。这有助于开发应用程序，因为我们清楚地知道需要创建哪些组件。我们还将决定组件的名称。根据Vue风格指南（[https://vuejs.org/v2/style-guide/index.html](https://vuejs.org/v2/style-guide/index.html)），我们的所有组件都将由两个名称组成。
- en: Route components
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由组件
- en: 'The following components will be used in conjunction with Vue-router to form
    the pages for our app:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 以下组件将与Vue-router一起用于形成我们应用程序的页面：
- en: '**Shop homepage**—`HomePage`: The shop homepage will display a list of products
    that are curated by the shop owner. This will use a pre-selected list of product
    handles to display.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**商店首页**—`HomePage`: 商店首页将显示由商店所有者精选的产品列表。这将使用预先选择的产品句柄列表进行显示。'
- en: '**Category page**—`CategoryPage`: This will list the products from a specific
    category. The category listing page will also have filters.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分类页面**—`CategoryPage`: 这将列出特定分类的产品。分类列表页面还将包含过滤器。'
- en: '**Product page**—`ProductPage`: The product page will display product details,
    images, and variations of the product.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**产品页面**—`ProductPage`: 产品页面将显示产品的详细信息、图片和变体。'
- en: '**Basket**—`OrderBasket`: In the basket, the user will be able to review the
    products they''ve added, remove unwanted items, and alter the quantity of each
    item. It will also show the overall cost of the order.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**购物篮**—`OrderBasket`: 在购物篮中，用户可以查看已添加的产品，删除不需要的项目，并更改每个项目的数量。它还将显示订单的总成本。'
- en: '**Checkout**—`OrderCheckout`: The checkout will lock down the basket – taking
    away the ability to remove and update products, and will have a form for the user
    to enter their address.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**结账**—`OrderCheckout`: 结账将锁定购物篮，禁止删除和更新产品，并提供一个表单供用户输入地址。'
- en: '**Order confirmation**—`OrderConfirmation`: This component will be displayed
    after the order has been placed, confirming the products purchased, the delivery
    address, and the total price.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**订单确认**—`OrderConfirmation`: 在下单后显示的组件，确认购买的产品、送货地址和总价。'
- en: '`404` **page**—`PageNotFound`: An error page when an incorrect URL is entered.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`404` **页面**—`PageNotFound`: 当输入错误的URL时显示的错误页面。'
- en: HTML components
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTML组件
- en: 'The HTML components will be used within the page components to help reduce
    repetition in our code for recurring layouts:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: HTML组件将在页面组件中使用，以帮助减少重复的布局代码：
- en: '**Product in a list**—`ListProducts`: This will display a paginated list of
    products when viewing in a list view – such as in the `HomePage` or `CategoryPage`
    components.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**产品列表**—`ListProducts`: 在列表视图中显示分页的产品列表，例如在`首页`或`分类页`组件中。'
- en: '**Category listing**—`ListCategories`: This will create a list of categories
    for navigation.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分类列表**—`ListCategories`: 这将创建一个用于导航的分类列表。'
- en: '**List of Purchases**—`ListPurchases`: This component will appear in the basket,
    checkout, and order confirmation page; it will list the products in a table form
    – detailing the variation, price, and quantity. It will also feature the total
    price of all the products in the basket.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**购买列表**—`ListPurchases`: 此组件将出现在购物篮、结账和订单确认页面中；它将以表格形式列出产品的变体、价格和数量。它还将显示购物篮中所有产品的总价。'
- en: '**Filtering**—`ProductFiltering`: A component used on the side of a category
    page will offer the user the ability to filter and will update the URL, using
    the GET parameters we covered in [Chapter 8](https://cdp.packtpub.com/vue_js_by_example/wp-admin/post.php?post=103&action=edit#post_93), *Introducing
    Vue-Router and Loading URL-Based Components.*'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**过滤**—`ProductFiltering`: 在分类页面的侧边使用的组件，将为用户提供过滤的能力，并更新URL，使用我们在[第8章](https://cdp.packtpub.com/vue_js_by_example/wp-admin/post.php?post=103&action=edit#post_93)中介绍的GET参数，*介绍Vue-Router和加载基于URL的组件*。'
- en: Paths
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路径
- en: 'With our components outlined, we can plan the paths and URLs to our shop, and
    which components or actions they are going to take. We also need to consider erroneous
    URLs and whether we should redirect the user to a suitable place or display an
    error message:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们概述了组件之后，我们可以规划商店的路径和URL，以及它们将采取的组件或操作。我们还需要考虑错误的URL，以及是否应该将用户重定向到适当的位置或显示错误消息：
- en: '`/`: `Home`'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/`: `首页`'
- en: '`/category/:slug`: `CategoryPage`, using the `:slug` unique identifier to identify
    which products to show'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/category`: This will redirect to `/`'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/product/:slug`: `ProductPage` – once again, using the `:slug` to identify
    the product'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/product`: This will redirect to `/`'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/basket`: `OrderBasket`'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/checkout`: `OrderCheckout` – if there are no products, however, it will redirect
    the user to `/basket`'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/complete`: `OrderConfirmation` – if the user did not come from the `OrderCheckout`
    component, then they will be redirected to ``/basket``'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*`: `PageNotFound` – this will catch any unspecified routes'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With our routes and components decided upon, we can begin to create our app.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Create initial files
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the app outlined in the preceding section, we can create the skeletons
    for our file structure and components. With this app being a large-scale app,
    we are going to split our files into individual files for each component. This
    means our files are much more manageable and our main app JavaScript file does
    not grow out of control.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: Although acceptable for development, deploying an app with this number of files
    could potentially increase your load times depending on how your server is set
    up. With the traditional HTTP/1.1, browsers have to request and load each file
    – which is a hindrance if there are multiple files. However, with HTTP/2, you
    are able to push several files to the user at the same time – in which case, multiple
    files can somewhat improve the performance of your app.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: 'Whichever method you choose to use with your deployment, it is highly advised
    you minify your JavaScript when deploying the code to a production environment.
    This ensures your code is as small as possible when being served up to your user:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00018.jpeg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
- en: Create a file for each component, view, and library, such as Vue, Vuex, and
    Vue-router. Then, create a folder for each type of file. Finally, add an `app.js`—which
    is where the libraries will be initialized.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: You may also consider using the vue-cli [(https://github.com/vuejs/vue-cli)](https://github.com/vuejs/vue-cli)
    for building your app. Beyond the scope of this book, as we only cover building
    a Vue app using the included JavaScript files, the vue-cli application allows
    you to develop your app in a more modular way and, once developed, deploy it in
    a similar fashion to how we have been developing the app.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an `index.html` and include your JavaScript files, ensuring Vue is loaded
    first and your app''s JavaScript last. Add a container for your app to form the
    view of our shop:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Ensure the `PageNotFound` component is loaded first, as we are going to be utilizing
    it within other components, as well as specifying it as the 404 page in our routes.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: Within each file, initialize the type of component it's going to be by either
    declaring a variable or using `Vue.component`. For the views, add a `name` attribute
    too – to help with debugging later on.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, all of the files located in the `js/components/` folder should
    be initialized like the following. Make sure these components are lowercase and
    are hyphenated:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Whereas the components for the routes and views, located in `js/views`, should
    look like the following:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The last step is to initialize our Vuex store, Vue-router, and Vue application.
    Open `app.js` and initialize the libraries:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: With the Vue components and routes ready to go, our store, route, and app initialized,
    let's look at setting up a server (if required) and loading in data.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: Server setup
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With our shop, we are going to be loading in a CSV of products on page load.
    This will simulate gathering stock and product data from a database or API from
    a point-of-sale system, something online shops with a physical shop might have
    to deal with.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: In a similar way to our Dropbox app earlier in the book, we will be loading
    external data and saving it into the Vuex store. The issue we will face, however,
    is when loading a resource via JavaScript; the browsers demand the protocol for
    the file being requested is via HTTP, HTTPS, or is a CORS request.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: This means that we are unable to load a *local* file using the `fetch()` technique
    we used with the Dropbox API as, when viewing our app in the browser, we are loading
    local assets over the `file://` protocol.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: 'We can resolve this issue in a few different ways – which one you choose depends
    on your circumstance. We are going to be loading a CSV file and, using two plugins,
    converting it into a useable JSON object. The three options you have are:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: Storing the file locally
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using a remote server or
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using a local server
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's run through each option, with the advantages and disadvantages for each.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: Storing the file locally
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first option is to convert the CSV to JSON appropriately once, and then
    save the output in a file. You''ll need to assign it to a variable in the file
    and load the JSON before your libraries. An example might be creating a `data.json`
    and updating it to be assigned to a variable:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You can then load the JSON file in your HTML:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You then have the `products` variable available to you in your `app.js`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: 'Advantages:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: Less load in your code
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No need to load the extra files required for processing the CSV
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No extra steps required
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Disadvantages:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: Does not simulate the real world
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want to update the CSV data, you need to convert, save, and assign to
    a variable
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a remote server
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another option is to upload the files to a remote, existing server and develop
    your app there.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: 'Advantages:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: Simulates real-world development of loading CSV
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can be developed anywhere, with any machine
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Disadvantages:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: Can be slow
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Needs to be connected to the internet
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Needs to either set up a deployment process or edit files on a live server
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up local server
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last option is to set up a local server on your machine. There are several
    small, lightweight, zero configuration modules, and applications, or there are
    bigger, beefier applications too. If you have npm installed on your machine, the
    node HTTP server is recommended. If not, there are other options available.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: The other option would be to use a more heavyweight application, which can provide
    you with an SQL database and the ability to run PHP applications. An example of
    this would be MAMP or XAMPP.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: 'Advantages:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: Simulates real-world development of loading CSV
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Quick, instant updates
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can be developed offline
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Disadvantages:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: Requires installing software
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: May require some configuration and/or command-line knowledge
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The option we are going to choose is the last one, using an HTTP server. Let's
    load and process the CSV so we can start creating our shop.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Loading CSV
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To simulate gathering data from a shop database or point-of-sale, our app is
    going to load product data from a CSV. CSV, or Comma Separated Values, is a file
    format often used for sharing data in a database-style way. Think of how you would
    lay out a list of products in excel or numbers: that is how a CSV file is formatted.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: This next step is going to require downloading and including a couple more JavaScript
    files. If you chose option 1 in the *Server setup* section – to have your files
    stored in a JSON file locally – you can skip this step.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: The data we're going to be using is example shop data from Shopify. These CSVs
    have a wide selection of product types and different data, which will test our
    Vue skills. Shopify has made their example data available for download from a
    GitHub repository ([https://github.com/shopifypartners/shopify-product-csvs-and-images](https://github.com/shopifypartners/shopify-product-csvs-and-images)).
    Download any CSV file that takes your interest and save it in a `data/` folder
    in your file system. For this app, I will be using the `bicycles.csv` file.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript cannot natively load and process CSV files without a significant
    amount of coding and processing of comma-separated and quote-encapsulated values.
    To save this book digressing into how to load, parse, and process CSV files, we
    are going to use a library to do the heavy lifting for us. There are two noteworthy
    libraries, CSV Parser ([https://github.com/okfn/csv.js](https://github.com/okfn/csv.js))
    and d3 ([https://d3js.org/](https://d3js.org/)). CSV Parser simply does CSV parsing
    and nothing else, while d3 has the ability to generate charts and data visualizations.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: It is worth considering which one suits you best; CSV Parser only adds just
    over 3 KB of weight to your app, whereas d3 is around 60 KB. Unless you anticipate
    adding visualizations later, it is recommended you go to the smaller library –
    especially as they execute the same function. However, we'll run through examples
    for both libraries.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: We want to load our product data when the app loads, so our CSV will be loaded
    and parsed by the time our components require the data. Because of this, we will
    be loading our data in the `created()` method of Vue.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Loading a CSV with d3
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Both plugins load the data in a very similar way, but the data returned varies
    somewhat – however, we'll deal with that once we have loaded our data.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: 'Load the d3 library – if you want to try it out, you can use the hosted version:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Using d3, we use a function on the `d3` object of `csv()`, which accepts one
    parameter – the path to the CSV file. Add the `created()` function to your Vue
    instance and initialize the CSV loader:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Remember the path to your file is relative to the HTML file which is including
    your JavaScript file – in this case, `index.html`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: 'Opening the file in your browser will not render any output. However, if you
    open the Javascript console and expand the object being output, you will see something
    similar to this:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00019.jpeg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
- en: 'This gives you a breakdown of all of the properties available on each product
    in a `key: value` format. This allows us to access each `value` in red, using
    a consistent `key` found on each product. For example, if we wanted `15mm-combo-wrench`
    from the product above, we could use the `Handle` key. More on this will be covered
    later'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Loading a CSV with CSV Parser
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'CSV Parser works in a slightly different way, in that it can accept many different
    parameters and the library contains several different methods and functions. The
    data output is also in a different format, providing a table/CSV style structure
    in return, with a `headers` and `fields` object:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Viewing the output this time will reveal a much different structure and will
    require matching up the `key` of the fields, with the index of the `headers` object.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: Unifying Shopify CSV data
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we can save and utilize the Shopify data, we need to unify the data and
    manipulate it into a more manageable state. If you inspect the data being output
    by either library, you will notice there is an entry for each variation or additional
    image of a product, with the handle being the linking factor between each entry.
    For example, there are around 12 entries with the handle of `pure-fix-bar-tape`,
    each one a different color. Ideally, we would like each variation grouped under
    the same item, also showing the images as a list of one product.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: The other issue with the Shopify CSV data is that the punctuation and grammar
    of the field headings do not make great object keys. Ideally object keys would
    be like URL slugs, lowercase and contain no spaces. For example, `Variant Inventory
    Qty` should ideally be `variant-inventory-qty`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: 'To save manually processing the data ourselves and updating the keys, we can
    use a Vue plugin to process the output from either loading library and return
    an object of products formatted exactly how we want. The plugin is `vue-shopify-products`
    and is available from unpkg:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Download and include the library into your `index.html` file. The next step
    is to tell Vue to use this plugin – at the top of your `app.js` file, include
    the following line:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This now exposes a new method on the Vue instance of `$formatProducts()`, which
    allows us to pass in the output of our CSV loading library and get a more useful
    collection of objects:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Inspecting the output now reveals a collection grouped by `handle`, with variations
    and images as objects:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00020.jpeg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
- en: With our products grouped more effectively, we can proceed with storing and
    recalling as desired.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: Storing the products
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once we have retrieved and formatted the CSV data, we can cache the contents
    in the Vuex store. This will be done via a simple mutation that takes a payload
    and stores it without any modifications.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `state` and `mutations` object in your store. Add a key of `products` as
    an object in the `state`, and create a function in the `mutations` object, also
    titled `products`. The mutation should accept two parameters – the state and a
    payload:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Update the `state.products` object to the contents of the `payload`:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Replace the `console.log` in the main Vue instance with a commit function,
    calling the new mutation and passing in the formatted product data:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This can be reduced somewhat, by passing the `$formatProducts` function directly
    into the store `commit()` function, rather than storing it as a variable:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Displaying a single product
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With our data stored, we can now begin making our components and displaying
    content on the frontend. We're going to start by making a product view – displaying
    product details, variations, and images. We'll move on to creating the category listing
    page in [Chapter 10](part0185.html#5GDO20-985bf4ae118d4f62b18ae64204cb251c), *Building
    an E-Commerce Store – Browsing Products*.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: The first step in making our product view is to create the route, to allow the
    component to be displayed via a URL. Referring back to our notes at the beginning
    of the chapter, the product component is to be loaded on the `/product/:slug`
    path.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `routes` array in your Vue-router, with the path and component specified:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: With the layout of the `products` object explained, we can start to understand
    how the route and products link. We will pass the handle of the product into the
    URL. This will select the product with that handle and display the data. This
    means we do not need to explicitly link `slug` with `products`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Page Not Found
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With our first route created, we should also create our `PageNotFound` route,
    to catch any URLs that are non-existent. We can also redirect to this page when
    there is no product that matches.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: We're going to create the `PageNotFound` component in a slightly different way
    than we did before. Rather than having the component on `*`, we're going to create
    a `/404` path as a named route. This allows us to alias and redirect several different
    routes as required.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Add a new object to the routes array, with  `/404` as the path, the `PageNotFound`
    component as the specified component. Add a name to your route, so we can utilize
    if required, and lastly, add an `alias` attribute, which contains our global,
    catchall route.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: 'Don''t forget to put this *at the end* of the routes array – to catch any previously
    unspecified route. When adding new routes, always remember to put them before
    the `PageNotFound` route:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Add a template to your `PageNotFound` component. For now, give it some basic
    content – we can improve it later, once we have the rest of our app set out:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Note the use of the router link in the content. The last thing we need to do
    to get our app started is to add the `<router-view>` element inside our app. Head
    to the view, and include it in the app space:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Load up the app in your browser, not forgetting to start the HTTP server if
    required. You should be, at first, presented with your `PageNotFound` component
    contents. Navigating to the following product URL should result in a JavaScript
    error instead of the `404` page. This shows the route is correctly picking up
    the URL but the error is because our `ProductPage` component does not contain
    a template:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: If you are presented with the `PageNotFound` component, check your route's code,
    as it means the `ProductPage` route is not being picked up.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Selecting the right product
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With our initial routes set up, we can now proceed with loading the desired
    product and displaying the information from the store. Open `views/Product.js`
    and create a template key. To begin with, create a simple `<div>` container that
    displays the title of the product:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Viewing this in the browser will instantly throw a JavaScript error as Vue is
    expecting the `product` variable to be an object – but it is currently undefined
    as we have yet to declare it. Although the fix for this seems fairly simple at
    the moment, we need to consider the case where the product is not yet defined.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: Our shop app loads the data CSV asynchronously. This means that the execution
    of the rest of the app does not stop while the products are being loaded. Overall,
    this increases the speed of our app at the moment we have the products, we can
    start manipulating and displaying the list, without waiting for the rest of the
    app to start.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Because of this, there is a distinct possibility that the user could visit the
    product details page, be it from a link that was shared or a search result, without
    the product list being loaded. To prevent the app trying to display the product
    data without being fully initialized, add a conditional attribute to the template
    to check if the product variable exists before trying to display any of its attributes.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: 'When loading our product data, we can then ensure the product variable is set
    to `false`, until everything is fully loaded. Add the `v-if` attribute to the
    containing element in your template:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We can now start loading the correct product from the store and assign it to
    a variable.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `computed` object with a `product()` function inside. Within that,
    create a blank variable of the product, and return it afterward. This now defaults
    to returning `false`, which means our template will not generate the `<div>`:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Selecting the product is now a fairly simple procedure, thanks to our helpfully-formatted
    product store and the `slug` variable, available to us within the `Product` component.
    The `products` object in the store is formatted with the handle as the key and
    the `product details` object as the value. With this in mind, we can select the
    desired product using the square bracket format. For example:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Using the router `params` object, load the desired product from the store and
    assign it to the `product` variable to be returned:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The reason we don't assign the value of `product` straightaway is so we can
    add some conditional statements. To ensure we are only loading the product if
    the store has the data available, we can add an `if()` statement to make sure
    the product's object has keys available; in other words, has the data loaded?
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: 'Add an `if` statement checking the length of the store product keys. If they
    exist, assign the data from the store to the `product` variable to be returned:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Viewing the app in the browser now, you will be presented with the title of
    the product – once the data has loaded. This should only take a split second to
    load and should be gracefully handled by our `if` statement.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Before proceeding with displaying all our product data, we need to handle the
    situation where a product does not exist with the handle in the URL. Because our
    `ProductPage` route is picking up anything after `/product` in the URL, the `PageNotFound`
    wildcard path will not be able to be used – as it is our `ProductPage` component
    that is loading the data and determining whether the product exists.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Catching products not found
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to show the `PageNotFound` page when a product is not available, we
    are going to load the component with our `ProductPage` component and display it
    conditionally.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: To do this, we need to register the component so we can use it in our template.
    We need to register it since our `PageNotFound` component currently lives as an
    object and not a Vue component (for example, when we use `Vue.component`).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a `components` object to your `ProductPage` component and include `PageNotFound`:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This now gives us a new HTML element to use in the form of `<page-not-found>`.
    Add this element to your template after the existing `<div>`. As our templates
    need a single root element, wrap both of them in an extra container:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Viewing this in the browser will render the `404`page template and, once the
    data has loaded, the product title above that. We now need to update the component
    to only show the `PageNotFound` component when there is no data to show. We could
    use the existing product variable with a `v-if` attribute and, if false, show
    the error message like so:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: However, this would mean that if the user visited the product page without the
    product data loading yet, they would see a flash of the 404 information before
    being replaced with the product information. This isn't a very good user experience,
    so we should only show the error if we are sure the product data has loaded and
    that there isn't a matching item.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: 'To combat this, we will create a new variable which will determine if the component
    displays. Create a data function in the `ProductPage` component that returns an
    object with a key of `productNotFound`, set to false. Add a `v-if` condition to
    the `<page-not-found>` element, checking against the new `productNotFound` variable:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The last step is to set the variable to `true` if a product doesn''t exist.
    As we only want to do this once the data has loaded, add the code to the `$store.state.products`
    check. We are already assigning the data to the `product` variable, so we can
    add a check to see if this variable exists – if not, change the polarity of our
    `productNotFound` variable:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Try entering an erroneous string at the end of the URL – you should be faced
    with our, now familiar, `404`error page.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Displaying product information
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With our product loading, filtering, and error-catching in place, we can proceed
    with displaying the information we need for our product. Each product could contain
    one or many images, and one or many variations and any combination in-between
    – so we need to make sure we cater for each of these scenarios.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: 'To see the data available to us, add a `console.log(product)` just before the
    `return`:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Open up the JavaScript console and inspect the object that should now be there.
    Familiarize yourself with the keys and values available to you. Take note that
    the `images` key is an array and the `variations` an object, containing a string
    and a further array.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: Before we tackle the variations and images – let's output the simple stuff.
    What we need to remember is that every field we output might not exist on every
    product – so it's best to wrap it in conditional tags where necessary.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: 'Output the `body`, `type`, and `vendor.title` from the product details. Prepend
    both the `vendor.title` and `type` with a description of what they are, but make
    sure you only render that text if it exists in the product details:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Notice we've got the flexibility to prepend the type and vendor with more user-friendly
    names. Once we have our categories and filtering set up, we can link both the
    vendor and type to appropriate product listing.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: 'Viewing this in the browser will reveal the body outputting all HTML tags as
    text – meaning we can see them on the page. If you cast your mind back to the
    beginning of the book where we were discussing output types, we need to use `v-html`
    to tell Vue to render the block as raw HTML:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Product images
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next step is to output the images for our product. If you are using the bicycles
    CSV file, a good product to test with is `650c-micro-wheelset` – navigate to this
    product as it has four images. Don't forget to go back to your original product
    to check that it works with one image.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: The images value will always be an array, whether there is one image or 100,
    so to display them, we will always need to do a `v-for`. Add a new container and
    loop through the images. Add a width to each image so it doesn't take over your
    page.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: 'The images array contains an object for each image. This has an `alt` and `source`
    key that can be input directly into your HTML. There are some instances, however,
    where the `alt` value is missing – if it is, insert the product title instead:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: With our images displaying, it would be a nice addition to create a gallery.
    Shops often show one big image, with a set of thumbnails underneath. Clicking
    each thumbnail then replaces the main image so the user can get a better look
    at the bigger image. Let's recreate that functionality. We also need to ensure
    we don't show the thumbnails if there is only one image.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: We do this, by setting an image variable to the first image in the images array,
    this is the one that will form the big image. If there is more than one image
    in the array, we will show the thumbnails. We will then create a click method
    that updates the image variable with the selected image.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new variable in your data object and update it with the first item
    from the images array when the product has loaded. It''s good practice to ensure
    the `images` key is, in fact, an array of items before trying to assign a value:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Next, update your existing images loop in your template to only display when
    there is more than one image in the array. Also, add the first image as the main
    image in your template – not forgetting to check whether it exists first:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The last step is to add a click handler to each of the thumbnail images, to
    update the image variable when interacted with. As the images will not natively
    have the `cursor: pointer` CSS attribute, it might be worth considering adding
    this.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: 'The click handler will be a method that accepts each image in the thumbnail
    loop as a parameter. On click, it will simply update the image variable with the
    object passed through:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Load the product up in your browser and try clicking on any of the thumbnails
    - you should be able to update the main image. Don't forget to validate your code
    on a product with one image or even zero images, to make sure the user isn't going
    to encounter any errors.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: Don't be afraid of whitespace and adding new lines for readability. Being able
    to easily understand your code is better than the few bytes you would have saved
    on file load. When deploying to production, files should be minified, but during
    development white space takes precedence.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: Product variations
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With this particular dataset, each of our products contains at least one variation
    but can contain several. This normally goes hand-in-hand with the number of images
    but does not always correlate. Variations can be things such as color or size.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: On our `Product` object, we have two keys which are going to help us display
    the variations. These are `variationTypes`, which list the names of the variations
    such as size and color, and `variationProducts`,which contains all of the variations.
    Each product within the `variationProducts` object has a further object of `variant`,
    which lists all of the changeable properties. For example, if a jacket came in
    two colors and each color had three sizes, there would be six `variationProducts`,
    each with two `variant` properties.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: Every product will contain at least one variation, although if there is only
    one variation, we may need to consider the UX of the product page.  We are going
    to display our product variations in both a table and drop-down, so you can experience
    creating both elements.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: Variations display table
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create a new container in your product template that will display the variations.
    Within this container, we can create a table to display the different variations
    of the product. This will be achieved with a `v-for` declaration. However, now
    that you are more familiar with the functionality, we can introduce a new attribute.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: Using a key with loops
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When using loops in Vue, it is advised you use an extra attribute to identify
    each item, `:key`. This helps Vue identify the elements of the array when re-ordering,
    sorting, or filtering. An example of `:key` use would be:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The key attribute should be a unique attribute of the item itself and not the
    index of the item in the array, to help Vue identify the specific object. More
    information about using a key with a loop is available in the [official Vue documentation](https://vuejs.org/v2/guide/list.html#key).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: We'll be utilizing the `key` attribute when displaying our variations, but using
    the `barcode` attribute.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: Displaying the variations in a table
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Add a table element to your variations container and loop through the `items`
    array. For now, display the `title`, `quantity` and `price`. Add an additional
    cell that contains a button with the value of Add to basket. We'll configure that
    in [Chapter 11](part0216.html#6DVPG0-985bf4ae118d4f62b18ae64204cb251c), *Building
    an E-commerce Store – Adding a Checkout.* Don't forget to add a `$` currency symbol
    in front of your price, as it's currently just a "raw" number.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: 'Watch out – when using the `$` sign within the template literals, JavaScript
    will try and interpret it, along with the curly brackets, as a JavaScript variable.
    To counteract this, prepend the currency with a backslash – this tells JavaScript
    that the next character is literal, and should not be interpreted in any other
    way:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Although we're displaying the price and quantity, we aren't outputting the actual
    variant properties of the variation (such as color). To do this, we are going
    to need to do some processing on our variation with a method.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: 'The variant object contains a child object for each variation type, with a
    name and a value for each type. They are also stored with a slug-converted key
    within the object. See the following screenshot for more details:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00021.jpeg)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
- en: 'Add a new cell at the beginning of the table that passes the variation to a
    method titled `variantTitle()`:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Create the new method within your `methods` object:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We now need to construct a string with the title of the variant, displaying
    all available options. To do this, we are going to construct an array of each
    of the types and then join them into a string.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: 'Store the `variants` as a variable and create an empty array. We can now loop
    through the keys available within the `variants` object and create a string to
    output. If you decide to add HTML into the string, as shown in the following example,
    we will need to update our template to output HTML instead of a raw string:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Our output array will have an item for each variant, formatted like the following:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We can now join each one together, which transforms the output from an array
    to a string. The character, string, or HTML you choose to join it with is up to
    you. For now, use a `/` with spaces on either side. Alternatively, you could use
    `</td><td>` tags to create a new table cell. Add the `join()` function and update
    the template to use `v-html`:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Attach a click event to the Add to basket button and create a new method on
    the component. This method will require the `variation` object to be passed in,
    so the correct one could be added to the basket. For now, add a JavaScript `alert()` to
    confirm you have the right one:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Note the template literals used within the alert box – this allows us to use
    Javascript variables without having to use string concatenation techniques. Clicking
    on the Add to basket button will now generate a popup listing of the name of the
    product and the variation clicked.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: Displaying variations in a select box
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A more common interface pattern on product pages is to have a drop-down list,
    or select box, with your variations displayed and available for selecting.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: When using a select box, we will have a variation which has either been selected
    by default or that the user has interacted with and chosen specifically. Because
    of this, we can change the image when the user changes the select box and display
    other pieces of information about the variant on the product page, including price
    and quantity.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: We won't be relying on passing through the variant to the `addToBasket` method,
    as it will exist as an object on the product component.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: 'Update your `<table>` element to be a `<select>`,  and the `<tr>` to an `<option>`.
    Move the button *outside* of this element and remove the parameter from the `click`
    event. Remove any HTML from the `variantTitle()` method. Because it is now inside
    a select box it is not required:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The next step is to create a new variable available to use on the component.
    In a similar vein to the images, this will be completed with the first item of
    the `variationProducts` array and updated when the select box changes.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new item in the data object, titled `variation`. Populate this variable
    when the data is loaded into the `product` computed variable:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Update the `addToBasket` method to use the `variation` variable of the `ProductPage`
    component and not rely on a parameter:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Try clicking the Add to basket button – it should add the first variation, regardless
    of what is selected in the dropdown. To update the variable on change, we can
    bind the `variations` variable to the select box – in the same way, that we did
    our textbox filtering at the beginning of this book.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a `v-model` attribute to the `select` element. We will also need to tell
    Vue what to bind to this variable when selecting. By default, it will do the contents
    of the `<option>`, which is currently our custom variant title. However, we want
    to bind the whole `variation` object. Add a `:value` property to the `<option>`
    element:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Changing the select box and clicking the Add to basket button will now produce
    the correct variation. This method gives us much more flexibility over displaying
    the variations in a table.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: 'It allows us to display variation data in other places on the product. Try
    adding the price next to the product title and the quantity within the `meta`
    container:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'These two new attributes will update when changing the variation. We can also
    update the image to the selected variation if it has one. To do this, add a `watch`
    object to your component, which watches the variation variable. When updated,
    we can check if the variation has an image and, if so, update the image variable
    with this property:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: When using `watch`, the function passes the new item as the first parameter.
    Rather than referring to the one on the component, we can use this to gather the
    image information.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: Another enhancement we can make is to disable the Add to basket button and add
    a note in the dropdown if the variation is out of stock. This information is gathered
    from the variation `quantity` key.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: 'Check the quantity and, if less than one, display an out of stock message in
    the select box and disable the Add to basket button using the `disabled` HTML
    attribute. We can also update the value of the button:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: If using the `bicycles.csv` dataset, the Keirin Pro Track Frameset product (`/#/product/keirin-pro-track-frame`)
    contains several variations, some without stock. This allows you to test the `out
    of stock` functionality along with the image changing.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: Another thing we can do to the product page is only show the dropdown when there
    is more than one variation. An example of a product with only one is the 15 mm
    Combo Wrench (`#/product/15mm-combo-wrench`). In this instance, it is not worth
    showing the `<select>` box. As we are setting the `variation` variable on the
    `Product` component on load, we are not relying on the selection to initially
    set the variable. Because of this, we can completely remove the select box with
    a `v-if=""` when there is only one alternate product.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: 'Like we did with the images, check if the length of the array is more than
    one, this time the `variationProducts` array:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: By removing elements when they are not needed, we now have a less cluttered
    interface.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: Updating the product details when switching URLs
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While navigating through the different product URLs to check variations, you
    may have noticed that clicking back and forward doesn't update the product data
    on the page.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: This is because `Vue-router` realizes the same component is being used between
    the pages, and so, rather than destroying and creating a new instance, it reuses
    the component. The downside to this is that the data does not get updated; we
    need to trigger a function to include the new product data. The upside is that
    the code is more efficient.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: To tell Vue to retrieve the new data, we need to create a `watch` function;
    instead of watching a variable, we are going to watch the `$route` variable. When
    this gets updated, we can load new data.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new variable in the data instance of `slug`, and set the default to
    be the route parameter. Update the `product` computed function to use this variable
    instead of the route:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: We can now create a `watch` function, keeping an eye on the `$route` variable.
    When this changes, we can update the `slug` variable, which in turn will update
    the data being displayed.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: When watching a route, the function has two parameters passed to it: `to` and
    `from`. The `to` variable contains everything about the route we are going to,
    including parameters and the component used. The `from` variable contains everything
    about the current route.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: 'By updating the `slug` variable to the new parameter when the route changes,
    we are forcing the component to redraw with new data from the store:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: With our product page completed, we can move on to creating a category listing
    for both the `type` and `vendor` variables. Remove any `console.log()` calls you
    have in your code, too, to keep it clean.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter has covered a lot. We loaded and stored a CSV file of products
    into our Vuex store. From there, we created a product detail page that used a
    dynamic variable in the URL to load a specific product. We have created a product
    detail view that allows the user to look through a gallery of images and choose
    a variation from a drop-down list. If the variation has an associated image, the
    main image updates.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 10](part0185.html#5GDO20-985bf4ae118d4f62b18ae64204cb251c), *Building
    an E-Commerce Store – Browsing Products*,
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: we will create a category page, creating filtering and ordering functions –
    helping the user to find the product they want.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
