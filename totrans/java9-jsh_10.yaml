- en: Chapter 10. Maximization of Code Reuse with Generics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn about parametric polymorphism and how Java 9
    implements this object-oriented concept by allowing us to write generic code.
    We will start creating classes that use one constrained generic type. We will:'
  prefs: []
  type: TYPE_NORMAL
- en: Understand parametric polymorphism
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn the differences between parametric polymorphism and duck typing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand Java 9 generics and generic code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Declare an interface to be used as a type constraint
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Declare a class that conforms to multiple interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Declare subclasses that inherit the implementation of interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create exception classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Declare a class that works with a constrained generic type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a generic class for multiple compatible types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding parametric polymorphism, Java 9 generics, and generic code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine that we have develop a Web Service that has to work with the representation
    of the organization of a party of specific wild animals. We definitely don't want
    to mix lions with hyenas because the party would end up with the hyenas intimidating
    a lonely lion. We want a well-organized party, and we don't want intruders such
    as dragons or cats in a party where only lions should attend.
  prefs: []
  type: TYPE_NORMAL
- en: We want to describe the procedures to start, welcome members, organize the party
    and say goodbye to the different members of the party. Then, we want to replicate
    these procedures with swans in a party of swans. Thus, we want to reuse our procedures
    for a party of lions and a party of swans. In the future, we will need to use
    the same procedures for parties of other wild and domestic animals, such as foxes,
    alligators, cats, tigers, and dogs. Obviously, we wouldn't like to become intruders
    in a party of alligators. Neither would we like to participate in the party of
    tigers.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapters, [Chapter 8](part0076_split_000.html#28FAO2-bc1530b4c4784270ae8a31a7038f8341
    "Chapter 8. Contract Programming with Interfaces"), *Contract Programming with
    Interfaces*, and [Chapter 9](part0083_split_000.html#2F4UM2-bc1530b4c4784270ae8a31a7038f8341
    "Chapter 9. Advanced Contract Programming with Interfaces"), *Advanced Contract
    Programming with Interfaces*, we learned to work with interfaces in Java 9\. We
    can declare an interface to specify the requirements for an animal that can participate
    in a party and then take advantage of Java 9 features to write generic code that
    works with any class that implements the interface.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Parametric polymorphism** allows us to write generic and reusable code that
    can work with values without depending on the type while keeping the full static-type
    safety.'
  prefs: []
  type: TYPE_NORMAL
- en: We can take advantage of parametric polymorphism in Java 9 through generics,
    also known as generic programming. After we declare an interface that indicates
    the requirements for an animal that can participate in a party, we can create
    a class that works with any instance that implements this interface. This way,
    we can reuse the code that generates a party of lions and create a party of swans,
    hyenas, or any other animal. Specifically, we can reuse code that generates a
    party of any instance of a class that implements the interface that specifies
    the requirements for an animal that can participate in a party.
  prefs: []
  type: TYPE_NORMAL
- en: We require animals to be sociable in order to participate in a party, and therefore,
    we can create an interface named `Sociable` to specify the requirements for an
    animal that can participate in a party. However, take into account that many wild
    animals we will use as an example are not very sociable.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Many modern strongly typed programming languages allow us to work with parametric
    polymorphism through generics. If you have worked with C# or Swift, you will find
    that the syntax in Java 9 is very similar to the syntax used in these programming
    languages. C# also works with interfaces, but Swift uses protocols instead of
    interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Other programming languages, such as Python, JavaScript, and Ruby, work with
    a different philosophy known as **duck typing**, where the presence of certain
    fields and methods make an object suitable to its usage as a specific sociable
    animal. With duck typing, if we require sociable animals to have the `getName`
    and `danceAlone` methods, we can consider any object as a sociable animal as long
    as it provides the required methods. Thus, with duck typing, any instance of any
    type that provides the required methods can be used as a sociable animal.
  prefs: []
  type: TYPE_NORMAL
- en: Let's move to a real-life situation to understand the duck typing philosophy.
    Imagine that we see a bird and this bird quacks, swims, and walks like a duck.
    We can definitely call this bird a duck because it satisfies all the conditions
    required for this bird to be a duck. Similar examples related to a bird and a
    duck generate the duck typing name. We don't need additional information to work
    with the bird as a duck. Python, JavaScript, and Ruby are examples of languages
    where duck typing is extremely popular.
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to work with duck typing in Java 9, but it is not the natural
    way of doing things in this programming language. It would require many complex
    workarounds to implement duck typing in Java 9\. Thus, we will focus on learning
    to write generic code with parametric polymorphism through generics.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring an interface to be used as a type constraint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we will create a `Sociable` interface to specify the requirements that
    a type must meet in order to be considered a potential member of a party, that
    is, a sociable animal in our application domain. Then, we will create a `SociableAnimal`
    abstract base class that implements this interface, and then, we will specialize
    this class in three concrete subclasses: `SocialLion`, `SocialParrot`, and `SocialSwan`.
    Then, we will create a `Party` class that will be able to work with instances
    of any class that implements the `Sociable` interface through generics. We will
    create two new classes that will represent specific exceptions. We will work with
    a party of sociable lions, one of sociable parrots, and another of sociable swans.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following UML diagram shows the interface, the abstract class that implements
    it, and the concrete subclasses that we will create, including all the fields
    and meth:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Declaring an interface to be used as a type constraint](img/00089.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The following lines show the code for the `Sociable` interface. The code file
    for the sample is included in the `java_9_oop_chapter_10_01` folder, in the `example10_01.java`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The interface declares the following nine method requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: '`getName`: This method must return a `String` with the name for `Sociable`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getAge`: This method must return an `int` with the age for `Sociable`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`actAlone`: This method must make `Sociable` act alone.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`danceAlone`: This method must make `Sociable` dance alone.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`danceWith`: This method must make `Sociable` dance with another `Sociable`
    received in the partner argument.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`singALyric`: This method must make `Sociable` sing the lyric received as an
    argument.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`speak`: This method makes `Sociable` say a message.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`welcome`: This method makes `Sociable` say a welcome message to another `Sociable`
    received in the other argument.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sayGoodbyeTo`: This method makes `Sociable` say goodbye to another `Sociable`
    received in the other argument.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We didn't include any default method in the interface declaration, and therefore,
    the classes that implement the `Sociable` interface are responsible for implementing
    the previously enumerated nine methods.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring a class that conforms to multiple interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '`actAlone`: This method prints the name followed by `"to be or not to be"`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`danceAlone`: This method uses the `String` retrieved with a call to the `getDanceRepresentation`
    method to print the name followed by a message indicating that the social animal
    is dancing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`danceWith`: This method uses the `String` retrieved with a call to the `getDanceRepresentation`
    method to print the name followed by a message indicating that the social animal
    is dancing with the partner specified in the partner argument of the `Sociable`
    type. The message prints the name for the partner.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`singALyric`: This method uses the strings retrieved with calls to `getFirstSoundInWords`,
    `getSecondSoundInWords`, and `getThirdSoundInWords` and the lyric received as
    an argument to print the name followed by a message indicating that the social
    animal sings the lyric.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`speak`: This method uses the `String` retrieved with a call to `getDanceRepresentation`
    and the message received as an argument to print the name followed by the words
    that the animal says followed by its dance representation characters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`welcome`: This method prints a message to say welcome to another `Sociable`
    received in the other argument. The message includes the name for the destination.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sayGoodbyeTo`: This method uses the strings retrieved with calls to `getFirstSoundInWords`,
    `getSecondSoundInWords`, and `getThirdSoundInWords` and to build and print a message
    to say goodbye to another `Sociable` received in the other argument. The message
    includes the name for the destination.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: First, the code checks whether the received `Object` is a reference to the actual
    instance. In this case, the code returns `true` and nothing else has to be checked.
  prefs: []
  type: TYPE_NORMAL
- en: Then, the code checks whether the value for `other` is equal to `null`. In case
    the method received `null`, the code returns `false` because the actual instance
    is not `null`.
  prefs: []
  type: TYPE_NORMAL
- en: Then, the code checks whether the `String` returned by the `getClass` method
    for the actual instance matches the `String` returned by the same method for the
    received instance. If these values do not match, it means that the received `Object`
    is an instance of a different type, and therefore, it is different and the code
    returns `false`.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we know that the actual instance has the same type as the received
    instance. Thus, it is safe to typecast the other argument to `SocialAnimal` and
    save the casted reference in the `otherSocialAnimal` local variable of the `SocialAnimal`
    type.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the code returns the results of evaluating whether the calls to `Object.equals`
    for `getName` and `getAge` for the current instance and `otherSocialAnimal` are
    both `true`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is a good practice to follow the previously explained steps when we override
    the `equals` method inherited from `java.lang.Object`. In case you have experience
    with C#, it is important to understand that Java 9 doesn't provide an equivalent
    to the `IEquatable<T>` interface. In addition, take into account that Java doesn't
    support user-defined operator overloading, a feature that is included in other
    object-oriented programming languages such as C++, C#, and Swift.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `SocialAnimal` abstract class also implements the `compareTo` method required
    by the `Comparable<Sociable>` interface. In this case, the code is very simple
    because the method receives a `Sociable` instance in the `otherSociable` argument
    and returns the results of calling the `Integer.compare` method, that is, the
    `compare` class method for the `java.lang.Integer` class. The code calls this
    method with the `int` values returned by `getAge` for the current instance and
    `otherSociable` as the two arguments. The `Integer.compare` method returns the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`0` if the first argument is equal to the second one.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Less than `0` if the first argument is lower than the second one.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Greater than `0` if the first argument is greater than the second one.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the concrete subclasses that inherit from `SocialAnimal` will be able to
    use the `equals` and `compareTo` methods implemented in the `SocialAnimal` abstract
    class.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring subclasses that inherit the implementation of interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have the `SocialAnimal` abstract class that implements both the `Sociable`
    and `Comparable<Sociable>` interfaces. We cannot create instances of this abstract
    class. Now, we will create a concrete subclass of `SocialAnimal` named `SocialLion`.
    The class declares a constructor that ends up calling the constructor defined
    in the superclass. The class implements the four abstract methods declared in
    its superclass to return the appropriate values for a lion that will participate
    in a party. The code file for the sample is included in the `java_9_oop_chapter_10_01`
    folder, in the `example10_01.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We will create another concrete subclass of `SocialAnimal` named `SocialParrot`.
    This new subclass also implements the abstract methods defined in the `SocialAnimal`
    superclass but, in this case, returns the appropriate values for a parrot. The
    code file for the sample is included in the `java_9_oop_chapter_10_01` folder,
    in the `example10_01.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we will create another concrete subclass of `SocialAnimal` named `SocialSwan`.
    This new subclass also implements the abstract methods defined in the `SocialAnimal`
    superclass but, in this case, returns the appropriate values for a swan. The code
    file for the sample is included in the `java_9_oop_chapter_10_01` folder, in the
    `example10_01.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We have three concrete classes that inherit the implementation of two interfaces
    from its abstract superclass: `SociableAnimal`. The following three concrete classes
    implement both the `Sociable` and `Comparable<Sociable>` interfaces, and they
    can use the inherited overridden `equals` method to compare their instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SocialLion`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SocialParrot`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SocialSwan`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating exception classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will create two exception classes because we need to throw exception types
    that aren't represented by any of the types included in the Java 9 platform. Specifically,
    we will create two subclasses of the `java.lang.Exception` class.
  prefs: []
  type: TYPE_NORMAL
- en: The following lines declare the `InsufficientMembersException` class that inherits
    from `Exception`. We will throw this exception when a party has an insufficient
    number of members to perform an operation that requires more members to be executed.
    The class defines an immutable `numberOfMembers` private field of the `int` type
    that is initialized with the value received in the constructor. In addition, the
    class declares a `getNumberOfMembers` method that returns the value for this field.
    The code file for the sample is included in the `java_9_oop_chapter_10_01` folder,
    in the `example10_01.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The following lines declare the `CannotRemovePartyLeaderException` class that
    inherits from `Exception`. We will throw this exception when a method tries to
    remove the current party leader from the party's member list. In this case, we
    just declare an empty class that inherits from `Exception` because we don't need
    additional features, we just want the new type. The code file for the sample is
    included in the `java_9_oop_chapter_10_01` folder, in the `example10_01.java`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Declaring a class that works with a constrained generic type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following lines declare a `Party` class that takes advantage of generics
    to work with many types. We import `java.util.concurrent.ThreadLocalRandom` because
    it is an extremely useful class to easily generate a pseudo-random number within
    a range. The class name, `Party`, is followed by a less than sign (`<`), a `T`
    that identifies the generic type parameter, the `extends` keyword, and an interface
    name that the `T` generic type parameter must implement, `Sociable`, an ampersand
    (`&`), and another interface name that the `T` generic type must also implement,
    `Comparable<Sociable>`. The greater than sign (`>`) ends the type constraint declaration
    that is included within angle brackets (`<>`). Thus, the `T` generic type parameter
    has to be a type that must implement both the `Sociable` and `Comparable<Sociable>`
    interfaces. The following code highlights the lines that use the `T` generic type
    parameter. The code file for the sample is included in the `java_9_oop_chapter_10_01`
    folder, in the `example10_01.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Now we will analyze many code snippets to understand how the code included in
    the `Party<T>` class works. The following line starts the class body, declares
    a protected `List<T>`, that is, a `List` of elements whose type is `T` or implements
    the `T` interface. `List` uses generics to specify the type of the elements that
    will be accepted and added to the list.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The following line declares a protected `partyLeader` field whose type is `T`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The following lines declare a constructor that receives a `partyLeader` argument
    whose type is `T`. The argument specifies the first party leader and also the
    first member of the party, that is, the first element added to the `membersList<T>`.
    The code that creates a new `ArrayList<T>` takes advantage of type inference that
    was introduced with Java 7, improved in Java 8, and persists in Java 9\. We specify
    `new ArrayList<>()` instead of `new` `ArrayList<T>()` because Java 9 can use the
    empty set of type parameters (`<>`) to infer the type arguments from the context.
    The `members` protected field has a `List<T>` type, and therefore, Java's type
    inference can determine that `T` is the type and that `ArrayList<>()` means `ArrayList<T>()`.
    The last line adds the `partyLeader` to the `members` list.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When we invoke the constructor of a generic class with an empty set of type
    parameters, the pair of angle brackets (`<>`) is known as the **diamond**, and
    the notation is named **diamond notation**.
  prefs: []
  type: TYPE_NORMAL
- en: The following lines declare the `getPartyLeader` method that specifies `T` as
    the return type. The method returns `partyLeader`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines declare the `addMember` method that receives a `newMember`
    argument whose type is `T`. The code adds the new member received as an argument
    to the `members` list and calls the `partyLeader.sayWelcomeTo` method with `newMember`
    as an argument to make the party leader welcome the new member:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The following lines declare the `removeMember` method that receives a `memberToRemove`
    argument whose type is `T`, returns `T`, and can throw a `CannotRemovePartyLeaderException`
    exception. The `throws` keyword after the method arguments followed by the exception
    name indicates that the method can throw the specified exception. The code checks
    whether the member to be removed matches the party leader with the help of the
    `equals` method. The method throws a `CannotRemovePartyLeaderException` exception
    in case the member is the party leader. The code retrieves the index for `memberToRemove`
    in the list and calls the `members.remove` method with `memberToRemove` as an
    argument in case it was a member of the list. Then, the code calls the `sayGoodbyeTo`
    method for the successfully removed member with `partyLeader` as an argument.
    This way, the member that leaves the party says goodbye to the party leader. In
    case the member is removed, the method returns the removed member. Otherwise,
    the method returns `null`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines declare the `makeMembersAct` method that calls the `actAlone`
    method for each member of the `members` list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the forthcoming chapters, we will learn other ways of coding the same method
    that performs an action for each member of a list because we will mix object-oriented
    programming with functional programming in Java 9.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following lines declare the `makeMembersDance` method that calls the `danceAlone`
    method for each member of the `members` list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines declare the `makeMembersSingALyric` method that receives
    a `lyricString` and calls the `singALyric` method with the received `lyric` as
    an argument for each member of the `members` list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Notice that methods are not marked as final, and therefore, we will be able
    to override these methods in a future subclass.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the following lines declare the `declareNewPartyLeader` method that
    can throw an `InsufficientMembersException`. As it happened with the `removeMember`
    method, the `throws` keyword after the method arguments followed by `InsufficientMembersException`
    indicates that the method can throw an `InsufficientMembersException` exception.
    In case we have just one member in the members list, the code throws an `InsufficientMembersException`
    exception and uses the value returned from `members.size()` to create the instance
    of the class that inherits from `Exception`. Remember that this exception class
    uses this value to initialize a field and the code that calls this method will
    be able to retrieve the number of members that is insufficient. If we have at
    least two members, the code generates a new pseudo-random party leader that is
    different from the existing one. The code uses `ThreadLocalRandom.current().nextInt`
    to generate a pseudo-random `int` number within a range. The code calls the `speak`
    method for the actual leader to make it explain to the other party members that
    they have a new party leader. The code calls the `danceWith` method for the new
    leader with the previous party leader as an argument. If the result of calling
    the `newPartyLeader.compareTo` method with the previous party leader as an argument
    returns less than `0`, it means that the new party leader is younger than the
    previous one and the code calls the `newPartyLeader.danceAlone` method. Finally,
    the code sets the new value to the `partyLeader` field.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Using a generic class for multiple compatible types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can create instances of the `Party<T>` class by replacing the `T` generic
    type parameter with any type name that adapts to the type constraints specified
    in the declaration of the `Party<T>` class. So far, we have three concrete classes
    that implement both the `Sociable` and `Comparable<Sociable>` interfaces: `SocialLion`,
    `SocialParrot`, and `SocialSwan`. Hence, we can use `SocialLion` to create an
    instance of `Party<SocialLion>`, that is, a `Party` of `SocialLion`. We take advantage
    of type inference and we use the previously explained diamond notation. This way,
    we will create a party of lions, and `Simba` is the party leader. The code file
    for the sample is included in the `java_9_oop_chapter_10_01` folder, in the `example10_01.java`
    file.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The `lionsParty` instance will only accept a `SocialLion` instance for all the
    arguments in which the class definition uses the generic type parameter named
    `T`. The following lines add the previously created three instances of `SocialLion`
    to the lions' party by calling the `addMember` method for each instance. The code
    file for the sample is included in the `java_9_oop_chapter_10_01` folder, in the
    `example10_01.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The following lines call the `makeMembersAct` method to make all the lions act,
    call the `makeMembersDance` method to make all the lions dance, use the `removeMember`
    method to remove a member that isn't the party leader, use the `declareNewPartyLeader`
    method to declare a new leader, and finally call the `makeMembersSingALyric` method
    to make all the lions sing. We will add the `try` keyword before the calls to
    `removeMember` and `declareNewPartyLeader` because these methods can throw exceptions.
    In this case, we don't check the result returned by `removeMember`. The code file
    for the sample is included in the `java_9_oop_chapter_10_01` folder, in the `example10_01.java`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines show the output after we run the preceding code snippets
    in JShell. However, we must take into account that there is a pseudo-random selection
    of the new party leader, and therefore, the results will vary in each execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We can use `SocialParrot` to create an instance of `Party<SocialParrot>`, that
    is, a `Party` of `SocialParrot`. We use the previously explained diamond notation.
    This way, we will create a party of parrots, and `Rio` is the party leader. The
    code file for the sample is included in the `java_9_oop_chapter_10_01` folder,
    in the `example10_01.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The `parrotsParty` instance will only accept a `SocialParrot` instance for all
    the arguments in which the class definition uses the generic type parameter named
    `T`. The following lines add the previously created three instances of `SocialParrot`
    to the parrots' party by calling the `addMember` method for each instance. The
    code file for the sample is included in the `java_9_oop_chapter_10_01` folder,
    in the `example10_01.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The following lines call the `makeMembersDance` method to make all the parrots
    dance, use the `removeMember` method to remove a member that isn't the party leader,
    use the `declareNewPartyLeader` method to declare a new leader, and finally call
    the `makeMembersSingALyric` method to make all the parrots sing. The code file
    for the sample is included in the `java_9_oop_chapter_10_01` folder, in the `example10_01.java`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines show the output after we run the preceding code snippets
    in JShell. Again, we must take into account that there is a pseudo-random selection
    of the new party leader, and therefore, the results will vary in each execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The following lines will fail to compile because we use incompatible types.
    First, we try to add a `SocialParrot` instance, `rio`, to the `Party<SocialLion>`,
    `lionsParty`. Then, we try to add a `SocialLion` instance, `simba`, to the `Party<SocialParrot>`,
    `parrotsParty`. Both lines will fail to compile and JShell will display a message
    indicating that the types are incompatible and they cannot be converted to the
    necessary type required by each party. The code file for the sample is included
    in the `java_9_oop_chapter_10_01` folder, in the `example10_02.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the errors displayed in JShell when we try to
    execute the previous lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using a generic class for multiple compatible types](img/00090.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We can use `SocialSwan` to create an instance of `Party<SocialSwan>`, that is,
    a `Party` of `SocialSwan`. This way, we will create a party of swans, and `Kevin`
    is the party leader. The code file for the sample is included in the `java_9_oop_chapter_10_01`
    folder, in the `example10_03.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The `swansParty` instance will only accept a `SocialSwan` instance for all the
    arguments in which the class definition uses the generic type parameter named
    `T`. The following lines add the previously created two instances of `SocialSwan`
    to the swans' party by calling the `addMember` method for each instance. The code
    file for the sample is included in the `java_9_oop_chapter_10_01` folder, in the
    `example10_03.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The following lines call the `makeMembersDance` method to make all the parrots
    dance, use the `removeMember` method to try to remove the party leader, use the
    `declareNewPartyLeader` method to declare a new leader, and finally call the `makeMembersSingALyric`
    method to make all the swans sing. The code file for the sample is included in
    the `java_9_oop_chapter_10_01` folder, in the `example10_03.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines show the output after we run the preceding code snippets
    in JShell. Again, we must take into account that there is a pseudo-random selection
    of the new party leader, and therefore, the results will vary in each execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Test your knowledge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `public class Party<T extends Sociable & Comparable<Sociable>>` line means:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The generic type constraint specifies that `T` must implement either the `Sociable`
    or `Comparable<Sociable>` interfaces.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The generic type constraint specifies that `T` must implement both the `Sociable`
    and `Comparable<Sociable>` interfaces.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The class is a subclass of both the `Sociable` and `Comparable<Sociable>` classes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Which of the following lines is equivalent to `List<SocialLion> lionsList =
    new ArrayList<SocialLion>();` in Java 9:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`List<SocialLion> lionsList = new ArrayList();`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`List<SocialLion> lionsList = new ArrayList<>();`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`var lionsList = new ArrayList<SocialLion>();`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Which of the following lines uses the diamond notation to take advantage of
    Java 9 type inference:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`List<SocialLion> lionsList = new ArrayList<>();`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`List<SocialLion> lionsList = new ArrayList();`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`var lionsList = new ArrayList<SocialLion>();`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Java 9 allows us to work with parametric polymorphism through:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Duck typing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rabbit typing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generics.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Which of the following code snippets declares a class whose generic type constraint
    specifies that `T` must implement both the `Sociable` and `Convertible` interfaces:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`public class Game<T extends Sociable & Convertible>`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`public class Game<T: where T is Sociable & Convertible>`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`public class Game<T extends Sociable> where T: Convertible`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned to maximize code reuse by writing code capable
    of working with objects of different types, that is, instances of classes that
    implement specific interfaces or whose class hierarchies include specific superclasses.
    We worked with interfaces, generics, and constrained generic types.
  prefs: []
  type: TYPE_NORMAL
- en: We created classes capable of working with one constrained generic type. We
    combined class inheritance and interfaces to maximize the reusability of code.
    We could make classes work with many different types and we were able to code
    the behavior of a party that could then be reused to create parties of lions,
    parrots, and swans.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have learned the basics about parametric polymorphism and generics,
    we are ready to work with more advanced scenarios that maximize code reuse with
    generics in Java 9, which is the topic we are going to discuss in the next chapter.
  prefs: []
  type: TYPE_NORMAL
