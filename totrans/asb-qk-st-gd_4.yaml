- en: Ansible Modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to master Ansible playbooks, we need to learn about modules and how
    useful they can be. Ansible modules are essential components that define the actions
    performed by every playbook. Each module is set up to enable a task to be performed. They
    are designed to function smoothly with no overheads because all their dependencies
    and requirements are covered. Ansible modules enable the user to manage several
    operating systems, services, applications, databases, packages managers, virtualized
    infrastructure datastores, and cloud environments. In this chapter, we will cover
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Overview of the use of Ansible modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ansible Linux modules and their varieties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing Ansible Windows modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A common constructor: Ansible network modules'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Ansible cloud modules of the big three cloud providers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ansible modules overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When installing Ansible, the user will also receive a very handy set of modules.
    This set is called a module library. It is a list of predefined functions and
    actions to be called when using Ansible, either via ad hoc commands or by running
    playbooks. An Ansible user is not limited to the predefined Ansible modules; they
    can easily write their own using Python and JSON scripting. The modules that come
    with the installation of Ansible might be referred to as task plugins or library
    plugins, but do not mistake these for the actual Ansible plugins, which are the
    scripts that allow Ansible to interact with other systems, a subject for another
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Ansible module library comes with its own machine library. Use the `ansible-doc` command
    followed by the name of the module to find out more about how it is used and what
    its output variables are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'To list all the available modules, use the `-l` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Using modules is very simple. You need to identify the name of the module, then input
    its arguments if required. Not all modules require argument input (the ping module,
    for example, doesn't require this) but most do. For other modules, inputting arguments
    is optional and might allow you to personalize the action, such as in the case
    of the Windows reboot module. As an example, let's look at executing modules in
    both ad hoc and playbook mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ad hoc versus playbook: the ping module'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As discussed previously, Ansible ad hoc can be used for a quick check, such
    as running a `ping` command to check if the hosts are up and running. The command
    should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the command will look similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/11804c49-8b16-4132-bec9-e4a2660d4cbe.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `ping` module can also be used in the playbook as part of the bigger script,
    where the result of the `ping` can be piped to be the condition for another action.
    The playbook code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this code will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c2791629-6003-4de6-a25d-0447e964012a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Ad hoc versus playbook: the win_reboot module'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The ad hoc command can be simply executed as shown in the following two examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting output of either command will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/cf8a919f-c1b1-4375-b052-9363b380e35c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This playbook file contains two ways of restarting hosts using the same module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting playbook output will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/d4910b37-1e9f-48df-a472-074a56dc2680.png)'
  prefs: []
  type: TYPE_IMG
- en: 'ad-hoc versus playbook: the copy module'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Ansible `copy` module can be used in ad hoc mode to quickly run a copy
    job:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this command should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/5656b15f-31ec-45c1-b6a2-300fea96440d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Alternatively, this can be used in a playbook with various options for a personalized
    result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Ansible module return values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Return values are the key feature for monitoring and managing task execution.
    An administrator can determine the status of each action and run other tasks accordingly,
    either to fix, improve, or follow up on the bigger job. Ansible modules are fitted
    with a variety of return values. Each module will have the common values and some
    extra specific ones for the role performed by the module. These extra return values
    can be used for numerous functionalities. In Ansible, most return values are used
    as input for playbook conditions and loops. This scripting allows the pipelining
    of actions and tasks to achieve an automated configuration management. Ansible
    basically collects all the useful output data about the action performed by the
    module and arranges it into variables presented as return values.
  prefs: []
  type: TYPE_NORMAL
- en: There is no need to learn all the return values of these modules; you can easily
    get very good documentation about each module using the `ansible-doc` command.
    Alternatively, consult the official Ansible documentation using `module index`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As for the most common return values, we can identify the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`stdout or stdout_lines`: This is the variable that contains the standard output
    of commands executed using an execution module such as `raw`, `command`, `shell`,
    or `win_shell`. The `stdout_lines` have the same value and string as `stdout`
    but they have a more organized output—a human-readable text divided into lines.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stderr` or `stderr_lines`: This has the same output source as `stdout`, but
    this is the error message output. If the command executed returns an error message,
    it will be stored in this variable. The `stderr_lines` also have the same output
    string as `stderr` but are more organized into lines.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`changed`: This is the return value that indicates the status of the task or
    action if the task has made a change to the target host. It will contain a Boolean
    value of `True` or `False`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`failed`: This is another status update return value that indicates whether
    the task or action has failed or not. It is also a Boolean value that can be either
    `True` or `False`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`skipped`: This is another status return value that indicates whether the task
    has been skipped. This occurs when a task has been triggered by a playbook condition
    and the condition was not met. Like the other status return values, it is a Boolean
    variable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rc`: This stands for **return code.** It contains the return code generated
    by the command that is executed by the command execution modules.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`results`: This a value that does not exist in a task unless it has a loop
    in it. It should contain the list of the normal module `result` per item used
    to loop on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`invocation`: This is a value that contains the method detailing how the module
    was invoked.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`backup_file`: This is a value that gets filled when a module has the specific
    `backup=no|yes` option. It states the location where the backup file has been
    created.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`msg`: This is a value containing the message that gets generated by the module
    to the Ansible user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The common values get collected during the execution of the task using a register,
    and then are either called for by the playbook condition functions or just printed
    using a debugger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This playbook will have the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/e34e1ccb-dc74-4672-a8b0-e1e4407b9f99.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Using the debugger, we can easily specify that we want one or all of the return
    values to be printed. The playbook task should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Ansible also collects some extra values to be used for internal Ansible functionalities.
    These values are `ansible_facts`, `exception`, `warning`, and `deprecations`.
    They can be added by some modules to be later removed from the register variables
    and collected by Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible Linux modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will start by exploring the Linux modules. These are a selection of the most
    commonly used modules to manage the operating systems, packages, applications,
    and services running on the Linux environment. We will be covering the two big
    Linux families, Debian and Red Hat. In this section, we will give a brief overview
    of the module and its useful functionalities and features. We will also look at
    a sample of a playbook of one of the interesting uses of this module.
  prefs: []
  type: TYPE_NORMAL
- en: We will not be covering all of the available modules that are supported in the
    Ansible releases. You can find full documentation for these either by running
    the ansible-doc command or on the official Ansible documentation in the modules
    index section. In this book, we will try to cover some of the community and galaxy
    modules that are needed to perform some tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Some modules require some specific technologies to be installed on the remote
    hosts. Most of those requirements are usually preinstalled as basic system utilities,
    while you can work around others by using another tool that can do a similar job.
    For example, when you are using the `apt` module, the hosts are required to have
    `aptitude` installed on the remote Debian. Ansible will use `apt-get` to execute
    the job with a warning message to the user stating the unavailability of aptitude.
    In case the requirements are not met, Ansible will be sure to inform the user.
  prefs: []
  type: TYPE_NORMAL
- en: Before using a new module, be sure to read its documentation carefully and check
    if all its requirements have been met, to be on the safe side.
  prefs: []
  type: TYPE_NORMAL
- en: Linux system modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following is a list of the most useful Ansible modules for managing a Linux
    system.
  prefs: []
  type: TYPE_NORMAL
- en: The user management module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As suggested by its name, this module is for user management on a Linux system.
    As an example, we will make a playbook that creates a system user named `install`
    to be used later to manage the remote machine. The playbook script is as follows
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'You can always add `-v` or `-vvv` if you want extra output when running a playbook.
    The following screenshot shows the output of a normal run and one with the `-v`
    option:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a9b5b82c-7bc8-4d3b-8021-f67c12025d69.png)'
  prefs: []
  type: TYPE_IMG
- en: The same module can also be used to remove the user, either by changing their
    state to absent or disabling them by changing their shell to `/bin/nologin`. For
    some clustered environments, some users shared by the systems must have the same
    UID to be able to run tasks via the jobs handlers. The `uid` option can allow
    a particular user to have a selection of specific UIDs when creating hosts, although
    this is not recommended.
  prefs: []
  type: TYPE_NORMAL
- en: 'The modules have many special return values, which can be collected for pipelining
    with other modules. The most useful modules are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`home`: Shows the home directory for the user'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ssh_public_key`: Allows the key print to be put into a file for multiple purposes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`uid`: Shows the UID of the newly created user'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The group management module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The group module has the same input types as the user module, but it affects
    the host groups. It is a basic module used to create, modify, and delete groups.
    It requires three basic commands for group management to be available: `groupdadd`,
    `groupdell`, and `groupmod`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It is very straightforward to use. A playbook script should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The hostname module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is another simple module that does the simple job of changing a hostname.
    To make this module more exciting, we will use some of the playbook features with
    it. This module takes one input, the new hostname, and changes the hostname of
    the remote host. We can use the playbook predefined variable, `{{ inventory_hostname
    }}`. This variable calls the hostname for the Ansible inventory and uses it with
    the playbook.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to change the inventory file to look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we use the following playbook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'After executing the playbook, you can simply test it out using an ad hoc Ansible
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The result should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/bd46debc-d9c1-446f-9208-63c539a7d49e.png)'
  prefs: []
  type: TYPE_IMG
- en: The sysctl control module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a module to manage the `sysctl` attributes. As this module can change
    some of the kernel behaviours, let's make sure we keep it safe. We are going to
    do a configuration to make the Linux server act as a gateway. We will not be covering
    "IPtables" rules in depth in this section. We are going to use a generic sample
    configuration and try to apply it via the `sysctl` module.
  prefs: []
  type: TYPE_NORMAL
- en: 'The playbook to run the module should contain the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: A reload option is needed when the task is required to run `sysctl -p` after
    the change has been made. This task, with the right firewall rules set, will enable
    this host to route a packet from one network interface to the other.
  prefs: []
  type: TYPE_NORMAL
- en: The service management module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This enables Linux system service management: starting, stopping, reloading,
    restarting, and enabling its system boot start. As an example, we will make sure
    that all hosts have `ntp` (that is, **network time service**) running and enabled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The systemd module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For more advanced service management, we can use `systemd` as an alternative
    to service. The `systemd` module should be able to manage services on all Linux
    operating systems because it has the advantage of having a status special return
    value containing a lot of useful service data. An example playbook of how to use
    it is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The playbook output should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/0d96f8ad-ebf0-4a6b-91fb-0f21b9af94c5.png)'
  prefs: []
  type: TYPE_IMG
- en: The kernel blacklist management module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This module allows you to manage the kernel blacklist of modules and drivers,
    which are the drivers and libraries to be excluded from the kernel devices driver
    initialization on the system startup. For our sample playbook, we will perform
    one of the most common blacklisting actions when using Nvidia GPUs—blacklisting
    the `nouveau` driver:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The cron job editing module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `cron` module is a similar tool to the `at` command, but it provides you
    with more timing options for the execution of the task as the `cron` module allows
    you to manage both `cron.d` and `crontab`. This module allows the creation and
    deletion of crontab entries and the creation of environmental variables. As for
    the playbook example, we will create `cron job` that makes sure that the shared
    folder contents have the correct permissions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This module can also be handy when working with an environmental variable,
    such as `PATH` or `HOME`, for a crontab entry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The SSH authorized keys management module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This module manages an SSH authorized key of a specific user account in a Linux
    host. Using a playbook, we will set up a new authorized key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This module does support many special return values. They can be used like the
    others to collect key data about the hosts.
  prefs: []
  type: TYPE_NORMAL
- en: The Git usage module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This module helps to deploy a tool or configuration files from a Git repository.
    This module requires the `git` tool to be installed on the remote host to work
    properly. As a playbook, we will clone the latest version of Ansible that is available
    on GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The execution of this playbook should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/131e42ad-6ef4-42ba-9852-9ab73b796ee7.png)'
  prefs: []
  type: TYPE_IMG
- en: The `git` module does support some special return values that help you to monitor
    the status of the project.
  prefs: []
  type: TYPE_NORMAL
- en: The SELinux control module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: On the Red Hat environment, SELinux can be a pain to manage on one machine,
    let alone on a series of hosts. This Ansible module helps its user with the configuration
    of the SELinux mode and policy.
  prefs: []
  type: TYPE_NORMAL
- en: This module, along with some others, may require a reboot after performing the
    task. Ansible will always let the user know if this is the case. Some advanced
    modules may have an integrated option that initiates a reboot automatically if
    the host needs it.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a quick playbook sample, we will ask Ansible to make SELinux permissive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This module requires the `libselinux-python` library to be installed on the
    remote hosts to work properly. This module also has its own special return values
    that can be used as input for handlers or other related modules.
  prefs: []
  type: TYPE_NORMAL
- en: Linux commands modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to address the tasks that have particularly complicated
    Linux commands, or where we don't want to search for a module, or where you want
    to use your own technique. Ansible offers a list of command execution modules
    to help you send a command to the remote hosts. The way you want to manage your
    environment is up to you; Ansible is just a tool to make your work more efficient.
  prefs: []
  type: TYPE_NORMAL
- en: Running the raw command module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Compared to the other command modules, this module is the simplest in command
    line delivery. It basically sends the command as it is via SSH on remote hosts
    with no headers or options. It does not support pipelining or handlers, but it
    works when sending PowerShell commands to a Windows host that is configured to
    be managed by Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: Fact gathering should be disabled when using the `raw` module to bootstrap Python
    onto the machine. In playbook syntax, the `become` option, to chose which user
    is going to run the task, does not work with the `raw` module, so we may need
    to add `sudo` in front of our commands when they require root permission.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple playbook to use this module might be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The command execution module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This module has the same function as the raw command module, but it is more
    optimized. It allows for multiple options and it has the capacity to use its return
    values for other tasks. As an example of a playbook, we will run a command and
    then collect its output for later use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the playbook will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/0061df25-2ae2-40b5-bb4a-c8524e955fb2.png)'
  prefs: []
  type: TYPE_IMG
- en: This module lacks the capacity to understand special environment variables,
    such as `$PATH`, Linux pipelining, and the redirection special characters. If
    this is necessary for your particular use case, use the next module on the list,
    `shell`.
  prefs: []
  type: TYPE_NORMAL
- en: The shell command module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This module is one of the handiest command modules. It not only allows you
    to run a command, it also runs shell scripts and allows you to specify the location
    for the working directory and the bash with which you want to execute the command
    line. By default, this module runs all its remote commands on the `/bin/sh` shell.
    The following playbook provides a good example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Shell also has several return values that are very useful.
  prefs: []
  type: TYPE_NORMAL
- en: The script execution module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is another module to run a shell script on remote nodes. At first, however,
    it transfers the script that is located on the Ansible master to the remote hosts
    before executing them. The module runs the script on the shell environment of
    the remote host, just as if it were run by a local user on the host.
  prefs: []
  type: TYPE_NORMAL
- en: 'This module provides support for running other types of script, such as Python,
    Perl, or Ruby. Take a look at the following example playbook, which shows how
    to use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This module acts like the raw command module. It is also supported on Windows
    remote hosts as it is.
  prefs: []
  type: TYPE_NORMAL
- en: The expect script module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you are familiar with expect scripting, this is a module that is similar,
    but even simpler and on an even bigger scale. It is a way of dealing with interactive
    commands, such as password changing and SSH questions. An example of a playbook
    for changing a user password is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This module requires `pexpect` and `python` to be installed on the remote host.
  prefs: []
  type: TYPE_NORMAL
- en: Linux package modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will show two types of package managers: for operating
    systems and for programming languages.'
  prefs: []
  type: TYPE_NORMAL
- en: Apt package manager module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This module manages packages for the Debian family, including Debian, Ubuntu,
    LinuxMint, KaliLinux, and so on. It requires you to have `aptitude`, `python-apt`,
    and `python3-apt` installed on the remote host to work. It has multiple options
    and functionalities to personalize package installation, removal, upgrade, and
    index update. The following playbook only shows some of its features:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This module has some extra complementary modules to help with extra repositories
    and the keys used for trusted certificates. It also has some special return values.
  prefs: []
  type: TYPE_NORMAL
- en: DNF package manager module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This module controls the new package manager for the Red Hat family, including
    Red Hat, Fedora, CentOS, and Scientific Linux. It helps to install, upgrade, remove,
    and search for packages in the local index. The following playbook shows how it
    can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This module requires you to have `python`, `python-dnf`, and `dnf` itself installed
    on the machine to work properly.
  prefs: []
  type: TYPE_NORMAL
- en: Yum package manager module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Yum is the original Red Hat package manager that is still in use today. It
    also has its own module that manages it. Just like `dnf`, it helps with managing
    packages and group packages. The following playbook shows how to enable a repository
    and then install a tool from it, using this module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Homebrew package manager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Homebrew is the most famous open source package manager for macOS X. This module
    is made to help manage Homebrew packages remotely. A simple playbook can be used
    to remove a package on macOS X:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: PyPI Python package manager module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is our first language package manager and probably the most famous. It
    manages Python packages and libraries. It has a variety of options that accommodate
    various different requirements that are related to Python libraries. To run this
    module we need to make sure that PyPI is installed on the remote hosts. The following
    example playbook will show some of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Cpanm Perl package manager module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Just like the `pip` module, this module manages the Perl package manager, **Comprehensive
    Perl Archive Network** (**CPAN**). It is used in the same way; you can either
    install a library or  package from the default repository or from an archive file
    located on the web or locally. To run this module, we need to make sure that `cpanminus` is
    installed on the remote hosts. This is shown in the example playbook, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Linux file modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Linux file management modules have some shared features that can be found in
    more than one module. You can use one module to perform a task that is composed
    of three different actions. In this section, we will be only talking about the
    major modules with a brief look at those that can perform similar functions as
    well.
  prefs: []
  type: TYPE_NORMAL
- en: File and folder management modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The file module is basically the tool to manage everything to do with files
    and folder organization in terms of creation, removal, symlinks creation, permissions,
    and ownership.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have linked the file module to the **access control list** (**ACL**) module,
    which is a module that only works on permission and ownership of files and folders
    on the Linux environment, to show that some tasks can be combined. This is shown
    in the following playbook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Data distribution modules (copy, unarchive, and get_url)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `copy` module is used to transfer files from the Ansible master to the
    remote hosts or locally from within the remote host. This is followed by `unarchive`,
    which is an archive extractor that then transfers the files to the selected hosts.
    The `get_url` module basically downloads a file from a web location as an HTTP,
    HTTPS, or FTP file. The following playbook shows how each module can be used to
    achieve a goal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The `copy` module supports having a backup option, which is very useful when
    copying configuration files; if there is an error, a user can always revert to
    the original. However, unarchive requires `gtar` and `unzip` to be installed on
    the master machine. All of these modules have special return values that show
    information about the status of the tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Data collection module (fetch)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is the module that reverses the previous module function. This module
    helps gather files from the remote hosts and stores them in the Ansible master
    machine. It can be handy when collecting apps and service logs, user configurations,
    or system related files. As an example, we will try to collect some files from
    each host and organize them in the master Ansible host:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This module is also supported when managing remote Windows hosts. It has a checksum
    validation process that can be deactivated for faster transfer at your own risk.
  prefs: []
  type: TYPE_NORMAL
- en: File editing modules (lineinfile, replace, and blockinfile)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These are the only three modules that you need to perform the great configuration
    file management skills that are had by tools, such as `awk` or `sed`. The `lineinfile` module
    looks for a specific line in a file and replaces it with a predefined regular
    expression. The `replace` module replaces all instances of a specific pattern
    within a file, and `blockinfile` inserts, modifies, or deletes one or several
    lines of text located between two marker lines in a file. We have merged these
    three modules together because they have similar basic functionalities, but each
    one is specialized with regard to how it does things. The following playbook example
    will show each of these modules used to deliver a specific task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Linux networking modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to discover some of the Linux system network management
    modules.
  prefs: []
  type: TYPE_NORMAL
- en: Network interfaces management module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This module is a way to manage the `/etc/network/interfaces` file in Linux
    hosts. Basically, it allows you to create, modify, and remove a network interface
    configuration. This configuration is specific to each identified network interface;
    it does not change non-specified ones. The following playbook shows you how to
    perform a change for a specific interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: If this task gets its return values registered, the user can easily identify
    all the information about the after-change configuration of the interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'For more advanced network management, check out the `nmcli` module. It can
    manage various connection and device types: Ethernet, teams, bonds, and VLANs.'
  prefs: []
  type: TYPE_NORMAL
- en: Firewall UFW management module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is an Ansible management module for the Linux firewall UFW. It basically
    manages ports, protocols, and IPS firewall permissions. An example playbook to
    enable a port on a specific protocol can be written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This module requires `ufw` , as the command-line tool, to be installed on the
    remote hosts.
  prefs: []
  type: TYPE_NORMAL
- en: HAProxy control module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is a module that manages HAProxy servers, commanding them to enable, disable,
    drain, and set weights for backend servers using socket commands. An example of
    a command to disable some HAProxy servers is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Wake-on-LAN trigger module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is a module that turns on hosts that are currently turned off. This feature
    requires Ansible to have already collected facts about the hosts and to be storing
    information about their MAC addresses. The following is a playbook code to show
    how this module can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Linux storage modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible does offer some Linux-specific storage devices and volume management.
  prefs: []
  type: TYPE_NORMAL
- en: File system management module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This module is most handy when dealing with a virtualized infrastructure, but
    it can also be used with a bare metal setup. A disk must already exist in a remote
    host before that host can manage it. In a virtual environment, Ansible or other
    management tools allow you to automatically add disks to the host and then manage
    them using this module. The following is an example of a  playbook for formatting
    a disk using this module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Check out the `lvg` and `lvol` modules for LVM volume and group management.
    LVM can simplify disk management when using a virtualized environment, especially
    when dealing with systems that require the shrinking and expansion of disk space.
  prefs: []
  type: TYPE_NORMAL
- en: Device mounting module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This can be a complimentary module to the file system. It is also very useful
    for managing volume mounting on a specific host system. This module manages `/etc/fstab`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: This module can also handle mounting network drives. This may require you to
    install extra tools such as NFS and SMB client.
  prefs: []
  type: TYPE_NORMAL
- en: Disk partitioning module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This a module that controls the parted tools that help with device partitioning,
    collect their information, or save them as return values. The following example
    playbook shows how to remove a partition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: GlusterFS control module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is an Ansible module used to manage GlusterFS volumes across a cluster
    of hosts. It enables the user to add, delete, start, stop, and tune volumes on
    demand. The following example playbook shows how to create a new volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Ansible Windows modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Moving on from the Linux modules, let's now explore the modules that are used
    by Ansible to administrate Windows desktops and servers. Make sure to have already
    followed the preparation steps to ensure that the Windows hosts are ready to be
    controlled by Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: Windows System Modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start by introducing the modules that control the Windows system and allow
    their users to manage its different aspects.
  prefs: []
  type: TYPE_NORMAL
- en: Windows user and group management module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These two modules are used to manage the users and groups of Windows hosts''
    local machines. The following playbook example shows how to add each mode to Windows
    hosts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Windows register editing module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Ansible offers remote management to the Windows hosts registry using the `win_regedit`
    module. This allows you to create, edit, and remove registry keys and their values.
    The following playbook shows how to disable Windows auto-update via the registry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Windows service management module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This module allows Ansible users to manage and query Windows hosts services.
    The following Ansible playbook shows how we can disable Windows update services
    (not recommended, but handy to know):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: This module has return values that give information about the service status.
  prefs: []
  type: TYPE_NORMAL
- en: Windows updates and feature management modules (win_updates, win_hotfix, and
    win_feature)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Ansible manages Windows updates, hotfixes, and features using three complementary
    modules: `win_updates`, `win_hotfix` and `win_feature`. These modules use system
    default services and tools by commanding them to apply a set of tasks configured
    on a playbook. The following example playbook has three examples on how to use
    each of the modules to install or enable Microsoft tools, fixes, or features:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Special return values get generated by the execution of these modules. These
    are key features to automate the maintenance of Windows hosts.
  prefs: []
  type: TYPE_NORMAL
- en: These three modules need to be run with the credentials of a user who is part
    of a domain or local administrator group.
  prefs: []
  type: TYPE_NORMAL
- en: Windows Wake-on-LAN trigger module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Just like the Linux host''s Wake-on-LAN module, this module will start to shut
    down Windows hosts using their MAC addresses. An example Playbook is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: This module will send a Wake-on-LAN magic packet to the specific MAC addressed.
    Only the hosts who are configured to accept the packet will respond. A BIOS or
    OS configuration to enable Wake-on-LAN is required.
  prefs: []
  type: TYPE_NORMAL
- en: Windows firewall management module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This module interacts with the Windows hosts'' local firewall to configure
    its rules. This is shown by the following playbook, which enables the VNC protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: This module also needs to be executed by a local or domain administrator.
  prefs: []
  type: TYPE_NORMAL
- en: Windows package modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Windows hosts application management can get complicated, compared to Linux
    and all the package managers that unify application installation in a few simple
    commands. Ansible uses its modules to bypass those challenges.
  prefs: []
  type: TYPE_NORMAL
- en: Chocolatey control module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Chocolatey is a third-party package manager for Windows systems. It allows
    its users to install, remove, and update a huge number of Windows applications
    using standard commands. Ansible provides a module that makes sure that Chocolatey
    is installed on the system, then starts using it to install the selected tools
    from its packages gallery ([https://chocolatey.org/packages](https://chocolatey.org/packages)).
    The following is a sample playbook that shows a few multiple usages of the `win_chocolatey`
    module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Windows package manager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is an Ansible module that is used to install and remove packages that
    are MSI or EXE files. It allows you to use a different source for the package,
    either on the local machine, on a network shared drive, or on the web. The following
    example playbook shows you how to install Atom:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: This module replaces old, unstable modules such as `win_msi`.
  prefs: []
  type: TYPE_NORMAL
- en: Windows command modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just like Linux, when there is a need to type your own command and there is
    no module that can simplify the task, a command module can make it easier. Ansible
    offers the following modules that allow you to send specific commands to remote
    Windows hosts.
  prefs: []
  type: TYPE_NORMAL
- en: Windows command modules (win_shell and win_command)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These two Ansible modules are the best way to send any PowerShell or bash commands
    to a Windows hosts. The `win_shell` module is more used for running scripts and
    long or multiline commands, while the command is more for running regular commands
    that may require extra parameters. The following playbook shows an example code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Windows task scheduling module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Windows hosts can be time-managed by scheduling future tasks using this module.
    It is a way to create, edit, and delete Windows-scheduled tasks. The following
    is an example of task scheduling on a playbook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Windows file modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Managing Windows hosts' files and folders is as simple as on a Linux system
    when using Ansible. It offers a set of modules that take care of all management
    needs.
  prefs: []
  type: TYPE_NORMAL
- en: Windows file and folder management module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is a module to create, update, and remove files and folders on remote
    Windows hosts. This sample playbook shows how to manage a file and folder on a
    Windows system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: This module does not change file permissions. To do this, you need to use the
    `win_share` module.
  prefs: []
  type: TYPE_NORMAL
- en: Windows data sharing module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is a complementary module to `win_file`. This module sets modifies and
    removes shared permissions on Windows files and folders. This is a playbook showing
    a sample configuration for a specific folder on remote Windows hosts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: This module is only supported on Windows 8 and Windows 2012 onward.
  prefs: []
  type: TYPE_NORMAL
- en: Windows file editing module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is the Windows version of the Ansible module, `lineinfile`. It basically
    does the same job of changing a specific line if a file is based on a regular
    expression, but it is specifically for Windows hosts. The following is an example
    playbook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Windows data sending modules (win_copy, win_robocopy, and win_get_url)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: These are the modules that are responsible for transferring files to Windows
    remote hosts. Each has its own way to get the files to their destination. The `win_copy` module
    will copy the file either from the local machine or the remote host to a specific
    location in the remote hosts. The `win_robocopy` module works like `rsync` to
    synchronize the contents of two folders within the remote host. It can be very
    handy as a backup solution. The `win_get_url` module gets a URL as input to download
    the files into the specified location.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following playbook shows some example cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Ansible network modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Network device management has never been easier than with Ansible. Having a
    playbook, a unified language for all modules makes the management of proprietary
    network devices very simple and does not require you to learn vendor-specific
    tools and coding languages. Network administration is now part of the automated
    configuration management strategy.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a list of network proprietary devices currently supported by Ansible:
    Arista, Avi Networks, Cisco, Citrix NetScaler, Cumulus, Dell EMC, F5, Huawei,
    Infoblox, Juniper, Nokia, Mellanox, Lenovo, Palo Alto Networks, and Pluribus.
    We will not be able to cover all the modules that control these—this would probably
    require a book of its own!'
  prefs: []
  type: TYPE_NORMAL
- en: Being agentless, Ansible uses SSH and HTTPS to communicate with devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this section, we will only cover the Cisco standard devices. We need to
    create a special inventory for them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: There are other ways to hide clear text passwords from YAML files; we will take
    a look at them, in the coming chapters on Ansible Vault.
  prefs: []
  type: TYPE_NORMAL
- en: Network data transfer modules (net_get and network_put)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These two modules allow for an easier transfer of configuration files between
    the control host and multiple network devices. They can be handy for backup or
    centralized configuration. These modules rely on the functionality of the `scp`
    command to carry out the transfer. An example is shown in the following playbook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Cisco IOS command module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This module helps its users to send commands to a Cisco device running IOS,
    either a router, a switch, an access-point, or firewall. This module also has
    the option of making the task wait for a condition before returning with a timeout.
    The following is an example of a playbook showing command execution on a Cisco
    device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Cisco ISO system configuration module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This module allows its user to modify the IOS running configuration of a Cisco
    device. The following example playbook will show how we can alter some configurations
    of the Cisco switch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Cisco IOS interface management module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This module manages the interface configuration of the Cisco network switches.
    In the following simple playbook, we will configure an interface and enable it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Cisco IOS static route control module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As its name states, this module manages static route configuration on a Cisco
    network device. We will set a static route switch in the following example playbook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Cisco IOS VLAN management module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This module allows the configuration of VLANs on a Cisco switch. This sample
    playbook shows how to add some network interfaces to a VLAN:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Ansible cloud modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible has made managing virtualized and on cloud infrastructures very easy.
    It has over 300 modules that run several APIs designed to cover a variety of cloud
    providers, such as Amazon Web Services, Google Cloud Platform, OpenStack, Microsoft
    Azure, Digital Ocean, and Linode. These modules manage multiple aspects of the
    environment, including the hosts' operating systems, network connectivity, compute
    resources, and hosts provisioning.
  prefs: []
  type: TYPE_NORMAL
- en: When using Ansible modules with a cloud or virtual environment, it is recommended
    that you use a dynamic inventory for better management.
  prefs: []
  type: TYPE_NORMAL
- en: VMware modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible offers a list of modules to enable VMware infrastructure automated management.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to have the `pyVmomi` Python SDK installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: These modules are built to manage the VMware ESX, ESXi, and vCenter server.
    In this section, we will describe some of the most useful modules that are involved
    in managing the VMware infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: 'An inventory file is required to host some of the data centre information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: VMware guest management modules (vmware_guest and vsphere_guest)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This module allows the creation, modification, and removal of virtual machines.
    They also allow status and resource control of the specified virtual machines,
    including power status modification and they complement customization. The following
    playbook example shows how to create a virtual machine based on a template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: The `vsphere_guest` module does the same job as `vmware_guest`, but it is a
    legacy module that is less stable and does not support as many features as `vmare_guest`.
  prefs: []
  type: TYPE_NORMAL
- en: VMware guest snapshot management module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This Ansible module enables automatic snapshot management of virtual machines.
    The following playbook example shows how to take a snapshot on virtual machines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Case sensitivity is very important when dealing with VMware modules, especially
    when dealing with virtual machine snapshots. When calling the snapshot later,
    ensure that its name is exactly the same.
  prefs: []
  type: TYPE_NORMAL
- en: VMware virtual machine shell execution module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following module allows its user to run commands on the virtual machine''s
    operating system via the use of the VMware tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: VMware host power state control module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This module manages the physical equipment of the VMware infrastructure. The
    ESX/ESXi hosts are where the computer resources are stored. This module manages
    the power status of the hosts. It can very handy when scheduling a reboot after
    maintenance, an update, or a fix. The following example playbook shows how this
    module can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Docker modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The recent versions of Ansible have introduced several modules dedicated to
    Docker container management. To be able to use the Docker''s Ansible modules,
    the management hosts should have the following Python packages installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: It is best to use a dynamic inventory when working with Docker containers.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible has recently introduced a new feature to enable building containers
    without the use of Dockerfiles. The `ansible-container` module builds containers
    and orchestrates the deployment via playbooks.
  prefs: []
  type: TYPE_NORMAL
- en: Docker container management module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This module manages the life cycle of a Docker container running on either
    on a local machine or other hosts. The following playbook shows how this module
    works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Docker image management module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This module is useful for container developers. It helps with building, loading,
    pulling, and pushing container images to a repository or archiving a container
    into a tar file. The following playbook example shows some possible tasks that
    can be carried out with this module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Docker login module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This module allows the user to log in to DockerHub or a private repository.
    The following playbook shows how this can be done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Amazon AWS modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible allows automation of your AWS cloud environment, enabling dynamic provisioning
    of instances and smart scalability via the huge number of modules dedicated to
    AWS services. In this section, we will only focus on Amazon AWS EC2\. There is
    a large library of modules to manage other AWS services and services for other
    cloud providers that can be found on the Ansible module index.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a prerequisite, it is highly recommended that you have a dynamic inventory.
    It is also recommended that you store the access and secret keys in `vars_file`
    and possibly protect them using Ansible Vault:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'You are also required to install the `boto` Python library on the controlling
    machine to interact with AWS Services:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: AWS EC2 instance management module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This module allows the creation and termination of AWS EC2 instances. The following
    playbook shows how to create a new AWS EC2 instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: AWS WC2 AMI management module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This module helps register new EC2 AMI images to be used for instance creation later.
    It also allows you to deregister old images when they are no longer needed. The
    following example playbook shows how to register an EC2 AMI image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: AWS EC2 key management module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This module helps with the management of an EC2 key pair. It helps to create
    and remove keys. The following example playbook shows you how to create a key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have tried to show you as many useful modules as possible,
    with examples of daily activities that can be carried out and personal comments
    based on our experience of using them. Further modules and more advanced features
    can be found in the official Ansible documentation. Here, we have only discussed
    modules that are officially supported and maintained; it would be impossible to
    cover all of the modules that are available in the community, on the Ansible Galaxy
    platform, or in the entire range of GitHub projects. If you can think of a task
    that I have not discussed in this chapter, rest assured that somebody out there
    will have a bug or a fix to make it happen. Ansible has one of the biggest communities
    in the open source world; feel free to use it.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to use some of these tools to carry out some
    real automation. We will be mixing and matching various modules in playbooks to
    perform a complex playbook for the usual daily tasks.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Ansible official documentation website: [https://docs.ansible.com/](https://docs.ansible.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ansible Module Index: [https://docs.ansible.com/ansible/latest/modules/list_of_all_modules.html](https://docs.ansible.com/ansible/latest/modules/list_of_all_modules.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Chocolatey Packages Gallery: [https://chocolatey.org/packages](https://chocolatey.org/packages)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
