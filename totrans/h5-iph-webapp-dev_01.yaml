- en: Chapter 1. Application Architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will create a standard architecture for our iPhone application.
    We will base it on the HTML5 Mobile Boilerplate and customize it for the needs
    of the several projects in this book. From marking up our content in HTML5 to
    creating a JavaScript framework, we'll create static pages that help us focus
    on the foundations of iPhone Web Application development.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the HTML5 Mobile Boilerplate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a preliminary architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customizing our framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating semantic markup
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Structuring our stylesheets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Responsive design principles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Establishing our JavaScript architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Routing to a mobile site
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Home screen icons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing our build script
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying our project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the HTML5 Mobile Boilerplate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you begin development, it is always critical to start with a basic framework
    that can be molded to the needs of your project. In many cases, we develop these
    frameworks in-house where we work, or perhaps for our own personal projects. However,
    the open source community has presented us with a great framework we can use in
    our projects—the HTML5 Mobile Boilerplate. This framework is based on the well-known
    HTML5 Boilerplate, and has been optimized for mobile including a lean HTML template;
    the utilization of `Zepto`, and use of tools and helpers optimized for mobile.
  prefs: []
  type: TYPE_NORMAL
- en: Downloading and installing the HTML5 Mobile Boilerplate
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first step we need to take is to download the HTML5 Mobile Boilerplate,
    which is located here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://html5boilerplate.com/mobile/](http://html5boilerplate.com/mobile/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the boilerplate is downloaded, you should see the following structure
    from the unzipped archive file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Downloading and installing the HTML5 Mobile Boilerplate](img/1024_01_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The Preliminary Directory Structure
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to take these files and place them in the directory of your
    choice. For example, I have placed my files in the following directory on my Mac:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/Users/alvincrespo/Sites/html5iphonewebapp`'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we'll want to use a build system that helps us create multiple environments,
    ease the deployment process, and overall make things easier when we want to optimize
    our site for testing and/or production.
  prefs: []
  type: TYPE_NORMAL
- en: According to the documentation for the HTML5 Mobile Boilerplate, there are two
    different types of build system, such as the Node Build script and the Ant Build
    script. In this book, we'll be using the Ant Build script. I would recommend using
    the Ant Build script since it has been around for a while and has the appropriate
    features that I use in my projects, including CSS Split, which will help split
    up the main CSS file that comes with the boilerplate.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating the build script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To download the Ant Build script, go to the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/h5bp/ant-build-script](https://github.com/h5bp/ant-build-script)'
  prefs: []
  type: TYPE_NORMAL
- en: Then, download the zip file by clicking on the **Download as zip** button. When
    you have downloaded the Ant Build script, copy the folder and its contents to
    your project.
  prefs: []
  type: TYPE_NORMAL
- en: Once your Ant Build script directory is fully transferred over to your project,
    rename the directory containing the build script to `build`. At this point, you
    should have your project completely set up for the rest of the applications in
    this book. We will cover how to utilize the build script later on in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our application framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With every project, it's important to create a framework that adjusts to your
    project's needs. It's critical to think about every aspect of the project. From
    the required document to the team's strengths and weaknesses, it's important we
    establish a solid foundation that helps us build and adjust accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying the boilerplate
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ll now modify our boilerplate for the needs of the projects we will be
    building. For simplicity, we''ll remove the following items from the folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CHANGELOG.md`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`crossdomain.xml`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`README.md`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/doc (Directory)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that the directory has been cleaned up, it's time to take a look at some
    of the boilerplate code and customize it for the needs of the projects in this
    book.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing our markup
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, open up the application in your favorite text editor. Once we've opened
    up the application in the editor of our choice, let's look at `index.html`.
  prefs: []
  type: TYPE_NORMAL
- en: The index file needs to be cleaned up in order to focus on iPhone Web Application
    development, and also unused items such as Google Analytics need to be removed.
    So let's remove some code that is not necessary for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'Look for the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Downloading the example code**'
  prefs: []
  type: TYPE_NORMAL
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  prefs: []
  type: TYPE_NORMAL
- en: 'And modify it to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'What we''ve done here is removed detection for IE Mobile. Although this may
    be helpful for other projects, for us it doesn''t really help in creating a fully
    compatible application just for the iPhone. However, we also need to remove an
    `IEMobile` specific meta tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The previous meta tag turns on `cleartype` (a utility that assists with the
    rendering of fonts) for the IE mobile. This isn't necessary for us and is not
    a requirement for our applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''ve removed some unnecessary markup from our page, we can go ahead
    and start enabling features that will enhance our application. Look for the following
    meta tags and enable them, by removing the comments surrounding them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: These directives inform our application that it can run in fullscreen and they
    set the status bar to black.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also remove the following code from the `<head>` of the document:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we''ve removed the previous script, your markup should now look like the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can focus on cleaning up our body. Lucky for us, we only need to remove
    one thing—Google Analytics, since we will not be focusing on tracking for iPhone
    Web Apps.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, find the following code and remove it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The only scripts that you should have on the page should be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we''ve completed the previous steps, our markup should be clean and simple
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: From here, we should examine our stylesheets and scripts for every project and
    optimize it as much as we can prior to beginning a project. However, this boilerplate
    that we will be using has been optimized by the community and continuously enhanced
    with support from many developers, and for our use here, both styles and scripts
    are good to go. If you are curious, I encourage you to look at the `normalize.css`
    file, which contains excellent directives for resetting a page. It would also
    be beneficial to review the `main.css` file that has been enhanced with this boilerplate
    to support mobile devices.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we'll move on to establishing our framework.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing our framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's critical for developers to establish a framework for each project they
    are working on, no matter how small or big the project may be. Of course, your
    framework should adjust to the requirements that the project demands as well.
    In this section, we'll establish a simple framework that we can work with throughout
    the use of this book.
  prefs: []
  type: TYPE_NORMAL
- en: We've gone through and cleaned up the boilerplate for our needs, now we'll go
    through and expand upon the boilerplate to include the files that are critical
    to the applications we will build.
  prefs: []
  type: TYPE_NORMAL
- en: The first application will be based on the HTML5 Video specification ([http://dev.w3.org/html5/spec-author-view/video.html](http://dev.w3.org/html5/spec-author-view/video.html)).
    In that application we'll create a specific functionality for our video player
    that includes play, pause, and fullscreen functionalities. So let's create a directory
    specific to this application; we'll call this directory `video`.
  prefs: []
  type: TYPE_NORMAL
- en: In this directory, we'll create an `index.html` file and copy the contents from
    the homepage of the `index.html` file.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our video section created, let's create the `video.css` file
    inside of our `css` directory.
  prefs: []
  type: TYPE_NORMAL
- en: Then, create an `App` directory within our `/js` folder. Within the `/js/App`
    directory, let's create an `App.js` file. Later, we'll explain in detail what
    this file is, but for now it will be our main application namespace that will
    essentially encapsulate global functionality for our application.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, let's create an `App.Video.js` file that will contain our video application
    functionality within the `/js/App` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will now repeat the previous steps for each of our applications; including
    Video, Audio, Touch, Forms, Location, Single Page, and Offline. In the end, your
    directory structure should have the following new directories and files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: At this point, we should fix the references to our dependencies, such as our
    JavaScript and stylesheet. So let's open up `/video/index.html`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s modify the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Change the previous markup to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that we add `../` to each dependency. This is essentially telling the page
    to go up one level and retrieve the appropriate files. We also need to do this
    for the apple-touch-icon-precomposed links, shortcut icon, and the scripts at
    the bottom of the page.
  prefs: []
  type: TYPE_NORMAL
- en: Our framework is now almost complete, except that they aren't connected yet.
    So now that we've got everything organized, let's start hooking up everything
    to one another. It won't look pretty, but at least it will be working and moving
    towards a fully functional application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the main `index.html` file, `/ourapp/index.html`. Once we''ve
    opened up the main `index.html` file, let''s create a basic site structure inside
    our `<body>` element. We''ll give it a class of `"site-wrapper"` and put it right
    below the comment `Add your site or application content here`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Within the wrapper containing our site, let''s use the new HTML5 `<nav>` element
    to semantically describe the main navigation bar that will exist across all our
    apps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Nothing too special yet, but now we''ll go ahead and use the unordered list
    element and create a navigation bar with no styling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'If we copy the code that we have created in `/video/index.html` and test the
    page, you see that it will not work correctly. For all subdirectories, like video
    and audio, we''ll need to change the relative path from `./` to `../` so that
    we can go up one folder. With this in mind, the `nav` element would look like
    the following within the other applications:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can copy the navigation from `/video/index.html` to the rest of the
    application files or to the `index.html` files we created previously. Once this
    is done, we will have a single site that now connects well with each other.
  prefs: []
  type: TYPE_NORMAL
- en: Believe it or not, we have a very simple website going on here. Our pages are
    set up with basic markup and general styles. At this point, we need a navigation
    that brings our pages together. However, we've barely touched on some important
    aspects, including semantic markup for applications, which we'll discuss next.
  prefs: []
  type: TYPE_NORMAL
- en: Creating semantic markup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Semantic markup is important for several reasons, including search engine optimization,
    creating maintainable architectures, making code easily understandable, and meeting
    accessibility requirements. However, you should be familiar with structuring your
    page with markup that is related to your content. There are new elements within
    the HTML5 specification that help to ease this process, including the `<header>`,
    `<nav>`, `<footer>`, `<section>`, `<article>`, and `<aside>` elements. Each one
    of these elements helps describe the aspects of a page and easily identifies components
    of your application. In this section, let's structure our applications, beginning
    with our Video application.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the header
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, let's start by giving our main index page a title and a header that describes
    the page we are on. Let's open the main `index.html` file in our application at
    `/index.html`.
  prefs: []
  type: TYPE_NORMAL
- en: Find the `<title>` tag and enter it in `iPhone Web Application Development –
    Home`. Note that we use a hyphen here. This is important since it makes it easier
    for users to scan the content of the page and helps with the ranking for specific
    keywords.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now have the following `<title>` in the `<head>` tag of your document:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<title>iPhone Web Application Development - Home</title>`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we want the content of the page to reflect the title as well and alert
    the user of their progress on our site. What we want to do is create a header
    that describes the section they are on. In order to achieve this, let''s place
    the following code before the navigation we created previously. Your code should
    then look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `<hgroup>` element is used to group multiple headers for a section. The
    rank of the headers is based on `<h1>` to `<h6>,` with `<h1>` being the highest
    rank and `<h6>` the lowest. Therefore, the highlighted text places our `<h1>`
    content higher than our `<h2>`.
  prefs: []
  type: TYPE_NORMAL
- en: Also note that we are not using the `<section>` element yet. However, this page
    does validate using the W3C Markup Validation Service ([http://validator.w3.org/](http://validator.w3.org/)).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can further describe the page by wrapping our `<hgroup>` and `<nav>` elements
    within a `<header>` element to give the page an introductory aid. Once you do
    this, you should have the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: With the previous code, we have finally given our page some structure. We are
    describing our page with a main header for the site and a sub header for the page.
    We have also given the page a navigation menu, allowing the user to navigate across
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the footer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now let''s add a `<footer>` that contains the name of this book with its copyright
    date:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous code will basically relate to the nearest sectioning ancestor.
    Thus the footer will relate to the content before it, which we will fill in a
    bit later. At this point, your content should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Clearing up section
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You may be wondering why we are not using the `<section>` element right away
    for the `<div>` element that contains both the `<header>` and `<footer>` element.
    In this case, it's not necessarily useful since we are not creating a page where
    the element's contents would be listed in an outline. This is the suggestion by
    the W3C and is something every developer should be aware of when deciding which
    element to use, `<div>` or `<section>`. In the end, it comes down to the content
    itself and the outline the team wishes to create.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a basic structure for our pages, we can go ahead and do the
    same for the rest of our applications. This will be done for you in the code provided
    with this book in case you wish to review a final version.
  prefs: []
  type: TYPE_NORMAL
- en: With this in mind, we will move forward with our application development, making
    sure that we use semantic code when and where it makes sense.
  prefs: []
  type: TYPE_NORMAL
- en: Structuring our stylesheets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Styling is extremely important in any application we build, especially since
    it is the first aspect of any application the user experiences. In this section,
    we'll start structuring our styles appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: Global styling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, let's open our `main.css` file, located in the `CSS` directory. When
    you open this file, you'll see default boilerplate styles. At this point, let's
    skip through these to create our own styles. We'll review those styles as we continue
    to develop our applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Find the following line in `main.css`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: It's after this comment that we want to include the global styles for the semantic
    code we wrote previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by defining the global site styling such as the background color:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In the previous styling, we are making some stylistic choices like setting our
    background color and some borders. The important part here is that the width is
    defined at 100 percent for the HTML element. This will basically allow us to extend
    to 100 percent of the width of the phone for all our content.
  prefs: []
  type: TYPE_NORMAL
- en: Defining our global fonts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We then have to define overall fonts on the page. This will be basic for now
    and can continue to extend as design as per our application, but for now take
    a look at the following styles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code, you can see that we are working from a higher level down,
    the essential understanding of Cascading Style Sheets. We first define our headers,
    anchors, and paragraphs by using a specific font family and having no decoration.
  prefs: []
  type: TYPE_NORMAL
- en: As we work down the previous styles, we start to define each one more specifically,
    with headers having no padding or margins and a specific color. Then, when we
    go down further, we can see that each type of header has a specific font size
    and we do the same for paragraphs and anchors.
  prefs: []
  type: TYPE_NORMAL
- en: Our page layout
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once we''ve defined some of our fonts and site styling, we include some basic
    layout information for the `<div>` element containing our content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Since our element automatically scales to 100 percent of the width of the screen,
    we tell the content to have a padding of `5px` at the top, `10px` at the left
    and right, and `10px` on the bottom. Alternatively, we could have written the
    following styles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The former is known as a shorthand property setting and is considered best practice.
  prefs: []
  type: TYPE_NORMAL
- en: Using content with :before and :after
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since we also want to make sure our second header is differentiated in some
    form, we can use a CSS3 pseudo class selector and property to define the before
    and after content, as following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Keep in mind that the `:before` and `:after` pseudo selectors are supported
    in Safari 3.2 and above.
  prefs: []
  type: TYPE_NORMAL
- en: The previous selector targets the `<h2>` elements within the `<hgroup>` element
    and appends the content we have defined in the property before and after it, as
    per the `:before` and `:after` pseudo class selector.
  prefs: []
  type: TYPE_NORMAL
- en: Styling our navigation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Next, let's style our navigation to look and feel a bit more useable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Here we remove the padding off the `<ul>` element and then remove the default
    styling option from each list element. Finally, we make sure each anchor is displayed
    correctly by setting the font size to `12px` and add padding to the top and bottom
    of each anchor to allow for easy selection on the iPhone.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we'll add some styling to our footer.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Very simply, we're aligning the paragraph within the footer to center. Since
    we've defined the default styles for our paragraph in our fonts section, the styling
    gets picked.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the previous styles are applied properly, your result should be similar
    to the following display:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Styling our navigation](img/1024_01_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Responsive design principles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Responsive design is the key to our mobile applications. Given the fact that
    many mobile experiences now surpass those viewed on desktop, it is essential we
    create applications that fit our evolving technological landscape. Lucky for us,
    the HTML5 Mobile Boilerplate comes with preliminary styles that we can modify.
  prefs: []
  type: TYPE_NORMAL
- en: Media queries to the rescue
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, let's open up our `main.css` file in our `css` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, scroll down to the bottom of the file and you should see the following
    styling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Although this styling gets us off the ground, for iPhone development, we need
    some more customization. The first media query is specific for tablet devices,
    and the second media query helps us by targeting devices with higher resolution,
    such as the iPhone 4.
  prefs: []
  type: TYPE_NORMAL
- en: 'What we want to do is make this a bit simpler. Since we are only targeting
    iPhones, this is what we can replace the previous code with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The previous code will target both the iPhone 4 and 5\. We specifically target
    these two devices by checking the `–webkit-min-device-pixel-ratio` property on
    the device, and if it is true it means we can serve high definition graphics.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another aspect we want to check is our viewport settings in the `index.html`
    pages we''ve set up. Luckily, we cleaned this up earlier and it should have the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The previous code snippet will basically resize our content based on the width
    of the device.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we should be set for implementing responsive styling later on
    in our applications. Now that our styling is set for our applications and is general
    enough to expand upon, let's start adding the framework behind the scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Responsive images
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Images are an extremely important part of any application. It helps showcase
    the features of a product and exemplifies information you want the user to understand.
    However, today's varying amount of devices require content to respond correctly.
    On top of that, we need to be able to deliver content that is appropriate for
    the experience, meaning we need to tailor to higher resolution devices so that
    the highest quality content reaches that audience.
  prefs: []
  type: TYPE_NORMAL
- en: There are multiple techniques for delivering the appropriate content. However,
    the one you choose depends on the requirements of your project. In this part,
    we'll review the traditional responsive web design principle of resizing an image
    according to its content and/or container.
  prefs: []
  type: TYPE_NORMAL
- en: Fluid images
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this technique, the developer sets all the images to a maximum width of 100
    percent. We then define the container of the image to adjust accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Fluid width images
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To achieve full width images, we can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The markup is pretty simple, we essentially wrap an image into an element that
    extends the full width of what we need. In this case, the body will extend 100
    percent in width.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we''ll define the style of the image as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: With this simple CSS declaration, we are telling our images to have their maximum
    width set to 100 percent of the containing content. This will automatically resize
    the image as the device's width changes, which is essential if we want to make
    sites responsive to the user's device.
  prefs: []
  type: TYPE_NORMAL
- en: Full width images
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In this case, we want the image to stay its full width, but we also need it
    to cut off accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'To achieve this, we can start by simply creating a `div` with a `class`, in
    this case we add a class of `overflow`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then create the styling that keeps the image at full width and cuts
    off based on the resizing of the content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This is a bit complex, but essentially we attach the image with a `background`
    property. The key here is to make sure we center it using 50 percent. The height
    property is just to show the image, and the width tells the container to be 100
    percent related to its content.
  prefs: []
  type: TYPE_NORMAL
- en: These are the two techniques we use when implementing a traditional responsive
    design. We'll be implementing these techniques much later when we create the video
    and image galleries.
  prefs: []
  type: TYPE_NORMAL
- en: Establishing our JavaScript architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When establishing a JavaScript architecture for your application, there's a
    lot to think about, including possible changes in the near or short term, security,
    ease of use and implementation, documentation, and more. Once we can answer the
    various questions we have, we can then decide on the pattern (module, facade and/or
    mediator, and so on). We also need to know what library or framework would be
    best suited for us, such as `jQuery`, `Zepto.js`, `Backbone.js`, or `Angular.js`.
  prefs: []
  type: TYPE_NORMAL
- en: Luckily for us, we'll be keeping it plain and simple in order to deliver an
    effective application on an iPhone. We'll be utilizing `Zepto.js` as our supported
    library to keep it light. We'll then build upon Zepto by creating a custom JavaScript
    framework that follows a modular pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Structuring our app functionality
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, let's open up our application directory in our preferred text editor.
  prefs: []
  type: TYPE_NORMAL
- en: Next, open the `App.js` file we created earlier within our JavaScript directory.
    The `App.js` file should be completely empty, and it shouldn't be included anywhere.
    This is where we will begin writing our framework.
  prefs: []
  type: TYPE_NORMAL
- en: Namespacing our application
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you're new to JavaScript, you have most likely created most of your code
    in the global scope—perhaps laying out most of your JavaScript inside of script
    tags. Although this may achieve some of your goals, when working on large scale
    applications we want to avoid such practices. Some of the reasons we want to namespace
    our applications is for maintainability, efficiency, and portability.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start out by checking for the `App` namespace; if it exists we''ll use
    what''s there, if it does not exist, then we''ll make an empty object. The following
    code shows how we can achieve this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Immediately Invoked Function Expressions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Great! We are checking for the `App` namespace, now let''s define it. Let''s
    include the following code after the check:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The previous code is doing several things, let's take it one step at a time.
    First, we're setting the `App` namespace to what is known as an **Immediately
    Invoked Function Expression** (**IIFE**). We are essentially creating a function
    that is wrapped by parentheses and immediately invoking it after the closing brace.
  prefs: []
  type: TYPE_NORMAL
- en: When we use the previous technique, or IIFE, we create a new execution context
    or scope. This helps in creating self-containing code that will hopefully, not
    impact other code on the site. It protects us and helps us follow the modular
    pattern efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s extend the previous functionality by passing in the window, document,
    and Zepto objects, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: I know that this may be a bit confusing, but let's take a second to think through
    what we're doing here. First, we are setting some parameters in the function named
    `window`, `document`, and `$`. Then, we are passing in `window`, `document`, and
    `Zepto` when we invoke this method. Remember, we discussed previously that this
    creates a new scope or execution context? Well, this becomes useful to us because
    we can now pass in references to any object that might be global.
  prefs: []
  type: TYPE_NORMAL
- en: How is this useful to us? Well, imagine if you wanted to use the actual `Zepto`
    object over and over again it would be kind of tiring. It's not that difficult
    to type `Zepto`, but you can just namespace it to the dollar sign and keep it
    simple.
  prefs: []
  type: TYPE_NORMAL
- en: Use strict
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Ok, so we''ve got our module setup. Now let''s continue to extend it by including
    the `use strict` directives:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This directive helps us debug our applications by making changes to how JavaScript
    runs, allowing certain errors to be thrown instead of failing silently.
  prefs: []
  type: TYPE_NORMAL
- en: Default options
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Default options are a great way of giving your codebase some extensibility.
    If, for example, we want to customize or cache an element related to the application
    itself then following are the defaults we will use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Let's look at these defaults briefly. First we will create a `defaults` variable,
    which will contain all the defaults for our application(s). Inside it, we have
    defined a default location to be referenced for our application with the `'element'`
    default set to `document.body`—which gets our body element in **DOM** (**Document
    Object Model**). We then create a custom name for our application called `'App'`.
    After this, we create empty objects for our video, audio, touch, form, location,
    and single page applications—to be built later. These empty objects will be extended
    as we continue through the book.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the constructor
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now we need to define our constructor after the `use strict` directive. This
    constructor will take a single parameter named `options`. We will then extend
    the defaults with the parameter `options` and store these settings that can be
    retrieved later, if needed. We will then ultimately cache the `'element'` option
    as a `Zepto` object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Here is what the previous code is accomplishing. First, we are using the keyword
    `this`, which is a reference to what will be, an instance of App itself. Thus,
    `this` is the context of the object itself. Hopefully, this is not too confusing
    and will become clear as we go on. In this case, we are using `this` to define
    an object `options`, which will contain the merged contents of `_defaults` and
    any custom options we pass into the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Note, when we pass an empty object, or `{}` into `$.extend()` as the first parameter,
    we are telling `Zepto` to merge `_defaults` and `options` into a new object, thus
    not overwriting the `_defaults` object. This is useful when we need to do some
    sort of check in the future with the default options.
  prefs: []
  type: TYPE_NORMAL
- en: Once we've defined the options, we then cache the element with `this.$element`,
    where `$` in front of `element` is just for my reference so that I immediately
    recognize a Zepto object versus a plain JavaScript object.
  prefs: []
  type: TYPE_NORMAL
- en: The prototype
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Ok, so we've created our `App` namespace, constructed an IIFE to contain our
    code and defined our constructor. Now, let's start creating some public methods
    that can be accessed to make this a bit modular. But before we do that, let's
    try to understand JavaScript's `prototype`.
  prefs: []
  type: TYPE_NORMAL
- en: Think of `prototype` as a live object that can be accessed, modified, and updated
    whenever and however you like. It can also be thought of as a pointer, because
    JavaScript will continue to go down the chain until it finds the object or it
    will return `undefined`. The prototype is simply a way of extending functionality
    to any non-plain object.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make things a bit more confusing, I mentioned that non-plain objects have
    prototypes. These non-plain objects would be Arrays, Strings, Numbers, and so
    on. A plain object is one where we simple declare an empty object as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The `x` variable does not have a prototype, it is simply there as a key/value
    storage similar to our `_defaults` object.
  prefs: []
  type: TYPE_NORMAL
- en: If you haven't yet understood the prototype, don't worry, it's all about getting
    your hands dirty and getting some experience. So, let's keep moving and getting
    our applications to work.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, your `App.js` file should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Defining public methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now we need to create some public methods by typing into the prototype. We'll
    create a `getDefaults` method, which returns our default options; `toString` will
    overwrite the native `toString` method so we can return a custom name. Then we'll
    create initialization methods to create our other applications, and we'll name
    these `initVideo`, `initAudio`, `initLocalization`, `initTouch`, `initForms`,
    and `initSinglePage` respectively.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point we have several methods we can access publicly when we create
    an instance of `App`. First, let''s review the code we implemented previously,
    specifically this line that gets duplicated, but customized based on the `init`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: For every `init` method we have created a call to the appropriate application,
    for example, `App.Touch`, `App.Forms`, `App.Video`, and so on. Then we pass it
    the options we've defined in the constructor that merged our defaults, for example,
    `this.options.touchOptions`, `this.options.formOptions`, `this.options.videoOptions`,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Note, we haven't created these classes yet for Video, Forms, Touch, and others,
    but we will be creating these soon.
  prefs: []
  type: TYPE_NORMAL
- en: Returning our constructor/function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The last thing we need to do in `App.js` includes returning the constructor.
    So, after all the public methods defined previously, include the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'This bit of code, although simple, is extremely important. Let''s look at a
    stripped down version of `App.js` to better understand what''s going on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: As mentioned earlier, we are creating an `App` namespace that gets set to the
    immediately invoked function expression. When we do this, we create a new scope
    inside this function.
  prefs: []
  type: TYPE_NORMAL
- en: This is why we can have a function or constructor with the name `App` as well
    and have no conflicts or errors. But if you recall, our function `App` is also
    an object, just like everything in JavaScript is an object. This is why, when
    we return our function `App` the `App` namespace gets set to the constructor.
    This then allows you to create multiple instances of `App`, while centralizing
    your code inside of a new scope that is untouchable.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating a custom module template
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, to get the rest of our architecture together we need to open up every other
    `App` file in the JavaScript directory we are in (`/js/App`).
  prefs: []
  type: TYPE_NORMAL
- en: 'When we have these files open, we need to paste the following template, which
    is based on the script we''ve written for `App.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: When we have each template in, we must then change `Module` to the appropriate
    type, that is Video, Audio, Location, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Once you are done with pasting in the section and changing the names, you should
    be all set with the basic JavaScript architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Including our scripts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the last items you will need to take care of is including this basic
    architecture into each `index.html` file. In order to do this, you will need to
    paste the following code at the bottom of the page, right after the inclusion
    of `helper.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: We are basically including each script of the framework. What's important here
    is to always include `App.js` first. The reason for this is that `App.js` creates
    the `App` object and directly modifies it. If you include it after all the other
    scripts, then `App.js` will overwrite the other scripts because it's directly
    affecting the `App` object.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing our framework
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The last item we need to take care of is `main.js`, which includes the initialization
    of our application. We do this by wrapping our code in IIFE and then exposing
    the instance to the `window` object. We do this with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: What we've seen earlier is an IIFE being assigned to an object. Here we don't
    see that because it's not necessary. We just want to make sure our code would
    not affect the rest of the code, which in most cases would not happen because
    of the simplicity of this project. However, as a best practice I try to self contain
    my code in most cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'The difference in the previous code is that we see the initialization of our
    framework here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: We do that by using the `new` keyword, creating a new instance of `App`, and
    then passing it an object, which will be merged into our default options we previously
    wrote.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`querySelector` is a JavaScript method that is attached to the document object.
    This method accepts a selector that we would normally use in CSS, parse DOM, and
    find the appropriate element. In this case, we are telling our application to
    self contain itself to the element with the `site-wrapper` class.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When we finally initialize our application, we then attach `app` to the `window`
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: This basically makes it accessible anywhere in our application by attaching
    it to the `window` object.
  prefs: []
  type: TYPE_NORMAL
- en: We are now done with the framework for our application. Although we don't have
    anything being manipulated on the page, or have attached any events that correlate
    with a user's input, we now have a solid foundation for coding that follows best
    practices, is effective, efficient, and easily accessible.
  prefs: []
  type: TYPE_NORMAL
- en: Routing to a mobile site
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unless we are making a completely responsive site where the styles of the site
    shift based on the dimensions of the device, we most likely will need to do some
    sort of redirect to a mobile friendly version of our site.
  prefs: []
  type: TYPE_NORMAL
- en: Lucky for us, this can easily be achieved in several ways. Although I won't
    cover in detail the ways in which we can achieve this, here are a few techniques
    that might help out when deciding how to move forward.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since this book is geared towards the frontend, routing to a mobile site will
    be briefly covered with PHP and htaccess. We can always perform this process on
    the frontend, but it should be avoided for SEO and page-ranking purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Redirecting via PHP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In PHP we could do the following type of redirect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: In this example we are creating a variable, `$iPhone`, and giving it a Boolean
    value of true or false. If `iPhone` is found in the user agent, which may or may
    not be the best technique to use, then we tell the page to redirect using the
    `header()` method in PHP.
  prefs: []
  type: TYPE_NORMAL
- en: Again, there are other ways of achieving this, but this will get you off the
    ground and running.
  prefs: []
  type: TYPE_NORMAL
- en: Redirecting via htaccess
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can also detect the iPhone and redirect it by putting these instructions
    on the server using an `htaccess` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we are turning on the rewrite engine, creating a rewrite condition
    that checks for the `iPhone` text in the user agent, and then creates a rewrite
    rule if the condition is met.
  prefs: []
  type: TYPE_NORMAL
- en: In essence, if we want to redirect to a mobile version of our site, we need
    to be able to detect the type of device, not its dimensions, and then redirect
    appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: Home screen icons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you're creating an application that should mimic the feeling of being a native
    application, or to simply increase the experience of a web app—it is a good idea
    to have bookmark icons that represent your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the moment, we do support this feature with the following markup in our
    `index.html` files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: These directives inform Safari that we have home screen icons for the appropriate
    devices. Starting from top to bottom we are supporting retina display, first-generation
    iPad and non-Retina iPhone, iPad Touch, and even Android 2.1+.
  prefs: []
  type: TYPE_NORMAL
- en: To put it simply, we have an application that users can bookmark to their home
    screen, allowing them to instantly access the web application from their home
    screen.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing our build script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Earlier, we installed our build script along with the HTML5 Mobile Boilerplate.
    We'll now explore the build script a bit further by customizing it for our purposes.
    We'll need to make sure our styles, scripts, images, and markup are optimized
    for deployment. It will also be necessary for us to set up multiple environments
    to test our application thoroughly.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring our build script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's start by configuring the build script for our needs, this way we'll have
    a custom build script that works for us and gets us going immediately.
  prefs: []
  type: TYPE_NORMAL
- en: Minifying and concatenating scripts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First, let''s make sure our scripts get concatenated and minified. So let''s
    open all our `index.html` files and wrap all our scripts at the bottom of the
    page with the following comments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The previous comments are used by the `ant` task, or build script, to find all
    JavaScript files being used, concatenate, and minify them. The process will also
    use a timestamp for the newly optimized JavaScript file in order to bust caching
    on the server.
  prefs: []
  type: TYPE_NORMAL
- en: Minifying and concatenating styles
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By default, the Ant Build script minifies and concatenates our styles. However,
    if we want to retain comments that identify a particular section of our app, such
    as the video or audio section, then we need to do something that will keep those
    comments.
  prefs: []
  type: TYPE_NORMAL
- en: 'The comments can be used to identify a section, and it can be written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Write the previous comments for each stylesheet.
  prefs: []
  type: TYPE_NORMAL
- en: We then need to add each of our stylesheets to the project properties so that
    each can be minified by the YUI compressor. To do this, we need to open up the
    `project.properties` file located in `/build/config`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then find the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we''ve found that line, let''s add all our `css` files as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Note, that there are no spaces after each file. This is necessary for the build
    script to process.
  prefs: []
  type: TYPE_NORMAL
- en: This is all we need to do at the moment for optimizing our styles.
  prefs: []
  type: TYPE_NORMAL
- en: Creating multiple environments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Typically a project will run on a development, test, and production environment.
    The test environment should be closest to production in terms of configuration,
    allowing us to effectively reproduce any issues that might come up.
  prefs: []
  type: TYPE_NORMAL
- en: In order to build our environments correctly, let's go through the process of
    building our project. First, let's open up `Terminal`, a program that allows you
    to interact with the operating system of any Unix style computer through a command-line
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: Navigating our directories
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once the terminal is up and running, we have to navigate to our project. Here
    are a couple of commands that will help you navigate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The previous command means we are changing our directory from the current directory
    to the `somesite` directory, relative to where you're now.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: This command tells us to change the directory, but going up a level with `../`
    and then going into the `somesite` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an easier example to understand, my project exists in `/Sites/html5iphonewebapp`.
    So what I can do is use the following command to enter my project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: This changes the directory for me to the project where I am developing this
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Building our project
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once we've entered the project directory, we can start building our project.
    By default, the Ant Build script creates a production environment, which optimizes
    all parts of the process.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: This command tells us to build our project, and as explained creates our production
    version in a directory labeled `publish`. You will also notice that when you run
    that command, your terminal will update, letting you know what step in the process
    the build is in.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the build is complete, your directory structure should look similar to
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building our project](img/1024_01_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `publish` directory represents the production environment. You will also
    see that an intermediate directory has been created; this is your test environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, let''s say you wanted to have full control of the build and wanted
    to create your environments manually, then one can do the following in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: This command, `ant build –Denv=`, lets us define which environment we want to
    build and does it accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: We now have a project that is ready to be built upon. There were many steps
    in this process, so I encourage you to practice this process in order to develop
    a good architecture and deployment process that works for you and/or your team.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we saw how to use the HTML5 Mobile Boilerplate for our projects,
    from downloading the default package to customizing it for our needs. We also
    took a couple of simple steps to establish a solid architecture for our JavaScript,
    CSS, and HTML. As a bonus, we went over including a build process and customizing
    it for our project. We then quickly reviewed best practices for JavaScript applications
    and gave a couple of tips on how to direct users to a separate mobile site. We
    are now prepared for in-depth development of the mobile web applications.
  prefs: []
  type: TYPE_NORMAL
