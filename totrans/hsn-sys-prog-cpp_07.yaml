- en: A Comprehensive Look at Memory Management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will step the reader through how to properly and safely
    perform C++-style memory management, while also adhering to the C++ Core Guidelines
    whenever possible, leveraging additions to the C++ standard template library in
    C++11, C++14, and C++17 to increase the safety, reliability, and stability of
    the reader's system program. We will start by first introducing the `new()` and
    `delete()` functions, and how they may be used to allocate type-safe memory, including
    aligned memory. Next, this chapter will discuss the safety issues with using `new()`
    and `delete()` directly and how these safety concern may be handled using smart
    pointers, including their impact on C++ Core Guideline compliance. How to perform
    memory mapping and permissions will also be discussed, with the chapter concluding
    with a brief discussion on fragmentation.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to compile and execute the examples in this chapter, the reader must
    have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A Linux-based system capable of compiling and executing C++17 (for example,
    Ubuntu 17.10+)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GCC 7+
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CMake 3.6+
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An internet connection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To download all of the code in this chapter, including the examples, and code
    snippets, please visit: [https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/tree/master/Chapter07](https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/tree/master/Chapter07).
  prefs: []
  type: TYPE_NORMAL
- en: Learning about the new and delete functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, the reader will learn how to allocate and deallocate memory
    using C++17. You will learn how to use `new()` and `delete()` instead of `malloc()`/`free()`
    to increase the type-safety of allocations and deallocations. Various versions
    of these functions will be explained, including array, aligned, and placement-style
    allocations.
  prefs: []
  type: TYPE_NORMAL
- en: The basics for writing a program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When writing a program, including system programming, there are a few different
    types of memory that can be leveraged by the author:'
  prefs: []
  type: TYPE_NORMAL
- en: Global memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stack memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Heap memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Global memory exists in the program itself, is allocated by the OS''s loader, and
    generally exists in two different locations (assuming ELF binaries):'
  prefs: []
  type: TYPE_NORMAL
- en: '`.bss`: zero-initialized (or uninitialized) memory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.data`: value-initialized memory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Although used a lot in system programming, global memory is usually discouraged
    in favor of stack memory and dynamic memory. Special care should be taken when
    using value-initialized global memory, as this form of memory usage increases
    the size of the program on disk, resulting in a larger storage impact, as well
    as long load times, while the zero-initialized memory is provided by the OS-loader
    during linking.
  prefs: []
  type: TYPE_NORMAL
- en: '**Stack memory** is the memory that is allocated on the stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As shown in this example, `stack_mem` is allocated on the stack instead of globally
    because it exists in the `main()` function. Stack memory is bound to the scope
    in which it was created—in this case, the `main()` function. Besides being scoped,
    another advantage of stack memory is that when the memory's scope is complete,
    the memory will be released automatically for you. Care should be taken when using
    stack memory as this memory is limited in size.
  prefs: []
  type: TYPE_NORMAL
- en: It should be noted that the total size of the stack is entirely system-dependent
    and can vary widely. Unless you know the size of the stack, it should be assumed
    to be small, and used with caution as there is no simple way to determine when
    the stack runs out. Unlike dynamic memory allocation, which usually returns an
    error of some kind when memory is not available, on most systems when the stack
    runs out, your program will simply crash.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, on our test system, when attempting to allocate an integer array
    of `268435456` on the stack as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This results in a segmentation fault as the `stack_mem` variable exceeds the
    total size of the stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'The third form of memory and the main topic of this chapter is dynamic memory
    (also called **heap memory**). Like the stack, each program is given a pool of
    heap memory by the OS, which often can grow based on demand. Unlike the stack,
    and even global memory, heap memory allocations can be quite large if the physical
    system and OS can support it. In addition, unlike stack and global memory, heap
    memory is slow to allocate and any memory that is allocated on-demand by the user
    must also be released back to the heap by the user when complete. In C++, the
    fundamental method for allocating heap memory is through the use of the `new()`
    and `delete()` operator functions, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In this simple example, an integer (whose size is architecture-dependent, but
    assumed to be `4` bytes here) is allocated on the heap using the new operator.
    The address of the newly-allocated memory is outputted to `stdout`, and then the
    memory is released back to the heap using the `delete()` operator. In addition
    to single objects, arrays can also be allocated/deallocated using the `new()`/`delete()`
    operators, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, an array of integers is allocated a size of `42`. Note that,
    unlike `malloc()` in standard C, the new operator automatically calculates the
    total number of bytes needed for an object or array of objects. Assuming that
    an integer is `4` bytes, in this example, the new operator allocates `42 * sizeof(int)
    == 42 * 4 == 11088` bytes. In addition to the use of `new[]()` to allocate an
    array, the `delete []()` operator is used instead of the `delete` operator. The
    delete operator calls the destructor for a single object while the `delete []()`
    operator calls the destructor for each object in the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: It's important to note that some systems may use different pools to allocate
    single objects versus arrays of objects versus aligned objects, and more. Care
    should be taken to ensure that the deallocation routine matches the allocation
    routine. For example, if `new []()` is used, `delete []()` should always be used
    instead of `delete()`. If a mismatch occurs, systems that share the same pools
    will function without issue, but a crash could occur on systems that do not share
    these pools as you would be attempting to release memory to a pool to which the
    memory did not originally belong. The easiest way to prevent these types of errors
    is to use `std::unique_ptr{}` and `std::shared_ptr{}`, which will be discussed
    in the *Understanding smart pointers and ownership* section.
  prefs: []
  type: TYPE_NORMAL
- en: Aligning memory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When programming systems, often allocating aligned memory (that is, memory
    that is divisible by a specific alignment) is required. Specifically, when memory
    is allocated, the resulting address that points to said allocated memory can be
    any value. When programming systems, however, this can often be problematic as
    some APIs and physical devices require memory to be allocated with a certain minimum
    granularity. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Aligned memory may be allocated using all three memory types:'
  prefs: []
  type: TYPE_NORMAL
- en: Globally
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the stack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamically
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To allocate aligned memory globally using C++, use the `alignas()` specifier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, an integer array of size `42` is allocated globally, and the
    `alignas()` specifier is used to align the array to a 4k page boundary. The array''s
    address is then outputted, and as shown, the address is divisible by a 4k page
    (that is, the first 12 bits are zero). To allocate aligned memory on the stack,
    you can also use the `alignas()` specifier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of the array being allocated globally, the array is moved into the
    `main` function''s scope and is therefore allocated using the stack when the `main`
    function executes, and automatically released when the `main` function completes.
    This type of allocation should be used with care as the compiler has to add code
    to the program''s executable to move the stack pointer in order to align this
    memory. As a result, aligned allocations on the stack indirectly allocate additional,
    unusable memory to ensure the pointer is aligned (shown on Intel''s x86_64 using
    GCC 7.3):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'As can be seen, the stack pointer (that is, the RSP register in this case),
    is moved to align the integer array. If this type of allocation is done a lot,
    or the alignment is high (say a 2 MB alignment), stack space could run out quickly.
    Another way to allocate aligned memory (regardless of the type) is to manually
    calculate an aligned position within an existing character buffer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, a character buffer of ample size is allocated on the stack.
    The character buffer''s address is then converted into an unsigned integer pointer
    type, an operation that is discouraged by the C++ Core Guidelines as `reinterpret_cast()`
    should be avoided, and then arithmetic on the character buffer''s pointer is performed
    to locate a page-aligned address inside the buffer, another operation that is
    discouraged by the C++ Core Guidelines as pointer arithmetic should be avoided
    as well. Both the original and resulting pointers are outputted to `stdout`, and
    as shown, the calculated pointer is aligned to a 4k page boundary within the character
    buffer. To see how this algorithm works, see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This type of process works, and has been used for years, but should be avoided
    as there are better ways to accomplish this same task using `alignas()` without
    the need for type-casting and pointer arithmetic that is prone to error and discouraged
    by the C++ Core Guidelines.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the third way to allocate aligned memory is to use dynamic allocations.
    Prior to C++17, this was done using `posix_memalign()` or the newer C11 `aligned_alloc()`,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `posix_memalign()` API is a bit clunky. First, a pointer must be declared*,*
    the alignment and size (which must be manually calculated) are provided, and then
    the function returns 0 upon success. Finally, `reinterpret_cast()` is needed to
    tell the `posix_memalign()` function that the provided pointer is `void **` and
    not `int**`. Since the `posix_memalign()` function is a C-style function, `free()`
    is used to release the memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to allocate aligned memory is to use the relatively new `aligned_alloc()`
    function, which provides a less clunky, more portable implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As shown, `aligned_alloc()` functions like a regular `malloc()` but with an
    additional alignment parameter. This API still suffers from the same size issue
    as `malloc()` and `posix_memalign()`, where the total size of the array must be
    manually calculated.
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve these issues, C++17 added aligned allocation versions of the `new()`
    and `delete()` operators that leverage `alignas()` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we allocate a single integer using `alignas()` and the `new()`
    and `delete()` operators. To accomplish this, we create a new type, called `aligned_int`,
    that leverages `alignas()` in the type definition. The following can also be used
    to allocate an aligned array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The same aligned integer type is used, with the only difference being the use
    of `new []()` and `delete []()` instead of `new()` and `delete()`. Unlike the
    C APIs shown in the preceding code, `new()` and `delete()`, including the aligned
    versions added to C++17, automatically calculate the total number of bytes that
    need to be allocated for you, removing potential errors.
  prefs: []
  type: TYPE_NORMAL
- en: nothrow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `new()` and `delete()` operators are allowed to throw exceptions. In fact,
    if an allocation fails, the default new operator throws `std::bad_alloc` instead
    of returning `nullptr`. In some situations, often seen when programming systems,
    an exception on an invalid allocation is unwanted, and for this reason, a `nothrow`
    version has been provided:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Specifically, `new (std::nothrow)` is used instead of `new()`, which tells
    C++ that you would like `nullptr` to be returned on an invalid allocation instead
    of `new()` throwing `std::bad_alloc`. The array version was also provided as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'And as one might expect, the aligned allocation versions of these functions
    were also provided for single-object allocations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'There''s also array-style allocations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'It should be noted that `nullptr` is only returned for types provided by C++.
    For user-defined types, if an exception is thrown during construction, the `nothrow`
    version of `new()`, which is marked `nothrow`, will call `std::terminate` and
    abort:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: To overcome this issue, class-specific `new` and `delete` operators may be used
    (a topic to be explained in the *Overloading* section).
  prefs: []
  type: TYPE_NORMAL
- en: Placement of new
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In addition to aligned allocations and `nothrow` specifiers, C++ also provides
    the ability to allocate memory from an existing, user-controlled buffer, a situation
    that can often be seen while programming systems. For example, suppose you have
    mapped a buffer from a physical device. Now suppose you wish to allocate from
    this buffer an integer, the `new()` placement operator may be used to accomplish
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we leverage the `new()` placement operator to allocate memory
    from an existing user-controlled buffer. The `new()` placement operator provides
    the object to be allocated with the address that is provided, and then, as usual,
    calls the object''s constructor. It should be noted that the `delete()` operator
    is not needed in this case because the memory to the object being allocated is
    user-defined, in which case there is no heap memory to return to the heap when
    complete. Furthermore, the `new()` placement operator doesn''t manage the memory
    provided to a set of objects, a task that must be performed by the user. To demonstrate
    this, see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, the `new()` placement is used twice. As shown, the address
    that is provided is the same since we have not manually advanced the address provided
    to the `new()` placement, demonstrating that C++ doesn''t automatically manage
    user-defined memory when the `new()` placement is used. Typically, this type of
    example would lead to undefined behavior if executed (in this case it doesn''t
    since we are not actually using the newly allocated memory). For these reasons,
    the `new()` placement should be used with special care. In addition to single
    allocations, array allocations are also provided:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Since C++ doesn''t manage `new()` placement allocations, aligned allocations
    must be provided by the user as well. The alignment algorithm provided in the
    preceding code could be used to provide aligned allocations from a user-defined
    buffer, the memory that is already aligned (for example, when interfacing with
    a physical device via `mmap()`) could be used, or `alignas()` could also be used,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, since the buffer is aligned using `alignas()`, the resulting
    new placement allocation is also aligned when this buffer is provided. This same
    type of allocation also works for array allocation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Overloading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Often when programming systems, the default allocation scheme provided by C++
    is undesirable. Examples include (but are not limited to):'
  prefs: []
  type: TYPE_NORMAL
- en: Custom memory layouts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fragmentation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance optimizations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging and statistics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'One way to overcome these issues is to leverage C++ allocators, a complex topic
    that will be discussed in [Chapter 9](2a64ae97-dad4-479a-bd9f-9df2cb634b74.xhtml),
    *A Hands-On Approach to Allocators*. Another, more heavy-handed, way to achieve
    this is to leverage the `new()` and `delete()` operators'' user-defined overloads:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In this example, a custom `new()` and `delete()` operator overload is provided.
    Instead of your program using the default allocation scheme provided by the `new()`
    and `delete()` functions, your user-defined versions will be used instead.
  prefs: []
  type: TYPE_NORMAL
- en: These overloads affect all allocations, including those used by the C++ library,
    so care should be taken when leveraging these overloads as infinite cyclic recursions
    could occur if an allocation is performed inside these functions. For example,
    data structures such as `std::vector` and `std::list`, or debugging functions
    such as `std::cout` and `std::cerr` cannot be used as these facilities use the
    `new()` and `delete()` operators to allocate memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the single-object `new()` and `delete()` operators, all of the
    other operators may also be overloaded, including the array allocation versions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Debugging and statistics are a common reason to overload the `new()` and `delete()`
    operators, providing useful information about the types of allocations that are
    occurring. For example, suppose you wish to record the total number of allocations
    larger than, or equal to, a page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown, no allocations larger than a page were performed by our program,
    including allocations made by the C++ library. Let''s see what happens if we allocate
    a page as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We get a single allocation larger than, or equal to, a page, as expected. This
    type of use of `new()` and `delete()` overloaded can be extremely useful for debugging
    memory leaks, locating allocation optimizations, and more. It should be noted
    however that care should be taken when writing these types of overloads. If you
    accidentally allocate memory (for example, when using a C++ data structure such
    as `std::vector{}`, or when using `std::cout`), you could end up in an infinite
    loop, or adding to statistics you might be trying to record.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to global operator `new` and `delete` operator overloads, class-specific
    versions are also provided:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: When class-specific operators are used, the only allocations that are directed
    to your overloads are allocations for the specific class or classes that you provide
    overloads for. As shown in the preceding example, the allocations made by `std::cout`
    are not directed to our class-specific overloads, preventing infinite recursion.
    The only allocation and deallocation that uses overload are the ones for `myclass`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As expected, all of the global operators also exist for the class-specific
    operators, including versions such as aligned allocations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Understanding smart pointers and ownership
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, the reader will learn how to use smart pointers to increase
    the safety, reliability, and stability of their program, while also adhering to
    the C++ Core Guidelines.
  prefs: []
  type: TYPE_NORMAL
- en: The std::unique_ptr{} pointer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It should be clear by now that C++ provides an extensive set of APIs for allocating
    and deallocating dynamic memory. It should also be clear that whether you are
    using `malloc()`/`free()` or `new()`/`delete()`, errors are not only possible
    but likely in large applications. For example, you might forget to release memory
    back to the heap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Or you could use `delete` instead of `delete []` when allocating an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'To overcome this, C++11 introduced the concept of pointer ownership with two
    classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::unique_ptr{}`: Defines a pointer uniquely owned by a single entity. Copying
    this pointer is not allowed and is explicitly prevented by the compiler, and deallocations
    are automatically handled by C++.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::shared_ptr{}`: Defines a pointer that may be owned by one or more entities.
    Copying this pointer is allowed, and deallocation only occurs when all of the
    owners have released their ownership.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The C++ Core Guidelines, in general, discourage any dynamic allocations that
    are not performed by these two classes. For most cases where `new` and `delete`
    would normally be used, `std::unique_ptr{}` should be used instead. Consider the
    following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'To create both `std::unique_ptr{}` and `std::shared_ptr`, C++ provides the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::make_unique()`: Creates `std::unique_ptr{}`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::make_shared()`: Creates `std::shared_ptr{}`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you plan to provide C++ Core Guideline compliance, get used to these functions.
    As shown, to create `std::unique_ptr{}`, you must provide the object type you
    plan to allocate, and the object''s initial value, as a template argument. Also,
    as shown, there is no need to manually call the `delete()` operator, as this is
    done for you. To demonstrate this, see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Using `std::unique_ptr{}` in this example, both memory leaks and memory API
    mismatching have been prevented. In addition, this smart allocation and deallocation
    is scoped. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '`myclass1` is stored as a member variable of `myclass2`. In the `main` function,
    `myclass2` is created and destroyed immediately, and as a result, when `myclass2`
    is destroyed, `myclass1` is also released back to the heap.'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::unique_ptr{}` accepts a pointer to previously-allocated memory (for example,
    via the `new()` operator), and then, on destruction, releases the memory it was
    given via the `delete()` operator by default. If the memory provided to `std::unique_ptr{}`
    is allocated using `new[]()` instead of `new()`, the `[]` version of `std::unique_ptr{}`
    should be used to ensure it releases the allocated memory using `delete[]()` instead
    of `delete()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The more C++-Core-Guideline-compliant method for allocating and deallocating
    an array using `std::unique_ptr{}` is to use the array version of `std::make_unique()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of manually allocating the array, `std::make_unique()` allocates the
    array for you. The difference between a single-object allocation and an array
    allocation with `std::make_unique()` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::make_unique<type>(args)`: To perform a single-object allocation, the
    type is provided as the template argument, and the object''s constructor arguments
    are provided as the arguments to `std::make_unique()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::make_unique<type[]>(size)`: To perform an array allocation, the array
    type is provided as the template argument, and the size of the array is provided
    as the argument to `std::make_unique()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In some cases, the memory provided to `std::unique_ptr{}` cannot be released
    using `delete()` or `delete[]()` (for example, a `mmap()` buffer, placement `new()`,
    and more). To support these types of scenarios, `std::unique_ptr{}` accepts custom
    deleters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, a `deleter` class is created, and a functor (that
    is, `operator ()`) is provided, which performs the custom deletion. When it's
    time to release the allocated memory, the functor is called by `std::unique_ptr{}`.
  prefs: []
  type: TYPE_NORMAL
- en: 'One disadvantage of `std::unqiue_ptr{}` in C++17 is that the alignment versions
    of the `new` and `delete` operators were not extended to `std::unique_ptr{}` (or
    `std::shared_pointer{}`). Since there is no alignment version for `std::unique_ptr{}`,
    if aligned memory is required, it must be allocated manually (hopefully an issue
    that will be resolved in future versions of C++ as this allocation style is typically
    discouraged by the C++ Core Guidelines):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Like a normal C++-style pointer, `*` and `->` may be used to dereference at
    `std::unique_ptr{}`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'To get `std::unique_ptr{}` to release its allocation, the pointer needs to
    lose scope, causing the destructor of `std::unique_ptr{}` to be called, which
    in turn releases the allocation back to the heap. `std::unique_ptr{}` also provides
    the `reset()` function, which explicitly tells the pointer to release its memory
    on demand, without having to lose scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `std::unique_ptr{}` is reset, and as a result, the pointer
    it is storing is equivalent to `nullptr`. `std::unique_ptr{}` does not check to
    ensure that the pointer is valid when it is dereferenced using operators such
    as `->` and `*`. For this reason, the `reset()` function should be used with care,
    and used only when needed (for example, when the order in which allocations are
    released matters).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a couple of ways `std::unique_ptr{}` could be invalid (but this is
    not an exhaustive list):'
  prefs: []
  type: TYPE_NORMAL
- en: It was originally created using `nullptr`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reset()` or `release()` was called'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To check whether `std::unique_ptr{}` is valid, to ensure a null dereference
    doesn''t accidentally occur, the Boolean operator may be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: As shown in this example, once `reset()` is called on `std::unique_ptr{}`, it
    becomes invalid (that is, its equal to `nullptr`), and the Boolean operator returns
    `false`, preventing a `nullptr` dereference.
  prefs: []
  type: TYPE_NORMAL
- en: 'If `std::unique_ptr{}` is created using the array syntax, the subscript operator
    may be used to access a specific element in the array, similar to using the subscript
    operator for a standard C array, or `std::array{}`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, an integer array is allocated a size of `42`, and
    the first element in the array is outputted to `stdout`, which contains the value
    of `0` since `std::make_unique()` uses value initialization to zero-initialize
    all allocations.
  prefs: []
  type: TYPE_NORMAL
- en: It should be noted that even though the C++ Core Guidelines encourage the use
    of `std::unique_ptr{}` instead of manually allocating and deallocating C-style
    arrays, the guidelines do not encourage the use of the subscript operator to access
    the array since doing so performs unsafe pointer arithmetic, and could potentially
    lead to a `nullptr` dereference. Instead, a newly-allocated array using `std::unique_ptr{}`
    should be provided to `gsl::span` prior to being accessed.
  prefs: []
  type: TYPE_NORMAL
- en: 'One limitation of C++17 with respect to `std::unique_ptr{}` is the inability
    to directly add one to an IO stream such as `std::cout`. With C++17, the best
    way to output the address of `std::unique_ptr{}` is to use the `get()` function,
    which returns the address of the pointer. Another way to accomplish this is to
    create a user-defined overload:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The std::shared_ptr pointer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In most cases, `std::unique_ptr{}` should be used to allocate dynamic memory.
    In some use cases, however, `std::unique_ptr{}` is incapable of properly representing
    pointer ownership. Pointer ownership refers to who owns a pointer, or in other
    words, who is responsible for allocating, and more importantly, deallocating a
    pointer. In most cases, a single entity within a program is responsible for this
    task. There are, however, some use cases where more than one entity must claim
    responsibility for deallocating a pointer.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most common scenario where more than one entity must claim ownership over
    a variable involves threading. Suppose you have two threads:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Thread #1 creates a pointer (and thus owns it)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Thread #2 uses the pointer from thread #1'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this example, the second thread owns the pointer just as much as the first
    thread that created the pointer and provided it in the first place. The following
    example demonstrates this scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the first thread is created, which creates a pointer to `myclass`.
    It then creates the second thread and passes the newly-created pointer to this
    second thread. Both threads perform a set of actions on the pointer, and then
    complete. The problem is that the first thread doesn't have as much work to perform
    as the second thread, so it completes quickly, releasing the pointer before the
    second thread has a chance to complete, since in this scenario we have explicitly
    stated that `thread1` is the owner of the pointer and `thread2` is simply a user
    of the pointer.
  prefs: []
  type: TYPE_NORMAL
- en: 'To overcome this issue, C++ provides a second smart pointer, called `std::shared_ptr{}`,
    that is capable of assigning ownership to more than one entity. The syntax for
    `std::shared_ptr{}` is almost identical to `std::unique_ptr{}`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Internally, `std::shared_ptr{}` maintains the managed object in a separate object
    that is shared between all copies of the original `std::shared_ptr{}`. This managed
    object stores a count of the total number of `std::shared_ptr{}` copies. Each
    time a copy is created, the count inside the managed object increases. When `std::shared_ptr{}`
    needs access to the pointer itself, it must use its pointer to the managed object
    to ask for the pointer (that is, `std::shared_ptr{}` doesn't store the pointer
    itself, but rather stores a pointer to a managed object that stores the pointer).
    Each time `std::shared_ptr{}` is destroyed, the managed object's count is decreased,
    and when the count reaches `0`, the pointer is finally released back to the heap.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using this pattern, `std::shared_ptr{}` is capable of providing ownership of
    a single pointer to multiple entities. The following rewrites the preceding example
    using `std::shared_ptr{}` instead of `std::unique_ptr{}`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: As shown in this example, `thread2` is given a copy of the original `std::shared_ptr{}`,
    creating in effect two copies that point to a single managed object. When `thread1`
    completes, `thread2` still maintains a reference to the managed object and as
    a result, the pointer remains intact. It's not until the second thread completes
    that the managed object's reference count reaches 0 and the pointer is released
    back to the heap.
  prefs: []
  type: TYPE_NORMAL
- en: 'It should be noted that there are some disadvantages to `std::shared_ptr{}`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Memory footprint**: Since `std::shared_ptr{}` maintains a pointer to a managed
    object, `std::shared_ptr{}` could result in two mallocs instead of one (some implementations
    are capable of allocating a single, larger chunk of memory and using it for both
    the pointer and the managed object). Regardless of the implementation, the amount
    of memory that is needed by `std::shared_ptr{}` is larger than that of `std::unique_ptr{}`,
    which is often the same size sd a regular C-style pointer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performance**: All access to the pointer must first be redirected to the
    managed object since `std::shared_ptr{}` does not actually have a copy of the
    pointer itself (just a pointer to the managed object). As a result, additional
    function calls (that is, pointer dereferences) are required.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Memory leaks**: There is a tradeoff between `std::unique_ptr{}` and `std::shared_ptr{}`,
    and neither provides the perfect solution for managing memory in a way that prevents
    possible `nullptr` dereferences while at the same time preventing memory leaks.
    As demonstrated, the use of `std::unique_ptr{}` in some situations could result
    in a `nullptr` dereference. On the other hand, `std::shared_ptr{}` could result
    in a memory leak if the number of copies of `std::shared_ptr{}` never reaches
    0\. Although these problems with smart pointers exist, the use of `new()`/`delete()`
    manually doesn''t address these issues (and almost certainly makes them worse),
    and in general, if the right smart pointer type is used in the right scenario,
    these types of issues can be alleviated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cyclic references**: It is possible to create cyclic references with `std::shared_ptr{}`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Like `std::unique_ptr{}`, `std::shared_ptr{}` provides a `reset()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: In this example, two copies of `std::shared_ptr{}` are created. We first output
    the address of these pointers to `stdout`, and as expected, the address is valid,
    and they are the same (as they both point to the same managed object). Next, we
    release using the `reset()` function, the second pointer and then output the address
    of the pointers again. The second time around, the first `std::shared_ptr{}` still
    points to a valid pointer, while the second points to `nullptr`, since it no longer
    has a reference to the original managed object. The pointer is eventually released
    back to the heap when the `main()` function completes.
  prefs: []
  type: TYPE_NORMAL
- en: 'One issue with the C++17 version of `std::shared_ptr{}` is a lack of an array
    version, similar to `std::unique_ptr{}`. That is, there is no `std::shared_ptr<type[]>`
    version of `std::shared_ptr{}`, similar to the `std::unique_ptr<type[]>{}` API. 
    As a result, there is no way to allocate an array using `std::make_shared()`, and
    there is no subscript operator to access each element in the array. Instead, you
    must do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'C++ also provides a method for determining how many copies of `std::shared_ptr{}`
    exist (which essentially just asks the managed object for its reference count):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: This example is similar to the preceding `reset()` example, but adds a call
    to the `use_count()` function that reports the total number of copies of `std::shared_ptr{}`.
    As shown, when two copies of `std::shared_ptr{}` are created, `use_count()` reports
    `2`. When `reset()` is run, `use_count()` reduces to `1`, and eventually when
    `main()` completes, this count will reduce to `0` and the pointer will be released
    to the heap. It should be noted that this function should be used with caution
    in multithreaded environments as races can occur with respect to the reported
    count.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to `std::unique_ptr{}`, a Boolean operator is provided to `std::shared_ptr{}` to
    check whether the pointer is valid. Unlike `std::unique_ptr{}`, the Boolean operator
    doesn''t determine whether the managed object has been released (as there might
    be a copy of `std::shared_ptr{}` lying around somewhere). Instead, the Boolean operator
    reports whether or not `std::shared_ptr{}` is maintaining a reference to the managed
    object. If `std::shared_ptr{}` is valid, it has a reference to the managed object
    (and thus access to the allocated pointer), and the Boolean operator reports `true`.
    If `std::shared_ptr{}` is invalid, it no longer maintains a reference to the managed
    object (and thus doesn''t have access to the allocated pointer), returning `nullptr`
    when `get()` is called, and the Boolean operator reports `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the preceding example, when the `reset()` function is called, the
    pointer is no longer valid, as the smart pointer's internally-managed object is
    now pointing to `nullptr`, and thus, the Boolean operator returns `false`. Since
    there are no other copies of `std::shared_ptr{}` (that is, the managed object's
    count is `0`), the allocated pointer is also released back to the heap.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like `std::unique_pt{}r`, both the `*` and `->` operators are provided to dereference `std::shared_ptr{}`
    (but no subscript operator since arrays are not supported):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, one issue with `std::shared_ptr{}` is that of cyclic references. The
    following example does the best job of describing the issue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: In this example, two classes are created—`myclass1` and `myclass2`. Both `myclass1`
    and `myclass2` maintain `std::shared_ptr{}` references to each other (that is,
    for whatever reason, both classes claim ownership over the other). When the pointers
    are destroyed, no memory is released back to the heap because none of the destructors
    is ever called. To understand why, we need to break down the number of copies
    that are made, and where they exist.
  prefs: []
  type: TYPE_NORMAL
- en: The original `std::shared_ptr{}` for `ptr1` and `ptr2` are both created in the
    `main()` function, when means the `#1` and `#2` managed objects both have a `use_count()`
    of `1` upon creation. Next, `ptr1` is given a copy of `std::shared_ptr{}` for
    `ptr2`, and vice version, meaning the `#1` and `#2` managed objects now both have
    a `use_count()` of `2`. When `main()` completes, the `std::shared_ptr{}` for `ptr2`
    in the `main()` function (not `std::shared_ptr{}` in `ptr1`) is destroyed, but
    since there is still a `std::shared_ptr{}` copy of `ptr2` in `ptr1`, the pointer
    itself is not released. Next, `ptr1`  in `main()` is destroyed, but since the
    copy of `ptr2` still exists in one of the copies of `ptr1`, `ptr1` itself is not
    released, and thus, we have created a copy of `ptr1` and `ptr2` that point to
    each other, but with no copies of these pointers left in the code itself to release
    this memory, and thus memory is permanently deleted.
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this, `std::shared_ptr{}` provides a version of itself called `std::weak_ptr{}`.
    It has all the same properties of `std::shared_ptr{}`, but doesn''t increment
    the reference counter of the managed object. Although the `get()` function could
    be used instead to store a raw pointer, `std::weak_ptr{}` still maintains a connection
    with the managed object, providing a means to determine whether the managed object
    has been destroyed, something you cannot do with a raw pointer. To demonstrate
    this, the preceding example has been converted to use `std::weak_ptr{}` in `myclass1`
    and `myclass2` instead of `std::shared_ptr{}`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in this example, even though a cyclic reference still exists, the
    allocated pointers are released back to the heap when `main()` completes. Finally,
    it should be noted that it is possible to convert `std::unique_ptr` to `std::shared_ptr`
    using the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Since `std::unique_ptr` is being moved, it no longer owns the pointer, and instead `std::shared_ptr`
    now owns the pointer. Moving from `std::shared_ptr` to `std::unqiue_ptr` is not
    allowed.
  prefs: []
  type: TYPE_NORMAL
- en: Learning about mapping and permissions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, the reader will learn how to map memory using C++ patterns.
    You will learn how to map memory (a common system-programming technique), while
    doing so using C++ patterns.
  prefs: []
  type: TYPE_NORMAL
- en: The basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`malloc()`/`free()`, `new()`/`delete()`, and `std::unique_ptr{}`/`std::shared_ptr{}`
    are not the only methods for allocating memory on a POSIX system. C++-style allocators
    are another, more complicated, method for allocating memory that will be discussed
    in greater detail in [Chapter 9](2a64ae97-dad4-479a-bd9f-9df2cb634b74.xhtml),
    *A Hands-On Approach to Allocators*. A more direct, POSIX style for allocating
    memory is to use `mmap()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The `mmap()` function may be used to map memory from different sources into
    a program. For example, if you want to make device memory into your application,
    you would use `mmap()`. If `MAP_ANONYMOUS` is passed to `mmap()`, it can be used
    to allocate memory the same way you would allocate memory using `malloc()` and
    `free()`. In the preceding example, `mmap()` is used to allocate a 4k page of
    memory that is marked read/write. The use of `MAP_PRIVATE` tells `mmap()` that
    you do not intend to share this memory with other applications (for example, for
    interprocess communication). Mapping memory this way compared to `malloc()`/`free()`
    has some advantages and disadvantages.
  prefs: []
  type: TYPE_NORMAL
- en: '**Advantages**:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Fragmentation**: Allocating memory using `MAP_ANONYMOUS` usually maps memory
    in sizes that are multiples of a page size, or, worst case, a power of two. The
    is because `mmap()` is asking the OS kernel for a block memory, and that memory
    must be mapped into the application, which can only be done in blocks no smaller
    than a page. As a result, fragmentation of this memory is far less likely that
    multiple, random memory allocations usually made using `malloc()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Permissions**: When using `mmap()`, you can state the permissions you wish
    to apply to the newly-allocated memory. This is especially useful if you need
    memory with special permissions, such as read/execute memory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Shared memory**: The memory allocated using `mmap()` can also be shared by
    another application instead of being allocated privately for a specific application,
    as with `malloc()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Disadvantages**:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Performance**: `malloc()`/`free()` allocate and deallocate to a block of
    memory that is managed by the C library inside the application itself. If more
    memory is needed, the C library will call into the OS, using functions such as `brk()` or
    even `mmap()`, to get more memory from the OS. When free is called, the released
    memory is provided back to the memory being managed by the C library, and in a
    lot of cases is never actually provided back to the OS. For this reason, `malloc()`/`free()`
    can quickly allocate memory for the application because no OS-specific calls are
    being made (unless of course the C library runs out of memory). `mmap()`, on the
    other hand, has to call into the OS on every single allocation. For this reason,
    it does not perform as well as `malloc()`/`free()` since an OS call can be expensive.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Granularity**: For the same reason that `mmap()` reduces fragmentation, it
    also reduces granularity. Every single allocation made by `mmap()` is at least
    a page in size, even if the requested memory is only a byte.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To demonstrate the potential waste of `mmap()`, see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: In this example, 42 bytes are allocated twice, but the resulting addresses are
    a 4k page apart. This is because allocations made by `mmap()` must be at least
    a page in size, even though the requested amount was only 42 bytes. The reason
    that `malloc()`/`free()` does not have this waste is that these functions request
    large chunks of memory at a time from the OS, and then manage this memory using
    various different allocation schemes internally within the C library. For more
    information on how this is done, there is a very good explanation within `newlib`
    on the topic: [https://sourceware.org/git/?p=newlib-cygwin.git;a=blob;f=newlib/libc/stdlib/malloc.c.](https://sourceware.org/git/?p=newlib-cygwin.git;a=blob;f=newlib/libc/stdlib/malloc.c;h=f5ac2920888563013663454758cce102e40b69ad;hb=HEAD)
  prefs: []
  type: TYPE_NORMAL
- en: Permissions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`mmap()` may be used to allocate memory with special parameters. For example,
    suppose you need to allocate memory that has read/execute permissions instead
    of the read/write permissions that are typically associated with `malloc()`/`free()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: As shown, allocating memory with read/execute permissions is the same as allocating
    memory with read/write permissions substituting `PROT_WRITE` with `PROT_EXEC`.
  prefs: []
  type: TYPE_NORMAL
- en: On systems that support read/write or read/execute (also known as W^E, which
    states that write is mutually exclusive with execute), write and execute permissions
    should not be used together at the same time. Specifically, in the event of malicious
    use of your program, preventing executable memory from also having write permissions
    can prevent a number of known cyber attacks.
  prefs: []
  type: TYPE_NORMAL
- en: The problem with allocating memory as read/execute and not read/write/execute
    is that there is no easy way to place executable code into your newly-allocated
    buffer as the memory was marked as read/execute only. The same is true if you
    wish to allocate read-only memory. Once again, since write permissions were never
    added, there is no way to add data to read-only memory as it doesn't have write
    permissions.
  prefs: []
  type: TYPE_NORMAL
- en: To make the situation worse, some operating systems prevent applications from
    allocating read/write/execute memory as they attempt to enforce W^E permissions.
    To overcome this issue, while still providing a means to set the desired permissions,
    POSIX provides `mprotect()`, which allows you to change the permissions of memory
    that has already been allocated. Although this may be used with memory that is
    managed by `malloc()`/`free()`, it should instead be used with `mmap()` memory
    permissions that can only be enforced at the page level on most architectures. `malloc()`/`free()`
    allocate from a large buffer that is shared among all of the program's allocations,
    while `mmap()` only allocates memory with page granularity, and therefore is not
    shared by other allocations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following shows an example of how to use `mprotect`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `mmap()` is used to allocate a buffer the size of a 4k page
    with read/write permissions. Once the memory is allocated, `mprotect()` is used
    to change the permissions of the memory to read-only. Finally, `munmap()` is used
    to release the memory back to the operating system.
  prefs: []
  type: TYPE_NORMAL
- en: Smart pointers and mmap()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With respect to C++, the biggest issue with `mmap()` and `munmap()` is that
    they suffer from a lot of the same disadvantages as `malloc()`/`free()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Memory leaks**: Since `mmap()` and `munmap()` must be executed manually,
    it''s possible the user could forget to call `munmap()` when the memory is no
    longer needed, or a complex logic bug could result in `munmap()` not being called
    at the right time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Memory mismatch**: It''s possible that the users of `mmap()` could call `free()`
    instead of `munmap()` by accident, resulting in a mismatch that is almost certain
    to generate instability because memory from `mmap()` is coming from the OS kernel,
    while `free()` is expecting memory from application heap.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To overcome this, `mmap()` should be wrapped with `std::unique_ptr{}`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the main function calls `mmap_unique()` instead of `std::make_unqiue()`,
    as `std::make_unique()` allocates memory using `new()`/`delete()`, and we wish
    to use `mmap()`/`munmap()` instead. The first part of the `mmap_unique()` function
    allocates memory using `mmap()` the same way as our previous examples. In this
    case, permissions were set to read/write, but they could have also been changed
    using `mprotect()` to provide read-only or read/execute if desired. If the call
    to `mmap()` fails, `std::bad_alloc()` is thrown, just like the C++ library.
  prefs: []
  type: TYPE_NORMAL
- en: The next line in this example uses the `new()` placement operator, as discussed
    earlier in in the *Placement new* section. The goal of this call is to create
    an object whose constructor has been called to initialize the  `T` type as required.
    In the case of this example, this is setting an integer to `42`, but if a class
    were used instead of an integer, the classes constructor would be called with
    whatever arguments were passed to `mmap_unique()`.
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to create a custom deleter for our `std::unqiue_ptr{}`. This
    is done because by default, `std::unqiue_ptr{}` will call the `delete()` operator
    instead of `munmap()`. The custom deleter takes a single argument that is the
    size of the original allocation. This is needed because `munmap()` needs to know
    the size of the original allocation, unlike `delete()` and `free()`, which just
    take a pointer.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, `std::unique_ptr{}` is created with the newly-created object and custom
    deleter. From this point on, all of the memory that was allocated using `mmap()`
    can be accessed using the standard `std::unique_ptr{}` interface, and treated
    as a normal allocation. When the pointer is no longer needed, and `std::unique_ptr{}`
    is out of scope, the pointer will be released back to the OS kernel by calling
    `munmap()` as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Shared memory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In addition to allocating memory, `mmap()` may be used to allocate shared memory,
    typically for interprocess communications. To demonstrate this, we start by defining
    a shared memory name, `"/shm"`, and our read, write, and execute permissions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we must define our custom deleter, which uses `munmap()` instead of `free()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we build off of the previous example, but instead of having
    a single `mmap_unique()` function, we now have a server and a client version.
    Although typically shared memory would be used for interprocess communication,
    in this example, we share memory in the same application to keep things simple.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `main` function creates both a server and a client-shared pointer. The
    server version creates shared memory using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: This function is similar to the `mmap_unique()` function in the previous example,
    but opens a handle to a shared memory file instead of allocating memory using
    `MAP*_*ANONYMOUS`. To open the shared memory file, we use the `POSIX shm_open()`
    function. This function is similar to the `open()` function. The first parameter
    is the name of the shared memory file. The second parameter defines how the file
    is opened, while the third parameter provides the mode. `shm_open()` is used to
    open the shared memory file, and the file descriptor is checked to make sure the
    allocation succeeded (that is, the file descriptor is not `-1`).
  prefs: []
  type: TYPE_NORMAL
- en: Next, the file descriptor is truncated. This ensures that the size of the shared
    memory file is equal to the size of the memory we wish to share. In this case,
    we wish to share a single `T` type, so we need to get the size of `T`. Once the
    shared memory file has been properly sized, we need to map in the shared memory
    using `mmap()`. The call to `mmap()` is the same as our previous examples, with
    the exception that `MAP_SHARED` is used.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, like the previous example, we leverage the `new()` placement operator
    to create the newly-allocated type in shared memory, we create the custom deleter,
    and then finally, we return `std::unique_ptr{}` for this shared memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'To connect to this shared memory (which could be done from another application),
    we need to use the client version of the `mmap_unique()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The server and client versions of these functions look similar, but there are
    differences. First and foremost, the shared memory file is opened without `O_CREAT`.
    This is because the server creates the shared memory file, while the client connects
    to the shared memory file, so there is no need to pass `O_CREAT` in the client
    version. Finally, the signature of the client version of this function doesn''t
    take any arguments like the server version. This is because the server version
    uses the `new()` placement to initialize the shared memory, which doesn''t need
    to be done a second time. Instead of using the new placement, `static_cast()`
    is used to convert `void *` to the proper type prior to delivering the pointer
    to the newly created `std::unique_ptr{}`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: The result of this example is that memory is shared between a server and a client,
    wrapping the shared memory in `std::unique_ptr{}`. Furthermore, as shown in the
    example, the memory is properly shared, as can be seen by `42` being printed for
    both the server and client version of the pointer. Although we use this for an
    integer type, this type of shared memory can be used with any complex type as
    needed (although care should be taken when attempting to share classes, especially
    those that leverage inheritance and contain `vTable`).
  prefs: []
  type: TYPE_NORMAL
- en: Learning importance of memory fragmentation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: No chapter on memory management would be complete without a brief discussion
    of fragmentation. Memory fragmentation refers to a process in which memory is
    broken up into chunks, often spread out, almost always resulting in the allocator's
    inability to allocate memory for an application, ultimately resulting in `std::bad_alloc()`
    being thrown in C++. When programming systems, fragmentation should always be
    a concern as it can dramatically impact the stability and reliability of your
    program, especially on resource-constrained systems, such as embedded and mobile
    applications. In this section, the reader will get a brief introduction to fragmentation,
    and how it affects the programs they create.
  prefs: []
  type: TYPE_NORMAL
- en: There are two types of fragmentation—external and internal fragmentation.
  prefs: []
  type: TYPE_NORMAL
- en: External  fragmentation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'External fragmentation refers to the process by which memory is allocated and
    deallocated in different sized chunks, ultimately leading to large amounts of
    unusable, unallocatable memory. To demonstrate this, suppose we have five allocations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9fc89297-46e9-493a-994f-e7b8b2386dcf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'All five allocations succeed, and all of the memory is allocated. Now, let''s
    suppose that the second and fourth allocations are released back to the heap:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/02d7340a-fdc8-4d25-9506-74b811a03676.png)'
  prefs: []
  type: TYPE_IMG
- en: 'By releasing memory back to the heap, memory is now available for allocation
    again. The problem is that this memory is spread out due to the original 1, 3,
    and 5 allocations. Now let''s suppose we want to make a final allocation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bdfab869-a161-4d4f-ae94-adc506cc324c.png)'
  prefs: []
  type: TYPE_IMG
- en: The final allocation fails, even though there is enough free memory for the
    allocation, because the free memory is spread out – in other words, the free memory
    is fragmented.
  prefs: []
  type: TYPE_NORMAL
- en: External fragmentation, in the general case, is an extremely difficult problem
    to solve, and this problem has been studied for years, with operating systems
    implementing various approaches over time. In [Chapter 9](2a64ae97-dad4-479a-bd9f-9df2cb634b74.xhtml),
    *A Hands-On Approach to Allocators*, we will discuss how C++ allocators can be
    used to address some external fragmentation issues in your program using various
    different custom allocator patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Internal fragmentation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Internal fragmentation refers to memory being wasted during an allocation.
    For example, when we allocate an integer using `mmap()`, as we did in the preceding
    examples, `mmap()` allocates an entire page for the integer, wasting nearly 4k
    of memory in the process. This is known as internal fragmentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5e7d70c8-4671-46ec-8946-83c569822fd1.png)'
  prefs: []
  type: TYPE_IMG
- en: Like external fragmentation, the lost memory from internal fragmentation cannot
    be used for other allocations. In fact, the view of memory at a high level would
    look just like that of external fragmentation. The difference is that external
    fragmentation continuously takes large chunks of free, unallocated memory and
    breaks it up into smaller and smaller fragmented memory, which at some point becomes
    too small to be allocated in the future. Internal fragmentation would appear the
    same, but in some cases, even larger, unusable blocks of memory would appear fragmented
    throughout all of the memory. This unusable memory is not unusable because it
    isn't large enough for a given allocation, but instead because the unusable memory
    has been claimed by a smaller, previous allocation that simply doesn't use all
    of the memory that it was given.
  prefs: []
  type: TYPE_NORMAL
- en: It should be noted that when solving fragmentation issues, often the solution
    is to optimize for one type of fragmentation over another, with each choice having
    its advantages and disadvantages.
  prefs: []
  type: TYPE_NORMAL
- en: Internal over external fragmentation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Allocators used by `malloc()` and `free()` often favor optimizing for internal
    fragmentation over external fragmentation. The goal is to provide an allocator
    with as little waste as possible and then leverage various different allocation
    patterns to reduce the likelihood of external fragmentation as much as possible.
    These types of allocators are preferred for applications as they minimize the
    memory requirements of a single application on any given operating system, leaving
    the additional memory for other applications. Furthermore, if external fragmentation
    prevents an allocation from occurring, the application always asks the OS for
    more memory (until the OS runs dry).
  prefs: []
  type: TYPE_NORMAL
- en: External over internal fragmentation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Operating systems tend to optimize for external fragmentation over internal
    fragmentation. This reason for this is that operating systems generally can only
    allocate memory at the page granularity, meaning internal fragmentation in a lot
    of cases is unavoidable. Furthermore, if external fragmentation is allowed to
    occur over time, it would result in the operating system eventually crashing if
    given enough time to execute. For this reason, operating systems use allocation
    patterns such as the buddy allocator pattern, which optimize for external fragmentation,
    even at the expense of large amounts of internal fragmentation.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned various ways to allocate memory using `new()` and
    `delete()` and `malloc()` and `free()`, including aligned memory and C-style arrays.
    We looked at the difference between global memory (memory in the global space),
    stack memory (or scoped memory), and dynamically-allocated memory (memory that
    is allocated using `new()` and `delete()`). The safety concerns of `new()` and
    `delete()` were also discussed, and we demonstrated how C++ smart pointers, including
    `std::shared_ptr{}` and `std::unique_ptr{}`, may be used to prevent common instability
    issues in programs, and how they provide C++ Core Guidance support. We concluded
    this chapter with a quick review of fragmentation and how it can affect system
    programs.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will cover file inputer and output including read and
    writing to a file, and the filesystem APIs that were added by C++17.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the difference between `new()` and `new[]()`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can `delete()` be safely used to release memory back to heap that was allocated
    using `new[]()`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between global memory and static memory?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does one allocate aligned memory using `new()`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can `std::make_shared()` be used to allocate an array?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When should `std::shared_ptr{}` be used instead of `std::unique_ptr{}`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can `mmap()` be used to allocate read/execute memory?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between internal and external fragmentation?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[https://www.packtpub.com/application-development/c17-example](https://www.packtpub.com/application-development/c17-example)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.packtpub.com/application-development/getting-started-c17-programming-video](https://www.packtpub.com/application-development/getting-started-c17-programming-video)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
