- en: Replication in MySQL 8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we dived deep into MySQL 8 indexing. Indexes are an
    important entity for any database management system. They help improve SQL query
    performance by limiting the number of records to be visited. Database administrators
    working on performance improvement must be aware of this important technique.
    This chapter explains in detail the types of indexes and their advantages. This
    chapter also explains how indexing works in MySQL 8\. It's going to be a pretty
    informative chapter!
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving further along the same line, in this chapter, we will discuss database
    replication. How much are we already aware about database replication? It doesn''t
    actually matter. This chapter covers insightful details about database replication.
    If you have prior knowledge of database replication, this chapter will add to
    it. If you have only just heard about it for the first time, you will find every
    detail that is required to make it work in this chapter. So, are we ready to jump
    in? The following is a list of topics that we will be covering in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Overview of replication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring replication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing replication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Group replication versus clustering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Replication solutions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overview of replication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will walk through the basics of database replication in this section. We
    will understand what replication is, the advantages it provides, and the scenarios
    in which replication can be beneficial.
  prefs: []
  type: TYPE_NORMAL
- en: What is MySQL replication?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is assumed that you are reading this for two reasons. You're familiar with
    MySQL replication and are willing to gain more knowledge, and perhaps you're unfamiliar
    with MySQL replication and want to learn.
  prefs: []
  type: TYPE_NORMAL
- en: MySQL replication is useful for serving lots of different purposes. Usually,
    people start thinking about MySQL replication when they start having more queries
    than a single database server can handle. Based on this, do you have any guesses
    on what MySQL replication is? Replication is the technique to have more than one
    databases set up to serve single or multiple client applications. A client can
    be an end user or person who sends a request for any query in terms of read data
    or write data from different devices, such as computers, mobiles, tablets, and
    so on. These databases are replicas of the same database. This means all databases
    participating in database replication are exactly the same as each other. Replication
    works by frequently copying data from one database to all other replica databases.
    These databases may be located on the same database server, different database
    servers, or different machines altogether.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned earlier, database replication serves various purposes. It depends
    on the reason why MySQL database replication is set up. MySQL replication is set
    up to scale up a database or an application that is backed up by the database.
    It is also useful for maintaining database backups and reporting purposes. We
    will discuss these in detail a little later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: MySQL replication is mostly set up for scaling reads. In any web application,
    the number of read operations is pretty higher compared to that of write database
    operations. Most common web applications are always read heavy. Consider an example
    of a social networking website. If we navigate to a user profile page, we see
    a lot of information such as the user's personal information, demographic information, social
    connections, some ratings, and so on. If observed carefully, we will find that
    the number of `SELECT` queries executed on a database are much higher than `INSERT`,
    `UPDATE`, or `DELETE` queries. With MySQL database replication, we can direct
    read operations to be performed on particular databases so that we can achieve
    higher performance.
  prefs: []
  type: TYPE_NORMAL
- en: MySQL replication looks pretty easy and can be set up in a couple of hours,
    but it gets complicated pretty easily. It is very easy to set up on a new database.
    On the contrary, it is pretty complex to set it up on a production database. We
    should not confuse MySQL replication with a distributed database system. In a
    distributed database system, the databases hold different sets of data. Database
    operations are routed to a particular database based on some key information.
  prefs: []
  type: TYPE_NORMAL
- en: In a traditional MySQL replication, one of the databases acts as a master and
    the rest of the databases play the role of slaves. It is not always necessary
    that we have only one master database. We can have multiple master databases in
    a replication. This technique is called multi-master replication. The slaves copy
    data from master databases. The process of copying data is asynchronous in traditional
    MySQL replication. This means slave database servers are not permanently connected
    with master database servers. MySQL supports replication at different levels.
    We can replicate all master databases, selected databases, or selected tables
    from a master database in to slave databases.
  prefs: []
  type: TYPE_NORMAL
- en: MySQL 8 provides different database replication methods. MySQL 8 has a binary
    log file. The contents of the file are events describing database changes. The
    event can be of type `statement based` or `row based`. The changes include data
    definition changes and data manipulation changes or statements that can potentially
    modify the database such as `DELETE` statements. The binary log also contains
    information on how much time each SQL statement took to update the database. The
    traditional MySQL database replication method synchronizes databases from master
    to slaves based on the binary log file on the master database server. The slaves
    replicate or copy the contents of binary log file from the master database server
    based on the positions of log records in the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'MySQL 8 also supports newer database replication methods along with the one
    based on the binary log file. Every transaction committed on the MySQL 8 database
    server is treated as unique. A unique **global transaction identifier** (**GTID**)
    is associated with every committed transaction on the master database server.
    As the name suggests, the global identifier is not unique only to the master database
    server on which it is created, but across all the databases participating in MySQL
    8 replication. So, essentially, there is a 1 to 1 mapping between each committed
    transaction and global transaction identifier. The newer method of MySQL replication
    is based on the GTID. It greatly simplifies the replication process as it is not
    dependent on events from binary log files and their positions. GTID is represented
    as a pair of colon (`:`) separated coordinates, as shown in the following block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `source_id` is the identifier for database servers originated from the
    GTID. Usually, a database server''s `server_uuid` is used as the `source_id`.
    The `transaction_id` is the sequence number in which the transaction was committed
    on the database server. For example, the following example shows the GTID for
    the first committed transaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The sequence number for transactions committed starts with `1`. It can never
    be `0`.
  prefs: []
  type: TYPE_NORMAL
- en: A GTID-based MySQL replication method is transactional and so this is why it
    is more reliable than a binary log file-based replication method. GTID guarantees
    the replication accuracy and consistency between master and slave databases as
    long as all the transactions committed on master database servers have also been
    applied on all of the slave database servers.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned earlier, MySQL database replication is usually asynchronous. However,
    MySQL 8 supports different types of synchronization for replication. The usual
    method of synchronization is asynchronous. It means one server acts as a master
    database server. It writes all events to a binary log file. Other database servers
    act as slaves. Slave database servers read and copy position-based event records
    within binary log files from the master database server. So, it is always from
    a master database server to a slave database server. MySQL 8 also supports semisynchronous
    synchronization methods. In semisynchronous methods of replication, any transaction
    committed on a master database server is blocked until the master database server
    receives acknowledgement from at least one of the slave database servers that
    it has received and logged the transaction event. Delayed replication is another
    replication method supported by MySQL 8\. In delayed replication, slave database
    servers intentionally log the transaction event behind master database servers
    by some amount of time.
  prefs: []
  type: TYPE_NORMAL
- en: Advantages of MySQL replication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we are now familiar with what MySQL database replication is, it's time to
    assess if the added complexity of maintaining multiple database servers is worth
    it or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'The advantages of MySQL 8 database replication are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Scale out solutions**: As described earlier, usually web applications are
    read-heavy applications. The read operations are much higher in number than the
    write operations. The applications provide features that require heavy, complex
    SQL queries to be executed on the database server. These are not the queries that
    take milliseconds to execute. Such complex queries may take a few seconds to minutes
    for execution. Execution of such queries put up heavy load on database server.
    In such cases, it is always better to have such read operations performed on a
    separate database server than master database servers. Write database operations
    will always be performed on master database servers. Do you know why? It''s because
    it triggers database modifications. Events of these modifications must be written
    to binary log files for replication synchronization by slave servers. Also, the
    synchronization is from master to slaves. So, if we performed write database operations
    on slaves, those will never be available on master database servers. This approach
    improves performance of write operations with increased speed for read operations
    as the read operations are performed across the number of slave servers.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Data Security**: Security, in general, is an important feature that every
    web application needs. The security can on at an application layer or on a database
    layer. Data security protects against loss of data. Data security is achieved
    by backing up a database on a regular basis. If replication is not set up, backing
    up production databases requires the application to be put on maintenance mode.
    This is required because simultaneous access to a database by an application and
    the back up process may corrupt the data. With replication in place, we can use
    one of the slaves for backup. As the slave database server is always in synchronization
    with the master database server, we can back up the slave database server. For
    that, we can make the slave database server stop replicating from a master database
    server while the back up process is running. This doesn''t require the web application
    to stop using a master database server. In fact, it doesn''t impact the master
    database server in any way. Another data security aspect is to provide role-based
    access to production or master database servers. We can have only a few roles
    who can access the master database server from the backend. The rest of the users
    or roles have access to the slave database server. This reduces the risk of accidental
    data loss because of human error.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Analytics**: Analytics and reporting are always important features for a
    database backed application. These features require fetching of information from
    a database on a frequent basis so that analysis on the data can be performed.
    If database replication is set up, we can fetch the data required for analytics
    from the slave database server without affecting the master database server performance.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Long distance data distribution**: It is a common requirement for application
    developers to replicate production data on local development environments. In
    a database replication enabled infrastructure, a slave database server can be
    used to prepare database copy on a development database server without constant
    access to the master database server.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configuring replication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will learn configuration for different types of MySQL 8
    replication methods. It includes step by step instructions for setting up and
    configuring replication.
  prefs: []
  type: TYPE_NORMAL
- en: Binary log file based replication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most common traditional methods of MySQL database replication is
    the binary log file position method. This section focuses on configuration of
    the binary log file position method of replication. Before we jump into the configuration
    section, it would be good to revise and understand the basics of binary log position
    based replication.
  prefs: []
  type: TYPE_NORMAL
- en: As described earlier, one of the MySQL database servers acts as master and the
    rest of the MySQL database servers become slaves. The master database server is
    the origin for the database changes. The master database server writes events
    based on updates or changes to the database in the binary log file. The format
    of the information record being written in the binary log file varies based on
    the database change being recorded. MySQL `REPLICATION SLAVE` database servers
    are configured so that they read the binary log events from the master database
    server. Slaves execute the events on local database binary log files. This way
    slaves synchronize the database with the master database. When slave database
    servers read the binary log file from the master database server, slaves get an
    entire copy of the binary log file. Once the binary log file is received, it is
    up to the slaves to decide which statements to execute on the slave binary log
    file. It is possible to specify that all statements from the master database server
    binary log file should be executed on the slave database servers binary log file.
    It is also possible to process events filtered by particular databases or tables.
  prefs: []
  type: TYPE_NORMAL
- en: Only slave database servers can be configured to filter events from master database
    server log files. It is not possible to configure the master database server to
    log only specific events.
  prefs: []
  type: TYPE_NORMAL
- en: MySQL 8 provides a system variable that helps identify the database server uniquely.
    All the database servers participating in MySQL replication must be configured
    to have a unique ID. Each of the slave database servers must be configured with
    the master database server hostname, log file name, and position within the log
    file. Once set up, it is possible to modify these details from within a MySQL
    session using the `CHANGE MASTER TO` statement executed on the slave database
    server.
  prefs: []
  type: TYPE_NORMAL
- en: When the slave database server reads the information from the master database
    binary log file, it keeps track of a record of the binary log coordinates. The
    binary log coordinates consists of the filename and position within the file,
    which is read and processed from the master database server. The efficiency of
    slave database servers reading the binary log file from the master database server
    is very high because multiple slave database servers can be connected to the master
    database server and process different parts of the binary log file from the master
    database server. The master database server operations remain unaffected because
    the connecting and disconnecting of slave database servers from the master database
    server is controlled by slaves themselves. As mentioned earlier, each slave database
    server keeps track of the current position within the binary log file. So, it
    is possible for the slave database server to disconnect and reconnect with the
    master database server and resume the binary log file processing.
  prefs: []
  type: TYPE_NORMAL
- en: A number of methods for setting up database replication are available in MySQL.
    The exact method for replication depends on if data already exists in the database
    and how replication is being set up. Each of the following sections are a step
    for configuring MySQL replication.
  prefs: []
  type: TYPE_NORMAL
- en: Replication master configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we set up the replication master database server, it must be ensured
    that the database server has a unique ID established and binary logging is enabled.
    It may be required to restart the database server after these configurations are
    made. The master database server binary log is the basis for MySQL 8 database
    replication.
  prefs: []
  type: TYPE_NORMAL
- en: To enable binary logging, the `log_bin` system variable should be set to `ON`.
    Binary logging is enabled for a MySQL database server by default. If `mysqld`
    is used to initialize the data directory manually with a `--initialize` or `--initialize-insecure`
    option, the binary logging is disabled by default. It has to be enabled by specifying
    the `--log-bin` option. The `--log-bin` option specifies the base name to be used
    for the binary log files.
  prefs: []
  type: TYPE_NORMAL
- en: If the filename is not specified with the startup option, the binary log filenames
    will be set based on the database server hostname. It is recommended that the
    binary log filename is specified with the `--log-bin` option. If the log filename
    is specified with `--log_bin=old_host_name-bin`, the log filename will be retained
    even after the database server host is changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'To set up the master database server, open the MySQL configuration file on
    the master database server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the configuration file, make the following changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, find the section that binds the server to localhost:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace the local IP address with the actual database server IP address. This
    step is important because the slaves can access the master database server using
    the public IP address of the master database server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The following changes are required to configure a unique ID for the master
    database server. It also includes the configuration required for setting up the
    master binary log file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s configure the database to be replicated on the slave database servers.
    If more than one database is required to be replicated on slave database servers,
    repeat the following line multiple times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Once these changes are done, restart the database server using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have the master database server set up. The next step is to grant privileges
    to the slave user as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The preceding commands creates the slave user, grants privileges on the master
    database server, and flushes database cached privileges.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we have to back up the database that we want to replicate. We will back
    up the database using the `mysqldump` command. This database will be used for
    creating the `slave` database. The master status output displays the name of the
    binary log filename, current position, and the name of the database to be replicated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Before we take the database backup using the `mysqldump` command, we have to
    lock the database to check the current position. This information will be used
    later to set up the slave database server.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the database dump is taken, the database should be unlocked using the
    following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We are done with all the configuration required to set up a replication master
    database server and make it accessible by the `REPLICATION SLAVE` database servers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following options have an impact on the master database server setup:'
  prefs: []
  type: TYPE_NORMAL
- en: '`innodb_flush_log_at_trx_commit=1` and `sync_binlog=1` options should be set
    to achieve higher durability and consistency. The options can be set in the `my.cnf`
    configuration file.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `skip-networking` option must not be enabled. If it is enabled, the slave
    cannot communicate with the master and database replication fails.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: REPLICATION SLAVE configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Similar to the master database server, each slave database server must have
    a unique ID. Once set up, this will require database server restart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: For setting up multiple slave database servers, a unique non zero `server-id`
    must be configured that is different from that of master or any other slave database
    servers. Binary logging on a slave database server is not required for replication
    to be set up. If enabled, a binary log file on a slave database server can be
    used for database backups and crash recovery.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, create a new database that will become the replica of the master database
    and import the database from the database dump prepared from the master database
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have to configure a few other options in the `my.cnf` file. Like the
    binary log, a relay log consists of numbered files with database change events
    as contents of the file. It also contains an index file that has the names of
    all the used relay log files. The following configurations set the relay log file,
    binary log file, and name of the slave database, which is a replica of the master
    database as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'A database server restart is required after this configuration change. The
    next step is to enable slave replication from within MySQL shell prompt. Execute
    the following command to set the `master` database information required by the
    `slave` database server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'As a final step, activate the slave server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'If the binary logging is enabled on the `slave` database server, a slave can
    participate in a complex replication strategy. In such a replication setup, database
    server `A` acts as a master for database server `B`. `B` acts as a slave to the `A`
    `master` database server. Now, `B` in turn can act as a master database server
    for the `C` `slave` database server. Something like this can be seen as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Adding slaves to replication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is possible to add a new slave database server to an existing replication
    configuration. This doesn't require the master database server to be stopped.
    The approach should be to make a copy of an existing `slave` database server.
    Once copied, we have to modify the value for a `server-id` configuration option.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following instructions set up a new slave database to an existing replication
    configuration. First, an existing slave database server should be shut down as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Now, a data directory from the existing slave should be copied to the new slave
    database server. Along with the data directory, binary logs and relay log files
    must be copied as well. It is recommended to use the same value for `--relay-log`
    for the new slave database server as that of the existing slave database server.
  prefs: []
  type: TYPE_NORMAL
- en: If the master info and relay log info repositories use files then those files
    must be copied from an existing slave database server to a new slave database
    server. These files hold a master's current binary log coordinates and a slave's
    relay logs.
  prefs: []
  type: TYPE_NORMAL
- en: Now, start the existing slave server that was stopped earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we should be able to start the new slave database server. We must have
    the unique `server-id` configured before starting the new slave server, if it
    is not set up already.
  prefs: []
  type: TYPE_NORMAL
- en: Global transaction identifiers based replication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section focuses on global transaction identifiers based replication. It
    explains how GTIDs are defined, created, and represented in MySQL server. It describes
    the procedure for setting up and starting GTID-based replication.
  prefs: []
  type: TYPE_NORMAL
- en: 'With GTID-based replication, each transaction is assigned a unique transaction
    ID as it is committed to the originating database server, known as **GTID**. The
    unique identifier is global, which means it is unique across all the database
    servers participating in replication. With GTID, it is easier to track and process
    each transaction as it is committed on to a `master` database server. With this
    replication method, it is not necessary to rely on the log files for synchronization
    between `master` and `slave` databases. It is also easier to identify if the `master`
    and `slave` databases are consistent as this method of replication is transaction
    based. Consistency between master and slave databases is guaranteed as long as
    all the transactions committed on the `master` database are applied on the slave
    databases as well. Either statement-based or row-based replication can be used
    with GTID. As mentioned earlier, GTID is represented with a pair of coordinates
    separated by colons (`:`), as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The advantages of using the GTID based replication method are:'
  prefs: []
  type: TYPE_NORMAL
- en: With this method of replication, it is possible to switch the master database
    server in the event of server failover. The global transaction identifier is unique
    across all participating database servers. The slaves maintain track of the last
    executed transaction using GTID. This means if the master database server is switched
    over to a new database server, it is a little easier for slaves to continue with
    the new master database server and resume the replication processing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The state of the slave database server is maintained in a crash-safe way. With
    the newer replication technique, `slave` database server keeps track of the current
    position in a system table named `mysql.gtid_slave_pos`. Using a transactional
    storage engine such as `InnoDB`, updates to the state are recorded within the
    same transaction as that of the database operation. So, if the slave server goes
    down, on booting up again, the slave server starts the crash recovery and makes
    sure that the recorded replication position matches the replicated changes. This
    is not possible with traditional binary log file based replication because the
    relay log file that is updated independently of the actual database changes can
    easily go out of synchronization if the slave server crashes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Before diving into the GTID based replication configuration, let's understand
    a few more terms.
  prefs: []
  type: TYPE_NORMAL
- en: 'A `gtid_set` is a set of global transaction identifiers. It is represented
    in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: There are several ways in which GTID sets are used. System variables `gtid_executed`
    and `gtid_purged` are represented with GTID sets. The MySQL functions `GTID_SUBSET()`
    and `GTID_SUBTRACT()` require GTID sets as input parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Both master and slave database servers preserve GTIDs. Once a transaction is
    committed with one GTID on one server, any subsequent transaction with similar
    GTID is ignored by that server. This means a transaction committed on a `master`
    database server can only be committed or applied on a `slave` database server
    only once. This helps to maintain the consistency between `master` and `slave`
    databases.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a summary of the lifecycle of a GTID:'
  prefs: []
  type: TYPE_NORMAL
- en: A transaction is executed and committed on the master database server. This
    transaction is assigned a GTID using the master's UUID. The GTID is written to
    the binary log file of a master database server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the binary log file is received by the slave and recorded in the the slave's
    relay log, the slave sets the value of the `gtid_next` system variable to the
    GTID read. This indicates to `slave` that the next transaction to be executed
    is the one with this GTID.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `slave` database server maintains its set of GTID for already processed
    transactions in a binary log file. Before applying the transaction with GTID indicated
    by `gtid_next`, it checks if the GTID is recorded or logged in its binary log
    file. If the GTID is not found in the binary log file, the slave processes the
    transaction associated with the GTID and writes the GTID in the binary log file.
    This way the slave guarantees that the same transaction is not executed more than
    once.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s now move to the master configuration for GTID-based MySQL replication.
    As a first step, open the `my.cnf` file and make the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: These configuration changes require server restart. The preceding configurations
    are self-explanatory. The `gtid_mode` option enables the GTID based database replication.
  prefs: []
  type: TYPE_NORMAL
- en: Now, create a user for accessing the master database from the slave database
    server. Also, take a database backup using the `mysqldump` command. The database
    backup will be used for setting up the slave database server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This is all for the master database configuration. Let's move onto the slave
    side of configurations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the shell prompt on the `slave` database server, import the database
    from the `master` database server backup as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, add the following configurations in the `my.cnf` file on the slave:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Once these configurations are made, restart the database server using the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to set up master database server information on the `slave`
    database server using the `CHANGE MASTER TO` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, start the `slave` server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In this replication method, the master database backup already has GTID information.
    So, we just need to provide the position from which the slave server should start
    synchronizing.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is done by setting up the `GTID_PURGED` system variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: MySQL multi-source replication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section focuses on replicating from multiple immediate masters in parallel.
    The method is known as **multi-source replication**. With multi-source replication,
    a `REPLICATION SLAVE` receives transactions from multiple sources at the same
    time. A channel is created by a `REPLICATION SLAVE` for each `master` from which
    it should receive transactions.
  prefs: []
  type: TYPE_NORMAL
- en: The multi-source replication configuration requires at least two masters and
    a slave to be configured. The masters can be configured using binary log position
    based replication or GTID-based replication. Replication repositories are stored
    in `FILE` or `TABLE` based repositories. A `TABLE` based repository is crash safe.
    MySQL multi-source replication requires a `TABLE` based repository. There are
    two ways to set up a `TABLE` repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'One is to start `mysqld` with options as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Another preferred way of doing this is to modify the `my.cnf` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'It is possible to modify an existing `REPLICATION SLAVE` that is using a `FILE`
    repository to use a `TABLE` repository. The following commands convert the existing
    repositories dynamically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The following commands can be used to add a new GTID-based replication master
    to an existing multi-source `REPLICATION SLAVE`. It adds a master to the existing
    slave channel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The following commands can be used to add a new binary log file position based
    replication master to an existing multi-source `REPLICATION SLAVE`. It adds a
    master to the existing slave channel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The following commands `START`/`STOP`/`RESET` all the configured replication
    channels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The following commands `START`/`STOP`/`RESET` a named channel using a `FOR
    CHANNEL` clause:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Replication administration tasks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section describes a few commonly required MySQL replication administrative
    tasks. Usually, once set up, MySQL replication doesn't require regular monitoring.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the most common tasks is to ensure that replication is taking place
    without errors between master and slave database servers. A `SHOW SLAVE STATUS`
    MySQL statement is used for this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding output, a few of the key fields are explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Slave_IO_State`: Current state of the slave'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Slave_IO_Running`: Indicates if the I/O thread for reading a master''s log
    file is running'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Slave_SQL_Running`: Indicates if the SQL thread for executing events is running'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Last_IO_Error, Last_SQL_Error`: Last errors reported by I/O or SQL threads
    processing the relay thread'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Seconds_Behind_Master`**:** Indicates the number of seconds the slave SQL
    thread is running behind the master processing the master binary log'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can check the status of connected slaves using a `SHOW_PROCESSLIST` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The `SHOW_SLAVE_HOSTS` statement, when executed on master, provides information
    about slaves as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Another important replication administrative task is to be able to start or
    stop the replication on a `slave` database server. The following commands are
    used to do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'It is also possible to stop and start individual threads by specifying the
    type of the thread as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Implementing replication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The basis for replication is that the master database server keeps track of
    all the changes taking place on the master database. The changes are tracked in
    the binary log files in the form of events since the server was started. `SELECT`
    operations are not recorded as they modify neither the database nor the contents. Each
    of the `REPLICATION SLAVE` pull a copy of the binary log file from `master` instead
    of a master database pushing the log file to the `slave`. The slave in turn executes
    the events as it is read from the master's binary log file. This maintains the
    consistency between `master` and `slave` servers. In MySQL replication, each `slave`
    functions independently from `master` and other `slave` servers. So, it is up
    to the slave to request the master's binary log file at a convenient time without
    impacting the `master` or `slave` functioning.
  prefs: []
  type: TYPE_NORMAL
- en: The focus for this section of the chapter is on MySQL replication details. We
    have already understood the basics, which will help us understand the in depth
    details.
  prefs: []
  type: TYPE_NORMAL
- en: Replication formats
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we already know by now, MySQL replication works based on replicating events
    from the master server generated binary logs. Later, these events are read and
    processed by the slave. What we do not yet know is the format in which the events
    are recorded in binary log files. Replication formats is the emphasis of this
    section.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the events are recorded in the master''s binary log files, the replication
    format used depends on the binary log format used. Basically, two binary logging
    formats exist: statement based and row based.'
  prefs: []
  type: TYPE_NORMAL
- en: With statement-based binary logging, SQL statements are written in the master's
    binary log file. Replication on the slave works by executing the SQL statements
    on the `slave` database. This approach is called **statement-based** replication.
    It corresponds with the MySQL statement-based binary logging format. This was
    the only traditional format that existed until MySQL versions 5.1.4 and earlier.
  prefs: []
  type: TYPE_NORMAL
- en: With row-based binary logging, the events written in the master binary log indicate
    how individual table rows changed. Replication in this case works by the slave
    copying the events representing changes to the table rows. This is called row-based
    replication. Row-based logging is the default MySQL replication method.
  prefs: []
  type: TYPE_NORMAL
- en: MySQL supports configuration to mix statement-based and row-based logging. The
    decision to use the logging format depends on the change being logged. This is
    known as mixed-format logging. Statement-based logging is the default format when
    mixed-format logging is used. Based on the type of statements and storage engine
    being used, the log automatically switches to row-based format. Replication based
    on the mixed logging format is known as **mixed-format** replication.
  prefs: []
  type: TYPE_NORMAL
- en: The `binlog_format` system variable controls the logging format used in a running
    MySQL server. `SYSTEM_VARIABLES_ADMIN` or `SUPER` privileges are required to set
    the `binlog_format` system variable at a session or global scope.
  prefs: []
  type: TYPE_NORMAL
- en: Statement-based versus row-based replication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the earlier section, we learned three different logging formats. Each one
    of these has its own advantages and disadvantages. In usual cases, mixed format
    should provide the best combination of integrity and performance. However, to
    achieve the best performance from either statement-based or row-based replication,
    the advantages and disadvantages described in this section are helpful.
  prefs: []
  type: TYPE_NORMAL
- en: Statement-based replication is a traditional and proven technique in comparison
    with row-based replication. The number of records or events recorded in the log
    files is smaller. If a statement impacts many rows, only one statement will be
    written to the binary log file. In case of row-based replication, a record will
    be entered for every table row modified though as part of the single statement.
    In essence, this means statement-based replication requires much less storage
    space for log files. It also means backing up and restoring or replicating the
    events is much quicker.
  prefs: []
  type: TYPE_NORMAL
- en: 'Along with the advantages described previously, statement-based replication
    has disadvantages as well. As the replication works based on the SQL statements,
    it is possible that not all the statements that modify data can be replicated
    with statement-based replication. A few examples are described as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: SQL statements depend on a user-defined function that is non-deterministic when
    the value returned by such user-defined functions depend on factors other than
    the parameters supplied to it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UPDATE` and `DELETE` statements with a `LIMIT` clause without an `ORDER BY`
    clause is non-deterministic as it is possible that the order may have changed
    while replicating.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FOR UPDATE` or `FOR SHARE` locking read statements that use `NOWAIT` or `SKIP
    LOCKED` options.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User-defined functions must be applied on the slave databases.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SQL statements using functions such as `LOAD_FILE()`, `UUID()`, `USER()`, `UUID_SHORT()`,
    `FOUND_ROWS()`, `SYSDATE()`, `GET_LOCK()`, and so on cannot be replicated properly
    using statement-based replication.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`INSERT` or `SELECT` statements require higher number of row level locks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UPDATE` with table scan requires locking a higher number of rows.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Complex SQL statements must be evaluated and executed on the slave database
    server before rows are inserted or updated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's see advantages provided by row-based replication. Row-based replication
    is the safest form of replication because instead of depending on SQL statements,
    it depends on the values stored in the table rows. So, every change can be replicated.
    It requires fewer row locks in case `INSERT...SELECT` statements. `UPDATE` and
    `DELETE` statements with `WHERE` clauses that do not use keys require fewer row
    level locks.
  prefs: []
  type: TYPE_NORMAL
- en: The major disadvantage with row-based replication is that it generates more
    data that must be logged. With statement-based replication, one DML SQL statement
    is sufficient for logging though it modifies many rows. In case of row-based replication,
    it requires logging for every row that changed. The binary log file grows very
    quickly with row-based replication. It takes longer time to replicate deterministic
    user defined functions that generate large `BLOB` values.
  prefs: []
  type: TYPE_NORMAL
- en: Replication implementation details
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are three threads that participate in implementing replication in MySQL.
    Out of these three threads, one is on the master server and the two others are
    on the `slave` database server. Let''s dive into the details of these threads:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Binlog dump thread**: When the slave database server requests the binary
    log file, the master server is responsible for sending the contents to the slave
    database server. To accomplish this, the master database server creates a thread
    when the slave database server connects to the master database server. The `binlog`
    dump thread sends the binary log contents to the slave database server. In the
    output of the `SHOW PROCESSLIST` command on the master database server, this thread
    can be identified as the `Binlog Dump` thread. The `binlog` dump thread locks
    the binary log file on the master for reading each event that is to be sent to
    the slave database server. The lock is released as soon as the event is read,
    even before it is sent to the slave database server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Slave I/O thread:** The primary responsibility of the slave I/O thread is
    to request binary log updates from the master database server. The slave database
    server creates the I/O thread when a `START SLAVE` command is executed. The thread
    connects to the master database server and requests to send updates from the binary
    logs. Once the contents are sent by the master''s `binlog` dump thread, the slave
    I/O thread reads the contents and copies those to the local files including the
    slave''s relay log. The status of this thread can be obtained in the output of
    `SHOW SLAVE STATUS` or `SHOW STATUS` commands.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Slave SQL thread:** The slave I/O thread writes the events in the slave''s
    relay logs. It is the responsibility of the slave SQL thread to execute those
    events on the slave database server. The slave SQL thread reads the events in
    the relay logs written by a slave I/O thread and executes them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Based on the preceding description, every master-slave connection pair creates
    three threads. If a master has more than one `slave` databases servers, it creates
    one dedicated binary log dump thread for each slave connected currently. On the
    other end, each slave creates its own I/O and SQL threads. Why does the slave
    database server create two separate threads, one for writing the events and another
    one for executing the events? The reason is that with this approach, the task
    of reading the statements is not slowed down by the executing of the statements.
    Considering the slave server is not running, its I/O thread quickly fetches all
    the binary logs from a master database when the `slave` server starts regardless
    of the SQL thread lags behind. Also, if the `slave` database server stops before
    the SQL thread can execute all of these statements, the statements are recorded
    in the slave relay logs. So, when the slave starts again, the SQL thread can execute
    those statements. So, relay logs work as a safe copy of the statements read from
    the master database server.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `SHOW PROCESSLIST` statement provides information about what is happening
    on the `master` or the `slave` database servers. The output of the statement when
    executed on the `master` database server looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The preceding output shows that thread 2 is the master's `binlog` dump thread.
    The state indicates that all the recent updates have been sent to the slave.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a `SHOW PROCESSLIST` statement is executed on the slave database server,
    the output looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: In the output, thread 10 is the slave's I/O thread and thread 11 is the slave's
    SQL thread. The I/O thread is waiting for the master's `binlog` dump thread to
    send binary log contents. The SQL thread has read all the statements logged in
    the `slave` relay logs. From the `Time` column, it can be determined how slow
    the `slave` is running behind the `master`.
  prefs: []
  type: TYPE_NORMAL
- en: Replication channels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A replication channel is a path of transaction flow from a master to a slave.
    This section explains how channels can be used in replication. The MySQL server
    automatically creates a default channel with the name as `""` (empty string) on
    startup. The default channel is always present and can't be created or destroyed
    by the user. Replication statements work on the default channel if no other channel
    is created. This section describes statements that are applied to replication
    channels when there exists at least one named channel.
  prefs: []
  type: TYPE_NORMAL
- en: In multi-source replication, the `slave` database server opens multiple channels,
    one for each master. Each channel has its own relay log and SQL threads. The replication
    channel has a hostname and port association. Multiple channels can be assigned
    to the same hostname and port combination. A maximum of 256 channels can be added
    to one slave in a multi-source replication topology in MySQL 8\. The channel must
    have a nonempty unique name.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `FOR CHANNEL` clause is used with various MySQL statements for the replication
    operations to be performed on individual channels. The clause can be applied to
    the following statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CHANGE MASTER TO`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`START SLAVE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`STOP SLAVE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RESET SLAVE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SHOW RELAYLOG EVENTS`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FLUSH RELAY LOGS`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SHOW SLAVE STATUS`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Apart from these, the following functions have an additional channel parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '`MASTER_POS_WAIT()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For multi-source replication to work correctly, the following startup options
    must be configured:'
  prefs: []
  type: TYPE_NORMAL
- en: '`--relay-log-info-repository`: As described earlier, this must be set to `TABLE`
    for multi-source replication. In MySQL 8, the `FILE` option is deprecated and
    `TABLE` is the default option.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--master-info-repository`: This must be set to `TABLE`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--log-slave-updates`: Transactions received from the master are written to
    the binary logs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--relay-log-purge`: Each channel purges its own relay logs automatically.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--slave-transaction-retries`: SQL threads of all channels retry transactions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--skip-slave-start`: No replication threads start on any channels.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--slave-skip-errors`: Execution continues and errors are skipped for all channels.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--max-relay-log-size=size`: The relay log file is rotated after reaching the
    maximum size.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--relay-log-space-limit=size`: Upper limit for total size of all relay logs
    for each individual channel.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--slave-parallel-workers=value`: Number of slave parallel workers per channel.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--slave-checkpoint-group`: Waiting time by I/O thread.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--relay-log-index=filename`: Each channel''s relay log index filename.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--relay-log=filename`: Each channel''s relay log filename.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--slave-net-timeout=N`: Each channel waits for N seconds to check for broken
    connection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--slave-skip-counter=N`: Each channel skips N events from the master.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Replication relay and status logs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `REPLICATION SLAVE` server creates logs that hold the binary log events
    sent from the master database server to the slave database server. The information
    is recorded about the current status and location in the relay log. Three types
    of logs are used in this process:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Relay log**: The relay log has events sent from the master''s binary log.
    The events are written by a slave''s I/O thread. Events from the slave''s relay
    log are executed on the slave by the slave''s SQL thread.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Master info log**: The master info log has information about status and current
    configuration for the slave''s connection to the master database server. The information
    held by the master info log includes hostname, login credentials, and coordinates
    indicating a slave''s position on reading the master''s binary log. These logs
    are written to the `mysql.slave_master_info` table.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Relay log info log**: The relay log info log stores information regarding
    the execution point within the slave''s relay log. The relay log info log is written
    in a `mysql.slave_relay_log_info` table.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: No attempt should be made to insert or update rows in the `slave_master_info`
    or `slave_relay_log_info` tables manually. This may cause unexpected behavior.
    It is not supported in MySQL replication.
  prefs: []
  type: TYPE_NORMAL
- en: The slave relay log consists of an index file along with a set of numbered log
    files. The index file contains the names of all relay log files. MySQL data directory
    is the default location for the relay log files. The relay log file indicates
    an individually numbered file containing events. Whereas the relay log denotes
    the set of numbered relay log files and an index file collectively. The format
    for relay log files is the same as that of the binary log files. The index filename
    for relay log is `host_name-relay-bin.index` by default for the default channel
    and `host_name-relay-bin-channel.index` for non-default replication channels.
    The default locations for the relay log file and relay log index file can be overridden
    with the `--relay-log` and `--relay-log-index` server startup options. If the
    slave's hostname is changed after replication has been set up and the slave uses
    default host-based relay log filenames, it can throw errors such as **Failed to
    open the relay log** and **Could not find target log** during relay log initialization.
    This may fail the replication. Such errors may be avoided by using `--relay-log`
    and `--relay-log-index` options to specify relay log filenames explicitly. Using
    these options on slave setup will make the names independent of the server's hostname.
  prefs: []
  type: TYPE_NORMAL
- en: Evaluating replication filtering rules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section focuses on the filtering rules and how servers evaluate these rules.
    Basically, if the master doesn't log the statement, the slave doesn't replicate
    the statement. If the master logs the statement in its binary log file, the slave
    receives the statement. However, it is up to the slave database server if it processes
    the statement or ignores it. Options are available for the master server to control
    which databases and tables should be replicated on the slaves. The recommended
    way is to use filters on the slave to control the events that are to be executed
    on the slave database server. The decision about whether to execute or ignore
    the statements received from the master are made based on the `--replicate-*`
    options used when the slave was started. Once the slave server is started, the
    `CHANGE REPLICATION FILTER` statement can be used to set the options dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: All replication filtering options follow the same rules for case sensitivity
    as names of databases and tables, including the `lower_case_table_names` system
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: Group replication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section of the chapter explains what group replication is, setting up group
    replication, configure and monitor group replication. Basically, MySQL group replication
    is a plugin that enables us to create elastic, highly-available, fault-tolerant
    replication topologies.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of the group replication is to create a fault tolerant system. To
    create a fault tolerant system, the components should be made redundant. The component
    should be removed without impacting the way system operates. There are challenges
    in setting up such a system. The complexity of such a system is of a different
    level. Replicated databases require maintenance and administration of several
    servers instead of just one. The servers cooperate together to create a group,
    which raises the problems related to network partitioning and split-brain scenarios.
    So, the ultimate challenge is to have agreement from multiple servers on the state
    of the system and data after every change applied on the system. This means that
    the servers need to operate as a distributed state machine.
  prefs: []
  type: TYPE_NORMAL
- en: MySQL group replication can provide such a distributed state machine replication
    with strong coordination between servers. The servers that belong to the same
    group coordinate themselves automatically. In a group, only one server accepts
    updates at a time. The election of primary is done automatically. This mode is
    known as single-primary mode.
  prefs: []
  type: TYPE_NORMAL
- en: MySQL provides a group membership service, which is responsible for keeping
    the view of the group consistent and available for all servers. The view is kept
    updated when the servers join or leave the group. In case, any of the servers
    leaves the group unexpectedly, the failure detection mechanism notifies the group
    about view change. This behavior is automatic.
  prefs: []
  type: TYPE_NORMAL
- en: The majority of the group members have to agree on the order of the transaction
    to commit in the global sequence of transactions. It is up to the individual server
    to decide whether the transaction should be committed or aborted, but all servers
    make the same decision. The system does not proceed until the members are unable
    to reach to agreement as a result of split due to network partition. This means
    the system has built-in, automatic, split-brain protection mechanism. All this
    is done by **Group Communication System** (**GCS**) protocols. It provides a failure
    detection mechanism, group membership service, safe and completely ordered message
    delivery. The implementation of the Paxos algorithm is at the core of this technology,
    which acts as the group communication engine.
  prefs: []
  type: TYPE_NORMAL
- en: Primary-secondary replication versus group replication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section focuses on some background details of how replication works. This
    will be useful in understanding the requirements for group replication and how
    it is different from the classic asynchronous MySQL replication.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure showcases how traditional asynchronous primary-secondary
    replication works. The primary is the master and the secondary is one or more
    slaves connected to the master, as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c962f92a-671d-4742-8fc1-ea98b5b2f01a.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1\. MySQL Asynchronous Replication
  prefs: []
  type: TYPE_NORMAL
- en: 'MySQL also supports semi synchronous replication in which the **master** waits
    for at least one of the slaves to acknowledge the transaction receipt:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b0c8f60a-a410-4436-83c2-d95c133dec8c.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2\. MySQL Semisynchronous Replication
  prefs: []
  type: TYPE_NORMAL
- en: The blue arrows in the figures indicate the messages passed between servers
    and the client application.
  prefs: []
  type: TYPE_NORMAL
- en: 'With group replication, a communication layer is provided that guarantees atomic
    messages and total order message delivery. All read-write transactions are committed
    only after they are approved by the group. The read only transactions are committed
    immediately as it does not need coordination. So, in group replication, the decision
    to commit a transaction or not is not unilateral by the originating server. When
    the transaction is ready for commit, the originating server broadcasts the write
    values and corresponding write set. All servers receive the same set of transactions
    in the same order. So, all servers apply the same transactions in the same order.
    This way all servers remain consistent within the group:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e67efdc9-e8c3-4196-ab3f-6207e02ddd58.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3\. MySQL Group Replication Protocol
  prefs: []
  type: TYPE_NORMAL
- en: Group replication configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section focuses on configuring group replication.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, open the `my.cnf` configuration file and add the following entries
    in the `mysqld` section as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: These are general configurations related to global transaction IDs and binary
    logging required for group replication.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to set up group replication configurations. These configurations
    include group UUID, group members white listing, and indicating seed members:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The following configuration is required for deciding whether a single-master
    group or multi-master group is to be set up. For enabling the multi-master group,
    uncomment
  prefs: []
  type: TYPE_NORMAL
- en: '`loose-group_replication_single_primary_mode` and'
  prefs: []
  type: TYPE_NORMAL
- en: '`loose-group_replication_enforce_update_everywhere_checks` directives. It will
    set up a multi-master or multi-primary group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: It must be ensured that these configurations are the same on all the servers.
    Any changes to these configurations require MySQL groups to be restarted.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following configurations are different on each of the servers in the group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The `server-id` must be unique across all servers in the group. The port 33061
    is the one used by members to coordinate for group replication. MySQL server restart
    is required after these changes are made.
  prefs: []
  type: TYPE_NORMAL
- en: 'If not already done, we have to allow access to these ports using the following
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to create a replication user and enable the replication plugin.
    The replication user is required for each server to establish group replication.
    We need to turn binary logging off during the replication user creation process
    as the user will be different for each server, as shown in the following block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, use `CHANGE MASTER TO` to configure the server to use the credentials
    for the `group_replication_recovery` channel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we are all set to install the plugin. Connect to the server and execute
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the following statement to verify if the plugin is activated or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to start up the group. Execute the following statements on
    one member of the group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can start group replication on another server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'We can check the group members list using the following SQL query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Group replication use cases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The MySQL group replication feature provides a way to build fault tolerant systems
    by replicating the state of the system throughout a set of servers. The group
    replication system stays available as long as the majority of servers are functioning
    even if some of the servers fail. Server failures are tracked by a group membership
    service. The group membership service relies on the distributed failure detector,
    which signals if any server leaves the group, voluntarily or due to unexpected
    halt. The distributed recovery procedure ensures that when the servers join the
    group, they are brought up to date automatically. Therefore, continuous database
    service is guaranteed with MySQL group replication. There is one problem though.
    Although the database service is available, the clients connected to it must be
    redirected to a different server when the server crashes. The group replication
    does not attempt to resolve it. It should be dealt with by a connector, load balancer,
    router, or some other middleware.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the typical use cases of MySQL group replication:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Elastic replication**: Group replication is suitable for fluid environments
    where the number of servers grow or shrink dynamically with minimum side effects.
    The example is cloud-based database services.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Highly available shards**: MySQL group replication can be used to implement
    highly available write scale-out shards where each replication group maps to one
    shard.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Alternative to master-slave replication**: Group replication can be an answer
    to contention problems arising in certain situations with single master server
    replication.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Autonomic systems**: MySQL group replication can be deployed for the automation
    built into the replication protocol.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Replication solutions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MySQL replication is useful in many different scenarios to fulfill a range of
    purposes. This section focuses on specific use cases and provides general information
    on how to use the replication.
  prefs: []
  type: TYPE_NORMAL
- en: One of the major use cases is to use replication for backup purposes. The data
    from the `master` can be replicated on the `slave` database server and then the
    data on the slave can be backed up. The `slave` database server can be shut down
    without affecting the operations running on the `master` database server.
  prefs: []
  type: TYPE_NORMAL
- en: Another use case is to handle unexpected halt of the `REPLICATION SLAVE`. To
    accomplish this, once the `slave` restarts, the I/O thread must be able to recover
    information about the transactions received and the transactions that are executed
    by the SQL thread. This information is stored in the `InnoDB` tables. As the `InnoDB`
    storage engine is transactional, it is always recoverable. As mentioned earlier,
    for MySQL 8 replication to use tables, `relay_log_info_repository` and `master_info_repository`
    must be set to `TABLE`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a row-based replication, it is possible to monitor the current progress
    of the slave''s SQL thread. It is done through performance schema instrument stages.
    To track the progress of all three row-based replication event types, use the
    following statement to enable three performance schema stages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The MySQL 8 replication process can work even though the source table on the
    master and the destination table on the slave uses different engine types. The
    `default_storage_engine` system variable is not replicated. This is a huge advantage
    in replication wherein different engine types can be used for different replication
    scenarios. An example is a scale-out scenario where we want all read operations
    to be performed on the slave database server, whereas all write operations should
    be performed on the master database server. In such a case, we can use a transactional
    `InnoDB` engine on the master and a non-transactional `MyISAM` engine type on
    the slave database server.
  prefs: []
  type: TYPE_NORMAL
- en: Consider an example of an organization that wants to distribute sales data to
    different departments to spread the load for data analysis. MySQL replication
    can be used to have a single master replicate different databases to different
    slaves. This can be achieved by limiting the binary log statements by using the
    `--replicate-wild-do-table` configuration option on each slave.
  prefs: []
  type: TYPE_NORMAL
- en: Once MySQL replication is set up, as the number of slaves connected to the master
    increase, the load also increases. The network load on the master also increases
    as each slave is supposed to receive a full copy of the binary logs. The master
    database server is also busy processing requests. In this scenario, it becomes
    necessary to improve the performance. One of the solutions to improve performance
    is to create a deeper replication structure that enables replication of a master
    to only one slave. The rest of the slaves connect to the primary slave for their
    operations.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned insightful details about MySQL 8 replication, what
    replication is, and how it helps solve specific problems. We also learned how
    to set up statement-based and row-based replication types. Along the way, we also
    learned about the system variables and server start up options for replication.
    In the later part of the chapter, we dived deep into group replication and how
    it is different from the traditional method of MySQL replication. We also learned
    logging and replication formats. Last but not least, we learned different replication
    solutions in brief. We covered a lot of stuff, huh?
  prefs: []
  type: TYPE_NORMAL
- en: It's now time to move on to our next chapter, where we will be setting up several
    types of partitioning, and exploring the selection of partitioning, and pruning
    of partitioning. It also explains how to cope with restrictions and limitations
    while partitioning. The reader will be able to understand which type of partitioning
    suits a situation as per the requirement.
  prefs: []
  type: TYPE_NORMAL
