- en: Using StaticRouter in a Server-Side Rendered React Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Server-Side Rendering** (**SSR**) is a technique of rendering client-side
    only **single-page applications** (**SPAs**) on the server and sending the fully
    rendered page as a response to the user''s request. In client-side SPAs, the JavaScript
    bundle is included as a script tag, and, initially, no content is rendered in
    the page. The bundle is first downloaded, and then the DOM nodes are populated
    by executing the code in the bundle. There are two downsides to this—on poor connections,
    it might take more time to download the bundle, and the crawlers that don''t execute
    JavaScript will not be able to see any content, thus affecting the page''s SEO.'
  prefs: []
  type: TYPE_NORMAL
- en: SSR solves these problems by loading HTML, CSS, and JavaScript in response to
    the user's request; the content is rendered on the server and the final HTML is
    given to the crawler. A React application can be rendered on the server using
    Node.js and the components available in React-Router can be used to define routes
    in the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will take a look at how React-Router components can be
    used in a server-side rendered React application:'
  prefs: []
  type: TYPE_NORMAL
- en: Performing SSR of a React application using Node.js and Express.js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding `<StaticRouter>` component and creating routes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the `<StaticRouter>` props
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating Isomorphic React applications by rendering the first page on the server
    and then allowing the client-side code to take over the rendering of subsequent
    pages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing SSR of a React application using Node.js and Express.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this example, we will use Node.js and Express.js to create a server-side
    application that will render the React application on the server. Node.js is a
    cross-platform JavaScript runtime environment for servers and applications. It
    is built on Google's V8 JavaScript engine, and it uses an event-driven, non-blocking
    I/O model, which makes it efficient and lightweight. Express.js is one of the
    most popular routing and middleware web-framework modules used in the Node.js
    environment. It allows you to create middleware that helps with handling HTTP
    requests from clients.
  prefs: []
  type: TYPE_NORMAL
- en: Installing dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s first create a server-side application using the `npm init` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This will create a file, `package.json`, with default values for various fields.
    The next step is to add dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command will add all the necessary libraries to the `dependencies`
    list in the package.json file. Please note that we are not creating a React application
    using the `create-react-app` CLI; instead, we will add the required dependencies
    and write the configuration files for building the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'To build the application, the following dev dependencies are added to the `devDependencies`
    list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command will add the libraries required to build the application
    for the `devDependencies` list in the `package.json` file.
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to write a build configuration, so that the server-side application
    can be built.
  prefs: []
  type: TYPE_NORMAL
- en: Webpack build configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is from Webpack''s documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: At its core, **W****ebPack** is a *static module bundler* for modern JavaScript
    applications. When webpack processes your application, it internally builds a *dependency
    graph* which maps every module your project needs and generates one or more *bundles*.
  prefs: []
  type: TYPE_NORMAL
- en: Webpack has become the de facto standard for creating bundles for JavaScript
    applications. The `create-react-app` CLI includes scripts that internally use `webpack`
    to create bundles for development and production environments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file called `webpack-server.config.babel.js`, and include the following
    configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: From the preceding configuration, the file `index.js` (at the `./src/server` path)
    is mentioned as the entry point, and the generated output file `server.js` is
    copied to the `dist` directory. The `webpack` plugin `babel-loader` is used to
    transpile JavaScript files in the application using `Babel` and `Webpack`. The
    `nodemon-webpack-plugin` is used to run the `nodemon` utility, which will monitor
    the changes in the JavaScript files in the application, and reload and build the
    application when `webpack` is running in watch mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to create a `.babelrc` file, which will list the presets required
    to build the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The `babel-preset-env` and `babel-preset-react` plugins are used to transpile
    ES6 and React code down to ES5\. As the last step, add a script command in the `package.json`
    file to start the application using the configuration mentioned in the `webpack-server.config.babel.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The command `npm start` will build the application, and will listen to the changes
    in the JavaScript files in the application and rebuild it when a change is detected.
  prefs: []
  type: TYPE_NORMAL
- en: Server-Side application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As mentioned in the `webpack` configuration, the entry point to the application
    is at  `/src/server/index.js`. Let''s create the `index.js` file at this path,
    and include the following code, which starts the server application at a given
    port:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: When you run the `npm start` command and access the application at the URL `http://localhost:3001`,
    the preceding HTML content is rendered. This ensures that the `webpack` configuration
    builds the application and runs the preceding server-side code at port `3001`,
    with `nodemon` monitoring the changes in the file.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering a React application using ReactDOMServer.renderToString
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To render a React application on the server-side, let''s first create a React
    component file —`shared/App.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, render the preceding component in the `server/index.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `ReactDOMServer` class includes various methods for rendering React components
    in a server-side Node.js application. The `renderToString` method in `ReactDOMServer`
    class renders the React component on the server-side and returns the generated
    markup. This generated markup string can then be included in the response being
    sent to the user.
  prefs: []
  type: TYPE_NORMAL
- en: When you visit the page at `http://localhost:3001`, you will notice that the
    message Inside React App (rendered with SSR) is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: 'To confirm that the content is indeed rendered on the server-side, you can
    right click on the page and select the View page source option from the context
    menu. The page source is shown in a new tab, and it includes the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The preceding content is helpful when the crawler visits the application. By
    rendering the React component on the server-side, the markup is populated and
    included as the response from the server. This content is then indexed by the
    search engine's crawler, helping with the application's SEO aspects.
  prefs: []
  type: TYPE_NORMAL
- en: Adding <StaticRouter> and creating routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `<StaticRouter>` component is part of the `react-router-dom` package (uses
    `<StaticRouter>` definition in `react-router`), and it's used in rendering React-Router
    components on the server-side. The `<StaticRouter>` component is similar to the
    other Router components, as it accepts only one child component—the React application's
    root component (`<App />`). This component should be used in a stateless application,
    where the user is not clicking around to navigate to different sections of the
    page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s include the `<StaticRouter>` component by wrapping the application''s
    root component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the `<StaticRouter>` component accepts two props—`context` and `location`.
    The `context` object is an empty object and is populated with properties when
    one of the `<Route>` components inside `<App />` is rendered as a result of the
    browser's location match.
  prefs: []
  type: TYPE_NORMAL
- en: The `location` object is usually the requested URL, and this information is
    available to the middleware function. The request object (`req`) contains the
    `url` property specifying the requested URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s include a couple of `<Route>` components in `App.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `<Route>` components match the requested URL specified in the `<StaticRouter>`
    component's `location` property and render.
  prefs: []
  type: TYPE_NORMAL
- en: Server-Side redirect using the <Redirect> and staticContext
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'From the previous example, let''s redirect the user from the `/` path to the `/home` path
    using the `<Redirect>` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'When you try accessing the URL `http://localhost:3001/`, you will notice that
    the redirection does not take place and the browser''s URL is not updated. The
    preceding redirect would have sufficed in the client-side environment. However,
    in the server-side environment, the server is responsible for handling the redirect.
    In this case, the `context` object mentioned in the `<StaticRouter>` component
    is populated with necessary details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `context` object contains the result of the component render. It's usually
    an empty object when the component renders just the content. However, it's populated
    with the preceding details when the rendered component redirects to a different
    path. Notice that the `url` property specifies the path to which the user should
    be redirected—to the `'/home'` path.
  prefs: []
  type: TYPE_NORMAL
- en: 'A check can be added to see if the `url` property exists in the `context` object,
    and then the user can be redirected by using the `redirect` method on the `response`
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `redirect` method in the `response` object is used to perform the server-side
    redirection, and mentions the status code and the URL to redirect to.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s also possible to populate the `context` object with more properties by
    using the `staticContext` prop in the rendered component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the `staticContext` prop is available in the rendered component, and
    the `status` property is added to it before redirecting the user using the `<Redirect>`
    component. The `status` property is then available in the `context` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `status` property in the `context` object is used to set the HTTP
    status when the user is redirected using the `redirect` method.
  prefs: []
  type: TYPE_NORMAL
- en: Request URL matching with matchPath
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When rendering the React application on the server-side, it is also helpful
    to know whether the requested URL matches any of the existing routes in the application.
    Only if the route is available should the corresponding component be rendered
    on the server-side. However, if the route is not available, the user should be
    presented with a Page Not Found page (404). The `matchPath` function in the `react-router` package
    allows you match the requested URL against an object containing route-matching
    properties such as `path`, `exact`, `strict`, and `sensitive`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `matchPath` function is similar to how the library matches `<Route>` components
    against the requested URL path. The first parameter passed to the `matchPath`
    function is the requested URL, and the second parameter is the object against
    which the requested URL should be matched. When the route matches, the `matchPath`
    function returns an object detailing how the requested URL matched the object.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if the requested URL is `/dashboard/`, the `matchPath` function
    returns the following object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the `path` property mentions the path pattern used to match the requested
    URL, the `url` property mentions the matched portion of the URL, the `isExact` Boolean
    property is set to `true` if the requested URL and path matched exactly, and the
    `params` property lists the params that matched the provided pathname. Consider
    the following example, which mentions parameters in the path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, instead of specifying an object as a second parameter, a path string
    is specified. This short notation is useful if you want to match the path against
    the requested URL, and use the default values for the `exact`, `strict`, and `sensitive`
    properties. The matched object will return the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the `params` property is now populated with the list of params mentioned
    in the `path`, with the values provided in the requested URL.
  prefs: []
  type: TYPE_NORMAL
- en: On the server-side, before initializing the `<StaticRouter>` and rendering the
    React application, a check can be performed to see if the requested URL matches
    any of the routes defined in a collection of objects. For example, consider a
    collection of route objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `shared/routes.js` we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding array contains route objects that can then be used in `matchPath`
    to check if the requested URL matches any of the routes in the preceding list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'If the requested URL is found, then `isRouteAvailalbe` will be the matched
    object in the `ROUTES` list, else it''s set to `undefined` when none of the route
    objects match the requested URL. In the latter case, a Page Not Found markup can
    be sent to the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: When the user requests a path, say `/user`, none of the objects mentioned in
    the `ROUTES` would match, and the preceding response is sent, mentioning the `404`
    HTTP status, with the response body mentioning that the requested path `/user` was
    not found.
  prefs: []
  type: TYPE_NORMAL
- en: StaticRouter context prop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `<StaticRouter>` component accepts props `basename`, `location`, and `context`.
    Similar to other Router implementations, the `basename` prop in `<StaticRouter>`
    is used to specify the `baseURL` location and the `location`, prop is used to
    specify the location properties—`pathname`, `hash`, `search`, and `state`.
  prefs: []
  type: TYPE_NORMAL
- en: The `context` prop is used only in the `<StaticRouter>` implementation, and
    it contains the result of the component render. As mentioned previously, the `context`
    object can be populated with an HTTP status code and with other arbitrary properties
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the time of initialization, the context object can contain properties that
    can then be consumed by the rendered component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the context object contains a `message` property, and when the `<Route>`
    component that matches the requested URL is found, the `staticContext` object
    containing this property is available to the rendered component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: When you try to access the `/home` path, the preceding `<Route>` matches and
    the value mentioned in the `staticContext` message property is rendered.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `staticContext` prop is available only in the server-side environment,
    and thus, when you try to refer the `staticContext` object in an isomorphic application
    (discussed in the next section), an error stating that you''re trying to access
    the property message of undefined is thrown. A check can be added to see if the
    `staticContext` is available or if the value of the `__isBrowser__` property defined
    in the webpack configuration can be checked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, if the page is rendered on the server-side, then the
    `__isBrowser__` property will be `false` and the message specified in the `staticContext`
    object will be rendered.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Isomorphic React applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An application where the code can run on server-and client-side environments
    with little or no change is referred to as an Isomorphic application. In an Isomorphic
    application, the first request made by the user's web browser is processed by
    the server, and any subsequent request is processed by the client. By processing
    and rendering the first request on the server-side, and sending HTML, CSS, and
    JavaScript code provides a better user experience, and also helps search engine
    crawlers to index the page. All subsequent requests can then be processed by the
    client-side code, which is sent as part of the first response from the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the updated request-response flow:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/5968e318-34f0-48bd-8fab-5731d0c8a64d.png)'
  prefs: []
  type: TYPE_IMG
- en: To render the application on the client-side, either of the `<BrowserRouter>`
    or `<HashRouter>` components can be used. For the purpose of this example, we
    will use the `<BrowserRouter>` component.
  prefs: []
  type: TYPE_NORMAL
- en: 'The application structure after adding a directory for the client-side code
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the `shared` directory will contain code that can be used by both the
    server-and the client-side code. The client-side specific code that uses the `<BrowserRouter>`
    component resides in the `index.js` file in the `client` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `hydrate` method in the `ReactDOM` class is used instead of calling
    the `render` method to render the application. The `hydrate` method is specifically
    designed to handle cases where the initial render happens on the server-side (using
    `ReactDOMServer`), and all the subsequent route-change requests to update specific
    sections of the page are handled by the client-side code. The `hydrate` method
    is used to attach event listeners to the markup rendered on the server-side.
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to build the application, so that the client-side bundle is
    generated at the build time and included in the first response from the server.
  prefs: []
  type: TYPE_NORMAL
- en: Webpack configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The existing webpack configuration builds the server-side application and runs
    the `nodemon` utility to monitor the changes. To generate a client-side bundle,
    we need to include another webpack configuration file—`webpack-client.config.babel.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The preceding configuration resolves the dependencies in the `/src/client/index.j`s
    file and creates a bundle at `/dist/public/bundle.js`. This bundle contains all
    the client-side code required to run the application; not only the code in the
    `index.js` file but also the components declared in the `shared` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'The current `npm start` script also needs to be modified so that the client-side
    application code builds along with the server-side code. Let''s create a file
    that exports both the server and client webpack configurations—`webpack.config.babel.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the `npm start` script is updated to refer to the preceding configuration
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The preceding script will generate `server.js`, which contains the server-side
    code, and `bundle.js`, which contains the client-side code.
  prefs: []
  type: TYPE_NORMAL
- en: Server-Side configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The last step is to update the server-side code to include the client-side
    bundle (`bundle.js`) as part of the first response. The server-side code can include
    a `<script>` tag which specifies the `bundle.js` file in the source (`src`) attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, for our express server to serve a JavaScript file, we include the middleware
    function for serving static content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code allows static files such as JavaScript files, CSS files,
    and Images, to be served from the `dist/public` directory. The preceding statement
    should be included before `app.get()` is used.
  prefs: []
  type: TYPE_NORMAL
- en: When you access the application at the `/home` path, the first response is from
    the server, and, in addition to rendering the `<Route>` that matched the `/home` path,
    the client-side bundle—`bundle.js`—is also included in the response. The `bundle.js`
    file is downloaded by the browser, and any change in the route path is then handled
    by the client-side code.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at how a React application can be rendered on the
    server-side (with Node.js and Express.js) using the `ReactDOMserver.renderToString`
    method. The `<StaticRouter>` component in React-Router can be used to wrap the
    application's root component, thus enabling you to add `<Route>` components that
    match the requested URL path on the server-side. The `<StaticRouter>` component
    accepts props `context` and `location`. The `staticContext` prop (available only
    on the server-side) in the rendered component contains the data provided by the
    `<StaticRouter>` in the `context` prop. It can also be used to add properties
    when you want to redirect the user using the `<Redirect>` component.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `matchPath` function is used to determine whether the requested URL matches
    the provided object of the shape `{path, exact, strict, sensitive}`. It''s similar
    to how the library matches the requested URL with the available `<Route>` components
    in the page. The `matchPath` function gives us the ability to determine if the
    requested URL matches any of the routes object in the collection; this provides
    us with an opportunity to send a 404: Page not found response up front.'
  prefs: []
  type: TYPE_NORMAL
- en: It's also possible to create an isomorphic React application that renders the
    first request on the server-side and the subsequent requests on the client side.
    This is accomplished by including the client-side bundle file when sending the
    first response from the server. The client-side code takes over after the first
    request, which enables you to update specific sections of the page that match
    the requested route.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 7](0928d71c-c469-46a1-a4a1-238921180019.xhtml), *Using NativeRouter
    in a React Native Application*, we will take a look at how the `NativeRouter`
    component can be used to define routes in a native mobile application created
    with React-Native.
  prefs: []
  type: TYPE_NORMAL
