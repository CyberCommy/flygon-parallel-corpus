- en: Chapter 12. What Are We Talking about When We Talk about Functional Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Functional programming has gained a lot of traction in the last few years.
    Various big tech companies have started using functional languages:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Twitter on Scala: [http://www.artima.com/scalazine/articles/twitter_on_scala.html](http://www.artima.com/scalazine/articles/twitter_on_scala.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'WhatsApp being written in Erlang: [http://www.fastcompany.com/3026758/inside-erlang-the-rare-programming-language-behind-whatsapps-success](http://www.fastcompany.com/3026758/inside-erlang-the-rare-programming-language-behind-whatsapps-success)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Facebook using Haskell: [https://code.facebook.com/posts/302060973291128/open-sourcing-haxl-a-library-for-haskell/1](https://code.facebook.com/posts/302060973291128/open-sourcing-haxl-a-library-for-haskell/1)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There has been some really wonderful and successful work done on functional
    languages that compile to JavaScript: the **Elm** and **PureScript** languages,
    to name a couple. There are efforts to create new languages that either extend
    or compile to some more traditional languages; we can cite the **Hy** and **Coconut**
    languages for Python.'
  prefs: []
  type: TYPE_NORMAL
- en: Even Apple's new language for iOS development, **Swift**, has multiple concepts
    from functional programming integrated into its core.
  prefs: []
  type: TYPE_NORMAL
- en: However, this book is not about using a new language, it is about benefiting
    from functional techniques without having to change our whole stack or learn a
    whole new technology. By just applying some principles to our everyday PHP, we
    can greatly improve the quality of our life and our code.
  prefs: []
  type: TYPE_NORMAL
- en: But before going further, let's start with a gentle introduction to what the
    functional paradigm really is and explain where it comes from.
  prefs: []
  type: TYPE_NORMAL
- en: What is functional programming all about?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you try searching the Internet for a definition of functional programming,
    chances are you will at some point find the Wikipedia article ([https://en.wikipedia.org/wiki/Functional_programming](https://en.wikipedia.org/wiki/Functional_programming)).
    Among other things, functional programming is described as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*In computer science, functional programming is a programming paradigm-a style
    of building the structure and elements of computer programs-that treats computation
    as the evaluation of mathematical functions and avoids changing-state and mutable
    data.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The Haskell wiki ([https://wiki.haskell.org/Functional_programming](https://wiki.haskell.org/Functional_programming))
    describes it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*In functional programming, programs are executed by evaluating expressions,
    in contrast with imperative programming where programs are composed of statements
    which change global state when executed. Functional programming typically avoids
    using mutable state.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Although our take might be a bit different, we can outline some key definitions
    of functional programming from them:'
  prefs: []
  type: TYPE_NORMAL
- en: Evaluation of mathematical functions or expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoiding mutable states
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From those two core ideas, we can derive a lot of interesting properties and
    benefits, which you will discover in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You're probably aware of what a function is in a programming language, but how
    it is different from a mathematical function, or as Haskell calls it, an expression?
  prefs: []
  type: TYPE_NORMAL
- en: A mathematical function does not care about the outside world, or the state
    of the program. For a given set of inputs, the outputs will always be exactly
    the same. To avoid confusion, developers often use the terms **pure functions**
    in this case. We discussed this in [Chapter 2](ch02.html "Chapter 2.  Pure Functions,
    Referential Transparency, and Immutability"), *Pure Functions, Referential Transparency
    and Immutability*.
  prefs: []
  type: TYPE_NORMAL
- en: Declarative programming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another difference is that functional programming is also sometimes called **declarative
    programming**, in contrast to imperative programming. These are called **programming
    paradigms**. Object-oriented programming is also a paradigm, but one that is strongly
    tied to the imperative one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of explaining the difference at length, let''s demonstrate it with
    an example. First an imperative one using PHP:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s see how you can do the same with SQL, which is, among other things,
    a declarative language:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Notice the difference? In the first example, you tell the computer what to do
    step by step, taking care of storing intermediary results yourselves. The second
    example only describes what you want; it will then be the role of the database
    engine to return the results.
  prefs: []
  type: TYPE_NORMAL
- en: In a way, functional programming looks a lot more like SQL than it does the
    PHP code we just saw.
  prefs: []
  type: TYPE_NORMAL
- en: 'Without any explanation, here is how you could do it with PHP in a more functional
    approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: I'll readily admit that this code might not be really clearer than the first
    one. This can be improved by using dedicated libraries. We will also see in detail
    the advantages of such an approach.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding mutable state
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As the name itself implies, functions are the most important building block
    of functional programming. The purest of functional languages will only allow
    you to use functions, no variables at all, thus avoiding any problems with state
    and mutating it, and at the same time making any kind of imperative programming
    impossible.
  prefs: []
  type: TYPE_NORMAL
- en: Although nice, the idea is not practical; this is why most functional languages
    allow you to have some kind of variable. However, those are often immutable, meaning
    that, once assigned, their value can't change.
  prefs: []
  type: TYPE_NORMAL
- en: Why is functional programming the future of software development?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we just saw, the functional world is moving, its adoption by the enterprise
    world is growing, and even new imperative languages take inspiration from functional
    languages. But why it is so?
  prefs: []
  type: TYPE_NORMAL
- en: Reducing the cognitive burden on developers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You''ve probably often read or heard that a programmer should not be interrupted
    because even a small interruption can lead to literally tens of minutes being
    lost. One of my favorite illustrations of this is the following comic:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Reducing the cognitive burden on developers](graphics/image_00_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is partly due to the cognitive burden, or in other words, the amount of
    information you have to keep in memory in order to understand the problem or function
    at hand.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we were able to reduce this issue, the benefits would be huge:'
  prefs: []
  type: TYPE_NORMAL
- en: Code will take less time to understand and will be easier to reason about
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interruption will lead to less disruption in the mental process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fewer errors will be introduced due to forgetting a piece of information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Small learning curve for newcomers on the project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I posit that functional programming can greatly help.
  prefs: []
  type: TYPE_NORMAL
- en: Keeping the state away
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the main contenders when it comes to the cognitive burden, as is depicted
    very well in the comic shown previously, is keeping all these little bits of state
    information in mind when trying to understand what a piece of code does.
  prefs: []
  type: TYPE_NORMAL
- en: Each time you access a variable or call a method on an object, you have to ask
    yourself what its value would be and keep that in mind until you reach the end
    of the piece of code you're currently reading.
  prefs: []
  type: TYPE_NORMAL
- en: By using pure functions, nearly all of this goes away. All your parameters are
    right there, in the function signature. Moreover, you have the absolute certainty that
    any subsequent call with the same parameters will have exactly the same outcome,
    because your function doesn't rely on external data or any object state.
  prefs: []
  type: TYPE_NORMAL
- en: 'To drive the nail further, let''s cite *Out of the Tar Pit* by Ben Moseley
    and Peter Marks:'
  prefs: []
  type: TYPE_NORMAL
- en: '*[...] it is our belief that the single biggest remaining cause of complexity
    in most contemporary large systems is state, and the more we can do to limit and
    manage state, the better.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: You can read the whole paper at [http://shaffner.us/cs/papers/tarpit.pdf](http://shaffner.us/cs/papers/tarpit.pdf).
  prefs: []
  type: TYPE_NORMAL
- en: Small building blocks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you do functional programming, you usually create a lot of small functions.
    You can then compose them like Lego blocks. Each of those small pieces of code
    is often easier to understand than this big messy method that tries to do a lot
    of things.
  prefs: []
  type: TYPE_NORMAL
- en: I am not saying that all imperative code is a big mess, just that having a functional
    mindset really encourages writing small and concise functions that are easier
    to work with.
  prefs: []
  type: TYPE_NORMAL
- en: Locality of concerns
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s have a look at the two following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Locality of concerns](graphics/image_00_002-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Imperative versus functional-separation of concerns
  prefs: []
  type: TYPE_NORMAL
- en: 'As illustrated previously in both fictional code snippets, functional techniques
    help you organize your code in a way that encourages locality of concerns. In
    the snippets, we can separate the concerns as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting data from a file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filtering all lines starting with **ERROR** text
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Taking the first 40 errors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second snippet clearly has a better locality for each of those concerns;
    they are not spread out in the code.
  prefs: []
  type: TYPE_NORMAL
- en: One can argue that the first code is not optimal and could be rewritten to achieve
    the same results. Yes, it's probably true. But as for the previous point, a functional
    mindset encourages this kind of architecture from the get-go.
  prefs: []
  type: TYPE_NORMAL
- en: Declarative programming
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We saw that declarative programming is about the *what* instead of the *how*.
    This helps understanding new code a lot, because our minds have a much easier
    time thinking about what we want instead of how to do it.
  prefs: []
  type: TYPE_NORMAL
- en: When you order something online or at a restaurant, you don't imagine how, what
    you want will be created or delivered, you just think of what you want. Functional
    programming is the same-you start with some data and you tell the language what
    you want done with it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This kind of code is also often easier to understand for non-programmers or
    people with less experience in the language, because we can visualize what will
    happen to the data. Here is another citation from *Out of the Tar Pit* illustrating
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*When a programmer is forced (through use of a language with implicit control
    flow) to specify the control, he or she is being forced to specify an aspect of
    how the system should work rather than simply what is desired. Effectively they
    are being forced to over-specify the problem*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Software with fewer bugs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We already saw that functional programming reduces the cognitive burden and
    makes your code easier to reason about. This is already a huge win when it comes
    to bugs, because it will allow you to spot issues quickly as you will spend less
    time understanding how the code works to focus on what it should do.
  prefs: []
  type: TYPE_NORMAL
- en: But all the benefits we've just seen have another advantage. They make testing
    a lot easier too! If you have a pure function and you test it with a given set
    of values, you have the absolute certainty that it will always return exactly
    the same thing in production.
  prefs: []
  type: TYPE_NORMAL
- en: How many times have you thought your test was fine, only to discover you had
    some kind of hidden dependency to an obscure state deep in your application that
    triggered an issue in some particular circumstances? This ought to happen a lot
    less with pure functions.
  prefs: []
  type: TYPE_NORMAL
- en: We also learn about property-based testing later in the book. Although the technique
    can be used on any imperative codebase, the idea behind it came from the functional
    world.
  prefs: []
  type: TYPE_NORMAL
- en: Easier refactoring
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Refactoring is never easy. But since the only inputs of a pure function are
    its parameters and its sole output is the returned value, things are simpler.
  prefs: []
  type: TYPE_NORMAL
- en: If your refactored function continues to return the same output for a given
    input, you can have the guarantee that your software will continue to work. You
    cannot forget to set some state somewhere in an object, because your functions
    are side-effect free.
  prefs: []
  type: TYPE_NORMAL
- en: Parallel execution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our computers have more and more cores and the cloud has made it a lot easier
    to share work across a bunch of nodes. The challenge, however, is ensuring that
    a computation can be distributed.
  prefs: []
  type: TYPE_NORMAL
- en: Techniques such as mapping and folding, coupled with immutability and the absence
    of state, make this pretty easy.
  prefs: []
  type: TYPE_NORMAL
- en: Sure, you will still have issues related to distributed computing itself, such
    as partitions and failure detection, but splitting the computation into multiple
    workloads will be made a lot easier! If you want to learn more about distributed
    systems, I can recommend this article ([http://videlalvaro.github.io/2015/12/learning-about-distributed-systems.html](http://videlalvaro.github.io/2015/12/learning-about-distributed-systems.html))
    by a former colleague.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcing good practices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This book is the proof that functional programming is more about the way we
    do things instead of a particular language. You can use functional techniques
    in nearly any language that has functions. Your language still needs to have certain
    properties, but not that many. I like to talk about having a functional mindset.
  prefs: []
  type: TYPE_NORMAL
- en: If this is so, why do companies move to functional languages? Because those
    languages enforce the best practice we will learn in this book. In PHP, you will
    have to always remember to use functional techniques. In Haskell, you cannot do
    anything else; the language forces you to write pure functions.
  prefs: []
  type: TYPE_NORMAL
- en: Sure, you can still write bad code in any language, even the purest ones. But
    usually, people, and developers especially, like to take the path of least resistance.
    And if this path is the one that leads to quality code, they will take it.
  prefs: []
  type: TYPE_NORMAL
- en: A quick history of the functional world
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Historically, functional programming has its roots in the academic world. It's
    only in recent years that more mainstream companies started using it to develop
    consumer-facing applications. Some new research into the field is now even done
    by people outside of universities. But let's begin at the beginning.
  prefs: []
  type: TYPE_NORMAL
- en: The first years
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our story starts in the 1930s when Alonzo Church formalized the Lambda Calculus,
    a way to solve mathematical problems using functions accepting other functions
    as parameters. Although this is the foundation of functional programming, it took
    20 years for the concept to be first used to implement a programming language
    when **Lisp** was released in 1958 by John McCarthy. To be fair, **Fortran**,
    considered the first programming language, was released in 1957.
  prefs: []
  type: TYPE_NORMAL
- en: Although LISP is considered a multi-paradigm language, it is often cited as
    the first functional language. Quickly, others took the hint and started working
    around the idea of functional programming, leading to the creation of **APL**
    (1964), **Scheme** (1970), **ML** (1973), **FP** (1977), and many others.
  prefs: []
  type: TYPE_NORMAL
- en: FP in itself is more or less dead right now, but the lecture in which it was
    presented by John Backus was pivotal to the research into the functional paradigm.
    It might not be the easiest read, but it's really interesting nonetheless. I can
    only suggest you give the whole paper a try at [http://worrydream.com/refs/Backus-CanProgrammingBeLiberated.pdf](http://worrydream.com/refs/Backus-CanProgrammingBeLiberated.pdf).
  prefs: []
  type: TYPE_NORMAL
- en: The Lisp family
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Scheme, first released in 1970, is an attempt to fix some of the shortcomings
    of Lisp. In the meantime, Lisp gave birth to a programming language family or
    dialects:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Common Lisp** (1984): an attempt to write a language specification to reunite
    all the Lisp dialects that were being written at the time.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Emacs Lisp** (1985): the scripting language used to customize and extend
    the Emacs editor.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Racket** (1994): first created to be a platform around language design and
    creation, it''s now used in multiple areas such as game scripting, education,
    and research.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Clojure** (2007): created by Rich Hickey after a lengthy reflection to create
    the perfect language. Clojure targets the **Java Virtual Machine** (**JVM**).
    It is interesting to note that Clojure can also now have other targets, for example,
    JavaScript (ClojureScript) and the .NET virtual machine.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Hy** (2013): a dialect that targets the Python runtime, allowing the use
    of all Python libraries.'
  prefs: []
  type: TYPE_NORMAL
- en: ML
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ML also spawned some children, most notably **Standard ML** and **OCaml** (1996)
    which are still in use today. It is also often cited as influence in the design
    of a lot of modern languages. To name a few: Go, Rust, Erlang, Haskell, and Scala.
  prefs: []
  type: TYPE_NORMAL
- en: The rise of Erlang
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I said earlier that the mainstream use of functional language is something that
    started happening in the last few years. This is not entirely true. Ericsson started
    working on Erlang as soon as 1986, interested in the stability and robustness
    promised by a functional language.
  prefs: []
  type: TYPE_NORMAL
- en: At first, Erlang was implemented on top of **Prolog** and it proved too slow,
    but a rewrite to use a virtual machine compiling Erlang to C in 1992, allowed
    Ericsson to use Erlang on production telephony system as early as 1995\. Since
    then, it has been used worldwide by telecom companies and is considered one of
    the best languages when it comes to high availability.
  prefs: []
  type: TYPE_NORMAL
- en: Haskell
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The year 1990 marked the first release of Haskell, the result of specification
    work done by academics around the world to create the first open standard around
    lazy purely functional languages. The idea was to consolidate existing functional
    languages into a common one so that it could be the basis for further research
    in functional language design.
  prefs: []
  type: TYPE_NORMAL
- en: Since then, Haskell has grown from a purely academic language in to one of the
    leading functional languages.
  prefs: []
  type: TYPE_NORMAL
- en: Scala
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Scala development was started in 2001 by former Java core developer Martin Odersky.
    The main idea was to make functional programming more approachable by mixing it
    with more traditional imperative concepts. The first public release in 2004 targeted
    both the JVM and the **Common Runtime Language** (**CRM**) used by .NET (this
    second target was later dropped in 2012).
  prefs: []
  type: TYPE_NORMAL
- en: Scala source code can use its language construct alongside those from the target
    virtual machine. The ability to use existing Java libraries directly and the ability to
    fall back to an imperative style is one of the reasons Scala quickly gained ground
    in the enterprise world.
  prefs: []
  type: TYPE_NORMAL
- en: Since Android uses a Java-compatible virtual machine, Scala is well suited for
    mobile development and there's also an initiative to compile it to JavaScript,
    meaning you can use it on both the server and the client for web development.
  prefs: []
  type: TYPE_NORMAL
- en: The newcomers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Nowadays, functional programming languages are starting to gain more mainstream
    acceptance and new languages are created outside of the academic world. Here is
    a quick overview of what is being actively worked on by people around the world.
  prefs: []
  type: TYPE_NORMAL
- en: '**Elm** is a serious attempt to create a functional language compiling to JavaScript
    besides ClojureScript. It is the result of a thesis by Evan Czaplicki trying to
    create a functional reactive language, a concept we will look into in the last
    chapter of the book. It gained some coverage when a time-traveling debugger ([http://debug.elm-lang.org/](http://debug.elm-lang.org/))
    was first presented some years ago, an idea that has since been implemented with
    much more pain in JavaScript frameworks such as **React**. The barrier of entry
    is greatly eased by an online editor, really great tutorials, and the fact that
    you can use **npm** to install it.'
  prefs: []
  type: TYPE_NORMAL
- en: '**PureScript** is another functional language compiling to JavaScript. It is
    closer to Haskell than Elm is and follows a more mathematical approach. The community
    is smaller, but a lot of work is going on to make the language user-friendly.
    The PureScript compiler was written in Haskell, it''s a bit harder to get started
    but it''s worth it if you want to have robust client-side code.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Idris** is, in my opinion, not really ready to shine in a production environment.
    It has its place in this list, however, as it is one of the more advanced functional
    languages implementing dependent types. A dependent type is an advanced typing
    concept that is mostly seen in purely academic languages. It''s beyond scope of
    this book to explain it in detail, but let''s do a quick example: *a pair of integers*
    is a **type**; *a pair of integers where the second one is greater than the first*
    is a **dependent type** because the type depends on the value of the variable.
    The advantages of such a typing system is that you can prove more thoroughly that
    your data is correct and thus the result of your software is also correct. This
    is, however, a really advanced technique and such languages are rare and hard
    to learn.'
  prefs: []
  type: TYPE_NORMAL
- en: Functional jargon
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like every other field, functional programming comes with its own jargon. This
    small glossary has the goal to make reading the book easier and also provide you
    with more understanding of the resources you will find online.
  prefs: []
  type: TYPE_NORMAL
- en: '**Arity**'
  prefs: []
  type: TYPE_NORMAL
- en: The number of parameters a function takes. The terms nullary, unary, binary,
    and ternary are also used to denote functions that take 0, 1, 2, and 3 parameters
    respectively. See also variadic as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '**Higher-order functions**'
  prefs: []
  type: TYPE_NORMAL
- en: A function that returns another function. [Chapter 1](ch01.html "Chapter 1. Functions
    as First Class Citizens in PHP"), *Functions as First Class Citizens*, further
    explain the concepts of higher-order functions as this is one of the foundations
    of functional programming.
  prefs: []
  type: TYPE_NORMAL
- en: '**Side effects**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Anything that affects the world outside the current function: changing a global
    state, a variable passed by reference, a value in an object, writing to the screen
    or a file, taking user inputs. This concept is an important one and will be explored
    further in multiple chapters of the book.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Purity**'
  prefs: []
  type: TYPE_NORMAL
- en: A function is said to be pure if it only uses the explicit parameters and has
    no side effects. A pure function is a function that will always yield exactly
    the same result when called with the same parameters. A pure language is a language
    allowing only pure functions. This concept is an angular stone of functional programing
    as discussed in [Chapter 2](ch02.html "Chapter 2.  Pure Functions, Referential
    Transparency, and Immutability"), *Pure Functions, Referential Transparency, and
    Immutability*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Function composition**'
  prefs: []
  type: TYPE_NORMAL
- en: Composing functions is a useful technique to reuse various functions as building
    blocks to achieve more complex operations. Instead of always calling the function
    `g` on the result of the function `f`, you can compose both functions to create
    a new function `h`. [Chapter 4](ch04.html "Chapter 4. Composing Functions"), *Composing
    Functions*, demonstrates how this idea can be used.
  prefs: []
  type: TYPE_NORMAL
- en: '**Immutability**'
  prefs: []
  type: TYPE_NORMAL
- en: An immutable variable is a variable that cannot be changed once it has been
    assigned a value.
  prefs: []
  type: TYPE_NORMAL
- en: '**Partial application**'
  prefs: []
  type: TYPE_NORMAL
- en: The process of assigning a given value to some parameters of a function to create
    a new function of a smaller arity. This is sometimes called fixing or binding
    a value to a parameter. This is a bit difficult to achieve in PHP, but [Chapter
    4](ch04.html "Chapter 4. Composing Functions"), *Composing Functions*, gives some
    idea of how to do it.
  prefs: []
  type: TYPE_NORMAL
- en: '**Currying**'
  prefs: []
  type: TYPE_NORMAL
- en: Akin to partial application, currying is the process of transforming a function
    with multiple parameters into multiple unary functions composed to achieve the
    same result. The reason and idea behind currying were presented in [Chapter 4](ch04.html
    "Chapter 4. Composing Functions"), *Composing Functions*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Fold/reduce**'
  prefs: []
  type: TYPE_NORMAL
- en: The process of reducing a collection to a *single* value. This is an often-used
    concept in functional programming and was demonstrated at length in [Chapter 3](ch03.html
    "Chapter 3.  Functional Basis in PHP"), *Functional Basis in PHP*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Map**'
  prefs: []
  type: TYPE_NORMAL
- en: The process of applying a function on all values of a collection. This is an
    often-used concept in functional programming and was demonstrated at length in
    [Chapter 3](ch03.html "Chapter 3.  Functional Basis in PHP"), *Functional Basis
    in PHP*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Functor**'
  prefs: []
  type: TYPE_NORMAL
- en: Any type of value or collection to which you can apply a mapping operation.
    The functor, given a function, is responsible for applying it to its inner value.
    It is said that the functor *wraps* the value. This concept was presented in [Chapter
    5](ch05.html "Chapter 5.  Functors, Applicatives, and Monads"), *Functors, Applicatives,
    and* *Monads*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Applicative**'
  prefs: []
  type: TYPE_NORMAL
- en: A data structure holding a function inside a context. The applicative, given
    a value, is responsible for applying the "inner" function to it. It is said that
    the functor *wraps* the function. This concept was presented in [Chapter 5](ch05.html
    "Chapter 5.  Functors, Applicatives, and Monads"), *Functors, Applicatives, and* *Monads*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Semigroup**'
  prefs: []
  type: TYPE_NORMAL
- en: Any type for which you can associate values two by two. For example, strings
    are a semigroup because you can concatenate them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Integers have multiple semigroups:'
  prefs: []
  type: TYPE_NORMAL
- en: The Addition semigroup, where you add integers together
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Multiplication semigroup, where you multiply the integers together
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Monoid**'
  prefs: []
  type: TYPE_NORMAL
- en: A monoid is a semigroup that also has an identity value. The identity value
    is a value that when associated with an object of the same type does not change
    its value. The Addition identity for integers is 0 and the identity for strings
    is the empty string.
  prefs: []
  type: TYPE_NORMAL
- en: A monoid also requires that the order of association to multiple values does
    not change the result, for example, *(1 + 2) + 3 == 1 + (2 + 3)*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Monad**'
  prefs: []
  type: TYPE_NORMAL
- en: A monad can act both as a functor or as an applicative; refer to the dedicated
    [Chapter 5](ch05.html "Chapter 5.  Functors, Applicatives, and Monads"), *Functors,
    Applicatives, and Monads*, for more information.
  prefs: []
  type: TYPE_NORMAL
- en: '**Lift/LiftA/LiftM**'
  prefs: []
  type: TYPE_NORMAL
- en: The process of taking something and putting it inside a functor, applicative,
    or monad respectively.
  prefs: []
  type: TYPE_NORMAL
- en: '**Morphism**'
  prefs: []
  type: TYPE_NORMAL
- en: 'A transformation function. We can distinguish multiple kinds of morphisms:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Endomorphism**: The type of the input and output stays the same, for example,
    making a string uppercase.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Isomorphism**: The type changes, but the data stays the same, for example,
    transforming an array containing coordinates to a Coordinate object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Algebraic type / union type**'
  prefs: []
  type: TYPE_NORMAL
- en: The combination of two types into a new one. Scala calls those either types.
  prefs: []
  type: TYPE_NORMAL
- en: '**Option type / maybe type**'
  prefs: []
  type: TYPE_NORMAL
- en: A union type that contains a valid value and the equivalent of null. This kind
    of type is used when a function is not sure to return a valid value. [Chapter
    3](ch03.html "Chapter 3.  Functional Basis in PHP"), *Functional Basis in PHP*,
    explains how to use these to simplify error management.
  prefs: []
  type: TYPE_NORMAL
- en: '**Idempotence**'
  prefs: []
  type: TYPE_NORMAL
- en: A function is said to be idempotent if reapplying it to its result does not
    produce a different result. If you compose an idempotent function with itself,
    it will still yield the same result.
  prefs: []
  type: TYPE_NORMAL
- en: '**Lambda**'
  prefs: []
  type: TYPE_NORMAL
- en: A synonym for an anonymous function, that is, a function assigned to a variable.
  prefs: []
  type: TYPE_NORMAL
- en: '**Predicate**'
  prefs: []
  type: TYPE_NORMAL
- en: A function that returns either true or false for a given set of parameters.
    Predicates are often used to filter collections.
  prefs: []
  type: TYPE_NORMAL
- en: '**Referential transparency**'
  prefs: []
  type: TYPE_NORMAL
- en: An expression is said to be referentially transparent if it can be replaced
    by its value without changing the outcome of the program. The concept is tightly
    linked to purity. [Chapter 2](ch02.html "Chapter 2.  Pure Functions, Referential
    Transparency, and Immutability"), *Pure functions, Referential Transparency, and
    Immutability*, explores the slight differences between the two.
  prefs: []
  type: TYPE_NORMAL
- en: '**Lazy evaluations**'
  prefs: []
  type: TYPE_NORMAL
- en: A language is said to be lazily evaluated if the result of an expression is
    only computed when it's needed. This allows you to create an infinite list and
    is only possible if an expression is referentially transparent.
  prefs: []
  type: TYPE_NORMAL
- en: '**Non-strict language**'
  prefs: []
  type: TYPE_NORMAL
- en: A non-strict language is a language where all constructs are lazily evaluated.
    Only a handful of languages are non-strict, mostly due to the fact that the language
    has to be pure in order to be non-strict and it poses non-trivial implementation
    issues. The most well-known non-strict language is probably Haskell.
  prefs: []
  type: TYPE_NORMAL
- en: 'Nearly all commonly seen languages are strict: C, Java, PHP, Ruby, Python,
    and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Variadic**'
  prefs: []
  type: TYPE_NORMAL
- en: A function with dynamic arity is called **variadic**. This means the function
    accepts a variable number of parameters.
  prefs: []
  type: TYPE_NORMAL
