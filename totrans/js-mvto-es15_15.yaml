- en: Chapter 3. Creational Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last chapter we took a long look at how to fashion a class. In this chapter
    we'll look at how to create instances of classes. On the surface it seems like
    a simple concern but how we create instances of a class can be of great importance.
  prefs: []
  type: TYPE_NORMAL
- en: We take great pains in creating our code so that it be as decoupled as possible.
    Ensuring that classes have minimal dependence on other classes is the key to building
    a system that can change fluently with the changing needs of those using the software.
    Allowing classes to be too closely related means that changes ripple through them
    like, well, ripples.
  prefs: []
  type: TYPE_NORMAL
- en: 'One ripple isn''t a huge problem but, as you throw more and more changes into
    the mix, the ripples add up and create interference patterns. Soon the once placid
    surface is an unrecognizable mess of additive and destructive nodes. This same
    problem occurs in our applications: the changes magnify and interact in unexpected
    ways. One place where we tend to forget about coupling is in the creation of objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see in this class that the Ruler''s house is strongly coupled to the
    class `Targaryen`. If this were ever to change then this tight coupling would
    have to change in a great number of places. This chapter discusses a number of
    patterns, which were originally presented in the gang of four book, *Design Patterns:
    Elements of Reusable Object-Oriented Software*. The goal of these patterns is
    to improve the degree of coupling in applications and increase the opportunities
    for code reuse. The patterns are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Abstract factory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Builder
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Factory method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Singleton
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prototype
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of course not all of these are applicable to JavaScript, but we'll see all about
    that as we work through the creational patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Abstract factory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first pattern presented here is a method for creating kits of objects without
    knowing the concrete types of the objects. Let's continue with the system presented
    in the preceding section for ruling a kingdom.
  prefs: []
  type: TYPE_NORMAL
- en: For the kingdom in question the ruling house changes with some degree of frequency.
    In all likelihood there is a degree of battling and fighting during the change
    of house but we'll ignore that for the moment. Each house will rule the kingdom
    differently. Some value peace and tranquility and rule as benevolent leaders,
    while others rule with an iron fist. The rule of a kingdom is too large for a
    single individual so the king defers some of his decisions to a second in command
    known as the hand of the king. The king is also advised on matters by a council,
    which consists of some of the more savvy lords and ladies of the land.
  prefs: []
  type: TYPE_NORMAL
- en: 'A diagram of the classes in our description look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Abstract factory](img/00039.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Unified Modeling Language** (**UML**) is a standardized language developed
    by the Object Management Group, which describes computer systems. There is vocabulary
    in the language for creating user interaction diagrams, sequence diagrams, and
    state machines, amongst others. For the purposes of this module we''re most interested
    in class diagrams, which describe the relationship between a set of classes.'
  prefs: []
  type: TYPE_NORMAL
- en: The entire UML class diagram vocabulary is extensive and is beyond the scope
    of this module. However, the Wikipedia article available at [https://en.wikipedia.org/wiki/Class_diagram](https://en.wikipedia.org/wiki/Class_diagram)
    acts as a great introduction as does Derek Banas' excellent video tutorial on
    class diagrams available at [https://www.youtube.com/watch?v=3cmzqZzwNDM](https://www.youtube.com/watch?v=3cmzqZzwNDM).
  prefs: []
  type: TYPE_NORMAL
- en: An issue is that, with the ruling family, and even the member of the ruling
    family on the throne, changing so frequently, coupling to a concrete family such
    as Targaryen or Lannister makes our application brittle. Brittle applications
    do not fare well in an ever-changing world.
  prefs: []
  type: TYPE_NORMAL
- en: An approach to fixing this is to make use of the abstract factory pattern. The
    abstract factory declares an interface for creating each of the various classes
    related to the ruling family.
  prefs: []
  type: TYPE_NORMAL
- en: 'The class diagram of this pattern is rather daunting:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Abstract factory](img/00040.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The abstract factory class may have multiple implementations for each of the
    various ruling families. These are known as concrete factories and each of them
    will implement the interface provided by the abstract factory. The concrete factories,
    in return, will return concrete implementations of the various ruling classes.
    These concrete classes are known as products.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by looking at the code for the interface for the abstract factory.
  prefs: []
  type: TYPE_NORMAL
- en: 'No code? Well, actually that is exactly the case. JavaScript''s dynamic nature
    precludes the need for interfaces to describe classes. Instead of having interfaces
    we''ll just create the classes right off the bat:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Abstract factory](img/00041.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Instead of interfaces, JavaScript trusts that the class you provide implements
    all the appropriate methods. At runtime the interpreter will attempt to call the
    method you request and, if it is found, call it. The interpreter simply assumes
    that if your class implements the method then it is that class. This is known
    as **duck typing**.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Duck typing**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The name duck typing comes from a 2000 post to the *comp.lang.python* news
    group by Alex Martelli in which he wrote:'
  prefs: []
  type: TYPE_NORMAL
- en: '*In other words, don''t check whether it IS-a duck: check whether it QUACKS-like-a
    duck, WALKS-like-a duck, and so on, depending on exactly what subset of duck-like
    behavior you need to play your language-games with.*'
  prefs: []
  type: TYPE_NORMAL
- en: I enjoy the possibility that Martelli took the term from the witch-hunt sketch
    from *Monty Python and the Holy Grail*. Although I can find no evidence of that,
    I think it quite likely as the Python programming language takes its name from
    Monty Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'Duck typing is a powerful tool in dynamic languages allowing for much less
    overhead in implementing a class hierarchy. It does, however, introduce some uncertainty.
    If two classes implement an identically named method which have radically different
    meanings then there is no way to know if the one being called is the correct one.
    Consider for example this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Both classes have a `punch()` method but they clearly have different meanings.
    The JavaScript interpreter has no idea that they are different classes and will
    happily call punch on either class, even when one doesn't make sense.
  prefs: []
  type: TYPE_NORMAL
- en: Some dynamic languages support a generic method, which is called whenever an
    undefined method is called. Ruby, for instance, has `missing_method`, which has
    proven to be very useful in a number of scenarios. As of writing, there is currently
    no support for `missing_method` in JavaScript. However, ECMAScript 2016, the follow
    up to ECMAScript 2015, defines a new construct called `Proxy` which will support
    dynamically wrapping objects, with this one could implement an equivalent of `missing_method`.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To demonstrate an implementation of the Abstract Factory the first thing we''ll
    need is an implementation of the `King` class. This code provides that implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This code does not include the module structure suggested in [Chapter 2](part0086_split_000.html#2I0GC1-015e68c68a464f18a9559f448be84435
    "Chapter 2. Organizing Code"), *Organizing Code*. Including the boiler-plate module
    code in every example is tedious and you're all smart cookies so you know to put
    this in modules if you're going to actually use it. The fully modularized code
    is available in the distributed source code.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is just a regular concrete class and could really contain any implementation
    details. We''ll also need an implementation of the `HandOfTheKing` class which
    is equally unexciting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The concrete factory method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This code simply instantiates new instances of each of the required classes
    and returns them. An alternative implementation for a different ruling family
    would follow the same general form and might look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The implementation of the Abstract Factory in JavaScript is much easier than
    in other languages. However the penalty for this is that you lose the compiler
    checks, which force a full implementation of either the factory or the products.
    As we proceed through the rest of the patterns, you'll notice that this is a common
    theme. Patterns that have a great deal of plumbing in statically typed languages
    are far simpler but create a greater risk of runtime failure. Appropriate unit
    tests or a JavaScript compiler can ameliorate this situation.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make use of the Abstract Factory we''ll first need a class that requires
    the use of some ruling family:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now call this `CourtSession` class and inject different functionality
    depending on which factory we pass in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Despite the differences between a static language and JavaScript, this pattern
    remains applicable and useful in JavaScript applications. Creating a kit of objects,
    which work together, is useful in a number of situations; any time a group of
    objects need to collaborate to provide functionality but may need to be replaced
    wholesale. It may also be a useful pattern when attempting to ensure that a set
    of objects be used together without substitutions.
  prefs: []
  type: TYPE_NORMAL
- en: Builder
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our fictional world we sometimes have some rather complicated classes, which
    need to be constructed. The classes contain different implementations of an interface
    depending on how they are constructed. In order to simplify the building of these
    classes and encapsulate the knowledge about building the class away from the consumers,
    a builder may be used. Multiple concrete builders reduce the complexity of the
    constructor in the implementation. When new builders are required, a constructor
    does not need to be added, a new builder just needs to be plugged in.
  prefs: []
  type: TYPE_NORMAL
- en: 'Tournaments are an example of a complicated class. Each tournament has a complicated
    setup involving the events, the attendees, and the prizes. Much of the setup for
    these tournaments is similar: each one has a joust, archery, and a melee. Creating
    a tournament from multiple places in the code means that the responsibility for
    knowing how to construct a tournament is distributed. If there is a need to change
    the initiation code then it must be done in a lot of different places.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Employing a builder pattern avoids this issue by centralizing the logic necessary
    to build the object. Different concrete builders can be plugged into the builder
    to construct different complicated objects. The relationship between the various
    classes in the builder pattern is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Builder](img/00042.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s drop in and look at some of the code. To start with, we''ll create a
    number of utility classes, which will represent the parts of a tournament as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The tournament itself is a very simple class as we don''t need to assign any
    of the public properties explicitly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll implement two builders which create different tournaments. This can
    be seen in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally the director, or as we''re calling it `TournamentBuilder`, simply takes
    a builder and executes it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Again you'll see that the JavaScript implementation is far simpler than the
    traditional implementation due to there being no need for interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Builders need not return a fully realized object. This means that you can create
    a builder which partially hydrates an object then allows the object to be passed
    on to another builder for it to finish. A good real world analogy might be the
    manufacturing process for a car. Each station along the assembly line builds just
    a part of the car before passing it onto the next station to build another part.
    This approach allows for dividing the work of building an object amongst several
    classes with limited responsibility. In our example above we could have a builder
    that is responsible for populating the events and another that is responsible
    for populating the attendees.
  prefs: []
  type: TYPE_NORMAL
- en: Does the builder pattern still make sense in view of JavaScript's prototype
    extension model? I believe so. There are still cases where a complicated object
    needs to be created according to different approaches.
  prefs: []
  type: TYPE_NORMAL
- en: Factory method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve already looked at the Abstract Factory and a builder. The Abstract Factory
    builds a family of related classes and the builder creates complicated objects
    using different strategies. The factory method pattern allows a class to request
    a new instance of an interface without the class making decisions about which
    implementation of the interface to use. The factory may use some strategy to select
    which implementation to return:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Factory method](img/00043.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Sometimes this strategy is simply to take a string parameter or to examine some
    global setting to act as a switch.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In our example world of Westeros there are plenty of times when we would like
    to defer the choice of implementation to a factory. Just like the real world,
    Westeros has a vibrant religious culture with dozens of competing religions worshiping
    a wide variety of gods. When praying in each religion, different rules must be
    followed. Some religions demand sacrifices while others demand only that a gift
    be given. The prayer class doesn't want to know about all the different religions
    and how to construct them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with creating a number of different gods to which prayers can
    be offered. This code creates three gods including a default god to whom prayers
    fall if no other god is specified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'I''ve avoided any sort of implementation details for each god. You may imagine
    whatever traditions you want to populate the `prayTo` methods. There is also no
    need to ensure that each of the gods implements an `IGod` interface. Next we''ll
    need a factory, which is responsible for constructing each of the different gods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see that in this example we''re taking in a simple string to decide
    how to create a god. It could be done via a global or via a more complicated object.
    In some polytheistic religions in Westeros, gods have defined roles as gods of
    courage, beauty, or some other aspect. The god to which one must pray is determined
    by not just the religion but the purpose of the prayer. We can represent this
    with a `GodDeterminant` class as is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The factory would be updated to take this class instead of the simple string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the last step is to see how this factory would be used. It is quite
    simple, we just need to pass in a string that denotes which religion we wish to
    observe and the factory will construct the correct god and return it. This code
    demonstrates how to call the factory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Once again there is certainly need for a pattern such as this in JavaScript.
    There are plenty of times where separating the instantiation from the use is useful.
    Testing the instantiation is also very simple thanks to the separation of concerns
    and the ability to inject a fake factory to allow testing of `Prayer` is also
    easy.
  prefs: []
  type: TYPE_NORMAL
- en: Continuing the trend of creating simpler patterns without interfaces, we can
    ignore the interface portion of the pattern and work directly with the types,
    thanks to duck typing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Factory Method is a very useful pattern: it allows classes to defer the selection
    of the implementation of an instantiation to another class. This pattern is very
    useful when there are multiple similar implementations such as the strategy pattern
    (see [Chapter 5](part0111_split_000.html#39REE1-015e68c68a464f18a9559f448be84435
    "Chapter 5. Behavioral Patterns"), *Behavioral Patterns*) and is commonly used
    in conjunction with the Abstract Factory pattern. The Factory Method is used to
    build the concrete objects within a concrete implementation of the abstract factory.
    An Abstract Factory pattern may contain a number of Factory Methods. Factory Method
    is certainly a pattern that remains applicable in the land of JavaScript.'
  prefs: []
  type: TYPE_NORMAL
- en: Singleton
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Singleton pattern is perhaps the most overused pattern. It is also a pattern
    that has fallen out of favor in recent years. To see why people are starting to
    advise against using Singleton let's take a look at how the pattern works.
  prefs: []
  type: TYPE_NORMAL
- en: Singleton is used when a global variable is desirable, but Singleton provides
    protection against accidentally creating multiple copies of complex objects. It
    also allows for the deferral of object instantiation until the first use.
  prefs: []
  type: TYPE_NORMAL
- en: 'The UML diagram for Singleton looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Singleton](img/00044.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: It is clearly a very simple pattern. The Singleton acts as a wrapper around
    an instance of the class and the singleton itself lives as a global variable.
    When accessing the instance we simply ask the Singleton for the current instance
    of the wrapped class. If the class does not yet exist within the Singleton it
    is common to create a new instance at that time.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Within our ongoing example in the world of Westeros, we need to find a case
    where there can only ever be one of something. Unfortunately, it is a land with
    frequent conflicts and rivalries, and so my first idea of using the king as the
    Singleton is simply not going to fly. This split also means that we cannot make
    use of any of the other obvious candidates (capital city, queen, general, and
    so on). However, in the far north of Westeros there is a giant wall constructed
    to keep an ancient enemy at bay. There is only one of these walls and it should
    pose no issue having it in the global scope.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go ahead and create a singleton in JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The code creates a lightweight representation of the Wall. The Singleton is
    demonstrated in the two highlighted sections. In a language like C# or Java we
    would normally just set the constructor to be private so that it could only be
    called by the static method `getInstance`. However, we don''t have that ability
    in JavaScript: constructors cannot be private. Thus we do the best we can and
    return the current instance from the constructor. This may appear strange but
    in the way we''ve constructed our classes the constructor is no different from
    any other method so it is possible to return something from it.'
  prefs: []
  type: TYPE_NORMAL
- en: In the second highlighted section we set a static variable, `_instance`, to
    be a new instance of the Wall when one is not already there. If that `_instance`
    already exists, we return that. In C# and Java, there would need to be some complicated
    locking logic in this function to avoid race conditions as two different threads
    attempted to access the instance at the same time. Fortunately, there is no need
    to worry about this in JavaScript where the multi-threading story is different.
  prefs: []
  type: TYPE_NORMAL
- en: Disadvantages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Singletons have gained something of a bad reputation in the last few years.
    They are, in effect, glorified global variables. As we've discussed, global variables
    are ill conceived and the potential cause of numerous bugs. They are also difficult
    to test with unit tests as the creation of the instance cannot easily be overridden
    and any form of parallelism in the test runner can introduce difficult-to-diagnose
    race conditions. The single largest concern I have with them is that singletons
    have too much responsibility. They control not just themselves but also their
    instantiation. This is a clear violation of the single responsibility principle.
    Almost every problem that can be solved by using a Singleton is better solved
    using some other mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript makes the problem even worse. It isn't possible to create a clean
    implementation of the Singleton due to the restrictions on the constructor. This,
    coupled with the general problems around the Singleton, lead me to suggest that
    the Singleton pattern should be avoided in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Prototype
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The final creational pattern in this chapter is the Prototype pattern. Perhaps
    this name sounds familiar. It certainly should: it is the mechanism through which
    JavaScript inheritance is supported.'
  prefs: []
  type: TYPE_NORMAL
- en: We looked at prototypes for inheritance but the applicability of prototypes
    need not be limited to inheritance. Copying existing objects can be a very useful
    pattern. There are numerous cases where being able to duplicate a constructed
    object is handy. For instance, maintaining a history of the state of an object
    is easily done by saving previous instances created by leveraging some sort of
    cloning.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Westeros, we find that members of a family are frequently very similar;
    as the adage goes: "like father, like son". As each generation is born it is easier
    to create the new generation through copying and modifying an existing family
    member than to build one from scratch.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 2](part0086_split_000.html#2I0GC1-015e68c68a464f18a9559f448be84435
    "Chapter 2. Organizing Code"), *Organizing Code*, we looked at how to copy existing
    objects and presented a very simple piece of code for cloning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This code can easily be altered to be used inside a class to return a copy
    of itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The highlighted section of code is the modified clone method. It can be used
    as such:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The Prototype pattern allows for a complex object to be constructed only once
    and then cloned into any number of objects that vary only slightly. If the source
    object is not complicated there is little to be gained from taking a cloning approach.
    Care must be taken when using the prototype approach to think about dependent
    objects. Should the clone be a deep one?
  prefs: []
  type: TYPE_NORMAL
- en: Prototype is obviously a useful pattern and one that forms an integral part
    of JavaScript from the get go. As such it is certainly a pattern that will see
    some use in any JavaScript application of appreciable size.
  prefs: []
  type: TYPE_NORMAL
- en: Tips and tricks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creational patterns allow for specialized behavior in creating objects. In many
    cases, such as the factory, they provide extension points into which crosscutting
    logic can be placed. That is to say logic that applies to a number of different
    types of objects. If you're looking for a way to inject, say, logging throughout
    your application, then being able to hook into a factory is of great utility.
  prefs: []
  type: TYPE_NORMAL
- en: For all the utility of these creational patterns they should not be used very
    frequently. The vast majority of your object instantiations should still be just
    the normal method of improving the objects. Although it is tempting to treat everything
    as a nail when you've got a new hammer, the truth is that each situation needs
    to have a specific strategy. All these patterns are more complicated than simply
    using `new` and complicated code is more liable to have bugs than simple code.
    Use `new` whenever possible.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter presented a number of different strategies for creating objects.
    These methods provide abstractions over the top of typical methods for creating
    objects. The Abstract Factory provides a method for building interchangeable kits
    or collections of related objects. The Builder pattern provides a solution to
    telescoping parameters issues. It makes the construction of large complicated
    objects easier. The Factory Method, which is a useful complement to Abstract Factory,
    allows different implementations to be created though a static factory. Singleton
    is a pattern for providing a single copy of a class that is available to the entire
    solution. It is the only pattern we've seen so far which has presented some questions
    around applicability in modern software. The Prototype pattern is a commonly used
    pattern in JavaScript for building objects based on other existing objects.
  prefs: []
  type: TYPE_NORMAL
- en: We'll continue our examination of classical design patterns in the next chapter
    by looking at structural patterns.
  prefs: []
  type: TYPE_NORMAL
