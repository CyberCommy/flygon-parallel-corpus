- en: Timers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Timers give us  the ability to set up an artifact where the OS lets us know
    once the specified time has expired—is a ubiquitous application (and, indeed,
    kernel) feature. Of course, the timer is usually only useful if it is running
    in parallel with the application logic; this asynchronous notification behavior
    is achieved by different means, very often by having the kernel send the relevant
    process a signal.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we shall explore the available interfaces on Linux for setting
    up and working with timers. These interfaces fall into two broad categories—the
    older APIs (`alarm(2)`, `[get|set]itimer(2)`), and the shiny, newer POSIX APIs
    (`timer_create(2)`, `timer_[set|get]time(2)`, and so on*)*. Of course, as signals
    are quite heavily employed along with timers, we make use of the signal interfaces
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: We would also like to point out that, due to the intrinsic dynamic nature of
    timers, statically seeing the output of our sample programs in the book will not
    suffice; as usual, we definitely urge the reader to clone the book's GitHub repository
    and try out the code themselves.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, the reader will learn to use the various timer interfaces (APIs)
    exposed by the Linux kernel. We begin with the older ones, which, though they
    have limitations are still very much used in system software, as the need arises.
    A simple **command-line interface** (**CLI**)- only digital clock program is written
    and analyzed using these APIs. Then we move the reader on to the more recent and
    powerful POSIX Timer API set. Two very interesting sample programs—a "how quickly
    can you react" game and a run-walk interval timer application—are shown and studied.
    We close with a brief mention of using timer APIs via the file abstraction, and
    what a watchdog timer is.
  prefs: []
  type: TYPE_NORMAL
- en: Older interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As previously mentioned, the older interfaces include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The `alarm(2)` system call
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The interval timer`[get|set]itimer(2)`system call APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's begin with the first of them.
  prefs: []
  type: TYPE_NORMAL
- en: The good ol' alarm clock
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `alarm(2)`system call allows a process to set up a simple timeout mechanism;
    its signature is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'It is, indeed, quite self-explanatory. Let''s take a simple example: A process
    wants to set up a timer that will expire in three seconds from now, so `alarm(3)`
    is essentially the code to use to do this.'
  prefs: []
  type: TYPE_NORMAL
- en: What exactly happens in the aforementioned code? Three seconds after the alarm system
    call is issued—that is, after the timer has been armed—the kernel will send the
    signal `SIGALRM` to the process.
  prefs: []
  type: TYPE_NORMAL
- en: 'The default action of `SIGALRM` (signal # 14 on x86) is to terminate the process.'
  prefs: []
  type: TYPE_NORMAL
- en: Thus, we expect the developer to catch the signal (via the `sigaction(2)` system
    call would be best, as discussed in depth in the preceding [Chapter 11](99fafa09-8972-4d9f-b241-46caf9de98f3.xhtml),
    *Signaling - Part I*, and [Chapter 12](657b6be0-ebc8-40dd-81b6-4741b04602b1.xhtml),
    *Signaling - II* ).
  prefs: []
  type: TYPE_NORMAL
- en: If the parameter input to alarm is `0`, any pending `alarm(2)` will be canceled
    (Actually, this will happen in any case when the alarm API is invoked.)
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the alarm API, unusually for a system call, returns an unsigned integer
    (thus `-1` cannot be returned, which is the usual failure case). Instead, it returns
    the number of seconds to any previous programmed timeout, or zero if none was
    pending.
  prefs: []
  type: TYPE_NORMAL
- en: A simple program (`ch13/alarm1.c`) demonstrating the basic usage of `alarm(2)` follows;
    the parameter specifies the number of seconds to time out in.
  prefs: []
  type: TYPE_NORMAL
- en: For readability, only the key parts of the source code are displayed in the
    following; to view the complete source code, build it, and run it, the entire
    tree is available for cloning from GitHub here: [https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux](https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux).
  prefs: []
  type: TYPE_NORMAL
- en: 'The signal trapping and timer arming code is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'What happens once the `SIGALRM` signal is dispatched to the process by the
    kernel; that is, once the timer times out? The signal handler runs, of course.
    Here it is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s a quick build and test run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We now enhance the previous code (`ch13/alarm1.c`) to have the timeout continually
    repeat (the source file is `ch13/alarm2_rep.c`); the relevant code snippet (which
    has changed from the previous code) is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Though it does not apply here, realize that calling `alarm(2)`automatically
    cancels any previously pending timeout. A quick trial run is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The alarm now repeats (every second in the above example run). Also notice how
    we just kill the process with a keyboard *Ctrl *+ *C* (delivering the `SIGINT`,
    which, as we haven't trapped it, just terminates the foreground process.
  prefs: []
  type: TYPE_NORMAL
- en: Alarm API – the downer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have looked at using the (simplistic) `alarm(2)`API, it''s important
    to realize that it has several downsides:'
  prefs: []
  type: TYPE_NORMAL
- en: A very coarse granularity timeout (a minimum of one second, which is a very
    long time on a modern processor!)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running more than a single timeout in parallel is not possible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's not possible to query or modify the timeout value at a later point—attempting
    to do so will cancel it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mixing the following APIs can result in problems/conflicts (in the following,
    the latter API may be internally implemented using the former)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`alarm(2)` and `setitimer(2)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`alarm(2)` and `sleep(3)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's always possible that the timeout occurs later than expected (overrun)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As we progress through this chapter, we will find more powerful functions that
    can overcome most of these issues. (Well, to be fair, the poor `alarm(2)`does
    have an upside: for simplistic purposes, it''s really quick and easy to use!)'
  prefs: []
  type: TYPE_NORMAL
- en: Interval timers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The interval timer APIs allow a process to set up and query a timer that can
    be programmed to auto-recur at a fixed time interval. The relevant system calls
    are these:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Quite obviously, the `setitimer(2)` is used to set up a new timer; the `getitimer(2)` can
    be used to query it, and returns the time remaining.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first parameter to both is `which`—it specifies the type of timer to use. Linux
    allows us to use three types of interval timer:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ITIMER_REAL`: Use this timer type to count down in real-time, which is also
    called wall clock time. Upon timer expiry, the kernel sends the signal `SIGALRM`
    to the calling process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ITIMER_VIRTUAL`: Use this timer type to count down in virtual time; that is,
    the timer only counts down when the calling process (all threads) is running in
    user space on the CPU. Upon timer expiry, the kernel sends the signal `SIGVTALRM`
    to the calling process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ITIMER_PROF`: Use this timer type to count down in virtual time too; this
    time, the timer  counts down when the calling process (all threads) is running
    in both user-space and/or kernel space on the CPU. Upon timer expiry, the kernel
    sends the signal `SIGPROF` to the calling process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thus, to have a timer that should expire when a certain amount of time has expired,
    use the first one; one can use the remaining two types to profile a process's
    CPU usage. Only one timer of each of the preceding types can be used at a time
    (more on this is to follow).
  prefs: []
  type: TYPE_NORMAL
- en: 'The next parameter to examine is the `itimerval` data structure (and its internal `timeval` structure
    members; both are defined in the `time.h` header):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: (FYI, both the internal `time_t` and the `suseconds_t` typedefs translate to
    a long (integer) value.)
  prefs: []
  type: TYPE_NORMAL
- en: 'As we can see, this—the second parameter to `setitimer(2)`, which is a pointer
    to struct `itimerval` called `new_value`—is where we specify the new timer''s
    expiration times, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `it_value` structure member, place the initial timeout value. This value
    decreases as the timer runs down, and, at some point, will hit zero; at this point,
    the appropriate signal corresponding to the timer type will be delivered to the
    calling process.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Subsequent to the previous step, the `it_interval` structure member is checked.
    If it is non-zero, this value will be copied into the `it_value` structure, causing
    the timer to effectively auto-reset and run again for that amount of time; in
    other words, this is how the API fulfills the interval timer role.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also, clearly, the time expiry is expressed in seconds:microseconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if we wanted a repeating (interval) timeout every second, we need
    to initialize the structures as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: (Error checking code is not shown in the previous code for clarity.) Precisely
    this is done in the simple digital clock demo program that follows.
  prefs: []
  type: TYPE_NORMAL
- en: 'A few special cases exist:'
  prefs: []
  type: TYPE_NORMAL
- en: To cancel (or disarm) a timer, set both fields of the `it_timer` structure to
    zero and invoke the `setitimer(2)` API.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To create a single-shot timer—that is, one that expires exactly once—initialize
    both fields of the `it_interval` structure to zero, and then invoke the `setitimer(2)` API.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the third parameter to `setitimer(2`) is non-NULL, the previous timer value
    is returned here (as if the `getitmer(2)` API were invoked).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As is usual, the pair of system calls returns `0` on success and `-1` on failure
    (with `errno` set appropriately).
  prefs: []
  type: TYPE_NORMAL
- en: As there is one signal generated upon expiry of each type of timer, one can
    only have one instance of each timer type running concurrently within a given
    process. If we try and set up multiple timers of the same type (for example, `ITIMER_REAL`), it's
    always possible that multiple instances of the same signal (in this example, `SIGALRM`)
    will be delivered to the process—and to the same handler routine—simultaneously.
    As we learned in [Chapter 11](99fafa09-8972-4d9f-b241-46caf9de98f3.xhtml), *Signaling
    - Part I*, and [Chapter 12](657b6be0-ebc8-40dd-81b6-4741b04602b1.xhtml), *Signaling
    - Part II *, regular Unix signals cannot be queued, and signal instances might
    thus be dropped. In effect, it is best (and safest) to work concurrently with
    one of each type of timer in a given process.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table contrasts the simple` alarm(2)` system call API that we
    saw earlier with the more powerful `[set|get]itimer(2)` interval timer APIs that
    we have just seen:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Feature** | **Simple timer** [`alarm(2)`] | **Interval timers** [`setitimer(2)`,
    `getitimer(2)`] |'
  prefs: []
  type: TYPE_TB
- en: '| Granularity (resolution) | Very coarse; 1 second | Fine granularity; in theory,
    1 microsecond (in practice, typically milliseconds prior to 2.6.16 HRT[1]) |'
  prefs: []
  type: TYPE_TB
- en: '| Query time remaining | Not possible | Yes, with `getitimer(2)` |'
  prefs: []
  type: TYPE_TB
- en: '| Modify timeout | Not possible | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| Cancel timeout | Yes | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| Auto-repeating | No, but it can be set up manually | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| Multiple timers | Not possible | Yes, but at most three—one of each type
    (real, virtual, and profiling)—per process |'
  prefs: []
  type: TYPE_TB
- en: 'Table 1 : A quick comparison of the simple alarm(2)API and interval timers'
  prefs: []
  type: TYPE_NORMAL
- en: '[1] **High-resolution timers** (**HRT**); implemented in Linux 2.6.16 onward.
    See a link to a detailed paper on this in the *Further reading* section on the
    GitHub repository.'
  prefs: []
  type: TYPE_NORMAL
- en: What is knowledge without application? Let's try out the interval timer API.
  prefs: []
  type: TYPE_NORMAL
- en: A simple CLI digital clock
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We humans are quite used to seeing a clock tick away, one second at a time.
    Why not write a quick C program that mimics a (very simplistic command-line) digital
    clock that must show us the correct date and time every single second! (Well,
    personally, I prefer seeing the old-fashioned analog clocks, but, hey, this book
    does not go into the closely held secret mantras to perform graphical drawing
    with X11.)
  prefs: []
  type: TYPE_NORMAL
- en: 'How we achieve this is quite simple, really: we set up an interval timer that
    times out every one second. The program (`ch13/intv_clksimple.c`) which demonstrates
    the basic usage of the quite powerful `setitimer(2)` API follows.'
  prefs: []
  type: TYPE_NORMAL
- en: For readability, only key parts of the source code are displayed in the following;
    to view the complete source code, build it, and run it, the entire tree is available for
    cloning from GitHub here: [https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux](https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux).
  prefs: []
  type: TYPE_NORMAL
- en: 'The signal trapping and set up of the single-second interval timer is shown
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Notice the self-explanatory comment on why we typically do not use the `SA_RESTART`
    flag when working with signals that deliver timeouts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Setting up the interval timer is easy: we initialize the `itimerval` structure
    such that we set the seconds members—of the internal `timeval` structures—to `1`
    (we just leave the microseconds as zero), and issue the `setitimer(2)` system
    call. The timer is armed—it starts counting down. When a second has elapsed, the
    kernel will deliver the signal `SIGALRM` to the process (as the timer type is
    `ITIMER_REAL`). The signal handler routine `ticktock` will perform the task of
    obtaining and printing out the current timestamp (see its code as follows). The
    interval component being set to `1`, the timer will automatically and repeatedly
    fire every single second.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous signal handler routine gets invoked once a second, every second
    (as, of course, the kernel delivers the signal `SIGALRM` to the process upon timer
    expiry). The job of this routine is clear: it must query and print the current
    date-time; that is, the timestamp.'
  prefs: []
  type: TYPE_NORMAL
- en: Obtaining the current time
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Querying the current time is, at first glance, straightforward. Many programmers
    use the following API sequence to achieve it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We do not. Why is this? Recall our discussion on the async-signal-safe (reentrant)
    functions in the first of [Chapters 11](99fafa09-8972-4d9f-b241-46caf9de98f3.xhtml),
    *Signaling - Part I*, (within the section *Reentrant Safety and Signaling*). Of
    the aforementioned three APIs, only the `time(2)` API is considered signal-safe;
    the other two are not (that is, they should not be used within a signal handler).
    The relevant man page (`signal-safety(7)`) confirms this.
  prefs: []
  type: TYPE_NORMAL
- en: Hence, we use documented async-signal-safe APIs-the `time(2)`, `clock_gettime(2)`
    and `ctime_r(3)`—to perform the role of obtaining the timestamp safely. A quick
    peek at them follows.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `clock_gettime(2)` system call''s signature is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The first parameter is the clock source or clock type to use; the fact is that
    the Linux OS (and glibc) supports many different built-in types of clocks; among
    them are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CLOCK_REALTIME`: A system-wide wall-clock clock (in real-time); use this to
    query the timestamp.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CLOCK_MONOTONIC`: Monotonic clocks count in one direction (up, obviously;
    travelling backwards through time is a feature still being worked upon by mad
    (or are they?) scientists). It usually counts the time elapsed since the system
    boot.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CLOCK_BOOTTIME` (from Linux 2.6.39): This is pretty much the same as CLOCK_MONOTONIC,
    except that it takes into account time the system has been suspended.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CLOCK_PROCESS_CPUTIME_ID`: A measure of CPU time spent on CPU by all threads
    of a given process (via PID; use the `clock_getcpuclockid(3)` API to query it).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CLOCK_THREAD_CPUTIME_ID`: A measure of CPU time spent on CPU by a specific
    thread (use the `pthread_getcpuclockid(3)` API to query it).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are more; please refer the man page on `clock_gettime(2)` for details.
    For our current purposes, `CLOCK_REALTIME` is the one we will go with.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second parameter to `clock_gettime(2)`is a value-result style one; in effect,
    this is a return value. Upon a successful return, it will hold the timestamp in
    the `timeval` structure; the structure is defined in the `time.h` header, and
    holds the current timestamp in seconds and nanoseconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We shall be quite satisfied with the value in seconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'But how exactly is this value in seconds and nanoseconds interpreted? It''s
    actually very common in the Unix universe: Unix systems store time as the number
    of seconds elapsed since January 1, 1970 midnight (00:00)—think of it as Unix''s
    birth! This time value is called time since the Epoch or Unix time. Okay, so it''s
    going to be a rather large number of seconds today, right? So how does one express
    it in a human-readable format? We''re glad you asked, as that''s precisely the
    job of the `ctime_r(3)`API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The first parameter will be (a pointer to) the `time_t` member we got returned
    from  the `clock_gettime(2)` API; again, the second parameter is a value result-style
    return—on successful completion, it will hold the human-readable timestamp! Note
    that it's the application programmer's job to allocate memory for the buffer `buf` (and
    subsequently free it as required). In our code, we just use a statically allocated
    local buffer. (Of course, we perform error checking on all APIs.)
  prefs: []
  type: TYPE_NORMAL
- en: Finally, depending on the `opt` value (passed by the user), we either use the
    (safe) `write(2)` system call or the (unsafe!) `printf(3)`/`fflush(3)` APIs to
    print out the current time.
  prefs: []
  type: TYPE_NORMAL
- en: The code `printf("\r%s", tmstamp);` has the `printf(3)` using the `\r` format—this
    is the carriage return, which effectively brings the cursor back to the beginning
    of the same line. This gives the appearance of a clock constantly updating. This
    is nice, except for the fact that using `printf(3)`itself is signal-unsafe!
  prefs: []
  type: TYPE_NORMAL
- en: Trial runs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is a trial run, first with the signal-safe `write(2)`method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'And now, here''s one with the signal-unsafe `printf(3)`/`fflush(3)`method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: It looks nicer, what with the timestamp being continually refreshed on the same
    line, but is unsafe. This book cannot show you, dear reader, the pleasant effect
    of the carriage return- style `printf("\r...")`. Do try it out on your Linux system
    to see this for yourself.
  prefs: []
  type: TYPE_NORMAL
- en: We understand that using the `printf(3)` and `fflush(3)`APIs within a signal
    handler is bad programming practice—they are not async-signal safe.
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if the low-level design specification demands that we use exactly
    these APIs? Well, there''s always a way: why not redesign the program to use one
    of the synchronous blocking APIs to wait upon and catch signal(s) wherever appropriate
    (Remember, when trapping  fatal signals such as `SIGILL`, `SIGFPE`, `SIGSEGV`,
    and `SIGBUS`, it''s recommended to use the usual async `sigaction(2)` API): the
    `sigwait(3)`, `sigwaitinfo(2)`, `sigtimedwait(2)` or even the `signalfd(2)` API
    (that we covered in [Chapter 12](657b6be0-ebc8-40dd-81b6-4741b04602b1.xhtml), *Signaling
    - Part II*, section *Synchronously blocking for signals via the sigwait* APIs*).
    We leave this as an exercise for the reader.'
  prefs: []
  type: TYPE_NORMAL
- en: A word on using the profiling timers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have explored, in some detail, the usage of the `ITIMER_REAL` timer type—which
    counts down in real-time. What about using the other two—the `ITIMER_VIRTUAL`
    and `ITIMER_PROF`—timers? Well, the code styling is very similar; there''s nothing
    new there. The catch that a developer who is new to this faces is this: the signal(s)
    may never seem to arrive at all!'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a simple code snippet using the `ITIMER_VIRTUAL` timer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: When run, no output appears—the timer is seemingly not working.
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s really not the case—it is working, but the catch is this: the process
    merely sleeps via the `pause(2)`. While sleeping, its not running on CPU; hence,
    the kernel has hardly decremented the (aforementioned, second-by-second) interval
    timer at all! Remember, both the `ITIMER_VIRTUAL` and `ITIMER_PROF` timers only
    decrement (or count down), when the process is on CPU. Thus, the one-second timer
    never actually expires, and the `SIGPROF` signal is never sent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, now, the way to solve the previous issue becomes obvious: let''s introduce
    some CPU processing into the program and reduce the timeout value. Our trusty `DELAY_LOOP_SILENT`macro
    (see source file `common.h`) has the process spin over some silly logic—the point
    being that it becomes CPU-intensive. Also, we have reduced the timer expiry to
    be expire for every 10 ms the process spends on the CPU:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, upon running, we see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The profiling timer is indeed working.
  prefs: []
  type: TYPE_NORMAL
- en: The newer POSIX (interval) timers mechanism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Earlier in this chapter, we saw in *Table 1 : A quick comparison of the simple*
    *alarm(2) API and interval timers*, that, although the interval timer `[get|set]itimer(2)`
    APIs are superior to the simplistic `alarm(2)` API, they still lack important
    modern features. The modern POSIX (interval) timer mechanism addresses several
    shortcomings, some of which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The resolution is improved a thousand-fold with the addition of nanosecond granularity timers
    (with the addition of an arch-independent HRT mechanism, which is integrated into
    2.6.16 Linux kernel onward).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A generic `sigevent(7)` mechanism—which is a way to handle asynchronous events
    such as timer expiry (our use case), AIO request completion, delivery of a message,
    and so on—to handle timer expiry. We are now not forced to tie timer expiry to
    the signaling mechanism.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Importantly, a process (or thread) can now set up and manage any number of timers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Well, ultimately, there''s always an upper limit: in this case, it''s the resource
    limit `RLIMIT_SIGPENDING`. (More technically, the fact is that the OS allocates
    a queued real-time signal for every timer created, which is thus the limit.)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These points are fleshed out as follows, so read on.
  prefs: []
  type: TYPE_NORMAL
- en: Typical application workflow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The design approach (and APIs used) to set up and use a modern POSIX timer
    follows; the sequence is typically in the order shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: Signal(s) setup.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assuming the notification mechanism being used is a signal, first trap the signal(s) 
    via `sigaction(2)`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create and initialize the timer(s).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decide on the clock type (or source) to use to measure the elapsed time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decide on the timer-expiry event-notification mechanism to be used by your application—typically,
    whether to use (the usual) signals or a (newly spawned) thread.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The aforementioned decisions are implemented via the `timer_create(2)` system
    call; thereby it allows one to create a timer, and, of course, we can create multiple
    timers by invoking it multiple times.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arm (or disarm) a particular timer  using `timer_settime(2)`. To arm a timer
    means to effectively start it running—counting down; disarming a timer is the
    opposite—stopping it in its tracks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To query the time remaining (to expiration) in a particular timer (and its interval
    setting) use `timer_gettime(2)`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check the overrun count of a given timer using `timer_getoverrun(2)`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delete (and obviously disarm) a timer using `timer_delete(2)`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating and using a POSIX (interval) timer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As seen previously, we use the powerful `timer_create(2)` system call to create
    a timer for the calling process (or thread, for that matter):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We have to link with the **real time** (**rt**) library to make use of this
    API. The `librt`library implements the POSIX.1b Realtime Extensions to POSIX interfaces.
    Find a link to the `librt`man page in the *Further Reading *section on the GitHub
    repository.
  prefs: []
  type: TYPE_NORMAL
- en: The first parameter passed to `timer_create(2)`informs the OS of the clock source to
    be used; we avoid repetition of the matter and refer the reader to the section
    *Obtaining the current time* covered earlier in the chapter, in which we enumerated
    several of the commonly used clock sources in Linux. (Also, as noted there, one
    can refer to the man page on `clock_gettime(2)` for additional details.)
  prefs: []
  type: TYPE_NORMAL
- en: 'The second parameter passed to `timer_create(2)`is interesting: it provides
    a generic way to specify the timer-expiry event-notification mechanism to be used
    by your application! To understand this, let''s take a look at the `sigevent` structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: (Recall that we have already come across and used the `union sigval` mechanism
    to pass along a value to a signal handler in [Chapter 11](99fafa09-8972-4d9f-b241-46caf9de98f3.xhtml),
    *Signaling - Part I*, and [Chapter 12](657b6be0-ebc8-40dd-81b6-4741b04602b1.xhtml),
    *Signaling - Part II*.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Valid values for the `sigev_notify` member are enumerated in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Notification method** : `sigevent.sigev_notify` | **Meaning** |'
  prefs: []
  type: TYPE_TB
- en: '| `SIGEV_NONE` | Nothing done upon event arrival—a null notification |'
  prefs: []
  type: TYPE_TB
- en: '| `SIGEV_SIGNAL` | Notification by sending the process the signal specified
    in the `sigev_signo` member |'
  prefs: []
  type: TYPE_TB
- en: '| `SIGEV_THREAD` | Notification by invoking (actually, spawning) a (new) thread
    whose function is `sigev_notify_function`, the parameter passed to it is `sigev_value`,
    and if `sigev_notify_attributes` is non-NULL it should be a `pthread_attr_t `structure
    for the new thread. (Readers, note that we shall cover multithreading in detail
    in subsequent chapters.) |'
  prefs: []
  type: TYPE_TB
- en: '| `SIGEV_THREAD_ID` | Linux-specific and used to specify a kernel thread that
    will run upon timer expiry; realistically, only threading libraries make use of
    this functionality. |'
  prefs: []
  type: TYPE_TB
- en: 'Table 2 : Using the sigevent(7) mechanism'
  prefs: []
  type: TYPE_NORMAL
- en: In the first case, `SIGEV_NONE`, the timer can always be manually checked for
    expiry via the `timer_gettime(2)`API.
  prefs: []
  type: TYPE_NORMAL
- en: 'The more interesting and common case is the second one, `SIGEV_SIGNAL`. Here,
    a signal is delivered to the process whose timer has expired; the process''s `sigaction(2)`
    handler''s `siginfo_t` data structure is populated appropriately; for our use
    case—that of using a POSIX timer—this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`si_code` (or signal origin field) is set to the value `SI_TIMER` to denote
    that a POSIX timer has expired (look up the other possibilities within the man
    page on `sigaction`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`si_signo` is set to the signal number (`sigev_signo`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`si_value` will be the value set in the union `sigev_value`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For our purposes (in this chapter, at least), we shall only consider the case
    of setting the `sigevent` notification type to the value `SIGEV_SIGNAL` (and thus
    setting the signal to deliver in the `sigev_signo` member).
  prefs: []
  type: TYPE_NORMAL
- en: The third parameter passed to `timer_create(2)`, `timer_t *timerid`, is a (now
    common) value result-style one; it is, in effect, the return ID of the newly created
    POSIX timer! Of course, the system call returns `-1` on failure (and `errno` is
    set accordingly), and `0` on success. The `timerid` is the handle to the timer—we
    shall typically pass it as a parameter in the subsequent POSIX timer APIs to specify
    a particular timer to act upon.
  prefs: []
  type: TYPE_NORMAL
- en: The arms race – arming and disarming a POSIX timer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As mentioned previously, we use the `timer_settime(2)` system call to either
    arm (start) or disarm (stop) a timer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: As one can have multiple concurrent POSIX timers running simultaneously, thus
    we need to specify exactly which timer we are referring to; this is done via the
    first parameter `timer_id`, which is the timer's ID, and the effective return
    of the previously seen `timer_create(2)` system call.
  prefs: []
  type: TYPE_NORMAL
- en: 'The important data structure employed here is the `itimerspec`; its definition
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'So, it should be quite clear: within the third parameter, a pointer to the `itimerspec` structure
    called, `new_value`:'
  prefs: []
  type: TYPE_NORMAL
- en: We can specify the time to the (theoretical) resolution to a single nanosecond!
    Note that the time is measured with respect to the clock source that was specified
    by the `timer_create(2`) API.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This reminds us, one can always query the clock resolution with the `clock_getres(2)` API.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With respect to initializing the `it_value`  (`timespec` structure):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set it to a non-zero value to specify the initial timer-expiry value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set it to zero to specify that we are disarming (stopping) the timer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What if this structure is holding a positive value already? Then it's overwritten,
    and the timer is re-armed with the new values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Not only that, but, by initializing the `it_interval` (timespec structure) to
    a non-zero value, we will set up a repeating - interval - timer (hence the name
    POSIX interval timer); the time interval being the value it is initialized to.
    The timer will continue to fire indefinitely, or until it's disarmed or deleted.
    If, instead, this structure is zeroed out, the timer becomes a one-shot timer
    (firing just once when the time specified in the it_value member elapses).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In general, set the `flags` value to `0`—the man page on `timer_settime(2)` specifies
    an additional flag that could be used. Finally, the fourth parameter `old_value` (again,
    a pointer to struct `itimerspec`) works as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: If `0`, it is simply ignored.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If non-zero, it is a means to query the time remaining to the expiry of the
    given timer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The time to expiry will be returned in the `old_value->it_value` member (in
    seconds and nanoseconds), and the interval it was set will be returned in the `old_value->it_interval` member.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As expected, the return value on success is `0` and is `-1` on failure (with `errno`
    being set appropriately).
  prefs: []
  type: TYPE_NORMAL
- en: Querying the timer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A given POSIX timer can be queried at any point to fetch the time remaining
    to timer expiry via the `timer_gettime(2`) system call API; its signature is as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Quite obviously, the first parameter passed to `timer_gettime(2)` is the ID
    of the particular timer to query, and the second parameter passed is the value
    result-style return—the time to expiry is returned in it (within the structure
    of type `itimerspec`).
  prefs: []
  type: TYPE_NORMAL
- en: As we know from preceding, the struct `itimerval` itself consists of two data
    structures of type `timespec`; the time remaining to timer expiry will be placed
    in the `curr_value->it_value` member. If this value is 0, it implies that the
    timer has been stopped (disarmed). If the value placed in the
  prefs: []
  type: TYPE_NORMAL
- en: '`curr_value->it_interval` member is positive, it indicates the interval at
    which the timer will repeatedly fire (after the first timeout); if 0, it implies
    the timer is a single-shot one (with no repeating timeouts).'
  prefs: []
  type: TYPE_NORMAL
- en: Example code snippet showing the workflow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the following, we display code snippets from our sample program `ch13/react.c`
    (see more on this rather interesting reaction time game app in the following section),
    which clearly illustrates the sequence of steps previously described.
  prefs: []
  type: TYPE_NORMAL
- en: 'Signal(s) set up:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Assuming the notification mechanism being used is a signal, first trap the
    signal(s)  via `sigaction(2)` as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Create and initialize the timer(s):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Decide on the clock type (or source) to use to measure the elapsed time:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We use the real-time clock `CLOCK_REALTIME` the system-wide wall clock time,
    as our timer source.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decide on the timer-expiry event-notification mechanism to be used by your application—typically,
    whether to use (the usual) signals or a (newly spawned) thread.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We use signaling as the timer-expiry event-notification mechanism.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The aforementioned decisions are implemented via the`timer_create(2)` system
    call, which allows one to create a timer; of course, we can create multiple timers
    by invoking it multiple times:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Arm (or disarm) a particular timer using the `timer_settime(2)` API. To arm
    a timer means to effectively start it running, or counting down; disarming a timer
    is the opposite—stopping it in its tracks:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: To query the time remaining (to expiration) in a particular timer (and its interval
    setting), use `timer_gettime(2)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is not performed in this particular application.
  prefs: []
  type: TYPE_NORMAL
- en: Check the overrun count of a given timer using `timer_getoverrun(2)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An explanation of what this API does, and why we might need it, is provided
    in the following section, *Figuring the overrun*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Delete (and obviously disarm) a timer using `timer_delete(2)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is not performed in this particular application (as the process exit will,
    of course, delete all timers associated with the process.)
  prefs: []
  type: TYPE_NORMAL
- en: 'As the man page on `timer_create(2)` informs us, a few more points to note
    on POSIX (interval) timers are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Upon `fork(2)`, all timers get auto-disarmed; in other words, timers are not
    going to continue towards expiry in the child process.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Upon `execve(2)`, all timers are deleted and will thus not be visible in the
    successor process.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Something useful of note is that (from the Linux 3.10 kernel onward) the proc filesystem
    can be used to query the timer(s) a process owns; just lookup cat the pseudo-`file /proc/<pid>/timers` to
    see them (if they exist).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From the Linux 4.10 kernel onward, POSIX timers are a kernel-configurable option
    (at kernel build time, they are enabled by default).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we have repeatedly mentioned, the man pages are a very precious and useful
    resource that is available to developers; again, the man page on `timer_create(2)` ([https://linux.die.net/man/2/timer_create](https://linux.die.net/man/2/timer_create))
    provides a nice example program; we urge the reader to refer to the man page,
    read it, build it and try the program out.
  prefs: []
  type: TYPE_NORMAL
- en: Figuring the overrun
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's say we use signaling as the event-notification mechanism to tell us that
    a POSIX timer has expired, and let's say that the timer-expiry period is a very
    small amount of time (say, a few tens of microseconds); for example, 100 microseconds.
    This implies that every 100 microseconds the signal will be delivered to the target
    process!
  prefs: []
  type: TYPE_NORMAL
- en: In these circumstances, it's quite reasonable to expect that the process, being
    delivered the same ever-repeating signal at such a high rate, cannot possibly
    handle it. We also know from our knowledge on signaling that, in cases precisely
    like this, using a real-time signal would be far superior to using a regular Unix
    signal, as the OS has the ability to queue real-time signals but not regular signals—they
    (regular signals) will be dropped and only a single instance preserved.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we shall use a real-time signal (say, `SIGRTMIN`) to denote timer expiry;
    however, with a really tiny timer expiry (for example, as we said, 100 microseconds),
    even this technique will not suffice! The process will certainly be overrun by
    the rapid delivery of the same signal. For precisely these situations, one can
    retrieve the actual number of overruns that occurred between the timer expiry
    and the actual signal processing. How do we do this? There are two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: One is via the signal handler's `siginfo_t->_timer->si_overrun`  member (implying
    we specified the `SA_SIGINFO` flag when trapping the signal with sigaction)—this
    is the overrun count.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, this method is Linux-specific (and non-portable). A simpler, portable
    method of obtaining the overrun count is by using the `timer_getoverrun(2)` system
    call. The downside here being that system calls have far more overhead than a
    memory lookup; as in life, when there's an upside, there's also a downside.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: POSIX interval timers – example programs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Programming is ultimately learned and understanding is deeply internalized by
    doing, not simply seeing or reading. Let's take our own advice and cut a couple
    of decent code examples, to illustrate using the POSIX (interval) timer APIs.
    (Of course, dear reader, it implies you do the same!)
  prefs: []
  type: TYPE_NORMAL
- en: The first sample program is a small CLI game of "how quickly can you react"?
    The second sample program is a simple implementation of a run-walk timer. Read
    on for the gory details.
  prefs: []
  type: TYPE_NORMAL
- en: The reaction – time game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We all understand that modern computers are fast! Of course, that's a very relative
    statement. How fast, exactly? That's an interesting question.
  prefs: []
  type: TYPE_NORMAL
- en: How fast is fast?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 2](976fc2af-8bb4-4060-96cd-3b921682ed75.xhtml), *Virtual Memory*,
    in the section on the memory pyramid, we saw *Table 2: Memory Hierarchy Numbers.* Here,
    a representative look at the numbers was done—the typical access speeds for different
    kinds of memory technologies (for both the embedded and server space) are enumerated
    in the table.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A quick recap gives us the following in terms of typical memory (and network)
    access speeds. Of course, these numbers are only indicative, and the very latest
    hardware might well have superior performance characteristics; here, the concept
    is what''s being focused upon:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **CPU registers** | **CPU caches** | **RAM** | **Flash** | **Disk** | **Network
    roundtrip** |'
  prefs: []
  type: TYPE_TB
- en: '| 300 - 500 ps | 0.5 ns (L1) to 20 ns (L3) | 50–100 ns | 25–50 us | 5–10 ms
    | >= 100s of ms |'
  prefs: []
  type: TYPE_TB
- en: 'Table 3 : Hardware memory speed summary table'
  prefs: []
  type: TYPE_NORMAL
- en: Most of these latency values are so tiny that we, as humans, cannot actually
    visualize them (see the information box on *average human reaction times* further
    on). So, that brings up the question. What minimally tiny numbers can we humans
    even hope to quite correctly visualize and relate to? The short answer is a few
    hundred milliseconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'Why do we make such a statement? Well, if a computer program told you to react
    quick as you can and press a certain keyboard key combination immediately upon
    seeing a message, how long would it take? So, what we''re really attempting to
    test here is the human reaction time to a visual stimulus. Ah, that''s what we
    can empirically answer by writing this precise program: a reaction timer!'
  prefs: []
  type: TYPE_NORMAL
- en: Do note that this simple visual stimulus reaction test is not considered to
    be scientific; we completely ignore important delay-inducing mechanisms such as
    the computer-system hardware and software itself. So don't beat yourself up on
    the results you get when you try it out!
  prefs: []
  type: TYPE_NORMAL
- en: Our react game – how it works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So, at a high level, here''s the step-by-step plan for the program (the actual
    code is shown in the following section; we suggest you first read this and then
    check out the code):'
  prefs: []
  type: TYPE_NORMAL
- en: Create and initialize a simple alarm; program it to expire at a random time—anywhere
    between 1 and 5 seconds from the program's start
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The moment the alarm expires, do the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arm a POSIX (interval) timer (to the frequency specified in the first parameter).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Display a message requesting the user to press *Ctrl *+ *C* on the keyboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Take a timestamp (let's call it `tm_start`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the user actually presses *^C* (*Ctrl *+ *C*; which we will know, simply,
    by trapping SIGINT via `sigaction(2)`), again, take a timestamp (let's call it `tm_end`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calculate the user's reaction time (as `tm_end` - `tm_start`) and display it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (Notice how the previous steps follow the *Typical application workflow* we
    described earlier in this chapter.)
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, we ask the user to specify the interval timer's interval in milliseconds
    (the first parameter), and an optional verbose option as the second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Breaking it down further (in more detail), the initialization code performs
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Traps signals via `sigaction(2)`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SIGRTMIN`: We shall use signal notification to specify the timer expiration;
    this is the signal generated upon our POSIX interval timer''s expiry.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SIGINT`: The signal generated when the user reacts by pressing the *^C* keyboard
    key combination.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SIGALRM`: The signal generated when our initial random alarm expires'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Set up the POSIX interval timer:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initialize the `sigevent` structure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create the timer (with a real-time clock source) with `timer_create(2)`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initialize the `itimerspec` structure to the frequency value specified by the
    user (in ms)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Displays a message to the user:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: At any random time between 1 and 5 seconds the alarm expires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We enter the `SIGALRM` handler function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It displays the `*** QUICK! Press ^C !!! *** `message
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It calls `timer_settime(2)` to arm the timer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It takes the `tm_start` timestamp (with the `clock_gettime(2)` API)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The POSIX interval timer now runs; it expires every `freq_ms` milliseconds (the
    value provided by the user); when running in verbose mode, we display a `**.**` for
    each timer expiry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The user, at some point, near or far, reacts and presses* Ctrl *+ *C*(*^C*);
    in the code for the signal handler for SIGINT, we do the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Take the `tm_end` timestamp (with the `clock_gettime(2)` API)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calculate the delta (the reaction time!) via `tm_end` - `tm_start`, and display
    it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exit.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: React – trial runs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is best to see the program in action; of course, the reader would do well
    (and enjoy this exercise a whole lot more!) to actually build and try it out for
    himself/herself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We first run it with a 10 millisecond frequency and without verbosity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'After a random interval of between 1 and 5 seconds, this message appears and
    the user must react:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, with a 10 millisecond frequency and verbose mode on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'After a random interval of between 1 and 5 seconds, this message appears and
    the user must react:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Now the period character,`.`,appears rapidly, appearing once for every single
    expiry of our POSIX interval timer; that is, once every 10 ms in this run.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: In our previous sample runs, the user took 405 ms and 379 ms to react; as we
    mentioned, it's in the hundreds of milliseconds range. Take the challenge—how
    much better can you do?
  prefs: []
  type: TYPE_NORMAL
- en: 'Research findings indicate the following numbers for average human reaction
    times:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Stimulus** | **Visual** | **Auditory** | **Touch** |'
  prefs: []
  type: TYPE_TB
- en: '| Average human reaction time | 250 ms | 170 ms | 150 ms |'
  prefs: []
  type: TYPE_TB
- en: Source: [https://backyardbrains.com/experiments/reactiontime](https://backyardbrains.com/experiments/reactiontime).We
    have become used to using phrases such as "in the blink of an eye" to mean really
    quickly. Interestingly, how long does it actually take to blink an eye? Research
    indicates that it takes an average of 300 to 400 ms!
  prefs: []
  type: TYPE_NORMAL
- en: The react game – code view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Some key functionality aspects are shown as follows; first is the code that
    sets up the signal handler for `SIGRTMIN` and creates the POSIX interval (`ch13/react.c`):'
  prefs: []
  type: TYPE_NORMAL
- en: For readability, only key parts of the source code are displayed in the following;
    to view the complete source code, build it, and run it, the entire tree is available for
    cloning from GitHub, here: [https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux](https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The surprise start is implemented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s invoked as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The signal handler (the function `startoff`) and associated logic for the alarm
    (for `SIGALRM`) is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember, while the user is lolling around, our POSIX interval timer continues
    to set and reset itself at the frequency specified by the user (as the first parameter
    passed, which we save in the variable `freq_ms`); so, every `freq_ms` milliseconds,
    our process will receive the signal `SIGRTMIN`. Here''s its signal handler routine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'When the user does (finally!) press *^C,* the signal handler for SIGINT (the
    function `userpress`) is invoked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The run:walk interval timer application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This book's author is a self-confessed recreational runner. In my humble opinion,
    runners/joggers, especially when starting out (and frequently, even experienced
    ones), can benefit from a consistently followed run:walk pattern (the unit is
    minutes, typically).
  prefs: []
  type: TYPE_NORMAL
- en: The idea behind this is that running continuously is hard, especially for beginners.
    Often, coaches have the newbie runner follow a useful run:walk strategy; run for
    some given amount of time, then take a walk break for a given time period, then repeat—run
    again, walk again—indefinitely, or until your target distance (or time) goal is
    met.
  prefs: []
  type: TYPE_NORMAL
- en: For example, when a beginner runs distances of, say, 5 km or 10 km, (s)he might
    follow a consistent 5:2 run:walk pattern; that is, run for 5 minutes, walk for
    2 minutes, keep repeating this, until the run is done. (Ultra-runners, on the
    other hand, might prefer something akin to a 25:5 strategy.)
  prefs: []
  type: TYPE_NORMAL
- en: Why not write a run:walk timer application to help out both our budding and
    serious runners.
  prefs: []
  type: TYPE_NORMAL
- en: We shall do just that. First, though, from the viewpoint of understanding this
    program better, let's imagine the program is written and working—we shall give
    it a spin.
  prefs: []
  type: TYPE_NORMAL
- en: A few trial runs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we simply run the program without passing any parameters, the help screen
    is displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'As can be seen, the program expects a minimum of two parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: The time to run (in seconds) [required]
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The time to walk (in seconds) [required]
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The verbosity level [optional]
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The optional third parameter, the verbosity level, allows the user to request
    more or less information as the program executes (always a useful way to instrument,
    and thus help debug, programs). We provide three possible verbosity levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '`OFF`: Nothing besides the required matter is displayed (pass the third parameter
    0)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LOW`: The same as for level OFF, plus we use the period character `**.**` to
    show the elapse of time—every second, a `**.** `is printed to `stdout` [default]'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HIGH`: The same as for level OFF, plus we show the internal data structure
    values, time to timer expiry, and so on (pass the third parameter 2)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s first try running at the default verbosity level (LOW), with the following
    spec:'
  prefs: []
  type: TYPE_NORMAL
- en: Run for 5 seconds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Walk for 2 seconds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Okay, okay, we know, you''re fitter than that—you can run:walk for longer than
    5s:2s. Forgive us, but here''s the thing: for the purpose of the demo, we do not
    really want to wait until 5 minutes and then another 2 minutes have elapsed, just
    to see if it works, right? (When you''re using this app on your run, then please
    convert minutes to seconds and go for it!).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Enough said; let''s fire up the run:walk POSIX timer for a 5:2 run:walk interval:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Yes, it works; we break it off by typing *^C* (*Ctrl *+ *C)*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding trial run was at the default verbosity level of `LOW`; now let''s
    rerun it with the same 5:2 run:walk interval, but with the verbosity level set
    to `HIGH` by passing `2` as the third parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The details are revealed; every second, the time remaining on our POSIX timer's
    expiry is shown (to the resolution of a millisecond). When the timer does expire,
    the OS delivers the real-time signal `SIGRTMIN` to the process; we enter the signal
    handler `its_time`, then we print out the signal information obtained from the struct
    `siginfo_t` pointer. We receive the signal number (34) and the pointer within
    the union `si->si_value`, which is the pointer to our application context data
    structure, so that we can access it without the use of globals (more on this later). (Of
    course, as noted several times, it's unsafe to use `printf(3)` and variants in
    a signal handler as they are signal-async-unsafe. We have done it here just as
    a demo; do not code like this for production use. A `Bzzzz!!!` message represents
    the buzz of the timer going off, of course; the program instructs the user to
    proceed with `RUN!` or `WALK!`, accordingly, and the number of seconds to do it
    for. The whole process repeats indefinitely.
  prefs: []
  type: TYPE_NORMAL
- en: The low – level design and code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This simple program will allow you to set up the number of seconds to run and
    to walk. It will time out accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: In this application, we use a simple one-shot POSIX timer to do the job. We
    set the timer to use signal notification as the timer expiry notification mechanism.
    We set up a signal handler for a RT signal (SIGRTMIN). Next, we initially set
    the POSIX timer to expire after the run period, then, when the signal does arrive
    in the signal handler, we reset (re-arm) the timer to expire after the walk period
    seconds. This essentially repeats forever, or until the user aborts the program
    by pressing *^C*.
  prefs: []
  type: TYPE_NORMAL
- en: For readability, only key parts of the source code are displayed in the following;
    to view the complete source code, build it, and run it, the entire tree is available for
    cloning from GitHub, here: [https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux](https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux).
  prefs: []
  type: TYPE_NORMAL
- en: 'Many real-world applications (indeed, any software) often requires several
    pieces of information—the state or application context—to be available to all
    functions at any given point in time; in other words, to be global. Ordinarily,
    one would just declare them as global (static) variables and proceed. We have
    a suggestion: why not encapsulate all of them into a single data structure? In
    fact, why not make it our own by typedef-ing a structure. Then we can allocate
    memory to it, initialize it, and just pass around its pointer in a manner that
    does not require it to be global. That would be efficient and elegant.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'In our app, to keep things simple, we just statically allocate memory to (further,
    notice that it''s a local variable, not global):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The initialization work is carried out here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Trap the real-time signal (`SIGRTMIN`) (delivered upon timer expiry).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Initialize our app context run:walk data structure:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In particular, we set the type to run and the timeout value (seconds) to the
    time passed by the user in the first parameter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The timer-expiry event-notification mechanism is selected as signaling via the `sigev_notify` member
    of our `sigevent` structure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is useful to set the data passed along via the `sigev_value.sival_ptr` member
    as the pointer to our app context; this way, we can always gain access to it within
    the signal handler (eliminating the need to keep it global).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create the POSIX timer with the real-time clock source, and set it's ID to the `timerid` member
    of our app context runwalk structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arm—or start—the timer. (Recall, it's been initialized to expire in run seconds.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In our preceding trial run, the run is set for 5 seconds, so, 5 seconds from
    the start, we shall asynchronously enter the signal handler for `SIGRTMIN`, `its_time`,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'In the signal handling code, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: (As mentioned previously) gain access to our app context data structure (by
    typecasting the `si->si_value.sival_ptr` to our (`sRunWalk *`) data type).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In HIGH verbose mode, we display more details (again, do not use `printf(3)`
    in production).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then, if the just-expired timer was the `RUN` one, we call our buzzer function `BUZZ `with
    the `WALK` message parameter, and, importantly:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Re-initialize the timeout value (seconds) to the duration for WALK (the second
    parameter passed by the user).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Toggle the type from RUN to WALK.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Re-arm the timer via the `timer_settime(2)` API.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And vice versa when transiting from the just-expired WALK to RUN mode.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This way, the process runs forever (or until the user terminates it via *^C*),
    continually timing out for the next run:walk interval.
  prefs: []
  type: TYPE_NORMAL
- en: Timer lookup via proc
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One more thing: interestingly, the Linux kernel allows us to peek deep inside
    the OS; this is (typically) achieved via the powerful Linux proc filesystem. In
    our current context, proc allows us to look up all the timers that a given process
    has. How is this done? By reading the pseudo-file `/proc/<PID>/timers`. Check
    it out. The screenshot below illustrates this being performed on the `runwalk_timer `process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ad7905d9-56a1-4f12-92c2-e77102b33333.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The terminal window on the left is where the `runwalk_timer` application runs;
    while it''s running, in the terminal window on the right, we lookup the proc filesystem''s
    pseudo-file `/proc/<PID>/timers`. The output clearly reveals the following:'
  prefs: []
  type: TYPE_NORMAL
- en: There's just one (POSIX) timer within the process (ID `0`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The timer-expiry event-notification mechanism is signaling, because we can
    see that `notify:signal/pid.<PID>` and signal: 34 are associated with this timer
    (signal: 34 is `SIGRTMIN`; use `kill -l` 34 to verify this).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The clock source associated with this timer is `ClockID 0`; that is, the real-time
    clock.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A quick mention
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To round off this chapter, we present a quick look at two interesting technologies:
    timers via the file abstraction model and watchdog timers. These sections are
    not covered in detail; we leave it to the interested reader to dig further.'
  prefs: []
  type: TYPE_NORMAL
- en: Timers via file descriptors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Do you recall a key philosophy of the Unix (and, thus, Linux) design that we
    covered in [Chapter 1](c17af8c2-a426-4ab6-aabb-aa1374e56cc4.xhtml), *Linux System
    Architecture*, of this book? That is, everything is a process; if it's not a process,
    it's a file. The file abstraction is heavily used on Linux; here, too, with timers, we
    find that there is a way to represent and use timers via the file abstraction.
  prefs: []
  type: TYPE_NORMAL
- en: How is this done? The `timerfd_*` APIs provide the required abstraction. In
    this book, we shall not attempt to delve into the intricate details; rather, we
    would like the reader to become aware that one can use the file abstraction—reading
    a timer via the read(2) system call—if required.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table quickly outlines the `timerfd_*` API set:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **API** | **Purpose** | **Equivalent to the POSIX timer API** |'
  prefs: []
  type: TYPE_TB
- en: '| `timerfd_create(2)` | Create a POSIX timer; the return value on success is
    the file descriptor associated with this timer. | `timer_create(2)` |'
  prefs: []
  type: TYPE_TB
- en: '| `timerfd_settime(2)` | (Dis)arm a timer referred to by the first parameter `fd`.
    | `timer_settime(2)` |'
  prefs: []
  type: TYPE_TB
- en: '| `timerfd_gettime(2)` | On successful completion, returns both the time to
    expiry and interval of the timer referred to by the first parameter `fd`. | `timer_gettime(2)`
    |'
  prefs: []
  type: TYPE_TB
- en: 'Table 4 : The timerfd_* APIs'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The real advantage to using file descriptors to represent various objects is
    that one can use a uniform, powerful set of APIs to operate upon them. In this
    particular case, we can monitor our file-based  timer(s) via the `read(2)`, `poll(2)`,
    `select(2)`, `epoll(7)`, and similar APIs.
  prefs: []
  type: TYPE_NORMAL
- en: What if the process that created the fd-based timer forks or execs? Upon a `fork(2)`,
    the child process will inherit a copy of the file descriptor pertaining to any
    timer created in the parent via  the `timerfd_create(2)` API. Effectively, it
    shares the same timer as the parent process.
  prefs: []
  type: TYPE_NORMAL
- en: Upon an `execve(2)`, the timer(s) remain valid in the successor process and
    will continue expiring upon timeout; unless, upon creation, the TFD_CLOEXEC flag
    was specified.
  prefs: []
  type: TYPE_NORMAL
- en: More detail (along with an example) can be found in the man page here: [https://linux.die.net/man/2/timerfd_create](https://linux.die.net/man/2/timerfd_create).
  prefs: []
  type: TYPE_NORMAL
- en: A quick note on watchdog timers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A watchdog is essentially a timer-based mechanism that is used to periodically
    detect if the system is in a healthy state, and if it is deemed not to be, to
    reboot it.
  prefs: []
  type: TYPE_NORMAL
- en: This is achieved by setting up a (kernel) timer (with, say, a 60-second timeout).
    If all is well, a watchdog daemon process will consistently disarm the timer before
    it expires, and subsequently re-enable (arm) it; this is known as *petting the
    dog*. If the daemon does not disarm the watchdog timer (due to something having
    gone badly wrong), the watchdog is annoyed and reboots the system.
  prefs: []
  type: TYPE_NORMAL
- en: A daemon is a system background process; more on daemons in [Appendix B](https://www.packtpub.com/sites/default/files/downloads/Daemon_Processes.pdf),
    *Daemon Processes*.
  prefs: []
  type: TYPE_NORMAL
- en: A pure software watchdog implementation will not be protected against kernel
    bugs and faults; a hardware watchdog (which latches into the board-reset circuitry)
    will always be able to reboot the system as and when required.
  prefs: []
  type: TYPE_NORMAL
- en: Watchdog timers are very often used in embedded systems, especially deeply embedded
    ones (or those unreachable by a human for whatever reason); in a worst-case scenario,
    it can reboot, and hopefully move along with its designated tasks again. A famous
    example of a watchdog timer causing reboots is the Pathfinder robot, NASA sent
    to the Martian surface back in 1997 (yes, the one that encountered the priority
    inversion concurrency bug while on Mars. We shall explore this a little in [Chapter
    15](5e7e9c60-48d8-41bd-adef-31bbfd598c78.xhtml), *Multithreading with Pthreads
    Part II - Synchronization*, on multithreading and concurrency). And, yes, that's
    the very same Pathfinder robot that is given a role in the superb movie The Martian!
    More on this in the *Further reading* section on the GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, the reader has been taken through the various interfaces exposed
    by Linux with regard to creating and using timers. Setting up and managing timeouts
    is an essential component of many, if not most, systems applications. The older
    interfaces—the venerable `alarm(2)` API, followed by the `[s|g]etitimer(2)` system
    calls—were shown with example code. Then, we delved into the newer and better POSIX
    timers, including the advantages provided by them, and how to use them in a practical
    fashion. This was greatly aided with the help of two fairly elaborate sample programs—the
    react game and the run:walk timer application. Finally, the reader was introduced
    to the notion of using timers via file abstractions, and to the watchdog timer.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter is where we begin our long three-chapter journey on understanding
    and using the powerful multithreading framework on Linux.
  prefs: []
  type: TYPE_NORMAL
