- en: Chapter 4. Layout, Elements, and Controls
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last chapter discussed XAML, a neutral language used to create objects and
    set up their properties. But XAML is just a tool—the content is what matters.
    Building an effective user interface involves at least selecting the best elements
    and controls to achieve the usability and required user experience.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we'll take a look at the WinRT layout system and discuss the
    major elements and controls that comprise most user interfaces.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Introducing layout
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Layout is the process of element placement and their size and position changes
    in face of user interactions or content changes. In the Win32/MFC world layout
    is mostly very simple and limited. Controls are placed using distance from the
    top-left point of a window and their size is explicitly specified. This model
    has very limited flexibility; if a control's content changes (for example, becomes
    bigger), the control can't compensate automatically. Other similar changes have
    no effect on the UI layout.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: WinRT, on the other hand, provides a much more flexible model based around a
    set of layout panels that provide different ways to lay out elements. By combining
    those panels in various ways, complex and adaptive layouts can be created.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: Layout is a two-step process. First, the layout container asks each of its children
    for their desired size. In the second step, it uses whatever logic is applicable
    (for that panel type) to determine at what position and what size each child element
    be, and places each child in that rectangular area.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: 'Each element indicates to its parent its size requirements. The following figure
    summarizes the most important properties related to these requirements:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: '![Introducing layout](img/5022_04_01.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
- en: 'Here''s a quick breakdown of these important properties:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: '`Width`/`Height` – the width and height of the element in question. This is
    not typically set (unset value being the default value—`"Auto"`—in XAML; more
    on that in a moment), meaning the element would like to be as big as it needs
    to be. Nevertheless, these may be set if needed. The actual (rendered) width and
    height of an element is available using the `FrameworkElement::ActualWidth` and
    `ActualHeight` read-only properties.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MinWidth`/`MaxWidth`/`MinHeight`/`MaxHeight` – the minima and maxima for the
    element size (not shown in the figure). Default values are `0` for the minima,
    and infinite for the maxima.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Margin` – a "breathing space" around the element. This is of type `Thickness`
    that has four fields (`Left`, `Top`, `Right`, and `Bottom`) that determine the
    amount of space around the element. It can be specified in XAML using four values
    (left, top, right, bottom), two values (the first is left and right, the second
    top and bottom), or a single number (the same distance in all four directions).'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Padding` – same idea as `Margin`, but determines the space between the outer
    edge of the element and its content (if any). This is typed as `Thickness` as
    well, and is defined by the `Control` base class and some other special elements,
    such as `Border` and `TextBlock`.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HorizontalAlignment`/`VerticalAlignment` – specifies how to align the element
    against its parent if extra space is available. Possible values are `Left`, `Center`,
    `Right`, and `Stretch` (for `HorizontalAlignment`) and `Top`, `Center`, `Bottom`,
    and `Stretch` for `VerticalAlignment`.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HorizontalContentAlignment`/`VerticalContentAlignment` (not shown in the figure)
    – same idea as `Horizontal`/`VerticalAlignment`, but for the `Content` of the
    element (if any).'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FlowDirection` – can be used to switch the layout direction from the default
    (`LeftToRight`) to `RightToLeft`, suitable for right to left languages, such as
    Hebrew or Arabic. This effectively turns every "left" to "right" and vice versa.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After the layout panel collects the required size of each child element (by
    calling `UIElement::Measure` on each one), it moves on to the second stage of
    the layout—arranging. In this stage, the panel calculates the final positions
    and sizes of its child elements based on the element's desired size (`UIElement::DesiredSize`
    read-only property) and whatever algorithm is appropriate for that panel and informs
    each element of the resulting rectangle by calling `UIElement::Arrange`. This
    procedure can go on recursively, because an element can be a layout panel in itself,
    and so on. The result is known as a visual tree.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在布局面板收集每个子元素所需的大小（通过对每个元素调用`UIElement::Measure`）之后，它进入布局的第二阶段——排列。在这个阶段，面板根据元素的期望大小（`UIElement::DesiredSize`只读属性）和适合该面板的任何算法来计算其子元素的最终位置和大小，并通过调用`UIElement::Arrange`通知每个元素所得到的矩形。这个过程可以递归进行，因为一个元素本身可以是一个布局面板，依此类推。结果被称为可视树。
- en: Note
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Interested readers may be wondering how to specify the `"Auto"` XAML value for,
    for example, `Width` in code, given that this is a `double` value. This is done
    by including `<limits>` and then using the expression `std::numeric_limits<double>::quiet_NaN()`.
    Similarly, to specify an infinite value, use `std::numeric_limits<double>::infinity()`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 感兴趣的读者可能想知道如何在代码中为`Width`（例如）指定`"Auto"`XAML值，因为这是一个`double`值。这是通过包括`<limits>`，然后使用表达式`std::numeric_limits<double>::quiet_NaN()`来完成的。类似地，要指定无限值，请使用`std::numeric_limits<double>::infinity()`。
- en: Layout panels
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 布局面板
- en: All layout panels must derive from the `Windows::UI::Xaml::Controls::Panel`
    class, itself deriving from `FrameworkElement`. The main addition `Panel` is the
    `Children` property (also its `ContentProperty` for easier XAML authoring), which
    is a collection of elements implementing the `IVector<UIElement>` interface. By
    using the `Children` property, elements can be dynamically added or removed from
    a `Panel`. WinRT provides a bunch of specific panels, each with its own layout
    logic, providing flexibility in creating the layout. In the following sections,
    we'll take a look at some of the built-in layout panels.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 所有布局面板都必须派生自`Windows::UI::Xaml::Controls::Panel`类，它本身派生自`FrameworkElement`。主要的附加`Panel`是`Children`属性（也是它的`ContentProperty`，用于更容易的XAML编写），它是实现`IVector<UIElement>`接口的元素集合。通过使用`Children`属性，可以动态地向`Panel`添加或删除元素。WinRT提供了一堆特定的面板，每个面板都有自己的布局逻辑，提供了创建布局的灵活性。在接下来的章节中，我们将看一些内置的布局面板。
- en: Note
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: All panel classes, as well as elements and controls described later, are assumed
    to exist in the `Windows::UI::Xaml::Controls` namespace, unless noted otherwise.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 所有面板类，以及稍后描述的元素和控件，都假定存在于`Windows::UI::Xaml::Controls`命名空间中，除非另有说明。
- en: StackPanel
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: StackPanel
- en: '`StackPanel` is one of the simplest layout panels. It lays out its children
    in a *stack*, one after the other, horizontally or vertically, based on the `Orientation`
    property (`Vertical` being the default).'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`StackPanel`是最简单的布局面板之一。它根据`Orientation`属性（`Vertical`是默认值）在*堆栈*中水平或垂直地布置其子元素。'
- en: 'When used for vertical layout, each element gets the height it wants and all
    the available width, and vice versa. Here''s an example of `StackPanel` with some
    elements:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当用于垂直布局时，每个元素都会得到它想要的高度和所有可用的宽度，反之亦然。这是`StackPanel`与一些元素的示例：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This is how it looks at runtime (after some text is entered):'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这是运行时的样子（在输入一些文本后）：
- en: '![StackPanel](img/5022_04_02.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![StackPanel](img/5022_04_02.jpg)'
- en: '`StackPanel` is useful for small layout tasks, as part of other, more complex
    layout panels.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`StackPanel`对于小型布局任务很有用，作为其他更复杂的布局面板的一部分。'
- en: Grid
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Grid
- en: '`Grid` is probably the most useful layout panel because of its flexibility.
    It creates a table-like layout of cells. Elements can occupy single or multiple
    cells, and cell size is customizable. We''ve used `Grid` to create the calculator
    layout from the previous chapter. Here''s another `Grid` example (wrapped in a
    `Border` element), a piece of markup for a login page:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`Grid`可能是最有用的布局面板，因为它很灵活。它创建了一个类似表格的单元格布局。元素可以占据单个或多个单元格，单元格大小是可定制的。我们已经使用`Grid`来创建了上一章中的计算器布局。这里是另一个`Grid`示例（包装在`Border`元素中），一个登录页面的标记：'
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This is how it looks at runtime:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这是运行时的样子：
- en: '![Grid](img/5022_04_03.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![Grid](img/5022_04_03.jpg)'
- en: The number of rows and columns is not specified by simple properties. Instead,
    it's specified using `RowDefinition` objects (for rows) and `ColumnDefinition`
    objects (for columns). The reason has to do with the size and behavior that can
    be specified on a row and/or column basis.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 行数和列数不是通过简单的属性来指定的。而是使用`RowDefinition`对象（对于行）和`ColumnDefinition`对象（对于列）来指定。原因在于可以根据行和/或列的大小和行为来指定。
- en: '`RowDefinition` has a `Height` property, while `ColumnDefintion` has a `Width`
    property. Both are of type `GridLength`. There are three options for setting `GridLength`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`RowDefinition`有一个`Height`属性，而`ColumnDefintion`有一个`Width`属性。两者都是`GridLength`类型。有三种设置`GridLength`的选项：'
- en: A specific length
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特定长度
- en: A star-based (relative) factor (this is the default, and factor equals 1)
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于星号的（相对）因子（这是默认值，因子等于1）
- en: Automatic length
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动长度
- en: Setting `Height` (of a `RowDefintion`) or `Width` (of a `ColumnDefinition`)
    to a specific number makes that row/column that particular size. In code it's
    equivalent to `ref new GridLength(len)`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 将`Height`（`RowDefintion`）或`Width`（`ColumnDefinition`）设置为特定数字会使该行/列具有特定的大小。在代码中，它相当于`ref
    new GridLength(len)`。
- en: Setting `Height` or `Width` to `"Auto"` (in XAML) makes the row/column as high/wide
    as it needs to be based on the tallest/widest element placed within that row/column.
    In code, it's equivalent to the static property `GridLength::Auto`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在XAML中将`Height`或`Width`设置为`"Auto"`会使行/列的高度/宽度根据放置在该行/列中的最高/最宽元素的需要而定。在代码中，它相当于静态属性`GridLength::Auto`。
- en: 'The last option (which is the default) is setting `Height`/`Width` to `n*`
    in XAML, where *n* is a number (`1` if omitted). This sets up a relationship with
    other rows/columns that have a "star" length. For example, here are three rows
    of a `Grid`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个选项（默认情况下）是在XAML中将`Height`/`Width`设置为`n*`，其中*n*是一个数字（如果省略则为`1`）。这将与具有“星号”长度的其他行/列建立关系。例如，这是`Grid`的三行：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This means that the first row is twice as tall as the second row (`Height="*"`).
    The last row is three times taller than the second row, and is one-and-a-half
    times taller than the first row. These relations are maintained, even if the `Grid`
    is dynamically resized due to layout changes.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着第一行的高度是第二行的两倍（`Height="*"`）。最后一行比第二行高三倍，比第一行高一倍半。即使`Grid`由于布局更改而动态调整大小，这些关系也会保持不变。
- en: Note
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The value for the "star" factor need not be a whole number; it can be a floating
    point value as well. The ratio is what matters, not the actual numbers.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: “星号”因子的值不必是整数；它也可以是浮点数值。重要的是比例，而不是实际数字。
- en: Elements are placed in specific grid cells using the attached `Grid.Row` and
    `Grid.Column` properties (both default to zero, meaning the first row and column).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 使用附加的`Grid.Row`和`Grid.Column`属性将元素放置在特定的网格单元格中（两者默认为零，意味着第一行和第一列）。
- en: Elements occupy one cell by default. This can be changed by using the `Grid.RowSpan`
    and `Grid.ColumnSpan` properties (this was set for the first `TextBlock` in the
    previous XAML).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 元素默认情况下占用一个单元格。可以通过使用`Grid.RowSpan`和`Grid.ColumnSpan`属性来更改这一点（在先前的XAML中为第一个`TextBlock`设置了这个属性）。
- en: Tip
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: It's ok to specify `ColumnSpan` or `RowSpan` with a large number to ensure an
    element will occupy all cells in a given direction. The `Grid` automatically will
    use the actual row/column count.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用大数字指定`ColumnSpan`或`RowSpan`以确保元素将占据给定方向上的所有单元格。`Grid`将自动使用实际的行/列计数。
- en: Canvas
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 画布
- en: '`Canvas` models the classic Win32/MFC layout – exact positioning. This type
    of layout is useful if exact coordinates are required, such as the case with graphs,
    animations, graphic games, and other complex drawings. `Canvas` is the fastest
    layout panel, just because it does very little layout (in fact almost none at
    all).'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`Canvas`模拟了经典的Win32/MFC布局——精确定位。如果需要精确坐标，例如图形、动画、图形游戏和其他复杂绘图的情况下，这种布局很有用。`Canvas`是最快的布局面板，因为它几乎没有布局（实际上几乎没有）。'
- en: 'Here''s an example of `Canvas` hosting some shapes:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`Canvas`托管一些形状的示例：
- en: '[PRE3]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The output is shown as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '![Canvas](img/5022_04_04.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![Canvas](img/5022_04_04.jpg)'
- en: The placement coordinates are set using the `Canvas.Left` and `Canvas.Top` attached
    properties (both default to zero, meaning the top-left corner of the `Canvas`).
    The only other attached property that `Canvas` defines is `ZIndex`. This specifies
    the relative order of rendering the elements inside the `Canvas`, where a large
    value places the element on top. By default, elements defined later in XAML are
    higher in the Z-order.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Canvas.Left`和`Canvas.Top`附加属性设置放置坐标（两者默认为零，意味着`Canvas`的左上角）。`Canvas`定义的唯一其他附加属性是`ZIndex`。这指定了在`Canvas`内部渲染元素的相对顺序，其中大值将元素放置在顶部。默认情况下，XAML中后定义的元素在Z顺序中更高。
- en: 'As a more complex example, suppose we wanted to allow the user to drag the
    shapes around the `Canvas` using the mouse or a finger. First, we''ll add event
    handlers for pointer pressing, releasing, and movement:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 作为更复杂的示例，假设我们想要允许用户使用鼠标或手指在`Canvas`上拖动形状。首先，我们将为指针按下、释放和移动添加事件处理程序：
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The concept of "pointer" replaces the "mouse" event names that may be familiar
    from Win32/MFC/WPF/Silverlight; pointer is generic, representing any pointing
    device, be it a mouse, stylus, or a finger.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: “指针”的概念取代了可能熟悉的来自Win32/MFC/WPF/Silverlight的“鼠标”事件名称；指针是通用的，代表任何指针设备，无论是鼠标、触控笔还是手指。
- en: The pointer-related events use the bubbling strategy, meaning any pressing on
    elements (such as the shapes used) will raise `PointerPressed` on that shape first,
    and if unhandled (as in this case), bubble up to its parent (the `Canvas`) where
    it does get handled.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 与指针相关的事件使用冒泡策略，这意味着对元素（例如使用的形状）的任何按压都会首先引发该形状上的`PointerPressed`事件，如果未处理（在这种情况下），则会冒泡到其父级（`Canvas`）上，那里会得到处理。
- en: 'The `PointerPressed` event may be handled like so:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`PointerPressed`事件可以这样处理：'
- en: '[PRE5]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Since this event fires on the `Canvas`, even though the original elements are
    the children of one of the `Canvas`, how do we get to that child element? The
    sender argument is the actual object that sent the event—the `Canvas` in this
    case. The child element is indicated by the `PointerRoutedEventArgs::OriginalSource`
    property (inherited from `RoutedEventArgs`). First, a check is made to see if
    the pointer pressing is in fact on the `Canvas` itself. If so, the method returns
    immediately.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 由于此事件在`Canvas`上触发，即使原始元素是`Canvas`的子元素，我们如何才能到达该子元素？发送者参数是实际发送事件的对象——在这种情况下是`Canvas`。子元素由`PointerRoutedEventArgs::OriginalSource`属性指示（从`RoutedEventArgs`继承）。首先，检查是否按下指针实际上在`Canvas`本身上。如果是，该方法立即返回。
- en: Note
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: With the preceding `Canvas`, this will never happen. The reason is that the
    default `Background` of the `Canvas` (or any other `Panel` for that matter) is
    `nullptr`, so that no events can register on it—they propagate to its parent.
    If events on the `Canvas` itself are desirable, `Background` must be some non-`nullptr`
    `Brush`; using `ref new SolidColorBrush(Colors::Transparent)` is good enough if
    the parent's background `Brush` is to show through.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的`Canvas`中，这是不可能发生的。原因是`Canvas`的默认`Background`（或者任何其他`Panel`）是`nullptr`，因此无法在其上注册事件——它们会传播到其父级。如果需要`Canvas`本身上的事件，`Background`必须是一些非`nullptr`的`Brush`；如果父级的背景`Brush`需要显示，使用`ref
    new SolidColorBrush(Colors::Transparent)`就足够了。
- en: Next, the position of the press is extracted in two steps, first using `PointerRoutedEventArgs::GetCurrentPointer()`
    (this is a `PointerPoint` object) and second, with the `PointerPoint::Position`
    property (of type `Windows::Foundation::Point`). Then the point is adjusted to
    become the offset of the pressing point to the top-left corner position of the
    element, this helps in making the later movement accurate.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，通过两个步骤提取按压的位置，首先使用`PointerRoutedEventArgs::GetCurrentPointer()`（这是一个`PointerPoint`对象），然后使用`PointerPoint::Position`属性（类型为`Windows::Foundation::Point`）。然后调整该点，使其成为按压点到元素左上角位置的偏移量，这有助于使后续移动准确。
- en: Capturing the pointer (`UIElement::CapturePointer`) ensures the `Canvas` continues
    to receive pointer-related events no matter where the pointer is. Setting `PointerRoutedEventArgs::Handled`
    to `true` prevents further bubbling (as there's no need here), and a flag indicating
    movement should occur from now on, until the pointer released is set (another
    private member variable).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 捕获指针（`UIElement::CapturePointer`）确保`Canvas`继续接收指针相关事件，无论指针在何处。将`PointerRoutedEventArgs::Handled`设置为`true`可以防止进一步的冒泡（因为这里没有必要），并且设置一个标志，指示从现在开始应该发生移动，直到释放指针（另一个私有成员变量）。
- en: Note
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Pointer capturing is similar in concept to mouse capturing that exists in other
    UI technologies (Win32/MFC/WPF/Silverlight).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 指针捕获与其他UI技术（Win32/MFC/WPF/Silverlight）中存在的鼠标捕获概念类似。
- en: 'When the pointer moves, the element in question needs to move as well, as long
    as the pointer has not yet been released:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当指针移动时，相关元素也需要移动，只要指针尚未释放：
- en: '[PRE6]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The main idea here is moving the element by setting the attached `Canvas` properties
    `Canvas.Left` and `Canvas.Top` (using the static `Canvas::SetLeft` and `Canvas::SetTop`
    methods).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的主要思想是通过设置附加的“Canvas”属性“Canvas.Left”和“Canvas.Top”（使用静态的“Canvas::SetLeft”和“Canvas::SetTop”方法）来移动元素。
- en: 'When the pointer is finally released, we just need to do some cleaning up:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当指针最终释放时，我们只需要进行一些清理工作：
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The complete code is in a project called `CanvasDemo` , part of the downloadable
    code for this chapter.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的代码在一个名为“CanvasDemo”的项目中，是本章可下载代码的一部分。
- en: Note
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The pointer-related methods may seem more complex than needed, but they're not.
    Since touch input is (more often than not) multi-touch, what happens if two fingers
    press on two different elements at the same time, trying to move them? Multiple
    `PointerPressed` events may trigger, and there should be a way to distinguish
    one finger from another. The previous code is implemented while assuming only
    one finger is used at a time.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 指针相关的方法可能看起来比需要的更复杂，但实际上并非如此。由于触摸输入通常是多点触控，如果两根手指同时按在两个不同的元素上并尝试移动它们会发生什么？可能会触发多个“PointerPressed”事件，因此需要一种方法来区分一个手指和另一个手指。先前的代码是在假设一次只使用一个手指的情况下实现的。
- en: Adding children to a panel dynamically
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 动态向面板添加子元素
- en: 'The `Panel::Children` property can be manipulated programmatically (for any
    `Panel` type). For example, using a `Canvas` as a drawing surface, we can use
    the previous pointer events to add `Line` elements that connect to each other
    to create a drawing. When the pointer is moving (after being pressed), `Line`
    objects may be added with code like the following:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: “Panel::Children”属性可以通过编程方式进行操作（适用于任何“Panel”类型）。例如，使用“Canvas”作为绘图表面，我们可以使用先前的指针事件来添加连接到彼此的“Line”元素以创建绘图。当指针移动（在按下后），可以使用以下代码添加“Line”对象：
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: A `Line` object is constructed, its properties set as appropriate, and finally
    it's added to the `Children` collection of the `Canvas`. Without this last step,
    the `Line` object is not attached to anything and simply dies out when its reference
    goes out of scope. `_paintBrush` is a `Brush` field maintained by the hosting
    page (not shown).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 构造了一个“Line”对象，设置了适当的属性，最后将其添加到“Canvas”的“Children”集合中。如果没有这最后一步，那么“Line”对象将不会附加到任何东西上，并且当其引用超出范围时，它将被销毁。`_paintBrush`是由托管页面维护的`Brush`字段（未显示）。
- en: 'The complete source is in a project called `SimpleDraw`, part of the downloadable
    code for this chapter. Here''s a sample drawing done with this application:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的源代码在一个名为“SimpleDraw”的项目中，是本章可下载代码的一部分。以下是使用此应用程序完成的示例绘图：
- en: '![Adding children to a panel dynamically](img/5022_04_05.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![动态向面板添加子元素](img/5022_04_05.jpg)'
- en: VariableSizedWrapGrid
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: VariableSizedWrapGrid
- en: '`StackPanel`, `Grid`, and `Canvas` are fairly straightforward; they are not
    much different from their counterparts in WPF or Silverlight. WinRT has some more
    interesting panels, starting with `VariableSizedWrapGrid`.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: “StackPanel”、“Grid”和“Canvas”都非常直观；它们与WPF或Silverlight中的对应物几乎没有什么不同。WinRT有一些更有趣的面板，从“VariableSizedWrapGrid”开始。
- en: As its name suggests, it's essentially a grid, where items are arranged in rows
    or columns (depending on the `Orientation` property). When space runs out, or
    if the number of items in a row/column reaches the limit set by the `MaximumRowsOrColumns`
    property, the layout continues on the next row/column.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 顾名思义，它本质上是一个网格，其中的项目按行或列排列（取决于“Orientation”属性）。当空间不足时，或者如果一行/列中的项目数量达到了“MaximumRowsOrColumns”属性设置的限制，布局将继续到下一行/列。
- en: 'A final twist with `VariableSizedWrapGrid` is that it is available with two
    attached properties, `RowSpan` and `ColumnSpan`, that can change the size of an
    item to take up more than one cell. Here''s an example `VariableSizedWrapGrid`
    with a bunch of `Rectangle` elements:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个关于“VariableSizedWrapGrid”的技巧是，它有两个附加属性，“RowSpan”和“ColumnSpan”，可以改变一个项目的大小，使其占据多个单元格。以下是一个带有一堆“Rectangle”元素的“VariableSizedWrapGrid”示例：
- en: '[PRE9]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This is the result:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这是结果：
- en: '![VariableSizedWrapGrid](img/5022_04_06.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![VariableSizedWrapGrid](img/5022_04_06.jpg)'
- en: Panel virtualization
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 面板虚拟化
- en: All the previously discussed panels create their child elements as soon as they
    are added. For most scenarios, this is acceptable. However, if the item count
    is very high (hundreds or more), the panel's performance may degrade, as many
    elements need to be created and managed, taking up memory and wasting CPU cycles
    upon creation, or when layout changes occur. A virtualizing panel does not create
    all the elements up front for items it holds; instead, it only creates actual
    elements that are currently visible. If the user scrolls to see more data, elements
    are created as needed. Elements that scroll out of view may be destroyed. This
    scheme conserves memory and CPU time (at creation time).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 所有先前讨论的面板在添加时都会创建它们的子元素。对于大多数情况，这是可以接受的。但是，如果项目数量非常多（数百个或更多），面板的性能可能会下降，因为需要创建和管理许多元素，占用内存并在创建时浪费CPU周期，或在布局更改时发生。虚拟化面板不会一次性创建它所持有的项目的所有元素；相反，它只会创建当前可见的实际元素。如果用户滚动以查看更多数据，则会根据需要创建元素。滚出视图的元素可能会被销毁。这种方案节省了内存和CPU时间（在创建时）。
- en: The `VirtualizingPanel` class is an abstract base class for all virtualization
    panel implementations in WinRT. A further refinement of `VirtualizingPanel` is
    `OrientedVirtualizingPanel`, indicating a panel with an inherent orientation.
    WinRT provides the three virtualizing panels, as we'll see in a moment.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`VirtualizingPanel`类是WinRT中所有虚拟化面板实现的抽象基类。`VirtualizingPanel`的进一步细化是`OrientedVirtualizingPanel`，表示具有固有方向的面板。WinRT提供了三种虚拟化面板，我们将在稍后看到。'
- en: All virtualizing panels have one more interesting trait, they can only be used
    to customize the panel used for controls based on `ItemsControl` (typically with
    data binding); they cannot be used as normal panels are used—by placing items
    inside them (in XAML or programmatically). Full discussion of `ItemsControl` and
    its derivatives is reserved for a later part of this chapter; for now we'll take
    a quick look at the way the existing virtualizing panels work; we'll see examples
    of usage later, when `ItemsControl` is discussed.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 所有虚拟化面板都有一个更有趣的特点，它们只能用于自定义基于`ItemsControl`（通常使用数据绑定）的控件面板；它们不能像正常面板一样使用——在其中放置项目（在XAML或以编程方式）。`ItemsControl`及其派生类的完整讨论将在本章的后面部分进行；现在我们将快速查看现有虚拟化面板的工作方式；当讨论`ItemsControl`时，我们将在稍后看到使用示例。
- en: Virtualizing panels
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 虚拟化面板
- en: The easiest virtualizing panel to understand is `VirtualizingStackPanel` . It
    acts just like a regular `StackPanel`, but it virtualizes elements that are currently
    not visible.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 最容易理解的虚拟化面板是`VirtualizingStackPanel`。它的行为就像常规的`StackPanel`，但它会虚拟化当前不可见的元素。
- en: '`WrapGrid` is similar to `VariableSizedWrapGrid` , but without the "variable"
    part (it has no attached properties that can change an individual element''s size).
    It''s used in a `GridView` as the default panel (`GridView` is one of the many
    types derived from `ItemsControl`). It can be customized with properties such
    as `Orientation`, `ItemHeight`, `ItemWidth`, and `MaximumRowsOrColumns`, which
    are mostly self-explanatory.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`WrapGrid`类似于`VariableSizedWrapGrid`，但没有“可变”部分（它没有可以更改单个元素大小的附加属性）。它在`GridView`中用作默认面板（`GridView`是从`ItemsControl`派生的许多类型之一）。它可以通过属性进行自定义，例如`Orientation`，`ItemHeight`，`ItemWidth`和`MaximumRowsOrColumns`，这些属性大多是不言自明的。'
- en: '`CarouselControl` is similar to `VirtualizingStackPanel`, with the added capability
    to roll over to the first item when the last one is reached. It''s used as the
    default panel for a `ComboBox` and, in fact, cannot be used by other control,
    making it pretty useless generally.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`CarouselControl`类似于`VirtualizingStackPanel`，还具有在达到最后一个项目时滚动到第一个项目的功能。它被用作`ComboBox`的默认面板，并且实际上不能被其他控件使用，因此通常没有什么用处。'
- en: Working with elements and controls
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与元素和控件一起工作
- en: The difference between "elements" and "controls" is not that important in practice,
    but it is useful to understand the distinction.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: “元素”和“控件”之间的区别在实践中并不那么重要，但了解这种区别是有用的。
- en: '**Elements** derive from `FrameworkElement` (directly or indirectly), but not
    from `Control`. They have some look and provide some functionality that is customizable
    mostly by changing properties. For example, `Ellipse` is an element. There''s
    no way to change the fundamental appearance of an `Ellipse` (and it would be illogical
    to be able to turn an `Ellipse` into, for example, a rectangle). It can still
    be customized in some ways using properties such as `Stroke`, `StrokeThickness`,
    `Fill`, and `Stretch`.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**元素**从`FrameworkElement`（直接或间接）派生，但不是从`Control`派生。它们具有一些外观并提供一些可通过更改属性进行自定义的功能。例如，`Ellipse`是一个元素。没有办法改变`Ellipse`的基本外观（并且能够将`Ellipse`变成矩形是不合逻辑的）。但是可以使用诸如`Stroke`，`StrokeThickness`，`Fill`和`Stretch`等属性以某种方式进行自定义。'
- en: '**Controls**, on the other hand, derive (directly or indirectly) from the `Control`
    class. `Control` adds a bunch of properties, of which the most significant is
    the `Template` property. This allows for completely changing the control''s appearance
    without affecting its behavior. Furthermore, all that can be achieved with XAML
    alone, without code or any class derivation. We''ll discuss control templates
    in [Chapter 6](ch06.html "Chapter 6. Components, Templates, and Custom Elements"),
    *Components, Templates, and Custom Elements*.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，**控件**从`Control`类（直接或间接）派生。`Control`添加了一堆属性，其中最重要的是`Template`属性。这允许完全更改控件的外观而不影响其行为。此外，所有这些都可以仅使用XAML实现，无需代码或任何类派生。我们将在[第6章](ch06.html
    "第6章。组件，模板和自定义元素")中讨论控件模板，*组件，模板和自定义元素*。
- en: 'The following class diagram shows some of the fundamental element-related classes
    in WinRT:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 以下类图显示了WinRT中一些基本的与元素相关的类：
- en: '![Working with elements and controls](img/5022_04_07.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![与元素和控件一起工作](img/5022_04_07.jpg)'
- en: In the following sections, we'll go over the various groups of elements and
    controls (based on derivation and usage categories), studying their main features
    and usage. In each group, we'll look at some of the more useful or unique controls.
    These sections are by no means complete (and are not intended as such); further
    information can be found in the official MSDN documentation and samples.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将讨论各种元素和控件的组（基于派生和使用类别），研究它们的主要特点和用法。在每个组中，我们将查看一些更有用或独特的控件。这些部分并不完整（也不打算如此）；更多信息可以在官方MSDN文档和示例中找到。
- en: Content controls
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内容控件
- en: 'Content controls derive from the `ContentControl` class (itself deriving from
    `Control`). `ContentControl` adds two important properties: `Content` (also its
    `ContentProperty` attribute, making it easy to set in XAML) and `ContentTemplate`.
    A simple example of a `ContentControl` is `Button`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 内容控件派生自`ContentControl`类（它本身派生自`Control`）。`ContentControl`添加了两个重要属性：`Content`（也是其`ContentProperty`属性，使其在XAML中易于设置）和`ContentTemplate`。`ContentControl`的一个简单示例是`Button`：
- en: '[PRE10]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This `Content` property may seem like a string, but in fact it's typed as `Platform::Object^`,
    meaning it can be anything at all.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这个“Content”属性可能看起来像一个字符串，但实际上它的类型是`Platform::Object^`，意味着它可以是任何东西。
- en: Note
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It may seem odd that "anything" is specified using `Platform::Object`; after
    all, WinRT is based on COM, so there must be an interface behind this. And there
    is, `Platform::Object` is, in fact, a projected replacement for the `IInspectable`
    interface pointer.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: “Platform::Object”指定“任何内容”似乎有些奇怪；毕竟，WinRT是基于COM的，所以肯定有一个接口在后面。实际上，`Platform::Object`就是`IInspectable`接口指针的投影替代品。
- en: 'A type derived from `ContentControl` renders its `Content` using the following
    rules:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 从`ContentControl`派生的类型使用以下规则呈现其“Content”：
- en: If it's a string, `TextBlock` is rendered with its `Text` set to the string
    value.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果它是一个字符串，将呈现`TextBlock`，其“Text”设置为字符串值。
- en: If it derives from `UIElement`, it's rendered as is.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果它是从`UIElement`派生的，它将按原样呈现。
- en: Otherwise (`Content` does not derive from `UIElement` and is not a string),
    if `ContentTemplate` is `nullptr`, then the content is rendered as a `TextBlock`
    with its `Text` set to a string representation of the `Content`. Otherwise, the
    supplied `DataTemplate` is used for rendering.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则（“Content”不是从“UIElement”派生的，也不是字符串），如果“ContentTemplate”是“nullptr”，那么内容将呈现为一个`TextBlock`，其“Text”设置为“Content”的字符串表示。否则，提供的`DataTemplate`用于呈现。
- en: 'The preceding rules are used for any type derived from `ContentControl`. In
    the case of the previous button, the first rule is used, as the `Content` of the
    `Button` is the string **Login**. Here''s an example that uses the second rule:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 前述规则适用于任何从`ContentControl`派生的类型。在前面的按钮的情况下，使用第一条规则，因为`Button`的“Content”是字符串**Login**。以下是使用第二条规则的示例：
- en: '[PRE11]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The resulting button is shown as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的按钮如下所示：
- en: '![Content controls](img/5022_04_08.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![内容控件](img/5022_04_08.jpg)'
- en: The resulting control is still a button, but its `Content` is set to a type
    derived from `UIElement` (in this case a `StackPanel`).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的控件仍然是一个按钮，但其“Content”设置为从`UIElement`派生的类型（在本例中是`StackPanel`）。
- en: 'The third rule is the most interesting. Suppose we have a simple data object
    implemented like so:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 第三条规则是最有趣的。假设我们有一个简单的数据对象实现如下：
- en: '[PRE12]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Given this implementation, let''s create a `Book` instance in XAML as a resource:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个实现，让我们在XAML中创建一个“Book”实例作为资源：
- en: '[PRE13]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To make this compile without errors, `#include "book.h"` must be added to `MainPage.xaml.h`.
    The reason for that will become clear in the next chapter.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使其编译不出错，必须在`MainPage.xaml.h`中添加`#include "book.h"`。这样做的原因将在下一章中变得清晰。
- en: 'Now, we can set the `Content` of a type derived from the `ContentControl` (such
    as `Button`) to that `Book` object:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将从`ContentControl`（如`Button`）派生的类型的“Content”设置为该“Book”对象：
- en: '[PRE14]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Running the application shows the following result:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序显示以下结果：
- en: '![Content controls](img/5022_04_09.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![内容控件](img/5022_04_09.jpg)'
- en: The result is simply the fully qualified type name of the class (including namespace);
    this is not always the case, it depends on the default control template of the
    control in question. In any case, it's obvious it's not usually what we want.
    To get custom rendering for the object, a `DataTemplate` is needed, plugged into
    the `ContentTemplate` property.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 结果只是类的完全限定类型名称（包括命名空间）；这并不总是这样，这取决于所讨论的控件的默认控件模板。无论如何，显然这通常不是我们想要的。要为对象获取自定义呈现，需要一个`DataTemplate`，并将其插入到`ContentTemplate`属性中。
- en: 'Here''s an example that creates a `DataTemplate` for use within the `Button`
    in question:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个为在问题中的`Button`中使用的`DataTemplate`的示例：
- en: '[PRE15]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'There are a few things to note here:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有几点需要注意：
- en: A `DataTemplate` can contain a single element (typically a `Panel`—`Grid` in
    this example), and can build any required UI.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DataTemplate`可以包含一个单一元素（通常是一个`Panel`—在本例中是`Grid`），并且可以构建任何所需的UI。'
- en: Using the properties of the actual content is done via data binding expressions,
    expressed with the `{Binding}` markup extension, with the property name. A complete
    treatment of data binding is found in the next chapter.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用实际内容的属性是通过数据绑定表达式完成的，使用`{Binding}`标记扩展和属性名称。有关数据绑定的完整处理在下一章中找到。
- en: 'To make the properties work with a data object (a `Book` in this case), the
    class (`Book`) must be decorated with the `Bindable` attribute like so:'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要使属性与数据对象（在本例中是`Book`）一起工作，必须像这样用`Bindable`属性装饰类（`Book`）：
- en: '[PRE16]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The result looks like the following:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下所示：
- en: '![Content controls](img/5022_04_10.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![内容控件](img/5022_04_10.jpg)'
- en: Data templates are powerful tools for visualizing data objects; we'll encounter
    more of those later. For now, it's important to realize that every type deriving
    from `ContentControl` has that customization ability.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 数据模板是可视化数据对象的强大工具；我们以后会遇到更多。现在，重要的是要意识到每个从`ContentControl`派生的类型都具有这种自定义能力。
- en: In the following sections, we'll discuss some of the common `ContentControl`-derived
    types.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将讨论一些常见的`ContentControl`派生类型。
- en: Buttons
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 按钮
- en: 'As we''ve already seen, the classic `Button` control is a `ContentControl`,
    meaning it can have any content, but still act like a button. Most of the functionality
    of the `Button` is derived from its abstract base class, `ButtonBase`. `ButtonBase`
    declares the ubiquitous `Click` event, along with some other useful properties:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '`ClickMode` – indicates what constitutes a "click": `Release`, `Press`, or
    `Hover`. Naturally, this is mostly applicable to a mouse.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Command` – indicates which command (if any) to invoke when the button is clicked
    (commands will be discussed in the next chapter).'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CommandParameter` – an optional parameter that is sent with the invoked command.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Button derives from `ButtonBase` and adds nothing in terms of members, except
    being concrete, rather than abstract.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Another `ButtonBase` derivative is `HyperlinkButton`. It renders as a web hyperlink
    by default, and adds a `NavigationUri` property that causes automatic navigation
    to the specified URI; the `Click` event is typically not handled.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '`RepeatButton` (in the `Windows::UI::Xaml::Controls::Primitives` namespace)
    is another `ButtonBase` derivative. It raises the `Click` event, as long as the
    button is pressed; the rate of `Click` events can be specified using the `Delay`
    (first `Click` event) and `Interval` (period of `Click` event raises) properties.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`RepeatButton` is less useful by itself; it''s mostly useful as a building
    block of other, more complex, controls. This is hinted by placing the control
    in the `Primitives` subnamespace. As an example, `RepeatButton` composes several
    parts of a `ScrollBar` (in itself in the `Primitives` namespace).'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: Two other useful button controls are `CheckBox` and `RadioButton` . Both derive
    from a common base, `ToggleButton` . `ToggleButton` defines the `IsChecked` property,
    which can have three values (`true`, `false`, or `nullptr`). The later indicates
    an indeterminate state, supported by `CheckBox` (but not by `RadioButton`). `ToggleButton`
    also declares the `IsThreeState` property, to indicate whether the third state
    should be allowed. Finally, it defines three events, `Checked`, `Unchecked`, and
    `Indeterminate`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '`CheckBox` adds nothing to `ToggleButton` except becoming concrete. `RadioButton`
    adds just one property, `GroupName` (a string). This allows grouping of `RadioButton`
    controls, to be used as an exclusion group. By default, all `RadioButton` controls
    under the same immediate parent become a group (only one in that group can have
    the `IsChecked` property set to `true` at a time). If `GroupName` is specified,
    all `RadioButtons` with the same `GroupName` are considered a group.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a simple example that uses `CheckBox` and `RadioButton` controls:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The resulting display, after some selections, is shown as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '![Buttons](img/5022_04_11.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
- en: ScrollViewer
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`ScrollViewer` is a content control that hosts a single child (its `Content`
    property, just like any other `ContentControl`) and uses a pair of `ScrollBar`
    controls to support scrolling. The most important properties are `VerticalScrollBarVisibility`
    and `HorizontalScrollBarVisibility`, which indicate the way scrolling should work
    and the way the scroll bars present themselves. There are four options (`ScrollBarVisibility`
    enumeration):'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '`Visible` – the scroll bar is always visible. If the content does not require
    scrolling, the scroll bar is disabled.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Auto` – the scroll bar appears if needed and disappears if not needed.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Hidden` – the scroll bar is not shown, but scrolling is still possible using
    the keyboard, touch, or programmatically.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Disabled` – the scroll bar is hidden and no scrolling is possible. The `ScrollViewer`
    does not give more space than it has to the content (in that dimension).'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The default values are `Visible` for `VerticalScrollBarVisibility` and `Disabled`
    for `HorizontalScrollBarVisibility`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: Another useful feature of the `ScrollViewer` is its ability to allow zooming
    in or out for the `Content` with a zoom/pinch touch gestures. This is controlled
    through the `ZoomMode` property (`Enabled` or `Disabled`).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`ScrollViewer`的另一个有用功能是它能够通过缩放/捏触手势来允许`Content`进行放大或缩小。这是通过`ZoomMode`属性（`Enabled`或`Disabled`）来控制的。'
- en: 'The `HorizontalScrollBarVisibility`, `VerticalScrollBarVisibility`, and `ZoomMode`
    properties are exposed as attached properties as well, so they are relevant to
    other controls that internally use a `ScrollViewer`, such as `ListBox` or `GridView`.
    Here''s a simple example that changes the way a horizontal scroll bar is presented
    in a `ListBox`:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`HorizontalScrollBarVisibility`、`VerticalScrollBarVisibility`和`ZoomMode`属性也作为附加属性公开，因此它们与内部使用`ScrollViewer`的其他控件相关，例如`ListBox`或`GridView`。以下是一个简单的示例，它改变了`ListBox`中水平滚动条的呈现方式：'
- en: '[PRE18]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Other content controls to note
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他需要注意的内容控件
- en: The following is a brief description of some of the other `ContentControl`-derived
    types in WinRT.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是WinRT中一些其他`ContentControl`派生类型的简要描述。
- en: AppBar
  id: totrans-174
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: AppBar
- en: '`AppBar` is a `ContentControl` that is used for the application bar, typically
    appearing at the bottom (sometimes at the top) if the user swipes from the bottom
    (or top) or right clicks the mouse. It typically hosts a horizontal `StackPanel`
    with buttons for various options. Here''s an example from the Weather app that
    is available with any Windows 8 installation:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`AppBar`是一个用于应用栏的`ContentControl`，通常出现在底部（有时在顶部），如果用户从底部（或顶部）滑动或右键单击鼠标。它通常托管一个水平的`StackPanel`，其中包含各种选项的按钮。以下是一个来自天气应用程序的示例，该应用程序可在任何Windows
    8安装中使用：'
- en: '![AppBar](img/5022_04_12.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![AppBar](img/5022_04_12.jpg)'
- en: Frame
  id: totrans-177
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Frame
- en: '`Frame` is a `ContentControl` that''s used for navigation among controls derived
    from `Page`. Calling the `Navigate` method with a `Page` type "navigates" to that
    page, by creating an instance and calling some virtual methods: `OnNavigatedFrom`
    on the old page (if any) and `OnNavigatedTo` on the new page. By default, the
    application wizard creates a `Frame` object in the `App::OnLaunched` method (event
    handler for the `Lanuched` event), and then quickly navigates to the `MainPage`
    with the following code:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`Frame`是用于在派生自`Page`的控件之间进行导航的`ContentControl`。使用`Navigate`方法与`Page`类型“导航”到该页面，通过创建一个实例并调用一些虚拟方法：在旧页面上调用`OnNavigatedFrom`（如果有的话），在新页面上调用`OnNavigatedTo`。默认情况下，应用程序向导在`App::OnLaunched`方法（`Lanuched`事件的事件处理程序）中创建一个`Frame`对象，然后快速导航到`MainPage`，代码如下：'
- en: '[PRE19]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The second parameter to `Navigate` is an optional context argument available
    in the `OnNavigatedTo` override (in `NavigationEventArgs::Parameter`).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`Navigate`的第二个参数是一个可选的上下文参数，在`OnNavigatedTo`重写中可用（在`NavigationEventArgs::Parameter`中）。'
- en: The `Frame` object maintains a back stack of pages which can be navigated using
    methods such as `GoBack` and `GoForward`. The `CanGoBack` and `CanGoForward` read-only
    properties can help maintain state on buttons that serve navigation purposes.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`Frame`对象维护着一个页面的后退堆栈，可以使用`GoBack`和`GoForward`等方法进行导航。`CanGoBack`和`CanGoForward`只读属性可以帮助维护用于导航目的的按钮的状态。'
- en: Navigating to previously visited pages can create new instances of those pages
    or reuse instances. The `CacheSize` property enables setting a maximum number
    of cached pages that are retained in memory during navigation. To enable any kind
    of caching for a particular `Page` instance, its `Page::NavigationCacheMode` property
    must be set to `Enabled` or `Required` (`Disabled` being the default). `Enabled`
    works with the cache, while `Required` always maintains the page state in memory
    (the `Required` setting does not count against the `Frame::CacheSize` value).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 导航到先前访问的页面可以创建这些页面的新实例或重用实例。`CacheSize`属性可以设置在导航期间在内存中保留的最大缓存页面数。要为特定的`Page`实例启用任何类型的缓存，必须将其`Page::NavigationCacheMode`属性设置为`Enabled`或`Required`（`Disabled`是默认值）。`Enabled`与缓存一起工作，而`Required`始终在内存中保持页面状态（`Required`设置不计入`Frame::CacheSize`值）。
- en: SelectorItem
  id: totrans-183
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: SelectorItem
- en: '`SelectorItem` is an abstract base class for items that may be selectable in
    `ItemsControl` controls (see the next section for a description of `ItemsControl`).
    It adds just one property: `IsSelected`. Derived types are containers for items
    in their respective collection-based control: `ListBoxItem` (in a `ListBox`),
    `GridViewItem` (in a `GridView`), `ListViewItem` (in a `ListView`), and so on.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`SelectorItem`是可在`ItemsControl`控件中选择的项目的抽象基类（有关`ItemsControl`的描述，请参见下一节）。它只添加了一个属性：`IsSelected`。派生类型是其各自基于集合的控件中项目的容器：`ListBoxItem`（在`ListBox`中）、`GridViewItem`（在`GridView`中）、`ListViewItem`（在`ListView`中）等。'
- en: Collection-based controls
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于集合的控件
- en: The following sections discuss controls that hold more than one data item. These
    all derive from the `ItemsControl` class that provides the basic structure of
    all derived types.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 以下各节讨论了持有多个数据项的控件。这些都派生自提供所有派生类型的基本结构的`ItemsControl`类。
- en: The `Items` read-only property is the collection of objects hosted in this `ItemsControl`
    (of type `ItemCollection`, also its `ContentProperty`). Objects can be added with
    the `Append` and `Insert` methods, and removed with the `Remove` and `RemoveAt`
    methods (any kind of object can be part of the `ItemsControl`). Although this
    may sound appealing, this is not the typical way of working with an `ItemsControl`
    or its derived types; usually a collection of objects is set to the `ItemsSource`
    property (typically with a data binding expression) and that automatically uses
    the `Items` property behind the scenes to populate the control. We'll see this
    in action in [Chapter 5](ch05.html "Chapter 5. Data Binding"), *Data Binding*.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`Items`只读属性是托管在此`ItemsControl`中的对象的集合（类型为`ItemCollection`，也是其`ContentProperty`）。对象可以使用`Append`和`Insert`方法添加，使用`Remove`和`RemoveAt`方法移除（任何类型的对象都可以成为`ItemsControl`的一部分）。尽管这听起来很吸引人，但这不是与`ItemsControl`或其派生类型一起工作的典型方式；通常会将对象集合设置为`ItemsSource`属性（通常使用数据绑定表达式），并且自动使用`Items`属性在幕后填充控件。我们将在[第5章](ch05.html
    "第5章。数据绑定")*数据绑定*中看到这一点。'
- en: 'The `ItemsPanel` property allows changing the default `Panel` hosting the items
    in the particular `ItemsControl`. For example, a `ListView` uses a vertical `VirtualizingStackPanel`
    as its default `Panel`. This can be changed to `WrapGrid` with the following XAML
    snippet inside the `ListView` element:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `ItemTemplate` property may be set to a `DataTemplate` , as a way to show
    an object that is part of the collection. `ItemTemplate` has the same purpose
    and rules as `ContentControl::ContentTemplate`, but is applicable to each and
    every object in the `ItemsControl`. We'll see examples of `ItemTemplate` usage
    in the next chapter.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '`DisplayMemberPath` is a `String` property that may be used if `ItemTemplate`
    is `nullptr` to show some property (or subproperty) of objects in this `ItemsControl`.
    As an example, suppose we use the following `Book` class (defined earlier):'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Creating an array of such `Book` objects and placing it in the `ItemsControl::ItemsSource`
    property (or adding them manually through `Items->Append` method calls), would
    show, by default, the `Book` type name (assuming no `ItemTemplate` has been set).
    Setting `DisplayMemberPath` to `"BookName"` would show every object's `BookName`
    within the `ItemsControl`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: The `ItemContainerStyle` property may be used to place a `Style` on the particular
    container item for this `ItemsControl`. For example, a `ListView` setting its
    `ItemContainerStyle` property affects the `ListViewItem` controls, each holding
    the data object in question (based on the usual rules for content).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll see some more properties of `ItemsControl` in the next chapter. The
    following sections discuss briefly some of the common types derived from `ItemsControl`.
    Technically, there''s just one such class: `Selector`, adding the notion of selection
    with the `SelectedItem` (the actual data object) and `SelectedIndex` (an integer
    index) properties. The `SelectedValue` property indicates the "value" of the selected
    item, based on the `SelectedValuePath` property. For example, if the control holds
    `Book` objects, as shown previously, and `SelectedValuePath` is `"BookName"`,
    then `SelectedValue` will hold the actual book name for the `SelectedItem` (which
    holds the entire `Book` object).'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '`Selector` also defines a single event, `SelectionChanged`, fired when the
    selected item changes.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: ListBox and ComboBox
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`ListBox` and `ComboBox` are the WinRT versions of the classic Windows controls.
    `ListBox` shows a collection of objects (vertically, by default), with scroll
    bars if necessary. `ListBox` also adds the notion of multiple selected items with
    the `SelectedItems` property and a `SelectionMode` property (`Single`, `Multiple`—each
    click/touch selects/deselects items, and `Extended`—pressing *Shift* selects multiple
    consecutive objects and *Ctrl* for nonadjacent group selection).'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '`ComboBox` shows just one item, selected from a drop-down list. Usage of both
    these controls is discouraged in Store apps, because their touch behavior is not
    as good as it should be, and they have no interesting visual transitions, making
    them a bit dull; that said, they still may be useful at times, particularly the
    `ComboBox`, which has no similar alternative.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: ListView and GridView
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`ListView` and `GridView` both derive from `ListViewBase` (that derives from
    `Selector`), and they''re the preferred controls for hosting multiple items. `ListView`
    and `GridView` add nothing to `ListViewBase` – they just have different defaults
    for their `ItemsPanel` property and some other tweaks.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: 'Both have been designed with a lot of thought for touch input, transition animations
    and the like; these are the workhorses for showing collections of objects. In
    fact, Visual Studio has some project templates that build sample `ListView` and
    `GridView` controls to help developers get started:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '![ListView and GridView](img/5022_04_13.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
- en: FlipView
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `FlipView` control adds nothing to `Selector`, but has a somewhat unique
    appearance, showing just one (selected) item at a time (similar to a `ComboBox`),
    but allows "flipping" through the items by swiping left or right, or by clicking
    two arrows on its sides. The classic example being flipping through image objects:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '![FlipView](img/5022_04_14.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
- en: Text-based elements
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Text is an all important part of any user interface. Naturally, WinRT provides
    several elements and controls that have text as their main visual appearance.
    With text, font-related properties are typically involved. These include:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '`FontSize` – the size of the text (a `double` value).'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FontFamily` – the font family name (such as "Arial" or "Verdana"). This can
    include fallback font families (separated by commas) in case that particular font
    is unavailable.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FontStretch` – indicates stretch characteristics for the font, such as `Condensed`,
    `Normal` (the default), `ExtraCondensed`, `Expanded`, and so on.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FontWeight` – indicates the font weight, such as `Bold`, `ExtraBold`, `Medium`,
    `Thin`, and so on (all taken from the static properties of the `FontWeights` class).'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FontStyle` – one of `Normal`, `Oblique` or `Italic`.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All font-related properties have one notable attribute, they set a "default"
    font for all elements that exist as children of the element in question (direct
    or indirect). This means that setting a font-related property on the `Page` object
    effectively sets the default font for all elements in the page (barring two exceptions:
    font properties set by a control template explicitly and a local font property
    set by a particular element; both override the default font settings).'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: Another property that is common to most text elements is `Foreground`. This
    sets the `Brush` that draws the actual text. There are several `Brush` types,
    `SolidColorBrush` is the simplest, but there are others, such as `LinearGradientBrush`
    and `TileBrush`.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Other text-related properties common to most text-related elements include `TextAlignment`
    (`Left`, `Right`, `Center`, `Justify`), `TextTrimming` (`None` and `WordEllipsis`),
    and `TextWrapping` (`NoWrap` and `Wrap`), all pretty self-explanatory.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: Using custom fonts
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Custom fonts can be used with WinRT. This involves adding a font file to the
    project (with a `.TTF` extension), and making sure its **Content** property in
    Visual Studio is set to **Yes**:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '![Using custom fonts](img/5022_04_16.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
- en: 'All that''s needed now is to use the `FontFamily` property with a special value,
    consisting of the font URI (filename and any logical folder it''s in), a hash
    (#) and the font name itself, visible when double-clicking the font file in Windows.
    Here''s an example of two lines using a standard font and a custom font:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The result is shown as follows:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '![Using custom fonts](img/5022_04_15.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
- en: The following sections discuss some of the common text-related elements and
    controls.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: TextBlock
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`TextBlock` is probably the most useful text-related element. It displays text
    that cannot be changed by the user interactively (only programmatic changes are
    possible). This is useful for showing static text, which should not be edited
    by the user.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although text cannot be edited in a `TextBlock`, it can still be selected by
    the user (and even copied by pressing *Ctrl* + *C*) if `IsTextSelectionEnabled`
    is `true`. In case it is, other properties can be used, namely `SelectedText`,
    `SelectionStart`, and `SelectionEnd` (the later returns `TextPointer` objects).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: The most straightforward way of working with a `TextBlock` is by setting the
    `Text` property (a `String`) and the font-related properties if needed. As an
    alternative to `Text`, `TextBlock` supports a collection of objects called inlines
    (through the `Inlines` property, which is also its `ContentProperty` for XAML
    purposes), that allow the building a more complex `TextBlock`, but still uses
    just one element (the `TextBlock`).
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: Inlines include (all deriving from `Inline`) `Span`, `Run`, `LineBreak`, and
    `InlineUIContainer` (all in the `Windows::UI::Xaml::Documents` namespace). `Span`
    is a container for more inlines with the same properties set by `Span`. `Run`
    has a `Text` property and adds a `FlowDirection`. `LineBreak` is exactly that.
    `InlineUIContainter` can't be used in a `TextBlock`, but only in a `RichTextBlock`
    (discussed later).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example `TextBlock`:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The result is shown as follows:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '![TextBlock](img/5022_04_17.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
- en: Note
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If the `Text` property is used along with inlines, `Text` wins and the inlines
    are not displayed.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: TextBox
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`TextBox` is the classic text-entering control and provides all the expected
    capabilities of such a control. Common properties include (in addition to the
    font properties and others discussed at the beginning of this section):'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '`Text` – the actual text shown or edited by the user.'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MaxLength` – the maximum character length allowed for user input (this setting
    is not used when programmatically manipulating the `Text` in the `TextBox`).'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SelectedText`, `SelectedLength`, `SelectionStart`, `SelectionEnd` – selection
    related properties (self-explanatory).'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IsReadOnly` – indicates whether text can actually be edited (default is `false`).'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AcceptsReturn` – if `true`, indicates a multiple line `TextBox` (default is
    `false`).'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`InputScope` – indicates what kind of virtual keyboard should pop up on a touch-based
    device that is not using a physical keyboard. This can help with text entering.
    Values (from the `InputScopeNameValue` enumeration) include: `Url`, `Number`,
    `EmailSmtpAddress` (e-mail address), and others. Here is a keyboard screenshot
    for `InputScope` of `Number`:![TextBox](img/5022_04_22.jpg)'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is the keyboard for `InputScope` of `Url`:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '![TextBox](img/5022_04_23.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
- en: 'This one is for `InputScope` of `EmailSmtpAddress`:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '![TextBox](img/5022_04_24.jpg)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
- en: '`TextBox` defines several events, `TextChanged` being the most useful.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: PasswordBox
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`PasswordBox` is used for entering passwords (no surprise here). The text is
    shown with a single repeating character, that can be changed with the `PasswordChar`
    property (default is `''*''` appearing as a circle). The `Password` property is
    the actual password, typically read in code.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: A nice feature of `PasswordBox` is a "reveal" button that can show the actual
    password when the button is pressed, useful to make sure entered password is what
    was intended; this feature can be turned off by setting `IsPasswordRevealButtonEnabled`
    to `false`.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: RichTextBlock and RichEditBox
  id: totrans-253
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The "rich" versions of `TextBlock` and `TextBox` provide richer formatting capabilities
    with respect to their "poor" counterpart. For example, it's possible to set font-related
    properties to any text within the control.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: For `RichTextBlock`, the actual content of the controls is in a collection of
    block objects (`Blocks` property), with just one derived type – `Paragraph`. `Paragraph`
    has its own formatting properties and can host `Inline` objects (similar to a
    `TextBlock`); the `InlineUIContainer` inline is supported by `RichTextBlock`,
    providing the ability to embed elements (such as images, or anything else for
    that matter) as part of the text.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '`RichEditBox` allows for richer editing capabilities that can embed *rich*
    content, such as hyperlinks. The `Document` property (of type `ITextDocument`)
    provides the gateway to the object model behind the `RichEditBox`. This object
    model supports saving and loading the document in text and rich text (RTF) formats,
    multiple undo/redo capability, and other features.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: Images
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Images can be displayed with the `Image` element. The `Source` property indicates
    what should be displayed. The simplest possibility is an image added to the project
    as content:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `Source` property is of type `ImageSource`; this markup works only because
    a type converter exists to turn the relative URI into a type derived from `ImageSource`.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: The simplest derived type is `BitmapImage` (actually derives from `BitmapSource`
    that derives from `ImageSource`). `BitmapImage` can be initialized from a URI
    (with the `UriSource` property), which is exactly what happens with the type converter
    used in the preceding XAML.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: A more interesting type is `WriteableBitmap` (derives from `BitmapSource` as
    well), that exposes the ability to change the bitmap bits dynamically.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a `WriteableBitmap`, we need to specify its dimensions in pixels,
    as the following code demonstrates:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '`_bitmap` is a `WriteableBitmap` reference. Next, we set it as the `Source`
    property of an `Image` element:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'To access the actual bits, we''ll need to use a native interface with WRL.
    First, two `includes` and a using statement:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '`robuffer.h` defines the `IBufferByteAccess` interface, used with the `WriteableBitmap::PixelBuffer`
    property like so:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Finally, the bits can be used. Here''s a simple example that draws the first
    line in the bitmap with a random color:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The call to `WriteableBitmap::Invalidate` is necessary, ensuring the bitmap
    is redrawn, and so connected `Image` elements are updated.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: The Stretch property
  id: totrans-274
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `Image::Stretch` property sets the way the `ImageSource` is stretched given
    the size of the `Image` element. Here''s how the `Stretch` property affects displayed
    images:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '![The Stretch property](img/5022_04_18.jpg)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
- en: With `Stretch=None`, the image is displayed in its original size. In the shown
    image, the penguins are clipped because the image is too big to fit. `Uniform`
    and `UniformToFill` preserve the aspect ratio (the original image width divided
    by the height), while `Fill` simply stretches the image to fill the available
    space for the `Image`. `UniformToFill` may cut out content if the available space
    has a different aspect ratio than the original.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-278
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Do not confuse `Image` with `ImageSource`. `Image` is an element, so can be
    placed somewhere in the visual tree. An `ImageSource` is the actual data, an `Image`
    element simply shows the image data in some way. The original image data (`ImageSource`)
    is unchanged.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: The SemanticZoom control
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `SemanticZoom` control deserves a section for itself, as it''s pretty unique.
    It combines two views in one control, one as a "zoomed out" view and another as
    a "zoomed in" view. The idea behind `SemanticZoom` is two related views – one
    more general (zoomed out) and the other more specific (zoomed in). The classic
    example is the Start screen. Doing the pinch/zoom touch gesture (or holding *Ctrl*
    and scrolling the mouse wheel) changes between the two views. The following is
    the zoomed in view:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '![The SemanticZoom control](img/5022_04_20.jpg)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
- en: 'This is the zoomed out view:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '![The SemanticZoom control](img/5022_04_19.jpg)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
- en: The `ZoomedInView` and `ZoomedOutView` properties hold the views—typically `ListView`
    or `GridView`, but technically anything that implements the `ISemanticZoomInformation`
    interface.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '`SemanticZoom` is an effective way to handle mater/detail scenarios in an easily
    accessible and intuitive way.'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building an effective and addictive user interface is an art in itself, and
    is beyond the scope of this book. The modern design guidelines, as they relate
    to Windows Store apps are relatively new, but a lot of information can be found
    on the web, on Microsoft websites and others.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: This chapter's goal was to introduce the C++ developer to the UI landscape,
    making it a more comfortable zone. Even if eventually the C++ developer will be
    more concerned with the application logic, infrastructure, and other low-level
    activities, it's still useful to understand the landscape of user experience and
    user interface.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll tie user interface and data via data binding to create
    robust and scalable applications, at least where UI and data are concerned.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
