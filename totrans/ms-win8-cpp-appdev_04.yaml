- en: Chapter 4. Layout, Elements, and Controls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last chapter discussed XAML, a neutral language used to create objects and
    set up their properties. But XAML is just a tool—the content is what matters.
    Building an effective user interface involves at least selecting the best elements
    and controls to achieve the usability and required user experience.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we'll take a look at the WinRT layout system and discuss the
    major elements and controls that comprise most user interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Layout is the process of element placement and their size and position changes
    in face of user interactions or content changes. In the Win32/MFC world layout
    is mostly very simple and limited. Controls are placed using distance from the
    top-left point of a window and their size is explicitly specified. This model
    has very limited flexibility; if a control's content changes (for example, becomes
    bigger), the control can't compensate automatically. Other similar changes have
    no effect on the UI layout.
  prefs: []
  type: TYPE_NORMAL
- en: WinRT, on the other hand, provides a much more flexible model based around a
    set of layout panels that provide different ways to lay out elements. By combining
    those panels in various ways, complex and adaptive layouts can be created.
  prefs: []
  type: TYPE_NORMAL
- en: Layout is a two-step process. First, the layout container asks each of its children
    for their desired size. In the second step, it uses whatever logic is applicable
    (for that panel type) to determine at what position and what size each child element
    be, and places each child in that rectangular area.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each element indicates to its parent its size requirements. The following figure
    summarizes the most important properties related to these requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introducing layout](img/5022_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here''s a quick breakdown of these important properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Width`/`Height` – the width and height of the element in question. This is
    not typically set (unset value being the default value—`"Auto"`—in XAML; more
    on that in a moment), meaning the element would like to be as big as it needs
    to be. Nevertheless, these may be set if needed. The actual (rendered) width and
    height of an element is available using the `FrameworkElement::ActualWidth` and
    `ActualHeight` read-only properties.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MinWidth`/`MaxWidth`/`MinHeight`/`MaxHeight` – the minima and maxima for the
    element size (not shown in the figure). Default values are `0` for the minima,
    and infinite for the maxima.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Margin` – a "breathing space" around the element. This is of type `Thickness`
    that has four fields (`Left`, `Top`, `Right`, and `Bottom`) that determine the
    amount of space around the element. It can be specified in XAML using four values
    (left, top, right, bottom), two values (the first is left and right, the second
    top and bottom), or a single number (the same distance in all four directions).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Padding` – same idea as `Margin`, but determines the space between the outer
    edge of the element and its content (if any). This is typed as `Thickness` as
    well, and is defined by the `Control` base class and some other special elements,
    such as `Border` and `TextBlock`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HorizontalAlignment`/`VerticalAlignment` – specifies how to align the element
    against its parent if extra space is available. Possible values are `Left`, `Center`,
    `Right`, and `Stretch` (for `HorizontalAlignment`) and `Top`, `Center`, `Bottom`,
    and `Stretch` for `VerticalAlignment`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HorizontalContentAlignment`/`VerticalContentAlignment` (not shown in the figure)
    – same idea as `Horizontal`/`VerticalAlignment`, but for the `Content` of the
    element (if any).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FlowDirection` – can be used to switch the layout direction from the default
    (`LeftToRight`) to `RightToLeft`, suitable for right to left languages, such as
    Hebrew or Arabic. This effectively turns every "left" to "right" and vice versa.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After the layout panel collects the required size of each child element (by
    calling `UIElement::Measure` on each one), it moves on to the second stage of
    the layout—arranging. In this stage, the panel calculates the final positions
    and sizes of its child elements based on the element's desired size (`UIElement::DesiredSize`
    read-only property) and whatever algorithm is appropriate for that panel and informs
    each element of the resulting rectangle by calling `UIElement::Arrange`. This
    procedure can go on recursively, because an element can be a layout panel in itself,
    and so on. The result is known as a visual tree.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Interested readers may be wondering how to specify the `"Auto"` XAML value for,
    for example, `Width` in code, given that this is a `double` value. This is done
    by including `<limits>` and then using the expression `std::numeric_limits<double>::quiet_NaN()`.
    Similarly, to specify an infinite value, use `std::numeric_limits<double>::infinity()`.
  prefs: []
  type: TYPE_NORMAL
- en: Layout panels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All layout panels must derive from the `Windows::UI::Xaml::Controls::Panel`
    class, itself deriving from `FrameworkElement`. The main addition `Panel` is the
    `Children` property (also its `ContentProperty` for easier XAML authoring), which
    is a collection of elements implementing the `IVector<UIElement>` interface. By
    using the `Children` property, elements can be dynamically added or removed from
    a `Panel`. WinRT provides a bunch of specific panels, each with its own layout
    logic, providing flexibility in creating the layout. In the following sections,
    we'll take a look at some of the built-in layout panels.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All panel classes, as well as elements and controls described later, are assumed
    to exist in the `Windows::UI::Xaml::Controls` namespace, unless noted otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: StackPanel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`StackPanel` is one of the simplest layout panels. It lays out its children
    in a *stack*, one after the other, horizontally or vertically, based on the `Orientation`
    property (`Vertical` being the default).'
  prefs: []
  type: TYPE_NORMAL
- en: 'When used for vertical layout, each element gets the height it wants and all
    the available width, and vice versa. Here''s an example of `StackPanel` with some
    elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how it looks at runtime (after some text is entered):'
  prefs: []
  type: TYPE_NORMAL
- en: '![StackPanel](img/5022_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '`StackPanel` is useful for small layout tasks, as part of other, more complex
    layout panels.'
  prefs: []
  type: TYPE_NORMAL
- en: Grid
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Grid` is probably the most useful layout panel because of its flexibility.
    It creates a table-like layout of cells. Elements can occupy single or multiple
    cells, and cell size is customizable. We''ve used `Grid` to create the calculator
    layout from the previous chapter. Here''s another `Grid` example (wrapped in a
    `Border` element), a piece of markup for a login page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how it looks at runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Grid](img/5022_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The number of rows and columns is not specified by simple properties. Instead,
    it's specified using `RowDefinition` objects (for rows) and `ColumnDefinition`
    objects (for columns). The reason has to do with the size and behavior that can
    be specified on a row and/or column basis.
  prefs: []
  type: TYPE_NORMAL
- en: '`RowDefinition` has a `Height` property, while `ColumnDefintion` has a `Width`
    property. Both are of type `GridLength`. There are three options for setting `GridLength`:'
  prefs: []
  type: TYPE_NORMAL
- en: A specific length
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A star-based (relative) factor (this is the default, and factor equals 1)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automatic length
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting `Height` (of a `RowDefintion`) or `Width` (of a `ColumnDefinition`)
    to a specific number makes that row/column that particular size. In code it's
    equivalent to `ref new GridLength(len)`.
  prefs: []
  type: TYPE_NORMAL
- en: Setting `Height` or `Width` to `"Auto"` (in XAML) makes the row/column as high/wide
    as it needs to be based on the tallest/widest element placed within that row/column.
    In code, it's equivalent to the static property `GridLength::Auto`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last option (which is the default) is setting `Height`/`Width` to `n*`
    in XAML, where *n* is a number (`1` if omitted). This sets up a relationship with
    other rows/columns that have a "star" length. For example, here are three rows
    of a `Grid`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This means that the first row is twice as tall as the second row (`Height="*"`).
    The last row is three times taller than the second row, and is one-and-a-half
    times taller than the first row. These relations are maintained, even if the `Grid`
    is dynamically resized due to layout changes.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The value for the "star" factor need not be a whole number; it can be a floating
    point value as well. The ratio is what matters, not the actual numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Elements are placed in specific grid cells using the attached `Grid.Row` and
    `Grid.Column` properties (both default to zero, meaning the first row and column).
  prefs: []
  type: TYPE_NORMAL
- en: Elements occupy one cell by default. This can be changed by using the `Grid.RowSpan`
    and `Grid.ColumnSpan` properties (this was set for the first `TextBlock` in the
    previous XAML).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It's ok to specify `ColumnSpan` or `RowSpan` with a large number to ensure an
    element will occupy all cells in a given direction. The `Grid` automatically will
    use the actual row/column count.
  prefs: []
  type: TYPE_NORMAL
- en: Canvas
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Canvas` models the classic Win32/MFC layout – exact positioning. This type
    of layout is useful if exact coordinates are required, such as the case with graphs,
    animations, graphic games, and other complex drawings. `Canvas` is the fastest
    layout panel, just because it does very little layout (in fact almost none at
    all).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example of `Canvas` hosting some shapes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Canvas](img/5022_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The placement coordinates are set using the `Canvas.Left` and `Canvas.Top` attached
    properties (both default to zero, meaning the top-left corner of the `Canvas`).
    The only other attached property that `Canvas` defines is `ZIndex`. This specifies
    the relative order of rendering the elements inside the `Canvas`, where a large
    value places the element on top. By default, elements defined later in XAML are
    higher in the Z-order.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a more complex example, suppose we wanted to allow the user to drag the
    shapes around the `Canvas` using the mouse or a finger. First, we''ll add event
    handlers for pointer pressing, releasing, and movement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The concept of "pointer" replaces the "mouse" event names that may be familiar
    from Win32/MFC/WPF/Silverlight; pointer is generic, representing any pointing
    device, be it a mouse, stylus, or a finger.
  prefs: []
  type: TYPE_NORMAL
- en: The pointer-related events use the bubbling strategy, meaning any pressing on
    elements (such as the shapes used) will raise `PointerPressed` on that shape first,
    and if unhandled (as in this case), bubble up to its parent (the `Canvas`) where
    it does get handled.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `PointerPressed` event may be handled like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Since this event fires on the `Canvas`, even though the original elements are
    the children of one of the `Canvas`, how do we get to that child element? The
    sender argument is the actual object that sent the event—the `Canvas` in this
    case. The child element is indicated by the `PointerRoutedEventArgs::OriginalSource`
    property (inherited from `RoutedEventArgs`). First, a check is made to see if
    the pointer pressing is in fact on the `Canvas` itself. If so, the method returns
    immediately.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With the preceding `Canvas`, this will never happen. The reason is that the
    default `Background` of the `Canvas` (or any other `Panel` for that matter) is
    `nullptr`, so that no events can register on it—they propagate to its parent.
    If events on the `Canvas` itself are desirable, `Background` must be some non-`nullptr`
    `Brush`; using `ref new SolidColorBrush(Colors::Transparent)` is good enough if
    the parent's background `Brush` is to show through.
  prefs: []
  type: TYPE_NORMAL
- en: Next, the position of the press is extracted in two steps, first using `PointerRoutedEventArgs::GetCurrentPointer()`
    (this is a `PointerPoint` object) and second, with the `PointerPoint::Position`
    property (of type `Windows::Foundation::Point`). Then the point is adjusted to
    become the offset of the pressing point to the top-left corner position of the
    element, this helps in making the later movement accurate.
  prefs: []
  type: TYPE_NORMAL
- en: Capturing the pointer (`UIElement::CapturePointer`) ensures the `Canvas` continues
    to receive pointer-related events no matter where the pointer is. Setting `PointerRoutedEventArgs::Handled`
    to `true` prevents further bubbling (as there's no need here), and a flag indicating
    movement should occur from now on, until the pointer released is set (another
    private member variable).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Pointer capturing is similar in concept to mouse capturing that exists in other
    UI technologies (Win32/MFC/WPF/Silverlight).
  prefs: []
  type: TYPE_NORMAL
- en: 'When the pointer moves, the element in question needs to move as well, as long
    as the pointer has not yet been released:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The main idea here is moving the element by setting the attached `Canvas` properties
    `Canvas.Left` and `Canvas.Top` (using the static `Canvas::SetLeft` and `Canvas::SetTop`
    methods).
  prefs: []
  type: TYPE_NORMAL
- en: 'When the pointer is finally released, we just need to do some cleaning up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The complete code is in a project called `CanvasDemo` , part of the downloadable
    code for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The pointer-related methods may seem more complex than needed, but they're not.
    Since touch input is (more often than not) multi-touch, what happens if two fingers
    press on two different elements at the same time, trying to move them? Multiple
    `PointerPressed` events may trigger, and there should be a way to distinguish
    one finger from another. The previous code is implemented while assuming only
    one finger is used at a time.
  prefs: []
  type: TYPE_NORMAL
- en: Adding children to a panel dynamically
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `Panel::Children` property can be manipulated programmatically (for any
    `Panel` type). For example, using a `Canvas` as a drawing surface, we can use
    the previous pointer events to add `Line` elements that connect to each other
    to create a drawing. When the pointer is moving (after being pressed), `Line`
    objects may be added with code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: A `Line` object is constructed, its properties set as appropriate, and finally
    it's added to the `Children` collection of the `Canvas`. Without this last step,
    the `Line` object is not attached to anything and simply dies out when its reference
    goes out of scope. `_paintBrush` is a `Brush` field maintained by the hosting
    page (not shown).
  prefs: []
  type: TYPE_NORMAL
- en: 'The complete source is in a project called `SimpleDraw`, part of the downloadable
    code for this chapter. Here''s a sample drawing done with this application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding children to a panel dynamically](img/5022_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: VariableSizedWrapGrid
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`StackPanel`, `Grid`, and `Canvas` are fairly straightforward; they are not
    much different from their counterparts in WPF or Silverlight. WinRT has some more
    interesting panels, starting with `VariableSizedWrapGrid`.'
  prefs: []
  type: TYPE_NORMAL
- en: As its name suggests, it's essentially a grid, where items are arranged in rows
    or columns (depending on the `Orientation` property). When space runs out, or
    if the number of items in a row/column reaches the limit set by the `MaximumRowsOrColumns`
    property, the layout continues on the next row/column.
  prefs: []
  type: TYPE_NORMAL
- en: 'A final twist with `VariableSizedWrapGrid` is that it is available with two
    attached properties, `RowSpan` and `ColumnSpan`, that can change the size of an
    item to take up more than one cell. Here''s an example `VariableSizedWrapGrid`
    with a bunch of `Rectangle` elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![VariableSizedWrapGrid](img/5022_04_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Panel virtualization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All the previously discussed panels create their child elements as soon as they
    are added. For most scenarios, this is acceptable. However, if the item count
    is very high (hundreds or more), the panel's performance may degrade, as many
    elements need to be created and managed, taking up memory and wasting CPU cycles
    upon creation, or when layout changes occur. A virtualizing panel does not create
    all the elements up front for items it holds; instead, it only creates actual
    elements that are currently visible. If the user scrolls to see more data, elements
    are created as needed. Elements that scroll out of view may be destroyed. This
    scheme conserves memory and CPU time (at creation time).
  prefs: []
  type: TYPE_NORMAL
- en: The `VirtualizingPanel` class is an abstract base class for all virtualization
    panel implementations in WinRT. A further refinement of `VirtualizingPanel` is
    `OrientedVirtualizingPanel`, indicating a panel with an inherent orientation.
    WinRT provides the three virtualizing panels, as we'll see in a moment.
  prefs: []
  type: TYPE_NORMAL
- en: All virtualizing panels have one more interesting trait, they can only be used
    to customize the panel used for controls based on `ItemsControl` (typically with
    data binding); they cannot be used as normal panels are used—by placing items
    inside them (in XAML or programmatically). Full discussion of `ItemsControl` and
    its derivatives is reserved for a later part of this chapter; for now we'll take
    a quick look at the way the existing virtualizing panels work; we'll see examples
    of usage later, when `ItemsControl` is discussed.
  prefs: []
  type: TYPE_NORMAL
- en: Virtualizing panels
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The easiest virtualizing panel to understand is `VirtualizingStackPanel` . It
    acts just like a regular `StackPanel`, but it virtualizes elements that are currently
    not visible.
  prefs: []
  type: TYPE_NORMAL
- en: '`WrapGrid` is similar to `VariableSizedWrapGrid` , but without the "variable"
    part (it has no attached properties that can change an individual element''s size).
    It''s used in a `GridView` as the default panel (`GridView` is one of the many
    types derived from `ItemsControl`). It can be customized with properties such
    as `Orientation`, `ItemHeight`, `ItemWidth`, and `MaximumRowsOrColumns`, which
    are mostly self-explanatory.'
  prefs: []
  type: TYPE_NORMAL
- en: '`CarouselControl` is similar to `VirtualizingStackPanel`, with the added capability
    to roll over to the first item when the last one is reached. It''s used as the
    default panel for a `ComboBox` and, in fact, cannot be used by other control,
    making it pretty useless generally.'
  prefs: []
  type: TYPE_NORMAL
- en: Working with elements and controls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The difference between "elements" and "controls" is not that important in practice,
    but it is useful to understand the distinction.
  prefs: []
  type: TYPE_NORMAL
- en: '**Elements** derive from `FrameworkElement` (directly or indirectly), but not
    from `Control`. They have some look and provide some functionality that is customizable
    mostly by changing properties. For example, `Ellipse` is an element. There''s
    no way to change the fundamental appearance of an `Ellipse` (and it would be illogical
    to be able to turn an `Ellipse` into, for example, a rectangle). It can still
    be customized in some ways using properties such as `Stroke`, `StrokeThickness`,
    `Fill`, and `Stretch`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Controls**, on the other hand, derive (directly or indirectly) from the `Control`
    class. `Control` adds a bunch of properties, of which the most significant is
    the `Template` property. This allows for completely changing the control''s appearance
    without affecting its behavior. Furthermore, all that can be achieved with XAML
    alone, without code or any class derivation. We''ll discuss control templates
    in [Chapter 6](ch06.html "Chapter 6. Components, Templates, and Custom Elements"),
    *Components, Templates, and Custom Elements*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following class diagram shows some of the fundamental element-related classes
    in WinRT:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with elements and controls](img/5022_04_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the following sections, we'll go over the various groups of elements and
    controls (based on derivation and usage categories), studying their main features
    and usage. In each group, we'll look at some of the more useful or unique controls.
    These sections are by no means complete (and are not intended as such); further
    information can be found in the official MSDN documentation and samples.
  prefs: []
  type: TYPE_NORMAL
- en: Content controls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Content controls derive from the `ContentControl` class (itself deriving from
    `Control`). `ContentControl` adds two important properties: `Content` (also its
    `ContentProperty` attribute, making it easy to set in XAML) and `ContentTemplate`.
    A simple example of a `ContentControl` is `Button`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This `Content` property may seem like a string, but in fact it's typed as `Platform::Object^`,
    meaning it can be anything at all.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It may seem odd that "anything" is specified using `Platform::Object`; after
    all, WinRT is based on COM, so there must be an interface behind this. And there
    is, `Platform::Object` is, in fact, a projected replacement for the `IInspectable`
    interface pointer.
  prefs: []
  type: TYPE_NORMAL
- en: 'A type derived from `ContentControl` renders its `Content` using the following
    rules:'
  prefs: []
  type: TYPE_NORMAL
- en: If it's a string, `TextBlock` is rendered with its `Text` set to the string
    value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If it derives from `UIElement`, it's rendered as is.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Otherwise (`Content` does not derive from `UIElement` and is not a string),
    if `ContentTemplate` is `nullptr`, then the content is rendered as a `TextBlock`
    with its `Text` set to a string representation of the `Content`. Otherwise, the
    supplied `DataTemplate` is used for rendering.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The preceding rules are used for any type derived from `ContentControl`. In
    the case of the previous button, the first rule is used, as the `Content` of the
    `Button` is the string **Login**. Here''s an example that uses the second rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting button is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Content controls](img/5022_04_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The resulting control is still a button, but its `Content` is set to a type
    derived from `UIElement` (in this case a `StackPanel`).
  prefs: []
  type: TYPE_NORMAL
- en: 'The third rule is the most interesting. Suppose we have a simple data object
    implemented like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Given this implementation, let''s create a `Book` instance in XAML as a resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To make this compile without errors, `#include "book.h"` must be added to `MainPage.xaml.h`.
    The reason for that will become clear in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can set the `Content` of a type derived from the `ContentControl` (such
    as `Button`) to that `Book` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the application shows the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Content controls](img/5022_04_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The result is simply the fully qualified type name of the class (including namespace);
    this is not always the case, it depends on the default control template of the
    control in question. In any case, it's obvious it's not usually what we want.
    To get custom rendering for the object, a `DataTemplate` is needed, plugged into
    the `ContentTemplate` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example that creates a `DataTemplate` for use within the `Button`
    in question:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'There are a few things to note here:'
  prefs: []
  type: TYPE_NORMAL
- en: A `DataTemplate` can contain a single element (typically a `Panel`—`Grid` in
    this example), and can build any required UI.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the properties of the actual content is done via data binding expressions,
    expressed with the `{Binding}` markup extension, with the property name. A complete
    treatment of data binding is found in the next chapter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To make the properties work with a data object (a `Book` in this case), the
    class (`Book`) must be decorated with the `Bindable` attribute like so:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The result looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Content controls](img/5022_04_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Data templates are powerful tools for visualizing data objects; we'll encounter
    more of those later. For now, it's important to realize that every type deriving
    from `ContentControl` has that customization ability.
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, we'll discuss some of the common `ContentControl`-derived
    types.
  prefs: []
  type: TYPE_NORMAL
- en: Buttons
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As we''ve already seen, the classic `Button` control is a `ContentControl`,
    meaning it can have any content, but still act like a button. Most of the functionality
    of the `Button` is derived from its abstract base class, `ButtonBase`. `ButtonBase`
    declares the ubiquitous `Click` event, along with some other useful properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ClickMode` – indicates what constitutes a "click": `Release`, `Press`, or
    `Hover`. Naturally, this is mostly applicable to a mouse.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Command` – indicates which command (if any) to invoke when the button is clicked
    (commands will be discussed in the next chapter).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CommandParameter` – an optional parameter that is sent with the invoked command.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Button derives from `ButtonBase` and adds nothing in terms of members, except
    being concrete, rather than abstract.
  prefs: []
  type: TYPE_NORMAL
- en: Another `ButtonBase` derivative is `HyperlinkButton`. It renders as a web hyperlink
    by default, and adds a `NavigationUri` property that causes automatic navigation
    to the specified URI; the `Click` event is typically not handled.
  prefs: []
  type: TYPE_NORMAL
- en: '`RepeatButton` (in the `Windows::UI::Xaml::Controls::Primitives` namespace)
    is another `ButtonBase` derivative. It raises the `Click` event, as long as the
    button is pressed; the rate of `Click` events can be specified using the `Delay`
    (first `Click` event) and `Interval` (period of `Click` event raises) properties.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`RepeatButton` is less useful by itself; it''s mostly useful as a building
    block of other, more complex, controls. This is hinted by placing the control
    in the `Primitives` subnamespace. As an example, `RepeatButton` composes several
    parts of a `ScrollBar` (in itself in the `Primitives` namespace).'
  prefs: []
  type: TYPE_NORMAL
- en: Two other useful button controls are `CheckBox` and `RadioButton` . Both derive
    from a common base, `ToggleButton` . `ToggleButton` defines the `IsChecked` property,
    which can have three values (`true`, `false`, or `nullptr`). The later indicates
    an indeterminate state, supported by `CheckBox` (but not by `RadioButton`). `ToggleButton`
    also declares the `IsThreeState` property, to indicate whether the third state
    should be allowed. Finally, it defines three events, `Checked`, `Unchecked`, and
    `Indeterminate`.
  prefs: []
  type: TYPE_NORMAL
- en: '`CheckBox` adds nothing to `ToggleButton` except becoming concrete. `RadioButton`
    adds just one property, `GroupName` (a string). This allows grouping of `RadioButton`
    controls, to be used as an exclusion group. By default, all `RadioButton` controls
    under the same immediate parent become a group (only one in that group can have
    the `IsChecked` property set to `true` at a time). If `GroupName` is specified,
    all `RadioButtons` with the same `GroupName` are considered a group.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a simple example that uses `CheckBox` and `RadioButton` controls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting display, after some selections, is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Buttons](img/5022_04_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: ScrollViewer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`ScrollViewer` is a content control that hosts a single child (its `Content`
    property, just like any other `ContentControl`) and uses a pair of `ScrollBar`
    controls to support scrolling. The most important properties are `VerticalScrollBarVisibility`
    and `HorizontalScrollBarVisibility`, which indicate the way scrolling should work
    and the way the scroll bars present themselves. There are four options (`ScrollBarVisibility`
    enumeration):'
  prefs: []
  type: TYPE_NORMAL
- en: '`Visible` – the scroll bar is always visible. If the content does not require
    scrolling, the scroll bar is disabled.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Auto` – the scroll bar appears if needed and disappears if not needed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Hidden` – the scroll bar is not shown, but scrolling is still possible using
    the keyboard, touch, or programmatically.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Disabled` – the scroll bar is hidden and no scrolling is possible. The `ScrollViewer`
    does not give more space than it has to the content (in that dimension).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The default values are `Visible` for `VerticalScrollBarVisibility` and `Disabled`
    for `HorizontalScrollBarVisibility`.
  prefs: []
  type: TYPE_NORMAL
- en: Another useful feature of the `ScrollViewer` is its ability to allow zooming
    in or out for the `Content` with a zoom/pinch touch gestures. This is controlled
    through the `ZoomMode` property (`Enabled` or `Disabled`).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `HorizontalScrollBarVisibility`, `VerticalScrollBarVisibility`, and `ZoomMode`
    properties are exposed as attached properties as well, so they are relevant to
    other controls that internally use a `ScrollViewer`, such as `ListBox` or `GridView`.
    Here''s a simple example that changes the way a horizontal scroll bar is presented
    in a `ListBox`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Other content controls to note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The following is a brief description of some of the other `ContentControl`-derived
    types in WinRT.
  prefs: []
  type: TYPE_NORMAL
- en: AppBar
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`AppBar` is a `ContentControl` that is used for the application bar, typically
    appearing at the bottom (sometimes at the top) if the user swipes from the bottom
    (or top) or right clicks the mouse. It typically hosts a horizontal `StackPanel`
    with buttons for various options. Here''s an example from the Weather app that
    is available with any Windows 8 installation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![AppBar](img/5022_04_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Frame
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`Frame` is a `ContentControl` that''s used for navigation among controls derived
    from `Page`. Calling the `Navigate` method with a `Page` type "navigates" to that
    page, by creating an instance and calling some virtual methods: `OnNavigatedFrom`
    on the old page (if any) and `OnNavigatedTo` on the new page. By default, the
    application wizard creates a `Frame` object in the `App::OnLaunched` method (event
    handler for the `Lanuched` event), and then quickly navigates to the `MainPage`
    with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The second parameter to `Navigate` is an optional context argument available
    in the `OnNavigatedTo` override (in `NavigationEventArgs::Parameter`).
  prefs: []
  type: TYPE_NORMAL
- en: The `Frame` object maintains a back stack of pages which can be navigated using
    methods such as `GoBack` and `GoForward`. The `CanGoBack` and `CanGoForward` read-only
    properties can help maintain state on buttons that serve navigation purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Navigating to previously visited pages can create new instances of those pages
    or reuse instances. The `CacheSize` property enables setting a maximum number
    of cached pages that are retained in memory during navigation. To enable any kind
    of caching for a particular `Page` instance, its `Page::NavigationCacheMode` property
    must be set to `Enabled` or `Required` (`Disabled` being the default). `Enabled`
    works with the cache, while `Required` always maintains the page state in memory
    (the `Required` setting does not count against the `Frame::CacheSize` value).
  prefs: []
  type: TYPE_NORMAL
- en: SelectorItem
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`SelectorItem` is an abstract base class for items that may be selectable in
    `ItemsControl` controls (see the next section for a description of `ItemsControl`).
    It adds just one property: `IsSelected`. Derived types are containers for items
    in their respective collection-based control: `ListBoxItem` (in a `ListBox`),
    `GridViewItem` (in a `GridView`), `ListViewItem` (in a `ListView`), and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: Collection-based controls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following sections discuss controls that hold more than one data item. These
    all derive from the `ItemsControl` class that provides the basic structure of
    all derived types.
  prefs: []
  type: TYPE_NORMAL
- en: The `Items` read-only property is the collection of objects hosted in this `ItemsControl`
    (of type `ItemCollection`, also its `ContentProperty`). Objects can be added with
    the `Append` and `Insert` methods, and removed with the `Remove` and `RemoveAt`
    methods (any kind of object can be part of the `ItemsControl`). Although this
    may sound appealing, this is not the typical way of working with an `ItemsControl`
    or its derived types; usually a collection of objects is set to the `ItemsSource`
    property (typically with a data binding expression) and that automatically uses
    the `Items` property behind the scenes to populate the control. We'll see this
    in action in [Chapter 5](ch05.html "Chapter 5. Data Binding"), *Data Binding*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ItemsPanel` property allows changing the default `Panel` hosting the items
    in the particular `ItemsControl`. For example, a `ListView` uses a vertical `VirtualizingStackPanel`
    as its default `Panel`. This can be changed to `WrapGrid` with the following XAML
    snippet inside the `ListView` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `ItemTemplate` property may be set to a `DataTemplate` , as a way to show
    an object that is part of the collection. `ItemTemplate` has the same purpose
    and rules as `ContentControl::ContentTemplate`, but is applicable to each and
    every object in the `ItemsControl`. We'll see examples of `ItemTemplate` usage
    in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '`DisplayMemberPath` is a `String` property that may be used if `ItemTemplate`
    is `nullptr` to show some property (or subproperty) of objects in this `ItemsControl`.
    As an example, suppose we use the following `Book` class (defined earlier):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Creating an array of such `Book` objects and placing it in the `ItemsControl::ItemsSource`
    property (or adding them manually through `Items->Append` method calls), would
    show, by default, the `Book` type name (assuming no `ItemTemplate` has been set).
    Setting `DisplayMemberPath` to `"BookName"` would show every object's `BookName`
    within the `ItemsControl`.
  prefs: []
  type: TYPE_NORMAL
- en: The `ItemContainerStyle` property may be used to place a `Style` on the particular
    container item for this `ItemsControl`. For example, a `ListView` setting its
    `ItemContainerStyle` property affects the `ListViewItem` controls, each holding
    the data object in question (based on the usual rules for content).
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll see some more properties of `ItemsControl` in the next chapter. The
    following sections discuss briefly some of the common types derived from `ItemsControl`.
    Technically, there''s just one such class: `Selector`, adding the notion of selection
    with the `SelectedItem` (the actual data object) and `SelectedIndex` (an integer
    index) properties. The `SelectedValue` property indicates the "value" of the selected
    item, based on the `SelectedValuePath` property. For example, if the control holds
    `Book` objects, as shown previously, and `SelectedValuePath` is `"BookName"`,
    then `SelectedValue` will hold the actual book name for the `SelectedItem` (which
    holds the entire `Book` object).'
  prefs: []
  type: TYPE_NORMAL
- en: '`Selector` also defines a single event, `SelectionChanged`, fired when the
    selected item changes.'
  prefs: []
  type: TYPE_NORMAL
- en: ListBox and ComboBox
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`ListBox` and `ComboBox` are the WinRT versions of the classic Windows controls.
    `ListBox` shows a collection of objects (vertically, by default), with scroll
    bars if necessary. `ListBox` also adds the notion of multiple selected items with
    the `SelectedItems` property and a `SelectionMode` property (`Single`, `Multiple`—each
    click/touch selects/deselects items, and `Extended`—pressing *Shift* selects multiple
    consecutive objects and *Ctrl* for nonadjacent group selection).'
  prefs: []
  type: TYPE_NORMAL
- en: '`ComboBox` shows just one item, selected from a drop-down list. Usage of both
    these controls is discouraged in Store apps, because their touch behavior is not
    as good as it should be, and they have no interesting visual transitions, making
    them a bit dull; that said, they still may be useful at times, particularly the
    `ComboBox`, which has no similar alternative.'
  prefs: []
  type: TYPE_NORMAL
- en: ListView and GridView
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`ListView` and `GridView` both derive from `ListViewBase` (that derives from
    `Selector`), and they''re the preferred controls for hosting multiple items. `ListView`
    and `GridView` add nothing to `ListViewBase` – they just have different defaults
    for their `ItemsPanel` property and some other tweaks.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Both have been designed with a lot of thought for touch input, transition animations
    and the like; these are the workhorses for showing collections of objects. In
    fact, Visual Studio has some project templates that build sample `ListView` and
    `GridView` controls to help developers get started:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ListView and GridView](img/5022_04_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: FlipView
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `FlipView` control adds nothing to `Selector`, but has a somewhat unique
    appearance, showing just one (selected) item at a time (similar to a `ComboBox`),
    but allows "flipping" through the items by swiping left or right, or by clicking
    two arrows on its sides. The classic example being flipping through image objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '![FlipView](img/5022_04_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Text-based elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Text is an all important part of any user interface. Naturally, WinRT provides
    several elements and controls that have text as their main visual appearance.
    With text, font-related properties are typically involved. These include:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FontSize` – the size of the text (a `double` value).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FontFamily` – the font family name (such as "Arial" or "Verdana"). This can
    include fallback font families (separated by commas) in case that particular font
    is unavailable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FontStretch` – indicates stretch characteristics for the font, such as `Condensed`,
    `Normal` (the default), `ExtraCondensed`, `Expanded`, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FontWeight` – indicates the font weight, such as `Bold`, `ExtraBold`, `Medium`,
    `Thin`, and so on (all taken from the static properties of the `FontWeights` class).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FontStyle` – one of `Normal`, `Oblique` or `Italic`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All font-related properties have one notable attribute, they set a "default"
    font for all elements that exist as children of the element in question (direct
    or indirect). This means that setting a font-related property on the `Page` object
    effectively sets the default font for all elements in the page (barring two exceptions:
    font properties set by a control template explicitly and a local font property
    set by a particular element; both override the default font settings).'
  prefs: []
  type: TYPE_NORMAL
- en: Another property that is common to most text elements is `Foreground`. This
    sets the `Brush` that draws the actual text. There are several `Brush` types,
    `SolidColorBrush` is the simplest, but there are others, such as `LinearGradientBrush`
    and `TileBrush`.
  prefs: []
  type: TYPE_NORMAL
- en: Other text-related properties common to most text-related elements include `TextAlignment`
    (`Left`, `Right`, `Center`, `Justify`), `TextTrimming` (`None` and `WordEllipsis`),
    and `TextWrapping` (`NoWrap` and `Wrap`), all pretty self-explanatory.
  prefs: []
  type: TYPE_NORMAL
- en: Using custom fonts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Custom fonts can be used with WinRT. This involves adding a font file to the
    project (with a `.TTF` extension), and making sure its **Content** property in
    Visual Studio is set to **Yes**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using custom fonts](img/5022_04_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'All that''s needed now is to use the `FontFamily` property with a special value,
    consisting of the font URI (filename and any logical folder it''s in), a hash
    (#) and the font name itself, visible when double-clicking the font file in Windows.
    Here''s an example of two lines using a standard font and a custom font:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using custom fonts](img/5022_04_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The following sections discuss some of the common text-related elements and
    controls.
  prefs: []
  type: TYPE_NORMAL
- en: TextBlock
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`TextBlock` is probably the most useful text-related element. It displays text
    that cannot be changed by the user interactively (only programmatic changes are
    possible). This is useful for showing static text, which should not be edited
    by the user.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although text cannot be edited in a `TextBlock`, it can still be selected by
    the user (and even copied by pressing *Ctrl* + *C*) if `IsTextSelectionEnabled`
    is `true`. In case it is, other properties can be used, namely `SelectedText`,
    `SelectionStart`, and `SelectionEnd` (the later returns `TextPointer` objects).
  prefs: []
  type: TYPE_NORMAL
- en: The most straightforward way of working with a `TextBlock` is by setting the
    `Text` property (a `String`) and the font-related properties if needed. As an
    alternative to `Text`, `TextBlock` supports a collection of objects called inlines
    (through the `Inlines` property, which is also its `ContentProperty` for XAML
    purposes), that allow the building a more complex `TextBlock`, but still uses
    just one element (the `TextBlock`).
  prefs: []
  type: TYPE_NORMAL
- en: Inlines include (all deriving from `Inline`) `Span`, `Run`, `LineBreak`, and
    `InlineUIContainer` (all in the `Windows::UI::Xaml::Documents` namespace). `Span`
    is a container for more inlines with the same properties set by `Span`. `Run`
    has a `Text` property and adds a `FlowDirection`. `LineBreak` is exactly that.
    `InlineUIContainter` can't be used in a `TextBlock`, but only in a `RichTextBlock`
    (discussed later).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example `TextBlock`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![TextBlock](img/5022_04_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If the `Text` property is used along with inlines, `Text` wins and the inlines
    are not displayed.
  prefs: []
  type: TYPE_NORMAL
- en: TextBox
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`TextBox` is the classic text-entering control and provides all the expected
    capabilities of such a control. Common properties include (in addition to the
    font properties and others discussed at the beginning of this section):'
  prefs: []
  type: TYPE_NORMAL
- en: '`Text` – the actual text shown or edited by the user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MaxLength` – the maximum character length allowed for user input (this setting
    is not used when programmatically manipulating the `Text` in the `TextBox`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SelectedText`, `SelectedLength`, `SelectionStart`, `SelectionEnd` – selection
    related properties (self-explanatory).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IsReadOnly` – indicates whether text can actually be edited (default is `false`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AcceptsReturn` – if `true`, indicates a multiple line `TextBox` (default is
    `false`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`InputScope` – indicates what kind of virtual keyboard should pop up on a touch-based
    device that is not using a physical keyboard. This can help with text entering.
    Values (from the `InputScopeNameValue` enumeration) include: `Url`, `Number`,
    `EmailSmtpAddress` (e-mail address), and others. Here is a keyboard screenshot
    for `InputScope` of `Number`:![TextBox](img/5022_04_22.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is the keyboard for `InputScope` of `Url`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![TextBox](img/5022_04_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This one is for `InputScope` of `EmailSmtpAddress`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![TextBox](img/5022_04_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '`TextBox` defines several events, `TextChanged` being the most useful.'
  prefs: []
  type: TYPE_NORMAL
- en: PasswordBox
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`PasswordBox` is used for entering passwords (no surprise here). The text is
    shown with a single repeating character, that can be changed with the `PasswordChar`
    property (default is `''*''` appearing as a circle). The `Password` property is
    the actual password, typically read in code.'
  prefs: []
  type: TYPE_NORMAL
- en: A nice feature of `PasswordBox` is a "reveal" button that can show the actual
    password when the button is pressed, useful to make sure entered password is what
    was intended; this feature can be turned off by setting `IsPasswordRevealButtonEnabled`
    to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: RichTextBlock and RichEditBox
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The "rich" versions of `TextBlock` and `TextBox` provide richer formatting capabilities
    with respect to their "poor" counterpart. For example, it's possible to set font-related
    properties to any text within the control.
  prefs: []
  type: TYPE_NORMAL
- en: For `RichTextBlock`, the actual content of the controls is in a collection of
    block objects (`Blocks` property), with just one derived type – `Paragraph`. `Paragraph`
    has its own formatting properties and can host `Inline` objects (similar to a
    `TextBlock`); the `InlineUIContainer` inline is supported by `RichTextBlock`,
    providing the ability to embed elements (such as images, or anything else for
    that matter) as part of the text.
  prefs: []
  type: TYPE_NORMAL
- en: '`RichEditBox` allows for richer editing capabilities that can embed *rich*
    content, such as hyperlinks. The `Document` property (of type `ITextDocument`)
    provides the gateway to the object model behind the `RichEditBox`. This object
    model supports saving and loading the document in text and rich text (RTF) formats,
    multiple undo/redo capability, and other features.'
  prefs: []
  type: TYPE_NORMAL
- en: Images
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Images can be displayed with the `Image` element. The `Source` property indicates
    what should be displayed. The simplest possibility is an image added to the project
    as content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The `Source` property is of type `ImageSource`; this markup works only because
    a type converter exists to turn the relative URI into a type derived from `ImageSource`.
  prefs: []
  type: TYPE_NORMAL
- en: The simplest derived type is `BitmapImage` (actually derives from `BitmapSource`
    that derives from `ImageSource`). `BitmapImage` can be initialized from a URI
    (with the `UriSource` property), which is exactly what happens with the type converter
    used in the preceding XAML.
  prefs: []
  type: TYPE_NORMAL
- en: A more interesting type is `WriteableBitmap` (derives from `BitmapSource` as
    well), that exposes the ability to change the bitmap bits dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a `WriteableBitmap`, we need to specify its dimensions in pixels,
    as the following code demonstrates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '`_bitmap` is a `WriteableBitmap` reference. Next, we set it as the `Source`
    property of an `Image` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'To access the actual bits, we''ll need to use a native interface with WRL.
    First, two `includes` and a using statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '`robuffer.h` defines the `IBufferByteAccess` interface, used with the `WriteableBitmap::PixelBuffer`
    property like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the bits can be used. Here''s a simple example that draws the first
    line in the bitmap with a random color:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The call to `WriteableBitmap::Invalidate` is necessary, ensuring the bitmap
    is redrawn, and so connected `Image` elements are updated.
  prefs: []
  type: TYPE_NORMAL
- en: The Stretch property
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `Image::Stretch` property sets the way the `ImageSource` is stretched given
    the size of the `Image` element. Here''s how the `Stretch` property affects displayed
    images:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Stretch property](img/5022_04_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: With `Stretch=None`, the image is displayed in its original size. In the shown
    image, the penguins are clipped because the image is too big to fit. `Uniform`
    and `UniformToFill` preserve the aspect ratio (the original image width divided
    by the height), while `Fill` simply stretches the image to fill the available
    space for the `Image`. `UniformToFill` may cut out content if the available space
    has a different aspect ratio than the original.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Do not confuse `Image` with `ImageSource`. `Image` is an element, so can be
    placed somewhere in the visual tree. An `ImageSource` is the actual data, an `Image`
    element simply shows the image data in some way. The original image data (`ImageSource`)
    is unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: The SemanticZoom control
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `SemanticZoom` control deserves a section for itself, as it''s pretty unique.
    It combines two views in one control, one as a "zoomed out" view and another as
    a "zoomed in" view. The idea behind `SemanticZoom` is two related views – one
    more general (zoomed out) and the other more specific (zoomed in). The classic
    example is the Start screen. Doing the pinch/zoom touch gesture (or holding *Ctrl*
    and scrolling the mouse wheel) changes between the two views. The following is
    the zoomed in view:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The SemanticZoom control](img/5022_04_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This is the zoomed out view:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The SemanticZoom control](img/5022_04_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `ZoomedInView` and `ZoomedOutView` properties hold the views—typically `ListView`
    or `GridView`, but technically anything that implements the `ISemanticZoomInformation`
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: '`SemanticZoom` is an effective way to handle mater/detail scenarios in an easily
    accessible and intuitive way.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building an effective and addictive user interface is an art in itself, and
    is beyond the scope of this book. The modern design guidelines, as they relate
    to Windows Store apps are relatively new, but a lot of information can be found
    on the web, on Microsoft websites and others.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter's goal was to introduce the C++ developer to the UI landscape,
    making it a more comfortable zone. Even if eventually the C++ developer will be
    more concerned with the application logic, infrastructure, and other low-level
    activities, it's still useful to understand the landscape of user experience and
    user interface.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll tie user interface and data via data binding to create
    robust and scalable applications, at least where UI and data are concerned.
  prefs: []
  type: TYPE_NORMAL
