- en: Micro-Optimizations and Memory Management
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微优化和内存管理
- en: In this chapter, we will cover some of the basic concepts of HTML, CSS, JavaScript,
    and the browser in which we expect all of these to run in union. We always have,
    and always will, code in a certain style, which is natural. However, how did we
    develop this style? Is it good or can it get better? How do we get to decide what
    we should and should not ask others to follow? These are some of the questions
    that we will try and answer in this chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍HTML、CSS、JavaScript和我们期望所有这些内容在其中运行的浏览器的一些基本概念。我们一直以来都以某种风格编码，这是自然的。然而，我们是如何形成这种风格的？它是好的还是可以变得更好？我们如何决定我们应该和不应该要求其他人遵循什么？这些是我们将在本章中尝试回答的一些问题。
- en: 'In this chapter, we will discuss the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下内容：
- en: Importance of best practices and take a look at some of the examples.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最佳实践的重要性，以及一些示例。
- en: Exploring different kinds of HTML, CSS, and JavaScript optimizations
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索不同类型的HTML、CSS和JavaScript优化
- en: Delve into the internal working of some of the features of Chrome.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深入了解Chrome一些功能的内部工作。
- en: Best practices
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最佳实践
- en: Best practices is a relative term for obvious reasons. What is considered best
    is rather dependent on the team in which you work and what version of JavaScript
    you work with. In this section, we will try to cast a wide net over some of these
    best practices, and get an understanding of what some of the practices look like
    so that we can adapt and use them as well.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 出于明显的原因，最佳实践是一个相对的术语。什么被认为是最佳的，更多取决于你所在的团队以及你使用的JavaScript版本。在本节中，我们将尝试广泛涵盖一些最佳实践，并了解一些实践看起来是什么样子，以便我们也可以适应并使用它们。
- en: Best practices for HTML
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTML的最佳实践
- en: Let's approach this section top-down and address the best practices for each
    of the sections within an HTML file.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从上到下来处理HTML文件中每个部分的最佳实践。
- en: Declaring the correct DOCTYPE
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明正确的DOCTYPE
- en: Have you ever wondered why we have `<!DOCTYPE html>` at the top of our page?
    We can clearly leave it out, and still the page seems to work. Then, why exactly
    do we need this? The answer is **a****voiding backward compatibility**—if we do
    not specify the DOCTYPE, the browser that is interpreting and rendering our HTML
    goes into quirks mode, which is a technique to support really old websites that
    were built with outdated versions and markups of HTML, CSS, and JS. Quirks mode
    emulates a lot of bugs that existed in the older versions of the browsers, and
    we do not want to deal with those.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否曾经想过为什么我们在页面顶部有“<!DOCTYPE html>”？我们显然可以不写它，页面似乎仍然可以工作。那么，我们为什么需要这个？答案是**避免向后兼容性**——如果我们不指定DOCTYPE，解释和呈现我们的HTML的浏览器将进入怪癖模式，这是一种支持使用过时版本和标记的HTML、CSS和JS构建的非常旧的网站的技术。怪癖模式模拟了旧版本浏览器中存在的许多错误，我们不想处理这些错误。
- en: Adding the correct meta-information to the page
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向页面添加正确的元信息
- en: 'Any web page, when rendered, needs some meta-information. Although this information
    does not get rendered on the page, it''s critical to render the page correctly.
    The following are some of the good practices for adding the meta-information:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 任何网页在呈现时都需要一些元信息。虽然这些信息不会在页面上呈现，但对于正确呈现页面至关重要。以下是一些添加元信息的良好实践：
- en: 'Adding the right `lang` attribute to your `html` tag to comply with w3c''s
    internationalization standards:'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在“html”标签中添加正确的“lang”属性，以符合w3c的国际化标准：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Declaring the correct `charset` to support special characters on your web page:'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明正确的“charset”以支持网页上的特殊字符：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Add the correct `title` and `description` tags to support search engine optimization:'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加正确的“title”和“description”标签以支持搜索引擎优化：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Add the appropriate `base` URL to avoid providing absolute URLs everywhere:'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加适当的“base” URL以避免在各处提供绝对URL：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Dropping unnecessary attributes
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除不必要的属性
- en: 'This might seem obvious, but is still largely used. When we add a `link` tag
    to download a `stylesheet`, our browser already knows that it is a `stylesheet`.
    There is no reason to specify the type of that link:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来很明显，但仍然被广泛使用。当我们添加一个“link”标签来下载样式表时，我们的浏览器已经知道它是一个样式表。没有理由指定该链接的类型：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Making your app mobile ready
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使您的应用程序适用于移动设备
- en: 'Have you ever seen one of those websites that look exactly the same on desktop
    and mobile and wonder why they would build it like that? In the new age of web
    development, why would someone not leverage the responsiveness provided by the
    latest HTML and CSS versions? This could happen to anyone; we have all the right
    breakpoints defined and are using media queries as expected, but nothing happens.
    This is usually because we forgot to include the `viewport`, the `meta` tag; including
    the `meta` tag for `viewport` fixes all our problems:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否曾经见过那些在桌面和移动设备上看起来完全相同的网站，并想知道为什么他们要这样构建？在新时代的网页开发中，为什么有人不利用最新的HTML和CSS版本提供的响应性？这可能发生在任何人身上；我们已经定义了所有正确的断点，并且按预期使用媒体查询，但什么都没有发生。这通常是因为我们忘记了包括“viewport”，“meta”标签；包括“viewport”的“meta”标签可以解决我们所有的问题：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `viewport` is basically the total viewable area for a user, which will be
    smaller in a mobile and larger in a desktop; the `meta` tag defines how the browser
    should render the website, based on the size of the `viewport`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: “视口”基本上是用户可见区域的总和，在移动设备上较小，在桌面上较大；“meta”标签定义了浏览器根据“视口”的大小来呈现网站的方式。
- en: Loading style sheets in the <head>
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在<head>中加载样式表
- en: This is a matter of preference and choice. Can we load the style sheets at the
    end of the page load? Sure we can, but we want to avoid it so that our users do
    not see unstyled page flashing before it picks up the correct styles. Our browsers,
    when provided with CSS and HTML, create a **CSS Object Model** (**CSSOM**) and
    **Document Object Model** (**DOM**). When a DOM is being constructed, the browser
    looks up the CSSOM to check whether there are any styles corresponding to that
    node of the DOM. Hence, we want to make sure that the CSSOM is constructed and
    ready for the DOM to render.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个偏好和选择的问题。我们可以在页面加载的末尾加载样式表吗？当然可以，但我们希望避免这样做，以便我们的用户在捕捉到正确的样式之前不会看到未经样式化的页面闪烁。当浏览器提供CSS和HTML时，它们创建一个**CSS对象模型**（**CSSOM**）和**文档对象模型**（**DOM**）。在构建DOM时，浏览器查找CSSOM，以检查是否有任何与DOM节点对应的样式。因此，我们希望确保CSSOM已经构建并准备好供DOM渲染。
- en: An alternative is to load only the basic styles first in the head tag of the
    page, and the rest of the styles can be requested at the end of the body. That
    means our page can be rendered a little faster, but it is worth noting that this
    may not be worth the effort sometimes, depending on your application size and
    use case.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 一个替代方法是首先在页面的头部标签中只加载基本样式，其余的样式可以在body的末尾请求。这意味着我们的页面可以渲染得更快一些，但值得注意的是，这有时可能不值得，这取决于您的应用程序大小和用例。
- en: Avoiding inline styles
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免内联样式
- en: 'Using inline styles by providing them directly on the element in an HTML file
    is bad for multiple reasons:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在HTML文件中直接提供内联样式来使用它们是不好的，原因有很多：
- en: We cannot reuse the styles applied to one element
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们无法重用应用于一个元素的样式
- en: Our HTML is flooded with CSS, making it very noisy
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的HTML充斥着CSS，变得非常嘈杂
- en: We cannot leverage pseudo elements, such as `before` and `after`
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们无法利用伪元素，比如`before`和`after`
- en: Using semantic markup
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用语义标记
- en: 'With HTML5, we no longer have to worry about using a `<div>` tag for everything.
    We have been gifted with a more robust set of semantic tags, which help us construct
    our templates in a more meaningful fashion:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 有了HTML5，我们不再需要担心为所有内容使用`<div>`标签。我们得到了一组更强大的语义标签，这些标签帮助我们以更有意义的方式构建我们的模板：
- en: '![](assets/dd8cb81c-7052-4a20-afb6-c694e977c20d.png)A point worth noting is
    that these new tags only provide meaning to our template but no styling. If we
    want it to look a certain way, we will need to style the elements as we want them
    to look. Also, the new HTML5 tags are not available in browsers older than IE9,
    so we need to prepare for fallbacks such as HTML5shiv.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/dd8cb81c-7052-4a20-afb6-c694e977c20d.png)值得注意的是，这些新标签只为我们的模板提供了含义，而没有样式。如果我们希望它看起来某种方式，我们需要根据我们希望它们看起来的样子来设计元素。此外，新的HTML5标签在IE9之前的浏览器中不可用，因此我们需要准备一些备用方案，如HTML5shiv。'
- en: Using Accessible Rich Internet Applications (ARIA) attributes
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用可访问的丰富互联网应用程序（ARIA）属性
- en: 'Whenever we are developing a web application, we will need to ensure that our
    applications are compatible with screen readers to support users with disabilities:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们开发一个网络应用程序时，我们都需要确保我们的应用程序与屏幕阅读器兼容，以支持残障用户：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This information does not collide with any of the existing information on the
    screen, and it enables the screen readers to pick up and process this information.
    Of course, all of this is possible only if the HTML renderer supports ARIA, which
    is available in all the latest browsers.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这些信息不会与屏幕上的任何现有信息发生冲突，并且使屏幕阅读器能够捕捉和处理这些信息。当然，只有在HTML渲染器支持ARIA时，所有这些才是可能的，这在所有最新的浏览器中都是可用的。
- en: Loading scripts at the end
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在末尾加载脚本
- en: The heart of any application lives in the JavaScript files that are defined
    by the developers. Hence, we will need to pay extra attention while we try to
    load and execute these files, which can be significantly larger than that of their
    counterpart HTML and CSS files. When we try to load external JS files using a
    script tag, the browser first downloads them and then executes them (after parsing
    and compiling). We will need to make sure that our application is loaded and executed
    at the right time. What that means for us is that if our application logic is
    reliant on the DOM, we need to ensure that the DOM is rendered before the script
    is executed. This makes it a pretty good reason for us to load the scripts at
    the end of the body tag within our application.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 任何应用程序的核心都存在于开发人员定义的JavaScript文件中。因此，当我们尝试加载和执行这些文件时，我们需要格外注意，因为它们的大小可能比它们的HTML和CSS文件的大小要大得多。当我们尝试使用脚本标签加载外部JS文件时，浏览器首先下载然后执行它们（在解析和编译之后）。我们需要确保我们的应用程序在正确的时间加载和执行。对我们来说，这意味着如果我们的应用逻辑依赖于DOM，我们需要确保DOM在脚本执行之前被渲染。这就是为什么我们需要在应用程序的body标签末尾加载脚本的一个很好的理由。
- en: Even if we do not rely on the DOM in our JavaScript, we would still want to
    load our scripts at the end because the script tags are render blocking by default,
    that is, if your browser encounters your script tag in the head (for example),
    it begins to download and execute the JS files and does not render the rest of
    the page until the execution is complete. Also, if we have too many JS files,
    then the page appears to have hung and does not render the UI completely to our
    end user until all the JS files have been downloaded and executed successfully.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们的JavaScript不依赖于DOM，我们仍然希望在末尾加载我们的脚本，因为脚本标签默认是渲染阻塞的，也就是说，如果您的浏览器在头部（例如）遇到您的脚本标签，它开始下载和执行JS文件，并且在执行完成之前不渲染页面的其余部分。此外，如果我们有太多的JS文件，那么页面似乎已经挂起，并且在所有JS文件都已成功下载和执行之前，不会完全渲染UI给我们的最终用户。
- en: There is one workaround if you still want to add the script tags along with
    the link tag to download the style sheets. You can add the `defer` or `async`
    attribute to the script tag. `Defer` lets you download the file parallel to the
    DOM rendering and executes the script once the render is complete. The `async`
    downloads the file parallel to the DOM render and pauses rendering for execution
    and then resumes after execution. Use them wisely.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您仍然希望添加脚本标签以及链接标签以下载样式表，则有一个解决方法。您可以向脚本标签添加`defer`或`async`属性。`Defer`允许您在DOM渲染时并行下载文件，并在渲染完成后执行脚本。`async`在DOM渲染时并行下载文件，并在执行时暂停渲染，然后在执行后恢复。明智地使用它们。
- en: CSS best practices
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CSS最佳实践
- en: The list of CSS best practices is not as long as that of HTML. Also, a lot of
    potential issues can be subsided significantly by the use of a preprocessing language,
    such as **Sassy CSS** (**SCSS**). Let's assume that you cannot use SCSS for some
    reason and discuss good and bad of plain old CSS.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: CSS最佳实践的列表不像HTML那么长。此外，通过使用预处理语言，如**Sassy CSS**（**SCSS**），许多潜在问题可以得到显著缓解。假设由于某种原因您不能使用SCSS，并讨论纯粹的CSS的优缺点。
- en: Avoiding inline styles
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免内联样式
- en: This is important enough to be part of both HTML's and CSS's best practices.
    Just do not do apply inline styles.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这足够重要，以至于成为HTML和CSS最佳实践的一部分。不要应用内联样式。
- en: Do not use !important
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不要使用!important
- en: Easy to say, hard to do. Using `!important` is one of the easiest workarounds
    available to make your styles apply to an element. However, this comes at a price
    of its own. CSS or Cascading Style Sheets rely on the fact that the styles will
    be cascaded based on the priority of the application (ID, class, and element tag)
    or the order in which they appear. Using `!important` messes that up, and if you
    have multiple CSS files, then it becomes a big mess to correct. It's better to
    avoid such a practice and do it the right way from the get-go.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 说起来容易，做起来难。使用`!important`是使样式应用于元素的最简单的解决方法之一。然而，这也有其代价。CSS或层叠样式表依赖于样式根据应用程序的优先级（ID、类和元素标签）或它们出现的顺序进行级联。使用`!important`会破坏这一点，如果您有多个CSS文件，那么纠正它将变得非常混乱。最好避免这样的做法，从一开始就用正确的方法做。
- en: Arranging styles within a class alphabetically
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在类中按字母顺序排列样式
- en: 'This does not sound like a big deal, does it? Well, if all you have is one
    CSS file with a couple of classes, then maybe it is okay. However, when you have
    big files with a complex hierarchy, the last thing you want is to commit a small
    mistake which costs you a lot of time. Take a look at the following example:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来不像什么大不了的事，对吧？如果您只有一个带有几个类的CSS文件，那也许还可以。但是，当您有一个包含复杂层次结构的大文件时，您最不希望的是犯一个小错误，这会花费您大量的时间。看看以下示例：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note in the preceding code that we added conflicting styles for the background
    property of the element, and now when rendered, it is all red. This could have
    been easily caught, but because of the ordering of the properties within the class,
    it got lost.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在上述代码中，我们为元素的背景属性添加了冲突的样式，现在在渲染时，它全部是红色的。这本来很容易被发现，但由于类内属性的顺序，它被忽略了。
- en: Defining the media queries in an ascending order
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按升序定义媒体查询
- en: 'Defining media queries is another area which gets confusing as the size of
    the application grows. When defining the media queries, always define them in
    an increasing order so that you can isolate your styles and leave an open upper
    bound, as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 定义媒体查询是另一个随着应用程序规模增长而变得混乱的领域。在定义媒体查询时，始终按递增顺序定义它们，以便您可以隔离您的样式并留下一个开放的上限，如下所示：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note in the preceding code that we have left the last media query to apply for
    all screens that are `1200px` and more in size, which would cover monitors, TVs,
    and so on. This would not have worked well if we were doing it the other way,
    in which we set the styles based on the max-width of the screen size. What would
    happen if we open it on a projector? It will certainly not work like you hoped
    it would.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在上述代码中，我们将最后一个媒体查询留给了适用于所有屏幕尺寸为`1200px`及以上的情况，这将涵盖显示器、电视等。如果我们按照屏幕尺寸的最大宽度设置样式，那么这样做就不会奏效。如果我们在投影仪上打开它会发生什么？它肯定不会像您希望的那样工作。
- en: Best practices for JavaScript
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript最佳实践
- en: There is no start and end to this topic. There are a lot of opinions regarding
    how things should be done in JavaScript, and it turns out that most of them are
    correct (depending on your background, experience, and use case). Let's take a
    look at some of the most commonly discussed best practices for JavaScript (ES5).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这个话题没有开始和结束。关于JavaScript应该如何完成任务，有很多不同的观点，结果是大多数都是正确的（取决于您的背景、经验和用例）。让我们来看看一些关于JavaScript（ES5）最常讨论的最佳实践。
- en: Avoiding polluting the global scope
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免污染全局范围
- en: Do not add properties or methods to the global scope. These will bloat your
    window object and make your page slow and stuttery. Instead, always create a variable
    within a method, which will be taken care of when the method is destroyed.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 不要向全局范围添加属性或方法。这将使您的窗口对象膨胀，并使您的页面变得缓慢和不稳定。相反，总是在方法内创建一个变量，在方法被销毁时会被处理。
- en: Using 'use strict'
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用'use strict'
- en: It's a one-line change, which can go a long way when it comes to catching code
    smells and any code irregularities, such as deleting a variable. The `use strict`
    clause throws an error when an illegal action is performed at the runtime, so
    it doesn't necessarily prevent our app from breaking, but we can catch and fix
    issues before they are deployed.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个一行的改变，当涉及捕捉代码异味和任何代码不规则性时，可以走很长的路，比如删除一个变量。`use strict`子句在运行时执行非法操作时会抛出错误，因此它并不一定防止我们的应用程序崩溃，但我们可以在部署之前捕捉并修复问题。
- en: Strict checking (== vs ===)
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 严格检查（== vs ===）
- en: JavaScript can be a fairly tricky language when coming to typecasting or type
    conversions. The fact that there are no data types does not make this any simpler.
    Using a ==forces an implicit typecasting as compared to ===**. **So, it is advisable
    to always use === unless you want 12== 12 to be true.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到类型转换时，JavaScript可能是一门相当棘手的语言。没有数据类型使得这一过程变得更加复杂。使用==会强制进行隐式类型转换，而===则不会。因此，建议始终使用===，除非你想让12==
    12成立。
- en: For more details on understanding why it works the way it does, refer to the
    Abstract Equality Comparison Algorithm, found at [https://www.ecma-international.org/ecma-262/5.1/#sec-11.9.3](https://www.ecma-international.org/ecma-262/5.1/#sec-11.9.3).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解它为什么会这样工作的更多细节，请参考抽象相等比较算法，网址为[https://www.ecma-international.org/ecma-262/5.1/#sec-11.9.3](https://www.ecma-international.org/ecma-262/5.1/#sec-11.9.3)。
- en: Using ternary operators and Boolean || or &&
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用三元运算符和布尔||或&&
- en: 'It is always suggested to keep your code readable but, when warranted, use
    the ternary operators to make your code concise and readable:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 建议始终保持代码可读，但在必要时，使用三元运算符使代码简洁易读：
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'For example, the preceding code can be condensed as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，上述代码可以简化如下：
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Setting default values can also be achieved easily as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 设置默认值也可以轻松实现如下：
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Modularization of code
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码的模块化
- en: When we create a script, it is obvious that we want it to do multiple things,
    for example, if we have a login page, the script for the login page should handle
    login (obviously), reset a password, and signup. All of these operations would
    require the email validation. Keeping validation part of each of these operations
    in its own method is known as Modularization. It helps us keep our methods small,
    readable, and makes unit testing a lot easier.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建一个脚本时，很明显我们希望它能做多种事情，例如，如果我们有一个登录页面，登录页面的脚本应该处理登录（显然），重置密码和注册。所有这些操作都需要电子邮件验证。将验证作为每个操作的一部分放入自己的方法中被称为模块化。它帮助我们保持方法小，可读，并且使单元测试变得更容易。
- en: Avoiding pyramid of doom
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免金字塔式的厄运
- en: 'Pyramid of doom is a classic scenario where we have tons of nesting or branching.
    This makes the code overly complex and the unit testing a very complex job:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 金字塔式的厄运是一个经典场景，我们有大量的嵌套或分支。这使得代码过于复杂，单元测试变得非常复杂：
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Instead, do the following:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是，做以下事情：
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Keeping DOM access to a minimum
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尽量减少DOM访问
- en: DOM access is an expensive operation, and we need to reduce it as much as we
    can to avoid our page from dying. Try caching the DOM elements once they are accessed
    in some local variables or leverage virtual DOM, which is more efficient, as it
    batches all the DOM changes and dispatches them all together.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: DOM访问是一个昂贵的操作，我们需要尽量减少它，以避免页面崩溃。尝试在访问DOM元素后将它们缓存到一些本地变量中，或者利用虚拟DOM，它更有效，因为它批处理所有DOM更改并一起分派它们。
- en: Validating all data
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证所有数据
- en: Registering a new user? Ensure that all the fields entered are validated on
    both the UI and the backend. Doing it in both the places makes it twice as good,
    and validations on the UI help get the error message to the user a lot quicker
    than that of server-side validation.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 注册新用户？确保所有输入的字段在UI和后端都经过验证。在两个地方都这样做会使它变得两倍好，UI上的验证帮助用户更快地获得错误消息，而不是服务器端验证。
- en: Do not reinvent the wheel
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不要重复造轮子
- en: JavaScript community is very generous when it comes to open source software
    and projects. Leverage them; do not rewrite something that is already available
    someplace else. It is not worth the time and effort to rewrite some of the community-tested
    software that is freely available. If a software does only 90% of what you need,
    consider contributing the remaining 10% of that functionality yourself to the
    open source project.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到开源软件和项目时，JavaScript社区非常慷慨。利用它们；不要重写已经在其他地方可用的东西。重写一些经过社区测试的免费可用软件不值得时间和精力。如果一个软件只满足你需求的90%，考虑为开源项目贡献剩下的10%功能。
- en: HTML optimizations
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTML优化
- en: As web developers, we are well versed in creating templates. In this section,
    we will explore ways in which we can make this process as efficient as possible.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 作为网页开发者，我们对创建模板非常熟悉。在这一部分，我们将探讨如何尽可能地提高这个过程的效率。
- en: DOM structuring
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DOM结构
- en: 'As obvious as this might seem, DOM structuring can make quite a big difference
    when it comes to rendering the UI. For an HTML template to become DOM, it goes
    through a series of steps:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 显而易见的是，DOM结构在渲染UI时会产生很大的差异。要使HTML模板成为DOM，需要经历一系列步骤：
- en: '**Template Parsing** : Parser reads the HTML file'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**模板解析**：解析器读取HTML文件'
- en: '**Tokenization**: Parser identifies the tokens, such as `html` and `body`'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**标记化**：解析器识别标记，比如`html`和`body`'
- en: '**Lexing**: Parser converts the tokens to tags, such as `<html>` and `<body>`'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**词法分析**：解析器将标记转换为标签，比如`<html>`和`<body>`'
- en: '**DOM Construction**: This is the last step where the browser converts the
    tags into a tree while applying the applicable styles and rules for the element'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**DOM构建**：这是最后一步，浏览器将标记转换为树，同时应用适用的样式和规则给元素'
- en: With that in mind, it becomes important that we do not nest our elements unnecessarily.
    Try to apply styles to elements rather than nest them in other elements. With
    that being said, one might wonder, how much does this really matter? The browsers
    are pretty good at doing this, so would it really matter if I have an extra element
    in my DOM? Truthfully, no, it would not matter if you do have an extra element.
    However, think about all the different browsers that are out there. Also, how
    many places you are adding this additional element; consider the precedent that
    such a practice would set. Over time, your overhead is going to start to matter.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Prefetching and preloading resources
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some of the lesser-known properties of the `<link>` tag are the `rel=prefetch`
    and `rel=preload` options. They allow the browser to preload some of the content
    that will be required in the subsequent or, sometimes, even the current page.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: <link rel=prefetch >
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s discuss a rather simple example to understand prefetching: loading images.
    Loading images is one of the most common actions a web page performs. We decide
    which image we want to load using either an `img` tag in the HTML template or
    the `background-image` property in CSS.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Either way, the image does not get loaded until the element is parsed. Also,
    let's say that your image is very large and takes a lot of time to download, then
    you would have to rely on a bunch of fallbacks, such as providing the image dimension
    so that the page does not flicker or using the `alt` attribute in case the download
    fails.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: 'One possible solution is to prefetch your resources that will be needed in
    the near future. That way, you can avoid downloading the resources until the user
    lands on that page. A simple example  would look as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We are intentionally delaying the load of the `img` tag until the prefetch is
    done. Ideally, you would prefetch the resources needed for the next page, but
    this accomplishes the same.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we run this page, we can see the requests for the image as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/321a0a8d-d618-4f88-b00b-2a4180924181.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
- en: This sounds too good to be true, right? Right, as useful as this feature is,
    there are issues that we run into when dealing with prefetch across multiple browsers.
    Firefox only prefetches when it is idle; some browsers are capable of pausing
    the download if the user triggers another action and then redownload the rest
    of the image when the browser is idle again, but again that depends on how the
    server is serving the cacheable content (that is, server needs to support serving
    multipart file). Then, there are browsers which can, and will, abandon the prefetch
    because the network is too slow.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: <link rel=preload >
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Preload is very similar to prefetch, with the difference that the browser does
    not have a choice to abandon the download for any reason at any point once the
    resource download is triggered.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax is also very similar, except that we define the type of the resource
    that we are trying to preload:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Prefetching and preloading are also a very common choice when it comes to downloading
    fonts and font families because the request to load fonts is not triggered until
    both the CSSOM and DOM are ready to go.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Layout and layering of HTML
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Coming up with an HTML template for rendering your elements on the UI is one
    of the simplest tasks of being a web developer. In this section, we will talk
    about how Chrome handles the template and renders it onto the UI. There are two
    crucial parts of the HTML template, layout and layers, and we will take a look
    at examples of each of these and how they affect the page performance.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: The HTML layout
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start with an extremely simple web page and take a look at how chrome
    handles rendering this page:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Once we load the page, we will use Chrome **Developer tools** (**DevTools**)
    to generate the performance snapshot of this templates load. To do so, navigate
    to the CDT on your Chrome browser (Settings -> More tools -> Developer tools).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we are there, let''s record a new snapshot by clicking on the record button
    on the top-left corner of the panel that just opened. Once your page loads, stop
    the recording and let the snapshot load in the panel. The result of that would
    look as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们到达那里，让我们通过点击打开面板左上角的记录按钮来记录一个新的快照。一旦你的页面加载完成，停止录制，让快照在面板中加载。结果如下：
- en: '![](assets/54f8d076-62e1-4693-a568-296d544c0175.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/54f8d076-62e1-4693-a568-296d544c0175.png)'
- en: Incomprehensible, right? Well, let's break this down into small pieces that
    we can understand. Our main focus will be on the `main` section (expanded in the
    screenshot). Let's zoom into that a bit to take a look at what the events are
    from left to right.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 难以理解，对吧？好吧，让我们把它分解成我们可以理解的小块。我们的主要关注点将是`main`部分（在截图中展开）。让我们放大一下，看看从左到右的事件是什么。
- en: 'First, we will see the beforeunload event:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将看到beforeunload事件：
- en: '![](assets/51ace852-0b26-492b-aacc-79bda81c73ee.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/51ace852-0b26-492b-aacc-79bda81c73ee.png)'
- en: 'Next, we will see the update layer tree (which we will discuss later):'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看到更新图层树（我们稍后会讨论）：
- en: '![](assets/266d1ed6-7cc7-4da3-b92c-0deb63079235.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/266d1ed6-7cc7-4da3-b92c-0deb63079235.png)'
- en: 'We now note a Minor GC, which is a browser-specific event (we will discuss
    this in a later section):'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们注意到一个Minor GC，这是一个特定于浏览器的事件（我们将在后面的部分讨论这个）：
- en: '![](assets/581f7229-dd5a-432e-af44-fcffb4d37f11.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/581f7229-dd5a-432e-af44-fcffb4d37f11.png)'
- en: 'Then, we will note the  `DOMContentLoaded` event followed by the `Recalculate
    Style` event, which is when our page is ready to be interacted with:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将注意`DOMContentLoaded`事件，然后是`Recalculate Style`事件，这是当我们的页面准备好进行交互时发生的事件：
- en: '![](assets/a171491a-16f2-49a4-bf80-949a8d0e8009.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/a171491a-16f2-49a4-bf80-949a8d0e8009.png)'
- en: Pretty cool, right? This syncs exactly with what we have heard about browsers
    before. They load the page, then `DOMContentLoaded` gets triggered when everything
    is ready. However, notice that, there is another event called Minor GC which is
    being triggered too. We can ignore this, as it is internally handled by the browser
    and has very little to do with the way our code is structured.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 很酷，对吧？这与我们之前听说的浏览器完全一致。它们加载页面，然后在一切准备就绪时触发`DOMContentLoaded`。然而，请注意，还有另一个被触发的事件叫做Minor
    GC。我们可以忽略这个，因为它是由浏览器内部处理的，与我们的代码结构几乎没有关系。
- en: Once the DOM is loaded, we note that we have another event being triggered called
    `Recalculate Style`, which is exactly what it sounds like. The DOM is ready, and
    the browser checks and applies any and all styles that need to be applied to this
    element. However, you may wonder, we did not add any styles to our template, right?
    Then, what styles are we talking about? By default, all browsers apply styles
    to all the elements they render, and these are known as User Agent Stylesheets.
    The browser still has to add the user agent style sheet styles to the CSSOM.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦DOM加载完成，我们注意到另一个被触发的事件叫做`Recalculate Style`，这正是它听起来的样子。DOM已经准备好了，浏览器会检查并应用需要应用到这个元素的所有样式。然而，你可能会想，我们没有向我们的模板添加任何样式，对吧？那么，我们在谈论什么样式呢？默认情况下，所有浏览器都会向它们渲染的所有元素应用样式，这些被称为用户代理样式表。浏览器仍然需要将用户代理样式表样式添加到CSSOM中。
- en: We still haven't really discussed what `Layout` is, apart from it being the
    geometrical structure in which the browser will arrange the elements including,
    but not limited to, their size, shape, and position on the page. `Layout` is also
    an event, which will be recorded by the CDT, to show you how long the browser
    is spending in trying to rearrange your layout. It is very important that we try
    to keep the layout event to a minimum. Why? Because `Layout` is not an isolated
    event. It is chained by a sequence of other events (such as updating the layer
    tree and painting the UI), which are required to complete the arrangement of the
    elements on the UI.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 除了它是浏览器将安排元素的几何结构之外，我们还没有真正讨论`Layout`是什么，包括但不限于它们在页面上的大小、形状和位置。`Layout`也是一个事件，将被CDT记录下来，以显示浏览器在尝试重新排列布局时花费了多长时间。我们尽量将布局事件保持在最小范围内非常重要。为什么？因为`Layout`不是一个孤立的事件。它是由一系列其他事件（例如更新图层树和绘制UI）链接在一起的，这些事件需要完成UI上元素的排列。
- en: 'Another important thing to consider is that the `Layout` event is triggered
    for all the elements that are effected on the page, that is, even when one deeply
    nested element is changed, your entire element (or event surrounding elements
    based on the change) is re-laid out. Let''s take a look at an example:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的事情要考虑的是，`Layout`事件会为页面上受影响的所有元素触发，也就是说，即使一个深度嵌套的元素被改变，你的整个元素（或者根据改变而改变的周围元素）都会被重新布局。让我们看一个例子：
- en: '[PRE17]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'It is pretty straightforward; we have one page with a very small parent consisting
    of four child elements. We have a button which sets the height of all elements
    to `100px`. Let''s now run this page and track the performance when we click on
    the button `update height` to change the height of the elements we see the following
    on the UI:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单；我们有一个包含四个子元素的非常小的父元素的页面。我们有一个按钮，它将所有元素的高度设置为`100px`。现在让我们运行这个页面，并跟踪当我们点击按钮`update
    height`来改变元素的高度时的性能，我们在UI上看到以下内容：
- en: '![](assets/f79f82f7-c9ed-4cd4-a22f-d6a6312d30a3.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f79f82f7-c9ed-4cd4-a22f-d6a6312d30a3.png)'
- en: We can see from preceding screenshot that once the click event starts, it triggers
    our function, which then sets off a chain of events, including `Layout` that takes
    0.23ms. However, one might wonder, why do we have a `Recalculate Style` event
    in between the `Function` and the `Layout`? Remember our old friend User Agent
    Stylesheet? It sets a few styles on the button when it is active, which triggers
    the `Recalculate Style` event.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从前面的截图中看到，一旦点击事件开始，它触发了我们的函数，然后触发了一系列事件，包括`Layout`，用时0.23毫秒。然而，你可能会想，为什么在`Function`和`Layout`之间有一个`Recalculate
    Style`事件？还记得我们的老朋友用户代理样式表吗？它在按钮激活时设置了一些样式，这触发了`Recalculate Style`事件。
- en: If you want to remove all the styles of an element (such as a button in the
    case described earlier), you can do so by applying the `all:unset`; property to
    the element of your choice. This will completely un-style the element. However,
    it will reduce the `Recalculate Style` event to a fraction of what it is with
    the User Agent Styles applied.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now change the JavaScript function to only change the style of the first
    child element instead of all the elements on the page and take a look at how that
    affects the `Layout` events execution in our case:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, when we run the page and profile the execution of the click method, we
    will see the following in the profiler:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/572fd447-4897-46b1-9042-c17a91bf5378.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
- en: As you can see in the preceding screenshot, it still takes 0.21ms to layout
    the entire page, which is not very different from our previous value. In our preceding
    example, we have five more elements. However, in a production application, this
    can, and will, scale to 1000s of elements, and, for a smooth transition, we want
    to keep our `Layout` event under 16ms (60fps).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: In all probability, you may not ever come across this issue, but if you do,
    the simplest way to handle it would be to first check that you are using the latest
    layout model supported by your browser. In most of the browsers, it would be flexbox
    or grid, so prefer that over floats, percentages, or positioning.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: HTML layers
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have seen in the earlier example, once the element is re-laid out, we
    `Paint` the element, that is, fill the pixels with the color, which is supposed
    to be a part of the element at the given position (determined by `Layout`).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: Once the `Paint` event is complete, the browser then performs `Composition`,
    which is basically our browser putting together all the parts of the page. The
    lesser these parts, the faster the page load will be. Also, if a certain section
    of the `Composition` takes too long, then the entire page load is delayed.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: How do we handle these operations which take too long? We can handle it by promoting
    them to their own layer. There are certain CSS operations that we can perform
    on elements, which will promote them to their own layer. What does that mean for
    us? These promoted elements will be now deferred and executed on the GPU as textures.
    We no longer have to worry about our browser triggering the `Layout` or `Paint`
    event for these promoted elements, and we are only concerned with the `Composition`
    of the element.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: 'From the example earlier, so far we have established the first four steps of
    the flow of any change as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript file gets executed
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Recalculation of styles
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Layout` event
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Paint` event
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, to that list, we can add the following steps to completely render the
    element on the UI:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: 5\. `Composition`
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: 6\. Multithread Rasterization
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '*Step 6* merely renders our pixels onto the UI, which can be batched and run
    on parallel threads. Let''s create a simple HTML and take a look at how it renders
    onto a single layer on the UI:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We can access the Layers from the DevTool by navigating to the Settings option
    and then selecting More tools and Layers. On loading the page shown previously,
    we will see the following in the Layers:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/22386b4f-25e5-4522-b94b-f2382afa915b.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
- en: 'When we profile the preceding page, we can see, as expected, that the page
    loads and renders the UI on the `Main` thread:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/4d72a23b-6be1-4df8-8512-2d1153d50d58.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
- en: 'Let''s now change this example to load onto its own layer so that we can completely
    skip both the `Layout` and the `Paint` sections altogether. To load an element
    onto a layer of its own, all we need to do is either give it a CSS transform or
    set the `will-change` property to transform:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The following is an updated example template, which uses the CSS3 `transform`
    property:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In the preceding code, we added a very small animation, which will infinitely
    rotate the element. When we reload the page, we can see that it has been added
    to its own layer:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c948a949-970a-4661-ba96-c92d1f7e34ca.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
- en: 'Not just that, when we record the performance of our modified template, we
    can see something quite interesting:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/67735520-b4cb-47f3-9140-4f49d5a87138.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
- en: As we can see in the preceding screenshot, the browser completely defers the
    `Layer` onto the GPU as a new texture, and, from then on, the GPU handles the
    rendering/updating of the element and not the browser.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: Okay, so, does that mean we load each element onto its own `Layer` and then
    let the GPU take it from there? No, certainly not, because each `Layer` internally
    requires memory, and loading 1,000s of elements onto each Layer would be counterproductive.
    For example, the only time when we should intentionally promote elements to their
    own `Layer` is when an element is taking too long during `Composition` and is
    choking operations, such as scroll or swipe. Another use case could be when you
    have a single element performing multiple changes, such as animating height, width,
    and background color. This will continuously invoke all the steps of the rendering
    process (from `Layout` to Rasterization), and we do not really need to do all
    of that if we know that it is limited to these few changes. We can simply promote
    this element to its own layer and be done with it.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: CSS optimizations
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'CSS optimizations are extremely easy and kind of obvious if you have experience
    developing with any preprocessor frameworks, such as SCSS/LESS. When we discuss
    CSS optimization, we are really talking about two different yet dependent things:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: Loading the style sheets
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rendering and applying styles
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coding practices
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a number of coding practices that we can adapt and learn to make our
    application perform better. Most of them might seem insignificant, but they do
    matter when scaled to a large application. We will discuss a few of these techniques
    with examples.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Using smaller values for common ENUM
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we are talking about reducing the page load time, one quick way to do so
    is by removing redundancies in the CSS file itself:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Using `#FFFFFF` ? Switch to `#FFF`, which is the same RGB value represented
    in short.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do not add `px` after a properties value if the value is `0`.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use minification if not being used already. This concatenates all the CSS files
    in use and removes all the whitespace and newlines.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use GZip to compress the minified file while transferring it over the network.
    It is very easy, and browsers are very good at unzipping the files efficiently.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Be aware of browser-specific optimizations at hand. For example, in case of
    Chrome, we do not have to apply styles in the `rgba(x,y,z,a)` format. We can apply
    it as `rgba` during dev and extract the corresponding HEX value using the DevTool.
    Simply, inspect the element in question and click on the small rectangle while
    pressing *Shift*:'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](assets/e80a8814-de08-45cf-a14c-b60e7b7ee381.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
- en: Using shorthand properties
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using shorthand properties is one way in which the page load can be sped up.
    As obvious as it may sound, sometimes, we take the browser and network for granted
    when we are working on our cozy laptop, and we forget to take into consideration
    the poor 3G-based devices. So, the next time you want to style the background
    or border of an element, ensure that they are all collapsed and written using
    shorthand.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, you may run into a situation where you want to override only one
    property of a certain element''s style. For example, if you want to apply border
    on three sides of an element, use the following:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Avoiding complex CSS selectors
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whenever you are creating your CSS styles, it is imperative to understand that there
    is a cost associated with the browser to apply these styles to any element. We
    can analyze our CSS selectors the same way we do our JavaScript and come up with
    the best and worst case runtime performance of each of the styles we apply.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, consider that we have a style as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The complexity of this would be much higher than simply creating a class and
    assigning it directly to the element itself:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Our browser no longer has to check whether each and every element falls into
    the hierarchy of the style defined previously. A technique developed out of this
    concept is called  **Block-Element-Modifier** (**BEM**), which is quite easy to
    understand. Give a single class name to your elements, and try not to nest them:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: 'So, consider that your template looks as follows:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'You could apply styles using BEM as follows:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If you ever need to add a custom styling to an element, you can either create
    a new class and apply it directly, or you can combine the nesting with the current
    level:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Understanding the browser
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similar to HTML rendering, CSS parsing and rendering are also complex processes,
    which browsers very effortlessly hide. It is always good to know what we can avoid
    to make things better for us. Let's take the same example as HTML and discuss
    how Chrome handles these.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding repaint and reflow
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s first briefly talk about what a repaint and reflow are:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '**Repaint**: An action performed by the browser when the non-geometric properties
    of an element change, for example, background color, text color, and so on.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '**Reflow**: An action performed by the browser because of the geometric change
    to an element (or its parent) directly or via a computed property. This process
    is same as the `Layout` discussed earlier.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: While we cannot completely prevent Repaint and Reflow events completely, we
    can certainly play our part in minimizing the changes that trigger these operations.
    Almost all DOM `read` operations (such as `offsetWidth` and `getClientRects`) trigger
    a `Layout` event because the values of such read operations are done on demand,
    and the browser does not care about their values until explicitly requested. Also,
    anytime we modify the DOM, the `Layout` is invalidated and it will have to be
    recalculated if we need to read the DOM elements properties the next time.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: Critical rendering path (CRP)
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have seen how to optimize the page load (reducing payload, size,
    and so on), and then we talked about the things which we will need to account
    for to keep the page performant once it is rendered. Critical rendering path is
    the technique of optimizing the initial load of the page above the fold (that
    is, the top part of the page that shows up on the initial load prior to any scroll).
    This is also known as **time to interact** (**TTI**) or **time to first byte**
    (**TTFB**), which we want to reduce to keep the page load fast.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: 'Technically, CRP includes the following steps:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: Receive and start parsing HTML.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Download and construct CSSOM.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Download and execute JS.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finish constructing DOM.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create Render Tree.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'So if we want our TTI to be low, it''s quite obvious that we will need to have
    our DOM and CSSOM constructed as quickly as possible without any render-blocking
    CSS or parser-blocking JS files. One of the indications for our TTI to be low
    is that our `DOMContentLoaded` event fires quickly because DCL is fired only when
    DOM and CSSOM are ready. Let''s take the following example template:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We can see that it is pretty lean and does not even load any external styles
    or scripts. This is pretty unusual for a web page, but it serves as a good example.
    When we run this page and open the Network tab, we can see the following:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/1bb2c85f-d936-4678-b647-c3e2c7ffe398.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
- en: 'However, the HTML we mentioned is pretty unusual. In all possibility, we will
    have more than one external CSS and JS file being loaded into our page. In situations
    like that, our DCL event gets delayed. Let''s add blank CSS and JS files to be
    loaded in our `blank.html` file:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a2b4363a-4909-4a4f-b2fb-b0a217c6fc6a.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
- en: 'Here, we can see that, even though there isn''t much to be loaded, the DCL
    event has been pushed until the browser downloads and runs the JS file because
    the JS files fetching and execution are render blocking operations. Our goal is
    now much clearer: we will need to reduce the DCL to a minimum, and, from what
    we have seen so far, we will need to load the HTML ASAP while everything else
    can be loaded once the initial page is rendered (or at least is being rendered).
    Earlier we have seen that we can use the `async` keywords along with the script
    tags to make the JavaScript load and execute asynchronously. Let''s use the same
    now to make our page load faster:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, when we run this page with the Network tab open, we will see the following:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/45273501-86bf-46b9-9d2e-0fbfbb2431a1.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
- en: We can see that the DCL (represented by the blue vertical line under the *waterfall*
    tab) occurs way before the CSS and JS files are downloaded and executed. Another
    advantage of using the `async` attribute is that the `async` attribute indicates
    that the JavaScript is not dependent on CSSOM, and hence it does not have to be
    blocked by the CSSOM construction.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript optimizations
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are tons of resources available online to discuss the various optimizations
    that can be applied to JavaScript. In this section, we will take a look at some
    of these micro-optimizations and determine how we can take small steps toward
    making our JavaScript more performant.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: Truthy/falsy comparisons
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have all, at some point, written if conditions or assigned default values
    by relying on the truthy or falsy nature of the JavaScript variables. As helpful
    as it is most of the times, we will need to consider the impact that such an operation
    would cause on our application. However, before we jump into the details, let''s
    discuss how any condition is evaluated in JavaScript, specifically an `if` condition
    in this case. As a developer, we tend to do the following:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This works for most of the cases, unless the number is 0, in which case it
    gets evaluated to false. That is a very common edge case, and most of us catch
    it anyway. However, what does the JavaScript engine have to do to evaluate this
    condition? How does it know whether the objOrNumber evaluates to true or false?
    Let''s return to our ECMA262 specs and pull out the IF condition spec ([https://www.ecma-international.org/ecma-262/5.1/#sec-12.5](https://www.ecma-international.org/ecma-262/5.1/#sec-12.5)).
    The following is an excerpt of the same:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: Semantics
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: The production IfStatement : If (Expression) Statement else Statement
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: 'Statement is evaluated as follows:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: Let exprRef be the result of evaluating Expression.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If ToBoolean(GetValue(exprRef)) is true, then
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return the result of evaluating the first Statement.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Else,
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return the result of evaluating the second Statement.
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, we note that whatever expression we pass goes through the following three
    steps:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: Getting the `exprRef` from `Expression`.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`GetValue` is called on `exprRef`.'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`ToBoolean` is called as the result of *step 2*.'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Step 1* does not concern us much at this stage; think of it this way—an expression
    can be something like `a == b` or something like the `shouldIEvaluateTheIFCondition()`
    method call, that is, something that evaluates your condition.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '*Step 2* extracts the value of the `exprRef`, that is, 10, true, undefined.
    In this step, we differentiate how the value is extracted based on the type of
    the `exprRef`. You can refer to the details of `GetValue` at [https://www.ecma-international.org/ecma-262/5.1/#sec-8.7.1](https://www.ecma-international.org/ecma-262/5.1/#sec-8.7.1).'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '*Step 3* then converts the value extracted from *Step 2* into a Boolean value
    based on the following table (taken from [https://www.ecma-international.org/ecma-262/5.1/#sec-9.2](https://www.ecma-international.org/ecma-262/5.1/#sec-9.2)):'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/3c9cc47e-b91e-414d-80ab-ef45d24f106b.png)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
- en: At each step, you can see that it is always beneficial if we are able to provide
    the direct boolean value instead of a truthy or falsy value.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: Looping optimizations
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can do a deep-down dive into the for loop, similar to what we did with the
    if condition earlier ([https://www.ecma-international.org/ecma-262/5.1/#sec-12.6.3](https://www.ecma-international.org/ecma-262/5.1/#sec-12.6.3)),
    but there are easier and more obvious optimizations which can be applied when
    it comes to loops. Simple changes can drastically affect the quality and performance
    of the code; consider this for example:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The preceding code can be changed as follows:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'What is even better is to run the loops in reverse, which is even faster than
    what we have seen previously:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The conditional function call
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Some of the features that we have within our applications are conditional.
    For example, logging or analytics fall into this category. Some of the applications
    may have logging turned off for some time and then turned back on. The most obvious
    way of achieving this is to wrap the method for logging within an if condition.
    However, since the method could be triggered a lot of times, there is another
    way in which we can make the optimization in this case:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Instead of the preceding approach, we can instead try to do something, which
    is only slightly different but allows V8-based engines to optimize the way the
    code is executed:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Now, the preceding implementation is a double-edged sword. The reason for that
    is very simple. JavaScript engines employ a technique called **inline caching**
    (**IC**), which means that any previous lookup for a certain method performed
    by the JS engine will be cached and reused when triggered the next time; for example,
    if we have an object that has a nested method, a.b.c, the method a.b.c will be
    only looked up once and stored on cache (IC); if a.b.c is called the next time,
    it will be picked up from IC, and the JS engine will not parse the whole chain
    again. If there are any changes to the a.b.c chain, then the IC gets invalidated
    and a new dynamic lookup is performed the next time instead of being retrieved
    from the IC.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: So, from our previous example, when we have `noOp` assigned to the `trackUserAnalytics()`
    method, the method path gets tracked and saved within IC, but it internally removes
    this function call as it is a call to an empty method. However, when it is applied
    to an actual function with some logic in it, IC points it directly to this new
    method. So, if we keep calling our `toggleUserAnalytics()` method multiple times,
    it keeps invalidating our IC, and our dynamic method lookup has to happen every
    time until the application state stabilizes (that is, `toggleUserAnalytics()`
    is no longer called).
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: Image and font optimizations
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When it comes to image and font optimizations, there are no limits to the types
    and the scale of optimization that we can perform. However, we need to keep in
    mind our target audience, and we need to tailor our approach based on the problem
    at hand.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: With both images and fonts, the first and foremost important thing is that we
    do not overserve, that is, we request and send only the data that is necessary
    by determining the dimensions of the device that our application is running on.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: The simplest way to do this is by adding a cookie for your device size and sending
    it to the server along with each of the request. Once the server receives the
    request for the image, it can then retrieve the image based on the dimension of
    the image that was sent to the cookie. Most of the time these images are something
    like a user avatar or a list of people who commented on a certain post. We can
    agree that the thumbnail images do not need to be of the same size as that of
    the profile page, and we can save some of the bandwidth while transmitting a smaller
    image based on the image.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: Since screens these days have very high **Dots Per Inch** (**DPI**), the media
    that we serve to screens needs to be worthy of it. Otherwise, the application
    looks bad and the images look all pixelated. This can be avoided using Vector
    images or `SVGs`, which can be GZipped over the wire, thus reducing the payload
    size.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: Another not so obvious optimization is changing the image compression type.
    Have you ever loaded a page in which the image loads from the top to bottom in
    small, incremental rectangles? By default, the images are compressed using a baseline
    technique, which is a default method of compressing the image from top to bottom.
    We can change this to be progressive compression using libraries such as `imagemin`.
    This would load the entire image first as blurred, then semi blurred, and so on
    until the entire image is uncompressed and displayed on the screen. Uncompressing
    a progressive JPEG might take a little longer than that of the baseline, so it
    is important to measure before making such optimizations.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: Another extension based on this concept is a Chrome-only format of an image
    called `WebP`. This is a highly effective way of serving images, which serves
    a lot of companies in production and saved almost 30% on bandwidth. Using `WebP`
    is almost as simple as the progressive compression as discussed previously. We
    can use the `imagemin-webp` node module, which can convert a JPEG image into a
    `webp` image, thus reducing the image size to a great extent.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: Web fonts are a little different than that of images. Images get downloaded
    and rendered onto the UI on demand, that is, when the browser encounters the image
    either from the HTML 0r CSS files. However, the fonts, on the other hand, are
    a little different. The font files are only requested when the Render Tree is
    completely constructed. That means that the CSSOM and DOM have to be ready by
    the time request is dispatched for the fonts. Also, if the fonts files are being
    served from the server and not locally, then there are chances that we may see
    the text without the font applied first (or no text at all) and then we see the
    font applied, which may cause a flashing effect of the text.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: 'There are multiple simple techniques to avoid this problem:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: 'Download, serve, and preload the font files locally:'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Specify the unicode-range in the font-face so that browsers can adapt and improvise
    on the character set and glyphs that are actually expected by the browser:'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'So far, we have seen that we can get the unstyled text to be loaded on to the
    UI and the get styled as we expected it to be; this can be changed using the font
    loading API, which allows us to load and render the font using JavaScript:'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Garbage collection in JavaScript
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's take a quick look at what **garbage collection** (**GC**) is and how we
    can handle it in JavaScript. A lot of low-level languages provide explicit capabilities
    to developers to allocate and free memory in their code. However, unlike those
    languages, JavaScript automatically handles the memory management, which is both
    a good and bad thing. Good because we no longer have to worry about how much memory
    we need to allocate, when we need to do so, and how to free the assigned memory.
    The bad part about the whole process is that, to an uninformed developer, this
    can be a recipe for disaster and they can end up with an application that might
    hang and crash.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: 'Luckily for us, understanding the process of GC is quite easy and can be very
    easily incorporated into our coding style to make sure that we are writing optimal
    code when it comes to memory management. Memory management has three very obvious
    steps:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: 'Assign the memory to variables:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Use the variables to read or write from the memory:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Free the memory when it's no longer needed.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, this is the part that is not explicit. How does the browser know when
    we are done with the variable `a` and it is ready to be garbage collected? Let''s
    wrap this inside a function before we continue this discussion:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We have a very simple function, which just adds to our variable `a` and returns
    the result and finishes the execution. However, there is actually one more step,
    which will happen after the execution of this method called **mark and sweep **(not
    immediately after, sometimes this can also happen after a batch of operations is completed
    on the main thread**)**. When the browser performs mark and sweep, it's dependent
    on the total memory the application consumes and the speed at which the memory
    is being consumed.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: Mark and sweep algorithm
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since there is no accurate way to determine whether the data at a particular
    memory location is going to be used or not in the future, we will need to depend
    on alternatives which can help us make this decision. In JavaScript, we use the
    concept of a **reference** to determine whether a variable is still being used
    or not—if not, it can be garbage collected.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: 'The concept of mark and sweep is very straightforward: what all memory locations
    are reachable from all the known active memory locations? If something is not
    reachable, collect it, that is, free the memory. That''s it, but what are the
    known active memory locations? It still needs a starting point, right? In most
    of the browsers, the GC algorithm keeps a list of the `roots` from which the mark
    and sweep process can be started. All the `roots` and their children are marked
    as active, and any variable that can be reached from these `roots` are also marked
    as active. Anything that cannot be reached can be marked as unreachable and thus
    collected. In most of the cases, the `roots` consist of the window object.'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we will go back to our previous example:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Our variable a is local to the `test()` method. As soon as the method is executed,
    there is no way to access that variable anymore, that is, no one holds any reference
    to that variable, and that is when it can be marked for garbage collection so
    that the next time GC runs, the `var a` will be swept and the memory allocated
    to it can be freed.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: Garbage collection and V8
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When it comes to V8, the process of garbage collection is extremely complex
    (as it should be). So, let's briefly discuss how V8 handles it.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: In V8, the memory (heap) is divided into two main generations, which are the
    **new-space** and **old-space**. Both new-space and old-space are assigned some
    memory (between *1 MB* and *20 MB*). Most of the programs and their variables
    when created are assigned within the new-space. As and when we create a new variable
    or perform an operation, which consumes memory, it is by default assigned from
    the new-space, which is optimized for memory allocation. Once the total memory
    allocated to the new-space is almost completely consumed, the browser triggers
    a **Minor GC**, which basically removes the variables that are no longer being
    referenced and marks the variables that are still being referenced and cannot
    be removed yet. Once a variable survives two or more **Minor GC**s, then it becomes
    a candidate for old-space where the GC cycle is not run as frequently as that
    of the new-space. A Major GC is triggered when the old-space is of a certain size,
    all of this is driven by the heuristics of the application, which is very important
    to the whole process. So, well-written programs move fewer objects into the old-space
    and thus have less Major GC events being triggered.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: Needless to say that this is a very high-level overview of what V8 does for
    garbage collection, and since this process keeps changing over time, we will switch
    gears and move on to the next topic.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding memory leaks
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Well, now that we know on a high level what garbage collection is in JavaScript
    and how it works, let's take a look at some common pitfalls which prevent us from
    getting our variables marked for GC by the browser.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: Assigning variables to global scope
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This should be pretty obvious by now; we discussed how the GC mechanism determines
    a root (which is the window object) and treats everything on the root and its
    children as active and never marks them for garbage collection.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the next time you forget to add a `var` to your variable declarations,
    remember that the global variable that you are creating will live forever and
    never get garbage collected:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Removing DOM elements and references
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s imperative that we keep our DOM references to a minimum, so a well-known
    step that we like to perform is caching the DOM elements in our JavaScript so
    that we do not have to query any of the DOM elements over and over. However, once
    the DOM elements are removed, we will need to make sure that these methods are
    removed from our cache as well, otherwise, they will never get GC''d:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The code shown previously removes the `row` from the DOM but the variable cache
    still refers to the DOM element, hence preventing it from being garbage collected.
    Another interesting thing to note here is that even when we remove the table that
    was containing the `row`, the entire table would remain in the memory and not
    get GC'd because the row, which is in cache internally refers to the table.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: Closures edge case
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Closures are amazing; they help us deal with a lot of problematic scenarios
    and also provide us with ways in which we can simulate the concept of private
    variables. Well, all that is good, but sometimes we tend to overlook the potential
    downsides that are associated with the closures. Here is what we do know and use:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'When we run this script in the browser and then profile it, we see as expected
    that the method consumes a constant amount of memory and then is GC''d and restored
    to the baseline memory consumed by the script:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ff54858d-f532-4323-85de-f1c5c9b62ee8.png)'
  id: totrans-320
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s zoom into one of these spikes and take a look at the call tree
    to determine what all events are bring triggered around the time of the spikes:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/6de48c89-3b37-43ef-834c-80fd809b704c.png)'
  id: totrans-322
  prefs: []
  type: TYPE_IMG
- en: We can see that everything happens as per our expectation here; first, our `setInterval()`
    is triggered, which calls `myGoodFunc()`, and once the execution is done, there
    is a GC, which collects the data and hence the spike, as we can see from the preceding
    screenshots.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, this was the expected flow or the happy path when dealing with closures.
    However, sometimes our code is not as simple and we end up performing multiple
    things within one closure, and sometimes even end up nesting closures:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We can note in the preceding code that we extended our method to contain two
    closures now: `closure1` and `closure2`. Although `closure1` still performs the
    same operation as before, `closure2` will run forever because we have it running
    at 1/10th of the frequency of the parent function. Also, since both the closure
    methods share the parent closure scope, in this case the variable a, it will never
    get GC''d and thus cause a huge memory leak, which can be seen from the profile
    as follows:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/81fb9ed7-2efd-4b8c-ba7e-d6da22d66fc4.png)'
  id: totrans-327
  prefs: []
  type: TYPE_IMG
- en: 'On a closer look, we can see that the GC is being triggered but because of
    the frequency at which the methods are being called, the memory is slowly leaking
    (lesser memory is collected than being created):'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/34a5a920-3ea6-4e32-bab8-ab8fb0c6fc57.png)'
  id: totrans-329
  prefs: []
  type: TYPE_IMG
- en: Well, that was an extreme edge case, right? It's way more theoretical than practical—why
    would anyone have two nested `setInterval()` methods with closures. Let's take
    a look at another example in which we no longer nest multiple `setInterval()`,
    but it is driven by the same logic.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assume that we have a method that creates closures:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'A simple fix to solve this problem is obvious, as we have said ourselves that
    the previous value of the object `something` doesn''t get garbage collected as
    it refers to the `previousValue` from the previous iteration. So, the solution
    to this would be to clear out the value of the `previousValue` at the end of each
    iteration, thus leaving nothing for `something` to refer once it is unloaded,
    hence the memory profiling can be seen to change:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/8c92b433-689b-4d11-b436-c1c08ad66748.png)'
  id: totrans-334
  prefs: []
  type: TYPE_IMG
- en: 'The preceding image changes as follows:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/603b37ed-b4ce-4155-9da2-be22cc8452a9.png)'
  id: totrans-336
  prefs: []
  type: TYPE_IMG
- en: Summary
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored ways in which the code performance can be improved
    by making optimizations to HTML, CSS, and JavaScript that we write for our applications.
    It is very important to understand that these are something that may, or may not,
    benefit you, based on the application that you are trying to build. The main takeaway
    from this chapter should be the ability to open up the browser's insides and not
    be scared to dissect and take a look at how the browsers handle our code. Also,
    be wary that the ECMA specification guide keeps changing, but it takes time for
    the browsers to catch up with the changes. Also, last but not the least, never
    over-optimize or optimize too early. If you run into issues, then measure first
    and then decide what the bottlenecks are before coming up with a plan for optimization.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: What's next?
  id: totrans-339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With this, we conclude the book. We hope that you had a great learning experience
    and that you benefit from these techniques on a day-to-day basis. JavaScript,
    being the way it is, is ever growing. Things are changing at a rapid pace, and
    it gets tough to keep track of things. Here are some suggestions, which you can
    explore and modify as you try them out:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: Identify your area of interests. By now, you know that JavaScript exists (and
    rocks) in a lot of things beyond the browser. Are you more of a UI person? Do
    you love APIs and scalable microservice? Do you dig building sensors which count
    how many coffees you consume every day? Find your passion and apply your newly
    learned JavaScript concepts there. The concepts are same, the applications are
    different.
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Subscribe to newsletters and mailing lists from areas of interests. You will
    be amazed by the amount of information you get from each of these emails on a
    daily or weekly basis. It helps you to keep on your toes, and you can stay up
    to date on the latest technologies.
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a blog (or even a StackOverflow answer) for what you know and learn. It
    always helps when you write down what you learn. Someday, you can even use that
    for your own reference.
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
