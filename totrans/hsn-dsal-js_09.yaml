- en: Micro-Optimizations and Memory Management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will cover some of the basic concepts of HTML, CSS, JavaScript,
    and the browser in which we expect all of these to run in union. We always have,
    and always will, code in a certain style, which is natural. However, how did we
    develop this style? Is it good or can it get better? How do we get to decide what
    we should and should not ask others to follow? These are some of the questions
    that we will try and answer in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will discuss the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Importance of best practices and take a look at some of the examples.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring different kinds of HTML, CSS, and JavaScript optimizations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delve into the internal working of some of the features of Chrome.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Best practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Best practices is a relative term for obvious reasons. What is considered best
    is rather dependent on the team in which you work and what version of JavaScript
    you work with. In this section, we will try to cast a wide net over some of these
    best practices, and get an understanding of what some of the practices look like
    so that we can adapt and use them as well.
  prefs: []
  type: TYPE_NORMAL
- en: Best practices for HTML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's approach this section top-down and address the best practices for each
    of the sections within an HTML file.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring the correct DOCTYPE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Have you ever wondered why we have `<!DOCTYPE html>` at the top of our page?
    We can clearly leave it out, and still the page seems to work. Then, why exactly
    do we need this? The answer is **a****voiding backward compatibility**—if we do
    not specify the DOCTYPE, the browser that is interpreting and rendering our HTML
    goes into quirks mode, which is a technique to support really old websites that
    were built with outdated versions and markups of HTML, CSS, and JS. Quirks mode
    emulates a lot of bugs that existed in the older versions of the browsers, and
    we do not want to deal with those.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the correct meta-information to the page
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Any web page, when rendered, needs some meta-information. Although this information
    does not get rendered on the page, it''s critical to render the page correctly.
    The following are some of the good practices for adding the meta-information:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding the right `lang` attribute to your `html` tag to comply with w3c''s
    internationalization standards:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Declaring the correct `charset` to support special characters on your web page:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the correct `title` and `description` tags to support search engine optimization:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the appropriate `base` URL to avoid providing absolute URLs everywhere:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Dropping unnecessary attributes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This might seem obvious, but is still largely used. When we add a `link` tag
    to download a `stylesheet`, our browser already knows that it is a `stylesheet`.
    There is no reason to specify the type of that link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Making your app mobile ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Have you ever seen one of those websites that look exactly the same on desktop
    and mobile and wonder why they would build it like that? In the new age of web
    development, why would someone not leverage the responsiveness provided by the
    latest HTML and CSS versions? This could happen to anyone; we have all the right
    breakpoints defined and are using media queries as expected, but nothing happens.
    This is usually because we forgot to include the `viewport`, the `meta` tag; including
    the `meta` tag for `viewport` fixes all our problems:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `viewport` is basically the total viewable area for a user, which will be
    smaller in a mobile and larger in a desktop; the `meta` tag defines how the browser
    should render the website, based on the size of the `viewport`.
  prefs: []
  type: TYPE_NORMAL
- en: Loading style sheets in the <head>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a matter of preference and choice. Can we load the style sheets at the
    end of the page load? Sure we can, but we want to avoid it so that our users do
    not see unstyled page flashing before it picks up the correct styles. Our browsers,
    when provided with CSS and HTML, create a **CSS Object Model** (**CSSOM**) and
    **Document Object Model** (**DOM**). When a DOM is being constructed, the browser
    looks up the CSSOM to check whether there are any styles corresponding to that
    node of the DOM. Hence, we want to make sure that the CSSOM is constructed and
    ready for the DOM to render.
  prefs: []
  type: TYPE_NORMAL
- en: An alternative is to load only the basic styles first in the head tag of the
    page, and the rest of the styles can be requested at the end of the body. That
    means our page can be rendered a little faster, but it is worth noting that this
    may not be worth the effort sometimes, depending on your application size and
    use case.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding inline styles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using inline styles by providing them directly on the element in an HTML file
    is bad for multiple reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: We cannot reuse the styles applied to one element
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our HTML is flooded with CSS, making it very noisy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We cannot leverage pseudo elements, such as `before` and `after`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using semantic markup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With HTML5, we no longer have to worry about using a `<div>` tag for everything.
    We have been gifted with a more robust set of semantic tags, which help us construct
    our templates in a more meaningful fashion:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/dd8cb81c-7052-4a20-afb6-c694e977c20d.png)A point worth noting is
    that these new tags only provide meaning to our template but no styling. If we
    want it to look a certain way, we will need to style the elements as we want them
    to look. Also, the new HTML5 tags are not available in browsers older than IE9,
    so we need to prepare for fallbacks such as HTML5shiv.'
  prefs: []
  type: TYPE_NORMAL
- en: Using Accessible Rich Internet Applications (ARIA) attributes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Whenever we are developing a web application, we will need to ensure that our
    applications are compatible with screen readers to support users with disabilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This information does not collide with any of the existing information on the
    screen, and it enables the screen readers to pick up and process this information.
    Of course, all of this is possible only if the HTML renderer supports ARIA, which
    is available in all the latest browsers.
  prefs: []
  type: TYPE_NORMAL
- en: Loading scripts at the end
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The heart of any application lives in the JavaScript files that are defined
    by the developers. Hence, we will need to pay extra attention while we try to
    load and execute these files, which can be significantly larger than that of their
    counterpart HTML and CSS files. When we try to load external JS files using a
    script tag, the browser first downloads them and then executes them (after parsing
    and compiling). We will need to make sure that our application is loaded and executed
    at the right time. What that means for us is that if our application logic is
    reliant on the DOM, we need to ensure that the DOM is rendered before the script
    is executed. This makes it a pretty good reason for us to load the scripts at
    the end of the body tag within our application.
  prefs: []
  type: TYPE_NORMAL
- en: Even if we do not rely on the DOM in our JavaScript, we would still want to
    load our scripts at the end because the script tags are render blocking by default,
    that is, if your browser encounters your script tag in the head (for example),
    it begins to download and execute the JS files and does not render the rest of
    the page until the execution is complete. Also, if we have too many JS files,
    then the page appears to have hung and does not render the UI completely to our
    end user until all the JS files have been downloaded and executed successfully.
  prefs: []
  type: TYPE_NORMAL
- en: There is one workaround if you still want to add the script tags along with
    the link tag to download the style sheets. You can add the `defer` or `async`
    attribute to the script tag. `Defer` lets you download the file parallel to the
    DOM rendering and executes the script once the render is complete. The `async`
    downloads the file parallel to the DOM render and pauses rendering for execution
    and then resumes after execution. Use them wisely.
  prefs: []
  type: TYPE_NORMAL
- en: CSS best practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The list of CSS best practices is not as long as that of HTML. Also, a lot of
    potential issues can be subsided significantly by the use of a preprocessing language,
    such as **Sassy CSS** (**SCSS**). Let's assume that you cannot use SCSS for some
    reason and discuss good and bad of plain old CSS.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding inline styles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is important enough to be part of both HTML's and CSS's best practices.
    Just do not do apply inline styles.
  prefs: []
  type: TYPE_NORMAL
- en: Do not use !important
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Easy to say, hard to do. Using `!important` is one of the easiest workarounds
    available to make your styles apply to an element. However, this comes at a price
    of its own. CSS or Cascading Style Sheets rely on the fact that the styles will
    be cascaded based on the priority of the application (ID, class, and element tag)
    or the order in which they appear. Using `!important` messes that up, and if you
    have multiple CSS files, then it becomes a big mess to correct. It's better to
    avoid such a practice and do it the right way from the get-go.
  prefs: []
  type: TYPE_NORMAL
- en: Arranging styles within a class alphabetically
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This does not sound like a big deal, does it? Well, if all you have is one
    CSS file with a couple of classes, then maybe it is okay. However, when you have
    big files with a complex hierarchy, the last thing you want is to commit a small
    mistake which costs you a lot of time. Take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note in the preceding code that we added conflicting styles for the background
    property of the element, and now when rendered, it is all red. This could have
    been easily caught, but because of the ordering of the properties within the class,
    it got lost.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the media queries in an ascending order
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Defining media queries is another area which gets confusing as the size of
    the application grows. When defining the media queries, always define them in
    an increasing order so that you can isolate your styles and leave an open upper
    bound, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note in the preceding code that we have left the last media query to apply for
    all screens that are `1200px` and more in size, which would cover monitors, TVs,
    and so on. This would not have worked well if we were doing it the other way,
    in which we set the styles based on the max-width of the screen size. What would
    happen if we open it on a projector? It will certainly not work like you hoped
    it would.
  prefs: []
  type: TYPE_NORMAL
- en: Best practices for JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is no start and end to this topic. There are a lot of opinions regarding
    how things should be done in JavaScript, and it turns out that most of them are
    correct (depending on your background, experience, and use case). Let's take a
    look at some of the most commonly discussed best practices for JavaScript (ES5).
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding polluting the global scope
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Do not add properties or methods to the global scope. These will bloat your
    window object and make your page slow and stuttery. Instead, always create a variable
    within a method, which will be taken care of when the method is destroyed.
  prefs: []
  type: TYPE_NORMAL
- en: Using 'use strict'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's a one-line change, which can go a long way when it comes to catching code
    smells and any code irregularities, such as deleting a variable. The `use strict`
    clause throws an error when an illegal action is performed at the runtime, so
    it doesn't necessarily prevent our app from breaking, but we can catch and fix
    issues before they are deployed.
  prefs: []
  type: TYPE_NORMAL
- en: Strict checking (== vs ===)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JavaScript can be a fairly tricky language when coming to typecasting or type
    conversions. The fact that there are no data types does not make this any simpler.
    Using a ==forces an implicit typecasting as compared to ===**. **So, it is advisable
    to always use === unless you want 12== 12 to be true.
  prefs: []
  type: TYPE_NORMAL
- en: For more details on understanding why it works the way it does, refer to the
    Abstract Equality Comparison Algorithm, found at [https://www.ecma-international.org/ecma-262/5.1/#sec-11.9.3](https://www.ecma-international.org/ecma-262/5.1/#sec-11.9.3).
  prefs: []
  type: TYPE_NORMAL
- en: Using ternary operators and Boolean || or &&
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is always suggested to keep your code readable but, when warranted, use
    the ternary operators to make your code concise and readable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, the preceding code can be condensed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Setting default values can also be achieved easily as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Modularization of code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we create a script, it is obvious that we want it to do multiple things,
    for example, if we have a login page, the script for the login page should handle
    login (obviously), reset a password, and signup. All of these operations would
    require the email validation. Keeping validation part of each of these operations
    in its own method is known as Modularization. It helps us keep our methods small,
    readable, and makes unit testing a lot easier.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding pyramid of doom
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Pyramid of doom is a classic scenario where we have tons of nesting or branching.
    This makes the code overly complex and the unit testing a very complex job:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Keeping DOM access to a minimum
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: DOM access is an expensive operation, and we need to reduce it as much as we
    can to avoid our page from dying. Try caching the DOM elements once they are accessed
    in some local variables or leverage virtual DOM, which is more efficient, as it
    batches all the DOM changes and dispatches them all together.
  prefs: []
  type: TYPE_NORMAL
- en: Validating all data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Registering a new user? Ensure that all the fields entered are validated on
    both the UI and the backend. Doing it in both the places makes it twice as good,
    and validations on the UI help get the error message to the user a lot quicker
    than that of server-side validation.
  prefs: []
  type: TYPE_NORMAL
- en: Do not reinvent the wheel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JavaScript community is very generous when it comes to open source software
    and projects. Leverage them; do not rewrite something that is already available
    someplace else. It is not worth the time and effort to rewrite some of the community-tested
    software that is freely available. If a software does only 90% of what you need,
    consider contributing the remaining 10% of that functionality yourself to the
    open source project.
  prefs: []
  type: TYPE_NORMAL
- en: HTML optimizations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As web developers, we are well versed in creating templates. In this section,
    we will explore ways in which we can make this process as efficient as possible.
  prefs: []
  type: TYPE_NORMAL
- en: DOM structuring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As obvious as this might seem, DOM structuring can make quite a big difference
    when it comes to rendering the UI. For an HTML template to become DOM, it goes
    through a series of steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Template Parsing** : Parser reads the HTML file'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Tokenization**: Parser identifies the tokens, such as `html` and `body`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Lexing**: Parser converts the tokens to tags, such as `<html>` and `<body>`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**DOM Construction**: This is the last step where the browser converts the
    tags into a tree while applying the applicable styles and rules for the element'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With that in mind, it becomes important that we do not nest our elements unnecessarily.
    Try to apply styles to elements rather than nest them in other elements. With
    that being said, one might wonder, how much does this really matter? The browsers
    are pretty good at doing this, so would it really matter if I have an extra element
    in my DOM? Truthfully, no, it would not matter if you do have an extra element.
    However, think about all the different browsers that are out there. Also, how
    many places you are adding this additional element; consider the precedent that
    such a practice would set. Over time, your overhead is going to start to matter.
  prefs: []
  type: TYPE_NORMAL
- en: Prefetching and preloading resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some of the lesser-known properties of the `<link>` tag are the `rel=prefetch`
    and `rel=preload` options. They allow the browser to preload some of the content
    that will be required in the subsequent or, sometimes, even the current page.
  prefs: []
  type: TYPE_NORMAL
- en: <link rel=prefetch >
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s discuss a rather simple example to understand prefetching: loading images.
    Loading images is one of the most common actions a web page performs. We decide
    which image we want to load using either an `img` tag in the HTML template or
    the `background-image` property in CSS.'
  prefs: []
  type: TYPE_NORMAL
- en: Either way, the image does not get loaded until the element is parsed. Also,
    let's say that your image is very large and takes a lot of time to download, then
    you would have to rely on a bunch of fallbacks, such as providing the image dimension
    so that the page does not flicker or using the `alt` attribute in case the download
    fails.
  prefs: []
  type: TYPE_NORMAL
- en: 'One possible solution is to prefetch your resources that will be needed in
    the near future. That way, you can avoid downloading the resources until the user
    lands on that page. A simple example  would look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We are intentionally delaying the load of the `img` tag until the prefetch is
    done. Ideally, you would prefetch the resources needed for the next page, but
    this accomplishes the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we run this page, we can see the requests for the image as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/321a0a8d-d618-4f88-b00b-2a4180924181.png)'
  prefs: []
  type: TYPE_IMG
- en: This sounds too good to be true, right? Right, as useful as this feature is,
    there are issues that we run into when dealing with prefetch across multiple browsers.
    Firefox only prefetches when it is idle; some browsers are capable of pausing
    the download if the user triggers another action and then redownload the rest
    of the image when the browser is idle again, but again that depends on how the
    server is serving the cacheable content (that is, server needs to support serving
    multipart file). Then, there are browsers which can, and will, abandon the prefetch
    because the network is too slow.
  prefs: []
  type: TYPE_NORMAL
- en: <link rel=preload >
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Preload is very similar to prefetch, with the difference that the browser does
    not have a choice to abandon the download for any reason at any point once the
    resource download is triggered.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax is also very similar, except that we define the type of the resource
    that we are trying to preload:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Prefetching and preloading are also a very common choice when it comes to downloading
    fonts and font families because the request to load fonts is not triggered until
    both the CSSOM and DOM are ready to go.
  prefs: []
  type: TYPE_NORMAL
- en: Layout and layering of HTML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Coming up with an HTML template for rendering your elements on the UI is one
    of the simplest tasks of being a web developer. In this section, we will talk
    about how Chrome handles the template and renders it onto the UI. There are two
    crucial parts of the HTML template, layout and layers, and we will take a look
    at examples of each of these and how they affect the page performance.
  prefs: []
  type: TYPE_NORMAL
- en: The HTML layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start with an extremely simple web page and take a look at how chrome
    handles rendering this page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Once we load the page, we will use Chrome **Developer tools** (**DevTools**)
    to generate the performance snapshot of this templates load. To do so, navigate
    to the CDT on your Chrome browser (Settings -> More tools -> Developer tools).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we are there, let''s record a new snapshot by clicking on the record button
    on the top-left corner of the panel that just opened. Once your page loads, stop
    the recording and let the snapshot load in the panel. The result of that would
    look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/54f8d076-62e1-4693-a568-296d544c0175.png)'
  prefs: []
  type: TYPE_IMG
- en: Incomprehensible, right? Well, let's break this down into small pieces that
    we can understand. Our main focus will be on the `main` section (expanded in the
    screenshot). Let's zoom into that a bit to take a look at what the events are
    from left to right.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will see the beforeunload event:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/51ace852-0b26-492b-aacc-79bda81c73ee.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we will see the update layer tree (which we will discuss later):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/266d1ed6-7cc7-4da3-b92c-0deb63079235.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We now note a Minor GC, which is a browser-specific event (we will discuss
    this in a later section):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/581f7229-dd5a-432e-af44-fcffb4d37f11.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, we will note the  `DOMContentLoaded` event followed by the `Recalculate
    Style` event, which is when our page is ready to be interacted with:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a171491a-16f2-49a4-bf80-949a8d0e8009.png)'
  prefs: []
  type: TYPE_IMG
- en: Pretty cool, right? This syncs exactly with what we have heard about browsers
    before. They load the page, then `DOMContentLoaded` gets triggered when everything
    is ready. However, notice that, there is another event called Minor GC which is
    being triggered too. We can ignore this, as it is internally handled by the browser
    and has very little to do with the way our code is structured.
  prefs: []
  type: TYPE_NORMAL
- en: Once the DOM is loaded, we note that we have another event being triggered called
    `Recalculate Style`, which is exactly what it sounds like. The DOM is ready, and
    the browser checks and applies any and all styles that need to be applied to this
    element. However, you may wonder, we did not add any styles to our template, right?
    Then, what styles are we talking about? By default, all browsers apply styles
    to all the elements they render, and these are known as User Agent Stylesheets.
    The browser still has to add the user agent style sheet styles to the CSSOM.
  prefs: []
  type: TYPE_NORMAL
- en: We still haven't really discussed what `Layout` is, apart from it being the
    geometrical structure in which the browser will arrange the elements including,
    but not limited to, their size, shape, and position on the page. `Layout` is also
    an event, which will be recorded by the CDT, to show you how long the browser
    is spending in trying to rearrange your layout. It is very important that we try
    to keep the layout event to a minimum. Why? Because `Layout` is not an isolated
    event. It is chained by a sequence of other events (such as updating the layer
    tree and painting the UI), which are required to complete the arrangement of the
    elements on the UI.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another important thing to consider is that the `Layout` event is triggered
    for all the elements that are effected on the page, that is, even when one deeply
    nested element is changed, your entire element (or event surrounding elements
    based on the change) is re-laid out. Let''s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'It is pretty straightforward; we have one page with a very small parent consisting
    of four child elements. We have a button which sets the height of all elements
    to `100px`. Let''s now run this page and track the performance when we click on
    the button `update height` to change the height of the elements we see the following
    on the UI:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/f79f82f7-c9ed-4cd4-a22f-d6a6312d30a3.png)'
  prefs: []
  type: TYPE_IMG
- en: We can see from preceding screenshot that once the click event starts, it triggers
    our function, which then sets off a chain of events, including `Layout` that takes
    0.23ms. However, one might wonder, why do we have a `Recalculate Style` event
    in between the `Function` and the `Layout`? Remember our old friend User Agent
    Stylesheet? It sets a few styles on the button when it is active, which triggers
    the `Recalculate Style` event.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to remove all the styles of an element (such as a button in the
    case described earlier), you can do so by applying the `all:unset`; property to
    the element of your choice. This will completely un-style the element. However,
    it will reduce the `Recalculate Style` event to a fraction of what it is with
    the User Agent Styles applied.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now change the JavaScript function to only change the style of the first
    child element instead of all the elements on the page and take a look at how that
    affects the `Layout` events execution in our case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when we run the page and profile the execution of the click method, we
    will see the following in the profiler:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/572fd447-4897-46b1-9042-c17a91bf5378.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see in the preceding screenshot, it still takes 0.21ms to layout
    the entire page, which is not very different from our previous value. In our preceding
    example, we have five more elements. However, in a production application, this
    can, and will, scale to 1000s of elements, and, for a smooth transition, we want
    to keep our `Layout` event under 16ms (60fps).
  prefs: []
  type: TYPE_NORMAL
- en: In all probability, you may not ever come across this issue, but if you do,
    the simplest way to handle it would be to first check that you are using the latest
    layout model supported by your browser. In most of the browsers, it would be flexbox
    or grid, so prefer that over floats, percentages, or positioning.
  prefs: []
  type: TYPE_NORMAL
- en: HTML layers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have seen in the earlier example, once the element is re-laid out, we
    `Paint` the element, that is, fill the pixels with the color, which is supposed
    to be a part of the element at the given position (determined by `Layout`).
  prefs: []
  type: TYPE_NORMAL
- en: Once the `Paint` event is complete, the browser then performs `Composition`,
    which is basically our browser putting together all the parts of the page. The
    lesser these parts, the faster the page load will be. Also, if a certain section
    of the `Composition` takes too long, then the entire page load is delayed.
  prefs: []
  type: TYPE_NORMAL
- en: How do we handle these operations which take too long? We can handle it by promoting
    them to their own layer. There are certain CSS operations that we can perform
    on elements, which will promote them to their own layer. What does that mean for
    us? These promoted elements will be now deferred and executed on the GPU as textures.
    We no longer have to worry about our browser triggering the `Layout` or `Paint`
    event for these promoted elements, and we are only concerned with the `Composition`
    of the element.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the example earlier, so far we have established the first four steps of
    the flow of any change as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript file gets executed
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Recalculation of styles
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Layout` event
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Paint` event
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, to that list, we can add the following steps to completely render the
    element on the UI:'
  prefs: []
  type: TYPE_NORMAL
- en: 5\. `Composition`
  prefs: []
  type: TYPE_NORMAL
- en: 6\. Multithread Rasterization
  prefs: []
  type: TYPE_NORMAL
- en: '*Step 6* merely renders our pixels onto the UI, which can be batched and run
    on parallel threads. Let''s create a simple HTML and take a look at how it renders
    onto a single layer on the UI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We can access the Layers from the DevTool by navigating to the Settings option
    and then selecting More tools and Layers. On loading the page shown previously,
    we will see the following in the Layers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/22386b4f-25e5-4522-b94b-f2382afa915b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When we profile the preceding page, we can see, as expected, that the page
    loads and renders the UI on the `Main` thread:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/4d72a23b-6be1-4df8-8512-2d1153d50d58.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s now change this example to load onto its own layer so that we can completely
    skip both the `Layout` and the `Paint` sections altogether. To load an element
    onto a layer of its own, all we need to do is either give it a CSS transform or
    set the `will-change` property to transform:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is an updated example template, which uses the CSS3 `transform`
    property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we added a very small animation, which will infinitely
    rotate the element. When we reload the page, we can see that it has been added
    to its own layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c948a949-970a-4661-ba96-c92d1f7e34ca.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Not just that, when we record the performance of our modified template, we
    can see something quite interesting:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/67735520-b4cb-47f3-9140-4f49d5a87138.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can see in the preceding screenshot, the browser completely defers the
    `Layer` onto the GPU as a new texture, and, from then on, the GPU handles the
    rendering/updating of the element and not the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Okay, so, does that mean we load each element onto its own `Layer` and then
    let the GPU take it from there? No, certainly not, because each `Layer` internally
    requires memory, and loading 1,000s of elements onto each Layer would be counterproductive.
    For example, the only time when we should intentionally promote elements to their
    own `Layer` is when an element is taking too long during `Composition` and is
    choking operations, such as scroll or swipe. Another use case could be when you
    have a single element performing multiple changes, such as animating height, width,
    and background color. This will continuously invoke all the steps of the rendering
    process (from `Layout` to Rasterization), and we do not really need to do all
    of that if we know that it is limited to these few changes. We can simply promote
    this element to its own layer and be done with it.
  prefs: []
  type: TYPE_NORMAL
- en: CSS optimizations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'CSS optimizations are extremely easy and kind of obvious if you have experience
    developing with any preprocessor frameworks, such as SCSS/LESS. When we discuss
    CSS optimization, we are really talking about two different yet dependent things:'
  prefs: []
  type: TYPE_NORMAL
- en: Loading the style sheets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rendering and applying styles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coding practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a number of coding practices that we can adapt and learn to make our
    application perform better. Most of them might seem insignificant, but they do
    matter when scaled to a large application. We will discuss a few of these techniques
    with examples.
  prefs: []
  type: TYPE_NORMAL
- en: Using smaller values for common ENUM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we are talking about reducing the page load time, one quick way to do so
    is by removing redundancies in the CSS file itself:'
  prefs: []
  type: TYPE_NORMAL
- en: Using `#FFFFFF` ? Switch to `#FFF`, which is the same RGB value represented
    in short.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do not add `px` after a properties value if the value is `0`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use minification if not being used already. This concatenates all the CSS files
    in use and removes all the whitespace and newlines.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use GZip to compress the minified file while transferring it over the network.
    It is very easy, and browsers are very good at unzipping the files efficiently.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Be aware of browser-specific optimizations at hand. For example, in case of
    Chrome, we do not have to apply styles in the `rgba(x,y,z,a)` format. We can apply
    it as `rgba` during dev and extract the corresponding HEX value using the DevTool.
    Simply, inspect the element in question and click on the small rectangle while
    pressing *Shift*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](assets/e80a8814-de08-45cf-a14c-b60e7b7ee381.png)'
  prefs: []
  type: TYPE_IMG
- en: Using shorthand properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using shorthand properties is one way in which the page load can be sped up.
    As obvious as it may sound, sometimes, we take the browser and network for granted
    when we are working on our cozy laptop, and we forget to take into consideration
    the poor 3G-based devices. So, the next time you want to style the background
    or border of an element, ensure that they are all collapsed and written using
    shorthand.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, you may run into a situation where you want to override only one
    property of a certain element''s style. For example, if you want to apply border
    on three sides of an element, use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Avoiding complex CSS selectors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whenever you are creating your CSS styles, it is imperative to understand that there
    is a cost associated with the browser to apply these styles to any element. We
    can analyze our CSS selectors the same way we do our JavaScript and come up with
    the best and worst case runtime performance of each of the styles we apply.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, consider that we have a style as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The complexity of this would be much higher than simply creating a class and
    assigning it directly to the element itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Our browser no longer has to check whether each and every element falls into
    the hierarchy of the style defined previously. A technique developed out of this
    concept is called  **Block-Element-Modifier** (**BEM**), which is quite easy to
    understand. Give a single class name to your elements, and try not to nest them:'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, consider that your template looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'You could apply styles using BEM as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'If you ever need to add a custom styling to an element, you can either create
    a new class and apply it directly, or you can combine the nesting with the current
    level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Understanding the browser
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similar to HTML rendering, CSS parsing and rendering are also complex processes,
    which browsers very effortlessly hide. It is always good to know what we can avoid
    to make things better for us. Let's take the same example as HTML and discuss
    how Chrome handles these.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding repaint and reflow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s first briefly talk about what a repaint and reflow are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Repaint**: An action performed by the browser when the non-geometric properties
    of an element change, for example, background color, text color, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Reflow**: An action performed by the browser because of the geometric change
    to an element (or its parent) directly or via a computed property. This process
    is same as the `Layout` discussed earlier.'
  prefs: []
  type: TYPE_NORMAL
- en: While we cannot completely prevent Repaint and Reflow events completely, we
    can certainly play our part in minimizing the changes that trigger these operations.
    Almost all DOM `read` operations (such as `offsetWidth` and `getClientRects`) trigger
    a `Layout` event because the values of such read operations are done on demand,
    and the browser does not care about their values until explicitly requested. Also,
    anytime we modify the DOM, the `Layout` is invalidated and it will have to be
    recalculated if we need to read the DOM elements properties the next time.
  prefs: []
  type: TYPE_NORMAL
- en: Critical rendering path (CRP)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have seen how to optimize the page load (reducing payload, size,
    and so on), and then we talked about the things which we will need to account
    for to keep the page performant once it is rendered. Critical rendering path is
    the technique of optimizing the initial load of the page above the fold (that
    is, the top part of the page that shows up on the initial load prior to any scroll).
    This is also known as **time to interact** (**TTI**) or **time to first byte**
    (**TTFB**), which we want to reduce to keep the page load fast.
  prefs: []
  type: TYPE_NORMAL
- en: 'Technically, CRP includes the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Receive and start parsing HTML.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Download and construct CSSOM.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Download and execute JS.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finish constructing DOM.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create Render Tree.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'So if we want our TTI to be low, it''s quite obvious that we will need to have
    our DOM and CSSOM constructed as quickly as possible without any render-blocking
    CSS or parser-blocking JS files. One of the indications for our TTI to be low
    is that our `DOMContentLoaded` event fires quickly because DCL is fired only when
    DOM and CSSOM are ready. Let''s take the following example template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that it is pretty lean and does not even load any external styles
    or scripts. This is pretty unusual for a web page, but it serves as a good example.
    When we run this page and open the Network tab, we can see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/1bb2c85f-d936-4678-b647-c3e2c7ffe398.png)'
  prefs: []
  type: TYPE_IMG
- en: 'However, the HTML we mentioned is pretty unusual. In all possibility, we will
    have more than one external CSS and JS file being loaded into our page. In situations
    like that, our DCL event gets delayed. Let''s add blank CSS and JS files to be
    loaded in our `blank.html` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a2b4363a-4909-4a4f-b2fb-b0a217c6fc6a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, we can see that, even though there isn''t much to be loaded, the DCL
    event has been pushed until the browser downloads and runs the JS file because
    the JS files fetching and execution are render blocking operations. Our goal is
    now much clearer: we will need to reduce the DCL to a minimum, and, from what
    we have seen so far, we will need to load the HTML ASAP while everything else
    can be loaded once the initial page is rendered (or at least is being rendered).
    Earlier we have seen that we can use the `async` keywords along with the script
    tags to make the JavaScript load and execute asynchronously. Let''s use the same
    now to make our page load faster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when we run this page with the Network tab open, we will see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/45273501-86bf-46b9-9d2e-0fbfbb2431a1.png)'
  prefs: []
  type: TYPE_IMG
- en: We can see that the DCL (represented by the blue vertical line under the *waterfall*
    tab) occurs way before the CSS and JS files are downloaded and executed. Another
    advantage of using the `async` attribute is that the `async` attribute indicates
    that the JavaScript is not dependent on CSSOM, and hence it does not have to be
    blocked by the CSSOM construction.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript optimizations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are tons of resources available online to discuss the various optimizations
    that can be applied to JavaScript. In this section, we will take a look at some
    of these micro-optimizations and determine how we can take small steps toward
    making our JavaScript more performant.
  prefs: []
  type: TYPE_NORMAL
- en: Truthy/falsy comparisons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have all, at some point, written if conditions or assigned default values
    by relying on the truthy or falsy nature of the JavaScript variables. As helpful
    as it is most of the times, we will need to consider the impact that such an operation
    would cause on our application. However, before we jump into the details, let''s
    discuss how any condition is evaluated in JavaScript, specifically an `if` condition
    in this case. As a developer, we tend to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This works for most of the cases, unless the number is 0, in which case it
    gets evaluated to false. That is a very common edge case, and most of us catch
    it anyway. However, what does the JavaScript engine have to do to evaluate this
    condition? How does it know whether the objOrNumber evaluates to true or false?
    Let''s return to our ECMA262 specs and pull out the IF condition spec ([https://www.ecma-international.org/ecma-262/5.1/#sec-12.5](https://www.ecma-international.org/ecma-262/5.1/#sec-12.5)).
    The following is an excerpt of the same:'
  prefs: []
  type: TYPE_NORMAL
- en: Semantics
  prefs: []
  type: TYPE_NORMAL
- en: The production IfStatement : If (Expression) Statement else Statement
  prefs: []
  type: TYPE_NORMAL
- en: 'Statement is evaluated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Let exprRef be the result of evaluating Expression.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If ToBoolean(GetValue(exprRef)) is true, then
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return the result of evaluating the first Statement.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Else,
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return the result of evaluating the second Statement.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, we note that whatever expression we pass goes through the following three
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Getting the `exprRef` from `Expression`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`GetValue` is called on `exprRef`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`ToBoolean` is called as the result of *step 2*.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Step 1* does not concern us much at this stage; think of it this way—an expression
    can be something like `a == b` or something like the `shouldIEvaluateTheIFCondition()`
    method call, that is, something that evaluates your condition.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Step 2* extracts the value of the `exprRef`, that is, 10, true, undefined.
    In this step, we differentiate how the value is extracted based on the type of
    the `exprRef`. You can refer to the details of `GetValue` at [https://www.ecma-international.org/ecma-262/5.1/#sec-8.7.1](https://www.ecma-international.org/ecma-262/5.1/#sec-8.7.1).'
  prefs: []
  type: TYPE_NORMAL
- en: '*Step 3* then converts the value extracted from *Step 2* into a Boolean value
    based on the following table (taken from [https://www.ecma-international.org/ecma-262/5.1/#sec-9.2](https://www.ecma-international.org/ecma-262/5.1/#sec-9.2)):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/3c9cc47e-b91e-414d-80ab-ef45d24f106b.png)'
  prefs: []
  type: TYPE_IMG
- en: At each step, you can see that it is always beneficial if we are able to provide
    the direct boolean value instead of a truthy or falsy value.
  prefs: []
  type: TYPE_NORMAL
- en: Looping optimizations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can do a deep-down dive into the for loop, similar to what we did with the
    if condition earlier ([https://www.ecma-international.org/ecma-262/5.1/#sec-12.6.3](https://www.ecma-international.org/ecma-262/5.1/#sec-12.6.3)),
    but there are easier and more obvious optimizations which can be applied when
    it comes to loops. Simple changes can drastically affect the quality and performance
    of the code; consider this for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code can be changed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'What is even better is to run the loops in reverse, which is even faster than
    what we have seen previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The conditional function call
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Some of the features that we have within our applications are conditional.
    For example, logging or analytics fall into this category. Some of the applications
    may have logging turned off for some time and then turned back on. The most obvious
    way of achieving this is to wrap the method for logging within an if condition.
    However, since the method could be triggered a lot of times, there is another
    way in which we can make the optimization in this case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of the preceding approach, we can instead try to do something, which
    is only slightly different but allows V8-based engines to optimize the way the
    code is executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Now, the preceding implementation is a double-edged sword. The reason for that
    is very simple. JavaScript engines employ a technique called **inline caching**
    (**IC**), which means that any previous lookup for a certain method performed
    by the JS engine will be cached and reused when triggered the next time; for example,
    if we have an object that has a nested method, a.b.c, the method a.b.c will be
    only looked up once and stored on cache (IC); if a.b.c is called the next time,
    it will be picked up from IC, and the JS engine will not parse the whole chain
    again. If there are any changes to the a.b.c chain, then the IC gets invalidated
    and a new dynamic lookup is performed the next time instead of being retrieved
    from the IC.
  prefs: []
  type: TYPE_NORMAL
- en: So, from our previous example, when we have `noOp` assigned to the `trackUserAnalytics()`
    method, the method path gets tracked and saved within IC, but it internally removes
    this function call as it is a call to an empty method. However, when it is applied
    to an actual function with some logic in it, IC points it directly to this new
    method. So, if we keep calling our `toggleUserAnalytics()` method multiple times,
    it keeps invalidating our IC, and our dynamic method lookup has to happen every
    time until the application state stabilizes (that is, `toggleUserAnalytics()`
    is no longer called).
  prefs: []
  type: TYPE_NORMAL
- en: Image and font optimizations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When it comes to image and font optimizations, there are no limits to the types
    and the scale of optimization that we can perform. However, we need to keep in
    mind our target audience, and we need to tailor our approach based on the problem
    at hand.
  prefs: []
  type: TYPE_NORMAL
- en: With both images and fonts, the first and foremost important thing is that we
    do not overserve, that is, we request and send only the data that is necessary
    by determining the dimensions of the device that our application is running on.
  prefs: []
  type: TYPE_NORMAL
- en: The simplest way to do this is by adding a cookie for your device size and sending
    it to the server along with each of the request. Once the server receives the
    request for the image, it can then retrieve the image based on the dimension of
    the image that was sent to the cookie. Most of the time these images are something
    like a user avatar or a list of people who commented on a certain post. We can
    agree that the thumbnail images do not need to be of the same size as that of
    the profile page, and we can save some of the bandwidth while transmitting a smaller
    image based on the image.
  prefs: []
  type: TYPE_NORMAL
- en: Since screens these days have very high **Dots Per Inch** (**DPI**), the media
    that we serve to screens needs to be worthy of it. Otherwise, the application
    looks bad and the images look all pixelated. This can be avoided using Vector
    images or `SVGs`, which can be GZipped over the wire, thus reducing the payload
    size.
  prefs: []
  type: TYPE_NORMAL
- en: Another not so obvious optimization is changing the image compression type.
    Have you ever loaded a page in which the image loads from the top to bottom in
    small, incremental rectangles? By default, the images are compressed using a baseline
    technique, which is a default method of compressing the image from top to bottom.
    We can change this to be progressive compression using libraries such as `imagemin`.
    This would load the entire image first as blurred, then semi blurred, and so on
    until the entire image is uncompressed and displayed on the screen. Uncompressing
    a progressive JPEG might take a little longer than that of the baseline, so it
    is important to measure before making such optimizations.
  prefs: []
  type: TYPE_NORMAL
- en: Another extension based on this concept is a Chrome-only format of an image
    called `WebP`. This is a highly effective way of serving images, which serves
    a lot of companies in production and saved almost 30% on bandwidth. Using `WebP`
    is almost as simple as the progressive compression as discussed previously. We
    can use the `imagemin-webp` node module, which can convert a JPEG image into a
    `webp` image, thus reducing the image size to a great extent.
  prefs: []
  type: TYPE_NORMAL
- en: Web fonts are a little different than that of images. Images get downloaded
    and rendered onto the UI on demand, that is, when the browser encounters the image
    either from the HTML 0r CSS files. However, the fonts, on the other hand, are
    a little different. The font files are only requested when the Render Tree is
    completely constructed. That means that the CSSOM and DOM have to be ready by
    the time request is dispatched for the fonts. Also, if the fonts files are being
    served from the server and not locally, then there are chances that we may see
    the text without the font applied first (or no text at all) and then we see the
    font applied, which may cause a flashing effect of the text.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are multiple simple techniques to avoid this problem:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Download, serve, and preload the font files locally:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Specify the unicode-range in the font-face so that browsers can adapt and improvise
    on the character set and glyphs that are actually expected by the browser:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, we have seen that we can get the unstyled text to be loaded on to the
    UI and the get styled as we expected it to be; this can be changed using the font
    loading API, which allows us to load and render the font using JavaScript:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Garbage collection in JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's take a quick look at what **garbage collection** (**GC**) is and how we
    can handle it in JavaScript. A lot of low-level languages provide explicit capabilities
    to developers to allocate and free memory in their code. However, unlike those
    languages, JavaScript automatically handles the memory management, which is both
    a good and bad thing. Good because we no longer have to worry about how much memory
    we need to allocate, when we need to do so, and how to free the assigned memory.
    The bad part about the whole process is that, to an uninformed developer, this
    can be a recipe for disaster and they can end up with an application that might
    hang and crash.
  prefs: []
  type: TYPE_NORMAL
- en: 'Luckily for us, understanding the process of GC is quite easy and can be very
    easily incorporated into our coding style to make sure that we are writing optimal
    code when it comes to memory management. Memory management has three very obvious
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Assign the memory to variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the variables to read or write from the memory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Free the memory when it's no longer needed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, this is the part that is not explicit. How does the browser know when
    we are done with the variable `a` and it is ready to be garbage collected? Let''s
    wrap this inside a function before we continue this discussion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: We have a very simple function, which just adds to our variable `a` and returns
    the result and finishes the execution. However, there is actually one more step,
    which will happen after the execution of this method called **mark and sweep **(not
    immediately after, sometimes this can also happen after a batch of operations is completed
    on the main thread**)**. When the browser performs mark and sweep, it's dependent
    on the total memory the application consumes and the speed at which the memory
    is being consumed.
  prefs: []
  type: TYPE_NORMAL
- en: Mark and sweep algorithm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since there is no accurate way to determine whether the data at a particular
    memory location is going to be used or not in the future, we will need to depend
    on alternatives which can help us make this decision. In JavaScript, we use the
    concept of a **reference** to determine whether a variable is still being used
    or not—if not, it can be garbage collected.
  prefs: []
  type: TYPE_NORMAL
- en: 'The concept of mark and sweep is very straightforward: what all memory locations
    are reachable from all the known active memory locations? If something is not
    reachable, collect it, that is, free the memory. That''s it, but what are the
    known active memory locations? It still needs a starting point, right? In most
    of the browsers, the GC algorithm keeps a list of the `roots` from which the mark
    and sweep process can be started. All the `roots` and their children are marked
    as active, and any variable that can be reached from these `roots` are also marked
    as active. Anything that cannot be reached can be marked as unreachable and thus
    collected. In most of the cases, the `roots` consist of the window object.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we will go back to our previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Our variable a is local to the `test()` method. As soon as the method is executed,
    there is no way to access that variable anymore, that is, no one holds any reference
    to that variable, and that is when it can be marked for garbage collection so
    that the next time GC runs, the `var a` will be swept and the memory allocated
    to it can be freed.
  prefs: []
  type: TYPE_NORMAL
- en: Garbage collection and V8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When it comes to V8, the process of garbage collection is extremely complex
    (as it should be). So, let's briefly discuss how V8 handles it.
  prefs: []
  type: TYPE_NORMAL
- en: In V8, the memory (heap) is divided into two main generations, which are the
    **new-space** and **old-space**. Both new-space and old-space are assigned some
    memory (between *1 MB* and *20 MB*). Most of the programs and their variables
    when created are assigned within the new-space. As and when we create a new variable
    or perform an operation, which consumes memory, it is by default assigned from
    the new-space, which is optimized for memory allocation. Once the total memory
    allocated to the new-space is almost completely consumed, the browser triggers
    a **Minor GC**, which basically removes the variables that are no longer being
    referenced and marks the variables that are still being referenced and cannot
    be removed yet. Once a variable survives two or more **Minor GC**s, then it becomes
    a candidate for old-space where the GC cycle is not run as frequently as that
    of the new-space. A Major GC is triggered when the old-space is of a certain size,
    all of this is driven by the heuristics of the application, which is very important
    to the whole process. So, well-written programs move fewer objects into the old-space
    and thus have less Major GC events being triggered.
  prefs: []
  type: TYPE_NORMAL
- en: Needless to say that this is a very high-level overview of what V8 does for
    garbage collection, and since this process keeps changing over time, we will switch
    gears and move on to the next topic.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding memory leaks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Well, now that we know on a high level what garbage collection is in JavaScript
    and how it works, let's take a look at some common pitfalls which prevent us from
    getting our variables marked for GC by the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Assigning variables to global scope
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This should be pretty obvious by now; we discussed how the GC mechanism determines
    a root (which is the window object) and treats everything on the root and its
    children as active and never marks them for garbage collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the next time you forget to add a `var` to your variable declarations,
    remember that the global variable that you are creating will live forever and
    never get garbage collected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Removing DOM elements and references
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s imperative that we keep our DOM references to a minimum, so a well-known
    step that we like to perform is caching the DOM elements in our JavaScript so
    that we do not have to query any of the DOM elements over and over. However, once
    the DOM elements are removed, we will need to make sure that these methods are
    removed from our cache as well, otherwise, they will never get GC''d:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The code shown previously removes the `row` from the DOM but the variable cache
    still refers to the DOM element, hence preventing it from being garbage collected.
    Another interesting thing to note here is that even when we remove the table that
    was containing the `row`, the entire table would remain in the memory and not
    get GC'd because the row, which is in cache internally refers to the table.
  prefs: []
  type: TYPE_NORMAL
- en: Closures edge case
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Closures are amazing; they help us deal with a lot of problematic scenarios
    and also provide us with ways in which we can simulate the concept of private
    variables. Well, all that is good, but sometimes we tend to overlook the potential
    downsides that are associated with the closures. Here is what we do know and use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run this script in the browser and then profile it, we see as expected
    that the method consumes a constant amount of memory and then is GC''d and restored
    to the baseline memory consumed by the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ff54858d-f532-4323-85de-f1c5c9b62ee8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s zoom into one of these spikes and take a look at the call tree
    to determine what all events are bring triggered around the time of the spikes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/6de48c89-3b37-43ef-834c-80fd809b704c.png)'
  prefs: []
  type: TYPE_IMG
- en: We can see that everything happens as per our expectation here; first, our `setInterval()`
    is triggered, which calls `myGoodFunc()`, and once the execution is done, there
    is a GC, which collects the data and hence the spike, as we can see from the preceding
    screenshots.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, this was the expected flow or the happy path when dealing with closures.
    However, sometimes our code is not as simple and we end up performing multiple
    things within one closure, and sometimes even end up nesting closures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'We can note in the preceding code that we extended our method to contain two
    closures now: `closure1` and `closure2`. Although `closure1` still performs the
    same operation as before, `closure2` will run forever because we have it running
    at 1/10th of the frequency of the parent function. Also, since both the closure
    methods share the parent closure scope, in this case the variable a, it will never
    get GC''d and thus cause a huge memory leak, which can be seen from the profile
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/81fb9ed7-2efd-4b8c-ba7e-d6da22d66fc4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'On a closer look, we can see that the GC is being triggered but because of
    the frequency at which the methods are being called, the memory is slowly leaking
    (lesser memory is collected than being created):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/34a5a920-3ea6-4e32-bab8-ab8fb0c6fc57.png)'
  prefs: []
  type: TYPE_IMG
- en: Well, that was an extreme edge case, right? It's way more theoretical than practical—why
    would anyone have two nested `setInterval()` methods with closures. Let's take
    a look at another example in which we no longer nest multiple `setInterval()`,
    but it is driven by the same logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assume that we have a method that creates closures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'A simple fix to solve this problem is obvious, as we have said ourselves that
    the previous value of the object `something` doesn''t get garbage collected as
    it refers to the `previousValue` from the previous iteration. So, the solution
    to this would be to clear out the value of the `previousValue` at the end of each
    iteration, thus leaving nothing for `something` to refer once it is unloaded,
    hence the memory profiling can be seen to change:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/8c92b433-689b-4d11-b436-c1c08ad66748.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding image changes as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/603b37ed-b4ce-4155-9da2-be22cc8452a9.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored ways in which the code performance can be improved
    by making optimizations to HTML, CSS, and JavaScript that we write for our applications.
    It is very important to understand that these are something that may, or may not,
    benefit you, based on the application that you are trying to build. The main takeaway
    from this chapter should be the ability to open up the browser's insides and not
    be scared to dissect and take a look at how the browsers handle our code. Also,
    be wary that the ECMA specification guide keeps changing, but it takes time for
    the browsers to catch up with the changes. Also, last but not the least, never
    over-optimize or optimize too early. If you run into issues, then measure first
    and then decide what the bottlenecks are before coming up with a plan for optimization.
  prefs: []
  type: TYPE_NORMAL
- en: What's next?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With this, we conclude the book. We hope that you had a great learning experience
    and that you benefit from these techniques on a day-to-day basis. JavaScript,
    being the way it is, is ever growing. Things are changing at a rapid pace, and
    it gets tough to keep track of things. Here are some suggestions, which you can
    explore and modify as you try them out:'
  prefs: []
  type: TYPE_NORMAL
- en: Identify your area of interests. By now, you know that JavaScript exists (and
    rocks) in a lot of things beyond the browser. Are you more of a UI person? Do
    you love APIs and scalable microservice? Do you dig building sensors which count
    how many coffees you consume every day? Find your passion and apply your newly
    learned JavaScript concepts there. The concepts are same, the applications are
    different.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Subscribe to newsletters and mailing lists from areas of interests. You will
    be amazed by the amount of information you get from each of these emails on a
    daily or weekly basis. It helps you to keep on your toes, and you can stay up
    to date on the latest technologies.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a blog (or even a StackOverflow answer) for what you know and learn. It
    always helps when you write down what you learn. Someday, you can even use that
    for your own reference.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
