- en: '*Chapter 3*: Getting Started with Danfo.js'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Python** data science and machine learning ecosystem is very mature when
    compared to other programming languages, but when it comes to data presentation
    and the client side, **JavaScript** reigns supreme. From its robust data presentation
    tools to its ready availability in the browser to ease of setup, JavaScript is
    always recommended.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will introduce you to the Danfo.js library, thus giving
    you an efficient tool for data analysis and manipulation in JavaScript. We'll
    cover the core data structures of Danfo.js â€“ DataFrames and Series. We'll show
    you how to load different types of files, such as JSON, Excel, and CSV, into Danfo.js,
    and finally, you'll learn about some important functions available in Danfo.js
    that make data analysis and preprocessing in JavaScript easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Why you need Danfo.js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing Danfo.js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing Series and DataFrames
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Essential functions and methods in Danfo.js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data loading and working with different file formats
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to follow along with this chapter, you should have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A modern browser such as Chrome, Safari, Opera, or Firefox
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Node.js**, Danfo.js, and **Dnotebook** installed on your system'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code for this chapter is available here: [https://github.com/PacktPublishing/Building-Data-Driven-Applications-with-Danfo.js/tree/main/Chapter03](https://github.com/PacktPublishing/Building-Data-Driven-Applications-with-Danfo.js/tree/main/Chapter03).'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'For most of the code snippets, you can make use of Dnotebook available online
    here: [https://playnotebook.jsdata.org/](https://playnotebook.jsdata.org/).'
  prefs: []
  type: TYPE_NORMAL
- en: Why you need Danfo.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To successfully bring a machine learning project written in Python to the web,
    there are a lot of processes and tasks to be carried out, things such as model
    deployment, creating API routes with frameworks such as **Flask**, **FastAPI**,
    or **Django**, and then using JavaScript to send HTTP requests to the model. You
    can clearly observe that the process involves a lot of JavaScript. It would be
    super awesome if we could perform all these processes in just JavaScript, wouldn't
    it? Well, the good news is that we can.
  prefs: []
  type: TYPE_NORMAL
- en: Over the past years, browsers have steadily increased in computational power
    and can support highly intensive computation, hence giving JavaScript the edge
    to challenge Python when it comes to data-intensive tasks.
  prefs: []
  type: TYPE_NORMAL
- en: With the help of Node.js, JavaScript has access to the GPU available on local
    computers, giving us the ability to undergo a full-stack machine learning project
    using Node.js for the backend and pure JavaScript for the frontend.
  prefs: []
  type: TYPE_NORMAL
- en: One of the benefits of using JavaScript is that inference can easily be done
    on the client side, hence data does not have to leave the client side to the server.
    Also, JavaScript gives our program cross-platform support and with the help of
    a **Content Delivery Network** (**CDN**), all the JavaScript packages needed for
    app development can easily be used without installing them.
  prefs: []
  type: TYPE_NORMAL
- en: With the introduction of tools such as **TensorFlow.js** and Danfo.js, we see
    more support for JavaScript in the data science and machine learning ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine a powerful data processing library such as **Python pandas** ([https://pandas.pydata.org/](https://pandas.pydata.org/))
    on the web, and think about the capability of infusing such a tool into popular
    modern frameworks in JavaScript such as **Vue** or **React**; the possibilities
    are endless. This is the power Danfo.js brings to the web.
  prefs: []
  type: TYPE_NORMAL
- en: There have been various attempts by JavaScript developers to bring the data
    processing capabilities of pandas to the web. Hence, we have libraries such as
    `pandas-js`, `dataframe-js`, `data-forge`, and `jsdataframe`.
  prefs: []
  type: TYPE_NORMAL
- en: The need to port Python pandas to JavaScript arose mainly because there was
    a need to perform data preprocessing and manipulation tasks in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a thread on **Stack Overflow** ([https://stackoverflow.com/questions/30610675/python-pandas-equivalent-in-JavaScript/43825646](https://stackoverflow.com/questions/30610675/python-pandas-equivalent-in-JavaScript/43825646))
    that gives a detailed overview of different tools for data preprocessing and manipulation
    in JavaScript, but most of these tools failed because of the following two reasons
    as explained in the thread:'
  prefs: []
  type: TYPE_NORMAL
- en: Lack of collaboration into a single library (lots of libraries trying to do
    different things)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Most of the libraries not having the main features of pandas, as shown: [https://github.com/pandas-dev/pandas#main-features](https://github.com/pandas-dev/pandas#main-features
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Besides the two reasons listed here, another issue we have observed when trying
    most of the existing tools is the lack of a good user experience like Python's
    pandas. pandas is very popular, and since most of the tools created in JavaScript
    mimic pandas, it is better to have a user experience that is quite similar to
    pandas.
  prefs: []
  type: TYPE_NORMAL
- en: Danfo.js was built to cover the gaps and issues faced by existing data processing
    libraries. The API has been carefully modeled after the pandas API, and as such
    provides a similar experience for people coming from a Python background, while
    at the same time providing a simple and intuitive API for JavaScript developers.
  prefs: []
  type: TYPE_NORMAL
- en: Besides a simple and familiar API, Danfo.js is faster thanks to TensorFlow.js,
    which powers all mathematical operations. Danfo.js has gained popularity in the
    JavaScript data science community with over 1,500 stars on GitHub in less than
    a year, as well as acceptance by the TensorFlow.js team at Google ([https://blog.tensorflow.org/2020/08/introducing-danfo-js-pandas-like-library-in-JavaScript.html](https://blog.tensorflow.org/2020/08/introducing-danfo-js-pandas-like-library-in-JavaScript.html)).
    Also, it is worth mentioning that Danfo.js is well maintained and under constant
    development thanks to active contributors, who ensure it is up to date and stable.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from the preceding reasons, there are many more reasons why we decided
    to write this book on Danfo.js so as to give you the required skills and knowledge
    to perform data manipulation tasks in JavaScript. In the next section, we will
    start by learning how to install and import Danfo.js both in the browser and also
    in a Node.js environment.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Danfo.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Danfo.js is readily available in both the browser and a Node.js environment.
    To use Danfo.js in the browser, you can add the `script` tag to the header of
    your `HTML` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: At the time of writing, the latest version of Danfo.js for a browser environment
    is 0.2.7\. This will most likely have changed, but rest assured that all code
    and snippets used in this book will work in future versions.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To install or get the latest version of Danfo.js, you can check the release
    page here, [https://danfo.jsdata.org/release-notes](https://danfo.jsdata.org/release-notes),
    in the official documentation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a Node.js environment, Danfo.js can be installed using `yarn`, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Once installed, you can import Danfo.js using any of the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: For practice, you can always make use of [https://playnotebook.jsdata.org/](https://playnotebook.jsdata.org/),
    as discussed in the previous chapter. With this, you have online access to make
    use of Dnotebook for fast experimentation. To make use of the latest version of
    Danfo.js in Dnotebook, you can always use the `load_package` function.
  prefs: []
  type: TYPE_NORMAL
- en: The browser and Node.js versions of Danfo.js follow the same API design. The
    major difference is that in the browser, Danfo.js is added to the global scope
    under the name `dfd`. Hence, the `dfd` variable is available to all JavaScript
    or HTML files.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we are done with the installation, we'll move on to the next section,
    where we discuss the major data structures and methods available in Danfo.js and
    Series.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Series and DataFrames
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Danfo.js exposes two main data structures, Series and DataFrames, to which all
    data manipulation can be done easily. DataFrames and Series provide a general
    representation for different types of data, hence the same data handling process
    can be applied to datasets with different formats.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will look at different means of creating Series and DataFrames.
    We will see how to handle data in DataFrame and Series format. We will also look
    into different DataFrame and Series methods for data handling.
  prefs: []
  type: TYPE_NORMAL
- en: We will start this section by looking at how to handle data in a Series data
    structure.
  prefs: []
  type: TYPE_NORMAL
- en: Series
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A Series provides an entry point to handling one-dimensional data, such as a
    single array with a sequence of values of the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will get familiar with Series data structures with the
    following Series methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code gives us the following output table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 â€“ Series table'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_3_1.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.1 â€“ Series table
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding code snippet, we make use of `table()` to print the Series
    table. This is because we are making use of Dnotebook for most of the code in
    this chapter. To print DataFrames or Series in a browser or Node.js console, you
    can always call `print()` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In subsequent code, we will always make use of the `table()` function, which
    allows us to print the DataFrame on the browser web page.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `.index` attribute: By default, the column name for a Series table is always
    0 unless it is specified. Also note that the index of a Series table ranges from
    `0` to `n â€“ 1` of the data, where `n` is the length of the data. The index can
    also be obtained via the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '`.dtype` and `astype()`: Sometimes the data passed into a Series might not
    be homogeneous, and may contain fields with mixed data types, as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '`dtype` outputted `string`, whereas the data is of a different data type, hence
    we can always change `dtype` as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code changes the data type of the Series, but it does not actually
    cast the strings in the data to `int32`. Hence, this will throw an error if we
    perform a numerical operation on the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `.tensor` attribute: The data in a Series can be obtained in two main formats
    â€“ as JavaScript `series.tensor` is a valid TensorFlow.js tensor, and as such all
    supported tensor operations can be performed on it. For example, in the following
    code, we call the exponential function on the Series `tensor` object:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we were able to print out the exponential of the Series
    data because we had access to the underlying tensor. The `arraySync` method returns
    the array format of a tensor. Let's look at the `set_index()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `set_index()` method: The index can be specified when creating a Series
    data structure. We demonstrate this in the following code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This sets the index of the Series and replaces the default numerical index
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 â€“ Series with a named index'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_3_2.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.2 â€“ Series with a named index
  prefs: []
  type: TYPE_NORMAL
- en: 'We can always change the default index value of a Series, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '`sdata.set_index()` resets the index and returns a new Series as shown in *Figure
    3.2* (*left*), without mutating the original Series. We can set `set_index()`
    to actually update the index of the original Series and not return a new Series,
    by setting the `inplace` key to `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We will now look at the `.apply()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `.apply()` method: Since a Series is a single-dimensional array, it is
    easy to apply operations similar to how it would be done if working with an array
    in JavaScript. Series have a method called `.apply` to which you can apply any
    function on each value of the Series data:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This converts each of the strings in the Series to uppercase by applying `x.toLocaleUpperCase()`
    on each of the values. The following figure shows the table output before and
    after applying `x.toLocaleUpperCase` on the Series data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3 â€“ Left: setting the index to string. Right: using apply to convert
    all strings to uppercase'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_3_3.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.3 â€“ Left: setting the index to string. Right: using apply to convert
    all strings to uppercase'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `.apply` method is also handy for performing numerical operations on each
    value of the Series data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We used the `.apply` function to find the log of each value in the Series. The
    same can also be done for all other mathematical operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding code outputs the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4 â€“ Applying math ops (Math.log) to each value of a Series'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_3_4.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.4 â€“ Applying math ops (Math.log) to each value of a Series
  prefs: []
  type: TYPE_NORMAL
- en: 'The Series data structure also contains the `.map` method, similar to `.apply`.
    This method maps each value of the Series to another value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The map accepts objects and functions as parameters. In the preceding code,
    we created an object called `map` that contains the values in the Series as keys
    and the values that each key should be mapped to.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding code outputs the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.5 â€“ Using map on Series values'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_3_5.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.5 â€“ Using map on Series values
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will look at the `.isna()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `.isna()` method: The data we''ve been passing into the Series so far seems
    to be okay and contains no missing values or undefined values, but when working
    with real data, we will always have `NaN` or undefined values. We can always check
    whether such values exist in our Series:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'As a test, we create a Series containing `NaN` and an undefined variable. We
    obtain the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.6 â€“ Table containing a Series frame with NaN values'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_3_6.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.6 â€“ Table containing a Series frame with NaN values
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s check the rows containing `NaN` and undefined values; for each of these
    rows, we output `true`, and if not, they are represented with `false` as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We obtain the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.7 â€“ The isna table for the Series data'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_3_7.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.7 â€“ The isna table for the Series data
  prefs: []
  type: TYPE_NORMAL
- en: The `.add()` method is as follows.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `.add()` method: The Series data structure also supports element-wise operations
    (such as addition, subtraction, multiplication, and division) between Series,
    and after this operation, the indexes are automatically aligned:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We have the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.8 â€“ Adding two Series'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_3_8.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.8 â€“ Adding two Series
  prefs: []
  type: TYPE_NORMAL
- en: The preceding code snippet adds the `sf2` Series to `sf1`, and each of the values
    is added element-wise, per row.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note also that a single value can be passed to `sf1.add`, which will add a
    constant value to each of the elements in the `sf1` Series:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.9 â€“ Adding a constant value to Series elements'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_3_9.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.9 â€“ Adding a constant value to Series elements
  prefs: []
  type: TYPE_NORMAL
- en: The operation shown previously applies for all other mathematical operations
    as well as Series.
  prefs: []
  type: TYPE_NORMAL
- en: In the next sub-section, we'll look into the operation of DataFrames, how to
    create a DataFrame, and how to handle data with DataFrame operations.
  prefs: []
  type: TYPE_NORMAL
- en: DataFrames
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A DataFrame represents a collection of Series, although unlike Series, it is
    basically a two-dimensional representation of data (although it can also represent
    higher dimensions) containing multiple columns and rows.
  prefs: []
  type: TYPE_NORMAL
- en: 'A DataFrame can basically be constructed using JavaScript objects, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting DataFrame should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.10 â€“ DataFrame table'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_3_10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.10 â€“ DataFrame table
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding code, JavaScript object data is created containing keys and
    values. Note the following about the JavaScript object:'
  prefs: []
  type: TYPE_NORMAL
- en: Each key contains a list value representing data per column.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each key represents the column and the column name.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each key must have the same length of list values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following are common methods for handling DataFrame data structures:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `head()` and `tail()` methods: Sometimes, while working on a big dataset,
    you might need to see the first set of rows (maybe the first 5 rows or the first
    30 rows, as much as you like) and also the last rows in the data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Since our DataFrame contains five rows, let''s print the first two rows of
    the table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `head()` method by default prints out the first five rows of a DataFrame,
    but we can specify `2` since our data is small.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table shows the result of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.11 â€“ Table for df.head(2)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_3_11.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.11 â€“ Table for df.head(2)
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, to see the last set of rows in the DataFrame, we make use of the `tail()`
    method. By default, the `tail` method prints out the last five rows in the DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The `tail` function takes in a value that specifies the number of rows to print
    from the end of the DataFrame table, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.12 â€“ Printing the last two rows'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_3_12.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.12 â€“ Printing the last two rows
  prefs: []
  type: TYPE_NORMAL
- en: '`data` variable contains the data, which is represented as an array of an array.
    Each array in the data array contains values arranged row-wise as it will be represented
    in the DataFrame table; `[Drake, 5, $1m]` represents a row in the DataFrame, while
    each value (`Drake`, `5`, `$1m`) represents different columns. `Drake` belongs
    to the `artist` column and `$1m` belongs to the `dollar` column, as shown in the
    following figure:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 3.13 â€“ DataFrame table'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_3_13.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.13 â€“ DataFrame table
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall that we said a DataFrame is a collection of Series, hence it is possible
    to access each of these Series from the DataFrame like the way we access JavaScript
    object elements. Here is how to do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that `artist` is the name of a column in the DataFrame, hence if we were
    to think of a DataFrame as an object, `artist` is the key and the value of the
    key is a Series. The preceding code should output the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.14 â€“ Column Series'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_3_14.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.14 â€“ Column Series
  prefs: []
  type: TYPE_NORMAL
- en: 'The `artist` column can also be accessed via `df[''artist'']`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This method also outputs the same result as the initial `df.dollar` method
    being used:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.15 â€“ Accessing column values'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_3_15.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.15 â€“ Accessing column values
  prefs: []
  type: TYPE_NORMAL
- en: 'Apart from accessing column values via an object-like method, we can also change
    the column data as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'If we were to print out `df.dollar`, we would obtain the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.16 â€“ Changing the column value'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_3_16.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.16 â€“ Changing the column value
  prefs: []
  type: TYPE_NORMAL
- en: 'The changing of column data can also be done by creating a Series frame and
    then assigning it to a column in the DataFrame, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code changes the value of the column rating and outputs the following
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.17 â€“ Changing column data with a Series value'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_3_17.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.17 â€“ Changing column data with a Series value
  prefs: []
  type: TYPE_NORMAL
- en: This method of using Series data to update column data comes in handy when working
    on a time-related column. We might need to extract hours or months in a date column
    and replace the column with the extracted information (hours or months).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add a date column to the DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We make use of the `addColumn` method to add a new column to the DataFrame.
    The `addColumn` method accepts an object argument that must contain the following
    keys:'
  prefs: []
  type: TYPE_NORMAL
- en: a) The name of the `column` to add
  prefs: []
  type: TYPE_NORMAL
- en: b) The new `value` for the column
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding code should output the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.18 â€“ Adding a new column'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_3_18.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.18 â€“ Adding a new column
  prefs: []
  type: TYPE_NORMAL
- en: 'The new column created is a date-time column, hence we can convert this column
    to a time series data structure and then extract the month name for each data
    point in the column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We extract the date column and assign it to a `date_series` variable. From `date_series`
    (which is actually a Series data structure), we extract the month name for each
    value. A Series data structure contains the `dt` method, which converts the Series
    structure to a time series structure and then extracts the month name using the
    `month_name()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding code outputs the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.19 â€“ Extracting the month name'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_3_19.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.19 â€“ Extracting the month name
  prefs: []
  type: TYPE_NORMAL
- en: The next methods that we will look into are `.values` and `.tensor`.
  prefs: []
  type: TYPE_NORMAL
- en: '`.values` and `.tensor`: The DataFrame values, that is, each column value,
    can be obtained as a giant array using `df.values`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Sometimes, we might want to obtain the DataFrame as a tensor for machine learning
    operations, hence the following shows how to obtain a DataFrame as tensor values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The `tensor` attribute returned a TensorFlow.js tensor data structure. Since
    a tensor must always contain a unique data type, all the data points in our DataFrame
    are converted to a `dtype` string.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `.transpose()` method: Since we made the claim that a DataFrame is a two-dimensional
    representation of data, we should be able to transpose the DataFrame:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '`df.transpose()` moves the column list as an index and the index as a column,
    as shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.20 â€“ Transposing a DataFrame'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_3_20.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.20 â€“ Transposing a DataFrame
  prefs: []
  type: TYPE_NORMAL
- en: 'We can obtain the index of the DataFrame and see whether the column is now
    the current index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is the index of the transposed DataFrame. In the preceding
    examples, the index has always been a numerical value, but with this, it shows
    that the index can also be a string.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `.set_index()` method: Using the DataFrame itself, before transposing it,
    let''s change the index of the DataFrame from integers to a string index:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Using the `set_index` method in the DataFrame sets the index with the given
    key values. `set_index` also accepts the `inplace` key (the `inplace` key is a
    Boolean key it receives either `true` or `false` as a value, but the default value
    is `false`) key to specify whether the DataFrame should be updated or a new DataFrame
    containing the update should be returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table shows the result of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.21 â€“ Setting the index of the DataFrame'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_3_21.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.21 â€“ Setting the index of the DataFrame
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the index can be anything, we can also set the index of the DataFrame
    to be one of the columns in the DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This time around, `set_index` takes in a value instead of an array of proposed
    index values. If a single value is passed as a key index, `set_index` believes
    it should be available as a column in the DataFrame.
  prefs: []
  type: TYPE_NORMAL
- en: The values in the `artist` column are used to replace the default index. Also
    note that the default value of `inplace` is `false`, hence a new DataFrame is
    created and returned with the updated index.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following shows the output of the DataFrame created:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.22 â€“ Setting the index to the artist column'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_3_22.png)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.22 â€“ Setting the index to the artist column
  prefs: []
  type: TYPE_NORMAL
- en: By now, you should be aware of how to create a Series and DataFrame and how
    to make use of their respective methods for data processing.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we look into some essential functions and methods in Danfo.js
    that will commonly be used for data analysis and processing.
  prefs: []
  type: TYPE_NORMAL
- en: Essential functions and methods in Danfo.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will look at some important functions and methods in relation
    to Series and DataFrames. The methods in each of the data structures are a lot
    and we can always visit the documentation for more methods. This section will
    only mention some of the most commonly used methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`loc` and `iloc` indexing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Sorting: the `sort_values` and `sort_index` methods'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Filter`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arithmetic operations such as `add`, `sub`, `div`, `mul`, and `cumsum`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: loc and iloc indexing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Accessing DataFrame rows and columns is made easier with the `loc` and `iloc`
    methods; both methods allow you to specify the rows and columns you would like
    to access. For those of you coming from Python' pandas library, the `loc` and
    `iloc` format as implemented in Danfo.js should be familiar.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `loc` method is used to access a DataFrame with an index that is not numeric,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Making use of the last updated DataFrame from the previous section, we used
    the `loc` method to obtain a certain row index from the DataFrame. This index
    value is specified in the `rows` key element:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.23 â€“ Accessing specific row index values'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_3_23.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.23 â€“ Accessing specific row index values
  prefs: []
  type: TYPE_NORMAL
- en: Also, the `loc` and `iloc` methods give us the ability to slice an array. This
    should be familiar to Python users. Don't worry if you don't know what it is;
    the following examples will show what it means and how it is done.
  prefs: []
  type: TYPE_NORMAL
- en: 'To obtain a range of indexes, we can specify the upper and lower bounds even
    for a non-numerical index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The `loc` method is used whenever the column name and index of a DataFrame is
    a string. For the preceding code, we specify that we want to extract data values
    between the `Rihanna` row index and the `Bellion` row index.
  prefs: []
  type: TYPE_NORMAL
- en: 'This colon helps specify the range boundary. The following table shows the
    output of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.24 â€“ String indexing'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_3_24.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.24 â€“ String indexing
  prefs: []
  type: TYPE_NORMAL
- en: 'Apart from indexing the rows, we can also extract a specific column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: A `columns` key is passed into `loc` to extract the column called `rating`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table shows the result of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.25 â€“ Column and row indexing'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_3_25.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.25 â€“ Column and row indexing
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also specify the range for the indexing column, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'This should return a table similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.26 â€“ Column range'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_3_26.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.26 â€“ Column range
  prefs: []
  type: TYPE_NORMAL
- en: From the preceding table, we can see the range is quite different from the row
    indexing; the column indexing does exclude the upper bound.
  prefs: []
  type: TYPE_NORMAL
- en: The `loc` method in a DataFrame uses characters to index both the row data and
    the column data. `iloc` does the same but makes use of integers for indexing rows
    and columns.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the initial DataFrame as shown in the following table, we are going to
    perform indexing using the `iloc` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.27 â€“ The artist table'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_3_27.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.27 â€“ The artist table
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use `iloc` to access index `2` to `4` of the table shown in *Figure
    3.27*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The `iloc` method accepts the same keywords as the `loc` method: the `rows`
    and `columns` keywords. The numbers are wrapped in a string because we want to
    perform `loc` method.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table shows the result of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.28 â€“ Indexing table rows from 2 to 4 using a closed upper bound'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_3_28.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.28 â€“ Indexing table rows from 2 to 4 using a closed upper bound
  prefs: []
  type: TYPE_NORMAL
- en: Slicing arrays (fancy indexing)
  prefs: []
  type: TYPE_NORMAL
- en: Slicing arrays will be familiar to those coming from Python. In Python, it is
    possible to index an array using a range of values, for example, `test = [1,2,3,4,5,6,7]
    test [2:5] => [3,4,5]`. JavaScript does not have this property, hence Danfo.js
    does this by passing the range as a string, and from the string, the upper and
    lower bounds are extracted.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same slicing operation as done in the previous example for rows can also
    be done on columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '`df.iloc({columns:[''1:'']})` is used to extract the column starting from index
    1 (which represents the `rating` column) up to the last column. For integer indexing,
    whenever the upper bound is not specified, it picks the last column as the upper
    bound.'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we talked about indexing and different methods of indexing
    a DataFrame. In the next section, we will be talking about sorting a DataFrame
    by column value and row index.
  prefs: []
  type: TYPE_NORMAL
- en: Sorting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Danfo.js supports two methods for sorting data â€“ in terms of index or by a column
    value. Also, Series data can only be sorted by index, because it is a DataFrame
    object with a single column. DataFrames have a method called `sort_values` that
    enables you to sort data by a specific column, hence by sorting a particular column,
    we are sorting all other columns with respect to this column.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a DataFrame containing numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'This outputs the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.29 â€“ DataFrame of numbers'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_3_29.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.29 â€“ DataFrame of numbers
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s sort the DataFrame by the values in column `B`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The `sort_values` method takes in the following keyword arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '`by`: The name of the column used to sort the DataFrame.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`inplace`: Whether the original DataFrame should be updated or not (`true`
    or `false`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ascending`: Whether the column should be sorted in ascending order or not.
    The default value is always `false`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the preceding code snippet, we specify to sort the DataFrame by column `C`
    and also set `inplace` to `true`, hence the DataFrame is updated and the column
    is also sorted in descending order. The following table shows the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.30 â€“ DataFrame sorted by column values'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_3_30.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.30 â€“ DataFrame sorted by column values
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes we might not want to update the original DataFrame itself. Here lies
    the influence of the `inplace` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, the DataFrame was sorted by a column. Let''s try to
    sort the same DataFrame by its index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '`sort_index` also accepts keyword arguments: `ascending` and `inplace`. We
    set the `ascending` keyword to be `true`, which should give us the DataFrame with
    its index set in ascending order.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following output is obtained:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.31 â€“ Sorted index DataFrame'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_3_31.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.31 â€“ Sorted index DataFrame
  prefs: []
  type: TYPE_NORMAL
- en: 'Sorting in a Series requires quite a simple approach; sorting is done by calling
    the `sort_values` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The `sort_values` method also accepts keyword arguments, `ascending` and `inplace`.
    By default, `ascending` is set to `true` and `inplace` is set to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table shows the result of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.32 â€“ Sorting a Series by value'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_3_32.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.32 â€“ Sorting a Series by value
  prefs: []
  type: TYPE_NORMAL
- en: Note the `sort_values` and `sort_index` methods also work for columns and indexes
    containing strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using our `artist` DataFrame, let''s try sorting a column with a string as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The DataFrame is sorted using the `artist` column in descending order. This
    results in a table with `Rihanna` in the first row followed by `Passenger`, based
    on the first character:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.33 â€“ Sorting by the string column'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_3_33.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.33 â€“ Sorting by the string column
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we saw how to sort a DataFrame by column values and row index.
    In the next section, we will see how we can filter DataFrame values.
  prefs: []
  type: TYPE_NORMAL
- en: Filtering
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Filtering out rows of a DataFrame based on some particular values in a column
    comes in handy most of the time during data manipulation and processing. Danfo.js
    has a method called `query` that is used to filter rows based on the value in
    a column.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `query` method takes in the following keyword arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '`column`: The column name'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`is`: Specifies the logical operator to use (`>, <, >=, <=, ==`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`to`: The value used to filter the DataFrame'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`inplace`: Updates the original DataFrame or returns a new one'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here is an example of how the `query` method works.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we create a DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The following figure shows the table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.34 â€“ DataFrame'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_3_34.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.34 â€“ DataFrame
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s sort the DataFrame by a value in column `B`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we filter column `B` by a value greater than 5\. This will result in
    returning rows containing a value greater than 5 in column `B`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.35 â€“ Filtered by a value greater than 5 in column B'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_3_35.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.35 â€“ Filtered by a value greater than 5 in column B
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s filter the DataFrame by checking whether the values in column `C` equal
    to `20`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'With this, we obtain the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.36 â€“ Filtered by values equal to 20 in column C'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_3_36.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.36 â€“ Filtered by values equal to 20 in column C
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we saw how to filter a DataFrame by column values. In the next
    section, we will see how to perform different arithmetic operations.
  prefs: []
  type: TYPE_NORMAL
- en: Arithmetic operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this sub-section, we will look into different arithmetic operations and how
    to use them to preprocess our data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Arithmetic operations such as addition, subtraction, multiplication, and division
    can be done between the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A DataFrame and a Series
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A DataFrame and an array
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A DataFrame and a `scalar` value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We start by performing an arithmetic operation between DataFrame and `scalar`
    values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The `add` method is used to add a `scalar` variable of `20` across each row
    of the DataFrame. The `add` method takes in two arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '`other`: This represents either a DataFrame, Series, array, or `scalar`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`axis`: Specifies whether the operation should be applied by row or by column.
    The row axis is represented with `0` and the column by `1`. The default is `0`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For the `scalar` operation, we obtain the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.37 â€“ Left: original DataFrame. Right: DataFrame after doing scalar
    addition'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_3_37.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.37 â€“ Left: original DataFrame. Right: DataFrame after doing scalar
    addition'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a Series and pass it to the `add` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: A Series is created containing two-row elements. This two-row element equals
    the number of columns in the `ar_df` DataFrame, which means that the first row
    value of `add_series` belongs to the first column of `ar_df`, just as the second
    row value corresponds to the second column of `ar_df`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The explanation in the preceding paragraph means that `20` will be used to
    multiply `Col1` and `30` will be used to multiply `Col2`. For this to occur, we
    specify the axis to be `1`, which tells the add operation to perform the operation
    column-wise, as we can see in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.38 â€“ Add operation between the DataFrame and Series'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_3_38.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.38 â€“ Add operation between the DataFrame and Series
  prefs: []
  type: TYPE_NORMAL
- en: The addition operation between a DataFrame and a Series is the same between
    a DataFrame and a normal JavaScript array, since a Series is just a JavaScript
    array with some extended functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look into the operation between two DataFrames:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: First, we create two sets of DataFrames and then add them together; but we must
    ensure the two DataFrames have the same number of columns and rows. Also, this
    operation is done row-wise.
  prefs: []
  type: TYPE_NORMAL
- en: The operation does not actually care whether the two DataFrames have the same
    column name or not, but the resulting column name is the column of the DataFrame
    we are adding to the former DataFrame.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table shows the result of the DataFrames created in the preceding
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.39 â€“ From left to right: tables for DataFrames df and df2 and addition
    between df and df2'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_3_39.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.39 â€“ From left to right: tables for DataFrames df and df2 and addition
    between df and df2'
  prefs: []
  type: TYPE_NORMAL
- en: The example done with the add operation is the same for the `sub()`, `mul()`,
    `div()`, `pow()`, and `mod()` methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, for both DataFrames and Series there is a set of mathematical operations
    called cumulative, which comprises the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Cumulative sum: `cumsum()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Cumulative min: `cummin()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Cumulative max: `cummax()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Cumulative product: `cumprod()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Each of these operations is the same in terms of the argument being passed
    in. They all accept the axis in which the operation is to be performed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: We create a DataFrame by specifying its data and columns, and we then perform
    a cumulative sum along the `0` axis.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table shows the result of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.40 â€“ Left: the DataFrame before cumsum(). Right: the DataFrame after
    cumsum()'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_3_40.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.40 â€“ Left: the DataFrame before cumsum(). Right: the DataFrame after
    cumsum()'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s perform a `cumsum` operation along axis `1` of the DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives us the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.41 â€“ cumsum along axis 1'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_3_41.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.41 â€“ cumsum along axis 1
  prefs: []
  type: TYPE_NORMAL
- en: 'The same cumulative operations can also be applied to Series. Let''s apply
    the same cumulative sum to Series data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '`cumsum` in a Series does not take in any argument. With the preceding operation,
    we have as the output, the following table *Figure 3.42* that is the original
    Series before applying the cumulative Series.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table shows the result of the `series.cumsum()` operation in
    the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.42 â€“ The cumulative sum Series'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_3_42.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.42 â€“ The cumulative sum Series
  prefs: []
  type: TYPE_NORMAL
- en: All other cumulative operations, such as `cumprod`, `cummin`, and `cummax`,
    are used in the same way as the `cumsum()` operation as shown in the preceding
    `cumsum` examples.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we looked into different arithmetic operations and how to make
    use of these operations to preprocess data. In the next section, we will dive
    into logical operations such as how to perform logical operations between a DataFrame
    and Series, array, and `Scalar` values.
  prefs: []
  type: TYPE_NORMAL
- en: Logical operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will see how we can perform logical operations, such as
    comparing the values between a DataFrame and Series, array, and scalar values.
  prefs: []
  type: TYPE_NORMAL
- en: 'The way logical operations are called and used is quite similar to how arithmetic
    operations work. A logical operation can be done between the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A DataFrame and a Series
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A DataFrame and an array
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A DataFrame and a scalar value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following logical operations are implemented:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Equal to (`==`): `.eq()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Greater than (`>`): `gt()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Less than (`<`): `lt()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Not equal to (`!=`): `ne()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Less than or equal to (`<=`): `le()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Greater than or equal to (`>=`): `ge()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All these methods take in the same argument, which are `other` and `axis`.
    Using the `lt()` method, let''s see how they work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The code checks whether each of the values in the DataFrame is less than 20\.
    The result can be seen in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.43 â€“ Left: DataFrame for df. Right: DataFrame for df_rep'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_3_43.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.43 â€“ Left: DataFrame for df. Right: DataFrame for df_rep'
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, the same operation can be done with a DataFrame and Series, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The `series` operation with the DataFrame is done column-wise. The following
    table is the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.44 â€“ Logical operation between a DataFrame and Series'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_3_44.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.44 â€“ Logical operation between a DataFrame and Series
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s perform a logical operation between two DataFrames, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The code outputs the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.45 â€“ Logical operation between DataFrames'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_3_45.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.45 â€“ Logical operation between DataFrames
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we looked into some essential DataFrame operations, such as
    how to filter a DataFrame by column value. We also saw how to sort a DataFrame
    by column value and row index. Also, this section dived into the indexing of DataFrames
    with `loc` and `iloc`, and finally, we looked into arithmetic and logical operations.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will dive into working with different data formats,
    how to parse these files into Danfo.js, and converting them into a DataFrame or
    Series.
  prefs: []
  type: TYPE_NORMAL
- en: Data loading and working with different file formats
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will look at how to work with different file formats. Danfo.js
    provides a method for working with three different file formats: CSV, Excel, and
    JSON. Data presented in these formats can easily be read and presented as a DataFrame.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the methods needed for each of the file formats:'
  prefs: []
  type: TYPE_NORMAL
- en: '`read_csv()`: To read CSV files'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`read_json()`: To read JSON files'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`read_excel()`: To read Excel files presented as `.xslx`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of these methods can read data locally and from the internet. Also, these
    methods only have access to the local files in a `Node.js` environment. On the
    web, these methods can read provided files (CSV, JSON, and .`xslx` files) provided
    these files are available on the internet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how to read local files in the Node.js environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: First, we import the Node.js version of Danfo.js and then make a call to `read_csv()`
    to read the `titanic.csv` files available in the same directory. Note that if
    the file to be read is not in the same directory, you will need to specify the
    path.
  prefs: []
  type: TYPE_NORMAL
- en: '`df.head().print()` prints the first five rows of the DataFrame table in the
    Node.js console; the `print()` function is similar to the `table()` function we''ve
    been using in Dnotebook. We obtain the following table from the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.46 â€“ DataFrame table read from a CSV file'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_3_46.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.46 â€“ DataFrame table read from a CSV file
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, the same thing can be done on the web, but we will be using the
    `http` link, which makes the same data available online:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives the same result as the previous code block. The same thing applies
    to all other file format methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The `read_excel()` method accepts an optional config argument that ensures
    the Excel files are properly parsed:'
  prefs: []
  type: TYPE_NORMAL
- en: '`source`: String, URL, or local file path to retrieve an Excel file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sheet_name` (optional): The name of the sheet you want to parse. The default
    is the first sheet.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`header_index` (optional): int, index of the row that represents the header
    column.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`data_index` (optional): int, index of the row that indicates where the data
    begins.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the preceding code block, we specify the `header_index` value to be `7`
    since that''s where the header columns are located, hence we have the following
    result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.47 â€“ DataFrame table read from an Excel file'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_3_47.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.47 â€“ DataFrame table read from an Excel file
  prefs: []
  type: TYPE_NORMAL
- en: 'The `read_json()` method is quite similar to `read_csv()` in terms of the argument
    being passed in; the method only accepts a URL to the JSON file or a directory
    path to where the JSON file is located:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'This reads a file called `book.json` from the same directory and outputs the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.48 â€“ DataFrame read from a JSON file'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_3_48.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.48 â€“ DataFrame read from a JSON file
  prefs: []
  type: TYPE_NORMAL
- en: Also, Danfo.js contains an ultimate tabular file reader method called `reader`;
    this method can read both CSV and Excel. It can also read other files such as
    `Datapackage` as specified in the Frictionless specs at [https://frictionlessdata.io/](https://frictionlessdata.io/).
  prefs: []
  type: TYPE_NORMAL
- en: The `reader` method makes use of a package called `Frictionless.js` at [https://github.com/frictionlessdata/frictionless-js](https://github.com/frictionlessdata/frictionless-js)
    to read local or remote files.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `reader` method has the same API design as `read_csv` and `read_excel`,
    just that it can read both file types, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: From the preceding code, we output the same table as shown in *Figure 3.48*.
  prefs: []
  type: TYPE_NORMAL
- en: Transforming a DataFrame into another file format
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After a series of data processing, we might want to transform our final DataFrame
    into a file format for proper saving. Danfo.js implements a method to transform
    a DataFrame into CSV format.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s convert the DataFrame we''ve created so far into a CSV file. Note that
    this will only work in a Node.js environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: This (`df.to_csv()`) saves the DataFrame in a CSV file in the path directory
    specified and with the name given to it (`path.csv`).
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we looked into reading files in different formats, such as
    CSV, JSON, and Excel, as available in Danfo.js. We looked into different methods
    of reading these files and we also looked into a more generic method for reading
    these file formats.
  prefs: []
  type: TYPE_NORMAL
- en: We also saw how to convert a DataFrame into the file format specified by the
    user.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we went through why Danfo.js is needed, then looked into what
    Series and DataFrames actually are. We also discussed some of the essential functionality
    available in Danfo.js and implemented it in DataFrames and Series.
  prefs: []
  type: TYPE_NORMAL
- en: We also saw how we can use DataFrames and Series methods to handle and preprocess
    data. We saw how to filter a DataFrame based on column values. We also sorted
    a DataFrame by row index and column values. This chapter equips us to perform
    day-to-day data operations such as reading files in different formats, converting
    formats, and saving DataFrames after preprocessing into a desirable file format.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look into data analysis, wrangling, and transformation.
    We will discuss data handling and preprocessing further and see how to handle
    missing numbers and how to deal with string and time series data.
  prefs: []
  type: TYPE_NORMAL
