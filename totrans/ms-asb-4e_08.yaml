- en: '*Chapter 6*: Unlocking the Power of Jinja2 Templates'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Manipulating configuration files by hand is a tedious and error-prone task.
    Equally, performing pattern matching to make changes to existing files is risky,
    and ensuring that the patterns are reliable and accurate can be time-consuming.
    Whether you are using Ansible to define configuration file content, perform variable
    substitution in tasks, evaluate conditional statements, or beyond, templating
    comes into play with nearly every Ansible playbook. In fact, given the importance
    of this task, it could be said that templating is the lifeblood of Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: 'The templating engine employed by Ansible is Jinja2, which is a modern and
    designer-friendly templating language for Python. Jinja2 deserves its own book;
    however, in this chapter, we will cover some of the more common usage patterns
    of Jinja2 templating in Ansible to demonstrate the power it can bring to your
    playbooks. In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Control structures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data manipulation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparing values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To follow the examples presented in this chapter, you will need a Linux machine
    running Ansible 4.3 or newer. Almost any flavor of Linux should do; for those
    interested in specifics, all the code presented in this chapter was tested on
    Ubuntu Server 20.04 LTS unless stated otherwise, and on Ansible 4.3\. The example
    code that accompanies this chapter can be downloaded from GitHub at [https://github.com/PacktPublishing/Mastering-Ansible-Fourth-Edition/tree/main/Chapter06](https://github.com/PacktPublishing/Mastering-Ansible-Fourth-Edition/tree/main/Chapter06).
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to view the Code in Action: [https://bit.ly/3lZHTM1](https://bit.ly/3lZHTM1)'
  prefs: []
  type: TYPE_NORMAL
- en: Control structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Jinja2, a control structure refers to the statements in a template that control
    the flow of the engine parsing the template. These structures include conditionals,
    loops, and macros. Within Jinja2 (assuming the defaults are in use), a control
    structure will appear inside blocks of `{% ... %}`. These opening and closing
    blocks alert the Jinja2 parser that a control statement has been provided instead
    of a normal string or variable name.
  prefs: []
  type: TYPE_NORMAL
- en: Conditionals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A conditional within a template creates a decision path. The engine will consider
    the conditional and choose from two or more potential blocks of code. There is
    always a minimum of two: a path if the conditional is met (evaluated as `true`),
    and either an explicitly defined `else` path if the conditional is not met (evaluated
    as `false`) or, alternatively, an implied `else` path consisting of an empty block.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The statement for a conditional is the `if` statement. This statement works
    in the same way as it does in Python. An `if` statement can be combined with one
    or more optional `elif` statements and an optional final `else`, and, unlike Python,
    it requires an explicit `endif`. The following example shows a config file template
    snippet that combines both regular variable replacement and an `if else` structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we check the `feature.enabled` variable to see whether it exists
    and that it has not been set to `False`. If this is `True`, then the `feature
    = True` text is used; otherwise, the `feature = False` text is used. Outside of
    this control block, the parser performs a normal variable substitution for the
    variables inside the curly braces. Multiple paths can be defined by using an `elif` statement,
    which presents the parser with another test to perform should the previous tests
    equate to `False`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate the rendering of the template and variable substitution, we''ll
    save the example template as `demo.j2`. Then, we''ll create a playbook, named `template-demo.yaml`, that
    defines the variables in use and then uses a `template` lookup as part of a `ansible.builtin.pause`
    task to display the rendered template on the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Executing this playbook will display the rendered template on the screen while
    waiting for the input. You can use the following command to execute it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Simply press *Enter* to run the playbook, as shown in *Figure 6.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1 – Rendering a simple template with conditionals using Ansible'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_06_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.1 – Rendering a simple template with conditionals using Ansible
  prefs: []
  type: TYPE_NORMAL
- en: 'Remembering the variable order of precedence for Ansible that we discussed
    in [*Chapter 1*](B17462_01_Final_JC_ePub.xhtml#_idTextAnchor015), *The* *System
    Architecture and Design of Ansible 3*, we can override the value of `feature.enabled`
    to `False`. We can do this by using the `--extra-vars` (or `-e`) parameter when
    running the playbook; this is because extra variables have higher priority than
    playbook-defined variables. You can achieve this by running the playbook again,
    but this time, using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In this instance, the output should be slightly different, as shown in *Figure
    6.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2 – Rendering a simple template with conditionals using Ansible
    while overriding a variable value'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_06_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.2 – Rendering a simple template with conditionals using Ansible while
    overriding a variable value
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from these simple tests, Jinja2 provides a very simple yet powerful
    way of defining data through conditionals in a template.
  prefs: []
  type: TYPE_NORMAL
- en: Inline conditionals
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Note that `if` statements can be used inside inline expressions. This can be
    useful in some scenarios where additional new lines are not desired. Let''s construct
    a scenario where we need to define an API as either `cinder` or `cinderv2`, as shown in
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This example assumes that `api.v2` is defined as Boolean `True` or `False`.
    Inline `if` expressions follow the syntax of `<do something> if <conditional is
    true> else <do something else>`. In an inline `if` expression, there is an implied `else`;
    however, that implied `else` is meant to be evaluated as an undefined object,
    which will normally create an error. We can protect against this by defining an
    explicit `else`, which renders a zero-length string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s modify our playbook to demonstrate an inline conditional. This time,
    we''ll use the `debug` module to render the simple template, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that, this time, we are not defining an external template file; the
    template is actually in line with the Ansible tasks. Execute the playbook using
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should look similar to the one shown in *Figure 6.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.3 – Running a playbook with an inline template'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_06_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.3 – Running a playbook with an inline template
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, just as we did in our earlier example, we''ll use Ansible''s extra variables
    to change the value of `api.v2` to `false` to see the effect this has on the rendering
    of the inline template. Execute the playbook again using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, the output should look similar to the one shown in *Figure 6.4*.
    Pay attention to how the rendered string has changed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.4 – Running a playbook with an inline template while changing the
    behavior with extra variables'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_06_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.4 – Running a playbook with an inline template while changing the behavior
    with extra variables
  prefs: []
  type: TYPE_NORMAL
- en: In this way, we can create very concise and powerful code that defines values based on
    an Ansible variable, just as we have demonstrated here.
  prefs: []
  type: TYPE_NORMAL
- en: Loops
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A loop allows you to build dynamically created sections in template files.
    It is useful when you know you need to operate on an unknown number of items in
    the same way. To start a loop control structure, we use the `for` statement. Let''s
    demonstrate a simple way to loop over a list of directories where a fictional
    service might find data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: By default, the `{% %}` blocks print an empty line when the template is rendered.
    This might not be desirable in our output, but luckily, we can trim this by ending
    the block with `-%}` instead. Please refer to the official Jinja2 documentation
    at [https://jinja.palletsprojects.com/en/3.0.x/templates/#whitespace-control](https://jinja.palletsprojects.com/en/3.0.x/templates/#whitespace-control) for
    more details.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we will get one `data_dir =` line per item within the `data_dirs` variable,
    assuming that `data_dirs` is a list with at least one item in it. If the variable
    is not a list (or another iterable type) or is not defined, an error will be generated.
    If the variable is an iterable type but is empty, then no lines will be generated.
    Jinja2 can handle this scenario and also allows substituting in a line when no
    items are found in the variable via an `else` statement. In the following example,
    let''s assume that `data_dirs` is an empty list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We can test this by modifying our playbook and template file again. We''ll
    create a template file called `demo-for.j2` with the template content listed earlier.
    Additionally, we will create a subtle variation on the playbook we used in our
    first example on conditionals to render the template and then pause for user input.
    The playbook file with the following code should be named `template-demo-for.yaml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have created these two files, you can then run the playbook using
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Running our playbook will render the template and produce an output that is
    similar to the one shown in *Figure 6.5*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.5 – Rendering a template with a for loop in Ansible'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_06_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.5 – Rendering a template with a for loop in Ansible
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the `else` statement in the `for` loop handled the empty `data_dirs` list
    gracefully, which is exactly what we want in a playbook run.
  prefs: []
  type: TYPE_NORMAL
- en: Filtering loop items
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Loops can be combined with conditionals, too. Within the loop structure, an `if` statement
    can be used to check a condition using the current loop item as part of the conditional.
    Let''s extend our example and prevent a user of this template from accidentally
    using `/` as a `data_dir` (any actions performed on the root directory of a filesystem
    can be dangerous, especially if they''re performed recursively):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding example successfully filters out any `data_dirs` item that is `/`,
    but it requires far more typing than should be necessary. Jinja2 provides a convenient
    way that allows you to filter loop items easily as part of the `for` statement.
    Let''s repeat the previous example using this convenience:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: So, not only does this structure require less typing, but it also correctly
    counts the loops, which we'll learn about in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Loop indexing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Loop counting is provided for free, yielding an index of the current iteration
    of the loop. As variables, they can be accessed in a few different ways. The following
    table outlines the ways they can be referenced:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/Table_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Having information related to the position inside the loop can help with the
    logic around what content to render. Considering our previous examples, rather
    than rendering multiple lines of `data_dir` to express each data directory, instead,
    we could provide a single line with comma-separated values. Without having access
    to loop iteration data, this would be difficult. However, by using this data,
    it can be straightforward. For the sake of simplicity, this example assumes a
    trailing comma after the last item is allowed, and that any white space (newlines)
    between items is also allowed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example made use of the `loop.first` variable to determine whether
    it needed to render the `data_dir =` part, or if it just needed to render the
    appropriately spaced padded directory. By using a filter in the `for` statement,
    we get a correct value for `loop.first`, even if the first item in `data_dirs` is
    an undesired `/`.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at the indentation on the first `else` statement – why did we do
    that? The answer is all to do with white space control in Jinja2 when it is rendered.
    Put simply, if you don't indent the control statement (for example, an `if` or
    `else` statement) that precedes the template content you wish to render, the template
    content will have all the white space to the left trimmed out; therefore, our
    subsequent directory entries would not be indented at all. Indentation is vitally
    important in some files (including YAML and Python!), and so, this is a small
    but vitally important nuance.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test this, we''ll create a new template file, named `demo-for.j2`, with
    the contents listed earlier. Additionally, we''ll modify `template-demo-for.yaml` to
    define some `data_dirs`, including one of the `/`, which should be filtered out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can execute the playbook using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'When it runs, we should see our rendered content, as shown in *Figure 6.6*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.6 – Rendering a template using a for loop in Ansible while making
    use of loop indexing'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_06_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.6 – Rendering a template using a for loop in Ansible while making use
    of loop indexing
  prefs: []
  type: TYPE_NORMAL
- en: 'If, in the preceding example, trailing commas were not allowed, we could utilize inline `if` statements
    to determine whether we''re done with the loop and render the commas correctly.
    You can view this in the following enhancement to the preceding template code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Using inline `if` statements allow us to construct a template that will only
    render a comma if there are more items in the loop that passed our initial filter.
    Once more, we''ll update `demo-for.j2` with the earlier content and execute the
    playbook using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the rendered template should look similar to the one shown in
    *Figure 6.7*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.7 – Rendering a template with a for loop in Ansible, making extended
    use of loop indexing'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_06_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.7 – Rendering a template with a for loop in Ansible, making extended
    use of loop indexing
  prefs: []
  type: TYPE_NORMAL
- en: The output is pretty much the same as before. However, this time, our template
    evaluates whether to place a comma after each value of `dir` in the loop using
    the inline `if` statement, removing the stray comma at the end of the final value.
  prefs: []
  type: TYPE_NORMAL
- en: Macros
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An astute reader will have noticed that, in the previous example, we had some
    repeated code. Repeating code is the enemy of any developer, and thankfully, Jinja2
    has a way to help! A macro is like a function in a regular programming language:
    it''s a way to define a reusable idiom. A macro is defined inside a `{% macro
    ... %} ... {% endmacro %}` block. It has a name and can take zero or more arguments.
    Code within a macro does not inherit the namespace of the block that is calling
    the macro, so all arguments must be explicitly passed in. Macros are called within
    curly brace blocks by name, and with zero or more arguments passed in via parentheses.
    Let''s create a simple macro named `comma` to take the place of our repeating
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Calling `comma` and passing it in the loop object allows the macro to examine
    the loop and decide whether a comma should be omitted or not.
  prefs: []
  type: TYPE_NORMAL
- en: Macro variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Macros have access to any positional or keyword argument passed along when
    calling the macro. Positional arguments are arguments that are assigned to variables
    based on the order they are provided, while keyword arguments are unordered and
    explicitly assign data to variable names. Keyword arguments can also have a default
    value if they aren''t defined when the macro is called. There are three additional
    special variables that are available:'
  prefs: []
  type: TYPE_NORMAL
- en: '`varargs`: This is a holding place for additional unexpected positional arguments
    that are passed along to the macro. These positional argument values will make
    up the `varargs` list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kwargs`: This is the same as `varargs`; however, instead of holding extra
    positional argument values, it will hold a hash of extra keyword arguments and
    their associated values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`caller`: This can be used to call back to a higher-level macro that might
    have called this macro (yes, macros can call other macros).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In addition to these three special variables, there are a number of variables
    that expose internal details regarding the macro itself. These are a bit complicated,
    but we''ll walk through their usage one by one. First, let''s take a look at a
    short description of each variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '`name`: This is the name of the macro itself.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`arguments`: This is a tuple of the names of the arguments that the macro accepts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`defaults`: This is a tuple of the default values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`catch_kwargs`: This is a Boolean that will be defined as `true` if the macro
    accesses (and, thus, accepts) the `kwargs` variable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`catch_varargs`: This is a Boolean that will be defined as `true` if the macro
    accesses (and, thus, accepts) the `varargs` variable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`caller`: This is a Boolean that will be defined as `true` if the macro accesses
    the `caller` variable (and, thus, could be called from another macro).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Similar to a class in Python, these variables need to be referenced via the
    name of the macro itself. Attempting to access these macros without prepending
    the name will result in undefined variables. Now, let's walk through and demonstrate
    the usage of each of them.
  prefs: []
  type: TYPE_NORMAL
- en: name
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `name` variable is actually very simple. It simply provides a way to access
    the name of the macro as a variable, perhaps for further manipulation or usage.
    The following template includes a macro that references the name of the macro
    to render it in the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s say we were to create `demo-macro.j2` with this template and the following `template-demo-macro.yaml` playbook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We will run this playbook using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run the playbook, your output should look similar to the one shown
    in *Figure 6.8*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.8 – Rendering a template employing the name macro variable'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_06_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.8 – Rendering a template employing the name macro variable
  prefs: []
  type: TYPE_NORMAL
- en: As you see from this test run, our template is simply rendered with the macro
    name and nothing else, just as expected.
  prefs: []
  type: TYPE_NORMAL
- en: arguments
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `arguments` variable is a tuple of the arguments that the macro accepts.
    Note that these are the explicitly defined arguments, not the special `kwargs` or `varargs`.
    Our previous example would have rendered an empty tuple, `()`, so let''s modify
    it to get something else:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the same playbook as before, to render this template in the same manner,
    should yield the output shown in *Figure 6.9*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.9 – Running a playbook to render a Jinja2 template that prints its
    macro arguments'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_06_09.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.9 – Running a playbook to render a Jinja2 template that prints its
    macro arguments
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we can clearly see that our template is rendered with the name
    of the arguments that the macro accepts (and not their values).
  prefs: []
  type: TYPE_NORMAL
- en: Defaults
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `defaults` variable is a tuple of the default values for any keyword arguments that
    the macro explicitly accepts. Although still present in the documentation for
    Jinja2 (at the time of writing, an issue is open to correct the documentation),
    this variable was removed from all versions of Jinja2 that are newer than version
    2.8.1\. If you need to access this variable, you will need to downgrade your Jinja2
    Python module to 2.8.1.
  prefs: []
  type: TYPE_NORMAL
- en: 'For those working with an older version of Jinja2, we can demonstrate this
    variable as follows; let''s change our macro to display the default values as
    well as the arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We can run our existing test playbook just as we have done before, but now
    using the newly updated template. If your version of Jinja2 supports the `defaults`
    variable, the output should look similar to the one shown in *Figure 6.10*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.10 – Rendering a Jinja2 template with the defaults and name macro
    variables'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_06_10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.10 – Rendering a Jinja2 template with the defaults and name macro variables
  prefs: []
  type: TYPE_NORMAL
- en: Here, we can see that the template is rendered with both the names and the default
    values of the arguments that are accepted by the macro.
  prefs: []
  type: TYPE_NORMAL
- en: catch_kwargs
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This variable is only defined if the macro itself accesses the `kwargs` variable
    to catch any extra keyword arguments that might have been passed along. If defined,
    it will be set to `true`. Without accessing the `kwargs` variable, any extra keyword arguments in
    a call to the macro will result in an error when rendering the template. Likewise,
    accessing `catch_kwargs` without also accessing `kwargs` will result in an undefined
    error. Let''s modify our example template again so that we can pass along additional `kwargs`
    variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We can run our updated template through our existing rendering template again,
    using the same command as before. This time, the output should look similar to
    the one shown in *Figure 6.11*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.11 – Rendering a template with the catch_kwargs variable'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_06_11.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.11 – Rendering a template with the catch_kwargs variable
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from this output, the template does not give an error when an
    unexpected variable is passed to it and, instead, enables us to access the unexpected
    value(s) that were passed.
  prefs: []
  type: TYPE_NORMAL
- en: catch_varargs
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Much like `catch_kwargs`, this variable only exists (and gets set to `true`) if
    the macro accesses the `varargs` variable. Modifying our example once more, we
    can see this in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The template''s rendered result should look similar to the one shown in *Figure
    6.12*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.12 – Rendering a template that makes use of the varargs and catch_varargs
    macro variables'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_06_12.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.12 – Rendering a template that makes use of the varargs and catch_varargs
    macro variables
  prefs: []
  type: TYPE_NORMAL
- en: Again, we can see that we were able to catch and render the unexpected value
    that was passed to the macro rather than returning an error on render, which would
    have happened if we hadn't used `catch_varargs`.
  prefs: []
  type: TYPE_NORMAL
- en: caller
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `caller` variable requires a bit more explanation. A macro can call out
    to another macro. This can be useful if the same chunk of the template will be
    used multiple times, but part of the internal data changes more than what could
    easily be passed as a macro parameter. The `caller` variable isn't exactly a variable;
    it's more of a reference back to the call to get the contents of that calling
    macro.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s update our template to demonstrate its usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The rendered result should be similar to the one shown in *Figure 6.13*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.13 – Rendering a template that makes use of the caller variable'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_06_13.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.13 – Rendering a template that makes use of the caller variable
  prefs: []
  type: TYPE_NORMAL
- en: 'A call to a macro can still pass arguments to that macro; any combination of
    arguments or keyword arguments can be passed. If the macro utilizes `varargs` or `kwargs`,
    then more of those can be passed along as well. Additionally, a macro can pass
    arguments back to the caller, too! To demonstrate this, let''s create a bigger
    example. This time, our example will generate a file that''s suitable for an Ansible
    inventory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Once rendered using our test playbook, the result should be as shown in *Figure
    6.14*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.14 – A more advanced example of a template rendered using the caller
    variable'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_06_14.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.14 – A more advanced example of a template rendered using the caller
    variable
  prefs: []
  type: TYPE_NORMAL
- en: We called the `test` macro twice, once for each group we wanted to define. Each
    group had a subtly different set of `host` variables to apply, and those were
    defined in the call itself. We saved typing by having the macro call back to the
    caller, passing along the `host` variable from the current loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'Control blocks provide programming power inside templates, allowing template
    authors to make their templates more efficient. The efficiency isn''t necessarily
    in the initial draft of the template; instead, efficiency really comes into play
    when a small change to a repeating value is needed. Now that we''ve looked, in
    detail, at building control structures within Jinja2, in the next section, we''ll
    move on to look at ways that this powerful templating language can help us with
    another common automation requirement: data manipulation.'
  prefs: []
  type: TYPE_NORMAL
- en: Data manipulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While control structures influence the flow of template processing, another
    tool exists that can help you to modify the contents of a variable. This tool
    is called a filter. Filters are the same as small functions, or methods, that
    can be run on the variable. Some filters operate without arguments, some take
    optional arguments, and some require arguments. Filters can be chained together
    as well, where the result of one filter action is fed into the next filter and
    then the next. Jinja2 comes with many built-in filters, and Ansible extends these
    with many custom filters that are available to you when using Jinja2 within templates,
    tasks, or any other place Ansible allows templating.
  prefs: []
  type: TYPE_NORMAL
- en: Syntax
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A filter is applied to a variable by way of the pipe symbol, `|`, followed
    by the name of the filter, and then any arguments for the filter inside parentheses.
    There can be a space between the variable name and the pipe symbol, as well as
    a space between the pipe symbol and the filter name. For example, if we wanted
    to apply the `lower` filter (which makes all the characters lowercase) to the `my_word` variable,
    we would use the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Because the lower filter does not take any arguments, it is not necessary to
    attach an empty parentheses set to it. However, if we use a different filter that
    requires arguments, this all changes. Let''s use the `replace` filter, which allows
    us to replace all occurrences of a substring with another substring. In this example,
    we want to replace all occurrences of the `no` substring with `yes` in the `answers` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Applying multiple filters is accomplished by simply adding more pipe symbols
    and more filter names. Let''s combine both `replace` and `lower` to demonstrate
    the syntax – the filters are applied in the sequence listed. In the following
    example, first, we replace all instances of the `no` substring with `yes`, and
    then convert the entire resulting string into lowercase:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'As we are doing a case-sensitive string replacement, you might choose to perform
    the lowercase conversion first, as this means you won''t miss any instances of
    the word `no` regardless of the case – assuming, of course, this is the behavior
    you want! The code for this latter example would simply be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We can easily demonstrate this with a simple play that uses the `debug` command
    to render the line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can execute the playbook using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'All instances of the word `no` within our `answers` variable that have been
    declared in the code will be replaced with the word `yes`. Additionally, all characters
    will be converted into lowercase. The output should be similar to the one shown
    in *Figure 6.15*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.15 – Demonstrating the use of chained filters in a simple Ansible
    playbook'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_06_15.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.15 – Demonstrating the use of chained filters in a simple Ansible playbook
  prefs: []
  type: TYPE_NORMAL
- en: Here, we can see that the playbook runs as expected and combines the two filters
    to operate on our test string, just as requested. Of course, these are just two
    of the filters available. In the next section, let's proceed to look at some of
    the more useful filters included with Jinja2.
  prefs: []
  type: TYPE_NORMAL
- en: Useful built-in filters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A full list of the filters that are built into Jinja2 can be found in the Jinja2
    documentation. At the time of writing this book, there are 50 built-in filters.
    We will take a look at some of the more commonly used filters next.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: If you want to look at the list of all available filters, the Jinja2 documentation
    for the current version (which was available at the time of writing) can be found
    at [https://jinja.palletsprojects.com/en/3.0.x/templates/#builtin-filters](https://jinja.palletsprojects.com/en/3.0.x/templates/#builtin-filters).
  prefs: []
  type: TYPE_NORMAL
- en: default
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `default` filter is a way to provide a default value for an otherwise undefined
    variable, which, in turn, prevents Ansible from generating an error. It is shorthand
    for a complex `if` statement, which checks whether a variable is defined before
    trying to use it with an `else` clause to provide a different value. Let''s look
    at two examples that render the same thing. One uses the `if/else` structure,
    while the other uses the `default` filter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The rendered result of each of these examples is the same; however, the example
    using the `default` filter is much quicker to write and easier to read.
  prefs: []
  type: TYPE_NORMAL
- en: While `default` is very useful, proceed with caution if you are using the same
    variable in multiple locations. Changing a default value can become a hassle,
    and it might be more efficient to define the variable with a default at the play
    or role level.
  prefs: []
  type: TYPE_NORMAL
- en: length
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `length` filter will return the length of a sequence or a hash. In earlier
    editions of this book, we referenced a variable called `count`, which is an alias
    of `length` and accomplishes the same thing. This filter can be useful for performing
    any sort of math around the size of a set of hosts, or any other scenario where
    the count of some set needs to be known. Let''s create an example where we set
    a `max_threads` configuration entry to match the count of the hosts in the play:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This provides us with a nice, concise way of getting the number of hosts contained
    within the `play_hosts` variable and assigning the answer to the `max_threads` variable.
  prefs: []
  type: TYPE_NORMAL
- en: random
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `random` filter is used to make a random selection from a sequence. Let''s
    use this filter to delegate a task to a random selection from the `db_servers` group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can easily delegate this task to a single member of the `db_servers` group,
    which is picked at random using our filter.
  prefs: []
  type: TYPE_NORMAL
- en: round
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `round` filter exists to round a number up or down. This can be useful
    if you need to perform floating-point math, and then turn the result into a rounded
    integer. The `round` filter takes optional arguments to define a precision (with
    a default of `0`) and a rounding method. The possible rounding methods are `common`
    (which rounds up or down and is the default), `ceil` (which always rounds up),
    and `floor` (which always rounds down). In this example, we''ll chain two filters
    together to round a math result to zero precision, and then turn that into an
    integer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Therefore, if the `math_result` variable was set to `3.4`, the output of the
    previous filter chain would be `3`.
  prefs: []
  type: TYPE_NORMAL
- en: Useful Ansible provided custom filters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While there are many filters provided with Jinja2, Ansible includes some additional
    filters that playbook authors might find particularly useful. We'll highlight
    these next.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: These custom filters in Ansible change often between releases. They are worth
    reviewing, especially if you make heavy use of them. A full list of the custom
    Ansible filters is available at [https://docs.ansible.com/ansible/latest/user_guide/playbooks_filters.html](https://docs.ansible.com/ansible/latest/user_guide/playbooks_filters.html).
  prefs: []
  type: TYPE_NORMAL
- en: Filters related to task status
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Ansible tracks task data for each task. This data is used to determine whether
    a task has failed, resulted in a change, or was skipped altogether. Playbook authors
    can register the results of a task, and in previous versions of playbooks, they
    would have used filters to check the tasks' status. As of Ansible 2.9, this has
    been removed completely. So, if you have any legacy playbooks from earlier Ansible
    versions, you might need to update them accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before the release of Ansible 2.7, you would have used a conditional with a
    filter like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'You should now use the new syntax, which is shown in the following snippet.
    Note that the code in the following code block performs the same function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s view this in action in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'You can run this playbook using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is shown in *Figure 6.16*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.16 – Running an Ansible playbook with a conditional based on task
    status'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_06_16.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.16 – Running an Ansible playbook with a conditional based on task status
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the `ansible.builtin.debug` statement resulted in `success`.
    So, we skipped the task to be run on a `change` and executed the one to be run
    on `success`.
  prefs: []
  type: TYPE_NORMAL
- en: shuffle
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Similar to the `random` filter, the `shuffle` filter can be used to produce
    randomized results. Unlike the `random` filter, which selects one random choice from a
    list, the `shuffle` filter will shuffle the items in a sequence and return the
    full sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Run this playbook using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is shown in *Figure 6.17*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.17 – Running a playbook that makes use of the shuffle filter'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_06_17.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.17 – Running a playbook that makes use of the shuffle filter
  prefs: []
  type: TYPE_NORMAL
- en: As expected, the whole list returned but with the order shuffled. If you run
    the playbook repeatedly, you will see a different order of the returned list on
    each run. Try this for yourself!
  prefs: []
  type: TYPE_NORMAL
- en: Filters dealing with pathnames
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Configuration management and orchestration frequently refer to pathnames, but
    often, only part of the path is desired. For example, we might need the full path
    to a file but not the filename itself. Or, perhaps we just need to extract the
    filename from a full path, ignoring the directories preceding it. Ansible provides
    a few filters to help with precisely these tasks, and we will examine them in
    the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: basename
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let''s say we have a requirement to work with just the filename from a full
    path. Of course, we could perform some complex pattern matching to do this. However,
    often, this results in code that is not easy to read and can be difficult to maintain.
    Luckily, Ansible provides a filter specifically for extracting the filename from
    a full path, as we will demonstrate next. In this example, we will use the `basename` filter
    to extract the filename from a full path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Run this playbook using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is shown in *Figure 6.18*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.18 – Running a playbook that makes use of the basename filter'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_06_18.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.18 – Running a playbook that makes use of the basename filter
  prefs: []
  type: TYPE_NORMAL
- en: Here, you can see that just the filename was returned from the full path, as
    desired.
  prefs: []
  type: TYPE_NORMAL
- en: dirname
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The inverse of `basename` is `dirname`. Instead of returning the final part
    of a path, `dirname` will return everything else (except the filename, which is
    the final part of the full path). Let''s change our previous play to use `dirname` and
    rerun it using the same command. The output should now look similar to the one
    shown in *Figure 6.19*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.19 – Running a playbook using the dirname filter'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_06_19.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.19 – Running a playbook using the dirname filter
  prefs: []
  type: TYPE_NORMAL
- en: Now, we have just the path of our variable, which could be extremely useful
    elsewhere in our playbook.
  prefs: []
  type: TYPE_NORMAL
- en: expanduser
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Often, paths to various things are supplied with a user shortcut, such as `~/.stackrc`.
    However, some tasks might require the full path to the file. Rather than the complicated
    command and register calls, the `expanduser` filter provides a way to expand the
    path to the full definition. In this example, the username is `jfreeman`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'You can run this playbook with the same command as before, and the output should
    look similar to the one shown in *Figure 6.20*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.20 – Running a playbook using the expanduser filter'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_06_20.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.20 – Running a playbook using the expanduser filter
  prefs: []
  type: TYPE_NORMAL
- en: Here, we have successfully expanded the path, which could be useful for creating
    configuration files or performing other file operations that might need an absolute
    pathname rather than a relative pathname.
  prefs: []
  type: TYPE_NORMAL
- en: Base64 encoding
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When reading content from remote hosts, such as with the `ansible.builtin.slurp` module
    (which is used to read file content from remote hosts into a variable), the content
    will be Base64 encoded. To decode such content, Ansible provides a `b64decode` filter.
    Similarly, if running a task that requires Base64-encoded input, regular strings
    can be encoded using the `b64encode` filter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use Ansible to create a test file, called `/tmp/derp`, which will contain
    a test string. Then, we''ll use the `ansible.builtin.slurp` module to obtain the
    file contents and decode them using the aforementioned filter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are working with the example code that accompanies this book, run the
    playbook using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is shown in *Figure 6.21*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.21 – Running a playbook featuring the b64decode filter'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_06_21.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.21 – Running a playbook featuring the b64decode filter
  prefs: []
  type: TYPE_NORMAL
- en: Here, we successfully read the small file we created into a variable. Additionally,
    we can see the variable contents in Base64-encoded form (remember that this encoding
    was performed by the `ansible.builtin.slurp` module). We can then decode it using
    a filter to view the original file contents.
  prefs: []
  type: TYPE_NORMAL
- en: Searching for content
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is relatively common in Ansible to search a string for a substring. In particular,
    the common administrator task of running a command and grepping the output for
    a particular key piece of data is a reoccurring construct in many playbooks. While
    it's possible to replicate this with a shell task to execute a command, pipe the
    output into `grep`, and use careful handling of `failed_when` to catch the `grep` exit
    codes, a far better strategy is to use a command task, `register` the output,
    and then utilize the Ansible-provided **Regular Expression** (**regex**) filters
    in later conditionals.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at two examples: one using `ansible.builtin.shell`, the
    pipe, and the `grep` method, and another using the `search` test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example works by forcing Ansible to always see the task as successful
    but assumes that if the exit code from the shell is nonzero, then the `juno` string was
    not found in the output of the `neutron-manage` command. This construct is functional
    but complex to read, and it could mask real errors from the command. Let's try
    again using the `search` test.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we previously mentioned, regarding the task status, using `search` on a
    string in Ansible is considered a test and is deprecated. Although it might read
    slightly odd, in order to be compliant with Ansible 2.9 and later versions, we
    must use the `is` keyword in place of the pipe when using `search` in this context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are requesting to run the task named `upgrade db` when `neutron_db_ver.stdout`
    does not contain the `juno` string. Once you get used to the concept of `when:
    not ... is`, you can see that this version is much cleaner to follow and does
    not mask errors from the first task.'
  prefs: []
  type: TYPE_NORMAL
- en: The `search` filter searches a string and will return `True` if the substring
    is found anywhere inside the input string. However, if an exact complete match
    is desired instead, the `match` filter can be used. Full Python regex syntax can
    be utilized inside the `search`/`match` string.
  prefs: []
  type: TYPE_NORMAL
- en: Omitting undefined arguments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `omit` variable requires a bit of explanation. Sometimes, when iterating
    over a hash of data to construct task arguments, it might be necessary to only
    provide some arguments for some of the items in the hash. Even though Jinja2 supports
    inline `if` statements to conditionally render parts of a line, this does not
    work well in an Ansible task. Traditionally, playbook authors would create multiple
    tasks, one for each set of potential arguments passed in, and use conditionals
    to sort the loop members between each task set. A recently added magic variable
    named `omit` solves this problem when used in conjunction with the `default` filter.
    The `omit` variable will remove the argument the variable was used with altogether.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate how this works, let''s consider a scenario where we need to install
    a set of Python packages with `ansible.builtin.pip`. Some of the packages have
    a specific version, while others do not. These packages are in a list of hashes
    named `pips`. Each hash has a `name` key and, potentially, a `ver` key. Our first
    example utilizes two different tasks to complete the installation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'This construct works, but the loop is iterated twice, and some of the iterations
    will be skipped in each task. The following example collapses the two tasks into
    one, and utilizes the `omit` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: This example is shorter, cleaner, and doesn't generate additional skipped tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Python object methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Jinja2 is a Python-based template engine, and so Python object methods are
    available within templates. Object methods are methods, or functions, that are
    directly accessible by the variable object (typically, a `string`, `list`, `int`,
    or `float`). A good way to think about this is as follows: if you were writing Python
    code and could write the variable, then a period, and then a method call, you
    would have access to do the same in Jinja2\. Within Ansible, only methods that
    return modified content or a Boolean are typically used. Let''s explore some common
    object methods that might be useful in Ansible.'
  prefs: []
  type: TYPE_NORMAL
- en: String methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'String methods can be used to return new strings, return a list of strings
    that have been modified in some way, or test a string for various conditions and
    return a Boolean. Some useful methods are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`endswith`: This determines whether the string ends with a substring.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`startswith`: This is the same as `endswith` but from the start.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`split`: This splits the string on characters (the default is space) into a
    list of substrings.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rsplit`: This is the same as `split`, but it starts from the end of the string
    and works backward.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`splitlines`: This splits the string at newlines into a list of substrings.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`upper`: This returns a copy of the string all in uppercase.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lower`: This returns a copy of the string all in lowercase.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`capitalize`: This returns a copy of the string with just the first character
    in uppercase.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can create a simple playbook that will utilize some of these methods in
    a single task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are using the example code that accompanies this book, run this playbook
    using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will look similar to the one shown in *Figure 6.22*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.22 – Running a playbook that makes use of the Python string object
    methods'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_06_22.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.22 – Running a playbook that makes use of the Python string object
    methods
  prefs: []
  type: TYPE_NORMAL
- en: As these are object methods, we need to access them using dot notation rather
    than with a filter via `|`.
  prefs: []
  type: TYPE_NORMAL
- en: List methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Most of the methods Ansible provides relating to lists perform modifications
    on the list itself. However, there are two list methods that are useful when working
    with lists, especially when loops are involved. These two functions are `index` and `count`,
    and their functionality is described as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`index`: This returns the first index position of a provided value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`count`: This counts the items in the list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These functions can be incredibly useful when iterating through a list in a
    loop, as it allows positional logic to be performed and appropriate actions to
    be taken, given our position in the list as we work through it. This is common
    in other programming languages, and fortunately, Ansible also provides this.
  prefs: []
  type: TYPE_NORMAL
- en: The int and float methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Most `int` and `float` methods are not useful for Ansible. Sometimes, our variables are
    not exactly in the format we want them in. However, instead of defining more and
    more variables that slightly modify the same content, we can make use of Jinja2
    filters to carry out the manipulation for us in the various places that require
    that modification. This allows us to stay efficient with the definition of our
    data, preventing numerous duplicate variables and tasks that might have to be
    changed later.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Comparisons are used in many places with Ansible. Task conditionals are comparisons.
    Jinja2 control structures, such as `if`/`elif`/`else` blocks, `for` loops, and
    macros, often use comparisons; some filters use comparisons as well. To master
    Ansible's usage of Jinja2, it is important to understand what comparisons are
    available.
  prefs: []
  type: TYPE_NORMAL
- en: Comparisons
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Like most languages, Jinja2 comes equipped with the standard set of comparison
    expressions you would expect, which will render a Boolean `true` or `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The expressions in Jinja2 are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/Table_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you have written comparison operations in almost any other programming language
    (usually in the form of an `if` statement), these should all seem very familiar.
    Jinja2 maintains this functionality in templates, allowing for the same powerful
    comparison operations you would expect in conditional logic from any good programming
    language.
  prefs: []
  type: TYPE_NORMAL
- en: Logic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes, performing a single comparison operation on its own is not enough
    – perhaps we might want to perform an action if two comparisons evaluate to `true` at
    the same time. Alternatively, we might want to perform an operation only if a
    comparison is not true. Logic in Jinja2 helps you to group two or more comparisons
    together, allowing for the formation of complex conditions from simple comparisons.
    Each comparison is referred to as an operand, and the logic that''s used to bind
    these together into complex conditionals is given in the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: '`and`: This returns `true` if the left and the right operand are true.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`or`: This returns `true` if the left or the right operand is true.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`not`: This negates an operand.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`()`: This wraps a set of operands together to form a larger operand.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To build on the definition of logical conditions in Jinja2, we can perform tests
    for certain variable conditions such as if a variable is defined or not. We will
    look at this in more detail in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A test in Jinja2 is used to determine whether a variable matches certain well-defined
    criteria, and we have already come across this in this chapter in specific scenarios.
    The `is` operator is used to initiate a test. Tests are used wherever a Boolean
    result is desired, such as with `if` expressions and task conditionals. There
    are many built-in tests, but we''ll highlight a few of the particularly useful
    ones, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`defined`: This returns `true` if the variable is defined.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`undefined`: This is the opposite of `defined`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`none`: This returns `true` if the variable is defined, but the value is none.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`even`: This returns `true` if the number is divisible by `2`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`odd`: This returns `true` if the number is not divisible by `2`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To test whether a value is not something, simply use `is not`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create a playbook to demonstrate some of these value comparisons:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are running the code that accompanies this book, you can execute this
    example playbook using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is shown in *Figure 6.23*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.23 – Executing a playbook containing a complex conditional'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_06_23.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.23 – Executing a playbook containing a complex conditional
  prefs: []
  type: TYPE_NORMAL
- en: Here, we can see that our complex conditional evaluated as `true`, and so the
    debug task was executed.
  prefs: []
  type: TYPE_NORMAL
- en: That concludes our look at Ansible's extensive templating capabilities. We hope
    that this chapter has sown seeds of ideas for you on ways to efficiently automate
    your infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Jinja2 is a powerful language that is extensively used by Ansible. Not only
    is it used to generate file content, but it is also used to make portions of a
    playbook dynamic. Mastering Jinja2 is vital for creating and maintaining elegant
    and efficient playbooks and roles.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we learned how to build simple templates with Jinja2 and render
    them from an Ansible playbook. Additionally, we learned how to make effective
    use of control structures, how to manipulate data, and even how to perform comparisons
    and tests on variables to both control the flow of Ansible playbooks (by keeping
    the code lightweight and efficient) and create and manipulate data without the
    need for duplicate definitions or excessive numbers of variables.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore Ansible's capability in more depth to define
    what constitutes a change or failure for tasks within a play.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Jinja2 conditionals can be used to render content inline with a playbook task.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) True
  prefs: []
  type: TYPE_NORMAL
- en: b) False
  prefs: []
  type: TYPE_NORMAL
- en: With of the following Jinja2 constructs will print an empty line each time it
    is evaluated?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) `{% if loop.first -%}`
  prefs: []
  type: TYPE_NORMAL
- en: b) `{% if loop.first %}`
  prefs: []
  type: TYPE_NORMAL
- en: c) `{%- if loop.first -%}`
  prefs: []
  type: TYPE_NORMAL
- en: d) `{%- if loop.first %}`
  prefs: []
  type: TYPE_NORMAL
- en: Jinja2 macros can be used to do which of the following?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) Define a sequence of keystrokes that need to be automated.
  prefs: []
  type: TYPE_NORMAL
- en: b) Define a function for automating spreadsheets with Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: c) Define a function that gets called regularly from elsewhere in the template.
  prefs: []
  type: TYPE_NORMAL
- en: d) Macros are not used in Jinja2.
  prefs: []
  type: TYPE_NORMAL
- en: Which of the following is a valid expression for chaining two Jinja2 filters
    together to operate on an Ansible variable?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) `{{ value.replace('A', 'B').lower }}`
  prefs: []
  type: TYPE_NORMAL
- en: b) `{{ value | replace('A', 'B') | lower }}`
  prefs: []
  type: TYPE_NORMAL
- en: c) `value.replace('A', 'B').lower`
  prefs: []
  type: TYPE_NORMAL
- en: d) `lower(replace('A', 'B',value))`
  prefs: []
  type: TYPE_NORMAL
- en: Jinja2 filters always have mandatory arguments.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) True
  prefs: []
  type: TYPE_NORMAL
- en: b) False
  prefs: []
  type: TYPE_NORMAL
- en: Which Ansible custom filter would you use to retrieve a random entry from a
    list variable?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) `shuffle`
  prefs: []
  type: TYPE_NORMAL
- en: b) `random`
  prefs: []
  type: TYPE_NORMAL
- en: c) `select`
  prefs: []
  type: TYPE_NORMAL
- en: d) `rand`
  prefs: []
  type: TYPE_NORMAL
- en: Ansible can extract the filename from a full path using which filter?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) `filename`
  prefs: []
  type: TYPE_NORMAL
- en: b) `dirname`
  prefs: []
  type: TYPE_NORMAL
- en: c) `expanduser`
  prefs: []
  type: TYPE_NORMAL
- en: d) `basename`
  prefs: []
  type: TYPE_NORMAL
- en: Ansible provides a construct for skipping optional arguments to prevent undefined
    variable errors. What is it called?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) `skip_var`
  prefs: []
  type: TYPE_NORMAL
- en: b) `skip`
  prefs: []
  type: TYPE_NORMAL
- en: c) `omit`
  prefs: []
  type: TYPE_NORMAL
- en: d) `prevent_undefined`
  prefs: []
  type: TYPE_NORMAL
- en: Complex conditionals can be constructed for Ansible tasks using which operators?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) `and`, `or`, and `not`
  prefs: []
  type: TYPE_NORMAL
- en: b) `and`, `nand`, `or`, `nor`, and `not`
  prefs: []
  type: TYPE_NORMAL
- en: c) `&&`, `||`, and `!`
  prefs: []
  type: TYPE_NORMAL
- en: d) `&`, `|`, and `!`
  prefs: []
  type: TYPE_NORMAL
- en: Which of the following task execution conditionals will allow the task to run
    if the previous task has been completed successfully?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) `previoustask | success`
  prefs: []
  type: TYPE_NORMAL
- en: b) `previoustask = success`
  prefs: []
  type: TYPE_NORMAL
- en: c) `previoustask == success`
  prefs: []
  type: TYPE_NORMAL
- en: d) `previoustask is success`
  prefs: []
  type: TYPE_NORMAL
