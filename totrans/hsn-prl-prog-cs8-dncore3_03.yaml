- en: Task Parallelism
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we introduced the concept of parallel programming.
    In this chapter, we will move on to discussing TPL and task parallelism.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: One of the major goals of .NET as a programming framework is to make a developer's
    life easier by wrapping up all the commonly required tasks as APIs. As we have
    already seen, threads have existed since the earliest versions of .NET, but they
    were initially very complex and were associated with a lot of overhead. Microsoft
    has introduced a lot of new parallel primitives that make it easier to write,
    debug, and maintain parallel programs from scratch, without having to deal with
    the complexities that are involved with legacy threading.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Creating and starting a task
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting results from finished tasks
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to cancel tasks
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to wait on running tasks
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling task exceptions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting **Asynchronous Programming Model** (**APM**) patterns into tasks
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting **Event-Based Asynchronous Patterns** (**EAPs**) into tasks
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'More on tasks:'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Continuation tasks
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parent and child tasks
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Local and global queues and storage
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Work-stealing queues
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To complete this chapter, you should have a good understanding of C# and some
    advanced concepts such as delegates.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: The source code for this chapter is available on GitHub at [https://github.com/PacktPublishing/Hands-On-Parallel-Programming-with-C-8-and-.NET-Core-3/tree/master/Chapter02](https://github.com/PacktPublishing/Hands-On-Parallel-Programming-with-C-8-and-.NET-Core-3/tree/master/Chapter02).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Tasks
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Tasks** are abstractions in .NET that provide units of asynchrony, just like
    promises in JavaScript. In initial versions of .NET, we had to rely on threads
    only, which were created either directly or using the `ThreadPool` class. The
    `ThreadPool` class provided a managed abstraction layer over threads but developers still relied
    on the `Thread` class for better control. By creating a thread via the `Thread`
    class, we gained access to the underlying object, which we can wait for, cancel,
    or move to the foreground or background. In real time, however, we required threads
    to perform work continuously. This required us to write lots of code, which was
    difficult to maintain. The `Thread` class was also unmanaged, which put a high
    burden on both the memory and the CPU. We needed the best of both worlds, which
    is where tasks come to the rescue. A task is nothing but a wrapper over a thread,
    which is created via `ThreadPool`. Tasks provide features such as await, cancellation,
    and continuation, and these run after a task has finished.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: 'Tasks have the following important features:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Tasks are executed by a `TaskScheduler` and the default scheduler simply runs
    on `ThreadPool`.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can return values from tasks.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tasks let you know when they finish, unlike `ThreadPool` or threads.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A task can be run in continuation using the `ContinueWith()` construct.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can wait on tasks by calling `Task.Wait()`. This blocks the calling thread
    until it has finished.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tasks make the code much more readable compared to legacy threads or `ThreadPool`.
    They also paved the way to the introduction of the asynchronous programming construct
    in C# 5.0.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can establish a parent/child relationship when one task is started from another
    task.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can propagate child task exceptions to parent tasks.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A task can be canceled using the `CancellationToken` class.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating and starting a task
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are many ways in which we can create and run a task using the TPL. In
    this section, we will try to understand all of these approaches and do a comparative
    analysis wherever we can. First, you need to add a reference to the `System.Threading.Tasks`
    namespace:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We will try to create a task using the following approaches:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: The `System.Threading.Tasks.Task` class
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `System.Threading.Tasks.Task.Factory.StartNew` method
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `System.Threading.Tasks.Task.Run` method
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`System.Threading.Tasks.Task.Delay`'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`System.Threading.Tasks.Task.Yield`'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System.Threading.Tasks.Task.Yield`'
- en: '`System.Threading.Tasks.Task.FromResult<T> Method`'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System.Threading.Tasks.Task.FromResult<T>方法`'
- en: '`System.Threading.Tasks.Task.FromException` and `Task.FromException<T>`'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System.Threading.Tasks.Task.FromException`和`Task.FromException<T>`'
- en: '`System.Threading.Tasks.Task.FromCancelled` and `Task.FromCancelled<T>`'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System.Threading.Tasks.Task.FromCancelled`和`Task.FromCancelled<T>`'
- en: The System.Threading.Tasks.Task class
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: System.Threading.Tasks.Task类
- en: A task class is a way of executing work asynchronously as a `ThreadPool` thread
    and is based on the **Task-Based Asynchronous Pattern** (**TAP**). The non-generic `Task`
    class doesn't return results, so whenever we need to return values from a task,
    we need to use the generic version, `Task<T>`. The tasks that are created via
    the `Task` class are not scheduled to run until we call the `Start` method.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 任务类是一种以`ThreadPool`线程异步执行工作的方式，它基于**基于任务的异步模式**（**TAP**）。非泛型的`Task`类不返回结果，所以每当我们需要从任务中返回值时，我们需要使用泛型版本`Task<T>`。通过`Task`类创建的任务直到我们调用`Start`方法才被安排运行。
- en: We can create a task using the `Task` class in various ways, all of which we'll
    cover in the following subsections.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过`Task`类的各种方式创建一个任务，所有这些方式我们将在以下小节中讨论。
- en: Using lambda expressions syntax
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用lambda表达式语法
- en: 'In the following code, we are creating a task by calling the `Task` constructor
    and passing a lambda expression containing the method we want to execute:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，我们通过调用`Task`构造函数并传递包含我们要执行的方法的lambda表达式来创建一个任务：
- en: '[PRE1]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Using the Action delegate
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Action delegate
- en: 'In the following code, we are creating a task by calling the `Task` constructor
    and passing a delegate containing the method we want to execute:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，我们通过调用`Task`构造函数并传递包含我们要执行的方法的delegate来创建一个任务：
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Using delegate
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用delegate
- en: 'In the following code, we are creating a `task` object by calling the `Task`
    constructor and passing an anonymous `delegate` containing the method we want
    to execute:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，我们通过调用`Task`构造函数并传递包含我们要执行的方法的匿名`delegate`来创建一个`task`对象：
- en: '[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In all of these cases, the output will be as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些情况下，输出将如下所示：
- en: '![](img/40ef715e-dff5-40e9-a0a0-acafb3317b7c.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/40ef715e-dff5-40e9-a0a0-acafb3317b7c.png)'
- en: All the preceding methods do the same thing – they just have different syntaxes.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 所有前面的方法都是做同样的事情 - 它们只是有不同的语法。
- en: We can only call the `Start` method on tasks that have not run previously. If
    you need to rerun a task that has already been completed, you need to create a
    new task and call the `Start` method on that.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只能对以前未运行过的任务调用`Start`方法。如果您需要重新运行已经完成的任务，您需要创建一个新的任务并在其上调用`Start`方法。
- en: The System.Threading.Tasks.Task.Factory.StartNew method
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: System.Threading.Tasks.Task.Factory.StartNew方法
- en: We can also create a task using the `StartNew` method of the `TaskFactory` class,
    as follows. In this approach, the task is created and scheduled for execution
    inside the `ThreadPool` and a reference of that `Task` is returned to the caller.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用`TaskFactory`类的`StartNew`方法创建一个任务，如下所示。在这种方法中，任务被创建并安排在`ThreadPool`内执行，并将该任务的引用返回给调用者。
- en: We can create a task using the `Task.Factory.StartNew` method. We'll go over
    this in the following subsections.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`Task.Factory.StartNew`方法创建一个任务。我们将在以下小节中讨论这个问题。
- en: Using lambda expressions syntax
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用lambda表达式语法
- en: 'In the following code, we are creating a `Task` by calling the `StartNew()`
    method on `TaskFactory` and passing a lambda expression containing the method
    we want to execute:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，我们通过在`TaskFactory`上调用`StartNew()`方法并传递包含我们要执行的方法的lambda表达式来创建一个`Task`：
- en: '[PRE4]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Using the Action delegate
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Action delegate
- en: 'In the following code, we are creating a `Task` by calling the `StartNew()`
    method on `TaskFactory` and passing a delegate wrapping method that we want to
    execute:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，我们通过在`TaskFactory`上调用`StartNew()`方法并传递包装我们要执行的方法的delegate来创建一个`Task`：
- en: '[PRE5]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Using delegate
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用delegate
- en: 'In the following code, we are creating a `Task` by calling the `StartNew()`
    method on `TaskFactory` and passing the `delegate` wrapping method we want to
    execute:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，我们通过在`TaskFactory`上调用`StartNew()`方法并传递我们要执行的`delegate`包装方法来创建一个`Task`：
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: All the preceding methods do the same thing – they just have different syntaxes.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 所有前面的方法都是做同样的事情 - 它们只是有不同的语法。
- en: The System.Threading.Tasks.Task.Run method
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: System.Threading.Tasks.Task.Run方法
- en: We can also create a task using the `Task.Run` method. This works just like
    the `StartNew` method and returns a `ThreadPool` thread.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用`Task.Run`方法创建一个任务。这与`StartNew`方法的工作方式相同，并返回一个`ThreadPool`线程。
- en: We can create a `Task` using the `Task.Run` method in the following ways, all
    of which will be discussed in the following subsections.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下方式使用`Task.Run`方法创建一个`Task`，所有这些方式将在以下小节中讨论。
- en: Using lambda expressions syntax
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用lambda表达式语法
- en: 'In the following code, we are creating a `Task` by calling the static `Run()`
    method on `Task` and passing a lambda expression containing the method we want
    to execute:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，我们通过在`Task`上调用静态的`Run()`方法并传递包含我们要执行的方法的lambda表达式来创建一个`Task`：
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Using the Action delegate
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Action delegate
- en: 'In the following code, we are creating a `Task` by calling the static `Run()`
    method on `Task` and passing a delegate containing the method we want to execute:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，我们通过在`Task`上调用静态的`Run()`方法并传递包含我们要执行的方法的delegate来创建一个`Task`：
- en: '[PRE8]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Using delegate
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用delegate
- en: 'In the following code, we are creating a `Task` by calling the static `Run()`
    method on `Task` and passing a `delegate` containing the method we want to execute:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，我们通过在`Task`上调用静态的`Run()`方法并传递包含我们要执行的方法的delegate来创建一个`Task`：
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The System.Threading.Tasks.Task.Delay method
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: System.Threading.Tasks.Task.Delay方法
- en: 'We can create a task that completes after a specified interval of time or that
    can be canceled at any time by the user using the `CancellationToken` class. In
    the past, we used the `Thread.Sleep()` method of the `Thread` class to create
    blocking constructs to wait on other tasks. The problem with this approach, however,
    was that it still used CPU resources and ran synchronously. `Task.Delay` provides
    a better alternative to waiting on tasks without utilizing CPU cycles. It also
    runs asynchronously:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The preceding code asks the user a question and then waits for two seconds before
    presenting the answer. During those two seconds, the main thread doesn't have
    to wait but has to carry out other tasks to improve the user's experience. The
    code runs asynchronously on the system clock and, once the time expires, the rest
    of the code is executed.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of the preceding code is as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e92b0ddd-683c-4c1f-92e9-6d9092ff30b0.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
- en: 'Before looking at the other methods we can use to create a task, we''ll take
    a look at two asynchronous programming constructs that were introduced in C# 5.0:
    the `async` and `await` keywords.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '`async` and `await` are code markers that make it easier for us to write asynchronous
    programs. We will learn about these keywords in depth in [Chapter 9](1b0d3653-dd80-486b-96fc-b17000f9439d.xhtml),
    *Async, Await, and Task-Based Asynchronous Programming Basics**.* As the name
    suggests, we can wait on any asynchronous call using the `await` keyword. The
    moment the executing thread encounters the `await` keyword inside a method, it
    returns to `ThreadPool`, marks the rest of the method as a continuation delegate,
    and starts executing the other queued tasks. Once the asynchronous task finishes,
    any available thread from `ThreadPool` finishes the rest of the method.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: The System.Threading.Tasks.Task.Yield method
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is another way of creating an `await` task. The underlying task is not
    directly accessible to the caller but is used in some scenarios involving asynchronous
    programming that are related to program execution. It is more like a promise than
    a task. Using `Task.Yield`, we can force our method to be asynchronous and return
    control to the OS. When the rest of the method executes at a later point in time,
    it may still run as asynchronous code. We can achieve the same effect using the
    following code:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This approach can be used to make UI applications responsive by providing control
    to the UI thread from time to time inside long-running tasks. However, this is
    not the preferred approach for UI applications. There are better alternatives,
    which are available in the form of `Application.DoEvents()` in WinForms and `Dispatcher.Yield
    (DispatcherPriority.ApplicationIdle)` in WPF:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the case of console or web applications, when we run the code and apply a
    breakpoint on the task's yield, we will see random thread pool threads switching
    context to run the code. The following screenshots depict various threads controlling
    execution at various stages.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows all the threads executing at the same time in
    the program flow. We can see that the current thread ID is 1664:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5a633f20-226e-49d4-aa64-3d7f3ca6092d.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
- en: 'If we press *F5* and allow the breakpoint to get hit for another value of `i`,
    we will see that the code is now being executed by another thread with an ID of 10244:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e7dd5bc6-0a11-4692-8ade-63a6fef19e9d.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
- en: We will learn more about thread windows and debugging techniques in [Chapter
    11](86c487fc-641d-47e9-9270-e9d667bca405.xhtml), *Writing Unit Test Cases for
    Parallel and Asynchronous Code*.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: The System.Threading.Tasks.Task.FromResult<T> method
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This approach, which was introduced recently in .NET framework 4.5, is very
    much underrated. We can return a completed task with results via this approach,
    as shown here:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As you can see from the preceding code, we have actually converted a synchronous
    `Sum` method to return results in an asynchronous manner using the `Task.FromResult<int>`
    class. This approach is frequently used in TDD for mocking asynchronous methods,
    as well as inside asynchronous methods to return default values based on conditions.
    We will explain these approaches in [Chapter 11](86c487fc-641d-47e9-9270-e9d667bca405.xhtml), *Writing
    Unit Test Cases for Parallel and Asynchronous Code**.*
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: The System.Threading.Tasks.Task.FromException and System.Threading.Tasks.Task.FromException<T>
    methods
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These methods create tasks that have completed with a predefined exception
    and are used to throw exceptions from asynchronous tasks, as well as in TDD. We
    will explain this approach further in [Chapter 11](86c487fc-641d-47e9-9270-e9d667bca405.xhtml), *Writing
    Unit Test Cases for Parallel and Asynchronous Code*:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As you can see in the preceding code, we are wrapping `FileNotFoundException`
    as a task and returning it to the caller.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: The System.Threading.Tasks.Task.FromCanceled and System.Threading.Tasks.Task.FromCanceled<T>
    methods
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These methods are used to create tasks that have completed as a result of cancellation
    via the cancellation token:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As shown in the preceding code, we created a cancellation token using the `CancellationTokenSource`
    class. Then, we created a task from that token. The important thing to consider
    here is that the token needs to be canceled before we can use it with the `Task.FromCanceled`
    method.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: This approach is useful if we want to return values from asynchronous methods,
    as well as in TDD.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Getting results from finished tasks
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To return values from tasks, TPL provides a generic variant of all of the classes
    that we defined previously:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '`Task<T>`'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Task.Factory.StartNew<T>`'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Task.Run<T>`'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once a task finishes, we should be able to get results from it by accessing
    the `Task.Result` property. Let''s try to understand this using some code examples.
    We will create various tasks and try to return values from them on completion:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'As shown in the preceding code, we have created tasks using generic variants.
    Once they finished, we were able to get the results using the result property:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bc4ef585-380d-4bed-82c2-49d3ea97a72a.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
- en: In the next section, we will learn about how we can cancel tasks.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: How to cancel tasks
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another important function of the TPL is to equip developers with ready-made
    data structures to cancel running tasks. Those of you that have a classic threading
    background will be aware of how difficult it used to be to make threads support
    canceling with all the custom home-grown logic, but this is no longer the case.
    The .NET Framework provides two classes to support task cancellation:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '`CancellationTokenSource`**: **This class is responsible for creating cancellation
    tokens and passing the cancellation request to all the tokens that were created
    via the source'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CancellationToken`**: **This class is used by listeners to monitor the current
    state of a request'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To create tasks that can be canceled, we need to perform the following steps:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: Create an instance of the `System.Threading.CancellationTokenSource` class,
    which further provides a `System.Threading.CancellationToken` via the `Token Property`.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pass the token while creating the task.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When required, call the `Cancel()` method on the `CancellationTokenSource`.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's try to understand how to create a token and how to pass it to the task.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: Creating a token
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Tokens can be created using the following code:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: First, we created a `tokenSource` using the `CancellationTokenSource` constructor.
    Then, we got our token using the token property of **`tokenSource`**.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: Creating a task using tokens
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can create a task by passing `CancellationToken` as the second argument
    to the task constructor, as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the classic threading model, we used to call the `Abort()` method on a thread
    that was non-deterministic. This would stop the thread abruptly, thereby leaking
    memory if resources were unmanaged. With TPL, we can call the `Cancel` method,
    which is a cancellation token source that will, in turn, set up the `IsCancellationRequested`
    property on the token. The underlying method that's being executed by the task
    should watch for this property and should exit gracefully if it is set.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在经典的线程模型中，我们曾经在非确定性的线程上调用`Abort()`方法。这会突然停止线程，从而导致资源未受管理时内存泄漏。使用TPL，我们可以调用`Cancel`方法，这是一个取消令牌源，将进而在令牌上设置`IsCancellationRequested`属性。任务执行的底层方法应该监视此属性，并且如果设置了，应该优雅地退出。
- en: 'There are various ways of keeping a watch of whether the token source has requested
    a cancellation:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 有各种方法可以监视令牌源是否请求了取消：
- en: Polling the status of the `IsCancellationRequested` property on the token
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过轮询令牌的`IsCancellationRequested`属性的状态
- en: Registering for a request cancellation callback
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注册请求取消回调
- en: Polling the status of the token via the IsCancellationRequested property
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过轮询令牌的状态来检查`IsCancellationRequested`属性
- en: This approach is handy in scenarios that involve recursive methods or methods
    that contain long-running computational logic via loops. Within our method or
    loops, we write code that polls `IsCancellationRequested` at certain optimal intervals.
    If it is set, it breaks the loop by calling the `ThrowIfCancellationRequested`
    method of the `token` class.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法在涉及递归方法或包含通过循环进行长时间计算逻辑的方法的场景中非常有用。在我们的方法或循环中，我们编写代码以在某些最佳间隔时轮询`IsCancellationRequested`。如果设置了，它通过调用`token`类的`ThrowIfCancellationRequested`方法来中断循环。
- en: 'The following code is an example of canceling a task by polling the token:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是通过轮询令牌来取消任务的示例：
- en: '[PRE19]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the preceding code, we created a cancellation token via the `CancellationTokenSource`
    class. Then, we created a task by passing the token. The task executes a long-running
    method, `LongRunningSum` (simulated), which keeps polling for the `IsCancellationRequested`
    property of the token. It throws an exception if the user has called `cancellationTokenSource.Cancel()`
    before the method finishes.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们通过`CancellationTokenSource`类创建了一个取消令牌。然后，我们通过传递令牌创建了一个任务。该任务执行一个长时间运行的方法`LongRunningSum`（模拟），该方法不断轮询令牌的`IsCancellationRequested`属性。如果用户在方法完成之前调用了`cancellationTokenSource.Cancel()`，它会抛出异常。
- en: Polling doesn't come with any significant performance overhead and can be used
    according to your requirements. Use it when you have full control over the work
    that's performed by the task, such as if it's core logic that you wrote yourself.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 轮询不会带来任何显著的性能开销，并且可以根据您的需求使用。当您对任务执行的工作有完全控制时使用它，例如如果它是您自己编写的核心逻辑。
- en: Registering for a request cancellation using the Callback delegate
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用回调委托注册请求取消
- en: This approach makes use of a `Callback` delegate that gets invoked when the
    cancellation is requested by the underlying token. We should use this with operations
    that are blocked in a way that makes it not possible to check the value of `CancellationToken`
    in a regular fashion.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法利用了一个`Callback`委托，当底层令牌请求取消时会被调用。我们应该将其与那些以一种使得无法以常规方式检查`CancellationToken`值的方式阻塞的操作一起使用。
- en: 'Let''s have a look at the following code, which downloads files from a remote
    URL:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下以下代码，它从远程URL下载文件：
- en: '[PRE20]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As you can see from the preceding method, once we call the `DownloadStringAsync`
    method of `WebClient`, the control leaves the user. Although the `WebClient` class
    allows us to cancel the task via the `webClient.CancelAsync()` method, we don't
    have any control over when to invoke that.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的方法中可以看到，一旦我们调用`WebClient`的`DownloadStringAsync`方法，控制权就离开了用户。虽然`WebClient`类允许我们通过`webClient.CancelAsync()`方法取消任务，但我们无法控制何时调用它。
- en: 'The preceding code can be modified to make use of a `Callback` delegate so
    that we can gain more control over task cancellation, as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码可以修改为使用`Callback`委托，以便更好地控制任务取消，如下所示：
- en: '[PRE21]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As you can see, in this modified version, we passed a cancellation token and
    subscribed to the cancellation callback via the `Register` method.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，在这个修改后的版本中，我们传递了一个取消令牌，并通过`Register`方法订阅了取消回调。
- en: As soon as the user calls the `cancellationTokenSource.Cancel()` method, it
    will cancel the download operation by calling `webClient.CancelAsync()`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦用户调用`cancellationTokenSource.Cancel()`方法，它将通过调用`webClient.CancelAsync()`取消下载操作。
- en: '`CancellationTokenSource` works well with the legacy `ThreadPool.QueueUserWorkItem`
    as well.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`CancellationTokenSource`也可以与传统的`ThreadPool.QueueUserWorkItem`很好地配合使用。'
- en: 'Here is code that creates a `CancellationTokenSource` that can be passed to
    `ThreadPool` to support cancellation:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是创建`CancellationTokenSource`的代码，可以传递给`ThreadPool`以支持取消：
- en: '[PRE22]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In this section, we discussed various ways of canceling tasks. Canceling tasks
    can really save us a lot of CPU time in cases where tasks may have become redundant.
    For example, say we have created multiple tasks to sort a list of numbers using
    different algorithms. Although all the algorithms will return the same result
    (a sorted list of numbers), we are interested in getting results as fast as we
    can. We will accept the result for the first (fastest) algorithm and cancel the
    rest to improve system performance. In the next section, we will discuss how to
    wait on running tasks.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论了取消任务的各种方法。取消任务可以在任务可能变得多余的情况下节省大量CPU时间。例如，假设我们创建了多个任务，使用不同的算法对一组数字进行排序。虽然所有算法都会返回相同的结果（一组排序好的数字），但我们希望尽快获得结果。我们将接受第一个（最快的）算法的结果，并取消其余的任务以提高系统性能。在下一节中，我们将讨论如何等待运行中的任务。
- en: How to wait on running tasks
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何等待运行中的任务
- en: In the previous examples, we called the `Task.Result` property to get a result
    from a completed task. This blocks the calling thread until a result is available.
    TPL provides another way for us to wait on one or more tasks.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的示例中，我们调用了`Task.Result`属性来从已完成的任务中获取结果。这会阻塞调用线程，直到结果可用。TPL为我们提供了另一种等待一个或多个任务的方法。
- en: 'There are various APIs available in TPL so that we can wait on one or more
    tasks. These are as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: TPL中有各种API可供我们等待一个或多个任务。这些包括：
- en: '`Task.Wait`'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Task.Wait`'
- en: '`Task.WaitAll`'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Task.WaitAll`'
- en: '`Task.WaitAny`'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Task.WaitAny`'
- en: '`Task.WhenAll`'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Task.WhenAll`'
- en: '`Task.WhenAny`'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Task.WhenAny`'
- en: These APIs will be defined in the following subsections.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这些API将在以下子节中定义。
- en: Task.Wait
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Task.Wait
- en: 'This is an instance method that can be used to wait on a single task. We can
    specify the maximum amount of time for which the caller will wait for the task
    to complete before unblocking itself with a timeout exception. We can also have
    full control over monitoring events that have been canceled by passing a cancellation
    token to the method. The calling method will be blocked until the thread either
    completes, is canceled, or throws an exception:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个实例方法，用于等待单个任务。我们可以指定调用者等待任务完成的最长时间，然后在超时异常中解除阻塞。我们还可以通过向方法传递取消令牌来完全控制已取消的监视事件。调用方法将被阻塞，直到线程完成、取消或抛出异常：
- en: '[PRE23]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'There are five overloaded versions of the `Wait` method:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`Wait`方法有五个重载版本：'
- en: '`Wait()`:Waits indefinitely for the task to finish. The calling thread is blocked
    until the child thread has finished.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Wait()`:无限期地等待任务完成。调用线程将被阻塞，直到子线程完成。'
- en: '`Wait(CancellationToken)`:Waits for the task to finish execution indefinitely
    or when the cancellation token is canceled.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Wait(CancellationToken)`:等待任务无限期地执行或取消令牌被取消时。'
- en: '`Wait(int)`: Waits for the task to finish execution within a specified period
    of time, in milliseconds.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Wait(int)`:在指定的时间段内等待任务完成执行，以毫秒为单位。'
- en: '`Wait(TimeSpan)`: Waits for the task to finish execution within a specified
    time interval.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Wait(TimeSpan)`:在指定的时间间隔内等待任务完成执行。'
- en: '`Wait(int, CancellationToken)`: Waits for the task to finish execution within
    a specified period of time, in milliseconds, or when the cancellation token is
    canceled.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Wait(int, CancellationToken)`:在指定的时间段内等待任务完成执行，以毫秒为单位，或者取消令牌被取消时。'
- en: Task.WaitAll
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Task.WaitAll
- en: 'This is a static method that is defined in the `Task` class and used to wait
    on multiple tasks. The tasks are passed as an array to the method and the caller
    is blocked until all the tasks are completed. This method also supports timeout
    and cancellation tokens. Some example code that uses this method is as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`Task`类中定义的静态方法，用于等待多个任务。任务作为数组传递给方法，调用者将被阻塞，直到所有任务完成。该方法还支持超时和取消令牌。使用此方法的一些示例代码如下：
- en: '[PRE24]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The output of the preceding code is as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '![](img/d8f72c1c-e31b-45b7-a3f7-083ea597cfa8.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d8f72c1c-e31b-45b7-a3f7-083ea597cfa8.png)'
- en: As you can see, the Calling method finishes statement is executed when both
    tasks have finished executing.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，当两个任务都完成执行时，调用方法完成语句被执行。
- en: An example use case of this method might be when we need data from multiple
    sources (we have one task for each source) and we want to combine the data from
    all the tasks so that they can be displayed on the UI.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法的一个示例用例可能是当我们需要来自多个来源的数据（我们为每个来源都有一个任务），并且我们希望将所有任务的数据组合起来，以便在UI上显示。
- en: Task.WaitAny
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Task.WaitAny
- en: 'This is another static method that is defined in the `Task` class. Just like
    `WaitAll`, `WaitAny` is used to wait on multiple tasks, but the caller is unblocked
    as soon as any of the tasks that are passed as arrays to the method finish executing.
    Like the other methods, `WaitAny` supports the timeout and cancellation tokens.
    Some example code that uses this method is as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`Task`类中定义的另一个静态方法。就像`WaitAll`一样，`WaitAny`用于等待多个任务，但只要传递给方法的任何任务完成执行，调用者就会解除阻塞。与其他方法一样，`WaitAny`支持超时和取消令牌。使用此方法的一些示例代码如下：
- en: '[PRE25]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the preceding code, we started two tasks and waited on them using `WaitAny`.
    This method blocks the current thread. As soon as any of the tasks complete, the
    calling thread is unblocked.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们启动了两个任务，并使用`WaitAny`等待它们。这个方法会阻塞当前线程。一旦任何一个任务完成，调用线程就会解除阻塞。
- en: An example use case of this method might be when the data we require is available
    from different sources and we need it as quickly as possible. Here, we create
    tasks that make requests to different sources. As soon as any of the tasks finish,
    we will unblock the calling thread and get the result from the finished task.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法的一个示例用例可能是当我们需要的数据来自不同的来源并且我们需要尽快获取它时。在这里，我们创建了请求不同来源的任务。一旦任何一个任务完成，我们将解除调用线程的阻塞并从完成的任务中获取结果。
- en: Task.WhenAll
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Task.WhenAll
- en: 'This is a non-blocking variant of the `WaitAll` method. It returns a task that
    represents a waiting action for all of the specified tasks. Unlike `WaitAll`,
    which blocks the calling thread, `WhenAll` can be awaited inside an asynchronous
    method, thus freeing up the calling thread to perform other operations. Some example
    code that uses this method is as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`WaitAll`方法的非阻塞变体。它返回一个代表所有指定任务的等待操作的任务。与阻塞调用线程的`WaitAll`不同，`WhenAll`可以在异步方法中等待，从而释放调用线程以执行其他操作。使用此方法的一些示例代码如下：
- en: '[PRE26]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This code works the same way as `Task.WaitAll`, apart from the fact that the
    calling thread returns to the `ThreadPool` instead of being blocked.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的工作方式与`Task.WaitAll`相同，除了调用线程返回到`ThreadPool`而不是被阻塞。
- en: Task.WhenAny
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Task.WhenAny
- en: 'This is a non-blocking variant of `WaitAny`. It returns a task that encapsulates
    a waiting action on a single underlying task. Unlike `WaitAny`, it doesn''t block
    the calling thread. The calling thread can call await on it inside an asynchronous
    method. Some example code that uses this method is as follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This code works the same way as `Task.WaitAny`, apart from the fact that the
    calling thread returns to the `ThreadPool` instead of being blocked.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we discussed how to write efficient code while working with
    multiple threads without code branching. Code flow looks synchronous though it
    works in parallel wherever required. In the next section, we will learn about
    how tasks deal with exceptions.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Handling task exceptions
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Exception handling is one of the most important aspects of parallel programming.
    All good clean code practitioners focus on handling exceptions efficiently. This
    becomes even more important with parallel programming as any unhandled exceptions
    in threads or tasks can cause the application to crash abruptly. Fortunately,
    TPL provides a nice, efficient design to handle and manage exceptions. Any unhandled
    exceptions that occur in a task are deferred and then propagated to a joining
    thread, which observes the task for exceptions.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: Any exception that occurs inside a task is always wrapped under the `AggregateException`
    class and returned to the caller that is observing the exceptions. If the caller
    is waiting on a single task, the inner exception property of the `AggregateException` class
    will return the original exception. If the caller is waiting for multiple tasks,
    however, such as `Task.WaitAll`, `Task.WhenAll`, `Task.WaitAny`, or `Task.WhenAny`,
    all the exceptions that occur from tasks are returned to the caller as a collection.
    They are accessible via the `InnerExceptions` property.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's look at the various ways we can handle exceptions inside tasks.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: Handling exception from single tasks
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the following code, we''re creating a simple task that tries to divide a
    number by 0, thereby causing a `DivideByZeroException`. The exception is returned
    to the caller and handled inside the catch block. Since it''s a single task, the
    exception object is wrapped under the `InnerException` property of the `AggregateException`
    object:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The following is the output when we run the preceding code:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f806dff4-80eb-4d19-88da-254dbe97be32.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
- en: Handling exceptions from multiple tasks
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we''ll create multiple tasks and then try to throw exceptions from them.
    Then, we''ll learn how to list different exceptions from different tasks from
    the caller:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Here is the output when we run the preceding code:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e1465881-0a19-42c5-979e-243cdf7845c6.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
- en: In the preceding code, we created three tasks that throw different exceptions
    and all threads are awaited using `Task.WaitAll`. As you can see, the exceptions
    are observed by calling `WaitAll` and not just by starting the task, which is
    why we wrapped `WaitAll` inside the `try` block. The `WaitAll` method will return
    when all the tasks that have been passed to it have faulted by throwing exceptions
    and the corresponding `catch` block is executed. We can find all the exceptions
    that originated from all the tasks by iterating over the `InnerExceptions` property
    of the `AggregateException` class.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: Handling task exceptions with a callback function
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another option to find out about these exceptions is to use the callback function
    to access and handle the exceptions that originate from tasks:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Here is the output when we run the preceding code in Visual Studio:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/68deb400-78ae-4c72-9467-8a6008210a12.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
- en: As shown in the preceding code, rather than integrating over `InnerExceptions`,
    we have subscribed to the handle callback function on `AggregateException`. This
    is fired for all the tasks that throw the exception and we can return `true`,
    indicating that the exception has been handled gracefully.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: Converting APM patterns into tasks
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The legacy APM approach used the `IAsyncResult` interface to create asynchronous
    methods with a design pattern using two methods: `BeginMethodName` and `EndMethodName`.
    Let''s try to understand the journey of a program from being synchronous, to an
    APM, and then to a task.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的APM方法使用`IAsyncResult`接口来创建使用两种方法设计模式的异步方法：`BeginMethodName`和`EndMethodName`。让我们试着理解程序从同步到APM再到任务的过程。
- en: 'Here is a synchronous method that reads data from a text file:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个从文本文件中读取数据的同步方法：
- en: '[PRE31]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'There is nothing fancy in the preceding code. First, we created a `FileStream`
    object and called the `Read` method, which reads the file from the disk synchronously
    into a buffer and then writes the buffer to the console. We converted the buffer
    into a string using the `UTF8Encoding` class. The problem with this approach,
    however, is that the moment a call to `Read` is made, the thread is blocked until
    the read operation has finished. I/O operations are managed by the CPU using CPU
    cycles, so there is no point in keeping the thread waiting for the I/O operation
    to complete. Let''s try to understand the APM way of doing this:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中没有什么花哨的。首先，我们创建了一个`FileStream`对象并调用了`Read`方法，该方法将文件从磁盘同步读入缓冲区，然后将缓冲区写入控制台。我们使用`UTF8Encoding`类将缓冲区转换为字符串。然而，这种方法的问题在于一旦调用`Read`，线程就会被阻塞，直到读取操作完成。I/O操作由CPU使用CPU周期来管理，因此没有必要让线程等待I/O操作完成。让我们试着理解APM的做法：
- en: '[PRE32]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'As shown in the preceding code, we have replaced the synchronous `Read` method
    with an asynchronous version, that is, `BeginRead`. The moment the compiler encounters
    `BeginRead`, an instruction is sent to the CPU to start reading the file and the
    thread is unblocked. We can perform other tasks in the same method before blocking
    the thread again by calling `EndRead` to wait for the `Read` operation to finish
    and collect the result. This is a simple yet efficient approach in order to make
    responsive applications, though we are also blocking the thread to fetch results.
    Rather than calling `EndRead` in the same method, we can make use of `Overload`,
    which accepts a callback method that gets called automatically when the read operation
    finishes, to avoid blocking the thread. The signature of this method is as follows:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的代码所示，我们用异步版本替换了同步的`Read`方法，即`BeginRead`。一旦编译器遇到`BeginRead`，就会向CPU发送指令开始读取文件，并解除线程阻塞。我们可以在同一方法中执行其他任务，然后通过调用`EndRead`再次阻塞线程，等待`Read`操作完成并收集结果。这是一个简单而有效的方法，以便制作响应式应用程序，尽管我们也在阻塞线程以获取结果。我们可以使用`Overload`而不是在同一方法中调用`EndRead`，它接受一个回调方法，当读取操作完成时会自动调用，以避免阻塞线程。该方法的签名如下：
- en: '[PRE33]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Here, we have seen how we moved from a synchronous method to APM. Now, we are
    going to convert the APM implementation into a task. This is demonstrated in the
    following code:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们已经看到了我们是如何从同步方法转换为APM的。现在，我们将把APM实现转换为一个任务。这在以下代码中进行了演示：
- en: '[PRE34]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As shown in the preceding code, we replaced the `BeginRead` method with `Task<int>.Factory.FromAsync`.
    This is a way of implementing a TAP. The method returns a task, which runs in
    the background while we continue doing other work in the same method, before blocking
    the thread again to get the results using `task.Wait()`. This is how you can easily
    convert any APM code into TAP.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的代码所示，我们用`Task<int>.Factory.FromAsync`替换了`BeginRead`方法。这是一种实现TAP的方法。该方法返回一个任务，在我们在同一方法中继续做其他工作的同时在后台运行，然后通过`task.Wait()`再次阻塞线程以获取结果。这就是你可以轻松地将任何APM代码转换为TAP的方法。
- en: Converting EAPs into tasks
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将EAP转换为任务
- en: EAPs are used to create components that wrap expensive and time-consuming operations.
    Due to this, they need to be made asynchronous. This pattern has been used in
    the .NET Framework to create components such as `BackgroundWorker` and `WebClient`.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: EAP用于创建包装昂贵和耗时操作的组件。因此，它们需要被异步化。这种模式已经被用于.NET Framework中创建诸如`BackgroundWorker`和`WebClient`等组件。
- en: Methods that implement this pattern carry out long-running tasks asynchronously
    in the background but keep notifying the user of their progress and status via
    events, which is why they are known as event-based.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这种模式的方法在后台异步执行长时间运行的任务，但通过事件不断通知用户它们的进度和状态，这就是为什么它们被称为基于事件的。
- en: 'The following code shows an implementation of a component that uses EAP:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了一个使用EAP的组件的实现：
- en: '[PRE35]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In the preceding code, we subscribed to the `DownloadStringCompleted` event,
    which gets fired once `webClient` has downloaded the file from the URL. As you
    can see, we tried to read various result options, such as exception, cancellation,
    and result, using the if-else construct. Converting EAP into TAP is tricky compared
    to APM as it requires a good understanding of the internal nature of EAP components
    because we need to plug the new code into the correct events to make it work.
    Let''s take a look at the converted implementation:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们订阅了`DownloadStringCompleted`事件，一旦`webClient`从URL下载文件，该事件就会触发。正如你所看到的，我们尝试使用if-else结构来读取各种结果选项，如异常、取消和结果。与APM相比，将EAP转换为TAP更加棘手，因为它需要对EAP组件的内部性质有很好的理解，因为我们需要将新代码插入到正确的事件中使其工作。让我们来看一下转换后的实现：
- en: '[PRE36]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The simplest way of converting EAP into TAP is via the `TaskCompletionSource`
    class. We have plugged in all the scenarios and set the result, exception, or
    cancellation results to the instance of the `TaskCompletionSource` class. Then,
    we returned the wrapped implementation as a task to the user.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 将EAP转换为TAP的最简单方法是使用`TaskCompletionSource`类。我们已经插入了所有的情景，并将结果、异常或取消结果设置为`TaskCompletionSource`类的实例。然后，我们将包装的实现作为任务返回给用户。
- en: More on tasks
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多关于任务
- en: Now, let's learn some more important concepts about tasks that might come in
    handy. Up until now, we have created tasks that are independent. To create more
    complex solutions, however, we sometimes need to define relationships between
    tasks. We can create subtasks, child tasks, as well as continuation tasks to do
    this. Let's try to understand each of these with examples. Later in this section,
    we will learn about thread storage and queues.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: Continuation tasks
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Continuation tasks work more like promises. We can make use of them when we
    need to chain multiple tasks. The second task starts when the first one finishes
    and the result of the first task or the exceptions are passed to the child task.
    We can chain more than one task to create a long chain of tasks, or we can create
    a selective continuation chain with the methods provided by TPL. The following
    constructs are provided by TPL for task continuation:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '`Task.ContinueWith`'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Task.Factory.ContinueWhenAll`'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Task.Factory.ContinueWhenAll<T>`'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Task.Factory.ContinueWhenAny`'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Task.Factory.ContinueWhenAny<T>`'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Continuing tasks using the Task.ContinueWith method
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The continuation of a task can be easily achieved using the `ContinueWith` method
    that's provided by TPL.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try to understand simple chaining with an example:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In the preceding example, we need to fetch and display data. The **primary
    task** calls the `FetchData` method. When it has finished, the result is passed
    as input to the **continuation task**, which takes care of printing the data.
    The output is as follows:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7f9e4067-d9cf-4c5d-8f73-8e08028d1cf7.png)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
- en: 'We can chain multiple tasks as well, thereby creating a chain of tasks, as
    shown here:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We can control when the continuation task will run by passing the `System.Threading.Tasks.TaskContinuationOptions`
    enumeration as a parameter that has the following options:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '`None`: This is the default option. The continuation task will run when the
    primary task has completed.'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnlyOnRanToCompletion`: The continuation task will run when the primary task
    has completed successfully, meaning it has not canceled or faulted.'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NotOnRanToCompletion`: The continuation task will run when the primary task
    has been canceled or faulted.'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnlyOnFaulted`: The continuation task will run only when the primary task
    has faulted.'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NotOnFaulted`: The continuation task will run only when the primary task has
    not faulted.'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnlyOnCancelled`: The continuation task will run only when the primary task
    has been canceled.'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NotOnCancelled`: The continuation task will run only when the primary task
    has not been canceled.'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Continuing tasks using Task.Factory.ContinueWhenAll and Task.Factory.ContinueWhenAll<T>
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can wait for multiple tasks and chain a continuation code that will only
    run when all the tasks are completed successfully. Let''s look at an example:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In the preceding code, we want to calculate `a*a + b*b +2 *a *b`. We break
    down the task into three units: `a*a`, `b*b`, and `2*a*b`. Each of these units
    is executed by three different threads: `taskA`, `taskB`, and `taskC`. Then, we
    wait for all the tasks to finish and pass them as a first parameter to the `ContinueWhenAll`
    method. When all the threads finish executing, the continuation delegate executes,
    which is specified by the second parameter to the `ContinueWhenAll` method. The
    continuation delegate sums the result of the execution from all the threads and
    returns them to the caller, which is printed in the next line.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: Continuing tasks using Task.Factory.ContinueWhenAny and Task.Factory.ContinueWhenAny<T>
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can wait for multiple tasks and chains in continuation code that will run
    when any of the tasks are completed successfully:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: As shown in the preceding code, we have three different pieces of logic to find
    out whether a number is odd. Let's assume that we don't know which of these pieces
    of logic is going to be the fastest. To calculate the result, we create three
    tasks, each of which encapsulates a different odd-number-finding logic, and run
    them concurrently. Since a number can be either odd or even at a time, the result
    from all the threads will be the same and will differ in terms of their speed
    of execution. Due to this, it makes sense to just get the first result and discard
    the rest. This is what we have achieved using the `ContinueWhenAny` method.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: Parent and child tasks
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another type of relationship that can occur between threads is a parent-child
    relationship. The child task is created as a nested task inside the body of the
    parent task. The child task can be created either as attached or detached. Both
    types of tasks are created inside the parent task and, by default, the created
    tasks are detached. We can make an attached task by setting the `AttachedToParent`
    property of the task to `true`. You may want to consider creating an attached
    task in any of the following scenarios:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: All the exceptions that are thrown in the child task need to be propagated to
    the parent
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The status of the parent task is dependent on the child task
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The parent needs to wait for the child task to finish
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a detached task
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code to create a detached class is as follows:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'As you can see, we have created another task within the body of a task. By
    default, the child or nested task is created as detached. We waited for the parent
    task to finish by calling `parentTask.Wait()`. In the following output, you can
    see that the parent task doesn''t wait for the child task to finish and finishes
    first, followed by the child task starting:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3b1d53c7-a4a2-40a7-8dcd-ef1160ffd33d.png)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
- en: Creating an attached task
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An attached task is created similarly to a detached one. The only difference
    is that we set the `AttachedParent` property of the task to `true`. This is demonstrated
    in the following snippet:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The output is as follows:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3d5d2a16-4cbe-48c5-8ecd-66c57980b423.png)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
- en: Here, you can see that the parent task does not finish until the child task
    has finished executing.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we discussed advanced aspects of tasks, including creating
    relationships among tasks. In the next section, we will dig more into working
    internally on tasks by understanding the concept of work queues and how tasks
    deal with them.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: Work-stealing queues
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Work-stealing is a performance optimization technique for a thread pool. Every
    thread pool maintains a single global queue of tasks that are created inside a
    process. In [Chapter 1](ec9722fc-d60f-410b-9db6-edd401804d3c.xhtml), *Introduction
    to Parallel Programming*, we learned that the thread pool maintains an optimal
    number of worker threads to work on tasks. The `ThreadPool` also maintains a thread
    global queue, where it queues all the work items before they can be assigned to
    available threads. Since this is a single queue and we work in multithreaded scenarios,
    we need to implement thread-safety using synchronization primitives. With a single
    global queue, synchronization leads to performance loss.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: The .NET Framework works around this performance loss by introducing the concept
    of local queues, which are managed by threads. Each thread has access to a global
    queue and also maintains its own thread-local queue to store work items in. Parent
    tasks can be scheduled inside the global queue. When tasks execute and need to
    create subtasks, they can be stacked up on local queues and processed using the
    FIFO algorithm as soon as the thread finishes executing.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram depicts the relationship between a global queue, a local
    queue, the thread, and the `Threadpool`:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f8426a23-055d-4869-ba04-97bc06d88270.png)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
- en: 'Let''s say that the main thread creates a set of tasks. All of these tasks
    are queued to the global queue to be executed later based on the availability
    of the thread inside the thread pool. The following diagram depicts the global
    queue with all the queued tasks:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/df6416be-11a8-4b46-9021-b2016fb2b9e9.png)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
- en: 'Let''s say **Task 1** is scheduled on **Thread 1**, **Task 2** on **Thread
    2**, and so on, as shown in the following diagram:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6dd8f4d1-e506-4240-9917-bf715c603c82.png)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
- en: 'If **Task 1** and **Task 2** generate more tasks, the new tasks will be stored
    in the thread-local queue, as shown in the following diagram:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d08e9c26-4b93-413a-8a96-3f403a3877a3.png)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
- en: Similarly, if more tasks are created by these child tasks, they will go inside
    the local queue instead of the global queue. Once **Thread 1** has finished with
    **Task 1**, it will look into its local queues and pick up the last task (LIFO).
    There is a high chance that the last task may still be in the cache and so it
    doesn't need to be reloaded. Again, this improves performance.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: Once a thread (T1) exhausts its local queue, it will search in the global queue.
    If there are no items in the global queue, it will search in the local queues
    for other threads (say T2). This technique is called work-stealing and is an optimization
    technique. This time, it doesn't pick the last task (LIFO) from T2 since the last
    item may still be in the T2 thread's cache. Instead, it picks up the first task
    (FIFO) since there is a high chance that the thread has moved out of T2's cache.
    This technique improves performance by making cached tasks available to the local
    thread and out-of-cache tasks to other threads.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have discussed how to break up tasks into smaller units
    so that each unit can be handled independently by a thread. We have also learned
    about various ways we can create tasks by utilizing `ThreadPool`. We introduced
    various techniques related to the internal workings of tasks, including the concepts
    of work-stealing and task creation or cancellation. We will be utilizing the knowledge
    we gained in this chapter in the rest of this book.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will introduce the concepts of data parallelism. This
    will include working with parallel loops and handling exceptions in them.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
