- en: Task Parallelism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we introduced the concept of parallel programming.
    In this chapter, we will move on to discussing TPL and task parallelism.
  prefs: []
  type: TYPE_NORMAL
- en: One of the major goals of .NET as a programming framework is to make a developer's
    life easier by wrapping up all the commonly required tasks as APIs. As we have
    already seen, threads have existed since the earliest versions of .NET, but they
    were initially very complex and were associated with a lot of overhead. Microsoft
    has introduced a lot of new parallel primitives that make it easier to write,
    debug, and maintain parallel programs from scratch, without having to deal with
    the complexities that are involved with legacy threading.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating and starting a task
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting results from finished tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to cancel tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to wait on running tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling task exceptions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting **Asynchronous Programming Model** (**APM**) patterns into tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting **Event-Based Asynchronous Patterns** (**EAPs**) into tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'More on tasks:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Continuation tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parent and child tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Local and global queues and storage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Work-stealing queues
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To complete this chapter, you should have a good understanding of C# and some
    advanced concepts such as delegates.
  prefs: []
  type: TYPE_NORMAL
- en: The source code for this chapter is available on GitHub at [https://github.com/PacktPublishing/Hands-On-Parallel-Programming-with-C-8-and-.NET-Core-3/tree/master/Chapter02](https://github.com/PacktPublishing/Hands-On-Parallel-Programming-with-C-8-and-.NET-Core-3/tree/master/Chapter02).
  prefs: []
  type: TYPE_NORMAL
- en: Tasks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Tasks** are abstractions in .NET that provide units of asynchrony, just like
    promises in JavaScript. In initial versions of .NET, we had to rely on threads
    only, which were created either directly or using the `ThreadPool` class. The
    `ThreadPool` class provided a managed abstraction layer over threads but developers still relied
    on the `Thread` class for better control. By creating a thread via the `Thread`
    class, we gained access to the underlying object, which we can wait for, cancel,
    or move to the foreground or background. In real time, however, we required threads
    to perform work continuously. This required us to write lots of code, which was
    difficult to maintain. The `Thread` class was also unmanaged, which put a high
    burden on both the memory and the CPU. We needed the best of both worlds, which
    is where tasks come to the rescue. A task is nothing but a wrapper over a thread,
    which is created via `ThreadPool`. Tasks provide features such as await, cancellation,
    and continuation, and these run after a task has finished.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Tasks have the following important features:'
  prefs: []
  type: TYPE_NORMAL
- en: Tasks are executed by a `TaskScheduler` and the default scheduler simply runs
    on `ThreadPool`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can return values from tasks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tasks let you know when they finish, unlike `ThreadPool` or threads.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A task can be run in continuation using the `ContinueWith()` construct.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can wait on tasks by calling `Task.Wait()`. This blocks the calling thread
    until it has finished.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tasks make the code much more readable compared to legacy threads or `ThreadPool`.
    They also paved the way to the introduction of the asynchronous programming construct
    in C# 5.0.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can establish a parent/child relationship when one task is started from another
    task.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can propagate child task exceptions to parent tasks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A task can be canceled using the `CancellationToken` class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating and starting a task
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are many ways in which we can create and run a task using the TPL. In
    this section, we will try to understand all of these approaches and do a comparative
    analysis wherever we can. First, you need to add a reference to the `System.Threading.Tasks`
    namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We will try to create a task using the following approaches:'
  prefs: []
  type: TYPE_NORMAL
- en: The `System.Threading.Tasks.Task` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `System.Threading.Tasks.Task.Factory.StartNew` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `System.Threading.Tasks.Task.Run` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`System.Threading.Tasks.Task.Delay`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`System.Threading.Tasks.Task.Yield`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`System.Threading.Tasks.Task.FromResult<T> Method`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`System.Threading.Tasks.Task.FromException` and `Task.FromException<T>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`System.Threading.Tasks.Task.FromCancelled` and `Task.FromCancelled<T>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The System.Threading.Tasks.Task class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A task class is a way of executing work asynchronously as a `ThreadPool` thread
    and is based on the **Task-Based Asynchronous Pattern** (**TAP**). The non-generic `Task`
    class doesn't return results, so whenever we need to return values from a task,
    we need to use the generic version, `Task<T>`. The tasks that are created via
    the `Task` class are not scheduled to run until we call the `Start` method.
  prefs: []
  type: TYPE_NORMAL
- en: We can create a task using the `Task` class in various ways, all of which we'll
    cover in the following subsections.
  prefs: []
  type: TYPE_NORMAL
- en: Using lambda expressions syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the following code, we are creating a task by calling the `Task` constructor
    and passing a lambda expression containing the method we want to execute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Using the Action delegate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the following code, we are creating a task by calling the `Task` constructor
    and passing a delegate containing the method we want to execute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Using delegate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the following code, we are creating a `task` object by calling the `Task`
    constructor and passing an anonymous `delegate` containing the method we want
    to execute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In all of these cases, the output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/40ef715e-dff5-40e9-a0a0-acafb3317b7c.png)'
  prefs: []
  type: TYPE_IMG
- en: All the preceding methods do the same thing – they just have different syntaxes.
  prefs: []
  type: TYPE_NORMAL
- en: We can only call the `Start` method on tasks that have not run previously. If
    you need to rerun a task that has already been completed, you need to create a
    new task and call the `Start` method on that.
  prefs: []
  type: TYPE_NORMAL
- en: The System.Threading.Tasks.Task.Factory.StartNew method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can also create a task using the `StartNew` method of the `TaskFactory` class,
    as follows. In this approach, the task is created and scheduled for execution
    inside the `ThreadPool` and a reference of that `Task` is returned to the caller.
  prefs: []
  type: TYPE_NORMAL
- en: We can create a task using the `Task.Factory.StartNew` method. We'll go over
    this in the following subsections.
  prefs: []
  type: TYPE_NORMAL
- en: Using lambda expressions syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the following code, we are creating a `Task` by calling the `StartNew()`
    method on `TaskFactory` and passing a lambda expression containing the method
    we want to execute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Using the Action delegate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the following code, we are creating a `Task` by calling the `StartNew()`
    method on `TaskFactory` and passing a delegate wrapping method that we want to
    execute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Using delegate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the following code, we are creating a `Task` by calling the `StartNew()`
    method on `TaskFactory` and passing the `delegate` wrapping method we want to
    execute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: All the preceding methods do the same thing – they just have different syntaxes.
  prefs: []
  type: TYPE_NORMAL
- en: The System.Threading.Tasks.Task.Run method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can also create a task using the `Task.Run` method. This works just like
    the `StartNew` method and returns a `ThreadPool` thread.
  prefs: []
  type: TYPE_NORMAL
- en: We can create a `Task` using the `Task.Run` method in the following ways, all
    of which will be discussed in the following subsections.
  prefs: []
  type: TYPE_NORMAL
- en: Using lambda expressions syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the following code, we are creating a `Task` by calling the static `Run()`
    method on `Task` and passing a lambda expression containing the method we want
    to execute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Using the Action delegate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the following code, we are creating a `Task` by calling the static `Run()`
    method on `Task` and passing a delegate containing the method we want to execute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Using delegate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the following code, we are creating a `Task` by calling the static `Run()`
    method on `Task` and passing a `delegate` containing the method we want to execute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The System.Threading.Tasks.Task.Delay method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can create a task that completes after a specified interval of time or that
    can be canceled at any time by the user using the `CancellationToken` class. In
    the past, we used the `Thread.Sleep()` method of the `Thread` class to create
    blocking constructs to wait on other tasks. The problem with this approach, however,
    was that it still used CPU resources and ran synchronously. `Task.Delay` provides
    a better alternative to waiting on tasks without utilizing CPU cycles. It also
    runs asynchronously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code asks the user a question and then waits for two seconds before
    presenting the answer. During those two seconds, the main thread doesn't have
    to wait but has to carry out other tasks to improve the user's experience. The
    code runs asynchronously on the system clock and, once the time expires, the rest
    of the code is executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e92b0ddd-683c-4c1f-92e9-6d9092ff30b0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Before looking at the other methods we can use to create a task, we''ll take
    a look at two asynchronous programming constructs that were introduced in C# 5.0:
    the `async` and `await` keywords.'
  prefs: []
  type: TYPE_NORMAL
- en: '`async` and `await` are code markers that make it easier for us to write asynchronous
    programs. We will learn about these keywords in depth in [Chapter 9](1b0d3653-dd80-486b-96fc-b17000f9439d.xhtml),
    *Async, Await, and Task-Based Asynchronous Programming Basics**.* As the name
    suggests, we can wait on any asynchronous call using the `await` keyword. The
    moment the executing thread encounters the `await` keyword inside a method, it
    returns to `ThreadPool`, marks the rest of the method as a continuation delegate,
    and starts executing the other queued tasks. Once the asynchronous task finishes,
    any available thread from `ThreadPool` finishes the rest of the method.'
  prefs: []
  type: TYPE_NORMAL
- en: The System.Threading.Tasks.Task.Yield method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is another way of creating an `await` task. The underlying task is not
    directly accessible to the caller but is used in some scenarios involving asynchronous
    programming that are related to program execution. It is more like a promise than
    a task. Using `Task.Yield`, we can force our method to be asynchronous and return
    control to the OS. When the rest of the method executes at a later point in time,
    it may still run as asynchronous code. We can achieve the same effect using the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This approach can be used to make UI applications responsive by providing control
    to the UI thread from time to time inside long-running tasks. However, this is
    not the preferred approach for UI applications. There are better alternatives,
    which are available in the form of `Application.DoEvents()` in WinForms and `Dispatcher.Yield
    (DispatcherPriority.ApplicationIdle)` in WPF:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In the case of console or web applications, when we run the code and apply a
    breakpoint on the task's yield, we will see random thread pool threads switching
    context to run the code. The following screenshots depict various threads controlling
    execution at various stages.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows all the threads executing at the same time in
    the program flow. We can see that the current thread ID is 1664:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5a633f20-226e-49d4-aa64-3d7f3ca6092d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If we press *F5* and allow the breakpoint to get hit for another value of `i`,
    we will see that the code is now being executed by another thread with an ID of 10244:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e7dd5bc6-0a11-4692-8ade-63a6fef19e9d.png)'
  prefs: []
  type: TYPE_IMG
- en: We will learn more about thread windows and debugging techniques in [Chapter
    11](86c487fc-641d-47e9-9270-e9d667bca405.xhtml), *Writing Unit Test Cases for
    Parallel and Asynchronous Code*.
  prefs: []
  type: TYPE_NORMAL
- en: The System.Threading.Tasks.Task.FromResult<T> method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This approach, which was introduced recently in .NET framework 4.5, is very
    much underrated. We can return a completed task with results via this approach,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the preceding code, we have actually converted a synchronous
    `Sum` method to return results in an asynchronous manner using the `Task.FromResult<int>`
    class. This approach is frequently used in TDD for mocking asynchronous methods,
    as well as inside asynchronous methods to return default values based on conditions.
    We will explain these approaches in [Chapter 11](86c487fc-641d-47e9-9270-e9d667bca405.xhtml), *Writing
    Unit Test Cases for Parallel and Asynchronous Code**.*
  prefs: []
  type: TYPE_NORMAL
- en: The System.Threading.Tasks.Task.FromException and System.Threading.Tasks.Task.FromException<T>
    methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These methods create tasks that have completed with a predefined exception
    and are used to throw exceptions from asynchronous tasks, as well as in TDD. We
    will explain this approach further in [Chapter 11](86c487fc-641d-47e9-9270-e9d667bca405.xhtml), *Writing
    Unit Test Cases for Parallel and Asynchronous Code*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the preceding code, we are wrapping `FileNotFoundException`
    as a task and returning it to the caller.
  prefs: []
  type: TYPE_NORMAL
- en: The System.Threading.Tasks.Task.FromCanceled and System.Threading.Tasks.Task.FromCanceled<T>
    methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These methods are used to create tasks that have completed as a result of cancellation
    via the cancellation token:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the preceding code, we created a cancellation token using the `CancellationTokenSource`
    class. Then, we created a task from that token. The important thing to consider
    here is that the token needs to be canceled before we can use it with the `Task.FromCanceled`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: This approach is useful if we want to return values from asynchronous methods,
    as well as in TDD.
  prefs: []
  type: TYPE_NORMAL
- en: Getting results from finished tasks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To return values from tasks, TPL provides a generic variant of all of the classes
    that we defined previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Task<T>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Task.Factory.StartNew<T>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Task.Run<T>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once a task finishes, we should be able to get results from it by accessing
    the `Task.Result` property. Let''s try to understand this using some code examples.
    We will create various tasks and try to return values from them on completion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the preceding code, we have created tasks using generic variants.
    Once they finished, we were able to get the results using the result property:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bc4ef585-380d-4bed-82c2-49d3ea97a72a.png)'
  prefs: []
  type: TYPE_IMG
- en: In the next section, we will learn about how we can cancel tasks.
  prefs: []
  type: TYPE_NORMAL
- en: How to cancel tasks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another important function of the TPL is to equip developers with ready-made
    data structures to cancel running tasks. Those of you that have a classic threading
    background will be aware of how difficult it used to be to make threads support
    canceling with all the custom home-grown logic, but this is no longer the case.
    The .NET Framework provides two classes to support task cancellation:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CancellationTokenSource`**: **This class is responsible for creating cancellation
    tokens and passing the cancellation request to all the tokens that were created
    via the source'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CancellationToken`**: **This class is used by listeners to monitor the current
    state of a request'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To create tasks that can be canceled, we need to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an instance of the `System.Threading.CancellationTokenSource` class,
    which further provides a `System.Threading.CancellationToken` via the `Token Property`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pass the token while creating the task.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When required, call the `Cancel()` method on the `CancellationTokenSource`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's try to understand how to create a token and how to pass it to the task.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a token
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Tokens can be created using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: First, we created a `tokenSource` using the `CancellationTokenSource` constructor.
    Then, we got our token using the token property of **`tokenSource`**.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a task using tokens
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can create a task by passing `CancellationToken` as the second argument
    to the task constructor, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In the classic threading model, we used to call the `Abort()` method on a thread
    that was non-deterministic. This would stop the thread abruptly, thereby leaking
    memory if resources were unmanaged. With TPL, we can call the `Cancel` method,
    which is a cancellation token source that will, in turn, set up the `IsCancellationRequested`
    property on the token. The underlying method that's being executed by the task
    should watch for this property and should exit gracefully if it is set.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are various ways of keeping a watch of whether the token source has requested
    a cancellation:'
  prefs: []
  type: TYPE_NORMAL
- en: Polling the status of the `IsCancellationRequested` property on the token
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Registering for a request cancellation callback
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Polling the status of the token via the IsCancellationRequested property
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This approach is handy in scenarios that involve recursive methods or methods
    that contain long-running computational logic via loops. Within our method or
    loops, we write code that polls `IsCancellationRequested` at certain optimal intervals.
    If it is set, it breaks the loop by calling the `ThrowIfCancellationRequested`
    method of the `token` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is an example of canceling a task by polling the token:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we created a cancellation token via the `CancellationTokenSource`
    class. Then, we created a task by passing the token. The task executes a long-running
    method, `LongRunningSum` (simulated), which keeps polling for the `IsCancellationRequested`
    property of the token. It throws an exception if the user has called `cancellationTokenSource.Cancel()`
    before the method finishes.
  prefs: []
  type: TYPE_NORMAL
- en: Polling doesn't come with any significant performance overhead and can be used
    according to your requirements. Use it when you have full control over the work
    that's performed by the task, such as if it's core logic that you wrote yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Registering for a request cancellation using the Callback delegate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This approach makes use of a `Callback` delegate that gets invoked when the
    cancellation is requested by the underlying token. We should use this with operations
    that are blocked in a way that makes it not possible to check the value of `CancellationToken`
    in a regular fashion.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at the following code, which downloads files from a remote
    URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the preceding method, once we call the `DownloadStringAsync`
    method of `WebClient`, the control leaves the user. Although the `WebClient` class
    allows us to cancel the task via the `webClient.CancelAsync()` method, we don't
    have any control over when to invoke that.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding code can be modified to make use of a `Callback` delegate so
    that we can gain more control over task cancellation, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, in this modified version, we passed a cancellation token and
    subscribed to the cancellation callback via the `Register` method.
  prefs: []
  type: TYPE_NORMAL
- en: As soon as the user calls the `cancellationTokenSource.Cancel()` method, it
    will cancel the download operation by calling `webClient.CancelAsync()`.
  prefs: []
  type: TYPE_NORMAL
- en: '`CancellationTokenSource` works well with the legacy `ThreadPool.QueueUserWorkItem`
    as well.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is code that creates a `CancellationTokenSource` that can be passed to
    `ThreadPool` to support cancellation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In this section, we discussed various ways of canceling tasks. Canceling tasks
    can really save us a lot of CPU time in cases where tasks may have become redundant.
    For example, say we have created multiple tasks to sort a list of numbers using
    different algorithms. Although all the algorithms will return the same result
    (a sorted list of numbers), we are interested in getting results as fast as we
    can. We will accept the result for the first (fastest) algorithm and cancel the
    rest to improve system performance. In the next section, we will discuss how to
    wait on running tasks.
  prefs: []
  type: TYPE_NORMAL
- en: How to wait on running tasks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous examples, we called the `Task.Result` property to get a result
    from a completed task. This blocks the calling thread until a result is available.
    TPL provides another way for us to wait on one or more tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are various APIs available in TPL so that we can wait on one or more
    tasks. These are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Task.Wait`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Task.WaitAll`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Task.WaitAny`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Task.WhenAll`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Task.WhenAny`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These APIs will be defined in the following subsections.
  prefs: []
  type: TYPE_NORMAL
- en: Task.Wait
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is an instance method that can be used to wait on a single task. We can
    specify the maximum amount of time for which the caller will wait for the task
    to complete before unblocking itself with a timeout exception. We can also have
    full control over monitoring events that have been canceled by passing a cancellation
    token to the method. The calling method will be blocked until the thread either
    completes, is canceled, or throws an exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'There are five overloaded versions of the `Wait` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Wait()`:Waits indefinitely for the task to finish. The calling thread is blocked
    until the child thread has finished.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Wait(CancellationToken)`:Waits for the task to finish execution indefinitely
    or when the cancellation token is canceled.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Wait(int)`: Waits for the task to finish execution within a specified period
    of time, in milliseconds.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Wait(TimeSpan)`: Waits for the task to finish execution within a specified
    time interval.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Wait(int, CancellationToken)`: Waits for the task to finish execution within
    a specified period of time, in milliseconds, or when the cancellation token is
    canceled.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Task.WaitAll
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is a static method that is defined in the `Task` class and used to wait
    on multiple tasks. The tasks are passed as an array to the method and the caller
    is blocked until all the tasks are completed. This method also supports timeout
    and cancellation tokens. Some example code that uses this method is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d8f72c1c-e31b-45b7-a3f7-083ea597cfa8.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the Calling method finishes statement is executed when both
    tasks have finished executing.
  prefs: []
  type: TYPE_NORMAL
- en: An example use case of this method might be when we need data from multiple
    sources (we have one task for each source) and we want to combine the data from
    all the tasks so that they can be displayed on the UI.
  prefs: []
  type: TYPE_NORMAL
- en: Task.WaitAny
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is another static method that is defined in the `Task` class. Just like
    `WaitAll`, `WaitAny` is used to wait on multiple tasks, but the caller is unblocked
    as soon as any of the tasks that are passed as arrays to the method finish executing.
    Like the other methods, `WaitAny` supports the timeout and cancellation tokens.
    Some example code that uses this method is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we started two tasks and waited on them using `WaitAny`.
    This method blocks the current thread. As soon as any of the tasks complete, the
    calling thread is unblocked.
  prefs: []
  type: TYPE_NORMAL
- en: An example use case of this method might be when the data we require is available
    from different sources and we need it as quickly as possible. Here, we create
    tasks that make requests to different sources. As soon as any of the tasks finish,
    we will unblock the calling thread and get the result from the finished task.
  prefs: []
  type: TYPE_NORMAL
- en: Task.WhenAll
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is a non-blocking variant of the `WaitAll` method. It returns a task that
    represents a waiting action for all of the specified tasks. Unlike `WaitAll`,
    which blocks the calling thread, `WhenAll` can be awaited inside an asynchronous
    method, thus freeing up the calling thread to perform other operations. Some example
    code that uses this method is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This code works the same way as `Task.WaitAll`, apart from the fact that the
    calling thread returns to the `ThreadPool` instead of being blocked.
  prefs: []
  type: TYPE_NORMAL
- en: Task.WhenAny
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is a non-blocking variant of `WaitAny`. It returns a task that encapsulates
    a waiting action on a single underlying task. Unlike `WaitAny`, it doesn''t block
    the calling thread. The calling thread can call await on it inside an asynchronous
    method. Some example code that uses this method is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This code works the same way as `Task.WaitAny`, apart from the fact that the
    calling thread returns to the `ThreadPool` instead of being blocked.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we discussed how to write efficient code while working with
    multiple threads without code branching. Code flow looks synchronous though it
    works in parallel wherever required. In the next section, we will learn about
    how tasks deal with exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: Handling task exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Exception handling is one of the most important aspects of parallel programming.
    All good clean code practitioners focus on handling exceptions efficiently. This
    becomes even more important with parallel programming as any unhandled exceptions
    in threads or tasks can cause the application to crash abruptly. Fortunately,
    TPL provides a nice, efficient design to handle and manage exceptions. Any unhandled
    exceptions that occur in a task are deferred and then propagated to a joining
    thread, which observes the task for exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: Any exception that occurs inside a task is always wrapped under the `AggregateException`
    class and returned to the caller that is observing the exceptions. If the caller
    is waiting on a single task, the inner exception property of the `AggregateException` class
    will return the original exception. If the caller is waiting for multiple tasks,
    however, such as `Task.WaitAll`, `Task.WhenAll`, `Task.WaitAny`, or `Task.WhenAny`,
    all the exceptions that occur from tasks are returned to the caller as a collection.
    They are accessible via the `InnerExceptions` property.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's look at the various ways we can handle exceptions inside tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Handling exception from single tasks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the following code, we''re creating a simple task that tries to divide a
    number by 0, thereby causing a `DivideByZeroException`. The exception is returned
    to the caller and handled inside the catch block. Since it''s a single task, the
    exception object is wrapped under the `InnerException` property of the `AggregateException`
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output when we run the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f806dff4-80eb-4d19-88da-254dbe97be32.png)'
  prefs: []
  type: TYPE_IMG
- en: Handling exceptions from multiple tasks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we''ll create multiple tasks and then try to throw exceptions from them.
    Then, we''ll learn how to list different exceptions from different tasks from
    the caller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output when we run the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e1465881-0a19-42c5-979e-243cdf7845c6.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding code, we created three tasks that throw different exceptions
    and all threads are awaited using `Task.WaitAll`. As you can see, the exceptions
    are observed by calling `WaitAll` and not just by starting the task, which is
    why we wrapped `WaitAll` inside the `try` block. The `WaitAll` method will return
    when all the tasks that have been passed to it have faulted by throwing exceptions
    and the corresponding `catch` block is executed. We can find all the exceptions
    that originated from all the tasks by iterating over the `InnerExceptions` property
    of the `AggregateException` class.
  prefs: []
  type: TYPE_NORMAL
- en: Handling task exceptions with a callback function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another option to find out about these exceptions is to use the callback function
    to access and handle the exceptions that originate from tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output when we run the preceding code in Visual Studio:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/68deb400-78ae-4c72-9467-8a6008210a12.png)'
  prefs: []
  type: TYPE_IMG
- en: As shown in the preceding code, rather than integrating over `InnerExceptions`,
    we have subscribed to the handle callback function on `AggregateException`. This
    is fired for all the tasks that throw the exception and we can return `true`,
    indicating that the exception has been handled gracefully.
  prefs: []
  type: TYPE_NORMAL
- en: Converting APM patterns into tasks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The legacy APM approach used the `IAsyncResult` interface to create asynchronous
    methods with a design pattern using two methods: `BeginMethodName` and `EndMethodName`.
    Let''s try to understand the journey of a program from being synchronous, to an
    APM, and then to a task.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a synchronous method that reads data from a text file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'There is nothing fancy in the preceding code. First, we created a `FileStream`
    object and called the `Read` method, which reads the file from the disk synchronously
    into a buffer and then writes the buffer to the console. We converted the buffer
    into a string using the `UTF8Encoding` class. The problem with this approach,
    however, is that the moment a call to `Read` is made, the thread is blocked until
    the read operation has finished. I/O operations are managed by the CPU using CPU
    cycles, so there is no point in keeping the thread waiting for the I/O operation
    to complete. Let''s try to understand the APM way of doing this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the preceding code, we have replaced the synchronous `Read` method
    with an asynchronous version, that is, `BeginRead`. The moment the compiler encounters
    `BeginRead`, an instruction is sent to the CPU to start reading the file and the
    thread is unblocked. We can perform other tasks in the same method before blocking
    the thread again by calling `EndRead` to wait for the `Read` operation to finish
    and collect the result. This is a simple yet efficient approach in order to make
    responsive applications, though we are also blocking the thread to fetch results.
    Rather than calling `EndRead` in the same method, we can make use of `Overload`,
    which accepts a callback method that gets called automatically when the read operation
    finishes, to avoid blocking the thread. The signature of this method is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have seen how we moved from a synchronous method to APM. Now, we are
    going to convert the APM implementation into a task. This is demonstrated in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the preceding code, we replaced the `BeginRead` method with `Task<int>.Factory.FromAsync`.
    This is a way of implementing a TAP. The method returns a task, which runs in
    the background while we continue doing other work in the same method, before blocking
    the thread again to get the results using `task.Wait()`. This is how you can easily
    convert any APM code into TAP.
  prefs: []
  type: TYPE_NORMAL
- en: Converting EAPs into tasks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: EAPs are used to create components that wrap expensive and time-consuming operations.
    Due to this, they need to be made asynchronous. This pattern has been used in
    the .NET Framework to create components such as `BackgroundWorker` and `WebClient`.
  prefs: []
  type: TYPE_NORMAL
- en: Methods that implement this pattern carry out long-running tasks asynchronously
    in the background but keep notifying the user of their progress and status via
    events, which is why they are known as event-based.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows an implementation of a component that uses EAP:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we subscribed to the `DownloadStringCompleted` event,
    which gets fired once `webClient` has downloaded the file from the URL. As you
    can see, we tried to read various result options, such as exception, cancellation,
    and result, using the if-else construct. Converting EAP into TAP is tricky compared
    to APM as it requires a good understanding of the internal nature of EAP components
    because we need to plug the new code into the correct events to make it work.
    Let''s take a look at the converted implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The simplest way of converting EAP into TAP is via the `TaskCompletionSource`
    class. We have plugged in all the scenarios and set the result, exception, or
    cancellation results to the instance of the `TaskCompletionSource` class. Then,
    we returned the wrapped implementation as a task to the user.
  prefs: []
  type: TYPE_NORMAL
- en: More on tasks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, let's learn some more important concepts about tasks that might come in
    handy. Up until now, we have created tasks that are independent. To create more
    complex solutions, however, we sometimes need to define relationships between
    tasks. We can create subtasks, child tasks, as well as continuation tasks to do
    this. Let's try to understand each of these with examples. Later in this section,
    we will learn about thread storage and queues.
  prefs: []
  type: TYPE_NORMAL
- en: Continuation tasks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Continuation tasks work more like promises. We can make use of them when we
    need to chain multiple tasks. The second task starts when the first one finishes
    and the result of the first task or the exceptions are passed to the child task.
    We can chain more than one task to create a long chain of tasks, or we can create
    a selective continuation chain with the methods provided by TPL. The following
    constructs are provided by TPL for task continuation:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Task.ContinueWith`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Task.Factory.ContinueWhenAll`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Task.Factory.ContinueWhenAll<T>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Task.Factory.ContinueWhenAny`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Task.Factory.ContinueWhenAny<T>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Continuing tasks using the Task.ContinueWith method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The continuation of a task can be easily achieved using the `ContinueWith` method
    that's provided by TPL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try to understand simple chaining with an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we need to fetch and display data. The **primary
    task** calls the `FetchData` method. When it has finished, the result is passed
    as input to the **continuation task**, which takes care of printing the data.
    The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7f9e4067-d9cf-4c5d-8f73-8e08028d1cf7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can chain multiple tasks as well, thereby creating a chain of tasks, as
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We can control when the continuation task will run by passing the `System.Threading.Tasks.TaskContinuationOptions`
    enumeration as a parameter that has the following options:'
  prefs: []
  type: TYPE_NORMAL
- en: '`None`: This is the default option. The continuation task will run when the
    primary task has completed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnlyOnRanToCompletion`: The continuation task will run when the primary task
    has completed successfully, meaning it has not canceled or faulted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NotOnRanToCompletion`: The continuation task will run when the primary task
    has been canceled or faulted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnlyOnFaulted`: The continuation task will run only when the primary task
    has faulted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NotOnFaulted`: The continuation task will run only when the primary task has
    not faulted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnlyOnCancelled`: The continuation task will run only when the primary task
    has been canceled.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NotOnCancelled`: The continuation task will run only when the primary task
    has not been canceled.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Continuing tasks using Task.Factory.ContinueWhenAll and Task.Factory.ContinueWhenAll<T>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can wait for multiple tasks and chain a continuation code that will only
    run when all the tasks are completed successfully. Let''s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we want to calculate `a*a + b*b +2 *a *b`. We break
    down the task into three units: `a*a`, `b*b`, and `2*a*b`. Each of these units
    is executed by three different threads: `taskA`, `taskB`, and `taskC`. Then, we
    wait for all the tasks to finish and pass them as a first parameter to the `ContinueWhenAll`
    method. When all the threads finish executing, the continuation delegate executes,
    which is specified by the second parameter to the `ContinueWhenAll` method. The
    continuation delegate sums the result of the execution from all the threads and
    returns them to the caller, which is printed in the next line.'
  prefs: []
  type: TYPE_NORMAL
- en: Continuing tasks using Task.Factory.ContinueWhenAny and Task.Factory.ContinueWhenAny<T>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can wait for multiple tasks and chains in continuation code that will run
    when any of the tasks are completed successfully:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the preceding code, we have three different pieces of logic to find
    out whether a number is odd. Let's assume that we don't know which of these pieces
    of logic is going to be the fastest. To calculate the result, we create three
    tasks, each of which encapsulates a different odd-number-finding logic, and run
    them concurrently. Since a number can be either odd or even at a time, the result
    from all the threads will be the same and will differ in terms of their speed
    of execution. Due to this, it makes sense to just get the first result and discard
    the rest. This is what we have achieved using the `ContinueWhenAny` method.
  prefs: []
  type: TYPE_NORMAL
- en: Parent and child tasks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another type of relationship that can occur between threads is a parent-child
    relationship. The child task is created as a nested task inside the body of the
    parent task. The child task can be created either as attached or detached. Both
    types of tasks are created inside the parent task and, by default, the created
    tasks are detached. We can make an attached task by setting the `AttachedToParent`
    property of the task to `true`. You may want to consider creating an attached
    task in any of the following scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: All the exceptions that are thrown in the child task need to be propagated to
    the parent
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The status of the parent task is dependent on the child task
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The parent needs to wait for the child task to finish
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a detached task
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code to create a detached class is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we have created another task within the body of a task. By
    default, the child or nested task is created as detached. We waited for the parent
    task to finish by calling `parentTask.Wait()`. In the following output, you can
    see that the parent task doesn''t wait for the child task to finish and finishes
    first, followed by the child task starting:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3b1d53c7-a4a2-40a7-8dcd-ef1160ffd33d.png)'
  prefs: []
  type: TYPE_IMG
- en: Creating an attached task
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An attached task is created similarly to a detached one. The only difference
    is that we set the `AttachedParent` property of the task to `true`. This is demonstrated
    in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3d5d2a16-4cbe-48c5-8ecd-66c57980b423.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, you can see that the parent task does not finish until the child task
    has finished executing.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we discussed advanced aspects of tasks, including creating
    relationships among tasks. In the next section, we will dig more into working
    internally on tasks by understanding the concept of work queues and how tasks
    deal with them.
  prefs: []
  type: TYPE_NORMAL
- en: Work-stealing queues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Work-stealing is a performance optimization technique for a thread pool. Every
    thread pool maintains a single global queue of tasks that are created inside a
    process. In [Chapter 1](ec9722fc-d60f-410b-9db6-edd401804d3c.xhtml), *Introduction
    to Parallel Programming*, we learned that the thread pool maintains an optimal
    number of worker threads to work on tasks. The `ThreadPool` also maintains a thread
    global queue, where it queues all the work items before they can be assigned to
    available threads. Since this is a single queue and we work in multithreaded scenarios,
    we need to implement thread-safety using synchronization primitives. With a single
    global queue, synchronization leads to performance loss.
  prefs: []
  type: TYPE_NORMAL
- en: The .NET Framework works around this performance loss by introducing the concept
    of local queues, which are managed by threads. Each thread has access to a global
    queue and also maintains its own thread-local queue to store work items in. Parent
    tasks can be scheduled inside the global queue. When tasks execute and need to
    create subtasks, they can be stacked up on local queues and processed using the
    FIFO algorithm as soon as the thread finishes executing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram depicts the relationship between a global queue, a local
    queue, the thread, and the `Threadpool`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f8426a23-055d-4869-ba04-97bc06d88270.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s say that the main thread creates a set of tasks. All of these tasks
    are queued to the global queue to be executed later based on the availability
    of the thread inside the thread pool. The following diagram depicts the global
    queue with all the queued tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/df6416be-11a8-4b46-9021-b2016fb2b9e9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s say **Task 1** is scheduled on **Thread 1**, **Task 2** on **Thread
    2**, and so on, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6dd8f4d1-e506-4240-9917-bf715c603c82.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If **Task 1** and **Task 2** generate more tasks, the new tasks will be stored
    in the thread-local queue, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d08e9c26-4b93-413a-8a96-3f403a3877a3.png)'
  prefs: []
  type: TYPE_IMG
- en: Similarly, if more tasks are created by these child tasks, they will go inside
    the local queue instead of the global queue. Once **Thread 1** has finished with
    **Task 1**, it will look into its local queues and pick up the last task (LIFO).
    There is a high chance that the last task may still be in the cache and so it
    doesn't need to be reloaded. Again, this improves performance.
  prefs: []
  type: TYPE_NORMAL
- en: Once a thread (T1) exhausts its local queue, it will search in the global queue.
    If there are no items in the global queue, it will search in the local queues
    for other threads (say T2). This technique is called work-stealing and is an optimization
    technique. This time, it doesn't pick the last task (LIFO) from T2 since the last
    item may still be in the T2 thread's cache. Instead, it picks up the first task
    (FIFO) since there is a high chance that the thread has moved out of T2's cache.
    This technique improves performance by making cached tasks available to the local
    thread and out-of-cache tasks to other threads.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have discussed how to break up tasks into smaller units
    so that each unit can be handled independently by a thread. We have also learned
    about various ways we can create tasks by utilizing `ThreadPool`. We introduced
    various techniques related to the internal workings of tasks, including the concepts
    of work-stealing and task creation or cancellation. We will be utilizing the knowledge
    we gained in this chapter in the rest of this book.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will introduce the concepts of data parallelism. This
    will include working with parallel loops and handling exceptions in them.
  prefs: []
  type: TYPE_NORMAL
