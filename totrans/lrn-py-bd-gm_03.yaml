- en: Flow Control - Building a Decision Maker For Your Game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the greatest blessings of Python is automation. When we talk about automation,
    there is no staggering logic; it's all about the power of conditionals and branching.
    They control sequencing when it comes to the execution of programs. Any program
    at its rudimentary stage is made with a simulation. Whenever we deploy such programs
    in a real-world environment, we are overwhelmed by various noises and unexpected
    behaviors. To preclude such behavior, conditionals play a major role. Flow controls
    decide how to execute a specific part of a program based on the Boolean logic
    that's present. We covered topics such as statements and operators in the previous
    chapter, both of which are useful when it comes to creating Boolean logic. Such
    statements are used to perform arithmetic computation. In this chapter, we will
    see how to manipulate such statements, which will result in true or false Boolean
    logic.
  prefs: []
  type: TYPE_NORMAL
- en: Mid-way through this chapter, we will learn about looping, an important technique
    that will make us competent enough to make code shorter and more powerful. This
    chapter will be a package that's complete with core programming, conditionals,
    and recursive programming. We will refine the tic-tac-toe game we made in the
    previous chapter by incorporating Boolean logic and flow controls.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Boolean logic and logical operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conditionals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Iteration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`for` and `while` loops'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making a game controller for our tic-tac-toe game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You will need the following requirements to be able to complete this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Python script and IDLE
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code assets for this chapter, which can be found at [https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter03](https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter03)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Check out the following video to see the code in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://bit.ly/2pvpBas](http://bit.ly/2pvpBas)'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Boolean logic and logical operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There won''t be a day that goes by without us stating that a Boolean type is
    either `True` or `False`. We use these keywords to make logic that determines
    whether we are going to execute a certain portion of code. Let''s talk about the
    bool type in terms of a real-life scenario. If we are hungry, we eat something.
    If we are tired, we rest. Let''s convert these scenarios into the appropriate
    Boolean statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '`is_hungry = True`: `eat something || is_hungry = False: don''t eat`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`is_tired = True`: `take rest || is_tired = False: do your work`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You perform these quotidian tasks based on the Boolean logic at hand. Now,
    let''s relate this to programming; you can use two sets of code based on Boolean
    data types:'
  prefs: []
  type: TYPE_NORMAL
- en: '(`True`): `Do something || (False): Do something`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We use Boolean expressions to make such types of logic. We look at how to create
    expressions in the previous chapter. Combining a variable and an operator will
    give us a simple form of expression, as in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Boolean expressions, however, are a bit different. Instead of giving a result
    as an integer, they provide an outcome of either `True` or `False`. The simplest
    form of a Boolean expression can be made with a double equal to operator (`==`).
    Don''t confuse it with a single equal sign (`=`). This is used for assignment,
    while a double equal sign (`==`) is used to check whether they are equal, as in
    the example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If you compare the data of two different types, the result is always `False`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You can always type-caste it to make your logic `True`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'To check the type of any Boolean variable, you can use the `type()` method
    and get the output of `<class ''bool''>`, which implies that `True` or `False`
    are values of the bool type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Boolean logic can also be used with comparison operators. We will learn how
    to create statements using **comparison operators** in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Comparison operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Any expression that results in either `True` or `False` is a Boolean expression.
    These Boolean expressions cannot be made without comparison and logical operators.
    We''ve already looked at the basic comparison operator (`==`); however, there
    are six more we need to learn about (`<`, `>`, `<=`, `>=`, `!=`, and `is`). Let''s
    take a look at them in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '**5 < 10**: 5 is less than 10, which results in `True`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**5 > 10**: 5 is greater than 10, which results in `False`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**10 <= 5**: 10 is less than or equal to 5, which results in `False`. 10 is
    neither less than nor equal to 5.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**10 >= 5**: 10 is greater than or equal to 5, which results in `True`. 10
    is greater than 5.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**10 != 10**: 10 is not equal to 10, which results in `False`. 10 is equal
    to 10.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**5 is 5**: 5 is the same as 5, so this results in `True`. However, `5` is
    5, and so this results in `False`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can store the preceding numbers in different variables and try the same
    Boolean expression on the IDLE to get the following results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In order to make logic that's applicable to the real world, we need operators
    that can combine different comparison operations at once and provide results instantly.
    These types of operators are called logical operators. In the next section, we
    will learn about the different types of logical operators and the ways we can
    use them.
  prefs: []
  type: TYPE_NORMAL
- en: Logical operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Operators are widely categorized as arithmetic operators, comparison operators,
    and logical operators. We've already covered the arithmetic and comparison operators;
    now, it's high time to cover logical operators.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can relate logical operators with a logic gate (`and`, `or`, and `not`),
    which is the basic building block of any digital circuit. They have two inputs,
    but with certain circuit computations, we only get one output. Circuit processing
    is done by `and`, `or`, and `not` gates. Similar to the digital circuits of a
    logic gate, logical operators can have many conditions passed with it, but the
    output will eventually be either `True` or `False`. Here, `conditions` refer to
    our Boolean expression, which we make using comparison operators. The working
    principles of these three elementary logical operators are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`and`: Two conditions are attached with a single `and` operator, that is, `condition_one` and
    `condition_two`. The entire condition will be `True` when each of these conditions
    is also `True`. If either of the conditions that are attached to the `and` operator
    is `False`, the result will be `False`. Let''s take a look at an example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The truth table for the `and` operator, which sets out the functional value
    as either `True` or `False` based on a combination of Boolean or logical expressions,
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/1cbdcdec-5887-4d30-8e9a-2ef49e1d4f70.png)'
  prefs: []
  type: TYPE_IMG
- en: '`or`: The same as the `and` operator—two conditions are attached with a single
    `or` operator. You can add more `or` operators if you want to add more conditions.
    In the case of the `or` operator, if both of the conditions that are attached
    to it are `False`, the result will be `False`; otherwise, it will be `True`. Let''s
    look at an example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The truth table for the `or` operator, which sets out the functional value
    to either `True` or `False` based on a combination of Boolean or logical expressions,
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/e09ac0d2-26f8-4563-ab0b-9db051f44ca0.png)'
  prefs: []
  type: TYPE_IMG
- en: '`not`: This operator inverses the type of the logic. It changes `False` to
    `True` and vice versa. Hence, it is called known as a logical inverter. It only
    takes one condition with it, as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The truth table for the `not` operator, which sets out the functional value
    as either `True` or `False` based on a combination of Boolean or logical expressions,
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/af697950-80c1-49a0-a497-4dd72f8b09d8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can also represent `True` and `False` with 1 and 0 in Python. Hence, we
    can conclude that any non-zero integers can be used alone to make a condition
    with logical operators, as in the example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Learning about the different types of operators was quite fun, but now we are
    going to hop over to the section, where you will learn how to use these conditions
    (made by comparison and logical operators) to make several decisions. **Conditionals** are
    highly practical in any real-world scenario. I'm excited to learn about them—are
    you?
  prefs: []
  type: TYPE_NORMAL
- en: Conditionals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we''ve learned about making conditions with comparison and logical
    operators. Now, we''ll talk about how we can evaluate these conditions. Conditionals
    are tools that come in handy when we want to compute the result of those conditions
    and control the flow of the program accordingly. As we already know, the results
    of these conditions are going to be either `True` or `False`. So, based on the
    type of bool we use, the conditionals are going to execute some part of the code.
    We use `if` statements in Python to perform conditionals. After writing the `if`
    keyword, we put conditions next to it. The condition can be singular or a combination
    of many with logical operators. We end an `if` statement with a colon; subsequent
    statements are indented property. Take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The following figure represents a boolean logic for implementing conditional
    statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/d2d8c293-c7ed-4118-b193-d5916ac3e0aa.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Take note of the following while using Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Colon (`:`)**: If you want to declare scope in Python, inside where you can
    write more than one statement, you need to use a colon (*`:`)* to specify it.
    Most of the programming language uses curly braces (`{ }`) for this, but Python
    is strange when it comes to defining scope and the extent of block statements
    for features such as functions, `if` statements, classes, and loops. However,
    once you get familiar with using this, you will find it amusing and be able to
    distinguish code written in Python from any other language within a second.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Indentation** (**whitespaces**): After we define the scope with a colon,
    we can enter its scope. Any subsequent statements that are written within its
    scope should start with uniform white spaces, which we call indents. You can press
    the *Tab* key to give each statement a uniform indentation. Most of the errors
    that beginners make are due to improper indentation. If you don''t provide the
    proper indentation, you will get the following warning from the Python interpreter:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](Images/81e98a1c-8db6-49eb-b492-3f99c28b1b76.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If statements evaluate logical statements. Whenever that statement is true,
    its indented statement will be executed; otherwise, it will be skipped. You can
    also add the `pass` keyword to tell the interpreter not to execute anything inside
    the indented block, as in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'As we already know, Boolean statements will either will result in `True` or
    `False`. Indented code inside an `if` statement will be executed if the condition
    is `True`, but if the condition is `False`, the indented code inside the `else`
    part will be executed. Let''s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Following figure represents the flowchart for implementing program to check
    whether number is positive or negative using conditional statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/a14660a0-236f-4200-9c72-966bfc0face3.png)'
  prefs: []
  type: TYPE_IMG
- en: You can see that we have created two branches of conditions for the `True` or
    `False` logic. Based on the result of the Boolean logic, flow control is transferred
    to either side of a program. Hence, conditionals are also called *branching*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although our code is able to execute the code with two branches, there is a
    little gap in our code. If the number variable contains zero, it is neither positive
    or negative. Therefore, we have to add one more condition to this conditional.
    Whenever we need more than two branches for the computation of logic, we can make
    chained conditionals. We can add as many conditions as we like with a chained
    sequence. To perform chained conditionals with any other programming language,
    we use the `else if` command. Python improvises by making different commands with
    `elif`. Let''s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We can put any number of conditionals within one conditional statement. We
    call these nested conditionals. Let''s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, the outer conditional contains two sub-branch conditions
    where, in the first branch, we check for an even number. The next default condition
    is checked for an odd number. We use a simple single statement to make a condition
    in this example, but conditions in nested conditionals can be made complex with
    logical operators, as in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Now that you know how to make decisions with several conditional statements,
    we will take a look at a highly practical topic known as **iteration**. This allows
    us to execute a sequence of instructions. This is repeated until a certain condition
    is reached.
  prefs: []
  type: TYPE_NORMAL
- en: Iteration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s say you want to write a program where you have to print your name 100
    times. What we have learned so far dictates that the easiest way to do this is
    to use the print statement 100 times. But what if you want to print your name
    10,000 times? Writing a print statement for 2/3 pages continuously is not good
    programming. We have to use loops in such a case. Loops will help us to iterate
    over datasets until a condition is met. In each iteration, a part of the code
    is executed and we have to update the iterating variable each time. The following
    is an example of iterating over a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We update the iterating variable with an increment and decrement unit. Here,
    we update the value of `i` by adding `1` to it. This is known as incrementing.
    You can also subtract 1 from it, which is known as decrementing. Each time we
    execute code inside indented loops, we update the iteration using either increment
    or decrement statements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, there is a comparatively easier and faster way of implementing increment
    and decrement statements. You can use the following statements to perform multiple
    operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`+=` adds a number to the variable and changes the variables in its process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-=` subtracts the variable with a value and sets the new value to its resulting
    variable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*=` multiplies the variable by a value and changes the outcome of the variable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/=` divides the variable with the value and places the result on the resulting
    variable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s look at an example to see its effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The effectiveness of the increment and decrement operators can be seen with
    looping, where we repeat a set of operations multiple times. Let's take a look
    at looping in action with for and while loops. We will begin by learning about
    the `for` loop.
  prefs: []
  type: TYPE_NORMAL
- en: Th for loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Whenever you want to loop within a dataset, let''s say, within a range of numbers,
    within a certain file, or within some definite word sets, we use a `for` loop.
    It is also referred to as a definite loop. Until and unless there is certain item
    left in your bucket of items, it will iterate. The `for` loop is terminated at
    the end of the bucket. Here, bucket is a metaphor for a list of items, such as
    a list of numbers, words, or sequences, as in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the `range()` method is used to create a list of numbers.
    `range(10)` provides a list of numbers from `0` to `9`. It is stored as `[0,1,2,3,4,5,6,7,8,9]`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the first iteration, the `i` value becomes `0`, it executes code within
    the block of the `for` loop, and changes the value of `i` to the next element
    of that list automatically, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also loop within data that contains words or text. The iterating variable
    will contain a value as a word each time we loop within that list, as in this
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, the iterating variable is a `name` variable and,
    every time it iterates through that list, it fetches its value and stores it in
    `name`. Hence, we can only use the `name` variable inside the body of our `for`
    loop. No other variable can be used except the iterating variable inside the `for`
    loop. This is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, `person_names` is a type of variable where we can
    store an array of items. This variable is called a list. We will cover lists in
    the next chapter. Here, the iterating variable is `name`, which is declared with
    a `for` loop. However, inside the body of a for loop, we didn't use the `name` variable.
    Instead, we used `person_names`, which gave us `NameError`. Hence, iterating variables
    can be only used inside the body of a `for` loop.
  prefs: []
  type: TYPE_NORMAL
- en: The next type of loop we will cover is the `while` loop, which will perform
    operations similar to the `for` loop but with some tweaks. The `while` loop is
    known to be used in scenarios where we don't care about the terminating point
    of loops.
  prefs: []
  type: TYPE_NORMAL
- en: While loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another form of iteration in Python can be performed using a `while` loop.
    Let''s recall the features of a `for` loop: it''s used to iterate over a finite
    sequence of elements, either as a list of numbers, words, or files. There has
    to be a termination point if you want to use a `for` loop. We also don''t care
    about the terminating condition while using `for` loops. It''s terminated when
    it reaches to end of the items or sequences. Now, what if we want to terminate
    the loop based on custom conditions? The `while` loop is the most appropriate
    loop in such cases. We can make a custom condition where we can terminate recursion
    with the help of a `while` loop.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Both the `while` and `for` loops are going to perform incessant looping. At
    each iteration, they are going to execute body of loop. The main difference between
    the `for` and `while` loop is that the `while` loop has to declare the update
    statement and terminating condition with its declaration. First of all, we have
    to make an iterating variable, and then we have to make a terminating condition
    in order to specify a stopping point for the loop. At each iteration, we have
    to update the iterating variable, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we created an iterating variable, `i`, and assigned
    a value of 0 to it. After that, we made use of a `while` loop. To use this loop,
    we used the `while` keyword and followed that by its terminating condition. We
    tell the interpreter we want to run this loop until `i` is less than 10\. If `i`
    is equal to or greater than 10, we want to terminate this loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, we put a colon to specify the scope for our loop. Then, we added
    a simple print statement to it, which will be executed each time this loop runs.
    Finally, we added an *i = i + 1* statement to specify the updating condition.
    This is going to change the value of `i` into the new one with an increment of
    one. This is important so that we don''t end up using an infinite loop. If you
    remove your updating condition, the loop is going to run an infinite amount of
    times and the Python Terminal isn''t going to be interactive to a user''s response.
    One way of creating an infinite loop is by using a condition that has no endpoint,as
    in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding loop is an infinite loop as there is no endpoint or termination
    point attached to the `while` keyword. If we are able to change the `True` keyword
    to `False`, only this loop is going to terminate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we'll learn about the looping pattern so that we can find
    out about how loop works under the hood.
  prefs: []
  type: TYPE_NORMAL
- en: Loop pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There may be trade-offs between the `for` and `while` loops, but both work well
    when we want to loop around a known list of elements or the content of files.
    We can arrange or sort the elements out of the list or file using these loops.
    A `for` loop cannot be made to loop an infinite amount of times, but a `while`
    loop can do so using a condition that is never going to be. The main purpose of
    looping is to get items from particular files or lists so that we can process
    them further. We can sort these items based on smallest and largest or important
    and superfluous while scanning datasets.
  prefs: []
  type: TYPE_NORMAL
- en: 'The construct of the loop pattern contains the following three pinpoints:'
  prefs: []
  type: TYPE_NORMAL
- en: Making an iterating variable. There can be one or more. They are used to make
    the conditions that represent the loop's terminating point.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some computation is done inside the body of the loop so that we can manipulate
    the data items that are fetched with the loop one by one. We can also change the
    value of the iterating variable inside the loop's body, which we normally do in
    the case of a `while` loop.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Look for the possible base condition so that the loop can be terminated. Otherwise,
    it will result in an infinite loop. We have to observe the resulting variable
    after the loop ends.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want to demonstrate the construct and working paradigm of loop patterns,
    it's always a good idea to use loops with a list of items. In the following example,
    we are going to make a program where we will take a list of numbers and check
    for the smallest number in the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do this in two ways. Python makes programming easy for both types of
    people: the naive or the professional. They have various ways of implementing
    the same logic, but the most common is to use Python''s built-in methods, such
    as `min()` and `max()`. These get the smallest and largest number from the list
    of numbers in Python, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The second way to write program is by making our own logic. We should instantly
    make a decision to use loops as there are many items in this list, which means
    we have to do some comparison repeatedly. Hence, it''s always better to use looping
    if you want to perform a task repeatedly. Now, we need to decide on what to use:
    a `for` or a `while` loop. It''s better to use a `for` loop here because for loops
    work on finite lists. Each time we iterate over an iterating variable, it will
    contain an element from the list so that we can compare them with the previous
    element repeatedly. At first, we won''t have anything to be the smallest number.
    Hence, we have to make a variable that will contain a `None` value. This means
    we won''t have any value. After the first iteration, we will assign its value
    to the first element of the list. Let''s see how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s break down the preceding code into the following segments:'
  prefs: []
  type: TYPE_NORMAL
- en: In the first statement, `smallest_number = None` is assigning `None` to that
    comparing variable. We assigned `None` instead of any other number so that we
    don't miss any numbers while comparing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the second statement, we made `item` an iterating variable, which is going
    to read a list of numbers. At each iteration, it is going to store elements from
    that list. In the first iteration, the value of the item is 113\. In the second
    iteration, the value of the item is 115; at the third iteration, the value is
    55; and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are now inside the body of our `for` loop, where we have to build a comparison
    statement. First, we need to check whether the smallest number is `None` to make
    sure we are starting from the base. After that, we are going to check whether
    the current item from the list is smaller than `smallest_number`. The first iteration's
    second condition is False, but the first condition, that is, `smallest_number`,
    is `None`, that is, True, which means we are going inside the body of the conditionals.
    We will assign `smallest_value` to the first item of the list, that is, 113.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the second iteration, the item is 115\. We are going inside the `for` loop
    and checking whether 115 is smaller than the value of `smallest_numbe`, which
    is 113\. This is `False`, and so it doesn't go inside the conditional's body;
    instead, it jumps to the third iteration.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the third iteration, the item is 55\. We are going to check for the condition,
    which is going to check whether the value of the item, that is, 55, is less than
    that of `smallest_number`, which is 113\. The condition (55 < 113) is `True`,
    and so it changes the value of the `smallest_number` variable to 55\. The `for`
    loop is going to iterate until the last number of that list. It is going to use
    the same comparison operation at each iteration to give us the smallest value,
    that is, 55.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With just a change in the comparison operator, we can make a program that will
    print the largest number from the list. Instead of using the `item < smallest_number` statement,
    we can use the `item > largest_number` statement to get the largest number as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we'll look at how to use two different statements, **break
    and continue**, in order to change or skim the sequence of iteration.
  prefs: []
  type: TYPE_NORMAL
- en: The break and continue statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While writing programs, sometimes, you want to skip the execution of statements
    or stop the iteration forcefully. These operations are handled by the continue
    and break statements. They can be powerful in multiple use cases where you want
    to make a program sort the elements of a list or to break the loop when an `if`
    condition is met. The `continue` statement is used to skip the execution of the
    program. We use these statements inside the body of loops. We can sort elements
    out of lists using these statements. We can''t use both of these statements in
    a single loop, even if we use both of them together since the break is going to
    stop the loop, which will make the continue statement useless. We can use these
    statements with conditionals. Whenever a condition is met, we are going to either
    break or skip the iteration. Let''s make a program that can sort the elements
    of a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we are refining the elements of a list by keeping the
    integer numbers in the output list. Other data values, such as strings and Booleans
    are removed. First, we looped an entire list and at each iteration, the element
    is stored in the item variable. We check the type of data that are stored in the
    item variable with the `type()` method. If the type of the value that's stored
    in the item is not an integer, we are using the continue statement to infer that
    we won't do anything if it is not an integer. If the type of item is a Boolean
    or string, we are skipping that iteration with the continue statement. However,
    if the type of the value that's stored in an item variable is an integer, we are
    going to execute the statement that's inside the else part of the code. We are
    going to take that integer item and add it to the new output list, which is called `refined_items`.
    After each element is checked, we print the refined list, which is the ultimate
    collection of numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you use a `break` statement instead, things will be the same until element
    8\. But instead of printing other elements from `[89,90,11]`, our output will
    be limited to `[1,5,7,8]`. This is because the `break` statement is going to stop
    iteration after appending element 8 to the list. Hence, we can conclude that whenever
    the Python interpreter triggers a break statement, the loop is going to be terminated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We know that, while deploying programs in a real-world environment, such programs
    will be accustomed to a different scenario that our code won't be able to handle.
    In such a case, our program will terminate, which will have a negative impact
    on the user or player of the game. Hence, we have to code in such a way that our
    code can be applied to any scenario, even when it encounters unexpected errors
    or exceptions. This type of powerful technique in programming is known as **exception
    handling** and is what we will cover in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Handling exceptions using try and except
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the preceding chapter, we created a simple tic-tac-toe game. We talked about
    making some modifications at the end of that chapter. One of the modifications
    was suggested due to the deficiency of the code, which was unable to handle the
    input of a user other than an integer. What if our user enters a string as input
    to the position variable of our game? The following exception will be thrown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/a6598120-5b6e-40a1-a74b-b0c29d2e055b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding screenshot, we can see that our code was unable to handle
    a string as input by the user. Our code is going to perform well if—and only if—we
    enter an integer. If the user mistakenly enters any other data values, the program
    will crash. The aim of this topic is to handle this type of error. We have two
    types of error: syntax errors and exception errors. The following code shows examples
    of both:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Whenever you type in the wrong statement, it is going to throw an error message,
    that is, a syntax error. Here, we used two more parentheses than normal to enclose
    the print statement, which is incorrect. Due to this, the Python parser throws
    a syntax error. Remove those extra two parentheses to eradicate the syntax error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Now, the Python parser has thrown an exception error. This type of error occurs
    even if your Python syntax is correct. This can be either a mathematical or logical
    error. In mathematics, you cannot divide any number by zero. This results in an
    infinite, which has not been defined by Python. Hence, we ran into an exception.
    There are different types of exceptions. If you want to know the name of the exception
    you ran into, check the last statement of your code after received the exception.
    In our error message, the last statement says `ZeroDivisionError`. Hence, we ran
    into a `ZeroDivisionError` exception. If you run into any of these exceptions,
    then it's likely that your code has crashed. Hence, our game tic-tac-toe has also
    crashed because it was unable to handle input data other than integers.
  prefs: []
  type: TYPE_NORMAL
- en: Now, our main aim is to make our code reliable so that even if our code runs
    into an exception, instead of crashing, it gives the user a friendly message.
    In the preceding example, instead of terminating the program, we can send the
    user a message saying `You cannot divide any number by zero`. This process is
    called exception handling. These are done within `try` and `except` blocks in
    Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are unsure about the code regarding whether it gave you an error, you
    should always use `try` and `except` blocks. Your main code, which is likely to
    run into exceptions, should be kept inside a `try` block. Then, if it runs into
    an exception, the Python parser should execute the code that''s inside the `except`
    block. The following example should make this clearer to you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code shows how easy it is to handle these kinds of errors. You
    put your main code inside a `try` block and if it ran into an exception, the main
    code won't be executed. Instead, the code inside of the except block will be executed,
    which in this case is a user-friendly message. You can also use `pass` so that
    you terminate the program without providing the user with a message.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the except keyword, you can also pass the name of an exception explicitly.
    However, make sure you know the proper exception name you are going to run into.
    In this case, we know we are going to run into `ZeroDivisionError`, and so we
    can write the exception name with an except block, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's see how we can refine our tic-tac-toe game with everything we have
    learned about so far. We will use conditionals, looping, and exception handling
    to modify the code that we wrote in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Making a game controller for our tic-tac-toe game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the preceding chapter, we build a simple tic-tac-toe game. Since we have
    learned about conditionals and looping in this chapter we are now able enough
    to make some advancement on our game. We will make the following changes to our
    game:'
  prefs: []
  type: TYPE_NORMAL
- en: We have to make the game multiplayer, which means we have to make modifications
    to the program so that two players can play our game. We can make conditions that
    can toggle who's playing when.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we talked about exception handling, we saw that our game was unable to
    handle string data that was inputted by a user. We can use `try` and `except`
    blocks to handle that exception.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We were unable to determine the winner of our game with the code that we wrote
    in the previous chapter. Now that we have learned about `if` conditionals, we
    can come up with some logic to check whether the player is the winner.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will start our game development process by brainstorming in order to gather
    some critical information about the game.
  prefs: []
  type: TYPE_NORMAL
- en: Brainstorming and information gathering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the important features our code lacks is readability. In the game code
    from the preceding chapter, we didn't have a proper way to track the positions
    of the game board. The first thing we can do with our code is make a choices list,
    which will contain all of the choices that can be made by the player. Here, the
    choices are for the tic-tac-toe board position. In the tic-tac-toe game, the player
    can choose between 0 and 8 numbers, which are placeholders if they're not occupied
    by another player.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second thing we have to add in our code is a way we can toggle whose turn
    it is. Since we have only two players, we can make player 1 play first and make
    the first move of the game. Hence, making logic would be easier. We will make
    one Boolean variable and change its value from True to False so that we can make
    a condition to change the player''s turn, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`playerOne = True` will make sure it''s player 1''s turn.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`playerOne = False` will allow player 2 to make a move on our game board.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We have to go through the rules of the tic-tac-toe game to make any player
    a winner based on the positions they occupy on the game board. If a player, either
    X or O, occupies entire rows, columns, or diagonals of the tic-tac-toe board,
    that player will be considered the winner. This is depicted in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/6a16772b-7803-464b-b4f3-631078d63310.png)'
  prefs: []
  type: TYPE_IMG
- en: Modifying the model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The program we wrote in the previous chapter was only able to make one player
    play the game. Since tic-tac-toe is a multiplayer game, modifications should be
    made so that multiple players can play this game. For that, we have to do two
    things:'
  prefs: []
  type: TYPE_NORMAL
- en: Track empty places on the board.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make a condition to toggle the player's turn.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For both of those modifications, we have to make one variable that can track
    every empty and occupied position on the game board:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'If you use the `>>> print(choices)` variable, this will result in a list of
    values: `[''1'', ''2'', ''3'', ''4'', ''5'', ''6'', ''7'', ''8'', ''9'']`. They
    are positions for our board game.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if you want to print the board''s layout, you cannot use code from the
    previous chapter. Instead of using the `game_board` variable, we are going to
    use the `choices` variable. This works in the same way it did in the previous
    example. We are going to add a single line of dashes in-between each row:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The main problem in our game may arise when the user inputs something other
    than a number. For example, if the player enters a string, the game will be terminated
    with an exception—we don't want that situation to happen. As you may recall, we
    use **exception handling** to avoid such a scenario. We will add this to our game
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Handling the exceptions of the game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s run the game that we''ve made so far and input a string into the input
    field instead of an integer value. You will get the following exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/aa708971-878e-4c70-a2a5-634070fb33d8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We don''t want our program to crash whenever the user makes a mistake while
    interacting with our game. Instead, we can send them a user-friendly message saying
    `This is not valid, press integer only`. Let''s handle this type of exception
    by using a `try` and `catch` block, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run our program this time, we will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/2902aef2-9493-4eb4-852d-53b8d85b2f87.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, we entered a Python string value into the input field. Instead of it crashing
    the program, we got a message saying `Please enter only valid fields from board`.
    This is a convenient way of handling exceptions using `try` and `except` blocks.
    We used the same main loop from the previous chapter, which was going to loop
    an infinite amount of times. Inside the body of the `try` block, we kept the code
    that might throw an exception. `strip()` is a string method that is going to remove
    white spaces from the user's input. We have to type-cast user input using the
    `int` method so that the input data, which will be in the form of a string, is
    converted into an integer. If we get an exception, we are going to execute the
    code that's inside the body of the `except` block. The `continue` keyword is going
    to make the main loop run again from the beginning if we run into an exception.
  prefs: []
  type: TYPE_NORMAL
- en: The main feature that must be added to our tic-tac-toe game is multiplayer so
    that two players can play the same game turn by turn. This toggling feature will
    be added in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Toggling the player's turn
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Writing programs to make two players play the game is easy with Python—all
    you need to do is create one Boolean variable that will denote who the current
    player is. Then, based on the two values of the Boolean, either `True` or `False`,
    we can change who''s playing the game. However, if you want to add more than two
    players, this idea isn''t going to work. We are going to use the following Booleans:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Is_Current_One = True`: The current player is player 1 or X.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Is_Current_One = False`: The current player is player 2 or O.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s break the preceding code into segments so that we can understand it
    better:'
  prefs: []
  type: TYPE_NORMAL
- en: We have our main loop, which is going to run an infinite amount of times until
    it triggers a `break` statement. We've already learned that the `break` keyword
    was going to terminate our loop. In the body of the main loop, we print whether
    it's player X's or O's turn to make the player aware of their turn.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have created a Boolean variable called `Is_Current_One`, which was assigned
    a value of `True`. This means that the first player to make a move will be player
    `X`. If we make this variable False, then the default player to make the first
    move will be player `O`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inside the main loop, we created a condition to check whether player `X` or
    player `O` has placed either `X` or `O` on the board layout accordingly. The `choices[]`
    variable reflects the board's position. `choice` is the user's input, which we
    subtract by 1 because our choices variable is a list type. We know that list indexes
    start from index 0, but we have entered user input from 1 to 9\. Hence, we subtract
    the `choice` input variable with 1 to accommodate this list variable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `>>> Is_Current_One = not Is_Current_One` statement is going to toggle between
    the players. As we mentioned previously, if `Is_Current_One` is `True`, the player
    is `X`, Now, we've also made a condition so that we can change True to False in
    the next iteration so that player `O` can make the next move.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s see what we are up to now by running our script file. You will see the
    following result printed in the shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/a9420bfc-fd6e-45c1-9ec6-0a6e0acc55ab.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, we have created our game, which can take some input from a user and place
    it on the tic-tac-toe board. We've created some logic to change whose turn it
    is. We were also able to handle exceptions that might appear in our game using
    `try` and `catch` blocks.
  prefs: []
  type: TYPE_NORMAL
- en: We have been progressing at a rapid pace, but our game is still incomplete.
    We haven't made any logic to make a player the winner if they occupy either a
    row, a column, or three diagonal cells. We will do this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Making a player the winner
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Tic-tac-toe** is an easy game to make, but the main purpose of building this
    game is to cover almost every core programming paradigm of Python, such as variables,
    numbers, models, built-in methods, looping, branching, and exception handling.
    Now, our game is good enough to be played by two players, but a multiplayer game
    can only have one winner at the end of it. Therefore, we have to make brand new
    logic that will reward the player if they win. We need to cover three use cases,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: If an entire row of the tic-tac-toe board is occupied by a player, that player
    will be the winner.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If an entire column of the board is occupied by a player, that player will be
    the winner.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If an entire diagonal of the board is occupied a player, that player will be
    the winner.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s print our game board layouts, along with their positions, so that we
    can track all of the positions of the board while making the preceding conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we have to loop through all of these positions from 1 to 9, we need to
    use a `for` loop. Since we have a finite list of numbers, a `for` loop is easy
    to use. We have to make two conditions to check whether a player occupies an entire
    row or column. After dealing with row and column, we will examine diagonal conditionals
    with isolation:'
  prefs: []
  type: TYPE_NORMAL
- en: '**For row**: If any user occupies [1,2,3], [4,5,6], [7,8,9], that particular
    player will be considered the winner.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**For column**: If any user occupies [1,4,7] , [2,5,8], [3,6,9], that particular
    player will be considered the winner.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, the position inside the `choice` variable ranges from 0 to 8, that
    is, ['0','1','2','3','4','5','6','7','8'], and so index 0 references the first
    position of the board, an index of 1 indicates the second position of the board,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have been using a while `True` statement for our main loop. Let''s modify
    that so that our code will run until we a player is the winner. We will run our
    main loop until `won= False`. If we get a winner of the game, we will change the
    value of the `won` variable to `True` so that the main loop will end:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we made two conditions to check whether the player is
    the winner. We made the `won` variable to track whether any player has won. If
    any player occupies an entire row or column, we are making the `won` variable''s
    value True and our loop will break, which means we will end our game. However,
    we haven''t given the user a message about being the winner. Let''s write some
    code that will tell the user they''re the winner after we check for the row and
    column condition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The statement we've written with the `print` method may create confusion because
    of the `str(int(Is_Current_One + 1))` command. Here, `Is_Current_One` is either
    `True` or `False`. However, it also corresponds to 1 or 0, where 1 is for `True`
    and 0 is for `False`. If player `X` is the winner, then it's player 1 who won,
    but the turn will have changed over to player `O`, that is, player 2.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hence, we have to add this to 1 so that the current player is determined the
    winner, rather than the player who goes next. Since this is a two-player game,
    this makes sense. Let''s run our code to examine the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/42281b71-20e0-4c0b-b4d9-4ba3b1cb5f40.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We haven''t finished yet—we also have to add one more condition to check whether
    the diagonals are also occupied by a player. Let''s add that condition now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'If any player occupy positions [1,5,9] or [3,5,7], they will be regarded as
    the winner. However, our `choices` variable is a list that contains all of the
    positions. Its index starts from 0, which means if you want to locate the position
    for player 1, you should pass this as `choices[0]`, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s run our game one more time to check whether this condition works
    properly:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/37ad5c38-36cc-4c49-9f21-154360dc2db6.png)'
  prefs: []
  type: TYPE_IMG
- en: Finally, we have completed our game! We were able to include many features in
    our game, such as exception handling, multiplayer mode, and logic to make a player
    a winner. However, we still have to refine this game by adding user-defined functions
    so that we can print our board layout. This will follow the DRY principle and
    will be covered in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter has given us a roller-coaster ride of all of the core topics of
    programming paradigms with Python. We have covered flow controls and how to achieve
    them using branches and loops. We learned how to make conditions and fed them
    to the conditionals. Then, based on those conditions, we were able to make a switch
    between the execution of statements. We saw how to automate things using Python
    looping and branching. We fed multiple possible conditions with the `if` keyword
    and, based on the result of the Boolean expressions, the flow of the program was
    controlled. We also learned about the different types of looping and saw how to
    use them to iterate a list of items or objects. Then, we saw how to handle exceptions
    using try and except block.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we made our tic-tac-toe game more playable than ever before by incorporating
    the different paradigms we learned about in this chapter. We added `try` and `except`
    blocks so that any exception will be caught and handled properly. We also added
    features such as multiplayer mode and logic to make a player the winner. This
    makes the game highly interactive. Finally, we made a game controller using conditionals
    and looping. However, we won't stop here; more modifications will be made in the
    upcoming chapters.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will be life-changing for us. Up until now, we have only been
    using the built-in functions of Python, such as `min()`, `max()`, and `input()`.
    In the next chapter, we will see how to make our own functions and to use them
    so that we can make our game more readable and reusable. We will cover data structures
    such as list, set and, dictionary so that we know how to manage and store more
    complex datasets. Don't be overwhelmed by all of these statements, though. You
    have come this far, and are now on the brink of becoming a proficient Python programmer.
    Before moving on to the next chapter, make sure you are comfortable with all of
    the topics that we have learned about so far.
  prefs: []
  type: TYPE_NORMAL
