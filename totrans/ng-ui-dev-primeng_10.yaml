- en: Creating Robust Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing web applications is an important process to eliminate bugs. Tests ensure
    that the written code works as expected and the functionality is not broken on
    subsequent changes. They also help you to better understand the complex code you
    are working on. There are two main types of testing--**unit testing** and **end-to-end**
    (**e2e**) testing.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing is about testing isolated pieces of code. Unit tests normally use
    mocks for inputs and then assert that the expected results have occurred. The
    e2e approach executes tests against your application running in a real browser.
    Such tests assert that all pieces of code properly interact with each other. Standard
    test frameworks for Angular applications are Jasmine and Protractor. Jasmine is
    used for unit testing in combination with Karma-- a test runner for JavaScript.
    Protractor is an e2e test framework. This chapter describes two types of testing
    in a concise manner. You will learn how to set up and use the test frameworks
    efficiently. Testing and debugging tips round off the book.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up unit testing with Jasmine and Karma
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit testing of components and services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tips on how to speed up unit testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the e2e test environment with Protractor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing automated UI tests at a glance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring an PrimeNG application with Augury and ng.probe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up unit testing with Jasmine and Karma
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section will give a brief overview of Jasmine ([http://jasmine.github.io](http://jasmine.github.io))
    and Karma ([https://karma-runner.github.io](https://karma-runner.github.io)).
    We will set up a testing environment before writing concrete unit tests. For this
    purpose, the Webpack seed project introduced in the *Setting up PrimeNG project
    with Webpack* section of [Chapter 1](0cbd9d79-a0ba-42ba-9172-2b76d8ad8788.xhtml),
    *Getting Started with Angular and PrimeNG*, will be extended.
  prefs: []
  type: TYPE_NORMAL
- en: Brief introduction to Jasmine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Jasmine is a JavaScript testing framework with zero dependencies. With `npm`,
    you can install it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You also need to install the Jasmine type definition file. Otherwise, the TypeScript
    compiler will not know about the Jasmine types.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Jasmine has four main concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Specs**: In Jasmine terminology, unit tests are called specs. The `it(string,
    function)` function specifies a test. It takes a title and a function containing
    one or more expectations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Suites**: Specs are wrapped in suites. The `describe(string, function)` function
    describes a test suite. It takes a title and a function containing one or more
    specs. Suit can contain other nested suites as well.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Expectations**: These are assertions which are specified using the `expect(actual)`
    function. The function gets one argument--the `actual` value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Matchers**: Assertions are followed by matchers. Jasmine has a lot of matchers
    such as `toBe(expected)`, `toEqual(expected)`, `toBeLessThan(expected)`, and many
    more. The `expected` argument is the expected value. For example, `expect(2 +
    3).toBeLessThan(6)`. Matchers implement a Boolean comparison between `actual`
    and `expected` values. If the matcher returns `true`, the spec passes; otherwise,
    an error is thrown. Any matcher can be negated with `not`; for example, `expect(array).not.toContain(member)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A full list of matchers is available on GitHub at [https://github.com/JamieMason/Jasmine-Matchers](https://github.com/JamieMason/Jasmine-Matchers).
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of a simple test with Jasmine is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The titles in the functions `it()` and `describe()` serve the purpose of documentation.
    Tests should be self-described so that other developers can better understand
    what the test does.
  prefs: []
  type: TYPE_NORMAL
- en: 'Jasmine has some setup and teardown functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`beforeAll()`: Executes some code before the suite runs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`beforeEach()`: Executes some code before each spec runs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`afterAll()`: Executes some code after the suite is finished.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`afterEach()`: Executes some code after each spec is finished.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An example with `beforeEach()` and `afterAll()` is demonstrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Testing setup with Webpack and Karma
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two runners to execute tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '**HTML runner from the Jasmine''s standalone distribution (**[https://github.com/jasmine/jasmine/releases](https://github.com/jasmine/jasmine/releases)**)**:
    Download the ZIP file, unzip it, and open the `SpecRunner.html` file in any text
    editor. This HTML file includes some base code that loads the test framework.
    You need to add regular Angular dependencies, an Angular testing library, and
    a SystemJS loader, which loads the `.spec` files. After that, you can open the
    HTML file in your web browser to see the test results.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Command-line runner Karma**: Karma can run tests in different browsers and
    report possible errors with various reporters. The runner can be integrated into
    the build process so that the unit tests get executed automatically as a part
    of the build.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this book, we will only concentrate on the Karma runner. The Webpack-based
    project setup needs the following Karma dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Attentive readers will notice that we want to run tests against Google Chrome
    and PhantomJS ([http://phantomjs.org](http://phantomjs.org))--a headless browser,
    which is perfect for testing web applications.
  prefs: []
  type: TYPE_NORMAL
- en: The complete project with instructions is available on GitHub at
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/ova2/angular-development-with-primeng/tree/master/chapter10/unit-testing](https://github.com/ova2/angular-development-with-primeng/tree/master/chapter10/unit-testing).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The testing setup with Webpack and Karma requires three configuration files.
    First of all, we need a Karma configuration file: `karma.config.js`. This file
    will tell Karma where the tests are located, which browser(s) to use to execute
    the tests, which reporting mechanism to use, and so on. In the project on GitHub,
    this file has the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Two important points should be mentioned here. There is a special Webpack configuration
    for tests, which is located in the `webpack.test.js` file. Its content is simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `webpack.test.js` doesn''t specify entry points for files to be tested.
    The location and file extension for test files are defined in `spec-bundle.js`.
    This is another important file processed by Webpack. It loads Angular modules
    required for testing and initializes the test environment. At the end, all the
    test files are getting loaded in the browser. The content of the `spec-bundle.js`
    file is listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The convention is to name your test file the same as the file it is testing,
    but with the suffix `.spec` before the file extension. For example, `header.component.spec.ts`
    and `language.service.spec.ts`. It is also the best practice to keep each test
    file in the same directory as the corresponding file under test.
  prefs: []
  type: TYPE_NORMAL
- en: In `package.json`, we can configure three convenient commands.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Now, we are ready to run our tests using one of the three commands. When we
    execute `npm run test`, Karma will open and close each configured browser and
    print the test results.
  prefs: []
  type: TYPE_NORMAL
- en: When using the Angular CLI, it handles the configuration for us. You don't need
    to write any configuration files and can quickly run all tests by typing `ng test`
    in our project root. This command watches for changes and reruns the tests automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing of components and services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will introduce Angular testing utilities and show how to
    test components and services. Testing of directives, pipes, router, and so on,
    will not be explained due to the limited size of the book.
  prefs: []
  type: TYPE_NORMAL
- en: Angular testing utilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you could see in the previous section, Angular comes with a testing library,
    `@angular/core/testing`, which offers the `TestBed` helper class and many other
    utilities. `TestBed` helps us to set up dependencies for tests--modules, components,
    providers, and so on. You can call `TestBed.configureTestingModule()` and pass
    the same metadata configuration object as used with `@NgModule`. The `configureTestingModule()`
    function should be called within a `beforeEach()` setup function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another useful function from the testing library is called `inject()`. It allows
    you to inject the specified objects into the tests. The following code snippet
    provides an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The next useful function is the `async()` function. It may be used with asynchronous
    operations because it doesn''t complete the test until all asynchronous operations
    in the test have been completed or the specified timeout occurs. The `async()`
    function wraps the second argument of the `it()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The timeout parameter is optional. It is also possible to call `async()` in
    combination with `inject()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that if you change some component''s property value and this property
    is bound to the view via the `ngModel` directive, you have to do this within `async()`
    as well. The reason: `ngModel` updates the value asynchronously. We will develop
    an appropriate example in this section.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `fakeAsync()` function from the Angular testing utilities is similar to
    `async()`, but it enables a linear coding style by running the test body in a
    special *fakeAsync test zone*. The `fakeAsync()` method is used in combination
    with the `tick()` function, which simulates the passage of time until all pending
    asynchronous activities have been finished. There are no nested `then(...)` blocks
    anymore; the test appears to be synchronous:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: There is one limitation with `fakeAsync()`--you cannot make an XHR call from
    within `fakeAsync()`.
  prefs: []
  type: TYPE_NORMAL
- en: Testing a component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We want to test a component called `SectionComponent` with just one property
    `username`. The component has the following markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In the test file `section.component.spec.ts`, we will assign the value `James
    Bond` to the property `username` and then check whether the value appears in the
    view. The full listing of the test code is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s explain the code. First of all, we need to configure the testing module
    with `TestBed`. It is done as usual within `beforeEach()`. The class `TestBed`
    has a static method `createComponent(component)`, which we use to create `ComponentFixture`--a
    wrapper around the component instance on the test environment. The fixture provides
    an access to the component instance itself, to the native root element, and to
    `DebugElement`, which is a wrapper around the root element of this component.
    Furthermore, `ComponentFixture` has a lot of other useful methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The most important methods are `detectChanges()` and `whenStable()`. The first
    one triggers the change detection cycle for the component. This is necessary to
    propagate the changes to the UI. The second one returns `Promise` and can be used
    to resume testing when all asynchronous calls or asynchronous change detection
    have ended. We used two different APIs to check the expected result after `Promise`
    got resolved.
  prefs: []
  type: TYPE_NORMAL
- en: 'Jasmine has a concept of spies. A spy mocks any object or function and tracks
    calls to it and all of its arguments. The `toHaveBeenCalled` matcher will return
    `true` if the spy was called. The next code snippet creates a spy on the `showDetails`
    method. After some interactions, we can verify if the method was called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We can also verify if the method was called with specific arguments, how many
    times it was called, and so on. Refer to the Jasmine documentation for more details.
  prefs: []
  type: TYPE_NORMAL
- en: Testing a service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next example outlines how to test services. We want to test a service,
    which returns some countries from a remote backend:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Country` objects have the following shape:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We don''t want to make HTTP calls during the tests. To achieve that, we have
    to replace `XHRBackend` by `MockBackend`. The `MockBackend` allows us to catch
    outgoing HTTP requests and simulate incoming responses. We can just define a response
    as we want and then compare the result from the service with our expectations.
    The next code snippet shows how to build a mocked response, so when we finally
    make a call to our service, it gets the predefined array of countries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Note, that we don''t need the `async()` function here because `MockBackend`
    behaves synchronously. Now, when all the tests are successful, you will see the
    following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/8e22742c-8e05-43d5-a9e8-d465faa01390.png)'
  prefs: []
  type: TYPE_IMG
- en: The demonstrated test of the service class was not an *isolated unit test*.
    Isolated unit tests explore the inner logic of the tested class and don't require
    the Angular testing utilities. You don't need to prepare a testing module, call
    `inject()`, `async()`, and so on. A test instance of the class is created with
    `new`, supplying mock, spy, or fake objects for the constructor parameters. Generally,
    services and pipes are good candidates for isolated unit testing. Read the official
    Angular testing guide to learn more details ([https://angular.io/docs/ts/latest/guide/testing.html](https://angular.io/docs/ts/latest/guide/testing.html)).
  prefs: []
  type: TYPE_NORMAL
- en: The complete project with instructions is available on GitHub at
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/ova2/angular-development-with-primeng/tree/master/chapter10/unit-testing](https://github.com/ova2/angular-development-with-primeng/tree/master/chapter10/unit-testing).'
  prefs: []
  type: TYPE_NORMAL
- en: Tips on how to speed up unit testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a real web application, you can have a lot of test files. The bundling and
    running of all test files might take a while. Karma takes a while for the booting
    process as well. It is not satisfactory for rapid software development if you
    always have to run hundreds and more tests in order to test a small change in
    a single file. If you would like to narrow testing for files you are writing the
    tests for, one file or a specified collection of files should be tested, without
    rebooting Karma. How to do this?
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the case where `karma-webpack-grep` ([https://www.npmjs.com/package/karma-webpack-grep](https://www.npmjs.com/package/karma-webpack-grep))
    can help you. It allows to limit files, which are bundled by `karma-webpack`.
    First, install it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we have to extend the `karma.conf.js` file. Put the new `karma-webpack-grep`
    plugin to the array of all Webpack''s plugins. Everything else remains unchanged:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the `testContext` option is exactly the same that as passed in `require.context(...)`
    (see `spec-bundle.js`). But, where the `config.grep` coming from? Karma parses
    command-line arguments. That means, if you execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The `config.grep` will be set to `some/path`. Let''s extend the `npm` scripts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you are able to run concrete tests in watch mode. For Chrome browser,
    it looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'For PhantomJS, the tests start with `npm test test:headless:grep`. The test
    result looks like the following (here for `CountryService`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The Karma runner continues to run and watches the file changes. Test results
    appear very fast on every file change. It is also possible to watch and execute
    test files in a certain folder. For that, you can simple pass this folder to the
    `npm` script. For instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'All tests under `src/app/section` will be watched and executed. Just concentrate
    on writing the code:'
  prefs: []
  type: TYPE_NORMAL
- en: The complete project with instructions is available on GitHub at
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/ova2/angular-development-with-primeng/tree/master/chapter10/unit-testing](https://github.com/ova2/angular-development-with-primeng/tree/master/chapter10/unit-testing).'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the e2e test environment with Protractor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Protractor ([http://www.protractortest.org](http://www.protractortest.org))
    is an open source e2e testing automation framework, designed specifically for
    Angular web applications. The Protractor is a Node.js tool built on the top of
    WebDriverJS--an official implementation of the W3C WebDriver API to interact with
    the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Protractor has many advantages. You no longer need to add `waits` and `sleeps`
    to your test for pending tasks. Protractor can automatically execute the next
    step in your test at the moment the web page finishes asynchronous tasks (for
    example, AJAX updates). The framework also supports Angular's locator strategies,
    which allows you to find Angular-specific elements by binding, model, and so on,
    without much effort. This section gives a brief introduction to Protractor including
    the setup and specific testing constructs.
  prefs: []
  type: TYPE_NORMAL
- en: Installing and configuring Protractor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The preferred method is to install Protractor globally with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Protractor will automatically download the *Selenium Standalone Server* and
    all the browser drivers.
  prefs: []
  type: TYPE_NORMAL
- en: The Selenium Standalone Server is normally needed if you want to connect to
    remote machine(s) and run tests against browser(s) on remote machine(s). It is
    often used with *Selenium-Grid* when you distribute your tests over multiple machines.
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute this command to update the Selenium Standalone Server and the browser
    drivers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Ensure that you have installed the `jasmine-core` package locally as shown
    in the *Setting up unit testing with Jasmine and Karma* section . The tests will
    be written in Jasmine, but you can also use Mocha ([https://mochajs.org](https://mochajs.org))--another
    JavaScript test framework running on Node.js. In addition, a reporter implementation
    is required. Install `jasmine-spec-reporter`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The Protractor configuration takes place in the `protractor.conf.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The description of the most important configuration options is listed down
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Option** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `allScriptsTimeout` | The timeout in milliseconds for each script running
    on the browser. |'
  prefs: []
  type: TYPE_TB
- en: '| `specs` | Spec patterns are relative to the location of this config. The
    best practice is to place all e2e tests in the `e2e` folder. The sub-folder names
    correspond to the page names. For example, tests for the `home` page should be
    in the `home` sub-folder. The file names also correspond to the name of pages.
    We add the `.e2e-spec.ts` suffix to our spec files. For example, the spec file
    for the home page is `home.e2e-spec.ts`. |'
  prefs: []
  type: TYPE_TB
- en: '| `capabilities` | Configuration object for the browser the tests run against.
    You can also run tests on more than one browser at once. For that, use the `multiCapabilities`
    option, which expects an array of capabilities. |'
  prefs: []
  type: TYPE_TB
- en: '| `seleniumAddress` | Use this option to connect to a running Selenium Server
    started with `webdriver-manager start`. For example, `seleniumAddress: ''http://localhost:4444/wd/hub''`.
    Protractor will send requests to this server to control a browser. You can see
    information about the status of the server at `http://localhost:4444/wd/hub`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `directConnect` | Use this option to connect to Chrome or Firefox directly
    (only two browsers are supported for direct connection). In this book, we use
    `directConnect` instead of `seleniumAddress`. |'
  prefs: []
  type: TYPE_TB
- en: '| `baseUrl` | The base URL for the application under test. |'
  prefs: []
  type: TYPE_TB
- en: '| `framework` | Test framework to use. Normally, Jasmine or Mocha are used.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `beforeLaunch` | A callback function called once configs are read but before
    any environment setup. This will only run once, and before `onPrepare`. In the
    preceding configuration, `ts-node` will be executed. The `ts-node` module takes
    care of transpiling TypeScript files to JavaScript ones. You must install it via
    `npm` as `npm install ts-node --save-dev`. Also, consider the `project` configuration
    option which points to the folder with a specific `tsconfig.json` file. Normally,
    we need different TypeScript compiler options for e2e tests. |'
  prefs: []
  type: TYPE_TB
- en: '| `onPrepare` | A callback function called once Protractor is ready and available,
    and before the specs are executed. We can add some reporters there. |'
  prefs: []
  type: TYPE_TB
- en: 'All preparations are done. Now, ensure that the application is running at `http://localhost:3000/`
    and run the tests from the project root with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'For the sake of convenience, you can configure this command as the `npm` script
    and run with `npm run e2e`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The `webdriver-manager update` command should be running first as a pre-hook.
    This is why we need `"pree2e"` in the `scripts` section.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is possible to separate e2e tests into various suites and run suite-related
    tests separately. You can accomplish this task in the configuration file within
    the `suites` section. For instance, let''s define two suites, `homepage` and `payment`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The following command will only run the homepage-related tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'When using the Angular CLI, it creates the configuration file for us. You can
    execute e2e tests by running `ng serve` and `ng e2e` in two separate consoles.
    If you need different settings, specific mocks, and so on for e2e tests, you must
    create a new `environment.e2e.ts` file with the specific environment variables,
    and register it in `.angular-cli.json` under `environments` as `"e2e": "environments/environment.e2e.ts"`.
    Now, you can import the `environment.ts` in the `app.module.ts`, check the environment
    variables and perform custom logic where required; for example, provide mocks,
    and so on. To make it work, the application should be started as `ng serve --env=e2e`.'
  prefs: []
  type: TYPE_NORMAL
- en: Writing automated UI tests at a glance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section describes the syntax of Protractor tests as well as the *Page Object*
    and *Page Element* design patterns, which are the best practices for the e2e testing.
    Armed with this knowledge, we will write a complete e2e test for the demo application
    introduced in [Chapter 9](2d7dd952-def7-41fa-bc5a-0fafbbd20eba.xhtml), *Miscellaneous
    Use Cases and Best Practices,* in the section *Displaying confirmation dialog
    with guarded routes*.
  prefs: []
  type: TYPE_NORMAL
- en: Browser object, element, and locators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The browser object is a globally created wrapper around an instance of `WebDriver`.
    It is used for navigation and page-wide information. With `browser.get()`, you
    can navigate to a page and then check the page''s title as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The current URL is returned by `browser.getCurrentUrl()`. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Other global objects created by Protractor are `element` and `by`. `element`
    is a helper function for finding DOM elements on the page you are testing. It
    requires one parameter--a *locator* for locating the element. Locators are created
    using the `by` object. There is a range of locators. We will only mention a few
    of them. For a full list, read the official API documentation ([http://www.protractortest.org/#/api](http://www.protractortest.org/#/api)).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `by.css` selector locates elements using a CSS selector. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The `by.id` selector locates an element by its ID. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The `by.tagName` selector locates elements with a given tag name. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Note that for Angular 2+ apps, the `by.binding` and `by.model` locators are
    not supported. They are only supported for Angular 1.x.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `element` function returns an `ElementFinder` object, which can be used
    to interact with the underlying DOM element or get information from it. The following
    table lists the most important methods of `ElementFinder`:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `getText()` | Returns the text of an element. |'
  prefs: []
  type: TYPE_TB
- en: '| `click()` | Executes a click on an element. |'
  prefs: []
  type: TYPE_TB
- en: '| `sendKeys(keys)` | Sends passed in characters to an element (useful for filling
    in forms). |'
  prefs: []
  type: TYPE_TB
- en: '| `element(locator)` | Finds child elements within a parent (this element)
    by a given locator. It returns the first found child element as an object of type
    `ElementFinder`. |'
  prefs: []
  type: TYPE_TB
- en: '| `all(locator)` | Finds child elements within a parent (this element) by a
    given locator. It returns an array of all found child elements as an object of
    type `ElementArrayFinder`. The `ElementArrayFinder` object has a lot of useful
    methods. For instance, `count()` provides a count of found elements, `get(index:
    number)` provides an element at a specified position in the array. For more information,
    read the API documentation. |'
  prefs: []
  type: TYPE_TB
- en: '| `getId()` | Gets the ID of the DOM element. |'
  prefs: []
  type: TYPE_TB
- en: '| `isDisplayed()` | Checks whether the DOM element is visible. |'
  prefs: []
  type: TYPE_TB
- en: '| `isEnabled()` | Checks whether the DOM element is enabled. |'
  prefs: []
  type: TYPE_TB
- en: 'Let''s see two examples, and check if an element with the style class `info`
    is displayed (visible) as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The next code snippet checks if a button is clickable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Be careful with animations. When an element appears after some animation, it
    is reasonable to wait for an animation end. To achieve that, use `browser.wait()`
    as `browser.wait(element(by.id('id')).isDisplayed()).toBe(true)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Be aware that access operations for DOM elements return promises and not elements
    themselves. It concerns, for example, `getText()`, `count()`, and so on. Protractor
    patches Jasmine''s `expect()` function so that it waits automatically until the
    promise gets resolved and the located DOM element is accessible. After that, the
    matcher will be applied. This is convenient, but there are some cases where you
    need an access to the value of the resolved promise. In these cases, you can use
    the promise''s `then()` function explicitly. Assume you want to output the count
    of rows within a table. The next code snippet exemplifies the idea:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Clean architecture with Page Objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A Page Object encapsulates the behavior of a web page. In single-page applications,
    we have views. For the sake of convenience, if we say "web page," we will mean
    both full page and view. There is one Page Object per web page that abstracts
    the page''s logic to the outside. That means the interaction with the web page
    is encapsulated in the Page Object. The e2e tests operate on Page Objects. Take
    an example from a web shop: the Page Objects could be written as classes: `ProductPage`,
    `ShoppingCartPage`, `PaymentPage`, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: A Page Element (aka *HTML Wrapper*) is another subdivision of a web page. It
    represents an HTML element and encapsulates the logic for the interaction with
    this element. For instance, an HTML Wrapper for DatePicker can provide the API
    methods such as "set a date into the input field," "open the calendar popup,"
    and "choose given day in the calendar popup". An HTML Wrapper can be composite;
    that means, it can consist of multiple small elements. For instance, a product
    catalog consists of products, a shopping cart consists of items, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Page Objects and HTML Wrappers as design patterns were described by Martin
    Fowler ([https://martinfowler.com/bliki/PageObject.html](https://martinfowler.com/bliki/PageObject.html)).
    There are a lot of advantages with this architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: Clean separation between test code and page-specific code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `by` locators to find elements on the page are not disclosed to the outside.
    The Page Object's caller never bothers with the `by` locators.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If some UI changes for any page, you don't need to change the corresponding
    tests. We just need to change the code at one place--within the Page Object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Page Objects reduce the amount of duplicated code. If the tests share the same
    scenario, you don't need to copy/paste your code. Write once, share everywhere!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The spec files are more readable and more compact--one glance at the code and
    we know what the test does.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The next code snippet demonstrates a simple Page Object for an imaginary login
    page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'As you see, many steps were extracted into one method. The test code using
    `LoginPage` is concise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: A spec file should be grouped with the corresponding Page Object in the same
    folder. It is a best practice to use the `.po.ts` suffix for the Page Object files.
    For example, the Page Object file for the login page is called `login.po.ts`.
    For Page Element files, we suggest to use the `.pe.ts` suffix; for example, `dialog.pe.ts`.
  prefs: []
  type: TYPE_NORMAL
- en: Writing complete the e2e test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to write e2e specs testing the UI from *Displaying confirmation
    dialog with guarded routes* of [Chapter 9](2d7dd952-def7-41fa-bc5a-0fafbbd20eba.xhtml),
    *Miscellaneous Use Cases and Best Practices*. Just to recap: the first view has
    an input field (username) with a submit button. The button triggers a navigation
    to the second view. Whenever the user changes the username, a confirmation dialog
    with the text You have unsaved changes. Are you sure you want to leave this page?
    will appear. The user can click on Yes or No. We want to write five test cases
    that verify:'
  prefs: []
  type: TYPE_NORMAL
- en: Whether the first page has a proper title displayed within the `h1` tag
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whether the navigation happens when no input exists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whether a confirmation dialog gets displayed when an input exists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whether the user leaves the current view when clicking on Yes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whether the user stays on the current view when clicking on No
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Before writing specs, we need a Page Object called `FirstViewPage`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The Page Element `ConfirmDialogPageElement` encapsulates the internal structure
    details of the confirmation dialog. It offers three methods to ask for the dialog''s
    visibility and to interact with the Yes and No buttons:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '`$()` is a handy shortcut notation for `element(by.css())`. The `by.xpath(''..'')`
    locator allows to select the parent element.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The specs themselves are clean--they invoke public APIs from `FirstViewPage`
    and `ConfirmDialogPageElement`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The next screenshot shows spec reports in IntelliJ/WebStorm:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/e3a4df7f-cf87-49f9-bc39-a042e1f15f21.png)The complete project with
    instructions is available on GitHub at'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/ova2/angular-development-with-primeng/tree/master/chapter10/e2e-testing](https://github.com/ova2/angular-development-with-primeng/tree/master/chapter10/e2e-testing).'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring a PrimeNG application with Augury and ng.probe
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Augury is a Google Chrome browser extension for inspecting Angular 2+ applications
    ([https://augury.angular.io/](https://augury.angular.io/)). The tool visualizes
    the application through a component tree, router tree, module dependencies, and
    more. Developers immediately see the application structure, change detection,
    and other useful characteristics. They can explore relationships between several
    building blocks, such as components, services, routes, modules, injectors, and
    so on. Augury is interactive. It allows for modifying application states and emitting
    events.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can install Augury from the Chrome Web Store: [https://chrome.google.com/webstore/detail/augury/elgalmkoelokbchhkhacckoklkejnhcd](https://chrome.google.com/webstore/detail/augury/elgalmkoelokbchhkhacckoklkejnhcd).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the plugin has been successfully installed, you will see a new Augury
    tab in the Chrome Developer Tools (DevTools). Shortcuts for opening the DevTools:
    *F12* (Windows), *Command* + *Option* + *I* (Mac).'
  prefs: []
  type: TYPE_NORMAL
- en: There is another way to explore Angular 2+ applications. In the development
    mode, Angular exposes a global `ng.probe` function, which takes native DOM element
    and returns corresponding debug elements. With the debug element, you can inspect
    the current state of components, injectors, listeners, trigger events, and so
    on. The `ng.probe` function is accessible in the browser's console.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will apply both Augury and `ng.probe` to the already known
    CRUD demo application from [Chapter 9](2d7dd952-def7-41fa-bc5a-0fafbbd20eba.xhtml),
    *Miscellaneous Use Cases and Best Practices*.
  prefs: []
  type: TYPE_NORMAL
- en: Augury in action
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first visible view in Augury is the Component Tree, which shows loaded
    components. Selecting a component within the tree highlights the component''s
    template within the browser. At the same time, additional information about the
    selected component is presented on the right side in the Properties tab. Let''s
    select `DataTableCrudComponent`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/88e03f87-fad4-4470-a307-c87816df9891.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You see all the internal properties, inputs, and outputs. All the properties
    are editable. The next screenshot shows the properties of the Dialog component.
    The output property `visibleChange` is an event emitter. We can trigger the event
    emitter by setting the value to `true` and clicking on the button Emit. In response,
    the dialog becomes visible:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/3222f6ee-ae1b-4b13-8751-50ab146e8232.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next to the Properties tab is the Injector Graph, which displays the dependencies
    of components and services. If we select the DataTable component, the dependency
    of the DataTable and its ancestry chain to the root injector will be shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/12772ffa-326a-4b6d-a797-cbcc4fe07a7a.png)'
  prefs: []
  type: TYPE_IMG
- en: The circle symbols for services need to be clarified. The hollow red circle
    means the service is not provided by the component. It is provided from an ancestor
    in the dependency tree. A dashed blue line shows exactly where the service comes
    from. In our case, all services are provided by the root injector--the main module
    declaration in `app.module.ts`. The filled red circle means the service is being
    injected and registered in the same component.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Router Tree gives you a tree view of all the routes in your application.
    You can explore which routes come from which parts of the application. We will
    skip the appropriate screenshot. The next tab, NgModules, lists all the modules
    in the application, along with the modules'' imports, exports, providers, and
    declarations. An insight into NgModules gives the complexity and size of the available
    modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/bacde7c2-9473-4897-9b53-2cdba7f2b022.png)'
  prefs: []
  type: TYPE_IMG
- en: Debugging with ng.probe
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By default, Angular runs in the development mode and builds a *debugging elements
    tree*--a tree, which has almost the same structure as a rendered DOM, but with
    objects of type `DebugElement`. Whenever `ng.probe(element)` is invoked in the
    browser console, a corresponding debug element is returned. The `DebugElement`
    class extends `DebugNode` ([https://angular.io/docs/ts/latest/api/core/index/DebugNode-class.html](https://angular.io/docs/ts/latest/api/core/index/DebugNode-class.html)).
  prefs: []
  type: TYPE_NORMAL
- en: In the production mode, no debugging elements tree is available and you cannot
    debug an Angular application with `ng.probe`. The production mode is enabled with
    `enableProdMode()`, which is a function from Angular's package, `@angular/core`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how to use public methods of the exposed `DebugElement`. First of
    all, we need to select a DOM element in DevTools. This keeps a reference to the
    selected DOM node in the variable `$0`, which can then be accessed from the console.
    In the CRUD application, we will select the Add button, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/aab4ac62-daf6-4481-8ab5-ce1b06efdf19.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, we are able to get a reference to the component instance the button belongs
    to. Once we have that instance, we can interact with it; for example, we can change
    properties, and so on. Let''s reset the array of `employees`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Selecting any element within the component template will always provide the
    same component instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one problem--the code explained didn''t change anything in the UI.
    The reason is obvious--we need to invoke the change detector manually. The next
    line is a bit complicated, but does exactly what we need--it runs the change detection
    cycle. As a result, the table with employees becomes empty:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The `injector` property allows accessing all the providers on the component
    and its parents. For instance, assume there is the following provider definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The value `http://someendpoint.com/v1/payment/` can be grabbed with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The DOM element with the `some` style class should be located within the component
    the defined provider is visible for.
  prefs: []
  type: TYPE_NORMAL
- en: 'One interesting use case is the triggering registered event handlers. In the
    demo application, we could select the Add button and trigger the click event on
    this button as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'This command will open the following dialog:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/aaf215a5-ed6f-4bfa-a46a-0da996927300.png)You might also be interested
    in a graphical analysis tool, *ngrev*, for reverse engineering of Angular projects
    ([https://github.com/mgechev/ngrev](https://github.com/mgechev/ngrev)). With this
    tool, you can explore the structure of your application, and the relationship
    between different modules, providers, and directives without running the application.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the end of this chapter, you should be able to set up the test environment
    for unit and e2e testing. The *de facto* standard unit test framework and runner
    introduced in this chapter were Jasmine and Karma, respectively. You got skills
    in writing unit tests for most used constructs, as well as basic skills in writing
    the e2e test with the Protractor framework.
  prefs: []
  type: TYPE_NORMAL
- en: You are also equipped with useful tips for creating robust applications. The
    `karma-webpack-grep` plugin can give a huge performance boost when booting up
    Karma in development. The Augury tool, as well as `ng.probe`, enable debugging
    and profiling Angular 2+ applications. We hope that the last chapter and the entire
    book will contribute to a flawless development process of your next Angular and
    PrimeNG applications.
  prefs: []
  type: TYPE_NORMAL
