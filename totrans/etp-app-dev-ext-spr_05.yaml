- en: Chapter 5. Testing the DAO Layer with Spring and JUnit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Everyone would agree that software testing should be a fundamental part of the
    development process. Thorough testing will ensure that the business requirements
    are met, the software works as expected, and that the defects are discovered before
    your client finds them. Although testing can never completely identify all the
    bugs, it is commonly believed that the earlier an issue is found, the cheaper
    it is to fix. It is far quicker to fix a `NullPointerException` in a block of
    code during development than when the system has been deployed to your client's
    production server. When developing enterprise systems, it becomes even more critical
    to deliver high-quality code. The reputation of your company is at stake; identifying
    and fixing issues before delivery is an important reason to make testing a critical
    part of the development lifecycle.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many different types of testing, including but not limited to, unit
    testing, integration testing, regression testing, black/white box testing, and
    acceptance testing. Each of these testing strategies could warrant a chapter in
    their own right but are beyond the scope of this book. An excellent article covering
    software testing in general can be found here: [https://en.wikipedia.org/wiki/Software_testing](https://en.wikipedia.org/wiki/Software_testing).
    We will focus on **unit testing**.'
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Unit testing is a strategy for testing discrete units of source code. From
    a programmer''s perspective, a unit is the smallest testable part of an application.
    A unit of source code is usually defined as a **public method** that is callable
    within the application and has a specific purpose. Unit testing of the DAO layer
    will ensure that each public method has at least one appropriate test case. In
    practice, we will need many more test cases than just a single one for each public
    method. For example, every DAO `find(ID)` method requires at least two test cases:
    one with an outcome returning a valid found object and one with an outcome that
    does not find a valid object. As a result, for every line of code written, developers
    often need several lines of test code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Unit testing is an art form that takes time to master. Our goal is to establish
    a set of tests that cover as many scenarios as possible. This is inherently opposite
    to what we are trying to achieve as developers, where our goal is to ensure that
    a task is performed to meet the precise functional requirements. Consider the
    following business requirement: take the cost value in cents and convert it to
    the euro equivalent according to the exchange rate of the day.'
  prefs: []
  type: TYPE_NORMAL
- en: The solution may seem self-explanatory, but what happens if the exchange rate
    is not available? Or the date is in the future? Or the cost value is null? What
    is the expected behavior if the value cannot be calculated? These are all valid
    scenarios that should be considered when crafting test cases.
  prefs: []
  type: TYPE_NORMAL
- en: With unit testing we define **how** the program should behave. Each unit test
    should tell a well-documented story of how that part of the program should act
    in a specific scenario. The tests become a contract that describes what should
    happen from the client code's point of view under the various reproducible conditions.
  prefs: []
  type: TYPE_NORMAL
- en: The benefits of unit testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Unit testing gives us confidence that the code we have written works correctly.
    The unit testing process also encourages us to think about how our code will be
    used and what conditions need to be met. There are many benefits including:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Identifying problems early:** Unit tests will help identify coding issues
    early in the development lifecycle when it is far easier to fix.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Higher quality:** We don''t want customers to find bugs, resulting in downtime
    and expensive release cycles. We want to build software that has as few bugs as
    possible in the first place.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Confidence:** Developers are reluctant to touch code that is fragile. Well-tested
    code with solid test cases can be approached with confidence.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Regression proofing:** Test cases build and evolve with the application.
    Enhancements and new functionalities may break the old code silently, but a well-written
    test suite will go a long way in identifying such scenarios.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enterprise applications, with many programmers doing parallel development across
    different modules, are even more vulnerable. Coding side effects may result in
    far-reaching consequences if not caught early.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A helper method was used to trim a Java String passed in as an argument. The
    argument was tested for null and the method returned an empty string " " if this
    was the case. The helper method was used everywhere in the application. One day,
    a developer changed the helper method to return null if the passed-in argument
    was null (they needed to identify the difference between null and an empty string).
    A simple test case would have ensured that this change did not get checked in
    to version control. The sheer number of null pointer exceptions when using the
    application was amazing!
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the test environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our strategy for unit testing is to create a set of test cases that can be
    run in an automated manner at any time during the development lifecycle. "Automated"
    means that no developer interaction is required; the tests can be run as part
    of the build process and do not require user input. The entire process is managed
    seamlessly through the use of Maven, JUnit, and Spring. Maven convention expects
    a test directory structure under the `src` directory with testing resources and
    Java test cases in subdirectories as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuring the test environment](img/5457OS_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Note how Maven uses the same directory structure for both source and testing
    layouts. All resources required to execute test cases will be found in the `src/test/resources`
    directory. Likewise, all the resources required for deployment will be found in
    the `src/main/resources` directory. The "convention over configuration" paradigm
    once again reduces the number of decisions that the developer needs to make. Maven-based
    testing will work without the need for any further configuration as long as this
    directory structure is followed. If you do not already have this directory structure,
    then you will need to create it manually by right-clicking on the required folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuring the test environment](img/5457OS_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'After adding the directory structure, we can create individual files as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuring the test environment](img/5457OS_05_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We will start by using NetBeans to create the `jdbc.properties` file.
  prefs: []
  type: TYPE_NORMAL
- en: The jdbc.properties file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Right-click on the `test/resources` folder and navigate to **New** | **Other**.
    The **New File** wizard will open where you can select **Other** from **Categories**
    and **Properties File** as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The jdbc.properties file](img/5457OS_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Select **Next** and type in `jdbc` as the filename:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The jdbc.properties file](img/5457OS_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on the **Finish** button to create the `jdbc.properties` file. NetBeans
    will then open the file in the editor where you can add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The jdbc.properties file](img/5457OS_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `jdbc.properties` file is used to define the database connection details
    that will be used by Spring to configure our DAO layer for unit testing. Enterprise
    projects usually have one or more dedicated test databases that are prefilled
    with appropriate data for all testing scenarios. We will use the database that
    was generated and populated in [Chapter 2](ch02.html "Chapter 2. The Task Time
    Tracker Database"), *The Task Time Tracker Database*.
  prefs: []
  type: TYPE_NORMAL
- en: The logback.xml file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create this file by using the **New File** wizard **XML** category as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The logback.xml file](img/5457OS_05_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'After creating the `logback.xml` file, you can enter the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'For those who are familiar with log4j, the syntax of the logback logger definitions
    is very similar. We have set the root log level to `INFO`, which will cover all
    the loggers that are not explicitly defined (note that the default level is `DEBUG`
    but this will usually result in extensive logging at the root level). Each individual
    logger, with the name matching a `com.gieman.tttracker` package, is set to log
    level `DEBUG`. This configuration gives us considerable flexibility and control
    over package-level logging properties. In production we would normally deploy
    a `WARN` level for all loggers to minimize logging. If an issue is encountered,
    we would then selectively enable logging in different packages to help identify
    any problems. Unlike log4j, this dynamic reloading of logger properties can be
    done on the fly thanks to logback''s `scan="true" scanPeriod="30 seconds"` option
    in the `<configuration>` node. More information about the logback configuration
    can be found here: [http://logback.qos.ch/manual/configuration.html](http://logback.qos.ch/manual/configuration.html).'
  prefs: []
  type: TYPE_NORMAL
- en: The test-persistence.xml file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow the **New File** steps outlined in the previous section to create the
    `test-persistence.xml` file. Enter the following persistence context definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This persistence unit definition is slightly different from the one created
    in [Chapter 3](ch03.html "Chapter 3. Reverse Engineering the Domain Layer with
    JPA"), *Reverse Engineering the Domain Layer with JPA*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the testing `persistence-unit` transaction type is `RESOURCE_LOCAL`
    rather than `JTA`. Our testing environment uses a local (Spring-managed) transaction
    manager rather than the one provided by our GlassFish server container (which
    is `JTA`). In both cases, the `tttPU` persistence unit name matches the `@PersistenceContext`
    `unitName` annotation of the `EntityManager` field in the `GenericDaoImpl`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The second difference is the way the classes are discovered. During testing
    our domain entities are explicitly listed and we exclude any classes that are
    not defined. This simplifies processing and ensures that only the required entities
    are loaded for testing *without scanning the classpath*. This is an important
    point for Windows users; on some Windows versions, there''s a limit to the length
    of the command-line statement, and therefore, a limit on how long you can make
    your classpath argument. Using classpath scanning, the loading of domain entities
    for testing may not work, resulting in strange errors such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Always ensure that your testing persistence XML definitions include all domain
    classes in your application.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the Spring IoC container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The modern Spring Framework is an extensive suite of framework "stacks" based
    on architectural concepts that go back to the start of the century. The Spring
    Framework first came to prominence with *Expert One-on-One J2EE Design and Development*,
    *Rod Johnson*, in 2002\. Spring's implementation of the **Inversion of Control**
    (**IoC**) principle, sometimes also known as **Dependency Injection** (**DI**),
    was a breakthrough in enterprise application design and development. The Spring
    IoC container provided a simple way of configuring objects (JavaBeans) and injecting
    dependencies through constructor arguments, factory methods, object properties,
    or setter methods. We have already seen the `@PersistenceContext` annotation in
    our DAO layer that is used by Spring to identify whether an `EntityManager` object
    should be injected into the `GenericDaoImpl` class. The sophisticated configuration
    options available make the Spring Framework a very flexible foundation for enterprise
    development.
  prefs: []
  type: TYPE_NORMAL
- en: It is beyond the scope of this book to cover more than the basics of the Spring
    Framework configuration as is required by our project needs. However, we recommend
    that you browse through the detailed description of how the IoC container works
    at [http://docs.spring.io/spring/docs/3.2.x/spring-framework-reference/html/beans.html#beans-definition](http://docs.spring.io/spring/docs/3.2.x/spring-framework-reference/html/beans.html#beans-definition)
    to enhance their knowledge of the core principles.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the testingContext.xml file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is the main configuration file used by Spring to configure and load the
    IoC bean container. The XML-based configuration has been the default way to configure
    Spring applications since the very start, but with Spring 3 Framework, it became
    possible to use the Java-based configuration. Both options achieve the same result—a
    fully configured Spring container. We will use the XML approach as it does not
    require any Java coding and is more intuitive and simple to use.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There have been many articles written over the years about the "complexities"
    of the Spring XML configuration. Prior to Java 1.5 and the introduction of annotations,
    there could have been a case made for such comments. Configuration files were
    lengthy and daunting for new users. This is no longer the case. Configuring a
    Spring container with XML is now a trivial process. Be wary of anyone who tells
    you otherwise!
  prefs: []
  type: TYPE_NORMAL
- en: 'The `testingContext.xml` configuration file completely defines the Spring environment
    required for testing the DAO layer. The full file listing is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Let's look at each section in detail.
  prefs: []
  type: TYPE_NORMAL
- en: The Spring XML namespaces
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For those not familiar with XML, you can simply ignore the `xmlns` definitions
    and schema location URLs. Consider them as "shortcuts" or "qualifiers" in the
    configuration file that provide the ability to validate the entries. Spring understands
    what `<tx:annotation-driven />` means in the context of loading the Spring environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each Spring application configuration file will have multiple namespace declarations
    depending on the resources your application needs. Defining the schema location
    in addition to the namespaces will allow NetBeans to provide helpful hints on
    configuration options:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Spring XML namespaces](img/5457OS_05_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The list of valid properties for different namespaces is very useful when new
    to Spring configuration.
  prefs: []
  type: TYPE_NORMAL
- en: The property file configuration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following bean loads the `jdbc.properties` file and makes it available
    for use in the configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `${}` syntax can then be used anywhere in the `testingContext.xml` file
    to replace the token with the required `jdbc` property.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the JDBC DataSource
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'DAO testing requires a connection to the MySQL database. The following Spring
    bean definition instantiates and makes available a fully configured DataSource:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The placeholders are automatically set with the properties loaded from the
    `jdbc.properties` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This very simple Spring configuration snippet replaces many lines of equivalent
    Java code if we had to implement the DataSource instantiation ourselves. Note
    how simple it would be to change any of the database properties for different
    testing scenarios, or for example, even change the database server from MySQL
    to Oracle. This flexibility makes the Spring IoC container very powerful for enterprise
    use.
  prefs: []
  type: TYPE_NORMAL
- en: You should note that the `org.springframework.jdbc.datasource.DriverManagerDataSource`
    should only be used for testing purposes and is not for use in a production environment.
    The GlassFish server will provide a connection-pooled `DataSource` for production
    use.
  prefs: []
  type: TYPE_NORMAL
- en: Defining helper beans
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `loadTimeWeaver` and `jpaVendorAdapter` bean definitions help configure
    the `entityManagerFactory` bean that is used to load the persistence context.
    Note the way in which we identify the database platform (MySQL) and JPA implementation
    (EclipseLink) by using specific Spring bean classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Spring provides a large number of database and JPA implementations as can be
    seen when using autocomplete in NetBeans (the *Ctrl* + Space bar combination in
    NetBeans triggers the autocomplete options):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Defining helper beans](img/5457OS_05_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Helper beans are used to define implementation-specific properties. It is very
    easy to swap implementation strategies for different enterprise environments.
    For example, developers may use MySQL databases running locally on their own environment
    for development purposes. Production enterprise servers may use an Oracle database
    running on a different physical server. Only very minor changes are required to
    the Spring XML configuration file to implement such differences for the application
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the EntityManagerFactory class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This Spring bean defines the `EntityManagerFactory` class that is used to create
    and inject the `EntityManager` instance into the `GenericDaoImpl` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This definition references the `tttDataSource` and `jpaVendorAdapter` beans
    that are already configured, as well as the `test-persistence.xml` persistence
    context definition file. Once again, Spring does a lot of work in the background
    by creating and configuring the `EntityManager` instance and making it available
    for use in our code.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the transaction manager
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Spring bean used to manage transactions is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This bean wires together the `tttDataSource` and `entityManagerFactory` instance
    to enable transactional behavior in our application. This behavior is applied
    to all classes with `@Transactional` annotations; in our current situation this
    applies to all the DAO objects. Spring scans for this annotation and applies a
    transactional wrapper to each annotated method when the following line is included
    in the configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Which classes are scanned for the `@Transactional` annotation? The following
    line defines that Spring should scan the `com.gieman.tttracker.dao` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Autowiring beans
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Autowiring** is a Spring term used to automatically inject a resource into
    a managed bean. The following line enables autowiring in beans that have the `@Autowired`
    annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We do not have any autowired annotations as of yet in our code; the next section
    will introduce how this annotation is used.
  prefs: []
  type: TYPE_NORMAL
- en: Thanks for the plumbing!
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Spring configuration file, when loaded by the Spring container, will do
    an enormous amount of work in the background configuring and wiring together the
    many supporting classes required by our application. The tedious and often error-prone
    "plumbing" code is done for us. Never again will we need to commit a transaction,
    open a database connection, or close a JDBC resource. These low-level operations
    will be handled very elegantly for us by the Spring Framework.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As enterprise application developers we can and should focus most of our time
    and energy on core application concerns: business logic, user interfaces, requirements,
    testing, and, of course, our customers. Spring makes sure we can stay focused
    on these tasks.'
  prefs: []
  type: TYPE_NORMAL
- en: Enabling the Maven environment for testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Maven build process includes the ability to execute test suites. We will
    now need to add this functionality to the `pom.xml` file. The required changes
    to the existing file are highlighted in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The first two changes add the `mysql-connector-java` and `junit` dependencies.
    Without these we will not be able to connect to the database or write test cases.
    These dependencies will download the appropriate Java libraries for inclusion
    into our project.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most important settings are in the Maven plugin that performs the actual
    work. Adding the `maven-surefire-plugin` will allow the test case execution based
    on the contents of the `main/src/test` directory structure. This clearly separates
    the testing classes from our application classes. The main configuration properties
    for this plugin are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<skipTests>`: This property can be `true` (to disable testing) or `false`
    (to enable testing).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<includes>`: This property includes a list of file sets during testing. The
    setting `<include>**/dao/*Test.java</include>` specifies that all the classes
    in any `dao` subdirectory with the filename ending in `Test.java` should be loaded
    and included in the testing process. You may specify any number of file sets.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<argLine>-javaagent:target/lib/spring-instrument-${spring.version}.jar</argLine>`:
    This property is used to configure the Java Agent for the testing JVM and is required
    by Spring for the load-time weaving of classes, a discussion of which is beyond
    the scope of this text.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have configured the Spring and Maven testing environments, we can
    start writing test cases.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a test case superclass
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first step is to create a superclass that all of our DAO test cases will
    inherit. This abstract class looks like the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The `AbstractDaoForTesting` class is marked as abstract so that it cannot be
    instantiated directly. It provides member variables that are accessible to all
    the subclasses, thus removing the need to replicate code in the descendents. As
    a result, each subclass will have access to the DAO instances as well as the SLF4J
    `logger`. There are two new Spring annotations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@ContextConfiguration`: This annotation defines the Spring application context
    used to load the bean container. The `testingContext.xml` file has been covered
    in detail in the previous sections.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Autowired`: This annotation indicates to Spring that the container-managed
    bean with matching type should be dependency injected into the class. For example,
    the `CompanyDao companyDao` definition will result in Spring querying the container
    for an object with type `CompanyDao`. There is only one object with this type:
    the `CompanyDaoImpl` class that was discovered and configured by Spring when scanning
    the `com.gieman.tttracker.dao` package via the `<context:component-scan base-package="com.gieman.tttracker.dao"/>`
    entry in the `testingContext.xml` file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The final important thing to notice is that the `AbstractDaoForTesting` class
    extends the Spring `AbstractTransactionalJUnit4SpringContextTests` class. Apart
    from being a very long class name, this class provides transparent transactional
    rollbacks at the end of each test method. This means the database state at the
    end of any DAO testing operations (including any insert, update, or delete) will
    be the same as at the start of testing. If this behavior is not required, you
    should extend `AbstractJUnit4SpringContextTests` instead. In this case any testing
    database operations can be examined and confirmed after the tests have been run.
    It is also possible to mark a single method with `@Rollback(false)` when using
    `AbstractTransactionalJUnit4SpringContextTests` to commit changes if required.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now write our first test case for the `CompanyDao` operation.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the CompanyDao test case
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Each `CompanyDao` method should have at least one test method defined. We will
    include exactly one test method per implemented `CompanyDao` method. In enterprise
    applications, we would expect many more scenarios to be covered than the ones
    identified in the code snippet that follows.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have also included minimum logging, just enough to split the output when
    running the test cases. You may wish to add more logging to help analyze the results.
    The test code assumes that the `ttt_company` table has appropriate data. In [Chapter
    2](ch02.html "Chapter 2. The Task Time Tracker Database"), *The Task Time Tracker
    Database*, we added three rows so that we know there is data available. Additional
    checks would need to be done if we do not have a database with consistent testing
    data. The file listing is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Running the JUnit test cases with Maven
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `pom.xml` configuration file will automatically run the test cases using
    `<skipTests>false</skipTests>` when doing **Clean and Build Project (task-time-tracker)**
    by clicking on the toolbar icon:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running the JUnit test cases with Maven](img/5457OS_05_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'It is also possible to only run the testing phase of the project by navigating
    to **Run** | **Test Project (task-time-tracker)**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running the JUnit test cases with Maven](img/5457OS_05_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The results of the testing process can now be examined in the **Output – task-time-tracker**
    panel. Note that you may need to dock the output panel to the bottom of the IDE
    if it is minimized, as shown in the following screenshot (the minimized panel
    is usually in the bottom-left corner of the NetBeans IDE). The `[surefire:test]`
    plugin output is displayed at the start of the testing process. There are many
    lines of output for configuring Spring, connecting to the database, and loading
    the persistence context:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running the JUnit test cases with Maven](img/5457OS_05_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We will examine the key testing output in detail soon. Scroll through the output
    until you reach the end of the test section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running the JUnit test cases with Maven](img/5457OS_05_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There were five tests executed in total with no errors—a great start!
  prefs: []
  type: TYPE_NORMAL
- en: Running the CompanyDaoTest.java file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can execute a single test case file by right-clicking on the file displayed
    in the editor and selecting the **Test File** option:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running the CompanyDaoTest.java file](img/5457OS_05_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This will execute the file''s test cases, producing the same testing output
    as shown previously, and present you with the results in the **Test Results**
    panel. This panel should appear under the file editor but may not be docked (it
    may be floating at the bottom of the NetBeans IDE; you can change the position
    and docking as required). The individual file testing results can then be examined:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running the CompanyDaoTest.java file](img/5457OS_05_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Single test file execution is a practical and quick way of debugging and developing
    code. We will continue to execute and examine single files during the rest of
    the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now examine the results of each test case in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In all of the following testing outputs, the SLF4J-specific messages have been
    removed. This will include timestamps, threads, and session information. We will
    only focus on the generated SQL.
  prefs: []
  type: TYPE_NORMAL
- en: The results for the CompanyDaoTests.testMerge test case
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The output for this test case is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'A `merge` call is used to update a persistent entity. The `testMerge` method
    is very simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We find the first `Company` entity (the first item in the list returned by `findAll`)
    and then update the name of the company to the `NEW_NAME` value. The `companyDao.merge`
    call then updates the `Company` entity state in the persistence context. This
    is tested using the `assertTrue()` test.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the testing output only has **one** SQL statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This output corresponds to the `findAll` method call. Note that there is no
    SQL update statement executed! This may seem strange because the entity manager's
    `merge` call should result in an update statement being issued against the database.
    However, the JPA implementation is **not** required to execute such statements
    immediately and may cache statements when possible, for performance and optimization
    purposes. The cached (or queued) statements are then executed only when an explicit
    `commit` is called. In our example, Spring executes a `rollback` immediately after
    the `testMerge` method returns (remember, we are running transactional test cases
    thanks to our `AbstractTransactionalJUnit4SpringContextTests` extension), and
    hence the persistence context never needs to execute the update statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can force a flush to the database by making a slight change to the `GenericDaoImpl`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The `em.flush()` method results in an **immediate** update statement being
    executed; the entity manager is flushed with all pending changes. Changing this
    code in the `GenericDaoImpl` class and executing the test case again will result
    in the following testing output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The update statement now appears as expected. If we now check the database
    directly after executing the test case, we find:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The results for the CompanyDaoTests.testMerge test case](img/5457OS_05_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As expected, Spring has rolled back the database at the end of the `testMerge`
    method call, and the company name of the first record has not changed.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In enterprise applications, it is recommended not to call `em.flush()` explicitly
    and to allow the JPA implementation to optimize statements according to their
    transactional behavior. There may be situations, however, where an immediate flush
    is required but these are rare.
  prefs: []
  type: TYPE_NORMAL
- en: The results for the CompanyDaoTests.testFindAll test case
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The output for this test case is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Even though the `testMerge` method uses the `findAll` method to retrieve the
    first item in the list, we should always include a separate `findAll` test method
    to compare the size of the result set with the database table. This is easy when
    using the Spring helper method `countRowsInTable`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then compare the size of the `findAll` result list with `rowCount` using
    the `assertTrue` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Note how the `assertTrue` statement is used; the message is displayed if the
    assertion is `false`. We can test the statement by slightly modifying the assertion
    so that it fails:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'It will now fail and result in the following output when the test case is executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The results for the CompanyDaoTests.testFindAll test case](img/5457OS_05_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The results for the CompanyDaoTests.testFind test case
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The output for this test case is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This may seem a bit surprising for those new to JPA. The `SELECT` statement
    is executed from the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: But where is the expected `SELECT` statement when calling the `find` method
    using the `id` attribute?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: JPA does not need to execute the `SELECT` statement using the primary key statement
    on the database as the entity with the required ID has already been loaded in
    the persistence context. There will be three entities loaded as a result of the
    `findAll` method with IDs 1, 2, and 3\. When asked to find the entity using the
    ID of the first item in the list, JPA will return the entity it has already loaded
    in the persistence context with the matching ID, avoiding the need to execute
    a database select statement.
  prefs: []
  type: TYPE_NORMAL
- en: This is often a trap in understanding the behavior of JPA-managed applications.
    When an entity is loaded into the persistence context it will remain there until
    it expires. The definition of what constitutes "expires" will depend on the implementation
    and caching properties. It is possible that small sets of data will never expire;
    in our Company example with only a few records, this will most likely be the case.
    Performing an update statement directly on the underlying table, for example,
    changing the company name of the first record, may never be reflected in the JPA
    persistence context as the persistence context entity will never be refreshed.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If an enterprise application expects data modification from multiple sources
    (for example, through stored procedures or web service calls via a different entity
    manager), a caching strategy to expire stale entities will be required. JPA does
    not automatically refresh the entity state from the database and will assume that
    the persistence context is the only mechanism for managing persistent data. EclipseLink
    provides several caching annotations to solve this problem. An excellent guide
    can be found here: [http://wiki.eclipse.org/EclipseLink/Examples/JPA/Caching](http://wiki.eclipse.org/EclipseLink/Examples/JPA/Caching).'
  prefs: []
  type: TYPE_NORMAL
- en: Results for the CompanyDaoTests.testPersist test case
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have added a few minor changes to the `GenericDaoImpl.persist` method as
    a result of the exercises from the previous chapter. The modified `persist` method
    in the `GenericDaoImpl` implementation is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'You will notice the `em.flush()` method in `GenericDaoImpl` after the `em.persist()`
    method. Without this flush to the database ,we cannot guarantee that a valid primary
    key has been set on the new `Company` entity. The output for this test case is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the logging outputs the newly generated primary key value of `4`.
    This value is retrieved when JPA queries MySQL using the `SELECT LAST_INSERT_ID()`
    statement. In fact, removing the `em.flush()` method from `GenericDaoImpl` and
    executing the test case would result in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The assertion `assertTrue(c.getId() != null)` will fail and we will not even
    display the `FINISHED testPersist()` message. Our test case fails before the debug
    message is reached.
  prefs: []
  type: TYPE_NORMAL
- en: Once again we see the JPA optimization in action. Without the `em.flush()` method,
    JPA will wait until a transaction is committed in order to execute any changes
    in the database. As a result, the primary key may not be set as expected for any
    subsequent code using the newly created entity object within the same transaction.
    This is another trap for the unwary developer, and the `persist` method identifies
    the only situation where an entity manager `flush()` to the database may be required.
  prefs: []
  type: TYPE_NORMAL
- en: Results for the CompanyDaoTests.testRemove test case
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is probably the most interesting test case so far. The output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The first `SELECT` statement is executed as a result of finding the first company
    in the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The second `SELECT` statement may not be as obvious:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Why does deleting a company result in a `SELECT` statement on the `ttt_project`
    table? The reason is that each `Company` entity may have one or more related `Projects`
    entities as defined in the `Company` class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'JPA understands that deleting a Company requires a check against the `ttt_project`
    table to see if there are any dependent Projects. In the `@OneToMany` annotation,
    the `cascade = CascadeType.ALL` property defines the behavior if a Company is
    deleted; the change should be cascaded to any dependent entities. In this example,
    deleting a company record will require the deletion of all related project records.
    Each `Project` entity in turn owns a collection of Task entities as defined in
    the `Project` class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of removing a `Company` entity has far-reaching consequences as
    all related Projects and their related Tasks are deleted from the underlying tables.
    A cascade of `DELETE` statements in the testing output is the result of the final
    deletion being that of the company itself. This may not be suitable behavior for
    enterprise applications; in fact, such a cascading of deletions is usually **never**
    implemented without extensive checks to ensure data integrity. A simple change
    in the cascade annotation in the `Company` class will ensure that the deletion
    is not propagated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now only the `MERGE` and `PERSIST` operations on the `Company` entity will
    be cascaded to the related `Project` entities. Running the test case again after
    making this change will result in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: As the cascade type for `REMOVE` was not included, JPA does not check for related
    rows in the `ttt_project` table and simply attempts to execute the `DELETE` statement
    on the `ttt_company` table. This will fail, as there are related records on the
    `ttt_project` table. It will now only be possible to remove a `Company` entity
    if there are no related `Project` entities (the `projects` field is an empty list).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Changing the `CascadeType` as outlined in this section adds **business logic**
    to the DAO layer. You will no longer be able to perform certain actions through
    the persistence context. There may, however, be a legitimate situation where you
    **do** want a cascading delete of a `Company` entity and this will no longer be
    possible. `CascadeType.ALL` is the most flexible option, allowing all possible
    scenarios. Business logic such as deletion strategies should be implemented in
    the service layer, which is the subject of the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We will continue to use the `cascade = CascadeType.ALL` property and allow JPA-managed
    deletions to propagate. The business logic to restrict these actions will be implemented
    in the service layer.
  prefs: []
  type: TYPE_NORMAL
- en: JPA traps for the unwary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are some JPA traps worthy of special examination. We will start by creating
    the following test case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this test case may surprise you:'
  prefs: []
  type: TYPE_NORMAL
- en: '![JPA traps for the unwary](img/5457OS_05_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The first failure arises from the `userDao.findByUsernamePassword` statement,
    which uses the uppercase password:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Why was the user found with an obviously incorrect password? The reason is
    very simple and is a trap for the unwary developer. Most databases, by default,
    are case insensitive when matching text fields. In this situation the uppercase
    `ADMIN` will match the lowercase `admin` in the password field. Not exactly what
    we want when checking passwords! The database term that describes this behavior
    is collation; we need to modify the password column to use a case-sensitive collation.
    This can be achieved in MySQL with the following SQL command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Other databases will have similar semantics. This will change the collation
    on the password field to be case sensitive (note the `_cs` appended in `latin1_general_cs`).
    Running the test case will now result in expected behavior for case-sensitive
    password checking:'
  prefs: []
  type: TYPE_NORMAL
- en: '![JPA traps for the unwary](img/5457OS_05_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `testManyToOne` failure is another interesting case. In this test case,
    we are reassigning the project to a different Company. The `p.setCompany(c2);`
    line will change the assigned company to the second one in the list. We would
    expect that after calling the `merge` method on the project, the collection of
    projects in the `c2` company would contain the newly reassigned project. In other
    words, the following code line should equate to `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Likewise, the old company should no longer contain the newly reassigned project
    and hence should be `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: This is obviously not the case and identifies a trap for developers new to JPA.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although the persistence context understands the relationship between entities
    using `@OneToMany` and `@ManyToOne`, the Java representation of the relationship
    needs to be handled by the developer when collections are concerned. The simple
    changes required are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: When the `projectDao.merge(p)` line is executed, the persistence context has
    no way of knowing the **original** parent company (if there is one at all; this
    may be a newly inserted project). The original `Company` entity in the persistence
    context still has a collection of projects assigned. This collection will never
    be updated during the lifetime of the `Company` entity within the persistence
    context. The additional two lines of code are used to remove the project (using
    `remove`) from the original company's project list and we add (using `add`) the
    project to the new company to ensure that the persistence context entities are
    updated to the correct state.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '1\. Add test assertions to the `CompanyDaoTest.find()` method to test for the
    following scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: Attempting to find a company with a null primary key
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attempting to find a company with a negative primary key
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What do you consider to be the expected results?
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Create the missing test case files for the `ProjectDao`, `TaskDao`, `UserDao`,
    and `TaskLogDao` implementations.
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Create a test case to determine if removing (deleting) a project will automatically
    remove the project from the owning company's project collection.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have once again covered a lot of territory. Unit testing is a critical part
    of enterprise application development, and the combination of NetBeans, Maven,
    JUnit, and Spring provides us with a solid platform to launch both automated and
    single file test cases. Writing comprehensive test cases is an art form that is
    always appreciated and valued in any high-quality development team; never underestimate
    the confidence gained from working with well-tested code with a solid suite of
    test cases!
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will examine the role of the service layer in enterprise
    application development. Our 3T business logic will then be implemented using
    the **Data Transfer Objects** (**DTO**) design pattern.
  prefs: []
  type: TYPE_NORMAL
