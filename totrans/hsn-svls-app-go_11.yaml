- en: Monitoring and Troubleshooting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lambda monitoring is different from traditional application monitoring, due
    to the fact that you're not managing the underlying infrastructure on which your
    code is running. Thus, there is no access to OS metrics. However, you still need
    function-level monitoring to optimize your function performance and debug in case
    of failure. In this chapter, you will learn how to achieve that and also how to
    debug and troubleshoot serverless applications in AWS. You will learn to set up
    alarms based on metric thresholds in CloudWatch to be notified of potential issues.
    You will also look at how to use AWS X-Ray to profile the application to detect
    abnormal behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring and debugging with AWS CloudWatch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: AWS CloudWatch is the easiest and most reliable solution to monitor AWS services,
    including Lambda functions. It's a centralized monitoring service to gather metrics
    and logs, and also creates alarms based on them. AWS Lambda automatically monitors
    Lambda functions on your behalf, reporting metrics through CloudWatch.
  prefs: []
  type: TYPE_NORMAL
- en: CloudWatch metrics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By default, each time you invoke your function through the Lambda console,
    it reports the key information about the function resource usage, execution duration,
    and how much time is billed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6531421d-cf8f-4b9c-9e47-5909459dc47a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'A quick real-time insight can be found by clicking on the Monitoring tab. This
    page will show a graphical representation of multiple CloudWatch metrics. You
    can control the observable time period in the top-right corner of the graph area:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9c882ed5-6d46-4f98-abb9-551c134e0826.png)'
  prefs: []
  type: TYPE_IMG
- en: 'These metrics include:'
  prefs: []
  type: TYPE_NORMAL
- en: Number of times the function has been invoked
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Execution time in milliseconds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Error rates, and throttle count due to concurrency reservation and unprocessed
    events (dead letter errors)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A list of all the available metrics in CloudWatch for AWS Lambda can be found
    at [https://docs.aws.amazon.com/lambda/latest/dg/monitoring-functions-metrics.html](https://docs.aws.amazon.com/lambda/latest/dg/monitoring-functions-metrics.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'For each metric, you can also click on View in metrics to view the CloudWatch
    metric directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/784ccac2-06a9-4ba2-9b6d-c9f37c061ee8.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding graph represents the number of invocations of the `production`
    and `staging` aliases of the `FindAllMovies` function in the last 15 minutes.
    You can take this further and create your own custom graphs. This allows you to
    construct a custom dashboard for your Lambda functions. It will outline the load
    (any problems you might face), the cost, and other important metrics.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moreover, you can also create your own custom metrics and publish them to CloudWatch
    using the CloudWatch Golang SDK. The following code snippet is of a Lambda function
    that uses the CloudWatch SDK to publish a custom metric. The metric represents
    the number of `Action` movies inserted into DynamoDB (some parts were omitted
    for brevity):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The metric is uniquely defined by a name, a namespace, a list of dimensions
    (name-value pair), a value, and a unit of measure. After you have published some
    values to CloudWatch, you can use the CloudWatch console to view statistical graphs:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3c2095f7-f42f-4b20-bc76-e75a943caa13.png)'
  prefs: []
  type: TYPE_IMG
- en: Now we know how to monitor our Lambda functions using out-of-the-box metrics
    provided by AWS and insert custom metrics into CloudWatch to enrich their observability.
    Let's look at how to create an alarm based on those metrics to alert us in real
    time if something goes wrong in our Lambda functions.
  prefs: []
  type: TYPE_NORMAL
- en: CloudWatch alarms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'CloudWatch allows you to create alerts-based on the available metrics when
    unexpected behavior occurs. In the following example, we will create an alarm
    based on the error rate of the `FindAllMovies` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3fa0ab95-2e59-4eff-8d54-f6ac34dacb3c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In order to achieve that, click on the ring bell icon from the Actions column.
    Then, fill in the following fields to set up an alarm that will be triggered if
    the number of errors is more than `10` within five minutes. Once the alarm is
    triggered, an email will be sent using **Simple Notification Service** (**SNS**):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ba1efb6b-99c5-4ad2-9481-b9bb7cbb3916.png)'
  prefs: []
  type: TYPE_IMG
- en: CloudWatch will send a notification through an SNS topic, and you can create
    as many SNS topic subscriptions as needed to deliver the notifications to where
    you want (SMS, HTTP, email).
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the Create Alarm button; you should receive an email to confirm the
    subscription. You must confirm the subscription before notifications can be sent:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a4543244-f971-4e83-97be-1fca4344f1f8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once confirmed, every time the error rate of the Lambda function crosses the
    defined threshold, the alert will change its state from OK to ALARM:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ff1b8461-b283-472d-8eaa-f53e598639cb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After this, an email will be sent to you in response to the event:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6e702fd1-dbdf-4e02-a048-7073d732e443.png)'
  prefs: []
  type: TYPE_IMG
- en: You can simulate an alarm by changing its state temporarily with this AWS CLI
    command:  `aws cloudwatch set-alarm-state --alarm-name ALARM_NAME --state-value
    ALARM --state-reason demo`.
  prefs: []
  type: TYPE_NORMAL
- en: CloudWatch logs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While working with AWS Lambda, you might face the following errors when your
    function is being invoked:'
  prefs: []
  type: TYPE_NORMAL
- en: Application error
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Permissions denied
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Timeout exceeded
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory exceeded
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Aside from the first use case, the rest can be fixed easily, by granting the
    right IAM policies and increasing the Lambda function's timeout or memory usage.
    However, the first error requires more debugging and troubleshooting, which requires
    adding logging statements into your code to validate that your code is working
    as expected. Fortunately, each time the Lambda function's code is executed in
    response to an event, it writes a log entry into the CloudWatch log group associated
    with a Lambda function, which is `/aws/lambda/FUNCTION_NAME`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your Lambda function should be granted the following permissions to achieve
    that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'That being said, you might use Go''s built-in logging library, called the `log` package.
    The following is an example of how to use the `log` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The code is self-explanatory, it performs a reverse operation on a given string.
    I have added logging statements around various parts of the code using the `log.Println`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can then deploy the function to AWS Lambda, and invoke it either from the
    AWS console or with the `invoke` command. Lambda automatically integrates with
    Amazon CloudWatch logs and pushes all logs from your code to a CloudWatch logs,
    group associated with a Lambda function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e45bccab-f93d-4661-91d6-6c7fc2c0f4aa.png)'
  prefs: []
  type: TYPE_IMG
- en: So far, we've learned how to troubleshoot and analyze each invocation with log
    and runtime data. In the upcoming section, we will cover how to track all upstream
    and downstream calls to external services in the Lambda function's code to troubleshoot
    errors quickly and easily. To track all these calls, using AWS X-Ray, we will
    add code instrumentation in different code segments where the actual work is performed.
  prefs: []
  type: TYPE_NORMAL
- en: There are many third-party tools you might use to monitor serverless applications,
    which rely on CloudWatch. Therefore, they are failing too on the real-time issue.
    We expect this to be resolved in the future as AWS is launching new services and features at
    a rapid pace.
  prefs: []
  type: TYPE_NORMAL
- en: Tracing with AWS X-Ray
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: AWS X-Ray is an AWS-managed service that allows you to track incoming and outgoing
    requests that your Lambda functions are issuing. It collects that information
    in segments and uses metadata to record additional data to help you debug, analyze,
    and optimize your function.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, X-Ray can help you identify performance bottlenecks. However, it might
    require additional network calls that need to be made during the function's execution,
    adding to user-facing latency.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started, enable active tracing from the Lambda function''s configuration
    page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d72406c2-c9cc-4434-9820-7652783e87b9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following IAM policy is required to make the Lambda function publish the
    trace segments to X-Ray:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, navigate to AWS X-Ray console, click on Traces, invoke the Lambda function
    a few times, and refresh the page. New rows will be added to the trace list. For
    each trace, you will be given the code response and execution time:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3e546688-f17e-4664-9dfe-e7ffc11bd21e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here is a trace of the `FindAllMovies` function; it includes the time it takes
    for Lambda to initialize the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bc9e0fc6-0e35-41f4-9db1-d5b24fbe4321.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can also visualize this information in graph format, by clicking on the
    Service map item:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ba0d574c-367a-4d44-a658-581e21d2b37f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'For each traced invocation, Lambda will emit the Lambda service segment and
    all of its subsegments. In addition, Lambda will emit the Lambda function segment
    and the init subsegment. These segments will be emitted regardless of the function''s
    runtime, and without any code changes or additional libraries required. If you
    want your Lambda function''s X-Ray traces to include custom segments, annotations,
    or subsegments for downstream calls, you might need to install the following X-Ray
    Golang SDK:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the `FindAllMovies` function''s code to configure X-Ray using the `Configure`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We will track the call to DynamoDB in a subsegment by wrapping the DynamoDB
    client with the `xray.AWS` call, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Once again, invoke the Lambda function on the X-Ray `Traces` page; a new subsegment
    will be added with the time it spent scanning the `movies` table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/79e37175-591c-4532-aeec-81479af31884.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The DynamoDB call will also appear as a downstream node on the service map
    in the X-Ray console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b52caee3-57e6-4cb0-a121-bc4e416fcada.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that we are familiar how X-Ray works, let''s create something complex.
    Consider a simple Lambda function, which takes the URL of a movie poster page as
    input. It parses the HTML page, scraps the data, and saves it to a DynamoDB table.
    This function will do a `GET` method on the given URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, it uses the `goquery` library (**JQuery** Go-based implementation) to
    scrap the data from the HTML page, using CSS selectors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the movie object is created, it uses the `PutItem` method to save the
    movie to a DynamoDB table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that our function handler is defined, deploy it to AWS Lambda, and test
    it out by giving it a URL as an input parameter. As a result, the movie information
    will be displayed in a JSON format:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/23b29884-ec6a-473c-9fa0-34549d4de49e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you point your browser to the frontend built in previous chapters, the new
    movie should be part of the movies listed in the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/62cf19ea-b235-4dc3-a88b-4c286cfdf3a9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now our Lambda function is working as expected; let''s add tracing calls to
    downstream services. First, configure the X-Ray and use the `ctxhttp.Get` method
    to instrument the `GET` call as a subsegment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create a subsegment around the parsing logic. The subsegment is called
    `Parsing` and the `AddMetaData` method has been used to record additional information
    about the subsegment in order to troubleshoot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, wrap the DynamoDB client with the `xray.AWS()` call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'As a result, the following subsegment will appear in traces for the `ParseMovies`
    Lambda function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ddbf2885-9baa-4f68-89ca-bd4d81657c3b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you click on the Subsegments – Parsing on the Metadata tab, the movie attributes
    will be displayed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bb70f98a-383f-4617-bf1d-2c99c5bedc80.png)'
  prefs: []
  type: TYPE_IMG
- en: 'On the service map, the downstream call to DynamoDB and outgoing HTTP call
    will also be displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8f29cc75-e040-4644-82c6-3e7fb011e2ee.png)'
  prefs: []
  type: TYPE_IMG
- en: By now, you should have a clear idea of how to easily troubleshoot performance
    bottlenecks, latency spikes, and other issues that impact the performance of your
    Lambda-based application.
  prefs: []
  type: TYPE_NORMAL
- en: When you trace your Lambda function, an X-Ray daemon will automatically run
    in the Lambda environment to gather trace data and send it to X-Ray. The X-Ray
    daemon can be run locally if you want to test your function before deploying it
    to Lambda. A step-by-step installation guide can be found here: [https://docs.aws.amazon.com/xray/latest/devguide/xray-daemon-local.html](https://docs.aws.amazon.com/xray/latest/devguide/xray-daemon-local.html).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to monitor your Lambda function in near real
    time using AWS CloudWatch metrics. You also learned how to publish custom metrics
    and detect problems with alerts and reporting. In addition, we covered how to
    stream a function's code logs to CloudWatch. Finally, we saw how to use AWS X-Ray
    to debug, how to trace upstream and downstream calls, and how to integrate the
    X-Ray SDK with Lambda in Golang.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn about securing your serverless application.
  prefs: []
  type: TYPE_NORMAL
