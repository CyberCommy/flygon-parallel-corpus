- en: Testing Cloud-Native Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we take a deep dive into testing cloud-native applications.
    Testing has matured a lot from manual testing to automated testing, using various
    testing tools, strategies, and patterns. The benefit of this approach is that
    the testing can be done frequently in a failsafe fashion that is important for
    cloud development.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Testing concepts, such as **behavior-driven development (BDD)** and **test-driven
    development (TDD)**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing patterns, such as A/B testing and test doubles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing tools, such as JUnit, Cucumber, JaCoCo, and Spring Test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Types of testing, such as unit, integration, performance, and stress testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying the concepts of BDD and integration testing to the Product service
    that we developed in [Chapter 2](8a0a7cae-4aaa-460d-a760-59d0ffde9b48.xhtml), *Writing
    Your First Cloud-Native Application*, and enhanced in [Chapter 4](678ed895-5878-4b5d-854a-f437840cdaa9.xhtml),
    *Extending Your Cloud-Native Application*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing test cases before development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this book, we started developing a simple service in [Chapter 2](8a0a7cae-4aaa-460d-a760-59d0ffde9b48.xhtml), *Writing
    Your First Cloud-Native Application*, in Spring Boot to get you excited about
    cloud development. However, real development follows a different style of best
    practice.
  prefs: []
  type: TYPE_NORMAL
- en: TDD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A project starts with understanding the requirements and writing test cases
    that validate the requirements. Since the code does not exist at this point, the
    test case will fail. Then, the code is written that passes the test case. This
    process iterates till the test cases and the required code are complete to realize
    the business functionality. Kent Beck has an excellent book on this subject, *Test
    Driven Development by Example*. In the next section, we will redo the product
    service from [Chapter 4](678ed895-5878-4b5d-854a-f437840cdaa9.xhtml), *Extending
    Your Cloud-Native Application*, using the principles in this chapter. But before
    that, let's look at another important concept, BDD.
  prefs: []
  type: TYPE_NORMAL
- en: BDD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Taking a leaf out of Agile development principles and user stories, BDD encourages
    us to think of development as a set of scenarios in which, given certain conditions,
    the system behaves in a certain, predictable way to the set stimuli. If these
    scenarios, conditions and actions can be captured in an easy-to-understand common
    language between the business and IT team, which brings a lot of clarity to development
    and reduces the chances of committing mistakes. It is a way to write specifications
    that are easily testable.
  prefs: []
  type: TYPE_NORMAL
- en: Moving ahead in this chapter, we will take our product service and apply BDD
    to it using the Cucumber tool.
  prefs: []
  type: TYPE_NORMAL
- en: Testing patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing large internet applications for the cloud requires a disciplined approach
    where a few patterns come in handy.
  prefs: []
  type: TYPE_NORMAL
- en: A/B testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The original intent of A/B testing, also called **split testing**, was for experimentation
    to find out the user response of a few selected users to two different web pages
    with the same functionality. If the users responded favorably to a certain pattern
    as compared to the other set, it was selected.
  prefs: []
  type: TYPE_NORMAL
- en: 'This concept can be expanded to the introduction of new features in a phased
    manner. The feature, campaign, layout, or new service is introduced to a controlled
    set of users and the response is measured:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8e04a14e-0ee4-454f-ab59-77b7b52500fa.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After the test window is over, the results are aggregated to plan the effectiveness
    of the updated functionality.
  prefs: []
  type: TYPE_NORMAL
- en: The strategy in such testing is that for the selected set of users, an HTTP
    `302` (temporary redirect) is used to switch the users from the regular website
    to a newly designed website. This will require running a variation of the website
    or functional services for the test period. Once the test is successful, the feature
    is slowly expanded to more users and is merged into the main website/code base.
  prefs: []
  type: TYPE_NORMAL
- en: Test doubles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Often, the functionality under test depends on components and APIs which are
    independently being developed by other teams, which has the following disadvantages:'
  prefs: []
  type: TYPE_NORMAL
- en: They may not be available for testing at the time of development of your functionality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They may not be always available and be set up with the data required for testing
    various cases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the actual components each time may be slower
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hence, the concept of a test double became popular. A test double (like a stunt
    double in a movie) is a component/API that replaces the actual component and mimics
    its behavior. The test double component is typically a lightweight and easy-to-change
    component that is under the control of the team building the functionality, unlike
    the real components that could be dependencies or external processes.
  prefs: []
  type: TYPE_NORMAL
- en: There are many types of test doubles, such as Dummy, Fakes, Test Stubs, and
    Mocks.
  prefs: []
  type: TYPE_NORMAL
- en: Test Stubs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Test Stubs are useful when a downstream component returns a response that alters
    the behavior of the system under test; for example, if our product service was
    to call a reference data service whose output decides the behavior of the product
    service. A Test Stub for a reference data service can mimic the various response
    types that cause change in the behavior of the product service:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/adc5e088-75aa-4700-a19e-18a933b4725f.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Mock objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next type of test double is a Mock object, which records how the system
    behaves with it and then presents the recording for verification. For example,
    a Mock database component could check whether it was not being called for a product
    that was supposed to be answered from a cache layer instead of a database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a basic diagram representation of the ecosystem around Mocks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4475e788-f329-4f3f-b7ae-dad19dbd83a7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Mock APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In cloud development, you will be building a service that depends on other services
    or mainly the APIs through which the services are accessed. Often, the other services
    will not be available for testing immediately. But you cannot stop your development.
    This is where mocking or adding a dummy service is a useful pattern to test your
    service.
  prefs: []
  type: TYPE_NORMAL
- en: A service Mock emulates all the contracts and behavior of the real service.
    A few examples such as [WireMock.org](http://wiremock.org/) or [Mockable.io](https://www.mockable.io/)
    help us to emulate the API and test the main cases, edge cases, and failure conditions.
  prefs: []
  type: TYPE_NORMAL
- en: Ensuring code review and coverage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The manual review of code is augmented by automatic code review tools. This
    helps to identify any possible errors in the code and ensure the coverage is complete
    and all paths are tested.
  prefs: []
  type: TYPE_NORMAL
- en: We will look at the code coverage tool JaCoCo later.
  prefs: []
  type: TYPE_NORMAL
- en: Types of testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The various types of testing we discuss later in the chapter were already known
    even before cloud computing became popular. The principles of Agile development
    using **continuous integration** (**CI**) and **continuous development** (**CD**)
    make it important to automate these types of testing so that they are executed
    each time a code check-in and build happens.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The aim of unit testing is to test each class or code component and ensure it
    is performing as expected. JUnit is the popular Java framework for unit testing.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Mock object pattern and Test Stubs, it is possible to isolate the
    dependent components of the services being tested so that the testing focuses
    on the system under test, which is the service.
  prefs: []
  type: TYPE_NORMAL
- en: JUnit is the most popular tool to perform unit testing.
  prefs: []
  type: TYPE_NORMAL
- en: Integration testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The aim of component testing is to check whether the components, such as the
    Product service, perform as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Components such as `spring-boot-test` help run the test suites and run the test
    on whole components. We are going to see this in action in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Load testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Load testing involves pushing a large volume of concurrent requests to the system
    under test for a period and observing the effect, such as response time and error
    rates on the system. A system is said to be horizontally scalable if adding more
    instances of the service enables it to handle additional loads.
  prefs: []
  type: TYPE_NORMAL
- en: JMeter and Gatling are the popular tools to cover this dimension.
  prefs: []
  type: TYPE_NORMAL
- en: Regression testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In introducing new functionality, the existing functionality should not break.
    Regression testing covers this.
  prefs: []
  type: TYPE_NORMAL
- en: Selenium is a web browser-based, open source tool popular in this space to perform
    regression testing.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the Product service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's apply the testing principles we learned to the Product service that we
    have been building so far. We start from a user point of view and hence with acceptance
    testing.
  prefs: []
  type: TYPE_NORMAL
- en: BDD through Cucumber
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first step is to recall the specification of our product service. In [Chapter
    4](678ed895-5878-4b5d-854a-f437840cdaa9.xhtml), *Extending Your Cloud-Native Application*,
    we built a few features on our product service that allowed us to fetch, add,
    modify, and delete products, and get a list of product IDs given a product category.
  prefs: []
  type: TYPE_NORMAL
- en: Let's represent this as features in Cucumber.
  prefs: []
  type: TYPE_NORMAL
- en: Why Cucumber?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cucumber allows the expression of behavior in a plain-English-like language
    called **Gherkin**. This enables a ubiquitous language from the domain-driven
    design parlance, so that the communication between the business, development,
    and testing is seamless and well-understood.
  prefs: []
  type: TYPE_NORMAL
- en: How does Cucumber work?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s understand how Cucumber works:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step in Cucumber is to express the user story as features with scenarios,
    and `Given`-`When`-`Then` conditions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Given`: Sets the preconditions for the behavior'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`When`: Trigger that changes the state of the system, for example, making a
    request to the service'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Then`: How the service should respond'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are translated to automated test cases using the `cucumber-spring` translation
    layer so that they can be executed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's start with a simple `getProduct` acceptance test case. We will write a
    simple feature in Gherkin that gets the product if the product ID exists, or returns
    an error if the product ID is not found.
  prefs: []
  type: TYPE_NORMAL
- en: Let's realize the following feature in a true BDD style. The `get` API on the
    Product service returns product details such as description and category ID given
    a product ID. It can also return an error, for example, 404 if the product is
    not found. Let's represent these two behaviors as two separate scenarios on our
    Gherkin feature file.
  prefs: []
  type: TYPE_NORMAL
- en: '**Feature**: `getProduct`'
  prefs: []
  type: TYPE_NORMAL
- en: Get the product details given a product ID.
  prefs: []
  type: TYPE_NORMAL
- en: '**Scenario 1**: The product ID is valid and exists. The product name and category
    it belongs to will be returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Given` the product service is running'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`When` the get product service is called with existing product ID `1`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Then` we should get a response with HTTP status code `200`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`And` return product details with, name `Apples` and category `1`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Scenario 2**: The product ID is invalid or does not exist. An error should
    be returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Given` product service is running'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`When` the get product service is called with a non-existing product ID `456`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Then` return a 404 not found status'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`And` return the error message `No product for ID 456`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Scenario 1 is a successful scenario where a product ID existing in the database
    is returned and validated against.
  prefs: []
  type: TYPE_NORMAL
- en: Scenario 2 checks for a failure condition of an ID that does not exist in the
    database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each scenario is divided into multiple parts. For the happy-path scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Given` sets a precondition. In our case, it is simple enough: that the product
    service should be running.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`When` changes the state of the system and, in our case, it is making the request
    to the service by giving a product ID.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Then` and `And` are the results that are expected on the system. In this case,
    we expect the service to return a `200` success code and the valid description
    and category codes for the given product.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you may have noticed, this is the documentation of our service that can be
    understood by the business and the testing team as well as the developers. It
    is technology-agnostic; that is, it does not change if the implementation is done
    through Spring Boot, Ruby, or a .NET microservice.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will map the service to the Spring Boot application
    that we developed.
  prefs: []
  type: TYPE_NORMAL
- en: Code coverage using JaCoCo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JaCoCo is a code coverage library developed by the EclEmma team. JaCoCo embeds
    an agent in JVM which scans the code paths traversed and creates a report.
  prefs: []
  type: TYPE_NORMAL
- en: This report can be imported into a wider DevOps code quality tool such as SonarQube.
    SonarQube is a platform that helps to manage code quality with numerous plugins
    and integrates nicely with DevOps processes (as we shall see in later chapters).
    It is open source but also has a commercial edition. It is a platform as it has
    multiple components, such as server (Compute Engine Server, Web Server, and Elasticsearch),
    database, and scanners that are language-specific.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Boot Test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spring Boot Test extends and simplifies the Spring-test module provided by
    the Spring Framework. Let''s look at the essential elements to write our acceptance
    tests and then we can revisit the details later in the chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Copy the project that we created in [Chapter 4](678ed895-5878-4b5d-854a-f437840cdaa9.xhtml), *Extending
    Your Cloud-Native Application* with HSQLDB and Hazelcast, as a new project for
    this chapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Include the dependency on Spring in the Maven POM file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As you may have noticed, the `scope` is changed to `test`. This means that the
    dependency we are defining is not required for normal runtime, only for compilation
    and test execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add two more dependencies to Maven. We are downloading the libraries for Cucumber
    and its Java translation, along with `spring-boot-starter-test`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `CucumberTest` class is the main class that starts the Cucumber tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '`RunWith` tells the JUnit to use Spring''s testing support, which then uses
    Cucumber. We give the path to our `.feature` file, which contains the test cases
    in Gherkin discussed earlier.'
  prefs: []
  type: TYPE_NORMAL
- en: The `Productservice.feature` file is the text file containing the scenarios
    in Gherkin language, as discussed earlier. We will have two test cases featured
    here. This file is present in the `src/test/resources` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `CucumberTestSteps` class contains the translation of the steps in Gherkin
    to the equivalent Java code. Each step corresponds to a method and the methods
    get called based on the scenario construction in the Gherkin file. Let''s discuss
    all steps related to one use case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `@SpringBootTest` annotation tells the Spring Boot Framework that it is
    a test class. The `RANDOM_PORT` indicates the test service to start Tomcat on
    a random port for testing.
  prefs: []
  type: TYPE_NORMAL
- en: We inject an autowired `restTemplate` which will help access the HTTP/REST service
    and receive the response which will be tested.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, note the methods with the annotations `@Given`, `@When`, and `@Then`.
    Each method uses a regular expression to extract the variable (from the feature
    file) and uses it for assertions in the method. We have systematically tested
    this by doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Checking whether the service is running first by accessing the `/health` (as
    we did for Spring Boot Actuator in [Chapter 2](8a0a7cae-4aaa-460d-a760-59d0ffde9b48.xhtml),
    *Writing Your First Cloud-Native Application*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Calling the service with the product ID.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Checking whether the return code is `200` and the description and category of
    the response match the expected result.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Running the tests.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Right-clicking the `CucumberTest.java` file and selecting Run As | JUnit Test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/aeb8a942-20e4-4ae4-b5c2-f4ab4aca8499.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You will see the console fire up with the start-up messages. Finally, the JUnit
    will reflect the test results as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/99043fcd-d743-4357-bab9-11aa1fdb232b.png)'
  prefs: []
  type: TYPE_IMG
- en: As an exercise, try adding the test cases to the inserting, updating, and deleting
    a product methods in the `ProductService` class.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating JaCoCo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s integrate JaCoCo into our existing project:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, include the plugin that includes JaCoCo in the POM file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The second and third step is to include pre-executions and post-executions into
    the preceding plugin.
  prefs: []
  type: TYPE_NORMAL
- en: The pre-execution prepares the agent to be configured and added to the command
    line.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The post-execution ensures that the reports get created in the output folders:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the created command-line change has to be inserted into the `maven-surefire-plugin`
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we are all set to run the coverage report. Right-click on the project
    and select Run As | Maven test to test the program, as shown in the following
    screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/74d4a555-4b66-497f-8f7e-6ff1f20354f2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As the console gets filled with the Spring Boot initiation, you will find the
    following lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This tells us that two scenarios were executed with `8 Steps` (as before).
    But in addition, `coverage-reports` got generated and placed in the `target` directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/2927cb7b-c5d5-4c0a-bca2-d78fe6dd75bf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the `site` folder, click on `index.html`; you will see the coverage report
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c10de181-60d7-476e-aa69-57ce441e6297.png)'
  prefs: []
  type: TYPE_IMG
- en: 'On investigation of the `product` package, you can see that the `ProductService`
    is only `24%` covered, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a3cb7b70-a1fb-4bc9-88cd-612d0f4af2bf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The reason for this is that we have covered only the `getProduct` API in the
    service. The `insertProduct` and `updateProduct` have not been covered. This is
    showcased in the drill-down report in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5d010c06-257b-4370-b8ea-fa9de6bc6d7c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'On the `getProduct` method, the coverage is complete. This is because, in two
    scenarios, we have covered the happy path as well as the error condition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/bb6b3bad-be68-4019-b44f-c45e330552ea.png)'
  prefs: []
  type: TYPE_IMG
- en: 'On the other hand, you will find that we have missed covering the branches
    in the `ExceptionHandler` class as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/508a5194-6c30-4d13-8780-6d7da4326ab2.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the upcoming chapters, we will integrate the coverage report with the DevOps
    pipeline and see it working during CI and CD. However, first, let's look at the
    deployment mechanisms.
  prefs: []
  type: TYPE_NORMAL
