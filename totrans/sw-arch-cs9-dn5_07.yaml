- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Azure Kubernetes Service
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is dedicated to describing the Kubernetes microservices orchestrator
    and, in particular, its implementation in Azure named Azure Kubernetes Service.
    The chapter explains the fundamental Kubernetes concepts, and then focuses on
    how to interact with a Kubernetes cluster, and how to deploy an Azure Kubernetes
    application. All concepts are put into practice with simple examples. We recommend
    reading *Chapter 5*, *Applying a Microservice Architecture to Your Enterprise
    Application*, and *Chapter 6*, *Azure Service Fabric*, before dealing with this
    chapter, since it relies on the concepts explained in these previous chapters.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'More specifically, in this chapter you will learn about the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes basics
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interacting with Azure Kubernetes clusters
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced Kubernetes concepts
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have learned how to implement and deploy
    a complete solution based on Azure Kubernetes.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Visual Studio 2019 free Community Edition or better, with all the database tools
    installed or any other `.yaml` file editor such as Visual Studio Code.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A free Azure account. The *Creating an Azure account* section in *Chapter 1*,
    *Understanding the Importance of Software Architecture*, explains how to create one.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code for this chapter is available at [https://github.com/PacktPublishing/Software-Architecture-with-C-9-and-.NET-5](https://github.com/PacktPublishing/Software-Architecture-with-C-9-and-.NET-5).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes basics
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kubernetes is an advanced, open source orchestrator that you can install locally
    on your private machine's cluster. At the time of writing, it is the most widespread
    orchestrator, so Microsoft also offers it as a better alternative to Azure Service
    Fabric, since it is currently the *de facto* standard, and can rely on a wide
    ecosystem of tools and applications. This section introduces basic Kubernetes
    concepts and entities.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: A Kubernetes cluster is a cluster of virtual machines running the Kubernetes
    orchestrator. As for Azure Service Fabric, the virtual machines composing the
    cluster are called nodes. The smallest software unit we can deploy on Kubernetes
    is not a single application, as in the case of Azure Service Fabric, but an aggregate
    of containerized applications called pods. While Kubernetes supports various types
    of containers, the most commonly used container type is Docker, which we analyzed
    in *Chapter 5*, *Applying a Microservice Architecture to Your Enterprise Application*,
    so we will confine our discussion to Docker.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '`pods` are important since applications belonging to the same pod are ensured
    to run on the same node. This means that they can easily communicate through localhost
    ports. Communication between different pods, however, is more complex since the
    IP addresses of pods are ephemeral resources because pods have no fixed node where
    they run, but are moved from one node to another by the orchestrator. Moreover,
    pods may be replicated to increase performance, so, in general, it makes no sense
    addressing a message to a specific pod, but just to any of the identical replicas
    of the same pod.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: While, in Azure Service Fabric, the infrastructure gives automatically virtual
    net addresses to groups of identical replicas, in Kubernetes we need to define
    explicit resources called Services that are assigned virtual addresses by the
    Kubernetes infrastructure and forward their communications to sets of identical
    pods. In short, Services are Kubernetes way to assign constant virtual addresses
    to sets of pod replicas.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: All Kubernetes entities may be assigned name value pairs called labels that
    are used to reference them through a pattern matching mechanism. More specifically,
    Selectors select Kubernetes entities by listing labels they must have.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Thus, for instance, all pods that receive traffic from the same Service are
    selected by specifying labels they must have in the Service definition.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: The way a Service routes its traffic to all connected pods depends on the way
    pods are organized. Stateless pods are organized in so called `ReplicaSets`, which
    are similar to stateless replicas of Azure Service Fabric services. As Azure Service
    Fabric stateless services, `ReplicaSets` have a unique virtual address assigned
    to the whole group and traffic is split equally among all pods of the group.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: 'Stateful Kubernetes pod replicas are organized into so called `StatefulSets`.
    Similar to Azure Service Fabric stateful services, `StatefulSets` use sharding
    to split the traffic among all their pods. For this reason, Kubernetes Services
    assign a different name to each pod of the `StatefulSet` they are connected to.
    These names look like the following: `basename-0.<base URL>`, `basename-1.<base
    URL>`, ..., `basename-n.<base URL>`. This way, message sharding is easily accomplished
    as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Each time a message must be sent to a `StatefulSet` composed of *N* replicas,
    you compute a hash between 0 and *N*-1, say `x`.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the postfix `x` to a base name to get a cluster address, such as `basename-x.<base
    URL>`.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Send the message to the `basename-x.<base URL>` cluster address.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Kubernetes has no predefined storing facilities, and you can't use node disk
    storage since pods are moved among available nodes, so long-term storage must
    be provided with sharded cloud databases or with other kinds of cloud storage.
    While each pod of a `StatefulSet` can access a sharded cloud database with the
    usual connection string technique, Kubernetes offers a technique to abstract disk-like
    cloud storage offered by the external Kubernetes cluster environment. We will
    describe these in the *Advanced Kubernetes concepts* section.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: All Kubernetes entities mentioned in this short introduction can be defined
    in a `.yaml` file, which, once deployed to a Kubernetes cluster, causes the actual
    creation of all entities defined in the file. The subsection that follows describes
    `.yaml` files, while the other subsections thereafter describe in detail all the
    basic Kubernetes objects mentioned so far, and explain how to define them in a
    `.yaml` file. Further Kubernetes objects will be described throughout the whole
    chapter.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: .yaml files
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`.yaml` files, like JSON files, are a way to describe nested objects and collections
    in a human-readable way, but they do it with a different syntax. You have objects
    and lists, but object properties are not surrounded by `{}`, and lists are not
    surrounded by `[]`. Instead, nested objects are declared by simply indenting their
    content with spaces. The number of spaces can be freely chosen, but once they''ve
    been chosen, they must be used consistently.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: List items can be distinguished from object properties by preceding them with
    a hyphen (`-`).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example involving nested objects and collections:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding `Person` object has a `Spouse` nested object, and a nested collection
    of addresses.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '`.yaml` files can contain several sections, each defining a different entity,
    that are separated by a line containing the `---` string. Comments are preceded
    by a `#` symbol, which must be repeated on each comment line.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: 'Each section starts with the declaration of the Kubernetes API group and version.
    In fact, not all objects belong to the same API group. For objects that belong
    to the `core` API group, we can specify just the API version, as in the following
    example:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'While objects belonging to different API groups must also specify the API name,
    as in the following example:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the next subsection, we analyze in detail `ReplicaSets` and `Deployments`
    that are built on top of them.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: ReplicaSets and Deployments
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most important building block of Kubernetes applications is the `ReplicaSet`,
    that is, a pod replicated *n* times. Usually, however, you adopt a more complex
    object that is built on top of the `ReplicaSet` – the `Deployment`. `Deployments`
    not only create a `ReplicaSet`, but also monitor them to ensure that the number
    of replicas is kept constant, independent of hardware faults and other events
    that might involve the `ReplicaSets`. In other words, they are a declarative way
    of defining `ReplicaSets` and pods.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: 'Each `Deployment` has a name (`metadata->name`), an attribute that specifies
    the desired number of replicas (`spec->replicas`), a key-value pair (`spec ->`
    `selector-> matchLabels`) that selects the pods to monitor, and a template (`spec->template`)
    that specifies how to build the pod replicas:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`namespace` is optional and, if not provided, a namespace called `default`
    is assumed. Namespaces are a way of keeping separate the objects of a Kubernetes
    cluster. For instance, a cluster can host the objects of two completely independent
    applications each placed in a separate `namespace`.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: Indented inside the template is the definition of the pod to replicate. Complex
    objects such as `Deployments` can also contain other kinds of templates, for instance,
    a template of disk-like memory required by the external environment. We will discuss
    this further, in the *Advanced Kubernetes concepts* section.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: 'In turn, the pod template contains a `metadata` section with labels used to
    select the pods, and a `spec` section with a list of all of the containers:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Each container has a name and must specify the name of the Docker image to use
    for creating the containers. In case the Docker image is not contained in the
    public Docker registry, the name must be a URI that also includes the repository
    location.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Then, containers must specify the memory and CPU resources that they need to
    be created in the `resources->requests` object. A pod replica is created only
    if these resources are currently available. The `resources->limits` object, instead,
    specifies the maximum resources a container replica can actually use. If, during
    the container execution, these limits are exceeded, actions are taken to limit
    them. More specifically, if the CPU limit is exceeded, the container is throttled
    (its execution is stopped to restore its CPU consumption), while, if the memory
    limits are exceeded, the container is restarted. `containerPort` must be the port
    exposed by the container. Here, we can also specify further information, such
    as the protocol used.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: CPU time is expressed in millicores, where 1,000 millicores means 100% of the
    CPU time, while memory is expressed in Mebibytes (*1Mi = 1024*1024 bytes*), or
    other units. `env` lists all the environment variables to pass to the containers
    with their values.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: Both containers and pod templates can contain further fields, such as properties
    that define virtual files, and properties that define commands that returns the
    readiness and the health state of the container. We will analyze these in the
    *Advanced Kubernetes concepts* section.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: The following subsection describes pod sets conceived to store state information.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: StatefulSets
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`StatefulSets` are very similar to a `ReplicaSet`, but while pods of a `ReplicaSet`
    are indistinguishable processors that contribute in parallel to the same workload
    through load balancing strategies, pods in a `StatefulSet` have a unique identity,
    and can contribute to the same workload only through sharding. This is because
    `StatefulSets` were conceived to store information, and information cannot be
    stored in parallel, merely split among several stores by means of sharding.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: For the same reason, each pod instance is always kept tied to any virtual disk
    space it requires (see the *Advanced Kubernetes concepts* section), so that each
    pod instance is responsible for writing to a specific store.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, `StatefulSets` pods instances have ordinal numbers attached to them.
    They are started in sequence according to these numbers, and they are stopped
    in reverse order. If the `StatefulSet` contains *N* replicas, these numbers go
    from zero to *N*-1\. Moreover, a unique name for each instance is obtained by
    chaining the pod name specified in the template, with the instance ordinal, in
    the following way – `<pod name>-<instance ordinal>`. Thus, instance names will
    be something like `mypodname-0`, `mypodname-1`, and so on. As we will see in the
    *Services* subsection, instance names are used to build unique cluster network
    URIs for all instances, so that other pods can communicate with a specific instance
    of a `StatefulSets` pods.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a typical `StatefulSet` definition:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The template part is the same as that of `Deployments`. The main conceptual
    difference with `Deployments` is the `serviceName` field. It specifies the name
    of a service that must be connected with `StatefulSets` to provide unique network
    addresses for all pod instances. We will discuss this subject in more detail in
    the *Services* subsection. Moreover, usually, `StatefulSets` use some form of
    storage. We will discuss this in detail in the *Advanced Kubernetes concepts*
    section.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: It is worth pointing out also that the default ordered creation and stop strategy
    of `StatefulSets` can be changed by specifying an explicit `Parallel` value for
    the `spec->podManagementPolicy` property (the default value is `OrderedReady`).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: The following subsection describes how to provide stable network addresses to
    both `ReplicaSets` and `StatefulSets`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: Services
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since pod instances can be moved between nodes, they have no stable IP address
    attached to them. Services take care of assigning a unique and stable virtual
    address to a whole `ReplicaSet` and of load balancing the traffic to all its instances.
    Services are not software objects created in the cluster, just an abstraction
    for the various settings and activities needed to put in place their functionalities.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: Services work at level 4 of the protocol stack, so they understand protocols
    such as TCP, but they aren't able to perform, for instance, HTTP-specific actions/transformations,
    such as for instance, ensuring a secure HTTPS connection. Therefore, if you need
    to install HTTPS certificates on the Kubernetes cluster, you need a more complex
    object that is capable of interacting at level 7 of the protocol stack. The `Ingress`
    object was conceived for this. We will discuss this in the next subsection.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: Services also handle assigning a unique virtual address to each instance of
    a `StatefulSet`. In fact, there are various kinds of Services; some were conceived
    for `ReplicaSet` and others for `StatefulSet`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: A `ClusterIP` service type is assigned a unique cluster internal IP address.
    It specifies the `ReplicaSets` or `Deployments` it is connected to through label
    pattern matching. It uses tables maintained by the Kubernetes infrastructure to
    load balance the traffic it receives among all pod instances to which it is connected.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, other pods can communicate with the pods connected to a Service
    by interacting with this Service that is assigned the stable network name `<service
    name>.<service namespace>.svc.cluster.local`. Since they are just assigned local
    IP addresses, a `ClusterIP` service can''t be accessed from outside the Kubernetes
    cluster. Here is the definition of a typical `ClusterIP` service:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Each Service can work on several ports, and can route any port (`port`) to the
    ports exposed by the containers (`targetPort`). However, it is very often the
    case that `port = targetPort`. Ports can be given names, but these names are optional.
    Also, the specification of the protocol is optional, in which case all supported
    level 4 protocols are allowed. The `spec->selector` property specifies all the
    name/value pairs that select the pods for the Service to route the communications
    it receives to.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Since a `ClusterIP` service can't be accessed from outside the Kubernetes cluster,
    we need other Service types to expose a Kubernetes application on a public IP
    address.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '`NodePort`-type Services are the simplest way to expose pods to the outside
    word. In order to implement a `NodePort` service, the same port `x` is opened
    on all nodes of the Kubernetes cluster and each node routes the traffic it receives
    on this port to a newly created `ClusterIP` service.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: 'In turn, the `ClusterIP` service routes its traffic to all pods selected by
    the service:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16756_07_01.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.1: NodePort service'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, it is enough to communicate with port `x` through a public IP of
    any cluster node in order to access the pods connected to the `NodePort` service.
    Of course, the whole process is completely automatic and hidden to the developer,
    whose only preoccupation is getting the port number `x` in terms of where to forward
    the external traffic.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: 'The definition of a `NodePort` service is identical to the definition of a
    `ClusterIP` service, the only difference being that they specify a value of `NodePort`
    for the `spec->type` property:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As a default, a node port `x` in the range 30000-327673 is automatically chosen
    for each `targetPort` specified by the `Service`. The port property associated
    with each `targetPort` is meaningless for `NodePortServices` since all traffic
    passes through the selected node port `x`, and, for convention, is set to the
    same value of the `targetPort`. The developer can also set the node port `x` directly
    through a `nodePort` property:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: When the Kubernetes cluster is hosted in a cloud, the more convenient way to
    expose some pods to the outside world is through a `LoadBalancer` service, in
    which case the Kubernetes cluster is exposed to the outside world through a level
    4 load balancer of the selected cloud provider.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: 'The definition of a `LoadBalancer` service is identical to that of a `ClusterIp`
    service, the only difference being that the `spec->type` property must be set
    to `LoadBalancer`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If no further specification is added, a dynamic public IP is randomly assigned.
    However, if a specific public IP address to the cloud provider is required, it
    can be used as a public IP address for the cluster load balancer by specifying
    it in the `spec->loadBalancerIP` property:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In Azure Kubernetes, you must also specify the resource group where the IP
    address was allocated, in an annotation:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In Azure Kubernetes, you can remain with a dynamic IP address, but you can
    get a public static domain name of the type `<my-service-label>.<location>.cloudapp.azure.com`,
    where `<location>` is the geographic label you have chosen for your resources.
    `<my-service-label>` is a label that you verified makes the previous domain name
    unique. The chosen label must be declared in an annotation of your service, as
    shown here:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`StatefulSets` don''t need any load balancing since each pod instance has its
    own identity, but just require a unique URL address for each pod instance. This
    unique URL is provided by the so called headless Services. Headless Services are
    defined like `ClusterIP` services, the only difference being that they have a
    `spec->clusterIP` property set to `none`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: All `StatefulSets` handled by a headless Service must place the Service name
    in their `spec-> serviceName` property, as already stated in the *StatefulSets*
    subsection.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: The unique name provided by a headless Service to all `StatefulSets` pod instances
    it handles is `<unique pod name>.<service name>.<namespace>.svc.cluster.local`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Services only understand low-level protocols, such as TCP/IP, but most web applications
    are situated on the more sophisticated HTTP protocol. That's why Kubernetes offers
    higher-level entities called `Ingresses` that are built on top of services. The
    following subsection describes these and explains how to expose a set of `pods`
    through a level 7 protocol load balancer, which could offer you typical HTTP services,
    instead of through a `LoadBalancer` service.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 服务只能理解低级协议，如TCP/IP，但大多数Web应用程序位于更复杂的HTTP协议上。这就是为什么Kubernetes提供了基于服务的更高级实体`Ingresses`。下一小节描述了这些内容，并解释了如何通过级别7协议负载均衡器将一组`pods`公开，该负载均衡器可以为您提供典型的HTTP服务，而不是通过`LoadBalancer`服务。
- en: Ingresses
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Ingresses
- en: '`Ingresses` are mainly conceived to work with HTTP(S). They provide the following
    services:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`Ingresses`主要用于使用HTTP(S)。它们提供以下服务：'
- en: HTTPS termination. They accept HTTPS connections and route them in HTTP format
    to any service in the cloud.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTPS终止。它们接受HTTPS连接并将其路由到云中的任何服务的HTTP格式。
- en: Name-based virtual hosting. They associate several domain names with the same
    IP address and route each domain, or `<domain>/<path prefix>`, to a different
    cluster Service.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于名称的虚拟主机。它们将多个域名与同一个IP地址关联，并将每个域或`<domain>/<path prefix>`路由到不同的集群服务。
- en: Load balancing.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 负载均衡。
- en: '`Ingresses` rely on web servers to offer the above services. In fact, `Ingresses`
    can be used only after having installed an `Ingress Controller`. `Ingress Controllers`
    are custom Kubernetes objects that must be installed in the cluster. They handle
    the interface between Kubernetes and a web server, which can be either an external
    web server or a web server that is part of the `Ingress Controller` installation.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`Ingresses`依赖于Web服务器来提供上述服务。实际上，只有在安装了`Ingress Controller`之后才能使用`Ingresses`。`Ingress
    Controllers`是必须安装在集群中的自定义Kubernetes对象。它们处理Kubernetes与Web服务器之间的接口，可以是外部Web服务器或作为`Ingress
    Controller`安装的Web服务器的一部分。'
- en: We will describe the installation of an `Ingress Controller` based on the NGINX
    web server in the *Advanced Kubernetes concepts* section, as an example of the
    use of Helm. The *Further reading* section contains information on how to install
    also an `Ingress Controller` that interfaces an external Azure application gateway.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在*高级Kubernetes概念*部分中描述基于NGINX Web服务器的`Ingress Controller`的安装，作为使用Helm的示例。
    *进一步阅读*部分包含有关如何安装与外部Azure应用程序网关进行接口的`Ingress Controller`的信息。
- en: HTTPS termination and name-based virtual hosting can be configured in the `Ingress`
    definition in a way that is independent of the chosen `Ingress Controller`, while
    the way load balancing is achieved depends on the specific `Ingress Controller`
    chosen and on its configuration. Some `Ingress Controller` configuration data
    can be passed in the `metadata-> annotations` field of the `Ingress` definition.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: HTTPS终止和基于名称的虚拟主机可以在`Ingress`定义中进行配置，与所选择的`Ingress Controller`无关，而负载均衡的实现方式取决于所选择的特定`Ingress
    Controller`及其配置。一些`Ingress Controller`配置数据可以通过`Ingress`定义的`metadata->annotations`字段传递。
- en: 'Name-based virtual hosting is defined in a `spec>rules` section of the Ingress
    definition:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 基于名称的虚拟主机在Ingress定义的`spec>rules`部分中定义：
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Each rule specifies an optional hostname that can contain the `*` wildcard.
    If no hostname is provided, the rule matches all hostnames. For each rule, we
    can specify several paths, each redirected to a different service/port pair, where
    the service is referenced through its name. The way the match with each `path`
    is carried out depends on the value of `pathType`; if this value is `Prefix`,
    the specified `path` must be a prefix of any matching path. Otherwise, if this
    value is `Exact`, the match must be exact. Matches are case-sensitive.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 每个规则都指定了一个可选的主机名，可以包含`*`通配符。如果没有提供主机名，则规则匹配所有主机名。对于每个规则，我们可以指定多个路径，每个路径重定向到不同的服务/端口对，其中服务通过其名称引用。与每个`path`的匹配方式取决于`pathType`的值；如果该值为`Prefix`，则指定的`path`必须是任何匹配路径的前缀。否则，如果该值为`Exact`，则匹配必须完全相同。匹配区分大小写。
- en: 'HTTPS termination on a specific hostname is specified by associating it a certificate
    encoded in a Kubernetes secret:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将特定主机名与在Kubernetes密钥中编码的证书关联，可以指定特定主机名上的HTTPS终止：
- en: '[PRE15]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: HTTPS certificates can be obtained free of charge at [https://letsencrypt.org/](https://letsencrypt.org/).
    The procedure is explained on the website, but basically, as with all certificate
    authorities, you provide a key and they return the certificate based on that key.
    It is also possible to install a **certificate manger** that takes care of automatically
    installing and renewing the certificate. The way a key/certificate pair is encoded
    in a Kubernetes secret string is detailed in the *Advanced Kubernetes concepts*
    section.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 可以免费获取HTTPS证书，网址为[https://letsencrypt.org/](https://letsencrypt.org/)。该过程在网站上有详细说明，但基本上，与所有证书颁发机构一样，您提供一个密钥，他们根据该密钥返回证书。还可以安装一个**证书管理器**，它负责自动安装和更新证书。在Kubernetes密钥/证书对如何编码为Kubernetes密钥的字符串中，详细说明在*高级Kubernetes概念*部分中。
- en: 'The whole `Ingress` definition looks like the following code:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 整个`Ingress`定义如下所示：
- en: '[PRE16]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here, the `namespace` is optional, and if not specified, is assumed to be `default`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`namespace`是可选的，如果未指定，则假定为`default`。
- en: In the next section, we will put in practice some of the concepts explained
    here by defining an Azure Kubernetes cluster and deploying a simple application.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将通过定义Azure Kubernetes集群并部署一个简单应用程序来实践这里解释的一些概念。
- en: Interacting with Azure Kubernetes clusters
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与Azure Kubernetes集群交互
- en: 'To create an **Azure Kubernetes Service** (**AKS**) cluster, type `AKS` into
    the Azure search box, select **Kubernetes services**, and then click the **Add**
    button. The following form will appear:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个**Azure Kubernetes服务**（**AKS**）集群，请在Azure搜索框中键入`AKS`，选择**Kubernetes服务**，然后单击**添加**按钮。将显示以下表单：
- en: '![](img/B16756_07_02.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16756_07_02.png)'
- en: 'Figure 7.2: Creating a Kubernetes cluster'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2：创建Kubernetes集群
- en: It is worth mentioning that you can get help by just hovering any circled **i**
    with the mouse, as shown in the preceding screenshot.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: As usual, you are required to specify a subscription, resource group, and region.
    Then, you can choose a unique name (**Kubernetes cluster name**), and the version
    of Kubernetes you would like to use. For computational power, you are asked to
    select a machine template for each node (node size) and the number of nodes. The
    initial screen shows a default of three nodes. We decreased it to two, because
    three nodes are too much for the Azure free credit. Moreover, the default virtual
    machine should also be replaced by a cheaper one, so click **Change size** and
    select **DS1 v2**.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: The **Availability zones** setting allows you to spread your nodes across several
    geographic zones for a better fault tolerance. The default is three zones. Please
    change it to two zones since we have just two nodes.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: 'Following the preceding changes, you should see the following settings:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16756_07_03.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.3: Chosen settings'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Now you can create your cluster by clicking the **Review + create** button.
    A review page should appear, confirm, and create the cluster.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: If you click **Next**, instead of **Review + create**, you can also define other
    node types, and then you can provide security information, namely, a *service
    principal*, and specify whether you wish to enable role-based access control.
    In Azure, service principals are accounts that are associated with services you
    may use to define resource access policies. You may also change the default network
    settings and other settings.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: Deployment may take a little while (10-20 minutes). After that time, you will
    have your first Kubernetes cluster! At the end of the chapter, when the cluster
    is no longer required, please don't forget to delete it in order to avoid wasting
    your Azure free credit.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: In the next subsection, you will learn how to interact with your cluster through
    Kubernetes' official client, Kubectl.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: Using Kubectl
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once you have created your cluster, you can interact with it with Azure Cloud
    Shell. Click on the console icon on the top right of your Azure portal page. The
    following screenshot shows the Azure Shell icon:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16756_07_04.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.4: Azure Shell icon'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: When prompted, select the **Bash Shell**. Then you will be prompted to create
    a storage account, so confirm and create it.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use this shell to interact with our cluster. On the top of the shell
    there is a file icon that we will use to upload our `.yaml` files:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16756_07_05.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.5: How to upload files in Azure Cloud Shell'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: It is also possible to download a client called Azure CLI and to install it
    on your local machine (see [https://docs.microsoft.com/en-US/cli/azure/install-azure-cli](https://docs.microsoft.com/en-US/cli/azure/install-azure-cli)),
    but, in this case, you also need to install all tools needed to interact with
    the Kubernetes cluster (Kubectl and Helm) that are pre-installed in the Azure Cloud Shell.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you''ve created a Kubernetes cluster, you can interact with it through
    the `kubectl` command-line tool. `kubectl` is integrated in the Azure Shell, so
    you just need to activate your cluster credentials to use it. You can do this
    with the following Cloud Shell command:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The preceding command stores the credentials that were automatically created
    to enable your interaction with the cluster in a `/.kube/config` configuration
    file. From now on, you can issue your `kubectl` commands with no further authentication.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: 'If you issue the `kubectl get nodes` command, you get a list of all your Kubernetes
    nodes. In general, `kubectl get <object type>` lists all objects of a given type.
    You can use it with `nodes`, `pods`, `statefulset`, and so on. `kubectl get all`
    shows a list of all the objects created in your cluster. If you also add the name
    of a specific object, you will get information on just that specific object, as
    shown here:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If you add the `--watch` option, the object list will be continuously updated,
    so you can see the state of all the selected objects changing over time. You can
    leave this watch state by hitting Ctrl + c.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果添加`--watch`选项，对象列表将持续更新，因此您可以看到所有选定对象的状态随时间变化。您可以通过按下Ctrl + c来退出此观察状态。
- en: 'The following command shows a detailed report on a specific object:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令显示了有关特定对象的详细报告：
- en: '[PRE19]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'All objects described in a `.yaml` file, say `myClusterConfiguration.yaml`,
    can be created with the following command:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下命令创建在`.yaml`文件中描述的所有对象，例如`myClusterConfiguration.yaml`：
- en: '[PRE20]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then, if you modify the `.yaml` file, you can reflect all modifications on
    your cluster with the `apply` command, as shown here:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，如果您修改了`.yaml`文件，可以使用`apply`命令在集群上反映所有修改，如下所示：
- en: '[PRE21]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '`apply` does the same job of `create` but, if the resource already exists,
    `apply` overrides it, while `create` exits with an error message.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`apply`执行与`create`相同的工作，但如果资源已经存在，`apply`会覆盖它，而`create`则会显示错误消息。'
- en: 'You can destroy all objects that were created with a `.yaml` file by passing
    the same file to the `delete` command, as shown here:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过将相同的文件传递给`delete`命令来销毁使用`.yaml`文件创建的所有对象，如下所示：
- en: '[PRE22]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `delete` command can also be passed an object type and a list of names
    of objects of that type to destroy, as shown in the following example:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`delete`命令还可以传递对象类型和要销毁的该类型对象的名称列表，如下例所示：'
- en: '[PRE23]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The preceding `kubectl` command shown should suffice for most of your practical
    needs. For more details, the *Further reading* section contains a link to the
    official documentation.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 上述`kubectl`命令应足以满足大部分实际需求。有关更多详细信息，请参阅*Further reading*部分中的官方文档链接。
- en: In the next subsection, we will use `kubectl create` to install a simple demo
    application.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一小节中，我们将使用`kubectl create`安装一个简单的演示应用程序。
- en: Deploying the demo Guestbook application
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署演示Guestbook应用程序
- en: The Guestbook application is a demo application used in the examples of the
    official Kubernetes documentation. We will use it as an example of a Kubernetes
    application since its Docker images are already available in the public Docker
    repository, so we don't need to write software.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: Guestbook应用程序是官方Kubernetes文档示例中使用的演示应用程序。我们将使用它作为Kubernetes应用程序的示例，因为它的Docker镜像已经在公共Docker存储库中可用，所以我们不需要编写软件。
- en: The Guestbook application stores the opinions of customers who visit a hotel
    or a restaurant. It is composed of an UI tier implemented with a `Deployment`,
    and of a database layer implemented with an in-memory store based on Redis. In
    turn, the Redis store is implemented with a unique master storage used for write/update
    and several read-only replicas, always based on Redis, that achieve a read parallelism.
    Write/update parallelism could be implemented with several sharded Redis masters,
    but for the very nature of the applications, write operations should not be predominant,
    so a single master database should suffice in the practical case of a single restaurant/hotel.
    The whole application is composed of three `.yaml` files that you can find in
    the GitHub repository associated with this book.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Guestbook应用程序存储了访问酒店或餐厅的客户的意见。它由一个使用`Deployment`实现的UI层和一个使用基于Redis的内存存储实现的数据库层组成。而Redis存储则是由一个用于写入/更新的唯一主存储和几个只读副本组成，这些副本始终基于Redis，并实现了读取并行性。写入/更新并行性可以通过多个分片的Redis主节点来实现，但由于应用程序的特性，写入操作不应占主导地位，因此在实际情况下，单个主数据库应该足够满足单个餐厅/酒店的需求。整个应用程序由三个`.yaml`文件组成，您可以在与本书相关的GitHub存储库中找到。
- en: 'Here is the code for the master storage based on Redis that is contained in
    the `redis-master.yaml` file:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是包含在`redis-master.yaml`文件中的基于Redis的主存储的代码：
- en: '[PRE24]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The file is composed of two object definitions separated by a line containing
    just `---`, that is, the object definition separator of `.yaml` files. The first
    object is a `Deployment` with a single replica, and the second object is a `ClusterIPService`
    that exposes the `Deployment` on the `6379` port at the internal `redis-master.default.svc.cluster.local`
    network address. The `Deployment pod template` defines the three `app`, `role`,
    and `tier` labels with their values that are used in the `selector` definition
    of the Service to connect the Service with the unique pod defined in the `Deployment`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件由两个对象定义组成，由一个只包含`---`的行分隔，即`.yaml`文件的对象定义分隔符。第一个对象是一个具有单个副本的`Deployment`，第二个对象是一个`ClusterIPService`，它在内部`redis-master.default.svc.cluster.local`网络地址上的`6379`端口上公开`Deployment`。`Deployment
    pod template`定义了三个`app`、`role`和`tier`标签及其值，这些值在Service的`selector`定义中用于将Service与在`Deployment`中定义的唯一pod连接起来。
- en: 'Let''s upload the `redis-master.yaml` file on Cloud Shell, and then deploy
    it in the cluster with the following command:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将`redis-master.yaml`文件上传到Cloud Shell，然后使用以下命令在集群中部署它：
- en: '[PRE25]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Once the operation is complete, you can inspect the content of the cluster with
    `kubectl get all`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 操作完成后，您可以使用`kubectl get all`命令检查集群的内容。
- en: The slave storage is defined in the `redis-slave.yaml` file and is completely
    analogous, the only difference being that this time we have two replicas, and
    a different Docker image.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 从`redis-slave.yaml`文件中定义了从存储，它与主存储完全类似，唯一的区别是这次有两个副本和不同的Docker镜像。
- en: 'Let''s upload this file as well and deploy it with the following command:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也上传此文件，并使用以下命令部署它：
- en: '[PRE26]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The code for the UI tier is contained in the `frontend.yaml` file. `Deployment`
    has three replicas and a different Service type. Let''s upload and deploy this
    file with the following command:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: UI层的代码包含在`frontend.yaml`文件中。`Deployment`有三个副本和不同的服务类型。让我们使用以下命令上传并部署此文件：
- en: '[PRE27]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'It is worthwhile analyzing the Service code in the `frontend.yaml` file:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 值得分析的是`frontend.yaml`文件中的服务代码：
- en: '[PRE28]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This type of Service is of the `LoadBalancer` type, since it must expose the
    application on a public IP address. In order to get the public IP address assigned
    to the service, and then to the application, use the following command:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The preceding command should display information on all the installed services.
    You should find the public IP under the `EXTERNAL-IP` column of the list. If you
    see only `<none>` values, please repeat the command until the public IP address
    is assigned to the load balancer.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: Once you get the IP address, navigate with the browser to this address. The
    application home page should now appear!
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have finished experimenting with the application, remove the application
    from the cluster to avoid wasting your Azure free credit (public IP addresses
    cost money) with the following commands:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In the next section, we will analyze other important Kubernetes features.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: Advanced Kubernetes concepts
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will discuss other important Kubernetes features, including
    how to assign permanent storage to `StatefulSets`, how to store secrets such as
    passwords, connection strings, or certificates, how a container can inform Kubernetes
    about its health state, and how to handle complex Kubernetes packages with Helm.
    All subjects are organized in dedicated subsections. We will start with the problem
    of permanent storage.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Requiring permanent storage
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since pods are moved among nodes, they can''t rely on the permanent storage
    offered by the current node where they are running. This leaves us with two options:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '**Using external databases**: With the help of databases, `ReplicaSets` can
    also store information. However, if we need a better performance in terms of write/update
    operations, we should use distributed sharded databases based on non-SQL engines
    such as Cosmos DB or MongoDB (see *Chapter 9*, *How to Choose Your Data Storage
    in the Cloud*). In this case, in order to take maximum advantage of table sharding,
    we need `StatefulSets`, where each `pod` instance takes care of a different table
    shard.'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Using cloud storage**: Not being tied to a physical cluster node, cloud storage
    can be associated permanently with specific pod instances of `StatefulSets`.'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since access to external databases doesn't require any Kubernetes-specific technique,
    but can be done with the usual connection strings, we will concentrate on cloud
    storage.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes offers an abstraction of storage called **PersistentVolumeClaim**
    (**PVC**) that is independent of the underlying storage provider. More specifically,
    PVCs are allocation requests that are either matched to predefined resources or
    allocated dynamically. When the Kubernetes cluster is in the cloud, typically,
    you use dynamic allocation carried out by dynamic providers installed by the cloud
    provider.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: 'Cloud providers such as Azure offer different storage classes with different
    performance and different costs. Moreover, the PVC can also specify the `accessMode`,
    which can be:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '`ReadWriteOnce` – The volume can be mounted as read-write by a single `pod`.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ReadOnlyMany` – The volume can be mounted as read-only by many pods.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ReadWriteMany` – The volume can be mounted as read-write by many pods.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Volume claims can be added to `StatefulSets` in a specific `spec->volumeClaimTemplates`
    object:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `storage` property contains the storage requirements. `volumeMode` set to
    `Filesystem` is a standard setting that means the storage will be available as
    a file path. The other possible value is `Block`, which allocates the memory as
    `unformatted`. `storageClassName` must be set to an existing storage class offered
    by the cloud provider. If omitted, the default storage class will be assumed.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: 'All available storage classes can be listed with the following command:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Once `volumeClaimTemplates` has defined how to create permanent storage, then
    each container must specify which file path to attach that permanent storage to
    in the `spec->containers->volumeMounts` property:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Here, `name` must correspond to the name given to the PVC.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: The following subsection shows how to use Kubernetes secrets.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes secrets
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Secrets are sets of key-value pairs that are encrypted to protect them. They
    can be created by putting each value in a file, and then invoking the following
    `kubectl` command:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In this case, the filenames become the keys and the file contents are the values.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: 'When the values are strings, they can be specified directly in the `kubectl`
    command, as shown here:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In this case, keys and values are listed one after the other, separated by the
    `=` character.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: 'Once defined, secrets can be referred to in the `spec->volume` property of
    a pod (`Deployment` or `StatefulSettemplate`), as shown here:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'After that, each container can specify in which path to mount them in the `spec->containers->volumeMounts`
    property:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In the preceding example, each key is seen as a file with the same name of the
    key. The content of the file is the secret value, base64-encoded. Therefore, the
    code that reads each file must decode its content (in .NET, `Convert.FromBase64`
    will do the job).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: 'When secrets contain strings, they can also be passed as environment variables
    in the `spec->containers->env object`:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Here, the `name` property must match the secret `name`. Passing secrets as environment
    variables is very convenient when containers host ASP.NET Core applications, since,
    in this case, environment variables are all immediately available in the configuration
    object (see the *Loading configuration data and using it with the options framework*
    section of *Chapter 15*, *Presenting ASP.NET Core MVC*).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: 'Secrets can also encode the key/certificate pair of an HTTPS certificate, with
    the following `kubectl` command:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Secrets defined in this way can be used to enable HTTPS termination in `Ingresses`.
    It is enough to place the secret names in the `spec->tls->hosts->secretName` properties
    of an `Ingress`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: Liveness and readiness checks
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Kubernetes automatically monitors all containers to ensure they are still alive
    and that they keep their resource consumption within the limits declared in the
    `spec->containers->resources->limits` object. When some conditions are violated,
    the container is either throttled, or restarted, or the whole pod instance is
    restarted on a different node. How does Kubernetes know that a container is in
    a healthy state? While it can use the operating system to check the healthy state
    of nodes, it has no universal check that works with all containers.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, the containers themselves must inform Kubernetes of their healthy
    state, otherwise Kubernetes must renounce verifying them. Containers can inform
    Kubernetes of their healthy state in two ways, either by declaring a console command
    that returns the healthy state, or by declaring an endpoint that provides the
    same information.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: 'Both declarations are provided in the `spec->containers->livenessProb` object.
    The console command check is declared as shown here:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: If `command` returns `0`, the container is considered healthy. In the preceding
    example, we suppose that the software running in the container records its state
    of health in the `/tmp/healthy` file, so that the `cat/tmp/healthy` command returns
    it. `PeriodSeconds` is the time between checks, while `initialDelaySeconds` is
    the initial delay before performing the first check. An initial delay is always
    necessary so as to give the container time to start.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: 'The endpoint check is quite similar:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The test is successful if the HTTP response contains the declared header with
    the declared value. You may also use a pure TCP check, as shown here:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In this case, the check succeeds if Kubernetes is able to open a TCP socket
    to the container on the declared port.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: In a similar way, the readiness of containers once they are installed is monitored
    with a readiness check. The readiness check is defined in exactly the same way
    as the liveness check, the only difference being that `livenessProbe` is replaced
    with `readinessProbe`.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: The following subsection explains how to autoscale `Deployments`.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: Autoscaling
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Instead of modifying manually the number of replicas in a `Deployment`, in order
    to adapt it to a decrease or increase in load, we can let Kubernetes decide for
    itself the number of replicas trying to keep constant a declared resource consumption.
    Thus, for instance, if we declare a target 10% CPU consumption, when the average
    resource consumption of each replica exceeds this limit, a new replica is created,
    while if the average CPU falls below this limit, a replica is destroyed. The typical
    resource used to monitor replicas is CPU consumption, but we can also use memory
    consumption.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: 'Autoscaling is achieved by defining a `HorizontalPodAutoscaler` object. Here
    is an example of the `HorizontalPodAutoscaler` definition:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '`spec-> scaleTargetRef->name` specifies the name of the `Deployment` to autoscale,
    while `targetAverageUtilization` specifies the target resource (in our case, CPU)
    percentage usage (in our case, 25%).'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: The following subsection gives a short introduction to the Helm package manager
    and Helm charts, and explains how to install Helm charts on a Kubernetes cluster.
    An example of how to install an `Ingress Controller` is given.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: Helm – Installing an Ingress Controller
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Helm charts are a way to organize the installation of complex Kubernetes applications
    that contain several `.yaml` files. A Helm chart is a set of `.yaml` files, organized
    into folders and subfolders. Here is a typical folder structure of a Helm chart
    taken from the official documentation:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16756_07_06.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.6: Folder structure of a Helm chart'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: 'The `.yaml` files specific to the application are placed in the top `templates`
    directory, while the `charts` directory may contain other Helm charts used as
    helper libraries. The top-level `Chart.yaml` file contains general information
    on the package (name and description), together with both the application version
    and the Helm chart version. The following is a typical example:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Here, `type` can be either `application` or `library`. Only `application` charts
    can be deployed, while `library` charts are utilities for developing other charts.
    `library` charts are placed in the `charts` folder of other Helm charts.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: In order to configure each specific application installation, Helm chart `.yaml`
    files contain variables that are specified when Helm charts are installed. Moreover,
    Helm charts also provide a simple templating language that allows some declarations
    to be included only if some conditions depending on the input variables are satisfied.
    The top-level `values.yaml` file declares default values for the input variables,
    meaning that the developer needs to specify just the few variables for which they
    require values different from the defaults. We will not describe the Helm chart
    templates language, but you can find it in the official Helm documentation referred
    to in the *Further reading* section.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: Helm charts are usually organized in public or private repositories in a way
    that is similar to Docker images. There is a Helm client that you can use for
    downloading packages from a remote repository and for installing charts in Kubernetes
    clusters. The Helm client is immediately available in the Azure Cloud Shell, so
    you can start using Helm for your Azure Kubernetes cluster with no need to install
    it.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: 'A remote repository must be added before using its packages, as shown in the
    following example:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The preceding command makes available the packages of a remote repository and
    gives a local name to it. After that, any package of the remote repository can
    be installed with a command such as the following:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Here, `<namespace>` is the namespace where to install the application. As usual,
    if not provided, the `default` namespace is assumed. `<instance name>` is the
    name that you give to the installed application. You need this name to get information
    about the installed application with the following command:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'You can get also information about all applications installed with Helm with
    the help of the following command:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The application name is also needed to delete the application from the cluster,
    by means of the following command:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'When we install an application, we may also provide a `.yaml` file with all
    the variable values we want to override. We can also specify a specific version
    of the Helm chart, otherwise the more recent version is assumed. Here is an example
    with both the version and values overridden:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Finally, value overrides can also be provided in-line with the `--set` option,
    as shown here:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We can also upgrade an existing installation with the `upgrade` command, as
    shown here:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The `upgrade` command may specify new value overrides with the `–f` option or
    with the `--set` option, and it can specify a new version with `--version`.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use Helm to provide an `Ingress` for the guestbook demo application.
    More specifically, we will use Helm to install an `Ingress-Controller` based on
    Nginx. The detailed procedure to be observed is as follows:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the remote repository:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Install the `Ingress-Controller`:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: When the installation is complete, you should see an entry for the installed
    `Ingress-Controller` among the installed services if you type `kubectl get service`.
    The entry should contain a public IP. Please make a note of this IP since it will
    be the public IP of the application.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the `frontend.yaml` file and remove the `type: LoadBalancer` line. Save
    and upload this to Azure Cloud Shell. We changed the service type of the frontend
    application from `LoadBalancer` to `ClusterIP` (the default). This service will
    be connected to the new Ingress you are going to define.'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Deploy `redis-master.yaml`, `redis-slave.yaml`, and `frontend.yaml` with `kubectl`,
    as detailed in the *Deploying the demo Guestbook application* subsection. Create
    a `frontend-ingress.yaml` file and place the following code in it:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Upload `frontend-ingress.yaml` to Cloud Shell and deploy it with the following
    command:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Open the browser and navigate to the public IP you annotated in *step 3*. There,
    you should see the application running.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since the public IP allocated to `Ingress-Controller` is available in the Azure
    *Public IP Addresses* section of Azure (use the Azure search box to find it),
    you can retrieve it there and assign it a hostname of the type `<chosen name>.<your
    Azure region>.cloudeapp.com`.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: 'You are encouraged to assign a hostname to the application public IP, and then
    to use this hostname to get a free HTTPS certificate from [https://letsencrypt.org/](https://letsencrypt.org/).
    Once you get a certificate, you can generate a secret from it with the following
    command:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Then you can add the preceding secret to your `frontend-ingress.yamlIngress`
    by adding the following `spec->tls` section to it:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Following the correction, upload the file to your Azure Cloud Shell, and update
    the previous `Ingress` definition with the following:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: At this point, you should be able to access the Guestbook application with HTTPS.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: 'When you are done experimenting, please don''t forget to delete everything
    from your cluster to avoid wasting your free Azure credit. You can do this by
    means of the following commands:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Summary
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we described Kubernetes basic concepts and objects, and then
    we explained how to create an Azure Kubernetes cluster. We also showed how to
    deploy applications, and how to monitor and inspect the state of your cluster
    with a simple demo application.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: The chapter also described more advanced Kubernetes features that cover a fundamental
    role in practical applications, including how to provide persistent storage to
    the containers running on Kubernetes, how to inform Kubernetes of the health state
    of your containers, and how to offer advanced HTTP services, such as HTTPS and
    name-based virtual hosting.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we reviewed how to install complex applications with Helm, and gave
    a short description of Helm and Helm commands.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn how to connect your .NET application with
    databases with Entity Framework.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Why are Services needed?
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is an `Ingress` needed?
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is Helm needed?
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is it possible to define several Kubernetes objects in the same `.yaml` file?
    If yes, how?
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does Kubernetes detect container faults?
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why are persistent volume claims needed?
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between a `ReplicaSet` and a `StatefulSet`?
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A good book for extending the knowledge acquired in this chapter is the following:
    [https://www.packtpub.com/product/hands-on-kubernetes-on-azure-second-edition/9781800209671](https://www.packtpub.com/product/hands-on-kubernetes-on-azure-second-edition/9781800209671).'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The official documentation for Kubernetes and `.yaml` files can be found here:
    [https://kubernetes.io/docs/home/](https://kubernetes.io/docs/home/).'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'More information on Helm and Helm charts can be found in the official documentation.
    This is extremely well written and contains some good tutorials: [https://helm.sh/](https://helm.sh/).'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The official documentation for Azure Kubernetes can be found here: [https://docs.microsoft.com/en-US/azure/aks/](https://docs.microsoft.com/en-US/azure/aks/).'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The official documentation on the Azure Application Gateway-based `Ingress
    Controller` is available here: [https://github.com/Azure/application-gateway-kubernetes-ingress](https://github.com/Azure/application-gateway-kubernetes-ingress).'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Ingress` certificate release and renewal can be automated as explained here:
    [https://docs.microsoft.com/en-us/azure/application-gateway/ingress-controller-letsencrypt-certificate-application-gateway](https://docs.microsoft.com/en-us/azure/application-gateway/ingress-controller-letsencrypt-certificat).
    While the procedure specifies an Azure Application Gateway-based ingress controller,
    it is adequate for any `Ingress Controller`.'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
