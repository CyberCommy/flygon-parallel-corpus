- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Azure Kubernetes Service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is dedicated to describing the Kubernetes microservices orchestrator
    and, in particular, its implementation in Azure named Azure Kubernetes Service.
    The chapter explains the fundamental Kubernetes concepts, and then focuses on
    how to interact with a Kubernetes cluster, and how to deploy an Azure Kubernetes
    application. All concepts are put into practice with simple examples. We recommend
    reading *Chapter 5*, *Applying a Microservice Architecture to Your Enterprise
    Application*, and *Chapter 6*, *Azure Service Fabric*, before dealing with this
    chapter, since it relies on the concepts explained in these previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'More specifically, in this chapter you will learn about the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes basics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interacting with Azure Kubernetes clusters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced Kubernetes concepts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have learned how to implement and deploy
    a complete solution based on Azure Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Visual Studio 2019 free Community Edition or better, with all the database tools
    installed or any other `.yaml` file editor such as Visual Studio Code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A free Azure account. The *Creating an Azure account* section in *Chapter 1*,
    *Understanding the Importance of Software Architecture*, explains how to create one.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code for this chapter is available at [https://github.com/PacktPublishing/Software-Architecture-with-C-9-and-.NET-5](https://github.com/PacktPublishing/Software-Architecture-with-C-9-and-.NET-5).
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kubernetes is an advanced, open source orchestrator that you can install locally
    on your private machine's cluster. At the time of writing, it is the most widespread
    orchestrator, so Microsoft also offers it as a better alternative to Azure Service
    Fabric, since it is currently the *de facto* standard, and can rely on a wide
    ecosystem of tools and applications. This section introduces basic Kubernetes
    concepts and entities.
  prefs: []
  type: TYPE_NORMAL
- en: A Kubernetes cluster is a cluster of virtual machines running the Kubernetes
    orchestrator. As for Azure Service Fabric, the virtual machines composing the
    cluster are called nodes. The smallest software unit we can deploy on Kubernetes
    is not a single application, as in the case of Azure Service Fabric, but an aggregate
    of containerized applications called pods. While Kubernetes supports various types
    of containers, the most commonly used container type is Docker, which we analyzed
    in *Chapter 5*, *Applying a Microservice Architecture to Your Enterprise Application*,
    so we will confine our discussion to Docker.
  prefs: []
  type: TYPE_NORMAL
- en: '`pods` are important since applications belonging to the same pod are ensured
    to run on the same node. This means that they can easily communicate through localhost
    ports. Communication between different pods, however, is more complex since the
    IP addresses of pods are ephemeral resources because pods have no fixed node where
    they run, but are moved from one node to another by the orchestrator. Moreover,
    pods may be replicated to increase performance, so, in general, it makes no sense
    addressing a message to a specific pod, but just to any of the identical replicas
    of the same pod.'
  prefs: []
  type: TYPE_NORMAL
- en: While, in Azure Service Fabric, the infrastructure gives automatically virtual
    net addresses to groups of identical replicas, in Kubernetes we need to define
    explicit resources called Services that are assigned virtual addresses by the
    Kubernetes infrastructure and forward their communications to sets of identical
    pods. In short, Services are Kubernetes way to assign constant virtual addresses
    to sets of pod replicas.
  prefs: []
  type: TYPE_NORMAL
- en: All Kubernetes entities may be assigned name value pairs called labels that
    are used to reference them through a pattern matching mechanism. More specifically,
    Selectors select Kubernetes entities by listing labels they must have.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, for instance, all pods that receive traffic from the same Service are
    selected by specifying labels they must have in the Service definition.
  prefs: []
  type: TYPE_NORMAL
- en: The way a Service routes its traffic to all connected pods depends on the way
    pods are organized. Stateless pods are organized in so called `ReplicaSets`, which
    are similar to stateless replicas of Azure Service Fabric services. As Azure Service
    Fabric stateless services, `ReplicaSets` have a unique virtual address assigned
    to the whole group and traffic is split equally among all pods of the group.
  prefs: []
  type: TYPE_NORMAL
- en: 'Stateful Kubernetes pod replicas are organized into so called `StatefulSets`.
    Similar to Azure Service Fabric stateful services, `StatefulSets` use sharding
    to split the traffic among all their pods. For this reason, Kubernetes Services
    assign a different name to each pod of the `StatefulSet` they are connected to.
    These names look like the following: `basename-0.<base URL>`, `basename-1.<base
    URL>`, ..., `basename-n.<base URL>`. This way, message sharding is easily accomplished
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Each time a message must be sent to a `StatefulSet` composed of *N* replicas,
    you compute a hash between 0 and *N*-1, say `x`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the postfix `x` to a base name to get a cluster address, such as `basename-x.<base
    URL>`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Send the message to the `basename-x.<base URL>` cluster address.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Kubernetes has no predefined storing facilities, and you can't use node disk
    storage since pods are moved among available nodes, so long-term storage must
    be provided with sharded cloud databases or with other kinds of cloud storage.
    While each pod of a `StatefulSet` can access a sharded cloud database with the
    usual connection string technique, Kubernetes offers a technique to abstract disk-like
    cloud storage offered by the external Kubernetes cluster environment. We will
    describe these in the *Advanced Kubernetes concepts* section.
  prefs: []
  type: TYPE_NORMAL
- en: All Kubernetes entities mentioned in this short introduction can be defined
    in a `.yaml` file, which, once deployed to a Kubernetes cluster, causes the actual
    creation of all entities defined in the file. The subsection that follows describes
    `.yaml` files, while the other subsections thereafter describe in detail all the
    basic Kubernetes objects mentioned so far, and explain how to define them in a
    `.yaml` file. Further Kubernetes objects will be described throughout the whole
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: .yaml files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`.yaml` files, like JSON files, are a way to describe nested objects and collections
    in a human-readable way, but they do it with a different syntax. You have objects
    and lists, but object properties are not surrounded by `{}`, and lists are not
    surrounded by `[]`. Instead, nested objects are declared by simply indenting their
    content with spaces. The number of spaces can be freely chosen, but once they''ve
    been chosen, they must be used consistently.'
  prefs: []
  type: TYPE_NORMAL
- en: List items can be distinguished from object properties by preceding them with
    a hyphen (`-`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example involving nested objects and collections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The preceding `Person` object has a `Spouse` nested object, and a nested collection
    of addresses.
  prefs: []
  type: TYPE_NORMAL
- en: '`.yaml` files can contain several sections, each defining a different entity,
    that are separated by a line containing the `---` string. Comments are preceded
    by a `#` symbol, which must be repeated on each comment line.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Each section starts with the declaration of the Kubernetes API group and version.
    In fact, not all objects belong to the same API group. For objects that belong
    to the `core` API group, we can specify just the API version, as in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'While objects belonging to different API groups must also specify the API name,
    as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the next subsection, we analyze in detail `ReplicaSets` and `Deployments`
    that are built on top of them.
  prefs: []
  type: TYPE_NORMAL
- en: ReplicaSets and Deployments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most important building block of Kubernetes applications is the `ReplicaSet`,
    that is, a pod replicated *n* times. Usually, however, you adopt a more complex
    object that is built on top of the `ReplicaSet` – the `Deployment`. `Deployments`
    not only create a `ReplicaSet`, but also monitor them to ensure that the number
    of replicas is kept constant, independent of hardware faults and other events
    that might involve the `ReplicaSets`. In other words, they are a declarative way
    of defining `ReplicaSets` and pods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each `Deployment` has a name (`metadata->name`), an attribute that specifies
    the desired number of replicas (`spec->replicas`), a key-value pair (`spec ->`
    `selector-> matchLabels`) that selects the pods to monitor, and a template (`spec->template`)
    that specifies how to build the pod replicas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '`namespace` is optional and, if not provided, a namespace called `default`
    is assumed. Namespaces are a way of keeping separate the objects of a Kubernetes
    cluster. For instance, a cluster can host the objects of two completely independent
    applications each placed in a separate `namespace`.'
  prefs: []
  type: TYPE_NORMAL
- en: Indented inside the template is the definition of the pod to replicate. Complex
    objects such as `Deployments` can also contain other kinds of templates, for instance,
    a template of disk-like memory required by the external environment. We will discuss
    this further, in the *Advanced Kubernetes concepts* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'In turn, the pod template contains a `metadata` section with labels used to
    select the pods, and a `spec` section with a list of all of the containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Each container has a name and must specify the name of the Docker image to use
    for creating the containers. In case the Docker image is not contained in the
    public Docker registry, the name must be a URI that also includes the repository
    location.
  prefs: []
  type: TYPE_NORMAL
- en: Then, containers must specify the memory and CPU resources that they need to
    be created in the `resources->requests` object. A pod replica is created only
    if these resources are currently available. The `resources->limits` object, instead,
    specifies the maximum resources a container replica can actually use. If, during
    the container execution, these limits are exceeded, actions are taken to limit
    them. More specifically, if the CPU limit is exceeded, the container is throttled
    (its execution is stopped to restore its CPU consumption), while, if the memory
    limits are exceeded, the container is restarted. `containerPort` must be the port
    exposed by the container. Here, we can also specify further information, such
    as the protocol used.
  prefs: []
  type: TYPE_NORMAL
- en: CPU time is expressed in millicores, where 1,000 millicores means 100% of the
    CPU time, while memory is expressed in Mebibytes (*1Mi = 1024*1024 bytes*), or
    other units. `env` lists all the environment variables to pass to the containers
    with their values.
  prefs: []
  type: TYPE_NORMAL
- en: Both containers and pod templates can contain further fields, such as properties
    that define virtual files, and properties that define commands that returns the
    readiness and the health state of the container. We will analyze these in the
    *Advanced Kubernetes concepts* section.
  prefs: []
  type: TYPE_NORMAL
- en: The following subsection describes pod sets conceived to store state information.
  prefs: []
  type: TYPE_NORMAL
- en: StatefulSets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`StatefulSets` are very similar to a `ReplicaSet`, but while pods of a `ReplicaSet`
    are indistinguishable processors that contribute in parallel to the same workload
    through load balancing strategies, pods in a `StatefulSet` have a unique identity,
    and can contribute to the same workload only through sharding. This is because
    `StatefulSets` were conceived to store information, and information cannot be
    stored in parallel, merely split among several stores by means of sharding.'
  prefs: []
  type: TYPE_NORMAL
- en: For the same reason, each pod instance is always kept tied to any virtual disk
    space it requires (see the *Advanced Kubernetes concepts* section), so that each
    pod instance is responsible for writing to a specific store.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, `StatefulSets` pods instances have ordinal numbers attached to them.
    They are started in sequence according to these numbers, and they are stopped
    in reverse order. If the `StatefulSet` contains *N* replicas, these numbers go
    from zero to *N*-1\. Moreover, a unique name for each instance is obtained by
    chaining the pod name specified in the template, with the instance ordinal, in
    the following way – `<pod name>-<instance ordinal>`. Thus, instance names will
    be something like `mypodname-0`, `mypodname-1`, and so on. As we will see in the
    *Services* subsection, instance names are used to build unique cluster network
    URIs for all instances, so that other pods can communicate with a specific instance
    of a `StatefulSets` pods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a typical `StatefulSet` definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The template part is the same as that of `Deployments`. The main conceptual
    difference with `Deployments` is the `serviceName` field. It specifies the name
    of a service that must be connected with `StatefulSets` to provide unique network
    addresses for all pod instances. We will discuss this subject in more detail in
    the *Services* subsection. Moreover, usually, `StatefulSets` use some form of
    storage. We will discuss this in detail in the *Advanced Kubernetes concepts*
    section.
  prefs: []
  type: TYPE_NORMAL
- en: It is worth pointing out also that the default ordered creation and stop strategy
    of `StatefulSets` can be changed by specifying an explicit `Parallel` value for
    the `spec->podManagementPolicy` property (the default value is `OrderedReady`).
  prefs: []
  type: TYPE_NORMAL
- en: The following subsection describes how to provide stable network addresses to
    both `ReplicaSets` and `StatefulSets`.
  prefs: []
  type: TYPE_NORMAL
- en: Services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since pod instances can be moved between nodes, they have no stable IP address
    attached to them. Services take care of assigning a unique and stable virtual
    address to a whole `ReplicaSet` and of load balancing the traffic to all its instances.
    Services are not software objects created in the cluster, just an abstraction
    for the various settings and activities needed to put in place their functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: Services work at level 4 of the protocol stack, so they understand protocols
    such as TCP, but they aren't able to perform, for instance, HTTP-specific actions/transformations,
    such as for instance, ensuring a secure HTTPS connection. Therefore, if you need
    to install HTTPS certificates on the Kubernetes cluster, you need a more complex
    object that is capable of interacting at level 7 of the protocol stack. The `Ingress`
    object was conceived for this. We will discuss this in the next subsection.
  prefs: []
  type: TYPE_NORMAL
- en: Services also handle assigning a unique virtual address to each instance of
    a `StatefulSet`. In fact, there are various kinds of Services; some were conceived
    for `ReplicaSet` and others for `StatefulSet`.
  prefs: []
  type: TYPE_NORMAL
- en: A `ClusterIP` service type is assigned a unique cluster internal IP address.
    It specifies the `ReplicaSets` or `Deployments` it is connected to through label
    pattern matching. It uses tables maintained by the Kubernetes infrastructure to
    load balance the traffic it receives among all pod instances to which it is connected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, other pods can communicate with the pods connected to a Service
    by interacting with this Service that is assigned the stable network name `<service
    name>.<service namespace>.svc.cluster.local`. Since they are just assigned local
    IP addresses, a `ClusterIP` service can''t be accessed from outside the Kubernetes
    cluster. Here is the definition of a typical `ClusterIP` service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Each Service can work on several ports, and can route any port (`port`) to the
    ports exposed by the containers (`targetPort`). However, it is very often the
    case that `port = targetPort`. Ports can be given names, but these names are optional.
    Also, the specification of the protocol is optional, in which case all supported
    level 4 protocols are allowed. The `spec->selector` property specifies all the
    name/value pairs that select the pods for the Service to route the communications
    it receives to.
  prefs: []
  type: TYPE_NORMAL
- en: Since a `ClusterIP` service can't be accessed from outside the Kubernetes cluster,
    we need other Service types to expose a Kubernetes application on a public IP
    address.
  prefs: []
  type: TYPE_NORMAL
- en: '`NodePort`-type Services are the simplest way to expose pods to the outside
    word. In order to implement a `NodePort` service, the same port `x` is opened
    on all nodes of the Kubernetes cluster and each node routes the traffic it receives
    on this port to a newly created `ClusterIP` service.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In turn, the `ClusterIP` service routes its traffic to all pods selected by
    the service:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16756_07_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.1: NodePort service'
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, it is enough to communicate with port `x` through a public IP of
    any cluster node in order to access the pods connected to the `NodePort` service.
    Of course, the whole process is completely automatic and hidden to the developer,
    whose only preoccupation is getting the port number `x` in terms of where to forward
    the external traffic.
  prefs: []
  type: TYPE_NORMAL
- en: 'The definition of a `NodePort` service is identical to the definition of a
    `ClusterIP` service, the only difference being that they specify a value of `NodePort`
    for the `spec->type` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'As a default, a node port `x` in the range 30000-327673 is automatically chosen
    for each `targetPort` specified by the `Service`. The port property associated
    with each `targetPort` is meaningless for `NodePortServices` since all traffic
    passes through the selected node port `x`, and, for convention, is set to the
    same value of the `targetPort`. The developer can also set the node port `x` directly
    through a `nodePort` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: When the Kubernetes cluster is hosted in a cloud, the more convenient way to
    expose some pods to the outside world is through a `LoadBalancer` service, in
    which case the Kubernetes cluster is exposed to the outside world through a level
    4 load balancer of the selected cloud provider.
  prefs: []
  type: TYPE_NORMAL
- en: 'The definition of a `LoadBalancer` service is identical to that of a `ClusterIp`
    service, the only difference being that the `spec->type` property must be set
    to `LoadBalancer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If no further specification is added, a dynamic public IP is randomly assigned.
    However, if a specific public IP address to the cloud provider is required, it
    can be used as a public IP address for the cluster load balancer by specifying
    it in the `spec->loadBalancerIP` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In Azure Kubernetes, you must also specify the resource group where the IP
    address was allocated, in an annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In Azure Kubernetes, you can remain with a dynamic IP address, but you can
    get a public static domain name of the type `<my-service-label>.<location>.cloudapp.azure.com`,
    where `<location>` is the geographic label you have chosen for your resources.
    `<my-service-label>` is a label that you verified makes the previous domain name
    unique. The chosen label must be declared in an annotation of your service, as
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`StatefulSets` don''t need any load balancing since each pod instance has its
    own identity, but just require a unique URL address for each pod instance. This
    unique URL is provided by the so called headless Services. Headless Services are
    defined like `ClusterIP` services, the only difference being that they have a
    `spec->clusterIP` property set to `none`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: All `StatefulSets` handled by a headless Service must place the Service name
    in their `spec-> serviceName` property, as already stated in the *StatefulSets*
    subsection.
  prefs: []
  type: TYPE_NORMAL
- en: The unique name provided by a headless Service to all `StatefulSets` pod instances
    it handles is `<unique pod name>.<service name>.<namespace>.svc.cluster.local`.
  prefs: []
  type: TYPE_NORMAL
- en: Services only understand low-level protocols, such as TCP/IP, but most web applications
    are situated on the more sophisticated HTTP protocol. That's why Kubernetes offers
    higher-level entities called `Ingresses` that are built on top of services. The
    following subsection describes these and explains how to expose a set of `pods`
    through a level 7 protocol load balancer, which could offer you typical HTTP services,
    instead of through a `LoadBalancer` service.
  prefs: []
  type: TYPE_NORMAL
- en: Ingresses
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Ingresses` are mainly conceived to work with HTTP(S). They provide the following
    services:'
  prefs: []
  type: TYPE_NORMAL
- en: HTTPS termination. They accept HTTPS connections and route them in HTTP format
    to any service in the cloud.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Name-based virtual hosting. They associate several domain names with the same
    IP address and route each domain, or `<domain>/<path prefix>`, to a different
    cluster Service.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Load balancing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Ingresses` rely on web servers to offer the above services. In fact, `Ingresses`
    can be used only after having installed an `Ingress Controller`. `Ingress Controllers`
    are custom Kubernetes objects that must be installed in the cluster. They handle
    the interface between Kubernetes and a web server, which can be either an external
    web server or a web server that is part of the `Ingress Controller` installation.'
  prefs: []
  type: TYPE_NORMAL
- en: We will describe the installation of an `Ingress Controller` based on the NGINX
    web server in the *Advanced Kubernetes concepts* section, as an example of the
    use of Helm. The *Further reading* section contains information on how to install
    also an `Ingress Controller` that interfaces an external Azure application gateway.
  prefs: []
  type: TYPE_NORMAL
- en: HTTPS termination and name-based virtual hosting can be configured in the `Ingress`
    definition in a way that is independent of the chosen `Ingress Controller`, while
    the way load balancing is achieved depends on the specific `Ingress Controller`
    chosen and on its configuration. Some `Ingress Controller` configuration data
    can be passed in the `metadata-> annotations` field of the `Ingress` definition.
  prefs: []
  type: TYPE_NORMAL
- en: 'Name-based virtual hosting is defined in a `spec>rules` section of the Ingress
    definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Each rule specifies an optional hostname that can contain the `*` wildcard.
    If no hostname is provided, the rule matches all hostnames. For each rule, we
    can specify several paths, each redirected to a different service/port pair, where
    the service is referenced through its name. The way the match with each `path`
    is carried out depends on the value of `pathType`; if this value is `Prefix`,
    the specified `path` must be a prefix of any matching path. Otherwise, if this
    value is `Exact`, the match must be exact. Matches are case-sensitive.
  prefs: []
  type: TYPE_NORMAL
- en: 'HTTPS termination on a specific hostname is specified by associating it a certificate
    encoded in a Kubernetes secret:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: HTTPS certificates can be obtained free of charge at [https://letsencrypt.org/](https://letsencrypt.org/).
    The procedure is explained on the website, but basically, as with all certificate
    authorities, you provide a key and they return the certificate based on that key.
    It is also possible to install a **certificate manger** that takes care of automatically
    installing and renewing the certificate. The way a key/certificate pair is encoded
    in a Kubernetes secret string is detailed in the *Advanced Kubernetes concepts*
    section.
  prefs: []
  type: TYPE_NORMAL
- en: 'The whole `Ingress` definition looks like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `namespace` is optional, and if not specified, is assumed to be `default`.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will put in practice some of the concepts explained
    here by defining an Azure Kubernetes cluster and deploying a simple application.
  prefs: []
  type: TYPE_NORMAL
- en: Interacting with Azure Kubernetes clusters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create an **Azure Kubernetes Service** (**AKS**) cluster, type `AKS` into
    the Azure search box, select **Kubernetes services**, and then click the **Add**
    button. The following form will appear:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16756_07_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.2: Creating a Kubernetes cluster'
  prefs: []
  type: TYPE_NORMAL
- en: It is worth mentioning that you can get help by just hovering any circled **i**
    with the mouse, as shown in the preceding screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: As usual, you are required to specify a subscription, resource group, and region.
    Then, you can choose a unique name (**Kubernetes cluster name**), and the version
    of Kubernetes you would like to use. For computational power, you are asked to
    select a machine template for each node (node size) and the number of nodes. The
    initial screen shows a default of three nodes. We decreased it to two, because
    three nodes are too much for the Azure free credit. Moreover, the default virtual
    machine should also be replaced by a cheaper one, so click **Change size** and
    select **DS1 v2**.
  prefs: []
  type: TYPE_NORMAL
- en: The **Availability zones** setting allows you to spread your nodes across several
    geographic zones for a better fault tolerance. The default is three zones. Please
    change it to two zones since we have just two nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following the preceding changes, you should see the following settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16756_07_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.3: Chosen settings'
  prefs: []
  type: TYPE_NORMAL
- en: Now you can create your cluster by clicking the **Review + create** button.
    A review page should appear, confirm, and create the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: If you click **Next**, instead of **Review + create**, you can also define other
    node types, and then you can provide security information, namely, a *service
    principal*, and specify whether you wish to enable role-based access control.
    In Azure, service principals are accounts that are associated with services you
    may use to define resource access policies. You may also change the default network
    settings and other settings.
  prefs: []
  type: TYPE_NORMAL
- en: Deployment may take a little while (10-20 minutes). After that time, you will
    have your first Kubernetes cluster! At the end of the chapter, when the cluster
    is no longer required, please don't forget to delete it in order to avoid wasting
    your Azure free credit.
  prefs: []
  type: TYPE_NORMAL
- en: In the next subsection, you will learn how to interact with your cluster through
    Kubernetes' official client, Kubectl.
  prefs: []
  type: TYPE_NORMAL
- en: Using Kubectl
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once you have created your cluster, you can interact with it with Azure Cloud
    Shell. Click on the console icon on the top right of your Azure portal page. The
    following screenshot shows the Azure Shell icon:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16756_07_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.4: Azure Shell icon'
  prefs: []
  type: TYPE_NORMAL
- en: When prompted, select the **Bash Shell**. Then you will be prompted to create
    a storage account, so confirm and create it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use this shell to interact with our cluster. On the top of the shell
    there is a file icon that we will use to upload our `.yaml` files:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16756_07_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.5: How to upload files in Azure Cloud Shell'
  prefs: []
  type: TYPE_NORMAL
- en: It is also possible to download a client called Azure CLI and to install it
    on your local machine (see [https://docs.microsoft.com/en-US/cli/azure/install-azure-cli](https://docs.microsoft.com/en-US/cli/azure/install-azure-cli)),
    but, in this case, you also need to install all tools needed to interact with
    the Kubernetes cluster (Kubectl and Helm) that are pre-installed in the Azure Cloud Shell.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you''ve created a Kubernetes cluster, you can interact with it through
    the `kubectl` command-line tool. `kubectl` is integrated in the Azure Shell, so
    you just need to activate your cluster credentials to use it. You can do this
    with the following Cloud Shell command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command stores the credentials that were automatically created
    to enable your interaction with the cluster in a `/.kube/config` configuration
    file. From now on, you can issue your `kubectl` commands with no further authentication.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you issue the `kubectl get nodes` command, you get a list of all your Kubernetes
    nodes. In general, `kubectl get <object type>` lists all objects of a given type.
    You can use it with `nodes`, `pods`, `statefulset`, and so on. `kubectl get all`
    shows a list of all the objects created in your cluster. If you also add the name
    of a specific object, you will get information on just that specific object, as
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: If you add the `--watch` option, the object list will be continuously updated,
    so you can see the state of all the selected objects changing over time. You can
    leave this watch state by hitting Ctrl + c.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command shows a detailed report on a specific object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'All objects described in a `.yaml` file, say `myClusterConfiguration.yaml`,
    can be created with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, if you modify the `.yaml` file, you can reflect all modifications on
    your cluster with the `apply` command, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '`apply` does the same job of `create` but, if the resource already exists,
    `apply` overrides it, while `create` exits with an error message.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can destroy all objects that were created with a `.yaml` file by passing
    the same file to the `delete` command, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The `delete` command can also be passed an object type and a list of names
    of objects of that type to destroy, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The preceding `kubectl` command shown should suffice for most of your practical
    needs. For more details, the *Further reading* section contains a link to the
    official documentation.
  prefs: []
  type: TYPE_NORMAL
- en: In the next subsection, we will use `kubectl create` to install a simple demo
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying the demo Guestbook application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Guestbook application is a demo application used in the examples of the
    official Kubernetes documentation. We will use it as an example of a Kubernetes
    application since its Docker images are already available in the public Docker
    repository, so we don't need to write software.
  prefs: []
  type: TYPE_NORMAL
- en: The Guestbook application stores the opinions of customers who visit a hotel
    or a restaurant. It is composed of an UI tier implemented with a `Deployment`,
    and of a database layer implemented with an in-memory store based on Redis. In
    turn, the Redis store is implemented with a unique master storage used for write/update
    and several read-only replicas, always based on Redis, that achieve a read parallelism.
    Write/update parallelism could be implemented with several sharded Redis masters,
    but for the very nature of the applications, write operations should not be predominant,
    so a single master database should suffice in the practical case of a single restaurant/hotel.
    The whole application is composed of three `.yaml` files that you can find in
    the GitHub repository associated with this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code for the master storage based on Redis that is contained in
    the `redis-master.yaml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The file is composed of two object definitions separated by a line containing
    just `---`, that is, the object definition separator of `.yaml` files. The first
    object is a `Deployment` with a single replica, and the second object is a `ClusterIPService`
    that exposes the `Deployment` on the `6379` port at the internal `redis-master.default.svc.cluster.local`
    network address. The `Deployment pod template` defines the three `app`, `role`,
    and `tier` labels with their values that are used in the `selector` definition
    of the Service to connect the Service with the unique pod defined in the `Deployment`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s upload the `redis-master.yaml` file on Cloud Shell, and then deploy
    it in the cluster with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Once the operation is complete, you can inspect the content of the cluster with
    `kubectl get all`.
  prefs: []
  type: TYPE_NORMAL
- en: The slave storage is defined in the `redis-slave.yaml` file and is completely
    analogous, the only difference being that this time we have two replicas, and
    a different Docker image.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s upload this file as well and deploy it with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The code for the UI tier is contained in the `frontend.yaml` file. `Deployment`
    has three replicas and a different Service type. Let''s upload and deploy this
    file with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'It is worthwhile analyzing the Service code in the `frontend.yaml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This type of Service is of the `LoadBalancer` type, since it must expose the
    application on a public IP address. In order to get the public IP address assigned
    to the service, and then to the application, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command should display information on all the installed services.
    You should find the public IP under the `EXTERNAL-IP` column of the list. If you
    see only `<none>` values, please repeat the command until the public IP address
    is assigned to the load balancer.
  prefs: []
  type: TYPE_NORMAL
- en: Once you get the IP address, navigate with the browser to this address. The
    application home page should now appear!
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have finished experimenting with the application, remove the application
    from the cluster to avoid wasting your Azure free credit (public IP addresses
    cost money) with the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will analyze other important Kubernetes features.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced Kubernetes concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will discuss other important Kubernetes features, including
    how to assign permanent storage to `StatefulSets`, how to store secrets such as
    passwords, connection strings, or certificates, how a container can inform Kubernetes
    about its health state, and how to handle complex Kubernetes packages with Helm.
    All subjects are organized in dedicated subsections. We will start with the problem
    of permanent storage.
  prefs: []
  type: TYPE_NORMAL
- en: Requiring permanent storage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since pods are moved among nodes, they can''t rely on the permanent storage
    offered by the current node where they are running. This leaves us with two options:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Using external databases**: With the help of databases, `ReplicaSets` can
    also store information. However, if we need a better performance in terms of write/update
    operations, we should use distributed sharded databases based on non-SQL engines
    such as Cosmos DB or MongoDB (see *Chapter 9*, *How to Choose Your Data Storage
    in the Cloud*). In this case, in order to take maximum advantage of table sharding,
    we need `StatefulSets`, where each `pod` instance takes care of a different table
    shard.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Using cloud storage**: Not being tied to a physical cluster node, cloud storage
    can be associated permanently with specific pod instances of `StatefulSets`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since access to external databases doesn't require any Kubernetes-specific technique,
    but can be done with the usual connection strings, we will concentrate on cloud
    storage.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes offers an abstraction of storage called **PersistentVolumeClaim**
    (**PVC**) that is independent of the underlying storage provider. More specifically,
    PVCs are allocation requests that are either matched to predefined resources or
    allocated dynamically. When the Kubernetes cluster is in the cloud, typically,
    you use dynamic allocation carried out by dynamic providers installed by the cloud
    provider.
  prefs: []
  type: TYPE_NORMAL
- en: 'Cloud providers such as Azure offer different storage classes with different
    performance and different costs. Moreover, the PVC can also specify the `accessMode`,
    which can be:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ReadWriteOnce` – The volume can be mounted as read-write by a single `pod`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ReadOnlyMany` – The volume can be mounted as read-only by many pods.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ReadWriteMany` – The volume can be mounted as read-write by many pods.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Volume claims can be added to `StatefulSets` in a specific `spec->volumeClaimTemplates`
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The `storage` property contains the storage requirements. `volumeMode` set to
    `Filesystem` is a standard setting that means the storage will be available as
    a file path. The other possible value is `Block`, which allocates the memory as
    `unformatted`. `storageClassName` must be set to an existing storage class offered
    by the cloud provider. If omitted, the default storage class will be assumed.
  prefs: []
  type: TYPE_NORMAL
- en: 'All available storage classes can be listed with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Once `volumeClaimTemplates` has defined how to create permanent storage, then
    each container must specify which file path to attach that permanent storage to
    in the `spec->containers->volumeMounts` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Here, `name` must correspond to the name given to the PVC.
  prefs: []
  type: TYPE_NORMAL
- en: The following subsection shows how to use Kubernetes secrets.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes secrets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Secrets are sets of key-value pairs that are encrypted to protect them. They
    can be created by putting each value in a file, and then invoking the following
    `kubectl` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the filenames become the keys and the file contents are the values.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the values are strings, they can be specified directly in the `kubectl`
    command, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: In this case, keys and values are listed one after the other, separated by the
    `=` character.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once defined, secrets can be referred to in the `spec->volume` property of
    a pod (`Deployment` or `StatefulSettemplate`), as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, each container can specify in which path to mount them in the `spec->containers->volumeMounts`
    property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, each key is seen as a file with the same name of the
    key. The content of the file is the secret value, base64-encoded. Therefore, the
    code that reads each file must decode its content (in .NET, `Convert.FromBase64`
    will do the job).
  prefs: []
  type: TYPE_NORMAL
- en: 'When secrets contain strings, they can also be passed as environment variables
    in the `spec->containers->env object`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `name` property must match the secret `name`. Passing secrets as environment
    variables is very convenient when containers host ASP.NET Core applications, since,
    in this case, environment variables are all immediately available in the configuration
    object (see the *Loading configuration data and using it with the options framework*
    section of *Chapter 15*, *Presenting ASP.NET Core MVC*).
  prefs: []
  type: TYPE_NORMAL
- en: 'Secrets can also encode the key/certificate pair of an HTTPS certificate, with
    the following `kubectl` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Secrets defined in this way can be used to enable HTTPS termination in `Ingresses`.
    It is enough to place the secret names in the `spec->tls->hosts->secretName` properties
    of an `Ingress`.
  prefs: []
  type: TYPE_NORMAL
- en: Liveness and readiness checks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Kubernetes automatically monitors all containers to ensure they are still alive
    and that they keep their resource consumption within the limits declared in the
    `spec->containers->resources->limits` object. When some conditions are violated,
    the container is either throttled, or restarted, or the whole pod instance is
    restarted on a different node. How does Kubernetes know that a container is in
    a healthy state? While it can use the operating system to check the healthy state
    of nodes, it has no universal check that works with all containers.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, the containers themselves must inform Kubernetes of their healthy
    state, otherwise Kubernetes must renounce verifying them. Containers can inform
    Kubernetes of their healthy state in two ways, either by declaring a console command
    that returns the healthy state, or by declaring an endpoint that provides the
    same information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Both declarations are provided in the `spec->containers->livenessProb` object.
    The console command check is declared as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: If `command` returns `0`, the container is considered healthy. In the preceding
    example, we suppose that the software running in the container records its state
    of health in the `/tmp/healthy` file, so that the `cat/tmp/healthy` command returns
    it. `PeriodSeconds` is the time between checks, while `initialDelaySeconds` is
    the initial delay before performing the first check. An initial delay is always
    necessary so as to give the container time to start.
  prefs: []
  type: TYPE_NORMAL
- en: 'The endpoint check is quite similar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The test is successful if the HTTP response contains the declared header with
    the declared value. You may also use a pure TCP check, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the check succeeds if Kubernetes is able to open a TCP socket
    to the container on the declared port.
  prefs: []
  type: TYPE_NORMAL
- en: In a similar way, the readiness of containers once they are installed is monitored
    with a readiness check. The readiness check is defined in exactly the same way
    as the liveness check, the only difference being that `livenessProbe` is replaced
    with `readinessProbe`.
  prefs: []
  type: TYPE_NORMAL
- en: The following subsection explains how to autoscale `Deployments`.
  prefs: []
  type: TYPE_NORMAL
- en: Autoscaling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Instead of modifying manually the number of replicas in a `Deployment`, in order
    to adapt it to a decrease or increase in load, we can let Kubernetes decide for
    itself the number of replicas trying to keep constant a declared resource consumption.
    Thus, for instance, if we declare a target 10% CPU consumption, when the average
    resource consumption of each replica exceeds this limit, a new replica is created,
    while if the average CPU falls below this limit, a replica is destroyed. The typical
    resource used to monitor replicas is CPU consumption, but we can also use memory
    consumption.
  prefs: []
  type: TYPE_NORMAL
- en: 'Autoscaling is achieved by defining a `HorizontalPodAutoscaler` object. Here
    is an example of the `HorizontalPodAutoscaler` definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '`spec-> scaleTargetRef->name` specifies the name of the `Deployment` to autoscale,
    while `targetAverageUtilization` specifies the target resource (in our case, CPU)
    percentage usage (in our case, 25%).'
  prefs: []
  type: TYPE_NORMAL
- en: The following subsection gives a short introduction to the Helm package manager
    and Helm charts, and explains how to install Helm charts on a Kubernetes cluster.
    An example of how to install an `Ingress Controller` is given.
  prefs: []
  type: TYPE_NORMAL
- en: Helm – Installing an Ingress Controller
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Helm charts are a way to organize the installation of complex Kubernetes applications
    that contain several `.yaml` files. A Helm chart is a set of `.yaml` files, organized
    into folders and subfolders. Here is a typical folder structure of a Helm chart
    taken from the official documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16756_07_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.6: Folder structure of a Helm chart'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `.yaml` files specific to the application are placed in the top `templates`
    directory, while the `charts` directory may contain other Helm charts used as
    helper libraries. The top-level `Chart.yaml` file contains general information
    on the package (name and description), together with both the application version
    and the Helm chart version. The following is a typical example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Here, `type` can be either `application` or `library`. Only `application` charts
    can be deployed, while `library` charts are utilities for developing other charts.
    `library` charts are placed in the `charts` folder of other Helm charts.
  prefs: []
  type: TYPE_NORMAL
- en: In order to configure each specific application installation, Helm chart `.yaml`
    files contain variables that are specified when Helm charts are installed. Moreover,
    Helm charts also provide a simple templating language that allows some declarations
    to be included only if some conditions depending on the input variables are satisfied.
    The top-level `values.yaml` file declares default values for the input variables,
    meaning that the developer needs to specify just the few variables for which they
    require values different from the defaults. We will not describe the Helm chart
    templates language, but you can find it in the official Helm documentation referred
    to in the *Further reading* section.
  prefs: []
  type: TYPE_NORMAL
- en: Helm charts are usually organized in public or private repositories in a way
    that is similar to Docker images. There is a Helm client that you can use for
    downloading packages from a remote repository and for installing charts in Kubernetes
    clusters. The Helm client is immediately available in the Azure Cloud Shell, so
    you can start using Helm for your Azure Kubernetes cluster with no need to install
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'A remote repository must be added before using its packages, as shown in the
    following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command makes available the packages of a remote repository and
    gives a local name to it. After that, any package of the remote repository can
    be installed with a command such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `<namespace>` is the namespace where to install the application. As usual,
    if not provided, the `default` namespace is assumed. `<instance name>` is the
    name that you give to the installed application. You need this name to get information
    about the installed application with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'You can get also information about all applications installed with Helm with
    the help of the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The application name is also needed to delete the application from the cluster,
    by means of the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'When we install an application, we may also provide a `.yaml` file with all
    the variable values we want to override. We can also specify a specific version
    of the Helm chart, otherwise the more recent version is assumed. Here is an example
    with both the version and values overridden:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, value overrides can also be provided in-line with the `--set` option,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also upgrade an existing installation with the `upgrade` command, as
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The `upgrade` command may specify new value overrides with the `–f` option or
    with the `--set` option, and it can specify a new version with `--version`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use Helm to provide an `Ingress` for the guestbook demo application.
    More specifically, we will use Helm to install an `Ingress-Controller` based on
    Nginx. The detailed procedure to be observed is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the remote repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Install the `Ingress-Controller`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: When the installation is complete, you should see an entry for the installed
    `Ingress-Controller` among the installed services if you type `kubectl get service`.
    The entry should contain a public IP. Please make a note of this IP since it will
    be the public IP of the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the `frontend.yaml` file and remove the `type: LoadBalancer` line. Save
    and upload this to Azure Cloud Shell. We changed the service type of the frontend
    application from `LoadBalancer` to `ClusterIP` (the default). This service will
    be connected to the new Ingress you are going to define.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Deploy `redis-master.yaml`, `redis-slave.yaml`, and `frontend.yaml` with `kubectl`,
    as detailed in the *Deploying the demo Guestbook application* subsection. Create
    a `frontend-ingress.yaml` file and place the following code in it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Upload `frontend-ingress.yaml` to Cloud Shell and deploy it with the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Open the browser and navigate to the public IP you annotated in *step 3*. There,
    you should see the application running.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since the public IP allocated to `Ingress-Controller` is available in the Azure
    *Public IP Addresses* section of Azure (use the Azure search box to find it),
    you can retrieve it there and assign it a hostname of the type `<chosen name>.<your
    Azure region>.cloudeapp.com`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You are encouraged to assign a hostname to the application public IP, and then
    to use this hostname to get a free HTTPS certificate from [https://letsencrypt.org/](https://letsencrypt.org/).
    Once you get a certificate, you can generate a secret from it with the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Then you can add the preceding secret to your `frontend-ingress.yamlIngress`
    by adding the following `spec->tls` section to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Following the correction, upload the file to your Azure Cloud Shell, and update
    the previous `Ingress` definition with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: At this point, you should be able to access the Guestbook application with HTTPS.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you are done experimenting, please don''t forget to delete everything
    from your cluster to avoid wasting your free Azure credit. You can do this by
    means of the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we described Kubernetes basic concepts and objects, and then
    we explained how to create an Azure Kubernetes cluster. We also showed how to
    deploy applications, and how to monitor and inspect the state of your cluster
    with a simple demo application.
  prefs: []
  type: TYPE_NORMAL
- en: The chapter also described more advanced Kubernetes features that cover a fundamental
    role in practical applications, including how to provide persistent storage to
    the containers running on Kubernetes, how to inform Kubernetes of the health state
    of your containers, and how to offer advanced HTTP services, such as HTTPS and
    name-based virtual hosting.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we reviewed how to install complex applications with Helm, and gave
    a short description of Helm and Helm commands.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn how to connect your .NET application with
    databases with Entity Framework.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Why are Services needed?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is an `Ingress` needed?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is Helm needed?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is it possible to define several Kubernetes objects in the same `.yaml` file?
    If yes, how?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does Kubernetes detect container faults?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why are persistent volume claims needed?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between a `ReplicaSet` and a `StatefulSet`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A good book for extending the knowledge acquired in this chapter is the following:
    [https://www.packtpub.com/product/hands-on-kubernetes-on-azure-second-edition/9781800209671](https://www.packtpub.com/product/hands-on-kubernetes-on-azure-second-edition/9781800209671).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The official documentation for Kubernetes and `.yaml` files can be found here:
    [https://kubernetes.io/docs/home/](https://kubernetes.io/docs/home/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'More information on Helm and Helm charts can be found in the official documentation.
    This is extremely well written and contains some good tutorials: [https://helm.sh/](https://helm.sh/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The official documentation for Azure Kubernetes can be found here: [https://docs.microsoft.com/en-US/azure/aks/](https://docs.microsoft.com/en-US/azure/aks/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The official documentation on the Azure Application Gateway-based `Ingress
    Controller` is available here: [https://github.com/Azure/application-gateway-kubernetes-ingress](https://github.com/Azure/application-gateway-kubernetes-ingress).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Ingress` certificate release and renewal can be automated as explained here:
    [https://docs.microsoft.com/en-us/azure/application-gateway/ingress-controller-letsencrypt-certificate-application-gateway](https://docs.microsoft.com/en-us/azure/application-gateway/ingress-controller-letsencrypt-certificat).
    While the procedure specifies an Azure Application Gateway-based ingress controller,
    it is adequate for any `Ingress Controller`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
