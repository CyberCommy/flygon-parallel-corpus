- en: Chapter 4. Built-in Data Structures – list, set, dict
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter we''ll look at the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Choosing a data structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building lists – literals, appending, and comprehensions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Slicing and dicing a list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deleting from a list – deleting, removing, popping, and filtering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reversing a copy of a list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using set methods and operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removing items from a set – remove(), pop(), and difference
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating dictionaries – inserting and updating
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removing from dictionaries – the pop() method and the del statement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling the order of dict keys
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling dictionaries and sets in doctest examples
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding variables, references, and assignment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making shallow and deep copies of objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoiding mutable default values for function parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python has a rich collection of built-in data structures. A great deal of useful
    programming is commonly done with these built-in structures. These collections
    cover a variety of common situations.
  prefs: []
  type: TYPE_NORMAL
- en: We'll look at an overview of the various structures that are available and what
    problems they solve. From there, we can look at lists, dictionaries, and sets
    in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we've set the built-in tuple and string aside as being different from
    the list structure. There are some important similarities as well as some differences.
    In [Chapter 1](text00014.html#page "Chapter 1. Numbers, Strings, and Tuples")
    , *Numbers, Strings, and Tuples* , we emphasized the way strings and tuples behave
    more like immutable numbers than mutable collections.
  prefs: []
  type: TYPE_NORMAL
- en: We'll also look at some more advanced topics related to how python handles references
    to objects. We'll look at some issues related to the mutability of these data
    structures, as well.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing a data structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python offers a number of built-in data structures to help us work with collections
    of data. It can be confusing to determine which is appropriate for a given purpose.
  prefs: []
  type: TYPE_NORMAL
- en: How do we choose which structure to use? What are the features of lists, sets,
    and dictionaries? Why do we have tuples and frozen sets?
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we put data into a collection, we'll need to consider how we'll gather
    the data, and what we'll do with the collection once we have it. The big question
    is always how we'll identify a particular item within the collection.
  prefs: []
  type: TYPE_NORMAL
- en: We'll look at a few key questions that we need to answer.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Is the programming focused on doing membership tests? An example of this is
    a collection of valid input values. When the user enters something that's in the
    collection, their input is valid, otherwise it's invalid.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Simple membership suggests using a `set` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'A `set` holds items in no particular order. Once an item is a member, we can''t
    add it again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We have created a set, `valid_inputs` , with four distinct string items. We
    can't add another `y` to a set which already contains `y` . The contents of the
    set doesn't change.
  prefs: []
  type: TYPE_NORMAL
- en: Also note that the order of the items in the set isn't exactly the order in
    which we initially provided them. A set can't maintain any particular order to
    the items, it can only determine if an item exists in the set.
  prefs: []
  type: TYPE_NORMAL
- en: Are we going to identify items by their position in the collection? An example
    includes the lines in an input file—the line number is its position in the collection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When we must identify an item using an index or position, we must use a `list`
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We have created a list, `month_name_list` , with 12 string items. We can pick
    an item by providing its position. We can also use the `index()` method to locate
    the index of an item in the list.
  prefs: []
  type: TYPE_NORMAL
- en: Lists in Python always start with position zero. This is true for tuples and
    strings, also.
  prefs: []
  type: TYPE_NORMAL
- en: If the number of items in the collection is fixed—for example RGB colors have
    three values—then we might be looking at a `tuple` instead of a `list` . If the
    number of items will grow and change, then the `list` collection is a better choice
    than the `tuple` collection.
  prefs: []
  type: TYPE_NORMAL
- en: Are we going to identify the items in a collection by a key that's not the item's
    position? An example might include a mapping between strings of characters—words—and
    integers which represent the frequencies of those words, or a mapping between
    a color name and the RGB tuple for that color.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When we must identify items with a non-positional key, we''re using some kind
    of mapping. The built-in mapping is `dict` . There are several extensions that
    add more features:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In this dictionary, `scheme` , we've created a mapping from color names to the
    RGB color tuples. When we use a key, for example `"Crimson"` , we can retrieve
    the value bound to that key.
  prefs: []
  type: TYPE_NORMAL
- en: Consider the mutability of items in a `set` collection and the keys in a `dict`
    collection. Each item in a set must be an immutable object. Numbers, strings,
    and tuples are all immutable, and can be collected into sets. Since a `list` ,
    `dict` , or `set` object is mutable, they can't be used as items in a set. It's
    impossible to build a `set` of `list` items, for example.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rather than create a `set` of `list` items, we can transform each `list` item
    into a `tuple` . We can create a `set` of immutable `tuple` items.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, dictionary keys must be immutable. We can use a number, or a string,
    or a tuple as a dictionary key. We can't use a `list` , or a `set` , or another
    mutable mapping as a dictionary key.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each of Python's built-in collections offers a specific set of unique features.
    The collections also offer a large number of overlapping features. The challenge
    for programmers new to Python is to identify the unique features of each collection.
  prefs: []
  type: TYPE_NORMAL
- en: It turns out that the `collections.abc` module provides a kind of road map through
    the built-in collections. The `collections.abc` module defines the **Abstract
    Base Classes** ( **ABC** s) that support the concrete classes we use. We'll use
    the names from this set of definitions to guide us through the features.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the ABCs, we can see that there are actually places for a total of six
    kinds of collections:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Set** : The unique feature is that items are either members or not. This
    means duplicates can''t be handled:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mutable set** : The `set` collection'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Immutable set** : The `frozenset` collection'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sequence** : The unique feature is that items are provided with an index
    position:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mutable sequence** : The `list` collection'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Immutable sequence** : The `tuple` collection'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mapping** : The unique feature is that each item has a key that refers to
    a value:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mutable mapping** : The `dict` collection'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Immutable mapping** : Interestingly, there''s no built-in frozen mapping'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python's libraries offer a large number of additional implementations of these
    core collection types. We can see many of these in the *Python Standard Library*
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'The `collections` module contains a number of variations on the built-in collections.
    These include:'
  prefs: []
  type: TYPE_NORMAL
- en: '`namedtuple` : A `tuple` that offers names for each item in a tuple. It''s
    slightly more clear to use `rgb_color.red` than `rgb_color[0]` .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`deque` : A double-ended queue. It''s a mutable sequence with optimizations
    for pushing and popping from each end. We can do similar things with a `list`
    , but the `deque` is more efficient.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`defaultdict` : A `dict` that can provide a default value for a missing key.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Counter` : A `dict` which is designed to count occurrences of a key. This
    is sometimes called a multiset or a bag.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OrderedDict` : A `dict` which retains the order in which keys were created.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ChainMap` : A `dict` which combines several dictionaries into a single mapping.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's more in the *Python Standard Library* . We can also use the `heapq`
    module which defines a priority queue implementation. The `bisect` module includes
    methods for searching a sorted list very quickly. This allows a list to have performance
    that is a little closer to the fast lookups of a dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can look at a list of data structures like this: [https://en.wikipedia.org/wiki/List_of_data_structures](https://en.wikipedia.org/wiki/List_of_data_structures)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: There are some important summaries that are part of this giant index of data
    structures. Different parts of the article provide slightly different summaries
    of data structures. We'll take a quick look at four classifications.
  prefs: []
  type: TYPE_NORMAL
- en: '**Arrays** : There are variant implementations that offer similar features.
    Python''s `list` structure is typical, and offers performance similar to a linked-list
    implementation of an array.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Trees** : Generally, tree structures can be used to create sets, sequential
    lists, or key-value mappings. We can look at a tree as an implementation technique,
    rather than a data structure with a unique feature set.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hashes** : Python uses hashes to implement dictionaries and sets. This leads
    to good speed but large memory consumption.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Graphs** : Python doesn''t have a built-in graph data structure. However,
    we can easily represent a graph structure with a dictionary where each node has
    a list of adjacent nodes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can—with a little cleverness—implement almost any kind of data structure
    in Python. Either the built-in structures have the essential features, or we can
    locate a built-in structure that can be pressed into service.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For advanced graph manipulation, see [https://networkx.github.io](https://networkx.github.io)
    .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building lists – literals, appending, and comprehensions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we've decided to create a collection that uses an item's position—a `list`
    —we have several ways of building this structure. We'll look at a number of ways
    we can build a list object from individual items.
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, we'll need a list because it allows duplicate values. A great
    many statistical operations don't require knowing the position of an item. A multiset
    would be useful for this, but we don't have this as a built-in structure; it's
    very common to use a `list` instead of a multiset.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s say we need to do some statistical analyses on some file sizes. Here''s
    a short script that will provide us with the sizes of some files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We've used a `pathlib.Path` object to represent a directory in our file system.
    The `glob()` method expands all names that match a given pattern. In this case,
    we used a pattern of `'*/index.rst'` . We can use the `for` statement to display
    the size from the file's OS `stat` data.
  prefs: []
  type: TYPE_NORMAL
- en: We'd like to accumulate a `list` object that has the various file sizes. From
    that we can compute total size, and average size. We can look for files which
    seem too large or too small.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have four ways to create `list` objects:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create literal display of a `list` using a sequence of values surrounded
    by `[]` characters. It looks like this: `[value, ... ]` . Python needs to match
    the `[` and `]` to see a complete logical line, so the literal can span physical
    lines. For more information see the *Writing long lines of code* recipe in [Chapter
    2](text00027.html#page "Chapter 2. Statements and Syntax") , *Statements and Syntax*
    .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We can convert some other data collection into a list using the `list()` function.
    We can convert a `set` , or the keys of a `dict` , or the values of a `dict` .
    We'll look at a more sophisticated example of this in the *Slicing and dicing
    a list* recipe.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have `list` methods that allow us to build a `list` one item a time. These
    methods include `append()` , `extend()` and `insert()` . We'll look at `append()`
    in the *Building a list with the append() method* section of this recipe. We'll
    look at the other methods in the *There's More...* section of this recipe.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have generator expressions which can be used to build `list` objects. One
    kind of generator is a list comprehension.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Building a list with the append() method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Create an empty list, `[]` :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Iterate through some source of data. Append the items to the list using the
    `append()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We used the path's `glob()` method to find all files that match the given pattern.
    The `stat()` method of a path provides the OS **stat** data structure, which includes
    the size, `st_size` , in bytes.
  prefs: []
  type: TYPE_NORMAL
- en: When we print the `list` , Python displays it in literal notation. This is handy
    if we ever need to copy and paste the list into another script.
  prefs: []
  type: TYPE_NORMAL
- en: It's very important to note that the `append()` method does not return a value.
    The `append()` method mutates the `list` object, and does not return anything.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Generally, any method that mutates an object has no return value. Methods like
    `append()` , `extend()` , `sort()` , and `reverse()` have no return value. They
    adjust the structure of the `list` object itself.
  prefs: []
  type: TYPE_NORMAL
- en: The `append()` method does not return a value.
  prefs: []
  type: TYPE_NORMAL
- en: It mutates the `list` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s surprisingly common to see wrong code like this: `a = [''some'', ''data'']`
    `a = a.append(''more data'')` This is emphatically wrong. This will set `a` to
    `None` .'
  prefs: []
  type: TYPE_NORMAL
- en: 'The correct approach is a statement like this, without any additional assignment:'
  prefs: []
  type: TYPE_NORMAL
- en: '`a.append(''more data'')`'
  prefs: []
  type: TYPE_NORMAL
- en: Writing a list comprehension
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The goal of a list comprehension is to create an object that occupies a syntax
    role similar to a list literal:'
  prefs: []
  type: TYPE_NORMAL
- en: Write the wrapping `[]` brackets that surround the list object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write the source of the data. This will include the target variable. Note that
    there''s no `:`  at the end because we''re not writing a complete statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Prefix this with the expression to evaluate for each value of the target variable.
    Again, since this is a simple expression we cannot use complex statements here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In some cases, we'll need to add a filter. This is an `if` clause after the
    `for` clause. We can make the generator expression quite sophisticated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the entire `list` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now that we've created a `list` object, we can assign it to a variable and do
    other calculations and summaries on the data.
  prefs: []
  type: TYPE_NORMAL
- en: The list comprehension includes a generator expression, called a **comprehension**
    in the language manual. The generator expression is a data expression attached
    to a `for` clause. Since this generator is an expression, not a complete statement,
    there are some limitations on what it can do. The data expression is evaluated
    repeatedly, and is controlled by the `for` clause.
  prefs: []
  type: TYPE_NORMAL
- en: Using the list function on a generator expression
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We''ll create a `list` function that uses the generator expression:'
  prefs: []
  type: TYPE_NORMAL
- en: Write the wrapping `list()` function that surrounds the generator expression.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We''ll reuse steps two and three from the list comprehension version to create
    a generator expression. Here''s the generator expression:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the entire list object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A Python `list` object has a dynamic size. The bounds of the array are adjusted
    when items are appended or inserted, or the `list` is extended with another `list`
    . Similarly, the bounds shrink when items are popped or deleted. We can access
    any item very quickly, and the speed of access doesn't depend on the size of the
    list.
  prefs: []
  type: TYPE_NORMAL
- en: 'In rare cases, we might want to create a `list` with a given initial size,
    and then set the values of the items separately. We can do this with a list comprehension
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This will create a list with an initial size of 100 items, each of which is
    `None` . It's rare to need this, though, because lists can grow in size as needed.
  prefs: []
  type: TYPE_NORMAL
- en: The list comprehension syntax and the `list()` function both consume items from
    a generator and append them to create a new `list` object.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our goal in creating a `list` object was to be able to summarize it. We can
    use a variety of Python functions for this. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve used the built-in `sum()` , `min()` , and `max()` to produce some descriptive
    statistics of these document sizes. Which of these index files is the smallest?
    We want to know the position of the minimum in the list of values. We can use
    the `index()` method for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We've found the minimum, and then used the `index()` method to locate the position
    of that minimal value. Recall that the index values start at zero, so the smallest
    file is for the twelfth chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Other ways to extend a list
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can extend a list, as well as insert into the middle or beginning of a list.
    We have two ways to extend a list: we can use the `+` operator or we can use the
    `extend()` method. Here''s an example of creating two lists and putting them together
    with `+` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We have created a list of sizes of documents with names like `ch_01*/*.rst`
    . We then created a second list of sizes of documents with a slightly different
    name pattern, `ch_02*/*.rst` . We then combined the two lists into a final list.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do this using the `extend()` method, also. We''ll reuse the two lists
    and build a new list from them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We noted that `append()` does not return a value. Note that `extend()` does
    not return a value, either. The `extend()` method mutates the `list` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can insert a value prior to any particular position in a list, also. The
    `insert()` method accepts the position of an item; the new value will be before
    the given position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We've inserted two new values into a `list` object. As with `append()` and `extend()`
    , `insert()` does not return a value. It mutates the `list` object.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See the *Slicing and dicing a list* recipe for ways to copy lists and pick sublists
    from a list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See the *Deleting from a list – deleting, removing, popping, and filtering*
    recipe for other ways to remove items from a list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the *Reversing a copy of a list* recipe we'll look at reversing a list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This article provides some insights into how Python collections work internally:
    [https://wiki.python.org/moin/TimeComplexity](https://wiki.python.org/moin/TimeComplexity)
    . When looking at the tables, it''s important to note that **O** (1) means that
    the cost is essentially constant, and **O** (n) means the cost varies with the
    index of the item we''re trying to process. This means that the cost grows as
    the size of the collection grows.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Slicing and dicing a list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many times when we want to pick items from a list. One of the most
    common kinds of processing is to treat the first item of a list as a special case.
    This leads to a kind of *head-tail* processing where we treat the head of a list
    differently from the items in the tail of a list.
  prefs: []
  type: TYPE_NORMAL
- en: We can use these techniques to make a copy of a list, also.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have a spreadsheet that was used to record fuel consumption on a large sailboat.
    It has rows which look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **date** | **engine on** | **fuel height** |'
  prefs: []
  type: TYPE_TB
- en: '|  | **engine off** |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | **Other notes** |  |'
  prefs: []
  type: TYPE_TB
- en: '| 10/25/2013 | 08:24 | 29 |'
  prefs: []
  type: TYPE_TB
- en: '|  | 13:15 | 27 |'
  prefs: []
  type: TYPE_TB
- en: '|  | calm seas—anchor solomon''s island |  |'
  prefs: []
  type: TYPE_TB
- en: '| 10/26/2013 | 09:12 | 27 |'
  prefs: []
  type: TYPE_TB
- en: '|  | 18:25 | 22 |'
  prefs: []
  type: TYPE_TB
- en: '|  | choppy—anchor in jackson''s creek |  |'
  prefs: []
  type: TYPE_TB
- en: Fuel height? Yes. There's no float sensor to estimate the level of fuel in the
    tanks. Instead there's a **sight-gauge** that allows direct observation of the
    fuel. It's calibrated in inches of depth. For all practical purposes the tank
    is rectangular, so the depth shown can be converted to volume pretty easily—31
    inches of depth is about 75 gallons.
  prefs: []
  type: TYPE_NORMAL
- en: What's important is that the spreadsheet data is not properly normalized. Ideally,
    each row follows the first normal form for data with each row having identical
    content, and each cell having only atomic values.
  prefs: []
  type: TYPE_NORMAL
- en: Our data is not properly normalized. We have four rows of headings. This is
    something the `csv` module can't deal with directly. We need to do some slicing
    to remove the rows from other notes. We'd like to combine the two rows of each
    day's travel to make it easier to compute an elapsed time and the number of inches
    used.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can read the data like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We've used the `csv` module to read the log details. A `csv.reader()` is an
    iterable object. In order to collect the items into a single list, we applied
    the `list()` function. We looked at the first and last item in the list to confirm
    that we really have a list of lists structure.
  prefs: []
  type: TYPE_NORMAL
- en: Each row of the original CSV file is a list. Each of those lists is a three
    item sublist.
  prefs: []
  type: TYPE_NORMAL
- en: For this recipe, we'll use an extension of a list index expression to slice
    items from a list. The slice, like the index, follows the list object in `[]`
    characters. Python offers us several variations on the slice expression. A slice
    can include two or three values in the slice, separated by `:` characters. We
    can write `:stop` , `start:` , `start:stop` , `start:stop:step` , or any of several
    other variations. The default step value is one. The default start value is the
    beginning of the list and the default stop value is the end of the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how we can slice and dice the raw list of rows to pick out the rows
    we need:'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first thing we need to do is remove the four lines of heading from the
    list of rows. We''ll use two partial slice expressions to divide the list at row
    four:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We've sliced the list into two sections using `log_rows[:4]` and `log_rows[4:]`
    . The `head` variable will have the four lines of headings. We don't really want
    to do any processing with the head, so we ignore that variable. The `tail` variable,
    however, has the rows of the sheet we care about.
  prefs: []
  type: TYPE_NORMAL
- en: We'll use slices with steps to pick the interesting rows. The `[start::step]`
    version of a slice will pick rows in groups based on the step value. In our case,
    we'll take two slices. One slice starts on row zero and the other slice starts
    on row one.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here''s a slice of every third row, starting with row zero:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll also want every third row, starting with row one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'These two slices can then be zipped together:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve sliced the list into two parallel groups:'
  prefs: []
  type: TYPE_NORMAL
- en: The `[0::3]` slice starts with the first row, and includes every third row.
    This will be rows zero, three, six, nine, and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `[1::3]` slice starts with the second row, and includes every third row.
    This will be rows one, four, seven, ten, and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We've used the `zip()` function to interleave these two sequences from the list.
    This gives us a sequence of three tuples that's very close to something we can
    work with.
  prefs: []
  type: TYPE_NORMAL
- en: 'Flatten the results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We've used a list comprehension from the *Building lists – literals, appending,
    and comprehensions* recipe to combine the two elements in each pair of rows to
    create a single row. Now we're in a position to convert the date and time into
    a single `datetime` value. We can then compute the difference in times to get
    the running time for the boat, and the difference in heights to estimate the fuel
    burned.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The slice operator has several different common forms:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[:]` : The start and stop are implied. The expression `S[:]` will copy the
    sequence, *S* .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[:stop]` : This makes a new list from the beginning to just before the stop
    value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[start:]` : This makes a new list from the given start to the end of the sequence.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[start:stop]` : This picks a sublist starting from the start index and stopping
    just before the stop index. Python works with half-open intervals. The start is
    included, the end is not included.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[::step]` : The start and stop are implied and include the entire sequence.
    The step—generally not equal to one—means we''ll skip through the list from the
    start using the step. For a given step, *s* , and a list of size | *L* |, the
    index values are ![How it works...](Image00010.jpg)  .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[start::step]` : The start is given, but the stop is implied. The idea is
    that the start is an offset, and the step applies to that offset. For a given
    start, *a* , step, *s* , and a list of size | *L* |, the index values are ![How
    it works...](Image00011.jpg)  .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[:stop:step]` : This is used to prevent processing the last few items in a
    list. Since the step is given, processing begins with element zero.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[start:stop:step]` : This will pick elements from a subset of the sequence.
    Items prior to start and after stop will not be used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The slicing technique works for lists, tuples, strings, and any other kind of
    sequence. This does not cause the object to be mutated; this will make a copy
    of the items.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the *Reversing a copy of a list* recipe, we'll look at an even more sophisticated
    use of slice expressions.
  prefs: []
  type: TYPE_NORMAL
- en: The copy is called a **shallow copy** because we'll have two collections that
    contain references to the same underlying objects. We'll look at this in detail
    in the *Making shallow and deep copies of objects* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: For this specific example, we have another way of restructuring multiple rows
    of data into single rows of data. We can use a generator function. We'll look
    at functional programming techniques in [Chapter 8](text00088.html#page "Chapter 8. Functional
    and Reactive Programming Features") , *Functional and Reactive Programming Features*
    .
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See the *Building lists – literals, appending, and comprehensions* recipe for
    ways to create lists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See the *Deleting from a list – deleting, removing, popping, and filtering*
    recipe for other ways to remove items from a list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the *Reversing a copy of a list* recipe we'll look at reversing a list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deleting from a list – deleting, removing, popping, and filtering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many times when we want to remove items from a `list` collection.
    We might delete items from a list, and then process the items which are left over.
  prefs: []
  type: TYPE_NORMAL
- en: Removing unneeded items has a similar effect as using the `filter()` to create
    a copy which has only the needed items. The distinction is that a filtered copy
    will use more memory than deleting items from a list. We'll show both techniques
    for removing unwanted items from a list.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have a spreadsheet that is used to record fuel consumption on a large sailboat.
    It has rows which look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **date** | **engine on** | **fuel height** |'
  prefs: []
  type: TYPE_TB
- en: '|  | **engine off** |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | **Other notes** |  |'
  prefs: []
  type: TYPE_TB
- en: '| 10/25/2013 | 08:24 | 29 |'
  prefs: []
  type: TYPE_TB
- en: '|  | 13:15 | 27 |'
  prefs: []
  type: TYPE_TB
- en: '|  | calm seas—anchor solomon''s island |  |'
  prefs: []
  type: TYPE_TB
- en: '| 10/26/2013 | 09:12 | 27 |'
  prefs: []
  type: TYPE_TB
- en: '|  | 18:25 | 22 |'
  prefs: []
  type: TYPE_TB
- en: '|  | choppy—anchor in jackson''s creek |  |'
  prefs: []
  type: TYPE_TB
- en: For more background on this data, see the *Slicing and dicing a list * recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can read the data like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We've used the `csv` module to read the log details. A `csv.reader()` is an
    iterable object. In order to collect the items into a single list, we applied
    the `list()` function. We looked at the first and last item in the list to confirm
    that we really have a list-of-lists structure.
  prefs: []
  type: TYPE_NORMAL
- en: Each row of the original CSV file is a list. Each of those lists has three items.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ll look at four ways to remove things from a list:'
  prefs: []
  type: TYPE_NORMAL
- en: The `del` statement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `remove()` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `pop()` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `filter()` function to create a copy that rejects selected rows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deleting items from a list
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can remove items from a list using the `del` statement.
  prefs: []
  type: TYPE_NORMAL
- en: To make it easy to follow the examples at the interactive prompt, we'll make
    a copy of the list. If we deleted rows from the original `log_rows` list, subsequent
    examples might be hard to follow. In a practical program, we would not make this
    extra copy. We could also have used `log_rows[:]` to copy the original list.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s how the `del` statement looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The `del` statement removed the header rows from the tail, leaving behind the
    rows that we really need to process. We can then combine these and summarize them
    using the *Slicing and dicing a list* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: The remove() method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can remove items from a list using the `remove()` method. This removes matching
    items from a list.
  prefs: []
  type: TYPE_NORMAL
- en: 'We might have a list that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This has a useless `''''` string in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `remove()` method does not return a value. It mutates the list
    in place. This is an important distinction that applies to mutable objects.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `remove()` method does not return a value.
  prefs: []
  type: TYPE_NORMAL
- en: It mutates the list object.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s surprisingly common to see wrong code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`a = [''some'', ''data'']`'
  prefs: []
  type: TYPE_NORMAL
- en: '`a = a.remove(''data'')`'
  prefs: []
  type: TYPE_NORMAL
- en: This is emphatically wrong. This will set `a` to `None` .
  prefs: []
  type: TYPE_NORMAL
- en: The pop() method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can remove items from a list using the `pop()` method. This removes items
    from a list based on their index.
  prefs: []
  type: TYPE_NORMAL
- en: 'We might have a list that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This has a useless `''''` string in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the `pop()` method does two things:'
  prefs: []
  type: TYPE_NORMAL
- en: It mutates the `list` object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It returns the value which was removed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The filter() function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can also remove items by building a copy that passes the desirable items
    and rejects the undesirable items. Here's how we can do this with the `filter()`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Identify the features of the items we wish to pass or reject. The `filter()`
    function expects a rule for passing data. The logical inverse of that function
    will reject data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In our case, the rows we want have a numeric value in column two. We can best
    detect this with a little helper function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the filter test function. If it''s trivial, use a lambda object. Otherwise,
    write a separate function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We've used the built-in `float()` function to see if a given string is a proper
    number. If the `float()` function does not raise an exception, the data is a valid
    number, and we want to pass this row. If an exception is raised, the data was
    not numeric, and we'll reject the row.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the filter test function (or lambda) with the data in the `filter()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We provided our test, `number_column()` and the original data, `log_rows` .
    The output from the `filter()` function is an iterable. To create a list from
    the iterable result, we'll use the `list()` function. The result has just the
    four rows we want; the remaining rows were rejected.
  prefs: []
  type: TYPE_NORMAL
- en: We haven't really deleted the rows. We've created a copy which omits those rows.
    The end result is the same.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Because a list is a mutable object, we can remove items from the list. This
    technique doesn't work for tuples or strings. All three collections are sequences,
    but only the list is mutable.
  prefs: []
  type: TYPE_NORMAL
- en: We can only remove items with an index that's present in the list. If we attempt
    to remove an item with an index outside the allowed range, we'll get an `IndexError`
    exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are some times where this doesn't work. If we use a list in a `for` statement,
    we can't delete items from the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say we want to remove all even items from a list. Here''s an example
    that does not work properly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The result is clearly not right. Why are some even-valued items left in the
    list?
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at what happens when processing the item with a value of eight. We'll
    execute the `remove()` method. The value will be removed, and all the subsequent
    values will be slid forward one position. The `10` will be moved into the position
    formerly occupied by the `8` . The list's internal index will move forward to
    the next position, which will have a `13` in it. The `10` will never be processed.
  prefs: []
  type: TYPE_NORMAL
- en: Bad things also happen if we insert into the middle of a list, the driving iterable
    in a `for` loop. In that case, items will be processed twice.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have two ways to avoid the *skip-when-delete* problem:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Make a copy of the list:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Use a `while` loop with a manual index:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We've designed a loop which only increments the position if the item is odd.
    If an item is even it's removed, and the other items are moved forward one position
    in the list.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See the *Building lists – literals, appending, and comprehensions* recipe for
    ways to create lists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See the *Slicing and dicing a list* recipe for ways to copy lists and pick sublists
    from a list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the *Reversing a copy of a list* recipe we'll look at reversing a list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reversing a copy of a list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once in a while, we need to reverse the order of the items in a `list` collection.
    Some algorithms, for example, produce results in a reversed order. We'll look
    at the way numbers converted to a specific base are often generated from least-significant
    to most-significant digit. We generally want to display the values with the most-significant
    digit first. This leads to a need to reverse the sequence of digits in a list.
  prefs: []
  type: TYPE_NORMAL
- en: We have two ways to reverse a list. First, there's the `reverse()` method. Then
    there's this handy trick.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's say we're doing a conversion among number bases. We'll look at how a number
    is represented in a base, and how we can compute that representation from a number.
  prefs: []
  type: TYPE_NORMAL
- en: 'Any value, *v* , can be defined as a polynomial function of the various digits,
    *d[n]* , in a given base, *b* :'
  prefs: []
  type: TYPE_NORMAL
- en: '*v* = *d[n]* × *b^n* + *d[n]* [-1] × *b^n* ^(-1) + *d[n]* [-2] × *b^n* ^(-2)
    + ... + *d* [1] × *b* + *d* [0]'
  prefs: []
  type: TYPE_NORMAL
- en: A rational number has a finite number of digits. An irrational number would
    have an infinite series of digits.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the number `0xBEEF` is a base 16 value. The digits are { *B* =
    11, *E* = 14, *F* = 15}, the base *b* = 16.
  prefs: []
  type: TYPE_NORMAL
- en: 48879 = 11 × 16³ + 14 × 16² + 14 × 16 + 15
  prefs: []
  type: TYPE_NORMAL
- en: 'We can restate this in a form that''s slightly more efficient to compute:'
  prefs: []
  type: TYPE_NORMAL
- en: '*v* = (...(( *d[n]* × *b* + *d[n]* [-1] ) × *b* + *d[n]* [-2] ) × *b* + ...
    + *d* [1] ) × *b* + *d* [0]'
  prefs: []
  type: TYPE_NORMAL
- en: There are many cases where the base isn't a consistent power of some number.
    The ISO date format, for example, has a mixed base that involves 7 days per week,
    24 hours per day, 60 minutes per hour, and 60 seconds per minute.
  prefs: []
  type: TYPE_NORMAL
- en: Given a week number, a day of the week, an hour, a minute, and a second, we
    can compute a timestamp of seconds, *t[s]* , within the given year.
  prefs: []
  type: TYPE_NORMAL
- en: '*t[s]* = ((( *w* × 7 + *d* ) × 24 + *h* ) × 60 + *m* ) × 60 + *s*'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: How do we invert this calculation? How do we get the various fields from the
    overall timestamp?
  prefs: []
  type: TYPE_NORMAL
- en: We'll need to use `divmod`  style division. For some background, see the *Choosing
    between True Division and Floor Division* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'The algorithm for converting a timestamp in seconds, *t[s]* , to individual
    week, day, and time fields looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*t[m]* , *s*  ← *t[s]* /60, *t[s]* mod 60'
  prefs: []
  type: TYPE_NORMAL
- en: '*t[h]* , *m*  ← *t[m]* /60, *t[m]* mod 60'
  prefs: []
  type: TYPE_NORMAL
- en: '*t[d]* , *h*  ← *t[h]* /60, *t[h]* mod 24'
  prefs: []
  type: TYPE_NORMAL
- en: '*w* , *d*  ← *t[d]* /60, *t[d]* mod 7'
  prefs: []
  type: TYPE_NORMAL
- en: 'This has a handy pattern that leads to a very simple implementation. It has
    a consequence of producing the values in reverse order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: We've applied the `divmod()` function four times to extract seconds, minutes,
    hours, days, and weeks from a timestamp given in seconds. These are in the wrong
    order. How can we reverse them?
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have two approaches: we can use the `reverse()` method or we can use a `[::-1]`
    slice expression. Here''s the `reverse()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: We made a copy of the original list, so that we could keep an unmutated copy
    to compare with the mutated copy. This makes it easier to follow the examples.
    We applied the `reverse()` method to reverse a copy of the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'This will mutate the list. As with other mutating methods, it does not return
    a useful value. It''s an error to use a statement like this: `a = b.reverse()`
    . The value of `a` will always be `None` .'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a slice expression with a negative step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we made a slice `[::-1]` which uses an implied start and stop,
    and the step was `-1` . This picks all of the items in the list in reverse order
    to create a new list.
  prefs: []
  type: TYPE_NORMAL
- en: The original list is emphatically *not* mutated by this `slice` operation. This
    creates a copy. Check the value of the `fields` variable to see that it's unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we noted in the *Slicing and dicing a list* recipe, the slice notation is
    quite sophisticated. Using a slice with a negative step size will create a copy
    (or a subset) with items processed in right to left order instead of the default
    left to right order.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s important to distinguish between these two methods:'
  prefs: []
  type: TYPE_NORMAL
- en: The `reverse()` function modifies the `list` object itself. As with methods
    like `append()` and `remove()` there is no return value from this method. Because
    it changes the list, it doesn't return a value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `[::-1]` slice expression creates a new list. This is a shallow copy of
    the original list, with the order reversed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See the *Making shallow and deep copies of objects* recipe for more information
    on what a shallow copy is and why we might want to make a deep copy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See the *Building lists – literals, appending, and comprehensions* recipe for
    ways to create lists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See the *Slicing and dicing a list* recipe for ways to copy lists and pick sublists
    from a list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See the *Deleting from a list – deleting, removing, popping, and filtering*
    recipe for other ways to remove items from a list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using set methods and operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have several ways to build a `set` collection. We can use the `set()` function
    to convert an existing collection to a set. We can use the `add()` method to put
    items into a set. We can also use the `update()` method and the union operator,
    `|` , to create a larger set from other sets.
  prefs: []
  type: TYPE_NORMAL
- en: We'll show a recipe that uses a `set` to show whether or not we've seen a complete
    domain of values from a pool of statistical data. The recipe will build a `set`
    collection as the samples are being scanned.
  prefs: []
  type: TYPE_NORMAL
- en: 'When doing exploratory data analysis, we need to answer the question: *Is this
    data random?* Many data collections have variances in the data that are ordinary
    noise. It''s important not to waste time doing complex modeling and analysis of
    random numbers.'
  prefs: []
  type: TYPE_NORMAL
- en: For discrete or continuous numeric data, like the depth of water in meters,
    or the size of a file in bytes, we can use averages and standard deviations to
    see if a given collection of data is random. We expect a sample's mean to match
    the population mean within boundaries that are measured by the standard deviation.
  prefs: []
  type: TYPE_NORMAL
- en: For categorical data, like customer ID numbers or phone numbers, we can't compute
    averages or standard deviations. These values have to be evaluated in a different
    way.
  prefs: []
  type: TYPE_NORMAL
- en: One technique for determining the randomness of categorical data is the **Coupon
    Collector's Test** . With this test, we will see how many items have to be examined
    before we have found a complete set of *coupons* . Is a sequence of customer visits
    random? Or is there some other distribution in the sequence of visits? If the
    data is not random, then we can invest in more research into the causes.
  prefs: []
  type: TYPE_NORMAL
- en: The Python `set` collection is central to how this works. We'll add items to
    a `set` until we've seen each customer once.
  prefs: []
  type: TYPE_NORMAL
- en: 'If customers arrive randomly, we can predict an expected number of visits before
    the business has seen each customer at least once. The overall expected arrival
    time for the entire domain is the sum of the arrival times for each customer in
    the domain. This is equal to the number of customers, *n* , times the n^(th) Harmonic
    Number, *H[n]* :'
  prefs: []
  type: TYPE_NORMAL
- en: '*E* = *n* × *H[n]* = *n* × ((1/1) + (1/2) + (1/3) + (1/ *n* ))'
  prefs: []
  type: TYPE_NORMAL
- en: This is the expected average number of visits before all customers have been
    seen. If the actual average arrival time matches this expectation that means all
    customers are visiting; we don't need to waste any more time on studying data
    that fits our expectations. If the actual average doesn't match expectations,
    then some customers are not visiting as frequently as others, and we need to pursue
    a deeper study of why.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll use a Python `set` to represent the collection of coupons. We'll need
    a population of data that may (or may not) have a proper distribution of *coupons*
    . We'll look at a set of eight customers.
  prefs: []
  type: TYPE_NORMAL
- en: Here's a function that simulates customers arriving in a random order. The customers
    are represented as numbers in the half-open interval [0, *n* ], we can say that
    all customers, *c* , fit the rule 0 ≤ *c* < *n* .
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The `arrival1()` function will yield an endless sequence of values. We've called
    this `arrival` with a `1` on the end. It may look like a spelling mistake, but
    we've used the `1` suffix so that we can create alternative implementations.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to put an upper bound on the number of values generated. Here''s a
    function that has an upper limit on the number of samples produced:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: This generator function uses another generator as a source of items. The idea
    is that we'll use the `arrival1()` function. The `samples()` function enumerates
    the items from a larger collection and stops when enough items have been seen.
    Since the `arrival1()` function is infinite, this boundary is essential.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how we use these functions to simulate the arrival of customers. We''ll
    produce a sequence of customer ID numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: We forced the random number generator to have a specific seed value so that
    we would produce a known test sequence. We applied the `samples()` function to
    the `arrival1()` function to produce a sequence of 10 customer visits. Customer
    seven seemed to have a lot of repeat business. Customers zero and five never showed
    up at all.
  prefs: []
  type: TYPE_NORMAL
- en: This is just a simulation of data. A business would use sales receipts to determine
    customer visits. A web site might record visits in a database, or might scrape
    the web logs to determine the sequence of actual values.
  prefs: []
  type: TYPE_NORMAL
- en: What's the expected number of visits before we've seen all eight customers?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: This function creates the series of fractions 1/1, 1/2, up to 1/ *n* . These
    are summed and multiplied by *n* .
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: On an average, it will take 22 customer visits before we'll see all eight of
    our customers once.
  prefs: []
  type: TYPE_NORMAL
- en: How do we use the `set` collection to create statistics on the actual number
    of visits before we've seen all eight customers?
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we step through each customer visit, we''ll put the customer ID into a `set`
    collection. Duplicates aren''t saved in a set. Once a customer ID is a member
    of the set, adding the value again doesn''t change the set. We''ll summarize the
    steps in this recipe and then show the complete function:'
  prefs: []
  type: TYPE_NORMAL
- en: Start with an empty `set` and a zero counter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Begin a `for` loop to visit all of the data items.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the next item to the `set` . Add one to the counter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the `set` is complete, the count can be yielded. This is the number of customers
    required to see a complete set. After yielding, empty the `set` and initialize
    the counter to zero in preparation for the next customer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here''s the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: This will start a `count` at zero and create an empty set, `collection` , in
    which we'll collect customer ID's. We'll step through each item in the sequence
    of source data values, `data` . The value of `count` shows how many visitors there
    are. The value of the variable `collection` is the set of distinct visitors.
  prefs: []
  type: TYPE_NORMAL
- en: The `add()` method of a `set` will mutate the set to add a distinct value. If
    the value is already in the set, there's no change to the content.
  prefs: []
  type: TYPE_NORMAL
- en: When the size of the collection is the size of our target population, we've
    got a complete set of coupons. We can yield the value of the `count` . We also
    reset the count of visits and create a new empty set for our collection of coupons.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since this is a generator, we''ll need to capture the data by creating a `list`
    object from the results. Here''s how we''d use the `coupon_collector()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: We've computed the expected time to see all `n` customers. We've used `samples(100,
    arrival1())` as a simulation to create the `data` variable which has a sequence
    of visits. In real life, we'd analyze sales receipts to gather this sequence of
    visits.
  prefs: []
  type: TYPE_NORMAL
- en: We applied the Coupon Collector's Test to the data. This emitted a sequence
    of values that showed how many customers had to arrive to create a complete set
    of *coupons* or customer ID's. This sequence of counts should be close to the
    expected number of visits. We've assigned this sequence to the variable `wait_times`
    because we've measured the time we need to wait before seeing all of the customers
    in our sample set.
  prefs: []
  type: TYPE_NORMAL
- en: This lets us easily compare the actual data with the expected data. The function
    that we just saw, `arrival1()` , produces averages that are quite close to the
    expected values. Since the input data is random, the simulation won't produce
    values that precisely match the expectation.
  prefs: []
  type: TYPE_NORMAL
- en: The Coupon Collector's Test relies on collecting a set of coupons. In this case,
    the term **set** is used in exact mathematical formalism that best represents
    the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'A given item either is a member of a set or it is not. We can''t add it to
    the set more than once. For example, we can create a set manually and add an item
    to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: When we attempt to add this item again, the value of the `set` doesn't change.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: This is the perfect data representation for collecting coupons.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the `add()` method does not return a value. It mutates the `set` object.
    This is similar to the way methods of the `list` collection work. Generally, a
    method that mutates the collection does not return a value. The only exception
    to this pattern is the `pop()` method, which both mutates the `set` object and
    returns the popped value.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have several ways to add items to a `set` :'
  prefs: []
  type: TYPE_NORMAL
- en: The example used the `add()` method. This works with a single item.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can use the `union()` method. This is like an operator—it creates a new result
    `set` . It does not mutate either of the operand sets.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can use the `|` union operator to compute the union of two sets.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can use the `update()` method to update one set with items from another set.
    This mutates a set, and does not return a value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For most of these, we''ll need to create a singleton `set` from the item we''re
    going to add. Here''s an example of adding a single item, `3` , to a set by turning
    it into a singleton set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Here, we've created a singleton set, `{item}` from the value of the `item` variable.
    We then used the `union()` method to compute a new set that is the union of `collection`
    and `{item}` .
  prefs: []
  type: TYPE_NORMAL
- en: Note that `union()` returns a resulting object and leaves the original `collection`
    set untouched. We would need to use this as `collection = collection.union({item})`
    to update the `collection` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is yet another alternative that uses the union operator, `|` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: This parallels common mathematical notation for {1, 3} ∪ {3} ≡ {1, 3}.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use the `update()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: This method mutates the `set` object. Because it mutates the set, it does not
    return a value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python has a number of set operators. These are ordinary operator symbols that
    we can use in complex expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`|` for union, often typeset as *A* ∪ *B*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`&` for intersection, often typeset as *A* ∩ *B*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`^` for symmetric difference, often typeset as *A* Δ *B*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-` for subtraction, often typeset as *A* - *B*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the *Removing items from a set – remove, pop, and difference* recipe we'll
    look at how we can update a set by removing or replacing items
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removing items from a set – remove(), pop(), and difference
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python gives us several ways to remove items from a `set` collection. We can
    use the `remove()` method to remove a specific item. We can use the `pop()` method
    to remove an arbitrary item.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, we can compute a new set using set intersection, difference,
    and symmetric difference operators: `&` , `-` , and `^` . These will produce a
    new set which is a subset of a given input set.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes we''ll have log files that contain lines with complex and varied
    formats. Here''s a small snippet from a long, complex log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to find the `IP: 111.222.111.222` lines in the log.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how we''d do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The problem with the larger log file is that there are places where the target
    line has real information. These are mingled with lines that look similar, but
    are just examples. We''ll also find lines like `IP: 1.2.3.4` , which is irrelevant
    output. It turns out that there are several of these irrelevant kinds of lines
    that we''d like to ignore.'
  prefs: []
  type: TYPE_NORMAL
- en: This is a place where set intersection and set subtraction can be very helpful.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a set of items we''d like to ignore:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Collect all entries from the log. We''ll use the `re` module for this, as shown
    earlier. Assume we have data that includes good addresses plus dummy and placeholder
    addresses from other parts of the log:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Remove items from the set of matches using a form of set subtraction. Here
    are two examples:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Note that both of these are operators which return new sets as their results.
    Neither of these will mutate the underlying set objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll often use these in statements like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: This will assign the resulting set to a new variable, `valid_matches` , so that
    we can do the required processing on this new set.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, if the item is not present in the set, it does not raise a `KeyError`
    exception.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A `set` object only tracks membership. An item is either in the `set` or it's
    not in the `set` . We specify the item we want to remove. Removing an item doesn't
    depend on an index position or a key value.
  prefs: []
  type: TYPE_NORMAL
- en: Because we have `set` operators, we can remove any of the items in one `set`
    from a target `set` . We don't need to process the items individually.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have several ways to remove items from a set:'
  prefs: []
  type: TYPE_NORMAL
- en: In the example, we used the `difference()` method and the `-` operator. The
    `difference()` method behaves like an operator and creates a new set.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can also use the `difference_update()` method. This will mutate a set in
    place. It does not return a value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can remove an individual item with the `remove()` method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can also remove an arbitrary item with the `pop()` method. This doesn't apply
    to this example very well because we can't control which item is popped.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s how the `difference_update()` method looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: First, we made a copy of the original `matches` set. This created a new set
    that we assigned the `valid_matches` set. We then applied the `difference_update()`
    method to remove the undesirable items from this set.
  prefs: []
  type: TYPE_NORMAL
- en: Since the set was mutated, no value is returned. Also, since the set is a copy,
    this doesn't modify the original `matches` set.
  prefs: []
  type: TYPE_NORMAL
- en: We could do something like this to use the `remove()` method. Note that `remove()`
    will raise an exception if an item is not present in the set.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: We tested to see if the item was in the `valid_matches` set before attempting
    to remove it. This is one way to avoid the raising a `KeyError` exception. The
    alternative is to use a `try:` statement to silence the exception.
  prefs: []
  type: TYPE_NORMAL
- en: The `pop()` method removes an arbitrary item. It both mutates the set and returns
    the item which was removed. If we try to pop items from an empty set, we'll raise
    a `KeyError` exception.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the *Using set methods and operators* recipe we'll look at other ways to
    create sets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](image/614271.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Creating dictionaries – inserting and updating
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A dictionary is one kind of Python mapping. The built-in type `dict` class provides
    a number of common features. There are some common variations on these features
    defined in the `collections` module.
  prefs: []
  type: TYPE_NORMAL
- en: As we noted in the *Choosing a data structure* recipe, we'll use a dictionary
    when we have some key that we need to map to a given value. For example, we might
    want to map a single word to a long, complex definition of the word. Or perhaps
    some value to a count of the number of times that value has occurred in a dataset.
  prefs: []
  type: TYPE_NORMAL
- en: The *key and count* dictionary is very common. We'll look at a detailed recipe
    that shows how to initialize the dictionary and update the counter.
  prefs: []
  type: TYPE_NORMAL
- en: In the *Using set methods and operators* recipe we looked at the arrival of
    customers at a business. In that recipe, we used a set to determine how many visits
    were required before the business had collected a complete set of visits.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we'll look at creating a histogram that shows how many times
    each customer visited. In order to create some interesting data, we'll modify
    the sample generator that was used in the other recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the earlier example, we used a simple, uniform random number generator to
    pick the sequence of customers. This is an alternative way to pick customers that
    generates random numbers with a slightly different distribution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: This uses a technique called **random walk** to generate the next customer ID
    number. It will start with zero and then make one of three changes. It may use
    the same customer or one of the two adjacent customer numbers. Using the expression
    `abs(p) % n` allows us to compute any integer value and map the number, *p* ,
    to the range 0 ≤ *p* < *n* .
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a tool to generate some data that we can use to simulate the arrival
    of customers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: This shows us how the `arrival2()` function simulates customers who tend to
    cluster around the starting value of customer zero. If we use this for the Coupon
    Collector's Test in the *Using set methods and operators* recipe, we'll see that
    this generator creates sample data that fails that test spectacularly. The clumpy
    arrival times mean we have to see an extraordinary number of customers before
    we've collected all eight distinct customers.
  prefs: []
  type: TYPE_NORMAL
- en: A histogram counts the number of occurrences of each customer. We'll use a dictionary
    to map from customer ID to the number of times we've seen the customer.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create an empty dictionary with `{}` . We can also use `dict()` to create an
    empty dictionary. Since we''re going to create a histogram that counts the number
    of times each customer arrived, we''ll call it `histogram` :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: For each customer number, if it's new, add an empty list to the dictionary.
    We can do this with an `if` statement or we can use the `setdefault()` method
    of the dictionary. We'll show the `if` statement version first. Later, we'll look
    at the `setdefault()` optimization.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Increment the value in the dictionary.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here''s the resulting loop to count occurrences in a dictionary. It works by
    creating and updating items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: When this is done, we'll have a count of the total number of simulated visits
    from each customer.
  prefs: []
  type: TYPE_NORMAL
- en: We can turn this into a handy bar chart to compare the frequencies. We can compute
    some basic descriptive statistics including the mean and standard deviation to
    see if any customer is over-represented or under-represented.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The core feature of a dictionary is a mapping from an immutable value to an
    object of any kind. In this case, we've used an immutable number as the key, and
    another number as the value. As we count, we replace the value associated with
    the key.
  prefs: []
  type: TYPE_NORMAL
- en: 'It can seem a little unusual to write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Or to write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: and think of the value in the dictionary as being *replaced* . When we write
    an expression like `histogram[customer] + 1` we're computing a new integer object
    from two other integer objects. This new object replaces the old value in the
    dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: It's essential that dictionary key objects be immutable. We cannot use a `list`
    , `set` , or `dict` as the key in a dictionary mapping. We can, however, transform
    a list into an immutable tuple, or make a `set` into a `frozenset` so that we
    can use one of these more complex objects as a key.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We don''t have to use an `if` statement to add missing keys. We can use the
    `setdefault()` method of a dictionary, instead. Our loop would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: If the key value, `customer` , doesn't exist, a default value is provided. If
    the key does exist, the `setdefault()` method does nothing.
  prefs: []
  type: TYPE_NORMAL
- en: The `collections` module provides a number of alternative mappings that we can
    use instead of the default `dict` mapping.
  prefs: []
  type: TYPE_NORMAL
- en: '`defaultdict` : This collection saves us from having to write step two explicitly.
    We provide an initialization function as part of creating a `defaultdict` . We''ll
    look at an example soon.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OrderedDict` : This collection retains the keys in the order they were initially
    created. We''ll save this for the *Controlling the order of dict keys* recipe.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Counter` : This collection does the entire **key-and-count** algorithm as
    it is being created. We''ll look at this soon too.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s the version using the `defaultdict` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: We've created a `defaultdict` instance that will initialize any unknown key
    values using the `int()` function. We provide `int` —the function object—to the
    `defaultdict` constructor. The `defaultdict` will evaluate the given function
    object to create default values.
  prefs: []
  type: TYPE_NORMAL
- en: This allows us to simply use `histogram[item] += 1` . If the value of the `item`
    attribute was previous in the dictionary, it will be incremented. If the value
    of the `item` attribute was not already in the dictionary, the `int` function
    is evaluated and that becomes the default value.
  prefs: []
  type: TYPE_NORMAL
- en: The other way we can do this is by creating a `Counter` object. We need to import
    the `Counter` class so that we can build the `Counter` object from the raw data.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: When we create a `Counter` from a source of data, the class will scan the data
    and count the distinct occurrences. This class implements the entire recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how the result looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Note that a `Counter` object displays the values in descending order of count
    value. An `OrderedDict` object will display the values in the order in which the
    keys were created. A `dict` maintains no order.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to impose an order on the keys, we can use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the *Removing from dictionaries – the pop() method and the del statement*
    recipe we'll look at how dictionaries can be modified by removing items
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the *Controlling the order of dict keys* recipe we'll look at how we can
    control the order of keys in a dictionary
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removing from dictionaries – the pop() method and the del statement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A common use case for a dictionary is as an **associative store** : we can
    keep an association between key and value objects. This means that we may be doing
    any of the **CRUD** operations on an item in the dictionary.'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new key and value pair
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retrieve the value associated with a key
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update the value associated with a key
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delete the key (and value) from the dictionary
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We have two common variations on this theme:'
  prefs: []
  type: TYPE_NORMAL
- en: We have the in-memory dictionary, `dict` , and the variations on this theme
    in the `collections` module. The collection only exists while our program is running.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We also have persistent storage in the `shelve` and `dbm` modules. The data
    collection is a persistent file in the file system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are very similar, the distinctions between a `shelf.Shelf` and `dict`
    object are minor. This allows us to experiment with a `dict` and switch to a `Shelf`
    without making dramatic changes to a program.
  prefs: []
  type: TYPE_NORMAL
- en: A server process will often have multiple, concurrent sessions. When sessions
    are created, they can be placed into `dict` or `shelf` . When the session exits,
    the item can be deleted or perhaps archived.
  prefs: []
  type: TYPE_NORMAL
- en: We'll simulate this concept of a service that handles multiple requests. We'll
    define a service that works in a simulated environment with a single processing
    thread. We'll avoid concurrency and multi-processing considerations.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the casino game of *Craps* , a player can (and often does) create and remove
    multiple bets during a game. The rules can be bafflingly complex, but the core
    concepts include four kinds of bets a player might make:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A **pass line** bet: For our purposes, this is how one buys in at the start
    of a game.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A **pass line odds** bet: This is not marked on the playing surface in a casino,
    but it''s a real bet. This bet pays off at different odds than the pass line bet,
    and has some statistical advantages. It can be removed, also.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A **come line** bet: This can be placed during a game.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A **come line odds** bet: This, too, is placed during a game. This can be taken
    down, also.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The best way to understand all of these betting choices is to simulate the game
    and a player. The game will need to track all of the bets a player places. This
    can be done using a dictionary where bets are inserted, and removed when they
    pay off, the player takes them down, or the game ends.
  prefs: []
  type: TYPE_NORMAL
- en: We'll simplify parts of the simulation so that we can focus on using a dictionary
    properly. This is handled best as a class definition so that we can properly isolate
    bets and game rules from player rules. For more information on class design, see
    [Chapter 6](text00070.html#page "Chapter 6. Basics of Classes and Objects") ,
    *Basics of Classes and Objects* .
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create the overall dictionary object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the key and value for each object we''re inserting into the dictionary.
    For example, the key might be a description of the bet: `come` , `pass` , `come
    odds` , or `pass odds` . The value might be the amount of the bet. It''s common
    to avoid working in currency, and instead work in units of the table minimum bet.
    Usually these are simple integer multiples, most often just the integer value
    one to represent the minimum bet.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter values as the bets are being placed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: For a concrete example, we'd have `working_bets["pass"] = 1` .
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove values as bets are paid off or taken down. We can use the `del` statement
    or the dictionary `pop()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: If the key is not present, this will raise a `KeyError` exception.
  prefs: []
  type: TYPE_NORMAL
- en: The `pop()` method both mutates the dictionary and returns a value associated
    with the key. If the key doesn't exist, this will raise an `KeyError` exception.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: It turns out that `pop()` can be given a default value. If the key is not present,
    it will not raise an exception, but will return the default value instead.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Because a dictionary is a mutable object, we can remove keys from a dictionary.
    This will delete both the key and the value object associated with the key.
  prefs: []
  type: TYPE_NORMAL
- en: If we try to delete a key which does not exist, we'll raise a `KeyError` exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can replace an object in a dictionary with statements like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: The key—`come` —remains in the dictionary. The old value, `1` , is no longer
    required and will be replaced by the new value, `None` . This is not the same
    as deleting an item.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can only remove the keys of a dictionary. As we noted earlier, we can set
    the value to `None` to remove the value, leaving the key in the dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we use a dictionary in a `for` statement, the target variable will be
    assigned key values. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: This will print all of the key values, `bet_name,` and the bet amount associated
    with that bet in the `working_bets` dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the *Creating dictionaries – inserting and updating* recipe we'll look at
    how we create dictionaries and fill them with keys and values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the *Controlling the order of dict keys* recipe we'll look at how we can
    control the order of keys in a dictionary
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling the order of dict keys
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the *Creating dictionaries – inserting and updating* recipe we looked at
    the basics of creating a dictionary object. In many cases, we'll put items into
    a dictionary and fetch items from a dictionary individually. The idea of an order
    to the keys doesn't even enter into the problem.
  prefs: []
  type: TYPE_NORMAL
- en: There are some cases where we might want to display the contents of a dictionary.
    In this case, we often want to impose some order on the keys. For example, when
    we work with web services, the messages are often dictionaries encoded in JSON
    notation. In many cases we'd like to keep the keys in a particular order so that
    the message is easier to understand when it's displayed in a debugging log.
  prefs: []
  type: TYPE_NORMAL
- en: As another example, when we read data with the `csv` module each row from a
    spreadsheet can be represented as a dictionary. In this case, we almost always
    want to keep the keys in a given order so that the dictionary follows the structure
    of the source file.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A dictionary is a good model for a row from a spreadsheet. This works particularly
    well when the spreadsheet has a heading row with column titles. Let''s say we
    have some data collected in a spreadsheet that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **final** | **least** | **most** |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | 0 | 6 |'
  prefs: []
  type: TYPE_TB
- en: '| -3 | -4 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| -1 | -3 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | 0 | 4 |'
  prefs: []
  type: TYPE_TB
- en: 'This shows the final outcome, the lowest amount the player had, and the highest
    amount the player had. We can use the `csv` module to read this data for further
    analysis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Each row of the spreadsheet is a dictionary. However, there's something peculiar
    about each row. It's not obvious, but the order of the keys in the row doesn't
    match the order of the keys in the original `.csv` file.
  prefs: []
  type: TYPE_NORMAL
- en: Why is that? The default `dict` structure does not guarantee any ordering for
    the keys. What if we want to show the keys in a specific order?
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have two common ways to force an ordering on the keys of a dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an `OrderedDict` : This keeps keys in the order they are created'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Use `sorted()` on the keys: This puts the keys into a sorted order'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most of the time, we can simply use `OrderedDict` instead of `dict()` or `{}`
    to create an empty dictionary. This will allow us to create keys in the required
    order.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, however, we can't easily replace a `dict` instance with an `OrderedDict`
    instance. We've chosen this example because we can't trivially replace the `dict`
    class that is created by `csv` .
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how we can force the row''s `dict` keys to follow the order of the
    columns in the original `.csv` file:'
  prefs: []
  type: TYPE_NORMAL
- en: Get the preferred order of keys. In the case of a `DictReader` the `fieldnames`
    attribute of the reader object has the proper order information.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use a generator expression to create the fields in the proper order. We''ll
    have something like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an `OrderedDict` from the generator. Here''s the whole sequence:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: This builds dictionaries with keys in a specific order.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an optimization, we can combine the two steps into a single step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: This will build an ordered version of the `raw_row` object.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `OrderedDict` class keeps the keys in the order they are created. This class
    is very handy for assuring a structure remains in an order that's easier to understand.
  prefs: []
  type: TYPE_NORMAL
- en: There's a small performance cost to this, of course. The default `dict` class
    computes a hash for each key, and the hash values are used to locate a space in
    the dictionary. This tends to use more memory, but performs extremely quickly.
  prefs: []
  type: TYPE_NORMAL
- en: The `OrderedDict` uses some additional storage to retain the ordering for the
    keys. This requires some additional time when a key is created. If key creation
    tends to dominate the algorithm, we'll notice the slowdown. If key retrieval tends
    to dominate the design, then we won't see much change when using an `OrderedDict`
    .
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In some packages—like `pymongo` —there are some alternative ordered dictionary
    implementations.
  prefs: []
  type: TYPE_NORMAL
- en: See [https://api.mongodb.org/python/current/api/bson/son.html](https://api.mongodb.org/python/current/api/bson/son.html)
    .
  prefs: []
  type: TYPE_NORMAL
- en: The `bson.son` module includes the `SON` class which is a very handy ordered
    dictionary. This is focused on the needs of the Mongo database, but it works very
    nicely for other applications, also.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the *Creating dictionaries – inserting and updating* recipe we'll look at
    how we can create dictionaries.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the *Removing from dictionaries – the pop() method and the del statement*
    recipe we'll look at how dictionaries can be modified by removing items.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling dictionaries and sets in doctest examples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will look at one small aspect of writing a proper test in this recipe. We'll
    look at testing overall in [Chapter 11](text00120.html#page "Chapter 11. Testing")
    , *Testing* . The data structures in this chapter—`dict` and `set` —both include
    some complexity when it comes to writing proper tests.
  prefs: []
  type: TYPE_NORMAL
- en: Since `dict` keys (and `set` members) have no order, our test results will have
    a problem. We need to have a repeatable result, but there's no way to guarantee
    the order of the collection. This can lead to test results which don't properly
    match our expectations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assume that our test expects the set `{"Poe", "E", "Near", "A", "Raven"}` .
    Since there''s no defined order to a set, Python can display this set in any order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: The elements are the same, but the overall line of output from Python isn't
    the same. The `doctest` package relies on the literal output from the example
    being *identical* to the output produced by Python's REPL.
  prefs: []
  type: TYPE_NORMAL
- en: How can we be sure our doctest examples really work?
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s look at an example that involves a `set` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: This example is simple. The results, however, will often vary each time we process
    this example. Indeed, when working on secure algorithms, it's considered important
    to have the order vary. This is called the **hash randomization** problem—when
    the hashed values are predictable, it can become a security vulnerability.
  prefs: []
  type: TYPE_NORMAL
- en: When we use the `doctest` module, we need to have examples that are perfectly
    consistent. As we'll see in [Chapter 11](text00120.html#page "Chapter 11. Testing")
    , *Testing* , the `doctest` module is clever about locating examples, but it's
    not a genius about assuring that actual results match expected results.
  prefs: []
  type: TYPE_NORMAL
- en: And the problem is—mostly—confined to sets and dictionaries. These are two collections
    where key ordering cannot be guaranteed because of hash randomization.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we need to be sure that items in a set or dictionary have a particular
    order, we can convert the collection to a sorted sequence.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have two choices:'
  prefs: []
  type: TYPE_NORMAL
- en: Convert a set to a sorted sequence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Convert a dictionary to a sorted sequence of (key, value) two-tuples
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Both of these recipes are similar. Here''s what we need to do to force a set
    into a normalized structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'For a dictionary, we''ll often use this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: This will extract each item in the dictionary as a `(key, value)` two-tuple.
    The tuples will be sorted into order by the key. The resulting sequence will be
    turned into a list so that it can be compared with the expected results.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When confronted with a collection that fails to impose an order, we have to
    locate a collection with two properties:'
  prefs: []
  type: TYPE_NORMAL
- en: The same content
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some kind of consistent order
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Python''s built-in structures are variations on three themes:'
  prefs: []
  type: TYPE_NORMAL
- en: Sequence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mapping
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since the only one with a guaranteed order is the sequence, we can convert sets
    and mappings into sequences. This, it turns out, is easy to do with the `sorted()`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: For sets, we'll sort the items. For mappings, we'll sort the `(key, value)`
    two-tuples. This assures us that the output from our example is precisely what
    is required.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ll look at several other kinds of data that has minor variations in [Chapter
    11](text00120.html#page "Chapter 11. Testing") , *Testing* :'
  prefs: []
  type: TYPE_NORMAL
- en: Floating-point numbers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Object ID's and Tracebacks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Random sequences
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of these need to be put into a context with a predictable output so that
    tests will work repeatedly. The two data structures, `set` and `dict` , are the
    subjects of this chapter. We'll cover other variations in the relevant chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding variables, references, and assignment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How do variables really work? What happens when we assign a mutable object to
    two variables? We can easily have two variables that share references to a common
    object; this can lead to potentially confusing results when the shared object
    is mutable. The rules are simple and the consequences are generally obvious.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll focus on this rule: **Python shares references. It doesn''t copy data**
    .'
  prefs: []
  type: TYPE_NORMAL
- en: We need to look at what this rule on reference sharing means.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll create two data structures, one is mutable and one is immutable. We''ll
    use two kinds of sequences, although we could do something similar with two kinds
    of sets:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Getting ready We''ll create two data structures, one is mutable and one is
    immutable. We''ll use two kinds of sequences, although we could do something similar
    with two kinds of sets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: The mutable data structure can be changed and shared. The immutable data structure
    is also shared, but it's much harder to tell that it's being shared.
  prefs: []
  type: TYPE_NORMAL
- en: We can't easily do this with a mapping because Python doesn't offer a handy
    immutable mapping.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Assign each collection to an additional variable. This will create two references
    to the structure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: we now have two references to the list `[1, 1, 2, 3, 5, 8]` and two references
    to the tuple `(5, 8, 13, 21)` .
  prefs: []
  type: TYPE_NORMAL
- en: 'We can confirm this using the `is` operator. This determines if two variables
    refer to the same underlying object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Make a change to one of the two references to the collection. For mutable structures,
    we have methods like `append()` or `add()` :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: For a list structure, the `+=` assignment is really an internal use of the `extend()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do a similar thing with an immutable structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: Since a tuple has no method like `extend()` , the += will build a new tuple
    object and replace the value of `immutable` with that new object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at the other reference to the structure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: The two variables `mutable` and `mutable_b` refer to the same underlying object.
    Because of that, we can use either variable to change the object and see the change
    reflected in the other variable's value.
  prefs: []
  type: TYPE_NORMAL
- en: The two variables, `immutable_b` and `immutable,` started out referring to the
    same object. Because the object cannot be mutated in place, a change to one variable
    means that a new object is assigned to that variable. The other variable remains
    firmly attached to the original object.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Python, a variable is a label that's attached to an object. We can think
    of them like adhesive notes in bright colors that we stick on the object temporarily.
  prefs: []
  type: TYPE_NORMAL
- en: A variable is a reference to the underlying object. When we assign an object
    to a variable, we're giving a name to a reference to the underlying object. When
    we use a variable in an expression, Python locates the object to which the variable
    refers.
  prefs: []
  type: TYPE_NORMAL
- en: For mutable objects, a method of an object can modify the object's state. All
    variables that refer to the object will reflect the state change because a variable
    is just a reference, not a complete copy.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we use a variable on an assignment statement there are two possible actions:'
  prefs: []
  type: TYPE_NORMAL
- en: For mutable objects that provide definitions for appropriate assignment operators
    like `+=` , the assignment is transformed into a special method; in this case,
    `__iadd__` . The special method will mutate the object's internal state.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For immutable objects that do not provide definitions for assignment like `+=`
    , the assignment is transformed into `=` and `+` . A new object is built by the
    `+` operator and the variable name is attached to that new object. Other variables
    which previously referred to the object being replaced are not affected, they
    continue to refer to old objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python tracks the number of places that an object is referenced. When the number
    of references becomes zero, the object is no longer used anywhere, and can be
    removed from memory.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Languages like C++ or Java have primitive types in addition to objects. In these
    languages, a `+=` statement leverages a feature of the hardware instructions or
    the Java Virtual Machine to tweak the value of a primitive type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python doesn''t have this kind of optimization. Numbers are immutable objects.
    When we do something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re not tweaking the internal state of the object `355` . This does not
    rely on the internal `__iadd__` special method. This behaves as if we had written:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: The expression `a + 113` is evaluated, and a new immutable integer object is
    created. This new object is given the label `a` . The old value previously assigned
    to `a` is no longer needed.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the *Making shallow and deep copies of objects* recipe we'll look at ways
    we can copy mutable structures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making shallow and deep copies of objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Throughout this chapter, we''ve talked about how assignment statements share
    references to objects. Objects are not normally copied. When we write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: we now have two references to the same underlying object. If `b` is a list,
    both `a` and `b` are references to the same, mutable list.
  prefs: []
  type: TYPE_NORMAL
- en: As we saw in the *Understanding variables, references, and assignment* recipe,
    a change to the `a` variable changes the list object that both `a` and `b` refer
    to.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the time, this is the behavior we want. There are rare situations in
    which we want to actually have two independent objects created from one original
    object.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to break the connection that exists when two variables are
    references to the same underlying object:'
  prefs: []
  type: TYPE_NORMAL
- en: Making a shallow copy of the structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making a deep copy of the structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have to make special arrangements to make a copy of an object. We've seen
    several kinds of syntax for doing that.
  prefs: []
  type: TYPE_NORMAL
- en: '**Sequences** – `list` and `tuple` : We can use `sequence[:]` to copy a sequence
    by using an empty slice expression. We can also use `sequence.copy()` to make
    a copy of a variable named `sequence` .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mappings** – `dict` : We can use `mapping.copy()` to copy a dictionary named
    `mapping` .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sets** – `set` and `frozenset` : We can use `someset.copy()` to clone a set
    named `someset` .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What's important is that these are all *shallow* copies.
  prefs: []
  type: TYPE_NORMAL
- en: Shallow means that two collections will contain references to the same underlying
    objects. If the underlying objects are immutable numbers or strings, this distinction
    doesn't matter. When we can't mutate items inside the collection, the items are
    simply replaced.
  prefs: []
  type: TYPE_NORMAL
- en: If we have `a = [1, 1, 2, 3]` , we can't perform any mutation on `a[0]` . The
    number `1` in `a[0]` has no internal state. We can only replace the object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Questions arise, however, when we have a collection that involves mutable objects.
    First, we''ll create an object, then we''ll create a copy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: We have to make a shallow copy of the dictionary. The two copies look alike
    because they both contain references to the same objects. There's a shared reference
    to the immutable string `a` . And a shared reference to the mutable list `[1,
    1, 2, 3]` . We can display the value of `another_dict` to see that it looks like
    `some_dict` .
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s what happens when we update the shared list that''s inside the copy
    of the dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: We made a change to a mutable `list` object that's shared between two `dict`
    objects, `some_dict` and `another_dict` .
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see that the item is shared by using the `id()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: Because the two `id()` values are the same, these are the same underlying object.
    The value associated with the key `a` is the same mutable list in both `some_dict`
    and `another_dict` . We can also use the `is` operator to see that they're the
    same object.
  prefs: []
  type: TYPE_NORMAL
- en: 'This mutation effect works for `list` collections that contain other `list`
    objects as items, also:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: We've made a copy of an object, `some_list` , and assigned it to the variable
    `another_list` . The top-level `list` object is distinct, but the items within
    the `list` are shared references. We used the `is` operator to show that item
    zero in each list are both references to the same underlying objects.
  prefs: []
  type: TYPE_NORMAL
- en: Because we can't make a `set` of mutable objects, we don't really have to consider
    making shallow copies of sets which share items.
  prefs: []
  type: TYPE_NORMAL
- en: What if we want to completely disconnect two copies? How do we make a deep copy
    instead of a shallow copy?
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Python generally works by sharing references. It only makes copies of objects
    reluctantly. The default behavior is to make a shallow copy, sharing references
    to the items within a collection. Here''s how we make deep copies:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the `copy` library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `copy.deepcopy()` function to duplicate an object and all of the mutable
    items contained within that object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'This will create copies that have no shared references. A change to one copy''s
    mutable internal items won''t have any effect anywhere else:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'We updated an item in `some_dict` and it had no effect on the copy in `another_dict`
    . We can see that the objects are distinct with the `id()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: Since the `id()` values are different, these are distinct objects. We can also
    use the `is` operator too see that they're distinct objects.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Making a shallow copy is relatively easy. We can write our own version of the
    algorithm using generator expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: In the `list` case, the items for the new `list` are references to the items
    in the source list. Similarly, in the `dict` case, the keys and values are references
    to the keys and values of the source dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: The `deepcopy()` function uses a recursive algorithm to look inside each mutable
    collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a `list` the conceptual algorithm is something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: The actual code doesn't look like this, of course. It's a bit more clever in
    the way it handles each distinct Python type. This does, however, provide some
    hints as to how the `deepcopy()` function works.
  prefs: []
  type: TYPE_NORMAL
- en: It turns out that there are some additional considerations. The most import
    consideration is an object which contains a reference to itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: This is a confusing, but technically valid, Python construct. It will lead to
    problems when attempting to write a naïve recursive operation to visit all items
    in the list. In order to overcome this, an internal cache is used so that items
    are only copied once. After that, an internal reference can be found in the cache.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the *Understanding variables, references, and assignment* recipe we'll look
    at how Python prefers to create references to objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoiding mutable default values for function parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 3](text00039.html#page "Chapter 3. Function Definitions") , *Function
    Definitions* , we looked at many aspects of Python function definitions. In the
    *Designing functions with optional parameters* recipe we showed a recipe for handling
    optional parameters. At the time, we didn't dwell on the issue of providing a
    reference to a mutable structure as a default. We'll take a close look at the
    consequences of a mutable default value for a function parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's imagine a function that either creates or updates a mutable `Counter`
    object. We'll call it `gather_stats()` .
  prefs: []
  type: TYPE_NORMAL
- en: 'Ideally, it could look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'This shows a *bad* design for a function with two stories. The first story
    offers no argument collection. The function creates and returns a collection of
    statistics. Here''s the example of this story:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'The second story allows us to provide an explicit parameter value so that the
    statistics update a given object. Here''s an example of this story:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: We've set the random number seed to be sure that the two sequences of random
    values are identical. This makes it easy to confirm that the results are the same
    if we provide a `Counter` object or use the default `Counter` object. In the second
    example, we provided an explicit `Counter` object, named `mc` to the function.
  prefs: []
  type: TYPE_NORMAL
- en: The `gather_stats()` function returns a value. When writing a script, we'd simply
    ignore the returned value. When working Python's interactive REPL the output is
    printed. We've shown `Counter...` instead of the lengthy output.
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem arises when we do the following operation after doing the preceding
    two operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: Note that the counts are doubled. Something has gone wrong. Since this only
    happens when we use the default story more than once, it may pass a unit test
    suite and appear correct.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we saw in the *Making shallow and deep copies of objects* recipe, Python
    prefers to share references. A consequence of that sharing is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: This means that two variables, `s1` and `s2` , are both references to the same
    underlying object. It appears that we've updated some shared collection.
  prefs: []
  type: TYPE_NORMAL
- en: Does that mean the value of `s1` changed?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: Yes, the default use of this `gather_stats()` function seems to be sharing a
    single object. How can we avoid this?
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two approaches to solving this problem:'
  prefs: []
  type: TYPE_NORMAL
- en: Provide an immutable default
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Change the design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll look at the immutable default first. Changing the design is generally
    a better idea. In order to see why it's better to change the design, we'll show
    the purely technical solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we provide default values for functions, the default object is created
    exactly once and shared forever after. Here''s the alternative:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Replace any mutable default parameter value with `None` :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'Add an `if` statement to check for an argument value of `None` and replace
    it with a fresh, new mutable object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: This will assure us that every time the function is evaluated with no argument
    value for a parameter, we create a fresh, new mutable object. We will avoid sharing
    a single mutable object over and over again.
  prefs: []
  type: TYPE_NORMAL
- en: There are very few good reasons for providing a mutable object as a default
    value to a function. In most cases, we should consider changing the design, and
    not using a mutable object as a default value for a parameter. In the rare case
    where we really do have a complex algorithm which can update an object or create
    a fresh new object, we should consider defining two separate functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''d refactor this function to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: We've created two separate functions. This will separate the two stories so
    that there's no confusion. The idea of optional mutable arguments is not a good
    idea in the first place.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we noted earlier, Python prefers to share references. It rarely creates copies
    of objects. Therefore, default values for function parameter values will be shared
    objects. Python doesn't easily create fresh, new objects.
  prefs: []
  type: TYPE_NORMAL
- en: The rule is very important and often confuses programmers new to Python.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Don't use mutable defaults for functions.
  prefs: []
  type: TYPE_NORMAL
- en: A mutable object (`set` , `list` , `dict` ) should not be a default value for
    a function parameter.
  prefs: []
  type: TYPE_NORMAL
- en: This rule applies to the core language. It doesn't apply throughout the standard
    library, however. There are cases where there are some clever alternative approaches.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the standard library, there are some examples of a cool technique that shows
    how we can create fresh default objects. One widely-used example is in the `defaultdict`
    collection. When we create a `defaultdict` we provide a no-argument function that
    will be used to create new dictionary entries.
  prefs: []
  type: TYPE_NORMAL
- en: When a key is missing from the dictionary, the given function is evaluated to
    compute a fresh default value. In the case of `defaultdict(int)` we're using the
    `int()` function to create an immutable object. As we've seen, a default value
    of an immutable object doesn't cause any problems because the immutable object
    has no internal state.
  prefs: []
  type: TYPE_NORMAL
- en: When we do `defaultdict(list)` or `defaultdict(set)` we see the real power of
    this design pattern. When a key is missing, a fresh, empty `list` (or `set` )
    is created.
  prefs: []
  type: TYPE_NORMAL
- en: The evaluate-a-function pattern used by `defaultdict` does not apply to the
    way functions themselves operate. Most of the time the default values we provide
    for function parameters are immutable objects like numbers, strings, or tuples.
    Having to wrap an immutable object with a `lambda` is certainly possible, but
    irksome because it's such a common case.
  prefs: []
  type: TYPE_NORMAL
- en: In order to leverage this technique, we need to modify the design of our example
    function. We will no longer update an existing counter object in the function.
    We'll always create a fresh, new object. We can modify what class of object is
    created.
  prefs: []
  type: TYPE_NORMAL
- en: Here's a function that allows us to plug in a different class in the case where
    we don't want the default `Counter` class to be used.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: For this version, we've defined an initialization value to be a function of
    one argument. The default will apply this one-argument function to a generator
    function for the random samples. We can override this function with another one-argument
    function that will collect data. This will build a fresh object using any kind
    of object that can gather data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example using `list()` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we provided the `list()` function to create a list with the individual
    random samples in it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example without an argument value. It will create a `Counter` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we've used the default value. The function created a `Counter()`
    object from the random samples.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See the *Creating dictionaries – inserting and updating* recipe, which shows
    how `defaultdict` works
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
