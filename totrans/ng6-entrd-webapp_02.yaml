- en: Create a Local Weather Web Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will be designing and building a simple Local Weather app
    with Angular and a third-party web API, using an iterative development methodology.
    You will focus on delivering value first, while learning about the nuances and
    optimal ways of using Angular, TypeScript, Visual Studio Code, Reactive Programming,
    and RxJS. Before we dive into coding, we will go over the philosophy behind Angular
    and ensure that your development environment is optimized and can enable collaboration
    and effortless information radiation.
  prefs: []
  type: TYPE_NORMAL
- en: Each section of this chapter will introduce you to new concepts, best practices,
    and optimal ways of leveraging these technologies and cover the bases to close
    any knowledge gaps you may have about web and modern JavaScript development basics.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn Angular fundamentals to build a simple web app
    and become familiar with the new Angular platform and full-stack architecture.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Get introduced to Angular and the philosophy behind it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring a repository with an optimal folder structure for full-stack development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Angular CLI to generate your Angular web application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimizing Visual Code for Angular & TypeScript development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Planning out your roadmap using Waffle as a GitHub-connected Kanban board
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Crafting a new UI element to display current weather information using components
    and interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Angular Services and HttpClient to retrieve data from OpenWeatherMap APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leveraging observable streams to transform data using RxJS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code samples provided in this book require Angular version 5 and 6\. Angular
    5 code is runtime compatible with Angular 6\. Angular 6 will be supported in LTS
    until October 2019\. The most up-to-date versions of the code repositories may
    be found at the following:'
  prefs: []
  type: TYPE_NORMAL
- en: For Chapters 2 to 6, LocalCast Weather, at: [Github.com/duluca/local-weather-app](https://github.com/duluca/local-weather-app)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For Chapters 7 to 12, LemonMart, at: [Github.com/duluca/lemon-mart](https://github.com/duluca/lemon-mart)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to Angular
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Angular is an open source project maintained by Google and a community of developers.
    The new Angular platform is vastly different from the legacy framework you may
    have used in the past. A collaboration with Microsoft makes TypeScript, which
    is a superset of JavaScript, the default development language, enabling developers
    to target legacy browsers such as Internet Explorer 11, while writing modern JavaScript
    code that is supported in evergreen browsers such as Chrome, Firefox, and Edge.
    The legacy versions of Angular, versions in the 1.x.x range, are now referred
    to as AngularJS. Version 2.0.0 and higher versions are simply called Angular. Where
    AngularJS is a monolithic JavaScript **Single Page Application** (**SPA**) framework,
    Angular is a platform that is capable of targeting browsers, hybrid-mobile frameworks,
    desktop applications, and server-side rendered views.
  prefs: []
  type: TYPE_NORMAL
- en: Each minor version increment in AngularJS meant risky updates with costly deprecations and
    major new features delivered at uncertain intervals. This led to an unpredictable,
    ever evolving framework with seemingly no guiding hand to carry code bases forward.
    If you used AngularJS, you likely got stuck on a particular version, because the
    specific architecture of your code base made it very difficult to move to a new
    version. In the spring/summer of 2018, the last major update to AngularJS will
    be released with version 1.7\. This release will mark the beginning of the end
    for the legacy framework, with a planned end-of-life in July 2021.
  prefs: []
  type: TYPE_NORMAL
- en: 'Angular improves upon AngularJS in every way imaginable. The platform follows
    semver, as defined at [https://semver.org/](https://semver.org/), where minor
    version increments denote new feature additions and potential deprecation notices
    for the second next major version, but no breaking changes. Furthermore, the Angular
    team at Google has committed to a deterministic release schedule for major version
    increments to be released every 6 months. After this 6-month development window,
    starting with Angular 4, all major releases receive **long-term support** (**LTS**)
    with bug fixes and security patches for an additional 12 months. From release
    to end-of-life, each major version is supported for 18 months. Refer to the following
    chart for the tentative release and support schedule for AngularJS and Angular:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/bbf1891b-b82c-4980-81fb-98864e5e4312.png)Tentative Angular Release
    and Support Schedule'
  prefs: []
  type: TYPE_NORMAL
- en: So, what does this mean for you? You can be confident that the code you write
    in Angular will be supported and backwards compatible for an approximate time
    frame of 24 months, even if you make no changes to it. So, if you wrote an Angular
    app in version 4 in April 2017, your code is now runtime compatible with Angular
    5, which itself is supported until April 2019\. In order to upgrade your Angular
    4 code to Angular 6, you will need to ensure that you're not using any of the
    deprecated APIs that were announced as deprecated in Angular 5\. In reality, the
    deprecations are minor and unless you are working with low-level APIs for a highly
    specialized user experience, the time and effort it takes to update your code
    base should be minimal. However, this is a promise made by Google and not a contract.
    The Angular team has a major incentive to ensure backwards compatibility, because
    Google runs around 600+ Angular apps with a single version of Angular active at
    any one time throughout the organization. This means, by the time you read this,
    all of those 600+ apps will be running in Angular 6\. You may think Google has
    infinite resources to make this happen, but like any other organization, they
    too have limited resources and not every app is actively maintained with a dedicated
    team. This means the Angular team must ensure compatibility through automated
    tests and make it as painless as possible to move through major releases going
    forward. In Angular 6, the update process was made much easier with the introduction
    of `ng update`. In the future, the team will release automated CLI tools to make
    upgrades of deprecated functionality a reasonable endeavor.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is great news for developers and organizations alike. Now, instead of
    being perpetually stuck on a legacy version of Angular, you can actually plan
    and allocate the necessary resources to keep moving your application to the future
    without costly rewrites. As I wrote in a 2017 blog post, *The Best New Feature
    of Angular 4*, at [bit.ly/NgBestFeature](http://bit.ly/NgBestFeature), the message
    is clear:'
  prefs: []
  type: TYPE_NORMAL
- en: '**For Developers & Managers: **Angular is here to stay, so you should be investing
    your time, attention, and money in learning it – even if you’re currently in love
    with some other framework.**For Decision Makers (CIOs, CTOs, etc.): **Plan to
    begin your transition to Angular in the next 6 months. It’ll be an investment
    you’ll be able to explain to business minded people, and your investment will
    pay dividends for many years to come, long after the initial LTS window expires,
    with graceful upgrade paths to Angular vNext and beyond.'
  prefs: []
  type: TYPE_NORMAL
- en: So, why does Google (Angular) and Microsoft (TypeScript, Visual Studio Code)
    give away such technologies for free? There are multiple reasons, some including
    demonstration of technical proves to retain and attract talent, proving and debugging
    new ideas and tools with millions of developers at scale, and ultimately allowing
    developers to more easily create great web experiences that ultimately drive more
    business for Google and Microsoft. I personally don't see any nefarious intent
    here and welcome open, mature, and high-quality tools that I can tinker with and
    bend to my own will, if necessary, and not have to pay for a support contract
    for a proprietary piece of tech.
  prefs: []
  type: TYPE_NORMAL
- en: Beware, looking for Angular help on the web may be tricky. You'll note that
    most of the time, Angular is referred to as Angular 2 or Angular 4\. At times,
    both Angular and AngularJS are simply referred to as AngularJS. This, of course,
    is incorrect. The documentation for Angular is at [angular.io](https://angular.io). If
    you land on [angularjs.org](https://angularjs.org/), you'll be reading about the
    legacy AngularJS framework.For the latest updates on the upcoming Angular releases,
    view the official Release Schedule at: [Github.com/angular/angular/blob/master/docs/RELEASE_SCHEDULE.md](https://github.com/angular/angular/blob/master/docs/RELEASE_SCHEDULE.md).
  prefs: []
  type: TYPE_NORMAL
- en: Angular's philosophy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The philosophy behind Angular is to err on the side of configuration over convention.
    Convention-based frameworks, although may seem elegant from the outside, make
    it really difficult for newcomers to pick up the framework. Configuration-based
    frameworks, however, aim to expose their inner workings through explicit configuration
    elements and hooks, where you can attach your custom behavior to the framework.
    In essence, Angular tries to be non-magical, where AngularJS was a lot of magic.
  prefs: []
  type: TYPE_NORMAL
- en: This results in a lot of verbose coding. This is a good thing. Terse code is
    the enemy of maintainability, only benefiting the original author. However, as
    Andy Hunt and David Thomas put it in the Pragmatic Programmer,
  prefs: []
  type: TYPE_NORMAL
- en: Remember that you (and others after you) will be reading the code many hundreds
    of times, but only writing it a few times.
  prefs: []
  type: TYPE_NORMAL
- en: Verbose, decoupled, cohesive, and encapsulated code is the key to future proofing
    your code. Angular, through its various mechanisms, enables the proper execution
    of these concepts. It gets rid of many custom conventions invented in AngularJS,
    such as `ng-click`, and introduces a more intuitive language that builds on the
    existing HTML elements and properties. As a result, `ng-click` becomes `(click)`,
    extending HTML rather than replacing it.
  prefs: []
  type: TYPE_NORMAL
- en: What's new in Angular 6?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Most, if not all, of the content, patterns, and practices in this book are
    compatible with Angular 4 and up. Angular 6 is the latest version of Angular,
    which brings a lot of under-the-cover improvements to the platform and overall
    stability and cohesion across the ecosystem. The development experience is being
    vastly improved with additional CLI tools that make it easier to update versions
    of packages and faster build times to improve your code-build-view feedback cycle.
    With Angular 6, all platform tools are version synced to 6.0, making it easier
    to reason about the ecosystem. In the following chart, you can see how this makes
    it easier to communicate tooling compatibility:'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | **Previously** | **With v6** |'
  prefs: []
  type: TYPE_TB
- en: '| **CLI** | 1.7 | 6.0 |'
  prefs: []
  type: TYPE_TB
- en: '| **Angular** | 5.2.10 | 6.0 |'
  prefs: []
  type: TYPE_TB
- en: '| **Material** | 5.2.4 | 6.0 |'
  prefs: []
  type: TYPE_TB
- en: Angular CLI 6.0 comes with major new capabilities, such as `ng update` and `ng
    add` commands; `ng update` makes it much easier to update your version of Angular,
    npm dependencies, RxJS, and Angular Material, including some deterministic code rewriting
    capabilities to apply name changes to APIs or functions. The topic of updating
    your version of Angular is covered in depth in [Chapter 4](374c123d-2621-42e2-b301-ed67c9c7d708.xhtml),
    *Staying Up to Date with Angular Updates.* `ng add` brings schematics support
    to the Angular CLI. With schematics, you can write custom code to add new capabilities
    to an Angular app, adding any dependencies, boilerplate configuration code, or
    scaffolding. A great example is to be able to add Angular Material to your project
    by executing `ng add @angular/material`. The topic of adding Angular Material
    to your project is covered in depth in [Chapter 5](5e0df0e8-57a6-47dc-86c8-d56f6e35021e.xhtml),* Enhance
    Angular App with Angular Material*. A standalone Material Update tool aims to
    make Angular Material updates less painful, found at [Github.com/angular/material-update-tool](https://github.com/angular/material-update-tool),
    but expect this functionality to be merged into `ng update`. Further schematics
    can bring their own `generate` commands to CLI, making your life easier and code
    base more consistent over time. In addition, version 4 of Webpack is configured
    to build your Angular application into smaller modules with scope hosting, shortening
    the first-paint time of your app.
  prefs: []
  type: TYPE_NORMAL
- en: The major theme of Angular 6 is under-the-hood performance improvements and
    Custom Elements support. Version 6 improves upon v5 in terms of the base bundle
    size by 12% at 65 KB, which improves load times a whopping 21-40% from Fast 3G
    to Fiber connections. As your applications grows, Angular takes advantage of a
    better tree-shaking technique to further prune unused code out of your final deliverable.
    Speed is a UX feature in Angular 6\. This is accomplished with better support
    for Angular **Component Development Kit** (**CDK**), Angular Material, Animations,
    and i18n. Angular Universal allows for server-side assisted fast startup times,
    and Angular **Progressive Web App** (**PWA**) support takes advantage of native
    platform features such as caching and offline, so in subsequent visits, your app
    remains fast. RxJS 6 support allows for the tree-shakeable `pipe` command, reducing
    bundle sizes more often, and fix the behavior of `throttle` as I caution you in [Chapter
    6](2d361227-9c8f-4487-bb14-592ca16c0f5a.xhtml),* Reactive Forms and Component
    Interaction, *among numerous bug fixes and performance improvements. TypeScript
    2.7 brings in better support for importing different types of JavaScript packages
    and more advanced features to catch coding errors during build time.
  prefs: []
  type: TYPE_NORMAL
- en: Custom Elements support, part of the Web Components spec, is huge. With Angular
    Elements, you can code an Angular component and reuse that component in *any *other
    web application using *any* web technology, in essence declaring your very own
    custom HTML element. These custom elements would be cross-compatible with any
    HTML-based tool chain, including other web application libraries or frameworks. For
    this to work, the entire Angular framework needs to be packaged alongside your
    new custom element. This is not feasible in Angular 6, because that will mean
    tacking on at least 65 KB, each and every time you create a new user control.
    Furthermore, in early 2018, only Chrome supports Custom Elements without polyfills
    adding more payload to make these custom elements work. Due to its experimental
    nature, I do not cover custom elements in this book. Future updates of Angular,
    in late 2018 or early 2019, should bring in the Ivy rendering engine, enabling
    base bundle sizes as small as 2.7 KB, resulting in lightning fast load times and
    making it feasible to ship Angular-based Custom Elements. In this time frame,
    tooling to build such components easily and native browser support for Custom
    Elements will also improve, including Firefox and Safari support, leaving Microsoft
    Edge the last browser to implement the standard.
  prefs: []
  type: TYPE_NORMAL
- en: Always check [https://caniuse.com](https://caniuse.com) before getting too excited
    about a new web technology to ensure that you are indeed able to use that feature
    in browsers that you must support.
  prefs: []
  type: TYPE_NORMAL
- en: Regardless of [Angular.io](https://Angular.io) being updated with custom elements
    to demonstrate the feasibility of the technology, the documentation website attracts
    1 million+ unique visitors per month, so it should help work out some of the kinks
    as it matures. Custom elements are great use cases to host interactive code samples
    alongside static content. In early 2018, [Angular.io](https://Angular.io) started
    using [StackBlitz.io](https://StackBlitz.io) for interactive code samples. This
    is an amazing website, in essence a Visual Studio Code IDE in the cloud, where
    you can experiment with different ideas or run GitHub repositories without needing
    to locally pull or execute any code.
  prefs: []
  type: TYPE_NORMAL
- en: The Angular ecosystem also welcomes the NgRx library, bringing Redux-like state
    management to Angular based on RxJS. Such state management is necessary for building
    offline-first applications in PWA and Mobile contexts. However, PWAs are not well
    supported in iOS's Safari browser and will not find widespread adoption until
    the new IE6 of browsers decides to join the party. Furthermore, NgRx, is an abstraction
    over already confusing and sophisticated tooling like RxJS. Given my positive
    attitude toward minimal tooling and a lack of clear necessity for RxJS beyond
    niche audience, I will not be covering this tool. RxJS is powerful and capable
    enough to unlock sophisticated and scalable patterns to help you build a great
    Angular application, as demonstrated in the lead up to [Chapter 10](99f040e3-89f0-4ac8-a849-4cef38e7a992.xhtml),
    *Angular App Design and Recipes*.
  prefs: []
  type: TYPE_NORMAL
- en: Angular Material 6 adds new user controls such as tree and badge, while making
    the library a lot more stable with a slew of bug fixes, completeness of functionality,
    and theming in existing components. Angular Flex Layout 6 brings in polyfills,
    enabling Internet Explorer 11 support CSS Flexbox. This makes Angular apps using
    Material and Flex Layout fully compatible with the last major legacy browser technology
    that still persists in enterprises and governments despite leaving mainstream
    support in January 2018 alongside Windows 8.1 and being superseded 16 times by
    Microsoft Edge. Angular 6 itself can be configured to be compatible down to IE9
    using polyfills. This is great news for developers, who must support such legacy
    browsers and still be able to use modern technologies to build their solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Some exciting, new ancillary tooling is also released that can enable high frequency,
    high performance, or large enterprise use cases. The Nx CLI tool, built by former
    Angular team members, brings an opinionated development environment setup to Angular,
    suitable for consultants and large organizations that must ensure a consistent
    environment. This book follows a similar pattern and aims to educate you in establishing
    a consistent architecture and design pattern to apply across your applications.
    Google's Bazel build tool enables incremental builds, so portions of your application
    that haven't changed don't need to be rebuilt, vastly improving build times for
    larges projects and allowing for packaging of libraries to be shared between Angular
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: I hope you are as excited as I am about Angular 6 and the future possibilities
    it unlocks. Now, let's put all that aside and dive deep into getting things done
    by building a simple Angular application that can display the current weather.
  prefs: []
  type: TYPE_NORMAL
- en: Angular in Full-Stack Architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will design, architect, create a backlog, and establish
    the folder structure for your Angular project that will be able communicate with
    a REST API. This app will be designed to demonstrate the uses of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Angular CLI tool (ng)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Angular Reuse of UI through components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Angular HttpClient
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Angular Router
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Angular Reactive Forms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Material Autocomplete
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Material Toolbar
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Material Sidenav
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regardless of your backend technology, I recommend that your frontend always
    resides in its own repository and is served using its own web server that is not
    depended on your API server.
  prefs: []
  type: TYPE_NORMAL
- en: First things first, you need a vision and a road map to act upon.
  prefs: []
  type: TYPE_NORMAL
- en: Wireframe design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are some great tools out there to do rough looking mock-ups to demonstrate
    your idea with surprising amounts of rich functionality. If you have a dedicated
    UX designer, such tools are great for creating quasi prototypes. However, as a
    full-stack developer, I find the best tool out there to be pen and paper. This
    way, you don''t have to learn yet another tool (YAL), and it is a far better alternative
    having no design at all. Putting things on paper will save you from costly coding
    detours down the line and if you can validate your wireframe design with users
    ahead of time, even better. I will call my app LocalCast Weather, but get creative
    and pick your own name. Behold, the wireframe design for your weather app:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/67bb08ec-66f3-459e-9bce-40d743225cf2.png)Wireframe for LocalCast.
    Intentionally hand-drawn.'
  prefs: []
  type: TYPE_NORMAL
- en: The wireframe shouldn't be anything fancy. I recommend starting with a hand-drawn
    design, which is very quick to do and carries over the rough outlines effectively.
    There are great wireframing tools out there and I will be suggesting and using
    a couple of them throughout this book, however in the first days of your project,
    every hour matters. Granted, this kind of rough design may never leave the boundaries
    of your team, but please know that nothing beats getting that instantaneous feedback
    and collaboration by putting your ideas down on paper or a whiteboard.
  prefs: []
  type: TYPE_NORMAL
- en: High level architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: No matter how small or large your project is, and frankly most of the times
    you will not be able to accurately predict this ahead of time, it is critical
    to start with a sound architecture that can scale if duty calls, but is not so
    burdensome that it will add days of effort to the execution of a simple app idea.
    The key is to ensure proper decoupling from the get go. In my view, there are
    two types of decoupling, one is a soft-decoupling, where essentially a *Gentlemen's
    Agreement* is made to not mix concerns and try and not mess up the code base.
    This can apply to the code you write, all the way to infrastructure-level interactions.
    If you maintain your frontend code under the same code structure as your backend
    code and if you let your REST server serve up your frontend application, then
    you are only practicing soft-decoupling.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should instead practice hard-decoupling, which means frontend code lives
    in a separate repository, never calls the database directly, and is hosted on
    its own web server altogether. This way, you can be certain that at all times,
    your REST APIs or your frontend code is entirely replaceable independent of each
    other. Practicing hard-decoupling has monetary and security benefits as well.
    The serving and scaling needs of your frontend application are guaranteed to be
    different from your backend, so you will be able to optimize your host environment
    appropriately and save money. If you white list access to your REST APIs to only
    the calls originating from your frontend servers, you will vastly improve your
    security. Consider the high-level architecture diagram for our LocalCast Weather
    app below:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/41e34a04-4d6b-4647-8d54-6d1679ade8db.jpg)LocalCast High-Level Architecture'
  prefs: []
  type: TYPE_NORMAL
- en: The high-level architecture shows that our Angular web application is completely
    decoupled from any backend. It is hosted on its own web server, can communicate
    to a web API such as **OpenWeatherMap**, or optionally be paired with a backend
    infrastructure to unlock rich and customized features that a web API alone can't
    provide, such as storing per user preferences or complimenting OpenWeatherMap's
    dataset with our own.
  prefs: []
  type: TYPE_NORMAL
- en: Folder structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I advise against keeping your frontend and backend code in the same code repository.
    Using the same repository leads to bizarre dependencies when you need to enable
    Continuous Integration or deploy your code to production. In order to get an integrated
    development experience with the ability to quickly switch between repositories,
    you can use IDE features, such as VS Code Workspace, to open multiple repositories
    under the same tree-structure at once.
  prefs: []
  type: TYPE_NORMAL
- en: If you must use a single repository, create separate folders for backend code
    and frontend code, named `server` and `web-app`, respectively. The benefit of
    doing this at a minimum is great, because team members can start working on either
    the frontend or the backend without stepping over each other's toes.
  prefs: []
  type: TYPE_NORMAL
- en: Follow the instructions in the next two sections to set up your application
    correctly. If you already have a robust development directory setup and you're
    a Git pro, then skip over to the *Generate Your Angular Application* section.
  prefs: []
  type: TYPE_NORMAL
- en: Set up your development directory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Setting up a dedicated `dev` directory is a life saver. Since all the data under
    this directory will be backed up using GitHub, you can safely configure your antivirus,
    cloud sync, or backup software to ignore it. This will help greatly reduce CPU,
    disk, and network utilization. As a full-stack developer, you're likely to be
    multitasking a lot, so avoiding unnecessary activity will have a net positive
    impact on performance, power, and data consumption on a daily basis, especially
    if your development environment is a laptop that is either resource starved or
    you wish to squeeze as much battery life as possible when you're on the move.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a `dev` folder directly under the `c:\` drive is very important, because
    Windows, or rather NTFS, isn't able handle file paths longer than 260 characters. This
    may seem adequate at first, but when you install npm packages in a folder structure
    that is already deep in the hierarchy, the `node_modules` folder structure can
    get deep enough to hit this limit very easily. With npm 3+, a new, flatter package
    installation strategy was introduced, which helps with npm-related issues, but
    being as close to the `root` folder as possible will help tremendously with any
    tool. In late 2016, there were reports that Microsoft may introduce an Enable
    NTFS long paths group policy to remedy this situation, but as of late 2017, this
    has not landed on Windows 10.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create your `dev` folder using the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For Windows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In Unix-based operating systems, `~` (pronounced tilde) is a shortcut to the
    current users `home` directory, which resides under `/Users/your-user-name`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For macOS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now that your development directory is ready, let's start with generating your
    Angular application.
  prefs: []
  type: TYPE_NORMAL
- en: Generate your Angular application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Angular CLI (Angular CLI) is an official Angular project to ensure that
    newly created Angular applications have a uniform architecture, following the
    best practices perfected by the community over time. This means that any Angular
    application you encounter going forward should have the same general shape. Angular
    CLI goes beyond initial code generation. You will be using it frequently to create
    new components, directives, pipes, services, modules, and more. Angular CLI will
    also help you during development with live-reloading features so that you can
    quickly see the results of your changes. Angular CLI can also test, lint, and
    build optimized versions of your code for a production release. Furthermore, as
    new Angular versions are released, Angular CLI will help you upgrade your code,
    by automatically rewriting portions of it so that it remains compatible with potential
    breaking changes.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Angular CLI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The documentation at [https://angular.io/guide/quickstart](https://angular.io/guide/quickstart) will
    guide you to install `@angular/cli` as a global npm package. Do *not* do this.
    Overtime, as Angular CLI is upgraded, it is a constant irritant to have to keep
    the global and the in-project version in sync. If you don't, the tool complains
    endlessly. Additionally, if you are working on multiple projects, you will have
    varying versions of Angular CLI overtime. As a result, your commands may not return
    the results you expect or your team members get.
  prefs: []
  type: TYPE_NORMAL
- en: The strategy detailed in the next section will make your initial configuration
    of your Angular project a bit more complicated than it needs to be; however, you'll
    be more than making up for this pain if you return to a project a few months or
    a year later. In that case, you will be able to use the version of the tool that
    you last used on that project, instead of some future version that may require
    upgrades that you're not willing to perform. In the next section, you will apply
    this best practice to initialize your Angular app.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing Angular app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we will initialize the application for development using `npx`, which
    is already installed on your system when you installed the latest version of Node
    LTS:'
  prefs: []
  type: TYPE_NORMAL
- en: Under your `dev` folder, execute `npx @angular/cli new local-weather-app`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'On your terminal, you should see a success message similar to this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Your project folder—`local-weather-app`—has been initialized as a Git repository
    and scaffolded with the initial file and folder structure, which should look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The alias for `@angular/cli` is `ng`. If you were to install Angular CLI globally,
    you would have simply executed `ng new local-weather-app`, but we didn't do this.
    So it is important to remember that going forward, you will be executing the `ng` command,
    but this time under the `local-weather-app` directory. The latest version of Angular
    CLI has been installed under the `node_modules/.bin` directory, so you can run
    `ng` commands such as `npx ng generate component my-new-component` and continue
    working in an effective manner.
  prefs: []
  type: TYPE_NORMAL
- en: If you are on macOS, you can further improve your development experience by
    implementing shell auto fallback, which removes the necessity of having to use
    the `npx` command. If an unknown command is found, npx will take over the request.
    If the package already locally exists under `node_modules/.bin`, the npx will
    pass along your request to the correct binary. So, you will just be able to run
    commands like `ng g c my-new-component` as if they're globally installed. Refer
    to npx's readme on how to set this up at [npmjs.com/package/npx#shell-auto-fallback](https://www.npmjs.com/package/npx#shell-auto-fallback).
  prefs: []
  type: TYPE_NORMAL
- en: Publishing Git Repository using GitHub Desktop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'GitHub Desktop allows you to create a new repository directly within the application:'
  prefs: []
  type: TYPE_NORMAL
- en: Open GitHub for Desktop
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: File | Add local repository...
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Locate the `local-weather-app` folder by clicking on Choose...
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on Add repository
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that Angular CLI already created the first commit for you in the History
    tab
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, click on Publish repository, as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](Images/c4aebec3-835d-4533-88ea-8063784d4b99.png)GitHub Desktop'
  prefs: []
  type: TYPE_NORMAL
- en: Inspecting and updating package.json
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Package.json` is the single most important configuration file that you should
    be keenly aware of at all times. Your project''s scripts, runtime, and development
    dependencies are stored in this file.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `package.json` and locate the `name` and `version` properties:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Rename your app to whatever you wish; I will be using `localcast-weather`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set your version number to `1.0.0`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`npm` uses semantic versioning (semver), where version number digits represent
    Major.Minor.Patch increments. Semver starts version numbers at `1.0.0` for any
    published API, though it doesn''t prevent 0.x.x versioning. As the author of a
    web application, the versioning of your app has no real impact on you, outside
    of internal tooling, team, or company communication purposes. However, the versioning
    of your dependencies is highly critical to the reliability of your application.
    In summary, Patch versions should just be bug fixes. Minor versions add functionality
    without breaking the existing features, and major version increments are free
    to make incompatible API changes. However, in reality, any update is risky to
    the tested behavior of your application. This is why the `package-lock.json` file
    stores the entire dependency tree of your application, so the exact state of your
    application can be replicated by other developers or Continuous Integration servers.
    For more information, visit: [https://semver.org/](https://semver.org/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code block, observe that the `scripts` property contains a
    collection of helpful starter scripts that you can expand on. The `start` and
    `test` commands are npm defaults, so they can just be executed by `npm start`
    or `npm test`. However, the other commands are custom commands that must be prepended
    with the `run` keyword. For example, in order to build your application, you must
    use `npm run build`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Before the introduction of npx, if you wanted to use Angular CLI without a global
    install, you would have to run it with `npm run ng -- g c my-new-component`. The
    double-dashes are needed to let npm know where the command-line tool name ends
    and options begin. For example, in order to start your Angular application on
    a port other than the default `4200`, you will need to run `npm start -- --port
    5000`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update your `package.json` file to run your development version of the app
    from a little used port like `5000` as the new default behavior:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Under the `dependencies` property, you can observe your runtime dependencies.
    These are libraries that will get packaged up alongside your code and shipped
    to the client browser. It''s important to keep this list to a minimum:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, all Angular components are on the same version. As
    you install additional Angular components or upgrade individual ones, it is advisable
    to keep all Angular packages on the same version. This is especially easy to do
    since npm 5 doesn't require the `--save` option anymore to permanently update
    the package version. For example, just executing `npm install @angular/router`
    is sufficient to update the version in `package.json`. This is a positive change
    overall, since what you see in `package.json` will match what is actually installed.
    However, you must be careful, because npm 5 will also automatically update `package-lock.json`,
    which will propagate your, potentially unintended, changes to your team members.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your development dependencies are stored under the `devDependencies` property.
    When installing new tools to your project, you must take care to append the command
    with `--save-dev` so that your dependency will be correctly categorized. Dev dependencies
    are only used during development and are not shipped to the client browser. You
    should familiarize yourself with every single one of these packages and their
    specific purpose. If you are unfamiliar with a package shown as we move on, your
    best resource to learn more about them is [https://www.npmjs.com/](https://www.npmjs.com/):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The characters in front of the version numbers have specific meanings in semver.
  prefs: []
  type: TYPE_NORMAL
- en: Tilde `~` enables tilde ranges when all three digits of the version number are
    defined, allowing for patch version upgrades to be automatically applied
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Up-caret character `^` enables caret ranges, allowing for minor version upgrades
    to be automatically applied
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lack of any character signals npm to install that exact version of the library
    on your machine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You may notice that major version upgrades aren''t allowed to happen automatically.
    In general, updating packages can be risky. In order to ensure, no package is
    updating without your explicit knowledge, you may install exact versions packages
    by using npm''s `--save-exact` option. Let''s experiment with this behavior by
    installing an npm package that I published called, `dev-norms`, a CLI tool that
    generates a markdown file with sensible default norms for your team to have a
    conversation around, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: Under the `local-weather-app` directory, execute `npm install dev-norms --save-dev
    --save-exact`. Note that `"dev-norms": "1.3.6"` or similar has been added to `package.json` with `package-lock.json` automatically
    updated to reflect the changes accordingly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After the tool is installed, execute `npx dev-norms create`. A file named `dev-norms.md` has
    been created containing the aforementioned developer norms.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save your changes to `package.json`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Working with stale packages comes with its own risks. With npm 6, the `npm audit`
    command has been introduced to make you aware of any vulnerabilities discovered
    in packages you're using. During `npm install` if you receive any vulnerability
    notices, you may execute `npm audit` to find out details about any potential risk.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you will commit the changes you have made to Git.
  prefs: []
  type: TYPE_NORMAL
- en: Commiting code using VS Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to commit your changes to Git and then synchronize your commits to
    GitHub, you can use VS Code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch over to the Source Control pane, marked as 1 here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](Images/e771b503-a971-4ce4-ae81-957de6a252b1.png)Visual Studio Code Source
    Control pane'
  prefs: []
  type: TYPE_NORMAL
- en: Enter a commit message in 2
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the check-mark icon to commit your changes in 3
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, synchronize your changes with your GitHub repository by clicking on
    the refresh icon in 4.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Going forward, you can do most Git operations from within VS Code.
  prefs: []
  type: TYPE_NORMAL
- en: Running your Angular app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Run your Angular app to check whether it works. During development, you can
    execute `npm start`, through the `ng serve` command; this action will transpile,
    package, and serve the code on localhost with live-reloading enabled:'
  prefs: []
  type: TYPE_NORMAL
- en: Execute `npm start`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to `http://localhost:5000`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You should see a rendered page similar to this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](Images/10bd04de-9c6d-4a91-b4b0-a20e77386d26.png)Default Angular CLI landing
    page'
  prefs: []
  type: TYPE_NORMAL
- en: Stop your application by pressing *Ctrl* + *C* in the integrated terminal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Optimizing VS Code for Angular
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Saving files all the time can get tedious. You can enable automatic saving
    by doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Open VS Code
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Toggle the setting under File | Auto Save
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can further customize many aspects of VS Code's behavior by launching Preferences. The
    keyboard shortcut to launch Preferences is *Ctrl* + *,* on Windows and ⌘ + *,*
    on macOS.
  prefs: []
  type: TYPE_NORMAL
- en: IDE settings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can share such settings with your coworkers by creating a `.vscode` folder
    in the root of your project directory and placing a `settings.json` file in it.
    If you commit this file to the repository, everyone will share the same IDE experience.
    Unfortunately, individuals aren't able to override these settings with their own
    local preferences, so ensure that shared settings are minimal and are agreed upon
    as a team norm.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the customizations that I use for an optimal, battery-life conscious
    Angular development experience:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, you may enable the following settings in VS Code for a richer
    development experience:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: IDE extensions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For a *magical* development experience with VS Code and Angular, you should
    install the Angular Essentials extension pack created and curated by John Papa.
    John Papa is one of the leading champions and thought leaders in the Angular community.
    He continuously and relentlessly seeks the best possible development experience
    you can attain so that you are more productive and happier as a developer. He
    is a resource to trust and take very seriously. I highly recommend you follow
    him on twitter at `@john_papa`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to settings, you can also share recommended extensions via a JSON file.
    These are the extensions that I use for Angular development:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: VS Code will also recommend some extensions for you to install. I would caution
    against installing too many extensions, as these will noticeably start slowing
    down the launch performance and optimal operation of VS Code.
  prefs: []
  type: TYPE_NORMAL
- en: Coding style
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can customize the coding style enforcement and code generation behavior
    in VS Code and Angular CLI. When it comes to JavaScript, I prefer StandardJS settings,
    which codifies a minimal approach to writing code, while maintaining great readability.
    This means 2-spaces for tabs and no semicolons. In addition to the reduced keystrokes,
    StandardJS also takes less space horizontally, which is especially valuable when
    your IDE can only utilize half of the screen with the other half taken up by the
    browser. You can read more about StandardJS at: [https://standardjs.com/](https://standardjs.com/).
  prefs: []
  type: TYPE_NORMAL
- en: 'With the default settings, your code will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'With StandardJS settings, your code will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Ultimately, this is an optional step for you. However, my code samples will
    follow the StandardJS style. You can start making the configuration changes by
    following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Install the Prettier - Code formatter extension
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update `.vscode/extensions.json` file with the new extension
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Execute `npm i -D prettier`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can use `i` for `install` and `-D` instead of the more verbose `--save-dev`
    option. However, if you mistype `-D` as `-d`, you will end up saving the package
    as a production dependency.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit `package.json` with a new script, update the existing ones, and create
    new formatting rules:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'macOS and Linux users must modify the `standardize` script to add single-quotes
    around `**/*.ts` for the script to correctly traverse the directory. In macOS
    and Linux, the correct script looks like `"standardize": "prettier ''**/*.ts''
    --write"`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, update `tslint.json` with new formatting rules:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Execute `npm run standardize` to update all your files to the new style
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Observe all the file changes in GitHub Desktop
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Going forward, every time you execute `npm start` or `npm run build`, the new
    `standardize` script will automatically run and keep the formatting of your files
    in shape
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Commit and push your changes to your repository
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As you type in new code or generate new components using Angular CLI, you will
    encounter double-quotes or semicolons being underlined with a red-squiggly line
    to indicate an issue. In most of those cases, a yellow bulb icon will appear next
    to the issue. If you click on the bulb, you will see an action to Fix: Unnecessary
    semicolon or a similar message. You can either take advantage of these auto-fixers
    or press *Shift* + *Alt* + *F* to run the Prettier Format Document command on
    the entire file. In the following screenshot, you can see the auto-fixer in action
    with the yellow bulb and the corresponding contextual menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/28378c58-35a6-4666-ba48-4e85e1364fec.png)VS Code Auto-Fixer'
  prefs: []
  type: TYPE_NORMAL
- en: Planning a feature road map using Waffle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building a rough plan of action before you start coding is a very important
    so that you and your colleagues or clients are aware of the road map you're planning
    to execute. Whether you're building an app for yourself or for someone else, a
    living backlog of features will always serve as a great reminder when you get
    back to a project after a break or serve as an information radiator that prevent
    constant requests for status updates.
  prefs: []
  type: TYPE_NORMAL
- en: In Agile development, you may have used various ticketing systems or tools that
    surface or Kanban boards. My favorite tool is Waffle.io, [https://waffle.io/](https://waffle.io/),
    because it directly integrates with your GitHub repository's issues and keeps
    track of status of issues via labels. This way, you can keep using the tool of
    your choice to interact with your repository and still, effortlessly, radiate
    information. In the next section, you will set up a Waffle project to achieve
    this goal.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a Waffle project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will now set up our Waffle project:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to Waffle.io [https://waffle.io/](https://waffle.io/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on Login or Get Started for Free.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select Public & Private Repos to allow access to all of your repositories.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on Create Project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Search for the local-weather-app repository and select it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hit Continue.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will get two starter layout templates, as shown in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/9cb448bb-d7e6-48ae-bde1-ce3cbb174c7a.png)Waffle.io Default Board
    Layouts'
  prefs: []
  type: TYPE_NORMAL
- en: For this simple project, you will be selecting Basic. However, the Advanced
    layout demonstrates how you can modify the default setup of Waffle, by adding
    additional columns such as Review, to account for testers or product owners participating
    in the process. You can further customize any board to fit your existing process.
  prefs: []
  type: TYPE_NORMAL
- en: Select the Basic layout and click on Create Project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will see a new board created for you.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](Images/59ab5b31-7f09-446d-9f1e-69d1bb6afed0.png)Empty Waffle Board'
  prefs: []
  type: TYPE_NORMAL
- en: By default, Waffle will serve as a Kanban board. Allowing you to move a task
    from one state to another. However, the default view will show all the issues
    that are present on the repository. To use Waffle as a Scrum board, you need to
    assign issues to GitHub milestones that will represent sprints. You can then use
    the filtering functionality to only display issues from that milestone, or put
    another way from the current sprint.
  prefs: []
  type: TYPE_NORMAL
- en: On Waffle, you can attach story points to issues by clicking on the ![](Images/743fa9fd-b4cb-44e6-952c-a53cedda025f.jpg) scale
    icon. The columns will automatically show totals and card orders, which represent
    priority, and they will be retained from session to session. Furthermore, you
    can switch to the Metrics view to get Milestone Burndown and Throughput graphs
    and statistics.
  prefs: []
  type: TYPE_NORMAL
- en: Creating issues for your Local Weather app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will now create a backlog of issues that you will use to keep track of your
    progress as you implement the design of your application. When creating issues,
    you should focus on delivering functional iterations that bring some value to
    the user. The technical hurdles you must clear to achieve those results are of
    no interest to your users or clients.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the features we plan to be building in our first release:'
  prefs: []
  type: TYPE_NORMAL
- en: Display Current Location weather information for the current day
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Display forecast information for current location
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add city search capability so that users can see weather information from other
    cities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a preferences pane to store the default city for the user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improve the UX of the app with Angular Material
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Go ahead with creating your issues on Waffle or on GitHub; whichever you prefer
    is fine. While creating the scope for Sprint 1, I had some other ideas for features,
    so I just added those issues, but I did not assign them to a person or a milestone.
    I also went ahead and added story points to the issues I intended to work on.
    The following is what the board looks like, as I''m to begin working on the first
    story:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/afcc6387-02dc-4e09-9f46-0c45a106a8e2.png)A snapshot of the initial
    state of the board at [https://waffle.io/duluca/local-weather-app](https://waffle.io/duluca/local-weather-app)Ultimately,
    Waffle provides an easy-to-use GUI so that non-technical people can easily interact
    with GitHub issues. By allowing non-technical people to participate in the development
    process on GitHub, you unlock the benefit of GitHub becoming the single source
    of information for your entire project. Questions, answers, and discussions around
    features and issues are all tracked as part of GitHub issues, instead of being
    lost in emails. You can also store wiki type documentation on GitHub, so by centralizing
    all project-related information, data, conversations, and artifacts on GitHub,
    you are greatly simplifying a potentially complicated interaction of multiple
    systems that require continued maintenance, at a high cost. For private repositories
    and on-premise Enterprise installations, GitHub has a very reasonable cost. If
    you''re sticking with open source, as we are in this chapter, all these tools
    are free.As a bonus, I created a rudimentary wiki page on my repository at [https://github.com/duluca/local-weather-app/wiki](https://github.com/duluca/local-weather-app/wiki).
    Note that you can''t upload images to `README.md` or wiki pages. To get around
    this limitation, you can create a new issue, upload an image in a comment, and
    copy and paste the URL for it to embed images to `README.md` or wiki pages. In
    the sample wiki, I followed this technique to embed the wireframe design into
    the page.'
  prefs: []
  type: TYPE_NORMAL
- en: With a concrete road map in place, you're now ready to start implementing your
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Crafting UI elements using components and interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will be leveraging Angular components, interfaces, and services to build
    the current weather feature in a decoupled, cohesive, and encapsulated manner.
  prefs: []
  type: TYPE_NORMAL
- en: The landing page of an Angular app, by default, resides in `app.component.html`.
    So, start by editing the template of `AppComponent` with rudimentary HTML, laying
    out the initial landing experience for the application.
  prefs: []
  type: TYPE_NORMAL
- en: We are now beginning the development of Feature 1: Display Current Location
    weather information for the current day, so, you can move the card in Waffle to
    the In Progress column.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will add a header as an `h1` tag, followed by the tagline of our app as
    a `div` and placeholders for where we may want to display the current weather,
    as demonstrated as shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: At this point, you should run `npm start` and navigate to `http://localhost:5000` on your
    browser so that you can observe the changes you're making in real time.
  prefs: []
  type: TYPE_NORMAL
- en: Discover OpenWeatherMap APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since `httpClient` is strongly typed, we need to create a new interface that
    conforms to the shape of the API we'll call. To be able to do this, you need to
    familiarize yourself with the Current Weather Data API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Read documentation by navigating to [http://openweathermap.org/current](http://openweathermap.org/current):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](Images/c2cf5e84-5346-44a8-b651-b8f3403adff4.png)OpenWeatherMap Current
    Weather Data API Documentation'
  prefs: []
  type: TYPE_NORMAL
- en: 'You will be using the API named By city name, which allows you to get current
    weather data by providing the city name as a parameter. So, your web request will
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'On the documentation page, click on the link under Example of API calls, and
    you will see a sample response like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Given the existing `ICurrentWeather` interface that you have already created,
    this response contains more information than you need. So you will write a new
    interface that conforms to the shape of this response, but only specify the pieces
    of data you will use. This interface will only exist in the `WeatherService` and
    we won't export it, since the other parts of the application don't need to know
    about this type.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new interface named `ICurrentWeatherData` in `weather.service.ts` between
    the `import` and `@Injectable` statements
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The new interface should like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: With the `ICurrentWeatherData` interface, we are defining new anonymous types
    by adding children objects to the interface with varying structures. Each of these
    objects can be individually extracted out and defined as their own named interface.
    Especially, note that `weather` will be an array of the anonymous type that has
    the `description` and `icon` properties.
  prefs: []
  type: TYPE_NORMAL
- en: Adding an Angular component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need to display the current weather information, where `<div>current weather</div>`
    is located. In order to achieve this, you need to build a component that will
    be responsible for displaying the weather data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The reason behind creating a separate component is an architectural best practice
    that is codified in the **Model-View-ViewModel** (**MVVM**) design pattern. You
    may have heard of the **Model-View-Controller** (**MVC**) pattern before. Vast
    majority of web-based code written circa 2005-2015 has been written following
    the MVC pattern. MVVM differs, in important ways, from the MVC pattern. As I have
    explained in my 2013 article on DevPro:'
  prefs: []
  type: TYPE_NORMAL
- en: '[An effective implementation of MVVM] inherently enforces proper separation
    of concerns. Business logic is clearly separated from presentation logic. So when
    a View is developed, it stays developed, because fixing a bug in one View''s functionality
    doesn''t impact other views. On the flip side, if [you use] visual inheritance
    effectively and [create] reusable user controls, fixing a bug in one place can
    fix issues throughout the application.'
  prefs: []
  type: TYPE_NORMAL
- en: Angular provides an effective implementation of MVVM.
  prefs: []
  type: TYPE_NORMAL
- en: ViewModels neatly encapsulate any presentation logic and allow for simpler View
    code by acting as a specialized version of the model. The relationship between
    a View and ViewModel is straightforward, allowing for more natural ways to wrap
    UI behavior in reusable user controls.
  prefs: []
  type: TYPE_NORMAL
- en: You can read further about the architectural nuance, with illustrations, at [http://bit.ly/MVVMvsMVC](http://bit.ly/MVVMvsMVC).
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you will create your very first Angular component, which will include
    the View and the ViewModel, using Angular CLI''s `ng generate` command:'
  prefs: []
  type: TYPE_NORMAL
- en: In the terminal, execute `npx ng generate component current-weather`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure that you are executing `ng` commands under the `local-weather-app` folder,
    and not under the `root` project folder. In addition, note that `npx ng generate
    component current-weather` can be rewritten as `ng g c current-weather`. Going
    forward, this book will utilize the shorthand format and expect you to prepend `npx`,
    if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Observe the new files created in your `app` folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'A generated component has four parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '`current-weather.component.css` contains any CSS that is specific to the component
    and is an optional file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`current-weather.component.html` contains the HTML template that defines the
    look of the component and rendering of the bindings, and can be considered the
    View, in combination with any CSS styles used'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`current-weather.component.spec.ts` contains Jasmine-based unit tests that
    you can extend to test your component functionality'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`current-weather.component.ts` contains the `@Component` decorator above the class
    definition and is the glue that ties together the CSS, HTML, and JavaScript code
    together. The class itself can be considered the ViewModel, pulling data from
    services and performing any necessary transformations to expose sensible bindings
    for the View, as shown as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: If the component you're planning to write is a simple one, you can rewrite it
    using inline styles and an inline template, to simplify the structure of your
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update `CurrentWeatherComponent` with an inline template and styles:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'When you executed the generate command, in addition to creating the component,
    the command also added the new module you created to `app.module.ts`, avoiding
    an otherwise tedious task of wiring up components together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The bootstrap process of Angular is, admittedly, a bit convoluted. This is the
    chief reason Angular CLI exists. `index.html` contains an element named `<app-root>`.
    When Angular begins execution, it first loads `main.ts`, which configures the
    framework for browser use and loads the app module. App module then loads all
    its dependencies and renders within the aforementioned `<app-root>` element. In
    [Chapter 7](b35a976c-1709-4f43-9c4e-1cf957e7ca6c.xhtml), *Create a Router-First
    Line-of-Business App*, when we build a line-of-business app, we will create our
    own feature modules to take advantage of the scalability features of Angular.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to display our new component on the initial `AppComponent` template,
    so it is visible to the end user:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `CurrentWeatherComponent` to `AppComponent` by replacing `<div>current
    weather</div>` with `<app-current-weather></app-current-weather>`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'If everything worked correctly, you should see this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](Images/0ae2d6b8-f075-4af4-a501-c31dd137408d.png)Initial render of your
    local weather appNote the icon and name in the tab of the browser window. As a
    web development norm, in the `index.html` file, update the `<title>` tag and the
    `favicon.ico` file with the name and icon of your application to customize the
    browser tab information. If your favicon doesn''t update, append the `href` attribute
    with a unique version number, such as `href="favicon.ico?v=2"`. As a result, your
    app will start looking like a real web app, instead of a CLI-generated starter
    project.'
  prefs: []
  type: TYPE_NORMAL
- en: Define your model using interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that your `View` and `ViewModel` are in place, you need to define your
    `Model`. If you look back on the design, you will see that the component needs
    to display:'
  prefs: []
  type: TYPE_NORMAL
- en: City
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Country
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Current date
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Current image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Current temperature
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Current weather description
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You will first create an interface that represents this data structure:'
  prefs: []
  type: TYPE_NORMAL
- en: In the terminal, execute `npx ng generate interface ICurrentWeather`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Observe a newly generated file named `icurrent-weather.ts` with an empty interface
    definition that looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This is not an ideal setup, since we may add numerous interfaces to our app
    and it can get tedious to track down various interfaces. Over time, as you add
    concrete implementations of these interfaces as classes, then it will make sense
    to put classes and their interfaces in their own files.
  prefs: []
  type: TYPE_NORMAL
- en: Why not just call the interface `CurrentWeather`? This is because later on we
    may create a class to implement some interesting behavior for `CurrentWeather`.
    Interfaces establish a contract, establishing the list of available properties
    on any class or interface that implements or extends the interface. It is always
    important to be aware of when you're using a class versus an interface. If you
    follow the best practice to always start your interface names with a capital `I`,
    you will always be conscious of what type of an object you are passing around.
    Hence, the interface is named `ICurrentWeather`.
  prefs: []
  type: TYPE_NORMAL
- en: Rename `icurrent-weather.ts` to `interfaces.ts`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Correct the capitalization of the interface name to `ICurrentWeather`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Also, implement the interface as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This interface and its eventual concrete representation as a class is the Model
    in MVVM. So far, I have highlighted how various parts of Angular fit the MVVM
    pattern; going forward, I will be referring to these parts with their actual names.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can import the interface into the component and start wiring up the
    bindings in the template of `CurrentWeatherComponent`.
  prefs: []
  type: TYPE_NORMAL
- en: Import `ICurrentWeather`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Switch back to the `templateUrl` and ``styleUrls``
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define a local variable called `current` with type `ICurrentWeather`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'If you just type `current: ICurrentWeather`, you can use the auto-fixer to
    automatically insert the import statement.'
  prefs: []
  type: TYPE_NORMAL
- en: In the constructor, you will temporarily populate the current property with
    dummy data to test your bindings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement dummy data as a JSON object and declare its adherence to `ICurrentWeather`
    using the as operator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In the `src/assets` folder, create a subfolder named `img` and place an image
    of your choice to reference in your dummy data.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may forget the exact properties in the interface you created. You can get
    a quick peek at them by holding *Ctrl* + hover-over the interface name with your
    mouse, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/9875716b-28c2-4286-8436-3365b3357d40.png)*Ctrl* + hover-over the
    interface'
  prefs: []
  type: TYPE_NORMAL
- en: Now you update the template to wire up your bindings with a rudimentary HTML-based
    layout.
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement the template:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: To change the display formatting of `current.date`, we used the `DatePipe` above,
    passing in `'fullDate'` as the format option. In Angular, various out-of-the-box
    and custom pipe `|` operators can be used to change the appearance of data without
    actually changing the underlying data. This is a very powerful, convenient, and
    flexible system to share such user interface logic without writing repetitive
    boilerplate code. In the preceding example, we could pass in `'shortDate'` if
    we wanted to represent the current date in a more compact form. For more information
    on various `DatePipe` options, refer to the documentation at [https://angular.io/api/common/DatePipe](https://angular.io/api/common/DatePipe). To
    format `current.temperature` so that no fractional values are shown, you can use
    `DecimalPipe`. The documentation is at [https://angular.io/api/common/DecimalPipe](https://angular.io/api/common/DecimalPipe).
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can render ℃ and ℉ using their respective HTML codes: ![](Images/3aead4cb-5060-4f39-99ff-77e8378a22e7.png) for
    ℃ and ![](Images/e8c94057-be77-44bd-9f19-f7c814114fa2.png) for ℉.
  prefs: []
  type: TYPE_NORMAL
- en: 'If everything worked correctly, you app should be looking similar to this screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](Images/39d31e79-3c3f-482d-993a-01450525f3d9.png)App after wiring up bindings
    with dummy data'
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations, you have successfully wired up your first component.
  prefs: []
  type: TYPE_NORMAL
- en: Using Angular Services and HttpClient to retrieve data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now you need to connect your `CurrentWeather` component to the `OpenWeatherMap`
    APIs. In the upcoming sections, we will go over the following steps to accomplish
    this goal:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Angular Service
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import `HttpClientModule` and inject it into the service
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Discover the `OpenWeatherMap` API
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new interface that conforms to the shape of the API
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a `get` request
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inject the new service into the `CurrentWeather` component
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call the service from the `init` function of the `CurrentWeather` component
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, map the API data to the local `ICurrentWeather` type using RxJS functions
    so that it can be consumed by your component
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating a new Angular Service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Any code that touches outside of the boundaries of a component should exist
    in a service; this includes inter-component communication, unless there's a parent-child
    relationship, and API calls of any kind and any code that cache or retrieve data
    from a cookie or the browser's localStorage. This is a critical architectural
    pattern that keeps your application maintainable in the long term. I expand upon
    this idea in my DevPro MVVM article at [http://bit.ly/MVVMvsMVC](http://bit.ly/MVVMvsMVC).
  prefs: []
  type: TYPE_NORMAL
- en: 'To create an Angular service, do this:'
  prefs: []
  type: TYPE_NORMAL
- en: In the terminal, execute `npx ng g s weather --flat false`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Observe the new `weather` folder created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'A generated service has two parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '`weather.service.spec.ts` contains Jasmine-based unit tests that you can extend
    to test your service functionality.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`weather.service.ts` contains the `@Injectable` decorator above the class definition,
    which makes it possible to inject this service into other components, leveraging
    Angular''s provider system. This will ensure that our service will be a singleton,
    meaning only instantiated once, no matter how many times it is injected elsewhere.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The service is generated, but it''s not automatically provided. To do this,
    follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open `app.module.ts`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type in `WeatherService` inside the providers array
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use the auto-fixer to import the class for you:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: If you installed the recommended extension TypeScript Hero, the import statement
    will be automatically added for you. You won't have to use the auto-fixer to do
    it. Going forward, I will not call out the need to import modules.
  prefs: []
  type: TYPE_NORMAL
- en: Inject dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to make API calls, you will be leveraging the `HttpClient` module
    in Angular. The official documentation ([https://angular.io/guide/http](https://angular.io/guide/http))
    explains the benefits of this module succinctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '"With HttpClient, @angular/common/http provides a simplified API for HTTP functionality
    for use with Angular applications, building on top of the XMLHttpRequest interface
    exposed by browsers. Additional benefits of HttpClient include testability support,
    strong typing of request and response objects, request and response interceptor
    support, and better error handling via APIs based on Observables."'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with importing the `HttpClientModule` in to our app, so we can
    inject the `HttpClient` within the module into the `WeatherService`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add `HttpClientModule` to `app.module.ts`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Inject `HttpClient` provided by the `HttpClientModule` in the  `WeatherService`, as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Now, `httpClient` is ready for use in your service.
  prefs: []
  type: TYPE_NORMAL
- en: Storing environment variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s easy to miss, but the sample URL from previous sections contains a required `appid` parameter.
    You must store this key in your Angular app. You can store it in the weather service,
    but in reality, applications need to be able to target different sets of resources
    as they move from development to testing, staging, and production environments.
    Out of the box, Angular provides two environments: one `prod` and the other one
    as the default.'
  prefs: []
  type: TYPE_NORMAL
- en: Before you can continue, you need to sign up for a free `OpenWeatherMap` account
    and retrieve your own `appid`. You can read the documentation for `appid` at [http://openweathermap.org/appid ](http://openweathermap.org/appid)for
    more detailed information.
  prefs: []
  type: TYPE_NORMAL
- en: Copy your `appid`, which will have a long string of characters and numbers
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Store your `appid `in `environment.ts`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Configure `baseUrl` for later use:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: In code, we use a camel-case `appId` to keep our coding style consistent. Since
    URL parameters are case-insensitive, `appId` will work as well as `appid`.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing an HTTP GET operation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we can implement the GET call in the Weather service:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a new function to the `WeatherService` class named `getCurrentWeather`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import the `environment` object
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement the `httpClient.get` function
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Return the results of the HTTP call:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Note the use of ES2015's String Interpolation feature. Instead of building your
    string by appending variables to one another like `environment.baseUrl + 'api.openweathermap.org/data/2.5/weather?q='
    + city + ',' + country + '&appid=' + environment.appId`, you can use the backtick
    syntax to wrap ``your string``. Inside the backticks, you can have newlines and
    also directly embed variables into the flow of your string by wrapping them with
    the `${dollarbracket}` syntax. However, when you introduce a newline in your code,
    it will be interpreted as a literal newline—`\n`. In order to break up the string
    in your code, you may add a backslash `\`, but then the next line of your code
    can have no indentation. It is easier to just concatenate multiple templates,
    as shown in the preceding code sample.Note the use TypeScript Generics with the
    get function using the caret syntax like `<TypeName>`. Using generics is development-time
    quality of life feature. By providing the type information to the function, input
    and/or return variables types of that function will be displayed as your write
    your code and validated during development and also at compile time.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving service data from a component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To be able to use the `getCurrentWeather` function in the `CurrentWeather`
    component, you need to inject the service into the component:'
  prefs: []
  type: TYPE_NORMAL
- en: Inject the `WeatherService` into the constructor of the `CurrentWeatherComponent`
    class
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Remove the existing code that created the dummy data in the constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Call the `getCurrentWeather` function inside the `ngOnInit` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Fair warning, do not expect this code to be working just yet. You should see
    an error, so let's understand what's going in the next segment.
  prefs: []
  type: TYPE_NORMAL
- en: Angular components have a rich collection of life cycle hooks that allow you
    to inject your custom behavior, when a component is being rendered, refreshed,
    or destroyed. `ngOnInit()` is the most common life cycle hook you will be using.
    It is only called once, when a component is first instantiated or visited. This
    is where you will want to perform your service calls. For a deeper understanding
    of component life cycle hooks, check out the documentation at [https://angular.io/guide/lifecycle-hooks](https://angular.io/guide/lifecycle-hooks).Note
    that the anonymous function you have passed to `subscribe` is an ES2015 arrow
    function. If you're not familiar with arrow functions, it may be confusing at
    first. Arrow functions are actually quite elegant and simple.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following arrow function:'
  prefs: []
  type: TYPE_NORMAL
- en: '`(data) => { this.current = data }`'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can rewrite it simply as:'
  prefs: []
  type: TYPE_NORMAL
- en: '`function(data) { this.current = data }`'
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s a special condition—when you write an arrow function that simply transforms
    a piece of data, such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`(data) => { data.main.temp }`'
  prefs: []
  type: TYPE_NORMAL
- en: 'This function effectively takes `ICurrentWeatherData` as an input and returns
    the temp property. The return statement is implicit. If you rewrite it as a regular
    function, it will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`function(data) { return data.main.temp }`'
  prefs: []
  type: TYPE_NORMAL
- en: When the `CurrentWeather` component loads, `ngOnInit` will fire once, which
    will call the `getCurrentWeather` function that returns an object with a type
    of `Observable<ICurrentWeatherData>`. An Observable, as described in the official
    documentation, *is the most basic building block of RxJS* that represents an event
    emitter, which will emit any data received over time with the type of `ICurrentWeatherData`.
    The `Observable` object by itself is benign and will not cause a network event
    to be fired unless it is being listened to. You can read more about Observables
    at [reactivex.io/rxjs/class/es6/Observable.js~Observable.html](http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html).
  prefs: []
  type: TYPE_NORMAL
- en: By calling `.subscribe` on the Observable, you're essentially attaching a listener
    to the emitter. You've implemented an anonymous function within the `subscribe`
    method, which will get executed whenever a new piece of data is received and an
    event is emitted. The anonymous function takes a data object as a parameter, and,
    the specific implementation in this case, assigns the piece of data to the local
    variable named current. Whenever current is updated, the template bindings you
    implemented earlier will pull in the new data and render it on the view. Even
    though `ngOnInit` executes only once, the subscription to the Observable persists.
    So whenever there's new data, the current variable will be updated and the view
    will rerender to display the latest data.
  prefs: []
  type: TYPE_NORMAL
- en: The root cause of the error at hand is that the data that is being emitted is
    of type `ICurrentWeatherData`; however, our component only understands data that
    is shaped as described by the `ICurrentWeather` interface. In the next section,
    you will need to dig deeper into RxJS to understand how best to accomplish that
    task.
  prefs: []
  type: TYPE_NORMAL
- en: 'Beware, VS Code and CLI sometimes stop working. As previously noted, as you
    code, the `npm start` command is running in the integrated terminal of VS Code.
    Angular CLI, in combination with the Angular Language Service plug-in, continuously
    watches for code changes and transpiles your TypeScript code to JavaScript, so
    you can observe your changes with live-reloading in the browser. The great thing
    is that when you make coding errors, in addition to the red underlining in VS
    Code, you will also see some red text in the terminal or even the browser, because
    the transpilation has failed. In most cases, when correcting the error, the red
    underlining will go away and Angular CLI will automatically retranspile your code
    and everything will work. However, under certain scenarios, you will note that
    VS Code will fail to pick typing changes in the IDE, so you won''t get autocompletion
    help or the CLI tool will get stuck with message saying webpack: Failed to compile.
    You have two main strategies to recover from such conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: Click on the terminal and hit *Ctrl* + *C*to stop running the CLI task and restart
    by executing `npm start`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If **#1** doesn't work, quit VS Code with *Alt* + *F4* for Windows or ⌘ + *Q*
    for macOS and restart it
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Given Angular and VS Code's monthly releases cycles, I'm confident that in time
    the tooling can only improve.
  prefs: []
  type: TYPE_NORMAL
- en: Transform data using RxJS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: RxJS stands for Reactive Extensions, which is a modular library that enables
    reactive programming, which itself is an asynchronous programming paradigm and
    allows for manipulation of data streams through transformation, filtering, and
    control functions. You can think of reactive programming as an evolution of event-based
    programming.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Reactive programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Event-Driven programming, you would define an event handler and attach it
    to an event source. In more concrete terms, if you had a save button, which exposes
    an `onClick` event, you would implement a `confirmSave` function, which when triggered,
    would show a popup to ask the user Are you sure?. Look at the following figure
    for a visualization of this process.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/087093d4-6cc4-4942-b53f-61a0cbce08f8.png)Event-Driven Implementation'
  prefs: []
  type: TYPE_NORMAL
- en: In short, you would have an event firing once per user action. If the user clicks
    on the save button many times, this pattern would gladly render as many popups
    as there are clicks, which doesn't make much sense.
  prefs: []
  type: TYPE_NORMAL
- en: The publish-subscribe (pub/sub) pattern is a different type of event-driven
    programming. In this case, we can write multiple handlers to act on the result
    of a given event all simultaneously. Let's say that your app just received some
    updated data. The publisher will go through its list of subscribers and pass on
    the updated data to each of them. Refer to the following diagram, how can updated
    data event trigger an `updateCache` function that can update your local cache
    with new data, a `fetchDetails` function that can retrieve further details about
    the data from the server, and also a `showToastMessage` function that can inform
    the user that the app just received new data. All these events can happen asynchronously;
    however, the `fetchDetails` and `showToastMessage` functions will be receiving
    more data than they really need, and it can get really convoluted to try to compose
    these events in different ways to modify application behavior.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/cfdf8261-a38b-401f-97b8-3f23210b81bf.png)Pub/Sub Pattern Implementation'
  prefs: []
  type: TYPE_NORMAL
- en: In reactive programming, everything is treated as a stream. A stream will contain
    events that happen over time and these events can contain some data or no data.
    The following diagram visualizes a scenario where your app is listening for mouse
    clicks from the user. Uncontrolled streams of user clicks are meaningless. You
    exert some control over this stream by applying the `throttle` function to it,
    so you only get updates every 250 **milliseconds** (**ms**). If you subscribe
    to this new event, every 250 ms, you will receive a list of click events. You
    may try to extract some data from each click event, but in this case, you're only
    interested in the number of click events that happened. We can shape the raw event
    data into number of clicks using the `map` function.
  prefs: []
  type: TYPE_NORMAL
- en: Further down the stream, we may only be interested in listening for events with
    two or more clicks in it, so we can use the `filter` function to only act on what
    is essentially a double-click event. Every time our filter event fires, it means
    that the user intended to double-click, and you can act on that information by
    popping up an alert. The true power for streams comes from the fact that you can
    choose to act on the event at any time as it passes through various control, transformation,
    and filter functions. You can choose to display click data on an HTML list using
    `*ngFor` and Angular's `async` pipe, so the user can monitor the types of click
    data being captured every 250ms.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/e47a3a03-78c2-45ee-ae01-35bae1e77478.png)A Reactive Data Stream
    Implementation'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing Reactive transformations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To avoid future mistakes in returning the unintended type of data from your
    service, you need to update the `getCurrentWeather` function to define the return
    type to be `Observable<ICurrentWeather>` and import the `Observable` type, as
    shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, VS Code will let you know that Type `Observable<ICurrentWeatherData>` is
    not assignable to type `Observable<ICurrentWeather>`:'
  prefs: []
  type: TYPE_NORMAL
- en: Write a transformation function named `transformToICurrentWeather` that can
    convert `ICurrentWeatherData` to `ICurrentWeather`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Also, write a helper function named `convertKelvinToFahrenheit` that converts
    the API provided Kelvin temperature to Fahrenheit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Note that you need to be converting the icon property to an image URL at this
    stage. Doing this in the service helps preserve encapsulation, binding the icon
    value to the URL in the view template will break the **Separation of concerns**
    (**SoC**) principle. If you wish to create truly modular, reusable, and maintainable
    components, you must remain vigilant and strict in terms of enforcing SoC. The
    documentation for Weather Icons and details of how the URL should be formed, including
    all the available icons can be found at [http://openweathermap.org/weather-conditions](http://openweathermap.org/weather-conditions).On
    a separate note, the argument can be made that Kelvin to Fahrenheit conversion
    is actually a view concern, but we have implemented it in the service. This argument
    holds water, especially considering that we have a planned feature to be able
    to toggle between Celsius and Fahrenheit. A counter argument would be that at
    this time, we only need to display in Fahrenheit and it is part of the job of
    the weather service to be able to convert the units. This argument makes sense
    as well. The ultimate implementation will be to write a custom Angular Pipe and
    apply it in the template. A pipe can easily bind with the planned toggle button
    as well. However, at this time, we only need to display in Fahrenheit and I would
    err on the side of *not*over-engineering a solution.
  prefs: []
  type: TYPE_NORMAL
- en: Update `ICurrentWeather.date` to the `number` type
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: While writing the transformation function, you will note that the API returns
    the date as a number. This number represents time in seconds since the UNIX epoch
    (timestamp), which is January 1st, 1970 00:00:00 UTC. However, `ICurrentWeather`
    expects a `Date` object. It is easy enough to convert the timestamp by passing
    it into the constructor of the `Date` object like `new Date(data.dt)`. This is
    fine, but also unnecessary, since Angular's `DatePipe` can directly work with
    the timestamp. In the name of relentless simplicity and maximally leveraging the
    functionality of the frameworks we use, we will update `ICurrentWeather` to use
    `number`. There's also a performance and memory benefit to this approach if you're
    transforming massive amounts of data, but that concern is not applicable here. There's
    one caveat—JavaScript's timestamp is in milliseconds, but the server value is
    in seconds, so a simple multiplication during the transformation is still required.
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the RxJS `map` operator right below the other import statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: It may seem odd to have to manually import the `map` operator. RxJS is a very
    capable framework with a wide API surface. Observable alone has over 200 methods
    attached to it. Including all of these methods by default creates development
    time issues with too many functions to choose from and also, it negatively impacts
    the size of the final deliverable, including app performance and memory use. So
    you must add each operator you intend to use individually.
  prefs: []
  type: TYPE_NORMAL
- en: Apply the `map` function to data stream returned by  `httpClient.get` method
    through a `pipe`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Pass the `data` object into the `transformToICurrentWeather` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Now incoming data can be transformed as it flows through the stream, ensuring
    that the `OpenWeatherMap` Current Weather API data is in the correct shape, so
    it can be consumed by the `CurrentWeather` component.
  prefs: []
  type: TYPE_NORMAL
- en: Ensure that your app compiles successfully
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inspect the results in the browser:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](Images/acb5fa9f-0a66-4115-ac92-88f29e710067.png)Displaying Live Data from
    OpenWeatherMap'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you should see that your app is able to pull live data from `OpenWeatherMap`
    and correctly transform server data into the format you expect.
  prefs: []
  type: TYPE_NORMAL
- en: You have completed the development of Feature 1: Display Current Location weather
    information for the current day. Commit your code and move the card in Waffle
    to the Done column.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we can move this task to the Done column:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](Images/ae1e16d3-ee5c-4476-b31a-59a191e05af7.png)Waffle.io Kanban Board
    Status'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Congratulations, in this chapter, you created your first Angular application
    with a flexible architecture while avoiding over-engineering. This was possible
    because we first built a road map and codified it in a Kanban board that is visible
    to your peers and colleagues. We stayed focused on implementing the first feature
    we put in progress and didn't deviate from the plan.
  prefs: []
  type: TYPE_NORMAL
- en: You can now use Angular CLI and an optimized VS Code development environment
    to help you reduce the amount of coding you need to do. You can leverage TypeScript
    anonymous types and observable streams to accurately reshape complicated API data
    into a simple format without having to create one-use interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: You learned to avoid coding mistakes by proactively declaring input and return
    types of functions and working with generic functions. You used the date and decimal
    pipes to ensure that the data is formatted as desired, while keeping formatting-related
    concerns mostly in the template, where this kind of logic belongs.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you used interfaces to communicate between components and services
    without leaking the external data structure to internal components. By applying
    all these techniques in combination, which Angular, RxJS, and TypeScript have
    allowed us to do, you have ensured proper separation of concerns and encapsulation.
    As a result, the `CurrentWeather` component is now a truly reusable and composable
    component; this is not an easy feat to achieve.
  prefs: []
  type: TYPE_NORMAL
- en: If you don't ship it, it never happened. In the next chapter, we will prepare
    this Angular app for a production release by troubleshooting application errors,
    ensuring automated unit and e2e tests pass and containerizing the Angular app
    with Docker, so it can be published on the web.
  prefs: []
  type: TYPE_NORMAL
