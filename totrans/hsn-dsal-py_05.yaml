- en: Stacks and Queues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are going to build upon the skills we learned in the last
    chapter in order to create special list implementations. We are still sticking
    to linear structures. We will get into the details of more complex data structures
    in the coming chapters.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we are going to understand the concepts of stacks and queues.
    We will also implement these data structures in Python using various methods such
    as `lists` and `node`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing stacks and queues using various methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some real-life example applications of stacks and queues
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You should have a computer system on which Python is installed. All the programs
    based on the concepts discussed in this chapter are provided in the book as well
    as the GitHub repository at the following link: [https://github.com/PacktPublishing/Hands-On-Data-Structures-and-Algorithms-with-Python-Second-Edition/tree/master/Chapter05](https://github.com/PacktPublishing/Hands-On-Data-Structures-and-Algorithms-with-Python-Second-Edition/tree/master/Chapter05).'
  prefs: []
  type: TYPE_NORMAL
- en: Stacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A stack is a data structure that stores data, similar to a stack of plates
    in a kitchen. You can put a plate on the top of the stack, and when you need a
    plate, you take it from the top of the stack. The last plate that was added to
    the stack will be the first to be picked up from the stack. Similarly, a stack
    data structure allows us to store and read data from one end, and the element
    which is added last is picked up first. Thus, a stack is a **last in, first out**
    (**LIFO**) structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/7db7f285-a46b-405d-a964-5a7367bb4533.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding diagram depicts a stack of plates. Adding a plate to the pile
    is only possible by leaving that plate on top of the pile. To remove a plate from
    the pile of plates means to remove the plate that is on top of the pile.
  prefs: []
  type: TYPE_NORMAL
- en: There are two primary operations that are performed on stacks—`push` and `pop`.
    When an element is added to the top of the stack, it is pushed onto the stack.
    When an element is to be picked up from the top of the stack, it is popped off
    the stack. Another operation that is used sometimes is `peek`, which makes it
    possible to see the element on top of the stack without popping it off.
  prefs: []
  type: TYPE_NORMAL
- en: 'Stacks are used for a number of things. One very common usage for stacks is
    to keep track of the return address during function calls. Let''s imagine that
    we have the following program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'When the program execution gets to the call to `a()`, the following happens:'
  prefs: []
  type: TYPE_NORMAL
- en: It first pushes the address of the current instruction onto the stack, then
    jumps to the definition of `a`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside function `a()`, the function `b()` is called
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: And, the return address of the function `b()` is pushed onto the stack
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the execution of the instructions in `b()` and the function are complete,
    the return address is popped off the stack, which takes us back to function `a()`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When all the instructions in function `a` are completed, the return address
    is again popped off from the stack, which takes us back to the `main` function
    and the `print` statement
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Stacks are also used to pass data between functions. Consider the following
    example. Say you have the following function call somewhere in your code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'What happens internally is that the values passed by the functions `14, ''eggs'',
    ''ham''`, and `''spam''` will be pushed onto the stack, one at a time, as shown
    in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/90a07abc-4ef2-4623-ab9b-73bfc8b6c7a2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When the code calls jump to the definition of the function, the values for
    `a, b, c, d` will be popped off the stack. The `spam` element will be popped off
    first and assigned to `d`, then `ham` will be assigned to `c`, and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Stack implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Stacks can be implemented in Python using node. We start off by creating a
    `node` class, as we did in the previous chapter with lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As we discussed, a node holds data and a reference to the next item in a list.
    Here, we are going to implement a stack instead of a list; however, the same principle
    of nodes works here—nodes are linked together through references.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let us look at the `stack` class. It starts off in a similar way to a singly
    linked list. We will need two things to implement a stack using nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: We first need to know the node which is at the top of the stack so that we will
    be able to apply the `push` and `pop` operations through this node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We would also like to keep track of the number of nodes in the stack, so we
    add a `size` variable to the stack class. Consider the following code snippet
    for the stack class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Push operation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `push` operation is an important operation on a stack; it is used to add
    an element at the top of the stack. We implement the push functionality in Python
    to understand how it works.  At first, we check if the stack already has some
    items in it or it is empty when we wish to add a new node in the stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the stack already has some elements, then we have to do two things:'
  prefs: []
  type: TYPE_NORMAL
- en: The new node must have its next pointer pointing to the node that was at the
    top earlier.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We put this new node at the top of the stack by pointing `self.top` to the
    newly added node. See the two instructions in the following diagram:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](Images/e27ba744-6175-41ae-afc1-0ee0b18031cb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If the existing stack is empty, and the new node to be added is the first element,
    we need to make this node the top node of the element. Thus, `self.top` will point
    to this new node. See the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/3c415c87-cfa5-41e5-87b9-35283f6d50fd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following is globally the complete implementation of the `push` operation
    in `stack`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Pop operation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we need another important function of the stack, and that is the `pop`
    operation. It reads the topmost element of the stack and removes it from the stack.
    The `pop` operation returns the topmost element of the stack and returns `None`
    if the stack is empty.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement the `pop` operation on a stack:'
  prefs: []
  type: TYPE_NORMAL
- en: First, check if the stack is empty. The `pop` operation is not allowed on an
    empty stack.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If the stack is not empty, it can be checked if the top node has its **next** attribute
    pointing to some other node. It means the stack has elements, and the topmost
    node is pointing to the next node in the stack. To apply the `pop` operation,
    we have to change the top pointer. The next node should be at the top. We do this
    by pointing `self.top` to `self.top.next`. See the following diagram to understand
    this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](Images/45afd13e-ada4-4424-b49e-5e78b9e2c4c1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When there is only one node in the stack, the stack will be empty after the
    pop operation. We have to change the top pointer to `None`. See the following
    diagram:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](Images/ee07d980-b726-4efe-bbc7-ac9a7bb29cb3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Removing such a node results in `self.top` pointing to `None`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](Images/c6831f6e-a390-4a57-b4cc-9abd84efb305.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We also decrement the size of the stack by `1` if the stack is not empty. Here
    is the complete code for the `pop` operation for `stack` in Python:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Peek operation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is another important operation that can be applied on stacks—the `peek`
    method. This method returns the top element from the stack without deleting it
    from the stack. The only difference between `peek` and `pop` is that the `peek` method
    just returns the topmost element; however, in the case of a `pop` method, the
    topmost element is returned and also that element is deleted from the stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'The pop operation allows us to look at the top element without changing the
    stack. This operation is very straightforward. If there is a top element, return
    its data; otherwise, return `None` (thus, the behavior of `peek` matches that
    of `pop`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Bracket-matching application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now let us look at an example application showing how we can use our stack implementation.
    We are going to write a little function that will verify whether a statement containing
    brackets—`(`, `[`,  or  `{`—is balanced, that is, whether the number of closing
    brackets matches the number of opening brackets. It will also ensure that one
    pair of brackets really is contained in another:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Our function parses each character in the statements passed to it. If it gets
    an open bracket, it pushes it onto the stack. If it gets a closing bracket, it
    pops the top element off the stack and compares the two brackets to make sure
    their types match, `(` should match `)`, `[` should match `]`, and `{` should
    match `}`. If they don't, we return `False`; otherwise, we continue parsing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we reach the end of the statement, we need to do one last check. If the
    stack is empty, then it is fine and we can return `True`. But if the stack is
    not empty, then we have an opening bracket that does not have a matching closing
    bracket and we will return `False`. We can test the bracket-matcher with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Only the first of the three statements should match. And when we run the code,
    we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/17bdec19-ac8d-4124-bb4e-16767635d5e8.png)'
  prefs: []
  type: TYPE_IMG
- en: The output of the preceding code is `True`, `False`, and `False`.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, the `push` and `pop` operations of the stack data structure attract
    a complexity of *O(1)*. The stack data structure is simple; however, it is used
    to implement many functionalities in real-world applications. The back and forward
    buttons in the browser are implemented using the stacks. Stacks are also used
    to implement the undo and redo functionalities in word processors.
  prefs: []
  type: TYPE_NORMAL
- en: Queues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another special type of list is the queue data structure. The queue data structure
    is very similar to the regular queue you are accustomed to in real life. If you
    have stood in line at an airport or to be served your favorite burger at your
    neighborhood shop, then you should know how things work in a queue.
  prefs: []
  type: TYPE_NORMAL
- en: Queues are very fundamental and an important concept to grasp since many other
    data structures are built on them.
  prefs: []
  type: TYPE_NORMAL
- en: 'A queue works as follows. The first person to join the queue usually gets served
    first, and everyone will be served in the order of how they joined the queue.
    The acronym FIFO best explains the concept of a queue. **FIFO** stands for **first
    in, first out**. When people are standing in a queue waiting for their turn to
    be served, service is only rendered at the front of the queue. The only time people
    exit the queue is when they have been served, which only occurs at the very front
    of the queue. See the following diagram, where people are standing in the queue,
    and the person in the front would be served first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/e5fb97b2-07a9-4729-b679-8b1f1727db3f.png)'
  prefs: []
  type: TYPE_IMG
- en: To join the queue, participants must stand behind the last person in the queue.
    This is the only legal or permitted way the queue accepts new entrants. The length
    of the queue does not matter.
  prefs: []
  type: TYPE_NORMAL
- en: We shall provide various implementations of a queue, but this will revolve around
    the same concept of FIFO. The item added first will be read first. We shall call
    the operation to add an element to the queue as `enqueue`. When we delete an element
    from the queue, we shall call this a `dequeue` operation. Whenever an element
    is enqueued, the length or size of the queue increments by 1\. Conversely, dequeuing
    items reduces the number of elements in the queue by 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate the two operations, the following table shows the effects of
    adding and removing elements from a queue:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Queue operation** | **Size** | **Contents** | **Operation results** |'
  prefs: []
  type: TYPE_TB
- en: '| `Queue()` | 0 | `[]` | Queue object created, which is empty.  |'
  prefs: []
  type: TYPE_TB
- en: '| `Enqueue` Packt  | 1 | `[''Packt'']` |  One item *Packt* is added to queue.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Enqueue` Publishing  | 2 | `[''Publishing'', ''Packt'']` | One more item
    *Publishing *is added to the queue.  |'
  prefs: []
  type: TYPE_TB
- en: '| `Size()` | 2 | `[''Publishing'', ''Packt'']` | Return the number of items
    in the queue, which is 2 in this example. |'
  prefs: []
  type: TYPE_TB
- en: '| `Dequeue()` | 1 | `[''Publishing'']` | The *Packt* item is dequeued and returned.
    (This item  was added first, so it is removed first.) |'
  prefs: []
  type: TYPE_TB
- en: '| `Dequeue()` | 0 | `[]` | The *Publishing* item is dequeued and returned.
    (This is the last item added, so it is returned last.) |'
  prefs: []
  type: TYPE_TB
- en: List-based queues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Queues can be implemented using various methods such as `list`, `stack`, and
    `node`. We shall discuss the implementation of queues using all these methods
    one by one. Let''s start by implementing a queue using Python''s `list` class.
    This is to help us quickly learn about queues. The operations that must be performed
    on the queue are encapsulated in the `ListQueue` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In the initialization method, `__init__`, the `items` instance variable is set
    to `[]`, which means the queue is empty when created. The size of the queue is
    also set to `zero`. The `enqueue` and `dequeue` are important methods in queues,
    and we will discuss them in the next subsections.
  prefs: []
  type: TYPE_NORMAL
- en: The enqueue operation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `enqueue` operation adds an item to the queue. It uses the `insert` method
    of the `list` class to insert items (or data) at the front of the list. See the
    following code for the implementation of the `enqueue` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: It is important to note how we implement insertions in queues using list. The
    concept is that we add the items at index `0` in a list; it is the first position
    in an array or list. To understand the concept of how the queue works when we
    add items at index `0` in a list, consider the following diagram. We start with
    an empty list. Initially, we add an item `1` at index `0`. Next, we add an item
    `2` at index `0`; it will shift the previously added item to the next index.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, when we again add a new item `3` to the list at index `0`, all the items
    already added to the list are shifted, as shown in the following figure. Similarly,
    when we add item `4` at index `0`, all the items are shifted in the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/3f3d2269-8c89-4dcd-88b6-986e1ff83407.png)'
  prefs: []
  type: TYPE_IMG
- en: Thus, in our implementation of a queue using a Python list, the array index
    `0` is the only place where new data elements are inserted into the queue. The
    `insert` operation will shift existing data elements in the list by one position
    up and then insert the new data in the space created at index `0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make our queue reflect the addition of the new element, the size is increased
    by `1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We could have used Python's `shift` method on the list as another way of implementing
    the insert at `0`.
  prefs: []
  type: TYPE_NORMAL
- en: The dequeue operation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `dequeue` operation is used to delete items from the queue. This method returns
    the topmost item from the queue and deletes it from the queue. Here is the implementation
    of the `dequeue` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The Python `list` class has a method called `pop()`. The `pop` method does
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Deletes the last item from the list
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Returns the deleted item from the list back to the user or code that called
    it
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The last item in the list is popped and saved in the `data` variable. In the
    last line of the method, the data is returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following figure as our queue implementation, where three elements
    are added—`1`, `2`, and `3`. To perform a `dequeue` operation, the node with data
    `1` is removed from the front of the queue as it was added first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/26a4406e-d047-41ca-a5ac-802bf0f38a3a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The resulting elements in the queue are shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/57d7bcfd-6bd3-40eb-9fac-9d062009f56f.png)'
  prefs: []
  type: TYPE_IMG
- en: The `enqueue` operation is very inefficient due to one reason. The method has
    to first shift all the elements by one space. Imagine there are 1 million elements
    in a list which need to be shifted around any time a new element is being added
    to the queue. This will make the enqueue process very slow for large lists.
  prefs: []
  type: TYPE_NORMAL
- en: Stack-based queues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Queues can also be implemented using two stacks. We initially set two instance
    variables to create an empty queue upon initialization. These are the stacks that
    will help us to implement a queue. The stacks, in this case, are simply Python
    lists that allow us to call `push` and `pop` methods on them, which eventually
    allow us to get the functionality of `enqueue` and `dequeue` operations. Here
    is the `Queue` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `inbound_stack` is only used to store elements that are added to the queue.
    No other operation can be performed on this stack.
  prefs: []
  type: TYPE_NORMAL
- en: Enqueue operation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `enqueue` method is to add items to the queue. This method is very simple
    and only receives the `data` to append to the queue. This data is then passed
    to the `append` method of the `inbound_stack` in the `queue` class. Further, the `append` method
    is used to mimic the `push` operation, which pushes elements to the top of the
    stack. The following code is the implementation of `enqueue` using the stack in
    Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'To `enqueue` data onto the `inbound_stack`, the following code does the job:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'A command-line output of the `inbound_stack` inside the queue is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Dequeue operation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `dequeue` operation is used to delete the elements from the queue in the
    order of items added. New elements added to our queue end up in the `inbound_stack`.
    Instead of removing elements from the `inbound_stack`, we shift our attention
    to another stack, that is, `outbound_stack`. We shall delete the elements from
    our queue only through the `outbound_stack`.
  prefs: []
  type: TYPE_NORMAL
- en: To understand how `outbound_stack` can be used to delete the items from the
    queue, let us consider the following example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Initially, our `inbound_stack` was filled with the elements **5**, **6**, and **7**,
    as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/445b36d4-1c69-4ec0-bba4-7588a994ea88.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We first check if the `outbound_stack` is empty or not. As it is empty at the
    start, we move all the elements of the `inbound_stack` to the `outbound_stack`
    using the `pop` operation on the stack.  Now the `inbound_stack` becomes empty
    and the `outbound_stack` keeps the elements. We show this in the following diagram
    for more clarity:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/9e911f2b-2f63-4ff0-b4ad-ec6f2d1e1860.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, if the `outbound_stack` is not empty, we proceed to remove the items from
    the queue using the `pop` operation. In the preceding figure, when we apply the `pop`
    operation on `outbound_stack`, we get the element `5`, which is correct as it
    was added first and should be the first element to be popped off from the queue.
    This leaves the `outbound_stack` with only two elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/414ded21-9d68-426a-84e5-eed9190d9f37.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here is the implementation of the `dequeue` method for the queue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `if` statement first checks whether the `outbound_stack` is empty or not.
    If it is not empty, we proceed to remove the element at the front of the queue
    using the `pop` method, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'If the `outbound_stack` is empty instead, all the elements in the `inbound­_stack` are
    moved to the `outbound_stack` before the front element in the queue is popped
    out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `while` loop will continue to be executed as long as there are elements
    in the `inbound_stack`.
  prefs: []
  type: TYPE_NORMAL
- en: The `self.inbound_stack.pop()` statement will remove the latest element that
    was added to the `inbound_stack` and immediately passes the popped data to the `self.outbound_stack.append()` method
    call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us consider an example code to understand the operations on the queue.
    We firstly use the queue implementation to add three items in the queue,that is, `5`,
    `6`, and `7`. Next, we apply dequeue operations to remove items from the queue.
    Here is the code :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The output for the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code snippet firstly adds elements to a queue and prints out the
    elements within the queue. Next, the `dequeue` method is called, after which a
    change in the number of elements is observed when the queue is printed out again.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a queue with two stacks is very important and questions about this
    are often posed during interviews.
  prefs: []
  type: TYPE_NORMAL
- en: Node-based queues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using a Python list to implement a queue is a good start to get a feel for how
    queues work. It is also possible for us to implement our own queue data structure
    by utilizing pointer structures.
  prefs: []
  type: TYPE_NORMAL
- en: A queue can be implemented using a doubly linked list, and `insertion` and `deletion`
    operations on this data structure, and that has a time complexity of `*O(1)*`.
  prefs: []
  type: TYPE_NORMAL
- en: The definition for the `node` class remains the same as the `Node` we defined
    when we discussed in the doubly linked lists. A doubly linked list can be treated
    as a queue if it enables a FIFO kind of data access, where the first element added
    to the list is the first to be removed.
  prefs: []
  type: TYPE_NORMAL
- en: Queue class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `queue` class is very similar to that of the doubly linked `list` class
    and the `Node` class to adding a node in a doubly linked list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Initially, the `self.head` and `self.tail` pointers are set to `None` upon creation
    of an instance of the `queue` class. To keep a count of the number of nodes in
    `Queue`, the `count` instance variable is also maintained here and initially set
    to `0`.
  prefs: []
  type: TYPE_NORMAL
- en: The enqueue operation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Elements are added to a `Queue` object via the `enqueue` method. The elements
    or data are added through nodes. The `enqueue` method code is very similar to
    the `append` operation of the doubly linked list which we discussed in [Chapter
    4](234b9cb7-47a2-4910-8039-d7fed6c4af81.xhtml), *Lists and Pointer Structures*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The enqueue operation creates a node from the data passed to it and appends
    it to the `tail` of the queue, and points both `self.head` and `self.tail` to
    the newly created node if the queue is empty. The total count of elements in the
    queue is increased by the line `self.count += 1`. If the queue is not empty, the
    new node''s previous variable is set to the tail of the list, and the tail''s
    next pointer (or variable) is set to the new node. Lastly, we update the tail
    pointer to point to the new node. This is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The dequeue operation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The other operation that makes our doubly linked list behave as a queue is
    the `dequeue` method. This method removes the node at the front of the queue. To
    remove the first element pointed to by `self.head`, an `if` statement is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '`current` is initialized by pointing it to `self.head`. If `self.count` is
    `1`, then it means only one node is in the list and invariably the queue. Thus,
    to remove the associated node (pointed to by `self.head`), the `self.head` and
    `self.tail` variables are set to `None`.'
  prefs: []
  type: TYPE_NORMAL
- en: If the queue has many nodes, then the head pointer is shifted to point to the
    next node after `self.head`.
  prefs: []
  type: TYPE_NORMAL
- en: After the `if` statement is executed, the method returns the node that was pointed
    to by the `head`. Also, the variable `self.count` is decremented by `1` in both
    of these conditions, that is, when the count is initially `1` and more than `1`.
  prefs: []
  type: TYPE_NORMAL
- en: Equipped with these methods, we have implemented a queue, borrowing heavily
    from the idea of a doubly linked list.
  prefs: []
  type: TYPE_NORMAL
- en: Remember also that the only things transforming our doubly linked list into
    a queue are the two methods, namely, `enqueue` and `dequeue` methods.
  prefs: []
  type: TYPE_NORMAL
- en: Application of queues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Queues can be used to implement a variety of functionalities in many real computer-based
    applications. For instance, instead of providing each computer on a network with
    its own printer, a network of computers can be made to share one printer by queuing
    what each printer wants to print. When the printer is ready to print, it will
    pick one of the items (usually called jobs) in the queue to print out. It will
    print the command from the computer that has given the command first and in the
    order of the commands given by different computers.
  prefs: []
  type: TYPE_NORMAL
- en: Operating systems also queue processes to be executed by the CPU. Let's create
    an application that makes use of a queue to create a bare-bones media player.
  prefs: []
  type: TYPE_NORMAL
- en: Media player queues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most music player software allows users to add songs to a playlist. Upon
    hitting the play button, all the songs in the main playlist are played one after
    the other. Sequential playing of the songs can be implemented with queues because
    the first song to be queued is the first song that is to be played. This aligns
    with the FIFO acronym. We will implement our own playlist queue to play songs
    in the FIFO manner.
  prefs: []
  type: TYPE_NORMAL
- en: Our media player queue will only allow for the addition of tracks and a way
    to play all the tracks in the queue. In a full-blown music player, threads would
    be used to improve how the queue is interacted with, while the music player continues
    to be used to select the next song to be played, paused, or even stopped.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `track` class will simulate a musical track:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Each track holds a reference to the title of the song and also the length of
    the song. The length of the song is a random number between `5` and `10`. The
    random module in Python provides the `randint` function to enable us to generate
    the random numbers. The class represents any MP3 track or file that contains music.
    The random length of a track is used to simulate the number of seconds it takes
    to play a song or track.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a few tracks and print out their lengths, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Your output may be different depending on the random length generated for the
    two tracks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s create our queue. Using inheritance, we simply inherit from the
    `queue` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'A call is made to properly initialize the queue by making a call to `super`.
    This class is essentially a queue that holds a number of track objects in a queue.
    To add tracks to the queue, an `add_track` method is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The method passes a `track` object to the `enqueue` method of the queue `super` class.
    This will, in effect, create a `Node` using the `track` object (as the node's
    data) and point either the tail, if the queue is not empty, or both head and tail,
    if the queue is empty, to this new node.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming the tracks in the queue are played sequentially from the first track
    added to the last (FIFO), then the `play` function has to loop through the elements
    in the queue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The `self.count` keeps count of when a track is added to our queue and when
    tracks have been dequeued. If the queue is not empty, a call to the `dequeue`
    method will return the node (which houses the `track` object) at the front of
    the queue. The `print` statement then accesses the title of the track through
    the `data` attribute of the node. To further simulate the playing of a track,
    the `time.sleep()` method halts program execution till the number of seconds for
    the track has elapsed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The media player queue is made up of nodes. When a track is added to the queue,
    the track is hidden in a newly created node and associated with the data attribute
    of the node. That explains why we access a node''s `track` object through the
    data property of the node which is returned by the call to `dequeue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/a61216ca-9e9e-4cc4-af3e-d1923711a688.png)'
  prefs: []
  type: TYPE_IMG
- en: You can see that, instead of our `node` object just storing just any data, it
    stores tracks in this case.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take our music player for a spin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We create five track objects with random words as titles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The output should be different from what you get on your machine due to the
    random length.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, an instance of the `MediaPlayerQueue` class is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The tracks will be added and the output of the `play` function should print
    out the tracks being played in the same order in which we queued them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Upon execution of the program, it can be seen that the tracks are played in
    the order in which they were queued. When playing the track, the system also pauses
    for the number of seconds equal to that of the length of the track.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we used our knowledge of linking nodes together to create other
    data structures, namely `stacks` and `queues`. We have seen how these data structures
    closely mimic stacks and queues in the real world. Concrete implementations, together
    with their varying types, were explored. We later applied the concepts of stacks
    and queues to write real-life programs.
  prefs: []
  type: TYPE_NORMAL
- en: We shall consider trees in the next chapter. The major operations of a tree
    will be discussed, and likewise the different spheres in which to apply their
    data structure.
  prefs: []
  type: TYPE_NORMAL
