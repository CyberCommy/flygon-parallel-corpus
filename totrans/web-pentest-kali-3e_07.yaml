- en: Cross-Site Request Forgery, Identification, and Exploitation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Cross-Site Request Forgery** (**CSRF**) is often mistakenly perceived as
    a vulnerability that is similar to XSS. XSS exploits the trust a user has in a
    particular site, which makes the user believe any information presented by the
    website. On the other hand, CSRF exploits the trust that a website has in a user''s
    browser, which has the website execute any request coming from an authenticated
    session without verifying if the user wanted to perform that specific action.'
  prefs: []
  type: TYPE_NORMAL
- en: In a CSRF attack, the attacker makes authenticated users perform unwanted actionsÂ in
    the web application in which they are authenticated. This is accomplished through
    an external site that the user visits, which triggers these actions.
  prefs: []
  type: TYPE_NORMAL
- en: 'CSRF can exploit every web application function that requires a single request
    within an authenticated session if sufficient defense is not implemented. Here
    are some examples of the actions that attackers can perform through a CSRF attack:'
  prefs: []
  type: TYPE_NORMAL
- en: Changing user details, such as email address and date of birth, in a web application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making fraudulent banking transactions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conducting fraudulent up-voting and down-voting on websites
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding items to a shopping cart on an e-commerce website or buying items without
    the user's knowledge
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preconditions for a CSRF attack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since CSRF leverages an authenticated session, the victim must have an active
    authenticated session in the target web application. The application should also
    allow transactions within a session without asking for re-authentication.
  prefs: []
  type: TYPE_NORMAL
- en: CSRF is a blind attack, and the response from the target web application is
    not sent to the attacker, but to the victim. The attacker must have knowledge
    about the parameters of the website that would trigger the intended action. For
    example, if you want to change the registered email address of the victim on the
    website, as an attacker you would identify the exact parameter that you need to
    manipulate to make this change. Therefore, the attacker would require proper understanding
    of the web application, which can be done by interacting with it directly.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, the attacker needs to find a way to trick the user into clicking
    on a prebuilt URL, or to visit an attacker-controlled website if the target application
    is using the `POST` method. This can be achieved using a social engineering attack.
  prefs: []
  type: TYPE_NORMAL
- en: Testing for CSRF flaws
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The description of the CSRF vulnerability clearly suggests that it is a business
    logic flaw. An experienced developer would create web applications that would
    always include a user confirmation screen when performing critical tasks such
    as changing a password, updating personal details, or when making critical decisions
    in a financial application such as an online bank account. Testing for business
    logic flaws is not the job of automated web application scanners, as they work
    with predefined rules. For example, most of the automated scanners test for the
    following items to confirm the existence of a CSRF flaw in the URL:'
  prefs: []
  type: TYPE_NORMAL
- en: Checking for common antiCSRF token names in the request and response
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Trying to determine whether the application is checking the referrer field by
    supplying a fake referrer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating mutants to check whether the application is correctly verifying the
    token value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking for tokens and editable parameters in the query string
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of the preceding methods used by most automated application scanners are
    prone to false positives and false negatives. The application would be using an
    entirely different mitigation technique to defeat a CSRF attack and thus render
    these scanning tools useless.
  prefs: []
  type: TYPE_NORMAL
- en: The best way to analyze the application for a CSRF flaw is first to gain a complete
    understanding on the functionality of the web application. Fire up a proxy, such
    as Burp or ZAP, and capture the traffic to analyze the request and response. You
    can then create a HTML page, replicating the vulnerable code identified from the
    proxy. The best way to test for CSRF flaws is to do it manually.
  prefs: []
  type: TYPE_NORMAL
- en: 'An application is likely to be vulnerable to CSRF flaws if it doesn''t include
    any special header or form parameter when performing server-side changes through
    an authenticated user''s session. For example, the following screenshot shows
    a request to add a comment to a picture in **Peruggia**, a vulnerable application
    included in the **OWASP BWA** virtual machine. You''ll notice that there is no
    special header that could identify one request from another on the server side.
    Also, the `GET` and `POST` parameters are used to identify the action to be executed,
    the image affected, and the contents of the comment:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00190.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Sometimes, applications use verification tokens, but the implementation of
    them is insecure. The following screenshot shows a request from Mutillidae II
    | OWASP 2013 | A8 - Cross Site Request Forgery (CSRF) | Register User, using security
    level 1\. You can see that there is a `csrf_token` parameter in the request for
    registering a new user. However, it is only four digits long and seems easily
    predictable. Actually, in this particular case, the token always has the same
    value: `7777`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00191.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Other examples of flawed implementations of CSRF prevention tokens are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Include the token as a cookie**: Browsers automatically send cookies corresponding
    to the visited sites in requests, which will render the implementation of an otherwise
    secure token useless.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**User or client information is used as a token**: Information such as IP address,
    username, or personal information can be used as a token. This unnecessarily exposes
    the user information, and such information can be gathered through social engineering
    or **Open Source Intelligence** (**OSINT**) in targeted attacks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Allow tokens to be reused**: Even if for a short period of time, if the server
    allows for a token to be used multiple times, an attack can still be performed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Client-side only checks**: If the application verifies that the user is actually
    executing certain actions only using client-side code, an attacker can still bypass
    those checks using JavaScript, be it via an XSS exploitation, or in the attacking
    page, or simply by replaying the final request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploiting a CSRF flaw
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Exploiting this vulnerability through a `GET` request (parameters sent within
    the URL) is as easy as convincing the user to browse to a malicious link that
    will perform the desired action. On the other hand, to exploit a CSRF vulnerability
    in a `POST` request requires creating an HTML page with a form or script that
    submits the request.
  prefs: []
  type: TYPE_NORMAL
- en: Exploiting CSRF in a POST request
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will focus on exploiting a `POST` request. We will use
    Peruggia''s user-creation functionality for this exercise. The first step is that
    you need to know how the request that you want to replicate works; if you log
    in as admin to Peruggia and create a new user while capturing the traffic with
    Burp Suite, you can see that the request appears as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00192.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The request only includes the `newuser` (username) and `newuserpass` (password)
    parameters. Thus, once the request and parameters that make the change are identified,
    we need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an HTML page that generates the request with those parameters and the
    information that you want to use.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Convince the user to browse to your page and submit the request. The latter
    may not be necessary, as you can have the page autosubmit the form.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'An elaborate HTML, like the following, is required to accomplish our objective.
    In this, example the vulnerable server is `10.7.7.5`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting page will look like the following screenshot. The bottom section
    is the Firefox developer tools panel. It can be activated using the *F12* key:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00193.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In a regular penetration test, this may work as **proof of concept** (**PoC**)
    and be enough to demonstrate the existence of a vulnerability. A more sophisticated
    version could include deceptive content and script code to autosubmit the request
    once the page is loaded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'To test this PoC page, open Peruggia and start a session with the `admin` user
    (password: `admin`) and load the attacking page in a different tab or window of
    the same browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00194.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, click on the Submit button or simply load the page, if using the scripted
    version, and the request will be processed by the server as if it were sent by
    an authenticated user. Using the browser''s developer tools, you can check that
    the request was sent to the target server and processed properly:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00195.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: CSRF on web services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's not uncommon for today's web applications to perform tasks using calls
    to web services instead of normal HTML forms. These requests are done through
    JavaScript using the XMLHttpRequest object, which allows developers to create
    an HTTP request and customize parameters such as method, headers, and body.
  prefs: []
  type: TYPE_NORMAL
- en: 'Web services often receive requests in formats different from the standard
    HTML form (for example, `parameter1=value1&parameter2=value2`), such as JSON and
    XML. The following example code snippet sends an address update request in JSON
    format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The body for this request (that is, the `POST` data) may look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'If you try to send this exact string as a `POST` parameter within an HTML form,
    it will result in an error on the server and your request won''t be processed.
    Submitting the following form, for example, will not process the parameters correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: There are a couple of ways to make it possible to exploit a CSRF to a request
    using JSON or XML formats.
  prefs: []
  type: TYPE_NORMAL
- en: 'Oftentimes, web services allow parameters in different formats, including the
    HTML form format; so your first option is to change the `Content-Type` header
    of the request to `application/x-www-form-urlencoded`. This is done simply by
    sending the request through an HTML form. Instead of trying to send the JSON string;
    however, you can create a form containing one input for each parameter in the
    string. In our example, a simple version of the HTML code would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'If the `Content-Type` header of the request is not allowed, and the web service
    only accepts JSON or XML formats, then you need to replicate (or create) the script
    code that generates the request following the same example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Notice the use of `xhr.withCredentials=true;`. This allows JavaScript to get
    the cookies stored in the browser for the target domain and send them along with
    the request. Additionally, the state change event handler is omitted, as you don't
    need to capture the response.
  prefs: []
  type: TYPE_NORMAL
- en: This last option has several drawbacks, as JavaScript behavior is limited in
    current day browsers and servers in terms of cross-site operations. For example,
    depending on the server's **Cross-Origin Resource Sharing** (**CORS**) configuration,
    applications may need to perform a preflight check before sending a cross-site
    request. This means that browsers will automatically send an `OPTIONS` request
    to check the methods allowed by that server before sending anything. If the requested
    method is not allowed for cross-origin requests, the browser will not send it.
    Another example of protection, this time in browsers, is the aforementioned **same-origin
    policy**, which by default makes browsers protect the server's resources from
    being accessed via script code by other websites.
  prefs: []
  type: TYPE_NORMAL
- en: Using Cross-Site Scripting to bypass CSRF protections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When an application is vulnerable to **Cross-Site Scripting** (**XSS**), an
    attacker can use that flaw (via scripting code) to read the variable containing
    the unique token and either send it to an external site and open the malicious
    page in a new tab, or use the same script code to send the request, also bypassing
    the CORS and same-origin policies, as the request will be made by the same site
    via local scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at the scenario where scripting code can be used to make the application
    perform a request on itself. You will use WebGoat's *CSRF Token By-Pass* (Cross-Site
    Scripting (XSS) | CSRF Token By-Pass) exercise. As expressed in the instructions,
    you need to abuse the fact that the *new post* functionality in a newsgroup allows
    the injection of HTML and JavaScript code in order to perform an unauthorized
    request to transfer funds.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the transfer funds page, which you can load
    adding the `&transferFunds=main`Â parameterÂ to the lesson''s URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00196.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you inspect the source code of the form, you can see that it has a hidden
    field called `CSRFToken`, which will change every time you load the page. This
    appears to be completely random:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00197.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In order to execute a CSRF in this form, you will need to exploit the XSS vulnerability
    in the comment form to have it load the transfer form inside an `iframe` tag using
    JavaScript. This will set the value to transfer and automatically submit the form.
    To do this, use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Thus, when the page contained in the iframe is completely loaded, it will call
    the `frame_loaded` function, which sets the value of the `transferFunds` field
    to `54321` (the amount to be transferred) and submits the request. Notice that
    the `form.submit();` line is commented. This is for demonstration purposes only
    in order to prevent the automatic submission.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now browse to the vulnerable page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Set a title for your post, write or paste your code in the Message field, and
    submit it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00198.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'After doing this, you will see your message''s title at the bottom of the page,
    just below the Submit button. If you click on it as a victim would do, you can
    see how it loads the amount to transfer that was set in the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00199.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'To test autosubmission, just post a new message, removing the comment on the
    `form.submit();` line. The result of opening the message will appear similar to
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00200.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The next screenshot, from Burp Suite''s proxy history, shows how the requests
    were made by the browser in the previous example. Shown first is the request to
    load a message with code injected, in our case, message 66 (parameter `Num=66`).
    Next, the malicious message loads the iframe with the fund transfer page (parameter
    `transferFunds=main`). Finally, according to the code, when this page finishes
    loading the script code, it fills in the amount to transfer and submits the request
    with a valid CSRF token:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00201.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Preventing CSRF
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Preventing CSRF is all about ensuring that the authenticated user is the person
    requesting the operation. Due to the way browsers and web applications work, the
    best choice is to use a token to validate operations, or, when possible, use a
    CAPTCHA control.
  prefs: []
  type: TYPE_NORMAL
- en: A CSRF attack is easier to execute when the vulnerable parameter is passed through
    the `GET` method. Therefore, avoid it in the first place and use the `POST` method
    wherever possible. It does not fully mitigate the attack, but it makes the attacker's
    task more difficult.
  prefs: []
  type: TYPE_NORMAL
- en: As attackers will try to break token generation or validation systems, it is
    very important to produce them securely; that is, in a way that attackers cannot
    guess them. You must also make them unique for each user and each operation, because
    reusing them voids their purpose. These tokens are usually included in a header
    field in every request or in a hidden input in HTML forms. Avoid including them
    in cookies, as they are automatically sent by the browser along with every request
    on a per-domain basis.
  prefs: []
  type: TYPE_NORMAL
- en: CAPTCHA controls and re-authentication are intrusive and annoying for users
    at some point, but if the criticality of the operation merits it, they may be
    willing to accept them in exchange for the extra level of security they provide.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, CORS policies should be configured on the server, as they can prevent
    some attacks which are done via script code through the web browser. CORS policies
    will prevent JavaScript running in a different tab or browser window in order
    to access data/resources on the server if the URL loaded in that window is not
    part of the same origin (such as host, port, or protocol).
  prefs: []
  type: TYPE_NORMAL
- en: More information about preventing CSRF can be found atÂ [https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)_Prevention_Cheat_Sheet](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)_Prevention_Cheat_Sheet).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about CSRF and how it abuses the trust relationship
    between the server and web browsers. You saw how to detect applications that may
    be vulnerable, reviewed an exploitation procedure, and practiced with an example,
    analyzing how it would work in web services. You also learned of a way to bypass
    token protection and the CORS and same-origin policies when combined with an XSS
    vulnerability.
  prefs: []
  type: TYPE_NORMAL
- en: As in previous chapters, the last section of this one was about defense. We
    reviewed recommended methods for preventing or mitigating CSRF vulnerabilities
    in your own applications or in those of your clients.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will be a brief introduction to cryptography, focusing on the
    basics that a penetration tester needs to know, such as distinguishing between
    encryption, hashing and encoding, identifying weak cryptographic implementations
    and exploiting common vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
