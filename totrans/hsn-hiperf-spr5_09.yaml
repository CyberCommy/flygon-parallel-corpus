- en: Profiling and Logging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we dove into the details of multithreading and concurrent
    programming. We looked at the `java.util.concurrent` package API. The chapter
    covered thread pooling for asynchronous programming, Spring task execution, scheduling,
    and Spring Async API. In the latter part of the chapter, we compared Spring Async
    with `CompletableFuture`.
  prefs: []
  type: TYPE_NORMAL
- en: Along similar lines, this chapter will focus on profiling and logging. This
    chapter starts by defining profiling and logging, and how they are useful for
    assessing application performance. In the latter part of the chapter, the focus
    will be on learning about software tools that can be used to study application
    performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Performance profiling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application logging and monitoring
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Profiling tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance profiling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This section will focus on performance and application profiling for performance
    measurement. Profiling is an important step in any application development and
    deployment life cycle. It helps us to perform the following two things:'
  prefs: []
  type: TYPE_NORMAL
- en: Defining a benchmark for expected performance outcomes
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Measuring and comparing the current performance outcome against benchmarks
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The second step defines further actions to be taken, in order to take performance
    to the benchmark level.
  prefs: []
  type: TYPE_NORMAL
- en: Application performance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Performance means different things to different people when used in terms of
    software applications. It must have some context for better understanding. Application
    performance is measured against two sets of performance metrics. The actual performance
    observed or experienced by the application users remains one of the most important
    metrics for measuring application performance. It includes the average response
    time during peak and normal loads. Measurements related to average response time
    include the time taken by the application to respond to a user's action, such
    as a page refresh, navigation, or a button click. They also include the time taken
    to perform certain operations, such as sorting, searching for, or loading data.
  prefs: []
  type: TYPE_NORMAL
- en: This section is meant to provide technical teams a perspective on some of the
    aspects of configurations and internals that can be set or altered to optimize
    effects, in order to improve the performance of the application. In usual cases,
    technical teams never keep an eye on the memory that the application uses or the
    CPU utilization unless they are stuck with a performance issue. Application transactions
    include requests received by the application per second, database transactions
    per second, and pages served per second. The load on the system is usually measured
    in terms of volume of transactions that the application processes.
  prefs: []
  type: TYPE_NORMAL
- en: There is another set of measurements that involves measuring the computational
    resources utilized by the application while performing operations. It is a very
    good way of identifying whether the application has enough resources to sustain
    the given load. It also helps in identifying whether the application utilizes
    more resources than it is expected to. If so, it can be concluded that the application
    is not optimized on the performance side. Cloud-hosted applications are popular
    these days. In this era, it is important for users to have the same experiences
    on applications deployed over the cloud or a non-cloud infrastructure, and on
    the local environment.
  prefs: []
  type: TYPE_NORMAL
- en: Application performance monitoring and improvements may not be necessary for
    an application, as long as it performs per expectations. However, as part of the
    application development life cycle, new requirements come up, new features are
    added, and the application becomes more complex by the day. This starts impacting
    the application's performance, as the main focus is kept on new feature development.
    A time will come when the performance is not up to marks, because no one actually
    works on application performance enhancement.
  prefs: []
  type: TYPE_NORMAL
- en: Application logging and monitoring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section focuses on logging important information while the application
    is running. It helps to debug the application from various aspects, which we will
    look at in detail. Another important aspect covered in this section is application
    monitoring. In some cases, application monitoring is considered no different from
    application profiling; these are certainly different aspects in application performance
    measurement.
  prefs: []
  type: TYPE_NORMAL
- en: Application logging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we dive into the details of Java application logging, it is mandatory
    to understand what logs and logging are. A **log** is a statement that displays
    information to help us understand the state of the application. Log statements
    are written in the log files, in an application-specific format. The log statements
    may include information such as the date and time of execution of a particular
    statement, the values of various variables, and the states of the objects. The
    process of writing log statements to log files is known as **logging**.
  prefs: []
  type: TYPE_NORMAL
- en: Every application produces logs for various purposes. Applications produce logs
    to keep track of application events, including access-related events, login and
    logout events, events when errors occur in an application, and system configuration
    modifications. Operating systems also produce log files. Log files can be processed
    to bifurcate required information. Logging is one of the most fundamental parts
    of software applications. A well-written log and well-designed logging mechanism
    become a huge utility for developers and administrators. It is most useful to
    teams working on application support activities. Well, designed logging saves
    a lot of time for development and support teams. As the frontend programs are
    executed, the system builds log files in an invisible manner.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are common log files, usually generated in applications:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Error/Exception logs**: Any unexpected situation in an application flow is
    termed as an **error**. Errors may occur for different reasons. Errors are categorized
    based on severity and impact on the application. If the user cannot proceed further
    in the application, such an error is categorized as a **blocker**. If the web
    page does not have an appropriate label, it is categorized as a low severity issue.
    An error log is a recording of critical errors that have occurred while the application
    is executing. An application without errors virtually doesn''t exist. In Java,
    it is not required to log all exceptions. Java supports managed exceptions, which
    can be taken care of and thrown as a warning or error message to the user. This
    could be a validation error or a user input error, which can be thrown using managed
    exceptions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Access logs**: At an abstract level, any request that comes to a web application
    can be considered a request to access a resource on the web application server.
    The resource could be a web page, a PDF file on the server, an image file, or
    a report from the data in the database. From a security point of view, every resource
    must be protected by access rights. Access rights define who can access the resource
    from the web application. Access logs are written information on who tried to
    access which resource. They may also include information about the location from
    which the resource was accessed. Access logs write access information for every
    request coming into the web application. Access logs can also be used to find
    information about the number of visitors, the number of visitors accessing the
    application for the first time, the number of visitors from a specific location,
    the number of requests for a particular page, and the application usage patterns.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Transaction logs**: Transactions are related to databases. A sequence of
    database commands or statements executed in order to maintain atomicity and database
    integrity is known as a **transaction**. Transactions are maintained to guarantee
    protection over crashes or failures. A **transaction log** is a file where all
    such transactions are recorded or written. At a particular time, if the database
    is found to be inconsistent, then transaction logs become helpful in debugging
    the issue. Transaction logs can also be used to record any rollback operations
    performed. Usually, transaction logs also record the time of database statements
    to execute, along with passed in parameters. This information is very helpful
    in profiling database performance issues.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Audit logs**: **Auditing** is the process of inspecting how the application
    is used. It inspects the application resources being used, the users who access
    or use application resources, and the authentication and authorization information
    for the users. The **audit log** records every event that the application passes
    through, along with the previously mentioned details.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logging best practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Having described what should be logged and common logging information, this
    section details the best practices for logging:'
  prefs: []
  type: TYPE_NORMAL
- en: It is very important to assign appropriate log levels to each of the log statements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logging should also be considered in a cluster environment. We can use the same
    type of log files, with the cluster node name as a suffix to the filename. This
    will prevent the log entries from being overwritten or wrongly considered when
    analyzing logs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building log files impacts the application's performance. If an application
    starts logging every minor piece of information, the application's performance
    will be slow. We must ensure that the size of the log files and frequency of writing
    log entries are low.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All exceptions, except for validations and input errors, must be logged. The
    exception messages must be logged in a way that highlights the problems clearly.
    The best practice is to let the framework log all of the exceptions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logs must be user-friendly and easily parsed. Logs can be used in two ways.
    One way is that the users read the logs to build understanding. Another way is
    that the utility programs parse the application logs, based on the log formats,
    to filter out unimportant information.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every log entry must be different from other log entries, though they represent
    the same information. Every log entry can have a unique identifier, most often
    based on the timestamp, which can be used to differentiate it from other logs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sensitive information must not be logged in log files. Passwords, credentials,
    and authentication keys are a few examples.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In most cases, best practices work as general guidelines and can be followed
    in a customized manner, based on the project.
  prefs: []
  type: TYPE_NORMAL
- en: Logging tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding sections of this chapter, we learned about the importance of
    logging. We also learned logging best practices. Now is the time to add logging
    tools to our skill sets. This section focuses on logging tools. Logging tools
    are helpful because of the features they provide. In the past, log files consisted
    of log statements, written in a plain text format. Plain text log files are still
    useful in specific situations, like analyzing infrastructure data, but they are
    no longer sufficient in logging information for an application. Java has built-in
    support for standard logging in the `java.util.logging` API. Log4j is another
    well-known and widely used logging tool in the Java community.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we jump into the details of logging tools, it is important to understand
    the key elements of the logging mechanism. The following are key logging components:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Log Level**: The Java logging levels are used to control the logging output.
    They provide flexibility in enabling or disabling the various logging levels.
    This makes it possible to choose which logs will be displayed in the log files.
    With this, it is possible that the application running on the production has a
    different logging level than the same application running on the staging environment.
    Enabling one level of logging will make all higher-level logs enabled for printing
    in the log files. The following are the log levels and effective logging levels
    for the Java logging API:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| **Request level** | **Effective logging level** |'
  prefs: []
  type: TYPE_TB
- en: '| `SEVERE` | `WARNING` | `INFO` | `CONFIG` | `FINE` | `FINER` | `FINEST` |'
  prefs: []
  type: TYPE_TB
- en: '| `SEVERE` | Yes | Yes | Yes | Yes | Yes | Yes | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| `WARNING` | No | Yes | Yes | Yes | Yes | Yes | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| `INFO` | No | No | Yes | Yes | Yes | Yes | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| `CONFIG` | No | No | No | Yes | Yes | Yes | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| `FINE` | No | No | No | No | Yes | Yes | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| `FINER` | No | No | No | No | No | Yes | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| FINEST | No | No | No | No | No | No | Yes |'
  prefs: []
  type: TYPE_TB
- en: '**Logger**: The job of the `Logger` object is to log application messages.
    The application can create anonymous loggers, which are stored differently than
    in the `Logger` namespace. The application must be sure to keep a reference to
    the `Logger` object, as the `Logger` may get garbage collected at any point in
    time. The `Logger` object is associated with a parent `Logger` object, which is
    the nearest ancestor in `Logger` namespace. During the logging process, log messages
    are sent to `Handler` objects. The `Handler` objects forward the log messages
    to files, logs, or consoles. Every `Logger` object has a log level associated
    with it. It indicates the minimum level `Logger` will print logs for.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Handler**: The responsibility of a `Handler` object is to get log messages
    from `Logger` objects, and send those log messages for printing to the appropriate
    destination. Examples include writing the log messages on the console, writing
    the log messages into a file, or writing the log messages to a network logging
    service. It is possible to enable or disable a `Handler`, which, in essence, stops
    printing those logs on the output medium.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Formatter:** The log `Formatter` formats the log messages before writing
    them to the output medium. Java supports two types of `Formatter` objects: `SimpleFormatter`
    and `XMLFormatter`. The `XMLFormatter` object is required to include a head and
    tail around formatted records. It is also possible to create custom `Formatter`
    objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**LogManager:** `LogManager` is a singleton object, used to maintain a shared
    state of loggers and log services. Apart from this, the `LogManager` object manages
    logging properties and the `Logger` namespace. The `LogManager` object is instantiated
    while class initialization takes place. The object cannot be subsequently changed. `LogManager`
    reads the initial configuration from the `lib/logging.properties` file by default,
    which can be modified.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram shows the logging process with one `Handler`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e1514066-4a73-4e46-a089-666099b86b62.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following diagram shows the logging process with multiple handlers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7f4ab92e-aa5a-4dd1-a80e-423270789732.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Java standard logging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section explains Java's built-in logging mechanism. The Java logging API
    is comprised of the `java.util.logging` package. The core package includes support
    for writing plain text or XML log entries to output streams, files, memory, the
    console, or sockets. The logging API is also capable of interacting with already
    existing logging services on the operating system.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code example is used for printing log messages using the standard
    logging API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is an example of the `logging.properties` file referenced in
    the preceding code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output after executing the preceding example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The benefit of using Java standard logging is that you don''t need separate
    JAR dependencies to be installed in the project. Though logging is related to
    troubleshooting issues that we come across on servers, we also have to make sure
    that logging does not impact the application performance in a negative way. The
    following points must be taken care of to make sure that logging does not impact
    application performance:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Logger.log` methods are used to print log records on the output medium via
    a `Handler`. We can use `Logger.isLoggable` to ensure that `Logger` is enabled
    for the log level. If we pass a custom object as an argument to the `Logger.log`
    method, the `toString` method of the custom object is called from deep inside
    of the library classes. So, if we want to perform heavy operations in order to
    prepare an object for logging, we should do that from either within the block
    which checks `Logger.isLoggable`, or from within the object''s `toString` method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We must not call the `toString` method on any object to get the log message
    contents. We must not pass the `toString` method call as an argument to `Logger.log`,
    either. The `Logger` object and logging framework take care of calling the `toString`
    method on a custom object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The mixing of format string concatenation and log arguments must be avoided.
    It is possible for an application user with wrong intentions to break the log
    and access data that is not permitted to the user using a malicious concatenated
    string.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One of the major drawbacks of Java standard logging is comparative performance.
    Standard logging takes more time as compared to other Java-based logging frameworks,
    like Apache Log4j 2, commons logging, or **Simple Logging Facade for Java** (**SLF4J**).
  prefs: []
  type: TYPE_NORMAL
- en: Apache Log4j 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Apache Log4j is one of the most widely used logging frameworks in the Java community.
    It is written in Java and distributed under the Apache software license. Apache
    Log4j 2 is the revision of an earlier version. The most notable features include
    thread safety, performance optimization, a named logger hierarchy, and internationalization
    support.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to set up Log4j 2, the following Maven dependencies must be added
    in the Maven `pom.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In order to gain access to the context rule that is required for testing of
    the named configuration files, we must include the `test` JAR, along with the
    main `log4j-core` package.
  prefs: []
  type: TYPE_NORMAL
- en: 'Log4j 2 has three major logging components:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Loggers`**:** The `Loggers` are responsible for capturing logging information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Appenders`**:** These are similar to that of the `Handler` objects in Java
    standard logging. `Appenders` are responsible for broadcasting logging information
    or messages to configured output mediums.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Layouts`**:** The `Layouts` are responsible for formatting the log messages
    into configured styles.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is an example of the `log4j2.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is an example of Log4j 2 Java code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'When we execute the preceding example, the following output is produced:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Apache Log4j 2 has additional log levels, beyond common log levels. These are
    `ALL` and `OFF` levels. The `ALL` log level is used when we want to enable logs
    at `ALL` log levels. If the `ALL` log level is configured, while the levels are
    not considered. The `OFF` log level is the opposite of the `ALL` log level. It
    disables all logging.
  prefs: []
  type: TYPE_NORMAL
- en: Application monitoring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As discussed earlier, application performance is considered one of the most
    important milestones in any software application life cycle. It is also required
    that the application performs well consistently. This is one of the ways that
    we can ensure that application users will have the best experience with the application.
    It also means that the application is up and running well. An application performance
    monitoring tool tracks every request and response coming in and out of the application,
    processes information from the requests, and responds and displays in a graphical
    user interface. It means monitoring tools provide the administrators with the
    data necessary for quickly discovering, isolating, and solving problems impacting
    the performance.
  prefs: []
  type: TYPE_NORMAL
- en: The monitoring tools usually collect data about CPU utilization, memory requirements,
    bandwidth, and throughput. It is possible to have multiple monitoring systems
    for disparate monitoring. One of the important aspects of any application performance
    monitoring is to combine data from such monitoring systems into a statistical
    analysis engine and display it on a dashboard. The dashboard makes it easy to
    read the data logs for analysis. Application monitoring tools help administrators
    monitor application servers in order to comply with **service level agreements**
    (**SLA**). Business rules are set to send administrators an alert in the event
    of a problem. This ensures that business-critical features and applications are
    considered with higher priority. With the fast changing environments, it has become
    very important to have rapid deployments in production systems. Rapid deployments
    mean more chances to introduce errors impacting system architecture or to slow
    the system down.
  prefs: []
  type: TYPE_NORMAL
- en: Many implementations and tools are available based on these basic concepts.
    There is a huge and crowded market for application monitoring tools, including
    industry-leading and well-known tools like AppDynamics, New Relic, and Dynatrace.
    Apart from these known tools, there also exist open source application monitoring
    tools. The open source tools include Stagemonitor, Pinpoint, MoSKito, Glowroot,
    Kamon, and many more. We will look at each of these tools in detail in the following
    sections.
  prefs: []
  type: TYPE_NORMAL
- en: Stagemonitor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Stagemonitor has a monitoring agent built with support for clustered application
    stacks. The purpose of the tool is to monitor applications running on a number
    of servers, which is a usual production scenario. Stagemonitor is optimized for
    integration with time series databases. It is optimized for time series data management,
    which includes arrays of numbers, indexed by time. Such databases include elasticsearch,
    graphite, and InfluxDB. Stagemonitor can also be set up in private networks. It
    uses the open tracking API to correlate requests in distributed systems. It features
    defining thresholds for the metrics. Stagemonitor also supports creating new plugins
    and integrating third-party plugins.
  prefs: []
  type: TYPE_NORMAL
- en: Stagemonitor contains a Java-based agent. The agent sits in the Java application.
    The agent connects to the central database and sends metrics and request traces
    and statistics. Stagemonitor requires one instance for monitoring all applications,
    instances, and hosts.
  prefs: []
  type: TYPE_NORMAL
- en: In the browser, on the monitoring side, we can see historical or current data
    from the cluster. We can also create custom alerts. It is also possible to define
    a threshold for each metric. Stagemonitor has a dashboard. The dashboard is utilized
    for visualizing and analyzing different metrics and requests of interest. Stagemonitor
    supports creating custom dashboards, writing custom plugins, and using third-party
    plugins. It has in-browser widget support, as well. The widget does not require
    a backend and is injected automatically into the monitored web page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following is the screenshot of Stagemonitor dashboard for reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d0794e01-e0a1-4ea6-960f-75e0265f5883.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The Stagemonitor dashboard view (source: http://www.stagemonitor.org/)'
  prefs: []
  type: TYPE_NORMAL
- en: Pinpoint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pinpoint is different from Stagemonitor, in that it was developed with large-scale
    applications in mind. It was developed after Dapper (a distributed systems tracing
    infrastructure developed by Google) in order to provide developers with more information
    about how complex distributed systems behave.
  prefs: []
  type: TYPE_NORMAL
- en: Pinpoint helps in analyzing the overall system structure and how different components
    of the system are interconnected. Pinpoint does this by tracing transactions across
    distributed applications. It is aimed at explaining how each transaction is executed,
    tracing the flow between components and potential bottlenecks and problematic
    areas.
  prefs: []
  type: TYPE_NORMAL
- en: Pinpoint, similar to Stagemonitor, has a dashboard for visualization. The dashboard
    helps in visualizing the interconnection between components. The dashboard also
    lets users monitor active threads in the applications at particular points in
    time. Pinpoint features a tracing request count and response patterns. This helps
    in identifying potential problems. It provides support for viewing critical information,
    including CPU utilization, memory utilization, garbage collection, and JVM arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Pinpoint consists of four components, named Collector, Web, Sample TestApp,
    and HBase. We can run an instance by executing a script for each of the components
    separately.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following is the Pinpoint dashboard for reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3f5c17c7-6333-4d01-95c2-9d8112fb6d06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The Pinpoint dashboard reference view (source: http://www.testingtoolsguide.net/tools/pinpoint-apm/)
  prefs: []
  type: TYPE_NORMAL
- en: MoSKito
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'MoSKito is a group of three tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '**MoSKito-Essential**: This standalone project is the core of MoSKito. It makes
    it possible to monitor the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MoSKito-Central**: This works as a centralized storage server. It stores
    all of the performance-related information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MoSKito-Control**: This tool works for multi-node web applications. It provides
    support for monitoring multi-node web applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In order to set up MoSKito, we need to install a JAR file in the application's
    `WEB-INF/lib` directory, which is a common folder for keeping API libraries. It
    can also be set up by adding a new section in the `web.xml` file.
  prefs: []
  type: TYPE_NORMAL
- en: The tool is capable of collecting all of the application performance metrics,
    including memory, threads, storage, caches, registrations, payments, conversions,
    SQL, services, load distribution, and many more. It does not require users to
    make any code changes in the application. It supports all major application servers,
    including Tomcat, Jetty, JBoss, and Weblogic. It stores the data locally.
  prefs: []
  type: TYPE_NORMAL
- en: MoSKito also has a notification feature to broadcast an alert when a threshold
    is met. It also records a user's actions, which might be of interest for monitoring
    purposes. MoSKito offers a mobile application for monitoring the application on
    the go. It also has web-based dashboards.
  prefs: []
  type: TYPE_NORMAL
- en: One of the distinguishing points for MoSKito is that it is very stable and well-known
    in the Java community. It is supported by the community and team, which includes
    paid support, as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following is the MoSKito dashboard for reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e8b1aab2-b6ba-4033-a50e-c379a733b6fd.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The MoSKito dashboard view (source: https://confluence.opensource.anotheria.net/display/MSK/Javaagent+light+and+multiple+java+processes)
  prefs: []
  type: TYPE_NORMAL
- en: Glowroot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the fast, clean, and simple application performance monitoring tools
    is Glowroot. It has a feature which allows tracing for slow requests and errors.
    With Glowroot, it is also possible to log the time taken for each user action.
    Glowroot supports SQL capture and aggregation. Historical rollup of the data with
    retention configuration is one of the additional features that Glowroot provides.
  prefs: []
  type: TYPE_NORMAL
- en: Glowroot provides support for visualizing response time breakdown and response
    time percentiles in charts. It has a responsive user interface, which allows one
    to monitor the application using mobile devices, as well as from desktop systems,
    without any additional installations.
  prefs: []
  type: TYPE_NORMAL
- en: Glowroot comes in a ZIP file bundle. In order to get started with Glowroot,
    we have to download and unzip the ZIP file bundle. Glowroot requires changes in
    the JVM parameters of the application. We have to add `-javaagent:<path to glowroot.jar>`
    in the JVM arguments for the application.
  prefs: []
  type: TYPE_NORMAL
- en: Glowroot provides continuous profiling with filtering once it is set up and
    running. We can also set up alerts for response time percentiles and MBean attributes.
    Asynchronous requests spanning multiple threads are also supported by Glowroot.
    In terms of application servers, Glowroot supports Tomcat, Jetty, JBoss, Wildfly,
    and Glassfish.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following is the Glowroot JVM dashboard for reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/97ae8f5c-5592-4717-9892-d546f6a56d44.png)'
  prefs: []
  type: TYPE_IMG
- en: The Glowroot JVM dashboard view (source: https://demo.glowroot.org)
  prefs: []
  type: TYPE_NORMAL
- en: New Relic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: New Relic is another widely used application performance monitoring tool in
    the Java community. New Relic provides grouped views for application and network
    performance statistics. This helps in the quick diagnosis of domain level problems.
    It also provides features for drilling down into specific requests for viewing
    performance metrics by response time, data transfer size, and throughput.
  prefs: []
  type: TYPE_NORMAL
- en: 'New Relic supports applications developed in Java, Scala, Ruby, Python, PHP,
    .NET, and Node.js. New Relic offers four different approaches for backend monitoring:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Application performance management**: In application performance management,
    New Relic features high-level metrics with the ability to drill down to the code
    level to see how the application is performing. On the dashboard, New Relic displays
    a response time graph. New Relic uses the Apdex index score method to distill
    metrics into performance indicators. New Relic requires the user to manually set
    the threshold values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Server monitoring**: New Relic focuses on the hardware the application servers
    are running on. The measurements include CPU usage, memory utilization, disk I/O,
    and network I/O. New Relic provides brief details on the heap memory and garbage
    collection attributes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Database monitoring**: In New Relic, the dashboard for the database is a
    part of the application performance management dashboard. It is possible to view
    database monitoring metrics through plugins.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Insights and analytics**: New Relic has a built-in, opt-in database, which
    stores statistics and enables querying the database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Following is the New Relic dashboard for reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a9255a23-618e-4fb8-828c-4b5007fcd6c5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The New Relic dashboard view (source: https://newrelic.com/)
  prefs: []
  type: TYPE_NORMAL
- en: Profiling tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Profiling tools, or profilers, are software tools used by application developers
    to investigate and identify characteristics of and issues in the code. Profiling
    tools are also useful in identifying performance problems. Profiling tools answer
    questions like what JVM parameters are set, what the status of the heap memory
    is, what the generation-based classification of memory utilization is, which threads
    are active, and so on. Some profilers also track methods in the code to understand
    how frequently SQL statements are called, or how frequently web services are called.
  prefs: []
  type: TYPE_NORMAL
- en: Similar to application performance monitoring tools, many profiling tools are
    available on the market. VisualVM, JConsole, and HeapAnalyzer are a few of them.
    We will discuss each of the profiling tools in detail in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: VisualVM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'VisualVM is a Java profiling and performance analysis tool. It has a visual
    interface to analyze detailed information for Java applications running in local
    and remote environments on JVMs. It integrates and utilizes JDK provided command-line
    tools like `jstack`, `jconsole`, `jmap`, `jstat`, and `jinfo`. These tools are
    part of the standard JDK distribution. VisualVM is instrumental in solving runtime
    problems, with features such as heap dump and thread analysis. It helps in identifying
    application performance and where it stands against the benchmark. It also helps
    in ensuring optimal memory usage. It further helps in monitoring the garbage collector,
    profiling CPU usage, analyzing heap data, and tracking memory leaks. The following
    are the purposes of each of the command-line tools used by VisualVM:'
  prefs: []
  type: TYPE_NORMAL
- en: '`jstack`**:** This tool is used to capture the thread dumps of a Java application'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jmap`**:** This tool prints shared object memory maps and heap memory details
    for a given process'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jstat`**:** This tool displays performance statistics for JVMs running the
    application'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jinfo`**:** This tool prints Java configuration information'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'VisualVM is part of the standard JDK bundle. It was first bundled with the
    JDK platform in JDK version 6, update 7\. It can also be installed separately.
    Let''s look at each section in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/000eb193-e61d-4572-89d6-df59d25a9cc2.png)'
  prefs: []
  type: TYPE_IMG
- en: The Applications window view of VisualVM
  prefs: []
  type: TYPE_NORMAL
- en: As can be seen in the preceding screenshot, on the left-side of the window,
    there is an Applications window. The Applications window has nodes and subnodes.
    The nodes and subnodes can be expanded in order to view configured applications
    and saved files. We can view additional information or perform actions by right-clicking
    the nodes and choosing items from the pop-up menus that appear. The pop-up menu
    options vary, depending on the selected node.
  prefs: []
  type: TYPE_NORMAL
- en: Inside of the Applications window, we can see a menu for Local nodes. A local
    node displays information about the name of the process and process identifier
    for the Java processes running on the same machine as VisualVM. After launching
    VisualVM, the local nodes are automatically populated when the Local root node
    is expanded. VisualVM is always loaded as one of the local nodes. The nodes automatically
    disappear when the service is terminated. If we take thread dumps and heap dumps
    of an application, those are displayed like subnodes.
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to connect to JVM running on a remote machine using VisualVM.
    All such running processes or applications are displayed under the Remote node.
    After a connection is established with the remote node, we can expand the Remote
    node to see all Java applications running on the remote machine.
  prefs: []
  type: TYPE_NORMAL
- en: The VM Coredumps node is only visible if the application is running on Linux
    or Solaris operating systems. When a core dump file is opened in VisualVM, the
    VM Coredumps node shows the open core dump file. It is a binary file containing
    information about the runtime status of the machine.
  prefs: []
  type: TYPE_NORMAL
- en: The last section in the Applications window is labeled Snapshots. The Snapshots
    section displays all of the saved snapshots taken while the application is running.
  prefs: []
  type: TYPE_NORMAL
- en: The data for local or remote applications is presented in tabs in VisualVM.
    The Overview tab is opened by default when viewing application data. The Overview
    tab displays information including the process ID, the location of the system,
    the main class for the application, the path to the Java installation, JVM arguments
    passed, JVM flags, and system properties.
  prefs: []
  type: TYPE_NORMAL
- en: The next tab in the list is the Monitor tab. The Monitor tab can be used to
    view real-time information about heap memory, permanent generation heap memory,
    and the number of classes and threads. The classes here indicate classes loaded
    into the virtual machine. The application monitoring process puts on low overhead.
  prefs: []
  type: TYPE_NORMAL
- en: The heap graph on the Monitor tab displays the total heap size and currently
    used heap size. The changes in the permanent generation area over a period of
    time are displayed in the PermGen graph. The classes graph displays the total
    number of loaded and shared classes. The number of live and daemon threads information
    is displayed in the Threads section. VisualVM can be used to take a thread dump,
    which shows exact information on threads at a specific time.
  prefs: []
  type: TYPE_NORMAL
- en: 'From within the Monitor tab, we can forcefully perform garbage collection.
    The action will immediately run garbage collection. It is also possible to capture
    a heap dump from the Monitor tab:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/60038421-778a-43a9-8075-aa2b08bb0880.png)'
  prefs: []
  type: TYPE_IMG
- en: VisualVM displays real-time thread activity in the Threads tab. As a default,
    the Threads tab shows the timeline of current thread activity. By clicking on
    a particular thread, we can view details about that particular thread in the Details
    tab.
  prefs: []
  type: TYPE_NORMAL
- en: The Timeline section shows a timeline with real-time thread states. We can filter
    the types of threads displayed by choosing the appropriate values in the drop-down
    menu. In the preceding screenshot, it shows the Live threads timeline. We can
    also view all of the threads, or finished threads, by selecting this from the
    drop-down menu.
  prefs: []
  type: TYPE_NORMAL
- en: We can choose to take a thread dump of the application while the application
    is running. The thread dump, when printed, shows a thread stack that includes
    thread states for Java applications.
  prefs: []
  type: TYPE_NORMAL
- en: The Profiler tab makes it possible to start and stop the profiling sessions
    of an application. The results are displayed in the Profiler tab itself. Profiling
    can be done for CPU profiling or memory profiling. Upon starting the profiling
    session, VisualVM connects to the application to start collecting the profiling
    data. Once the results are available, they are displayed in the Profiler tab automatically.
  prefs: []
  type: TYPE_NORMAL
- en: JConsole
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JConsole is another Java profiling tool. It compiles to **Java Management Extension**
    (**JMX**) specifications. JConsole extensively uses instrumentation in JVM to
    collect and display information about the performance and resource consumption
    of applications running on the Java platform. JConsole is updated to a GNOME and
    Windows look and feel in Java SE 6.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to VisualVM, JConsole comes bundled with the Java development kit.
    The executable file for JConsole can be found in the `JDK_HOME/bin` directory.
    JConsole can be started from the Command Prompt or console window with the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Upon executing the preceding command, JConsole presents the user with a choice
    of all of the Java applications running on the system. We can choose to connect
    to any running application.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also possible to supply the process ID, if we know the process ID of
    the Java application that we want JConsole to connect to. The following is the
    command to boot JConsole up, with a connection to a specific Java application
    identified by its process ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The following command can be used to connect to a Java application running
    on a remote machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'JConsole presents information in the following tabs:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Overview: This tab displays information about the JVM and values to be monitored.
    It presents the information in a graphical monitoring format. The information
    contains overview details on CPU usage, memory usage, thread counts, and the number
    of classes loaded in JVM.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Memory: This tab displays information about memory consumption and usage. The
    memory tab contains a Perform GC button, which can be clicked to activate immediate
    garbage collection. For the HotSpot Java VM, the memory pools are Eden Space,
    Survivor Space, Tenured Generation, Permanent Generation, and Code Cache. It is
    possible to display various charts for depicting the consumption of memory pools.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Threads: This tab displays information about thread usage. The threads include
    active threads, Live threads, and all threads. The chart''s representation shows
    the peak number of threads and the number of live threads on two different lines.
    MXBean provides other information not covered by the Threads tab. With MXBean,
    it is possible to detect deadlocked threads.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Classes: This tab displays information about classes loaded in the Java virtual
    machine. The class information includes the total number of classes loaded so
    far, including those which are unloaded later on and the current number of classes
    loaded.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'VM: This tab displays statistical information about the Java virtual machine.
    The summary includes uptime, indicating the amount of time since the JVM started;
    the process CPU time, indicating the amount of CPU time that JVM has consumed
    since it started; and the total compile time, indicating the time spent on the
    compilation process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'MBeans: This tab displays information about MBeans. The MBeans include those
    currently running. We can get `MBeanInfo` descriptor information by selecting
    the MBean.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Following screenshot shows how the JConsole dashboard looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/43734b6d-8df0-4662-be7d-258c92879688.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter was full of information on application performance measurement
    techniques. The chapter is useful for development teams working on application
    performance enhancement tasks. At the same time, it can be referred to by technical
    teams setting up their application logging mechanisms.
  prefs: []
  type: TYPE_NORMAL
- en: The chapter started with introductory details on performance profiling and logging.
    Moving ahead, we learned about specific application performance monitoring and
    application logging. We learned what the key elements of logging are. We also
    looked into logging tools, like standard Java logging and Log4j. In the latter
    part of the chapter, we learned about VisualVM as a performance profiling tool.
    VisualVM is one of the most widely used Java-based performance profiling tools,
    available as a standard Java distribution package. That was it for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will focus on optimizing application performance. One can leverage
    the knowledge and information provided in this chapter in the next chapter while
    working on performance optimization. This chapter provides a base for the next
    chapter. The next chapter covers details for identifying the symptoms of performance
    issues, the performance tuning life cycle, and JMX support in Spring. Pretty exciting
    stuff, isn't it?
  prefs: []
  type: TYPE_NORMAL
