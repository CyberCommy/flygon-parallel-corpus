- en: Chapter 1. Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**PHP Data Objects**, (**PDO**) is a PHP5 extension that defines a lightweight
    DBMS connection abstraction library (sometimes called data access abstraction
    library). The need for a tool like PDO was dictated by the great number of database
    systems supported by PHP. Each of these database systems required a separate extension
    that defined its own API for performing the same tasks, starting from establishing
    a connection to advanced features such as preparing statements and error handling.'
  prefs: []
  type: TYPE_NORMAL
- en: The fact that these APIs were not unified made transition between underlying
    databases painful, often resulting in the rewriting of many lines of code, which
    in turn, led to new programming errors that required time to track, debug and
    correct. On the other hand, the absence of a unified library, like JDBC for Java,
    was putting PHP behind the big players in the programming languages world. Now
    that such library exists, PHP is regaining its position and is a platform of choice
    for millions of programmers.
  prefs: []
  type: TYPE_NORMAL
- en: It should be noted, however, that there exist several libraries written in PHP,
    that serve the same purpose as PDO. The most popular are the ADOdb library and
    the PEAR DB package. The key difference between them and PDO is speed. PDO is
    a PHP extension written in a compiled language (C/C++), while the PHP libraries
    are written in an interpreted language. Also, once PDO is enabled, it does not
    require you to include source files in your scripts and redistribute them with
    your application. This makes installing your applications easier, as the end user
    does not need to take care of third-party software.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here, we are neither comparing these libraries with PDO nor advocating the use
    of PDO over such libraries. We are just showing the advantages and disadvantages
    of this extension. For example, the PEAR package, MDB2, has richer functionality
    of an advanced database abstraction library, which PDO does not.
  prefs: []
  type: TYPE_NORMAL
- en: PDO being a PECL extension, itself relies on database-specific drivers and on
    other PECL extensions. These drivers must also be installed in order to use PDO
    (you only need the drivers for the databases you are using). Since the description
    of installation of PDO and database-specific drivers is beyond the scope of this
    book, you can refer to PHP manual at [www.php.net/pdo](http://www.php.net/pdo)
    for technical information regarding installation and upgrade issues.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: PECL is PHP Extension Community Library, a repository of PHP extensions written
    in C. These extensions offer functionality that would be impossible to implement
    in PHP, as well as some extensions that exist for performance reasons as the C
    code is much faster than PHP. The home page of PECL is at [http://pecl.php.net](http://pecl.php.net)
  prefs: []
  type: TYPE_NORMAL
- en: Using PDO
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As it has been noted in the previous section, PDO is a connection, or data access
    abstraction library. This means that PDO defines a unified interface for creating
    and maintaining database connections, issuing queries, quoting parameters, traversing
    result sets, dealing with prepared statements, and error handling.
  prefs: []
  type: TYPE_NORMAL
- en: We will give a quick overview of these topics here and look at them in greater
    detail in the following chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to the Database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s consider the well-known MySQL connection scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Here, we establish a connection and then select the default database for the
    connection. (We ignore the issue of possible errors.)
  prefs: []
  type: TYPE_NORMAL
- en: 'In SQLite, for example, we would write something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Here again we ignore errors (we will cover more on this later). For completeness,
    let''s see how we would connect to a PostgreSQL:'
  prefs: []
  type: TYPE_NORMAL
- en: pg_connect("host=$host dbname=$db user=$user password=$password");
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, all three databases require quite different ways of opening
    a connection. While this is not a problem now, but if you always use the same
    database management system in case you need to migrate, you will have to rewrite
    your scripts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s see what PDO has to offer. As PDO is fully object-oriented, we
    will be dealing with **connection objects**, and further interaction with the
    database will involve calling various methods of these objects. The examples above
    implied the need for something analogous to these connection objects—calls to
    `mysql_connect` or `pg_connect` return link identifiers and PHP variables of a
    special type: **resource**. However, we didn''t use connection objects then since
    these two database APIs don''t require us to explicitly use them if we only have
    one connection in our scripts. However, SQLite always requires a link identifier.'
  prefs: []
  type: TYPE_NORMAL
- en: With PDO, we will always have to explicitly use the connection object, since
    there is no other way of calling its methods. (Those unfamiliar with object-oriented
    programming should refer to Appendix A).
  prefs: []
  type: TYPE_NORMAL
- en: 'Each of the three above connections could be established in the following manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the only part that is changing here is the first argument passed
    to the PDO constructor. For SQLite, which does not utilize username and password,
    the second and third arguments can be skipped.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: SQLite is not a database server, but it is an embedded SQL database library
    that operates on local files. More information about SQLite can be found at [www.sqlite.org](http://www.sqlite.org)
    and more information about using SQLite with PHP can be found at [www.php.net/sqlite](http://www.php.net/sqlite).
    Information about using SQLite with PDO can be obtained from [www.php.net/manual/en/ref.pdo-sqlite.php](http://www.php.net/manual/en/ref.pdo-sqlite.php)
  prefs: []
  type: TYPE_NORMAL
- en: Connection Strings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you have seen in previous example, PDO uses the so-called **connection strings**
    (or Data Source Names, abbreviated to DSN) that allow the PDO constructor to select
    proper driver and pass subsequent method calls to it. These connection strings
    or DSNs are different for every database management system and are the only things
    that you will have to change.
  prefs: []
  type: TYPE_NORMAL
- en: If you are designing a big application that will be able to work with different
    databases, then this connection string (together with a connection username and
    a password) can be defined in a configuration file and later used in the following
    manner (assuming your configuration file is similar to `php.ini)`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Your configuration file might then look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We will cover connection strings in more detail in [Chapter 2](ch02.html "Chapter 2. Using
    PHP Data Objects: First Steps"); here we gave a quick example so that you can
    see how easy it is to connect to different database systems with PDO.'
  prefs: []
  type: TYPE_NORMAL
- en: Issuing SQL Queries, Quoting Parameters, and Handling Result Sets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: PDO would not be worth a whole book, if it didn't go beyond the single interface
    for creating database connections. The PDO object introduced in the previous example
    has all the methods needed to uniformly execute queries regardless of the database
    used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider a simple query that would select all the car `make` attributes
    from an imaginary database employed at a used car lot. The query is as simple
    as the following SQL command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Previously, we would have had to call different functions, depending on the
    database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we are using PDO, we can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, doing things the PDO way is not too different from traditional
    methods of issuing queries. Also, here it should be underlined, that a call to
    `$conn->query()` is returning another object of class `PDOStatement`, unlike the
    calls to `mysql_query(), sqlite_query()`, and `pg_query()`, which return PHP variables
    of the **resource** type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s make our simplistic SQL query a bit more complicated so that it
    selects the total value of all Fords on sale in our imaginary car lot. The query
    would then look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'To make our example even more interesting, let''s assume that the name of the
    car manufacturer is held in a variable ($make) so that we must quote it, before
    passing it to the database. Our non-PDO queries would now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The PDO class defines a single method for quoting strings so that they can
    be used safely in queries. We will discuss security issues such as SQL injection,
    in [Chapter 3](ch03.html "Chapter 3. Error Handling"). This method does a neat
    thing; it will automatically add quotes around the value if necessary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Again, you can see that PDO allows you to use the same pattern as you would
    have used before, but the names of all the methods are unified.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have issued our query, we will want to see its results. As the
    query in the last example will always return just one row, we will want more rows.
    Again, the three databases will require us to call different functions on the
    `$q` variable that was returned from one of the three calls to `mysql_query(),
    sqlite_query()`, or `pg_query()`. So our code for getting all the cars will look
    similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the idea is the same, but we have to use different function
    names. Also, note that SQLite requires an extra parameter if we want to get the
    rows in the same way as with MySQL and PostgreSQL (of course, this could be omitted,
    but then the returned rows would contain both column name indexed and numerically
    indexed elements.)
  prefs: []
  type: TYPE_NORMAL
- en: 'As you may already have guessed, things are pretty straightforward when it
    comes to PDO: We don''t care what the underlying database is, and the methods
    for fetching rows are the same across all databases. So, the above code could
    be rewritten for PDO in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Nothing is different from what happens before. One thing to note here is that
    we explicitly specified the `PDO::FETCH_ASSOC` fetch style constant here, since
    PDO''s default behavior is to fetch the result rows as arrays indexed both by
    column name and number. (This behavior is similar to `mysql_fetch_array(), sqlite_fetch_array()`
    without the second parameter, or `pg_fetch_array().)` We will discuss the fetch
    styles that PDO has to offer in [Chapter 2](ch02.html "Chapter 2. Using PHP Data
    Objects: First Steps").'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The last example was not intended to be used to render HTML pages as it used
    the newline character to separate lines of output. To use it in a real webpage,
    you will have to change `echo $r['make'], "\n"`; to `echo $r['make'], "<br>\n"`;
  prefs: []
  type: TYPE_NORMAL
- en: Error Handling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Of course, the above examples didn't provide for any error checking, so they
    are not very useful for real-life applications.
  prefs: []
  type: TYPE_NORMAL
- en: When working with a database, we should check for errors when opening the connection
    to the database, when selecting the database and after issuing every query. Most
    web applications, however, just need to display an error message when something
    goes wrong (without going into error detail, which could reveal some sensitive
    information). However, when debugging an error, you (as the developer) would need
    the most detailed error information possible so that you can debug the error in
    the shortest possible time.
  prefs: []
  type: TYPE_NORMAL
- en: 'One simplistic scenario would be to abort the script and present the error
    message (although this is something you probably would not want to do). Depending
    on the database, our code might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, error handling is starting to get a bit different for SQLite
    compared to MySQL and PostgreSQL. (Note the call to `sqlite_error_string (sqlite_last_error($dbh)).)`
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we take a look at how to implement the same error handling strategy
    with PDO, we should note that this will be only one of the three possible error
    handling strategies in PDO. We will cover them in detail later in this book. Here
    we will just use the simplest one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This example shows that PDO will force us to use a slightly different error
    handling scheme from the traditional one. We wrapped the call to the PDO constructor
    in a *try* … *catch* block. (Those who are new to PHP5's object-oriented features
    should refer to Appendix A.) This is because while PDO can be instructed not to
    use exceptions, (in fact, it is PDO's default behavior not to use exceptions),
    however, you cannot avoid exceptions here. If the call to the constructor fails,
    an exception will always be thrown.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is a very good idea to catch that exception because, by default, PHP will
    abort the script execution and will display an error message like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Fatal error: Uncaught exception ''PDOException'' with message ''SQLSTATE[28000]
    [1045] Access denied for user ''bosss''@''localhost'' (using password: YES)''
    in /var/www/html/pdo.php5:3 Stack trace: #0 c:\www\hosts\localhost\pdo.php5(3):
    PDO->__construct(''mysql:host=loca...'', ''bosss'', ''password'', Array) #1 {main}
    thrown in /var/www/html/pdo.php5 on line 3**'
  prefs: []
  type: TYPE_NORMAL
- en: 'We made this exception by supplying the wrong username, *bosss*, in the call
    to the PDO constructor. As you can see from this output, it contains some details
    that we would not like others to see: Things like file names and script paths,
    the type of database being used, and most importantly, usernames and passwords.
    Suppose that this exception had happened when we had supplied the right username
    and something had gone wrong with the database server. Then the screen output
    would have contained the real username and password.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we catch the exception properly, the error output might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '**SQLSTATE[28000] [1045] Access denied for user ''bosss''@''localhost'' (using
    password: YES)**'
  prefs: []
  type: TYPE_NORMAL
- en: 'This error message contains much less sensitive information. (In fact, this
    output is very similar to the error output that would be produced by one of our
    non-PDO examples.) But we will again warn you that the best policy is just show
    some neutral error message like: "Sorry, the service is temporarily unavailable.
    Please try again later." Of course, you should also log all errors so that you
    can find out later whether anything bad has happened.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Prepared Statements**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is a rather advanced topic, but you should become familiar with it. If
    you are a user of PHP with MySQL or SQLite, then you probably didn't even hear
    of prepared statements, since PHP's MySQL and SQLite extensions don't offer this
    functionality. PostgreSQL users might have already used `pg_prepare()` and `pg_execute()`
    in tandem. MySQLi (the *improved* MySQL extension) also offers the prepared statements
    functionality, but in a somewhat awkward way (despite the possible object-oriented
    style).
  prefs: []
  type: TYPE_NORMAL
- en: For those who are not familiar with **prepared statements**, we will now give
    a short explanation.
  prefs: []
  type: TYPE_NORMAL
- en: 'When developing database-driven, interactive dynamic applications, you will
    sooner or later need to take user input (which may originate from a form) and
    pass it as a part of a query to a database. For example, given our cars'' database,
    you might design a feature that will output a list of cars made between any two
    years. If you allow the user to enter these years in a form, the code will look
    something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In this simple example the query depends on two variables, which are part of
    the resulting SQL. A corresponding prepared statement in PDO would look something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we replaced the `$sy` and `$ey` variables with placeholders
    in the query body. We can now manipulate this query to create the prepared statement
    and execute it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: These three lines of code tells us that the prepared statements are objects
    (with class `PDOStatement)`. They are created using calls to `PDO::prepare()`
    method that accepts an SQL statement with placeholders as its parameters.
  prefs: []
  type: TYPE_NORMAL
- en: The prepared statements then have to be *executed* in order to obtain the query
    results by calling the `PDOStatement::execute()` method. As the example shows,
    we call this method with an array that holds the values for the placeholders.
    Note how the order of the variables in that array matches the order of the placeholders
    in the `$sql` variable. Obviously, the number of elements in the array must be
    the same as the number of placeholders in the query.
  prefs: []
  type: TYPE_NORMAL
- en: 'You have probably noticed that we are not saving the result of the call to
    the `PDOStatement::execute()` method in any variable. This is because the statement
    object itself is used to access the query results, so that we can complete our
    example to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As this complete example shows, we call the `PDOStatement::fetch()` method until
    it returns a false value, at which point the loop quits—just like we did in previous
    examples when discussing result sets traversal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, the replacement of question mark placeholders with actual values
    is not the only thing that prepared statements can do. Their power lies in the
    possibility of being executed as many times as needed. This means that we can
    call the `PDOStatement::execute()` method as many times as we want, and every
    time we can supply different values for the placeholders. For example, we can
    do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Prepared statements tend to execute faster than calls to `PDO::query()` methods,
    since the database drivers optimize them only once, in a call to `PDO::prepare()`
    methods. Another advantage of using prepared statements is that you don't have
    to quote the parameters passed in a call to `PDOStatement::execute()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example we used an explicit cast of the request parameters into integer
    variables, but we could also have done the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The prepared statement here will take care of the proper quoting made before
    executing the query.
  prefs: []
  type: TYPE_NORMAL
- en: And just to finish the introduction of the prepared statements here, probably
    the best feature about them is that PDO emulates them for every supported database.
    This means you can use prepared statements with any databases; even if they don’t
    know what they are.
  prefs: []
  type: TYPE_NORMAL
- en: Appropriate Understanding of PDO
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our introduction would not be complete if we didn''t mention that. PDO is a
    database connection abstraction library, and as such, cannot ensure that your
    code will work for each and every database that it supports. This will only happen
    if your SQL code is portable. For example, MySQL extends the SQL syntax with this
    form of insert:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This kind of SQL code is not portable, as other databases do not understand
    this way of doing inserts. To ensure that your inserts work across databases,
    you should replace the above code with :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This is just one example of incompatibilities that may arise when you use PDO.
    It is only by making your database schema and SQL portable that can ensure you
    that your code will be compatible with other databases. However, ensuring this
    portability is beyond this text.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This introductory chapter showed you the basics of using PDO when developing
    dynamic, database-driven applications with the PHP5 language. Also we looked at
    how PDO can be effectively used to eliminate the differences between different
    traditional database access APIs and to produce a clearer and more portable code.
  prefs: []
  type: TYPE_NORMAL
- en: In the subsequent chapters, we will be looking at each of the features discussed
    in this chapter in a greater detail so that you fully master the PHP Data Objects
    extension.
  prefs: []
  type: TYPE_NORMAL
