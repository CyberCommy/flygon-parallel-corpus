- en: Development Mode and Mastering Hot Reloading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, you learned how to use `create-react-app`. This is
    just the beginning of our *React toolin*g journey. By using `create-react-app`
    to bootstrap your application, you''re installing many other tools used for development.
    These tools are part of the `react-scripts` package. The focus of this chapter
    will be the development server that comes with `react-scripts` where we''ll cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Starting the development server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automatic Webpack configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Putting hot component reloading to use
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Starting the development server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you created a React application using the `create-react-app` tool in the
    previous chapter, then you have everything you need to launch a development server.
    No configuration is necessary! Let''s start it up right now. First, make sure
    that you''re in the project directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can start the development server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This will start the development server using the `start` script from the `react-scripts`
    package. You should see the console output that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ll notice that in addition to printing this output in the console, this
    script will launch a new browser tab with `http://localhost:3000/` as the address.
    The page that''s displayed looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/1dcf9a53-b771-44f1-bf22-e40360ffbf28.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We''ve accomplished a lot in just a couple of chapters so far. Let''s pause
    and recap what we''ve done:'
  prefs: []
  type: TYPE_NORMAL
- en: You created a new React application using the `create-react-app` package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You have the basic project structure in place and a placeholder `App` component
    to render.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You launched the development server, and now you're ready building React components.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To get to this point without `create-react-app` and `react-scripts` would typically
    take hours. You probably don't have hours to spend messing with meta development
    work. A lot of it has just been automated for you!
  prefs: []
  type: TYPE_NORMAL
- en: Webpack configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Webpack is the tool of choice for building modern web applications. It's powerful
    enough to compile everything from JSX syntax to static images into bundles that
    are ready to deploy. It also comes with a development server. Its main drawback
    is its complexity. There are a lot of moving parts that need to be configured
    just to get Webpack off the ground, but you didn't have to touch any of it. This
    is because most of the Webpack configuration values that you would set for a React
    app are the same for most React apps.
  prefs: []
  type: TYPE_NORMAL
- en: There are two separate pieces of the development server to configure. First,
    there's the Webpack development server itself. Then, there's the main Webpack
    configuration, which you'll need even if you weren't using the Webpack development
    server. So where are these configuration files? They're part of the `react-scripts`
    package, meaning, you don't have to mess around with them!
  prefs: []
  type: TYPE_NORMAL
- en: Let's walk through some of these configuration values now to give you a better
    sense of the unnecessary headache you're able to avoid.
  prefs: []
  type: TYPE_NORMAL
- en: Entry points
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Entry points are used to tell Webpack where to start looking for modules used
    to build your application. With a simple application, you don't need anything
    more than a single file as your entry point. For example, this could be your `index.js`
    file that's used to render your root React component. Another way to think of
    this entry point, borrowing terminology from other programming languages, is the
    main program.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `react-scripts` package looks for an `index.js` file in your source folder
    when you run the `start` script. It adds a couple of other entry points as well:'
  prefs: []
  type: TYPE_NORMAL
- en: Polyfills for `Promise`, `fetch()`, and `Object.assign()`. These are only used
    if they don't already exist in the target browser.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A client for hot module reloading.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These last two entry points are valuable for React development, but they're
    not something you want to have to think about when you're trying to get a project
    off the ground.
  prefs: []
  type: TYPE_NORMAL
- en: Build output
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The job of Webpack is to bundle your application resources so that they can
    be easily served from the web. This means that you have to configure various things
    related to bundle output, starting with the output path and file. The Webpack
    development server doesn't actually write a bundle file to disk because it is
    assumed that builds will happen frequently. The resulting bundle is kept in memory.
    Even with this in mind, you still have to configure the main output path because
    the Webpack development server still needs to serve it to the browser as though
    it were a real file.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the main output location, you can also configure chunk filenames
    and the public path used to serve files from. Chunks are bundles that are split
    into smaller pieces to avoid creating a single bundle file that's too big and
    might cause performance problems. Wait, what? Thinking about performance and the
    path used to serve resources before you've even implemented a single component
    for your application? This is completely unnecessary at this point in the project.
    Don't worry, `react-scripts` has you covered and provides configuration for output
    that you probably won't ever need to change.
  prefs: []
  type: TYPE_NORMAL
- en: Resolving input files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the key strengths of Webpack is that you don't need to supply it with
    a list of modules that need to be bundled. Once you supply an entry point in the
    Webpack configuration, it can figure out which modules your application needs,
    and will bundle them accordingly. Needless to say, this is a complex task that
    Webpack is performing for you and needs all the help it can get.
  prefs: []
  type: TYPE_NORMAL
- en: For example, part of the `resolve` configuration is telling Webpack which file
    extensions to consider, for example, `.js` or `.jsx`. You also want to tell Webpack
    where to look for package modules. These are modules that you didn't write and
    aren't part of your application. These are npm packages that are typically found
    in the `node_modules` directory of your project.
  prefs: []
  type: TYPE_NORMAL
- en: There are more advanced options as well, such as creating aliases for modules
    and using resolver plugins. Once again, none of these things are relevant to you
    before you write any React code, yet, you need them configured so that you can
    develop your components, unless of course, you're using `react-scripts` to take
    care of this configuration for you.
  prefs: []
  type: TYPE_NORMAL
- en: Loading and compiling files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Loading and compiling files for your bundle are probably the most important
    capabilities of Webpack. Interestingly, Webpack doesn''t directly process your
    files once they''re loaded. Instead, it coordinates I/O as it passes through Webpack
    loader plugins. For example, the Webpack configuration used by `react-scripts`
    uses the following loader plugins:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Babel**: The Babel loader transpiles the JavaScript in your application''s
    source files into JavaScript that all browsers will understand. Babel will also
    take care of compiling your JSX syntax into regular JavaScript.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CSS**: There are a couple loaders used by `react-scripts` that result in
    CSS output:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`style-loader`: Import CSS modules like JavaScript modules using the `import`
    syntax.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`postcss-loader`: Enhanced CSS features like modules, functions, and custom
    properties.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Images**: Images that are imported by JavaScript or CSS are bundled using
    `url-loader`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As your application matures, you might find yourself needing to load and bundle
    different types of assets that fall outside of the default `react-scripts` configuration.
    Since you don't need to worry about this at the beginning of your project, there's
    no point in wasting time configuring Webpack loaders.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring plugins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There's a seemingly infinite list of plugins that you can add to your Webpack
    configuration. Some of them are really useful for development, so you want these
    plugins configured up front. Others might not prove useful until down the road
    as your project matures. The plugins that `react-scripts` uses out of the box
    contribute to a seamless React development experience.
  prefs: []
  type: TYPE_NORMAL
- en: Hot reloading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The hot module reloading mechanism requires configuration in both the main Webpack
    bundle configuration file, as well as the development server configuration. This
    is another example of something that you want as soon as you start developing
    your components, but don't want to spend time on. The `start` command of `react-scripts`
    starts a Webpack development server with hot reloading configured and ready to
    go.
  prefs: []
  type: TYPE_NORMAL
- en: Hot component reloading in action
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Earlier in this chapter, you learned how to start the `react-scripts` development
    server. This development server has hot module reloading configured and ready
    to use. All you have to do is start writing component code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by implementing the following heading component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This component will render any child text as an `<h1>` tag. Easy enough? Now,
    let''s change the `App` component to use `Heading`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you can see what this looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/485a5c5f-f3a7-44db-b479-b00cd63f5c98.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `Heading` component is rendered as expected. Now that you''ve initially
    loaded your application in the browser, it''s time to put the hot reloading mechanism
    to work. Let''s say that you''ve decided to change the title of this heading:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as you hit save in your code editor, the Webpack development server
    detects that a change has taken place and that new code should be compiled, bundled,
    and sent to the browser. Since `react-scripts` has taken care of configuring Webpack,
    you can just head right into the browser and watch the changes as they take place:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/e7c80c59-40c7-4e5c-9a24-49c2a71ce4b7.png)'
  prefs: []
  type: TYPE_IMG
- en: This should help speed up development! In fact, it already has and you've just
    witnessed it. You altered the text of a React element and saw the result immediately.
    You could have spent hours setting up this infrastructure with Webpack configuration
    at the center of it, but you didn't have to because you just reused the configuration
    provided by `react-scripts` because nearly all React development configurations
    should look about the same. Over time they diverge, but projects without any components
    look awfully similar. The name of the game is to hit the ground running.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s try something different. Let''s add a component with `state` and
    see what happens when we change it. Here''s a simple button component that keeps
    track of its clicks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s break down what''s happening with this component:'
  prefs: []
  type: TYPE_NORMAL
- en: It has a `style` object, but without any properties, so this has no effect.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It has a `count` state that is incremented each time the button is clicked.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `onClick()` handler sets the new `count` state, incrementing the old `count`
    state by `1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `render()` method renders a `<button>` element with an `onClick` handler
    and a `style` property.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once you click on this button, it will have a new state. How will this work
    with hot module loading? Let''s try it out. We''ll render this `Button` component
    in our `App` component as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'When you load the UI, you should see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/d1d97bb0-a1fc-4eb7-9769-4c83ad7d8f19.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Clicking on the button should increment the `count` state by `1`. Sure enough,
    clicking it a few times causes the rendered button label to change, reflecting
    the new state:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/0753634f-4787-49aa-9bdb-f3a75138c414.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s say that you wanted to change the style of the button. We''ll make
    the text bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The hot module mechanism works as expected, but with one important difference:
    the state of the `Button` component has reverted to its initial state:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/20a0a67c-9e7c-471b-a3f8-37919c578ef6.png)'
  prefs: []
  type: TYPE_IMG
- en: This happens because when the `Button.js` module is replaced, the existing component
    instance is unmounted before being replaced with the new instance. The state of
    the component is blown away along with the component itself.
  prefs: []
  type: TYPE_NORMAL
- en: The solution to this is to use the *React Hot Loader* tool. This tool will keep
    your components mounted as their implementation is updated. This means that the
    state persists. In some cases, this can be incredibly helpful. Is this needed
    when you're just getting started? Probably not—hot module reloading that doesn't
    persist state is good enough to get rolling.
  prefs: []
  type: TYPE_NORMAL
- en: Ejecting from Create React App
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The goal of `create-react-app` and `react-scripts` is zero-configuration React
    development. The less time you spend configuring development boilerplate, the
    more time you spend developing components. You should continue to avoid worrying
    about configuring your app for as long as you can. But at some point, you'll have
    to bail on `create-react-app` and maintain your own configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Providing a zero-configuration environment is only possible because many defaults
    and many limitations are assumed by `create-react-app`. This is the trade-off.
    By providing sane defaults for most of the things that React developers have to
    do but don't want to, you're making a choice for the developer. This is a good
    thing—being able to punt on decisions early in the development of your application
    makes you more productive.
  prefs: []
  type: TYPE_NORMAL
- en: React component hot loading is a good example of a limitation of `create-react-app`.
    It isn't part of the configuration offered by `create-react-app` because you probably
    don't need it early on in your project. But as things become more complex, being
    able to troubleshoot your components without disrupting their current state is
    critical. At this point in the project, `create-react-app` has served its purpose
    and it's time to eject.
  prefs: []
  type: TYPE_NORMAL
- en: 'To eject from `create-react-app`, run the `eject` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: You'll be asked to confirm this action, because there's no going back. At this
    point, it's worth reinforcing the point that you should not eject from `create-react-app`
    until it gets in the way. Remember, once you eject from `create-react-app`, you
    now assume the responsibilities of maintaining all of the scripts and all of the
    configuration that was once hidden from view.
  prefs: []
  type: TYPE_NORMAL
- en: 'The good news is that part of the ejection process involves setting up scripts
    and configuration values for your project. Essentially, it''s the same thing that
    `react-scripts` uses internally, except now these scripts and config files are
    copied into your project directory for you to maintain. For example, after ejecting,
    you''ll see a `scripts` directory with the following files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`build.js`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`start.js`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`test.js`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now if you take a look at `package.json`, you''ll see that the scripts that
    you invoke using `npm` now reference your local scripts instead of referencing
    the `react-scripts` package. In turn, these scripts use the files found in the
    `config` directory that was created for you when you ran eject. Here are the relevant
    Webpack configuration files found here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`webpack.config.dev.js`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`webpack.config.prod.js`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`webpackDevServer.config.js`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remember, these files are copied over from the `react-scripts` package. Ejecting
    simply means that you now control everything that was once hidden. It's still
    set up the exact same way and will remain so until you change it.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s suppose that you''ve decided that you need hot module replacement
    for React in a way that persists component state. Now that you''ve ejected from
    `create-react-app`, you can configure the necessary parts that enable the `react-hot-loader`
    tool. Let''s start by installing the dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s update the `webpack.config.dev.js` file so that it uses `react-hot-loader`.
    This is something that would have been impossible to configure before we ejected.
    There are two sections that need to be updated:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, find the following line in the `entry` section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace this with the following two lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, you have to add `react-hot-loader` to the `module` section of the Webpack
    configuration. Find the following object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace it with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: All you're doing here is changing the `loader` option to the `use` option so
    that you can pass an array of loaders. The `babel-loader` that you were using
    stays the same. But now you've added the `react-hot-loader/webpack` loader as
    well. Now this tool can detect when it needs to hot replace React components when
    their source changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s all you have to change with your development Webpack configuration.
    Next, you''ll have to change the way that your root React component is rendered.
    Here''s what `index.js` used to look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'To enable hot component replacement, you can change `index.js` so that it looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s break down what you''ve just added:'
  prefs: []
  type: TYPE_NORMAL
- en: The `import 'react-hot-loader/patch'` statement is necessary to bootstrap the
    `react-hot-loader` mechanism.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You've created a `render()` function that accepts a component to render. The
    component is wrapped with the `AppContainer` component from `react-hot-loader`,
    which handles some of the bookkeeping associated with hot loading.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first call to `render(App)` renders the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The call to `module.hot.accept()` sets up a callback function that renders the
    `App` component when a new version of the component arrives.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now your app is ready to receive hot React component updates. It was always
    able to receive updates when your source changed, but as discussed earlier in
    the chapter, these updates will wipe out any state in the component before the
    component is re-rendered. Now that `react-hot-loader` is in place, you get to
    keep any state in your components. Let's try it out.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you load up the UI, click on the button a few times to change its state.
    Then, change the `style` constant to make the font bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you save this file, you''ll notice that the button component has been
    updated. More importantly, the state hasn''t changed! If you clicked on the button
    twice, it should look like this now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/b7439ce3-0172-47ea-a557-57f5447d0030.png)'
  prefs: []
  type: TYPE_IMG
- en: This was a simple example that involved only one button. But the setup that
    you've just created by ejecting from `create-react-app`, tweaking the development
    Webpack configuration, and changing the way the `App` component is rendered can
    support hot component loading with every component you create going forward.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the `react-hot-loader` package to your project is just one example of
    the need to eject from `create-react-app` so that you can tweak the configuration.
    I would caution against changing what's absolutely necessary. Make sure that you
    have a specific goal in mind when you change the configuration that `create-react-app`
    gives you. In other words, don't undo all the work that `create-react-app` has
    done for you.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to start the development server for a project
    created with `create-react-app`. You then learned that the `react-scripts` package
    has its own Webpack configuration that it uses when it starts the development
    server for you. We went over the key areas of configuration that you shouldn't
    necessarily have to think about when you're trying to write an application.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you saw hot module reloading in action. Out of the box, `react-scripts`
    reloads the app for you when you make source changes. This results in a page refresh,
    which is good enough to get started. We then looked at the potential challenges
    of developing components using this approach because it wipes out any state that
    the component had before it was updated. So you ejected from `create-react-app`
    and customized the Webpack configuration for your project to support hot component
    reloading that will preserve the state.
  prefs: []
  type: TYPE_NORMAL
- en: In the following chapter, you'll work with tooling to support unit tests in
    your React application.
  prefs: []
  type: TYPE_NORMAL
