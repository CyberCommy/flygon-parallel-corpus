- en: Security, Updating, and Package Management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Checking package versions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking the OS version
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking for updates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automating updates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking mailing lists and errata pages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using snaps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Flatpak
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Pip, RubyGems, and other package managers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependency hell (a quick word)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compiling from sources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding additional repositories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Your system will be in a perfect state once (maybe twice) in its lifetime.
  prefs: []
  type: TYPE_NORMAL
- en: The first time that it's perfect, unsullied, and unsoiled, is when it's installed
    (providing that you've ticked the box to update the packages during installation).
    Your system will never again be in such a pristine condition, because it has not
    had dirty human hands meddling with its innards.
  prefs: []
  type: TYPE_NORMAL
- en: The second time it's perfect is when it's turned off for the last time, with
    a job well done, and with a visit to the scrap factory well earned (or, in the
    case of cloud computing, a quick ethereal jaunt to silicon heaven).
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you'll learn about different sources of packages, how to go
    about finding and installing new software, and the importance of keeping your
    systems secure and up to date (lest you end up as a headline on The Register).
  prefs: []
  type: TYPE_NORMAL
- en: It's not the most fun element of the job, and you might find yourself banging
    your head against the nearest wall several times, but if you get it right, you'll
    find you have to deal with considerably fewer problems caused by mismatched software
    in your infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: The best installations that I've come across automatically rebuild their images
    periodically, then roll them out across the infrastructure in a consistent and
    testable way. That takes time to accomplish, and here, we will look at the building
    blocks to get you started.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will deal with disparate package managers and multiple ways of
    doing the same thing (which pretty much sums up Linux in general).
  prefs: []
  type: TYPE_NORMAL
- en: 'Because of that, we''re going to use three different boxes in our `Vagrantfile`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Spinning up these boxes (with `vagrant up`) will provide you with a CentOS
    installation, a Debian installation, and an Ubuntu installation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9f597ee6-7597-406c-a1a4-f664640a9382.png)'
  prefs: []
  type: TYPE_IMG
- en: We're going to be using each of these at one point or other.
  prefs: []
  type: TYPE_NORMAL
- en: Checking package versions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll look at listing the packages installed on our systems,
    and getting the version numbers of those packages.
  prefs: []
  type: TYPE_NORMAL
- en: This will generally be useful if you hear about the latest vulnerability that
    signals the end of the world, and you are shouted at by your boss to fix it, fix
    it, fix it.
  prefs: []
  type: TYPE_NORMAL
- en: There are a considerable number of vulnerabilities out there; it just so happens
    that a few of the bigger ones bleed through to the mainstream media on occasion.
    These are arguably the most dangerous, as they make people panic, and if there's
    one thing worse than a bad situation, it's being in a bad situation while everyone
    around you is losing their heads.
  prefs: []
  type: TYPE_NORMAL
- en: You should also generally keep your systems up to date, because it's a lot more
    awkward to jump several version releases (when you inevitably do have to upgrade)
    than to change things incrementally.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Ensure that all of your boxes are spun up, and try to connect to the first
    two (CentOS and Debian):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In your Debian box, be sure to install `aptitude`, as it''s one of the frontends
    that we''ll be using later in this section; while it is installed by default on
    some distributions, this Debian installation isn''t one of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The method is similar for each OS, but we're going to take them in turn.
  prefs: []
  type: TYPE_NORMAL
- en: CentOS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CentOS (and Red Hat) have two package managers, with another soon to be added
    to the equation.
  prefs: []
  type: TYPE_NORMAL
- en: Starting at the top, we have **RPM Package Manager** (**RPM** is a recursive
    acronym), which is the underpinning of package management in Red Hat based systems.
    It is what you might consider to be a raw package manager, in the sense that it
    is primordial, and you probably won't be using it directly day to day.
  prefs: []
  type: TYPE_NORMAL
- en: 'RPM does the following four things:'
  prefs: []
  type: TYPE_NORMAL
- en: Select
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Query
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Verify
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Install
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These options have arguments, and the one that I find myself using the most
    often is query.
  prefs: []
  type: TYPE_NORMAL
- en: 'To list all installed packages on your system, use `-qa`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'To list a specific package, you can name it (without the full version information),
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'To get information on the package, you can use `-i`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'One trick that I find useful is to output specific information in a pseudo-YAML
    fashion. This can be handy for logging the versions of packages, and can be accomplished
    with the `--queryformat` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: I joke about how RPM is old hat, but there are a considerable number of areas
    in which it excels, and in a lot of cases it's much quicker to run a package query
    using the `rpm` command than any of its available frontends, meaning that it is
    great for scripts. Just be aware that using both RPM and YUM together (to install
    things) can cause problems.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to use something a bit more recent, the current incarnation of the
    nice frontend to RPM is called **Yellowdog Updater Modified** (**YUM**), and was
    originally developed for Yellow Dog Linux.
  prefs: []
  type: TYPE_NORMAL
- en: YUM is generally used because it handles dependency resolution (automatic downloading
    and installing of dependent packages) as well as installation from configured
    remote repositories.
  prefs: []
  type: TYPE_NORMAL
- en: Those of you that had a Playstation 3 in the mid-2000s might be interested to
    know that Yellow Dog was targeted to run on those consoles, during the brief period
    that Sony allowed for the installation of third-party operating systems alongside
    its own Orbis OS (based on FreeBSD.)
  prefs: []
  type: TYPE_NORMAL
- en: 'To list all installed packages with YUM, use `list installed`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use `yum` to query individual pieces of information, just like
    we did with RPM, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note that we also get the available packages by default, and those of you with
    sharp eyes will have noticed that the only difference between these two packages
    is the fact that the available one is the 32-bit version.
  prefs: []
  type: TYPE_NORMAL
- en: DNF (which doesn't stand for did not finish) is the newest of the frontend package
    managers to take on the task of unifying Red Hat installations. It has been the
    default in Fedora (a good distribution, and also Red Hat's testing ground) for
    a while, which means that there is a good chance it'll make it into the next version
    of CentOS and Red Hat itself. For the most part, it's a drop-in replacement, with
    a couple of newer features to justify its existence.
  prefs: []
  type: TYPE_NORMAL
- en: Debian
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Under the hood, Debian uses the `dpkg` package manager to install and manage
    packages. There are also various frontends available, such as `apt` and `aptitude`,
    which make management more user friendly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting with the basics, you can use `dpkg-query` to query installed packages
    on a system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ll no doubt notice that by default, the packages and versions are separated
    by a tab character. Personally, I think this is hideous (because two spaces are
    the superior option), but thankfully, we can customize the output by using `showformat`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This can be especially handy for scripts!
  prefs: []
  type: TYPE_NORMAL
- en: 'On top of `dpkg-query`, we have `apt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This default output might be preferable to you.
  prefs: []
  type: TYPE_NORMAL
- en: '`apt` is the newer way of interacting with packages on your system, though
    the traditionalists among you (or those that have learned from traditionalists)
    might be more familiar with the `apt-get` and `apt-cache` suite of tools.'
  prefs: []
  type: TYPE_NORMAL
- en: Lastly for this section, there's `aptitude`.
  prefs: []
  type: TYPE_NORMAL
- en: Aptitude is the first package manager that I can remember using, and I also
    remember it being a pain to use, because occasionally, it would drop me into a
    TUI (textual or text-based user interface), and I wouldn't know what was happening.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s possible to use `aptitude` on the command line, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s also possible to type `aptitude` on its own, and get dropped into the
    TUI:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e2ff4e45-f9fc-4d94-8b34-f025f8bf7b76.png)'
  prefs: []
  type: TYPE_IMG
- en: This interface can be navigated either via the arrow keys on your keyboard,
    or by using your mouse.
  prefs: []
  type: TYPE_NORMAL
- en: 'Right off the bat, however, we can see the listed `Security Updates` and `Installed
    Packages`, which make up the `369` packages that we get on the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We can double-click and drill down into the `aptitude` interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following screenshot, I''ve shown the two kernels installed in our VM
    (`4.9.0-6` and `4.9.0-7`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/38ac4bfb-6dfc-4ec3-bb56-3d5ff56bf5c2.png)'
  prefs: []
  type: TYPE_IMG
- en: You might also notice `linux-image-amd64`, which is a meta-package, as opposed
    to a package in its own right.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can look for these kernels on the command line, too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What you're effectively doing (in both cases) is querying the package database
    on your system.
  prefs: []
  type: TYPE_NORMAL
- en: On your CentOS system, RPM and YUM are both looking inside `/var/lib/rpm` in
    order to determine the state of your system.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, on your Debian system, your package state is held within `/var/lib/dpkg`.
  prefs: []
  type: TYPE_NORMAL
- en: It is advisable to not mess with these folders outside of the applications that
    are used to manage them, as modifying the nature of the packages installed on
    your system (outside of a package manager) can cause odd, and sometimes destructive,
    behavior.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Remember that you don't have to use the system's package manager to list versions;
    if you would rather trust the output of the application itself, most applications
    have some variation of the `-v`, `--version` standard.
  prefs: []
  type: TYPE_NORMAL
- en: '`bash`, for example, is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The following shows the code for `ssh`, which uses `-V` (uppercase):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'And, just to be awkward, Vagrant uses `-v` (lowercase):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed the distinct lack of Ubuntu in the preceding examples;
    this is because anything that works on a Debian system is extremely likely to
    work on an Ubuntu system.
  prefs: []
  type: TYPE_NORMAL
- en: Checking the OS version
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will be using the same `Vagrantfile` that was used in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we're going to list the canonical version of our operating
    system, as well as the kernel version.
  prefs: []
  type: TYPE_NORMAL
- en: We will also take a look at the concept of LSB compliance.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll break this section into the different operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: CentOS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can determine the version of our `CentOS` installation by printing the contents
    of the `centos-release` file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s a fun fact (among a certain type of people): if you `cat` the contents
    of `redhat-release` on your box, you''ll get the same information, due to the
    fact that `CentOS` and Red Hat systems are so closely aligned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '`cat` (derived from concatenate) is a program that was historically used to
    print the contents of multiple files to standard out.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Likewise, `system-release` is a symbolic link to `centos-release`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'If you wanted more detailed information, you could even print the contents
    of the `os-release` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: These commands tell you the release of your operating system; what they don't
    provide you with is the kernel release, which is separate (think back to [Chapter
    1](e2264f18-69d3-4ff4-af6c-dc8fe152b3e0.xhtml), *Introduction and Environment
    Setup*).
  prefs: []
  type: TYPE_NORMAL
- en: 'To determine the kernel release, one might query `dmesg`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, for a command that doesn''t rely on a log file, you might run
    `uname` with `-a`, in order to print all information about the system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'For just the kernel release information, use `-r`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '`uname` is definitely not a Linux-specific command; it''ll work on most Unix
    and Unix-like derivatives. Take a look at what it prints out on your FreeBSD or
    OpenBSD systems (or your macOS box, if you''re not that sad).'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use YUM, as listed previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are a real rebel, you can even take a look at what kernels you have
    installed in `/boot`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: There's a good chance that the most recent version (emboldened in the preceding
    code) is the one that you're running, though this doesn't always ring true.
  prefs: []
  type: TYPE_NORMAL
- en: Debian
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Things are much the same in the Debian world, although there are fewer OS version
    files to be worried about.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Debian, we can look at the contents of `/etc/debian_version` for the version
    that we are running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, we can look in `/etc/os-release`, like with `CentOS`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Also like in `CentOS`, we can `grep` the `dmesg` log for the version of our
    kernel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, we could use `uname`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Yes, Debian has a much more recent version of the kernel at the time of writing
    this book; this is a mixture of `CentOS`  backporting fixes and features into
    their older kernels (literally taking improvements from upstream and applying
    them to older releases,) and the Debian distribution having a much shorter release
    cycle.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can list the installed versions by using any of the methods listed previously;
    the following is the `dpkg-query` example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'There''s also the trusty old `/boot`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Ubuntu
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like all good distributions, Ubuntu also lets you `cat` a file to get information;
    but, unlike some others, it also tells you when you log in (by default).
  prefs: []
  type: TYPE_NORMAL
- en: 'SSHing to our Ubuntu box should print something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Note the emboldened line, which tells you right when you log in what version
    of Ubuntu you are running.
  prefs: []
  type: TYPE_NORMAL
- en: 'This **message of the day** (**MOTD**) is actually built from several files;
    the header is `00-header`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Within this file are some lines, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can check to see whether the `lsb-release` file exists (and is readable)
    before it's sourced (`. /etc/lsb-release`) for the version.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we have an `if` statement, which says that if the `DISTRIB_DESCRIPTION`
    variable is empty, and the `lsb_release` binary is executable, we fall back to
    using that utility to determine the release version (`lsb_release -s -d`).
  prefs: []
  type: TYPE_NORMAL
- en: We then print the output, which is what we saw at the top of the login message.
  prefs: []
  type: TYPE_NORMAL
- en: 'Failing the MOTD, we can `cat /etc/lsb-release` ourselves, using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, we can use `os-release` again, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'For the kernel, it''s much the same as the previous actions; check the `uname`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Check the installed versions, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, take a look at `/boot`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The `vmlinuz` object, as seen previously, is the compressed executable of the
    Linux kernel.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you are querying these files, you are asking the OS what version it thinks
    it is.
  prefs: []
  type: TYPE_NORMAL
- en: This is useful in everything from security to writing scripts. Not only do you
    want to know when the version of an OS you're running is insecure, you might also
    want to add a sanity check to the top of any scripts, to ensure they're only run
    on systems they're designed for, that is, you can write a script for CentOS systems,
    and step one can be to "check we're actually being executed on a CentOS system."
  prefs: []
  type: TYPE_NORMAL
- en: '`uname` (Unix name) is more interesting, because instead of querying files
    for the OS version, what we were actually doing was querying the running kernel
    for its information.'
  prefs: []
  type: TYPE_NORMAL
- en: '`uname` uses the `uname` system call (confused yet?), which is not only POSIX-compliant,
    but has roots that go all the way back to the 1970s and PWB/Unix.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You might have noticed the Ubuntu usage of `lsb_release` to grab its OS version;
    the same can be done on `CentOS`, but first, `lsb_release` needs to be installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can run the same command that Ubuntu uses in order to get OS information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The same can be done on `Debian`, without having to install anything by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '**Linux Standard Base** (**LSB**) is basically a standard that multiple distributions
    sign up to. It specifies a **Filesystem Hierarchy Standard** (**FHS**), as well
    as various other components of a Linux system.'
  prefs: []
  type: TYPE_NORMAL
- en: The LSB also suggests the package format of RPM, although Debian and Ubuntu
    obviously don't use this by default, opting for `.deb` instead. To get around
    this, Debian offers the `alien` package, which is used to transform `.rpm` files
    into `.deb` files prior to installation. It is something of a dirty hack, and
    it doesn't guarantee compliance; it is more a sort of courtesy nod.
  prefs: []
  type: TYPE_NORMAL
- en: See also...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Take a look at the old Unix programs and conventions, and you'll be surprised
    by how many of them have survived till the modern day.
  prefs: []
  type: TYPE_NORMAL
- en: GNU is not Unix, though, so why do Linux systems also have `uname`? The answer
    is, because it's Unix-like, and a lot of the commands and conventions pioneered
    by Unix were rewritten by the GNU operating system and free software movement,
    for the convenience of familiarity.
  prefs: []
  type: TYPE_NORMAL
- en: Checking for updates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will use the `Vagrantfile` that was used in part of the
    first section. Now that we know the versions of software associated with our system
    (packages, OS, and kernel), we're going to look at what updates are available
    to us, and how we might install them.
  prefs: []
  type: TYPE_NORMAL
- en: We will check for both specific package updates and updates to all packages.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we're going to drop into our `CentOS` and `Debian` boxes, skipping
    Ubuntu, as the same rules from Debian will apply.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to use the kernel throughout these examples, although any package
    on your system can be substituted.
  prefs: []
  type: TYPE_NORMAL
- en: CentOS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In `CentOS`, the easiest way to check for updates to a package is with YUM,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Note that we are not limiting the output to installed packages; instead, we
    are checking what we have installed, and what is available.
  prefs: []
  type: TYPE_NORMAL
- en: The output tells us that while the version number has not changed, the release
    of the kernel has been updated, and is available from the `updates/7/x86_64` repo.
  prefs: []
  type: TYPE_NORMAL
- en: 'To update our kernel, we would simply run a `yum upgrade` command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: We've previously mentioned the list of packages-that-will-change when running
    YUM commands. With '-y' we auto-accept these changes, but if you're unsure, it's
    a good idea to omit the '-y' flag and sanity-check manually by reading the presented
    list.
  prefs: []
  type: TYPE_NORMAL
- en: So, specific packages are pretty simple, but how do we check all installed packages
    on our system?
  prefs: []
  type: TYPE_NORMAL
- en: With YUM, of course!
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use either `update` or `upgrade`, which are basically the same on modern
    installations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Using `upgrade` (rather than `update`) should technically be different, as it
    also uses logic to obsolete and replace obsoleted programs, but because this is
    behavior that most people desire, `obsoletes=1` is also set in `yum.conf`, making `update` and `upgrade` functionally
    the same by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our preceding command should result in a screen like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1b99277c-c53c-46ff-9896-1180817c89da.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that without flags added to the command, the update will stop here, with
    a prompt for you to choose `y/d/N` (with `N` being the default).
  prefs: []
  type: TYPE_NORMAL
- en: If you are ready to upgrade, passing `y` to this command will update and install
    the preceding packages.
  prefs: []
  type: TYPE_NORMAL
- en: If you are not ready to upgrade, passing `d` will only download the packages.
  prefs: []
  type: TYPE_NORMAL
- en: As we've said before, typically, the only programs that require a reboot to
    update are the kernel and `systemd` (the `init` system), as these are the soul
    of your installation, and you're basically killing the old program to make way
    for the new (which will be selected by default on most systems, following an upgrade).
  prefs: []
  type: TYPE_NORMAL
- en: 'Running our `yum info` command will now show two installed kernels, and no
    available ones, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Debian
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: On Debian, we're going to use `apt`, which is the newest and, in my opinion,
    friendliest tool.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike YUM, we can easily and independently update the list of available packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Note that it only updates its list, not the programs themselves.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can look for specific information by using the suggested command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Without adding the `regex-matched` package on the end, this command will list
    all packages that are `upgradable`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'As with YUM, we can upgrade a single package by using `apt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Note that we specifically use the `install` option instead of `upgrade`, as `upgrade`
    would try to do all packages, instead of just `linux-image-amd64`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we wanted to upgrade everything, we would use `upgrade` or `full-upgrade`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The reason that I used `full-upgrade` is because using only `upgrade` can result
    in packages not being upgraded (if that upgrade requires the removal of another
    package).
  prefs: []
  type: TYPE_NORMAL
- en: There may be moments when `upgrade` is preferable to `full-upgrade`, so I would
    advocate checking the output of your `upgrade` command prior to confirming that
    it is what you want to do.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you run the preceding package manager commands, what you are doing is querying
    whichever upstream servers they're configured to talk to, and asking if there
    are any newer versions of the installed packages available.
  prefs: []
  type: TYPE_NORMAL
- en: Configured repositories are in `/etc/yum.repos.d/` on `CentOS` and `/etc/apt/sources.list.d`
    (or `sources.list.conf`).
  prefs: []
  type: TYPE_NORMAL
- en: If there are newer versions of your software available, you have the option
    to install or download for later. Generally, it's a good idea to ensure that all
    your software is kept up to date, but this is especially true for public-facing
    services, such as web servers and SSH daemons.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some popular and tricky software exists outside the realm of sense (as far as
    this opinionated author is concerned).
  prefs: []
  type: TYPE_NORMAL
- en: 'Of particular note are the Hashicorp suite of tools, which check to see if
    there''s a new version of themselves available when invoked. This means that when
    you run `Terraform`, there is a chance that it will inform you that it is out
    of date, and you should download a newer version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The package maintainers for distributions usually do not keep on top of this,
    through no fault of their own, and quite a few won't even bother to package software
    that does this at the moment. What this means is that frequently people will instead
    add Terraform, Packer, and other pieces of cool software outside of their package
    manager, doubling the number of package management systems you need to keep track
    of (one being your system's, and the other being you).
  prefs: []
  type: TYPE_NORMAL
- en: Automating updates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will use the `Vagrantfile` that was used in part of the
    first section.
  prefs: []
  type: TYPE_NORMAL
- en: Something of a slur, "automatic updating" is a sticky subject for a lot of system
    administrators, because historically, it was frequently the case that updates
    would brick a system.
  prefs: []
  type: TYPE_NORMAL
- en: This is less and less likely these days, and there are ways you can automate
    updates on your boxes without worry (though I still wouldn't do this in production,
    personally).
  prefs: []
  type: TYPE_NORMAL
- en: We will also discuss programmatically rebuilding systems.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Jump into each of your boxes in turn, in this section.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that you might not want to automatically install updates
    at all, especially if you are in an environment where machines are periodically
    destroyed and rebuilt.
  prefs: []
  type: TYPE_NORMAL
- en: There might also be in-house procedures that tie your hands, meaning that whatever
    you are technically capable of doing, bureaucracy can always get in the way.
  prefs: []
  type: TYPE_NORMAL
- en: CentOS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'On `CentOS` systems, we have a handy tool called `yum-cron`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: It comes with two configuration files, located in `/etc/yum/`.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, the `/etc/yum/yum-cron.conf`  file will be used, and it has a random
    sleep inside it that we are going to disable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, this means that when `yum-cron` is called, it will automatically run,
    applying the default settings of `yum-cron.conf`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: If there are no updates, `yum-cron` will not show any output (as seen previously).
  prefs: []
  type: TYPE_NORMAL
- en: 'If there are updates, by default, you will get a notification that they have
    downloaded successfully:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8890cd95-2e9f-4e8d-9c5e-31674b585dbd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you wanted to apply the updates automatically, that would involve another
    config file change, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Running `yum-cron` again will apply the downloaded updates:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b337a448-b86e-440d-8b61-1908e95298e3.png)'
  prefs: []
  type: TYPE_IMG
- en: We have mentioned previously (but it is worth saying again) that this does not
    necessarily mean that services will instantly be fixed, or will have new features.
  prefs: []
  type: TYPE_NORMAL
- en: That is where the command `needs-restarting` comes in.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also run this with a timer (or `cron`, if you must) to list processes
    that need restarting after they''ve been updated, or a component they utilize
    has:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'If you would like nicer output, you can specify services, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Or only if a reboot is needed, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'A really simple way of starting `yum-cron` is with the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Debian
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the Debian (and Ubuntu) world, we use a package called `unattended-upgrades`.
    It's been around for quite a while, and is usually the option people go with for
    automatically updating their Debian-based distributions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Jump into your stretch box and run a quick `install` of the package, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'If you now `ls` the `/etc/apt/apt.conf.d/` directory, you will see a couple
    of new files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: These are the crux of the `unattended-upgrades` package.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we take a look at the block in the `50unattended-upgrades` configuration
    file that handles which updates to pull in, we will see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Note that the only uncommented line is the bottom one (before the closing brace).
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to uncomment the lines that precede it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'You can run and test your configuration by starting the command in debug mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'It might look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/41e2ddc7-898d-4023-845e-e646e015438a.png)'
  prefs: []
  type: TYPE_IMG
- en: Noticed how the upgrades were actually installed, and a log file was created.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`yum-cron` is actually just an easy way to use YUM from within a cron job (which
    we mentioned disparagingly earlier, while discussing `systemd` timers). Because
    of this, you would find it easy to incorporate into a custom timer (see earlier
    chapters) or a cron job that might run nightly.'
  prefs: []
  type: TYPE_NORMAL
- en: In general, you could apply all updates to a development environment nightly,
    and then potentially stagger updates to other (higher) environments throughout
    the week, upgrading production to the next Tuesday. That is entirely up to you,
    as the all-powerful sysadmin.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have taken the suggestion of enabling `yum-cron` as a service, you should
    now find that the following file exists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'This enables the two `cron` jobs, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: These will use the configuration files that we mentioned.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of Debian's `unattended-upgrades`, and as with most modern systems,
    `systemd` is used to run this job daily.
  prefs: []
  type: TYPE_NORMAL
- en: 'List your `systemd` timers, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Note the two `apt` jobs, the first of which runs the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'The second one runs the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Like unattended upgrades on Debian, `yum-cron` has the ability to work through
    only specific types of upgrades. By default, this is set to `default`, as seen
    in the following snippet, which is why we didn''t modify it earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: There's nothing stopping you from changing this, perhaps specifying that only
    security upgrades should be applied automatically?
  prefs: []
  type: TYPE_NORMAL
- en: Automatic provisioning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the prelude I suggested that we would touch on this, and it is definitely
    worth discussing.
  prefs: []
  type: TYPE_NORMAL
- en: Once, it was the case that physical machines roamed the earth, preying on unsuspecting
    sysadmins that dared to enter their swamps and server cages.
  prefs: []
  type: TYPE_NORMAL
- en: Nowadays, servers still exist, but they have been given a more tech-unfriendly
    and media-savvy name, becoming colloquially known as the **cloud**, and being
    made transparent enough that sysadmins no longer know whether their favorite hipster
    distribution is running on a Dell, HPE, or IBM machine.
  prefs: []
  type: TYPE_NORMAL
- en: This has given rise to transient servers, or servers that periodically cease
    to exist in the evening, only to be born anew the next morning.
  prefs: []
  type: TYPE_NORMAL
- en: Aside from giving you an existential crisis about whether or not you cease to
    exist when you go to sleep for the night, this might start to give you ideas about
    never updating your machines, instead simply ensuring that they come back up with
    all updates already applied.
  prefs: []
  type: TYPE_NORMAL
- en: The notion of automatically provisioning your infrastructure on a schedule is
    gaining traction, and what it boils down to is creating an image programmatically
    (with a program such as Packer) before uploading and/or moving it to a different
    portion of your virtual infrastructure, where another program (Terraform) can
    use the new image to spin up a lot of shiny new boxes.
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, this works all the way up to a production network without issues,
    because there are no customers around on your `dev` instances (I hope—I really,
    really hope). It does present a problem in production, but then you start to think
    about wild and crazy things such as blue/green deployments.
  prefs: []
  type: TYPE_NORMAL
- en: Checking mailing lists and errata pages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Outside of our systems, we will take a look at where you go for news on how
    your operating systems are performing, in general. Are they healthy? Do they need
    some space? Are they going to implode pretty soon?
  prefs: []
  type: TYPE_NORMAL
- en: It's good practice to get into this habit, because occasionally, system and
    behavioral changes may require manual intervention on the part of the sysadmin,
    even if you automate all of your other problems away.
  prefs: []
  type: TYPE_NORMAL
- en: Servers – who needs them?
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will be using our VMs a bit, and the almighty internet.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We're going to take a look at our VMs a little bit, but we are mostly going
    to be focusing on online locations for news.
  prefs: []
  type: TYPE_NORMAL
- en: There are various methods and places that you might go for information, so let's
    work through some of the more popular ones.
  prefs: []
  type: TYPE_NORMAL
- en: Package changelogs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you want information about a package, one thing that you might like is the
    `changelog`, accessible from your system with a simple RPM command.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, find the package you want to check; we''re going to grab the most recently
    installed `kernel`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, open the `changelog` for that `kernel` (it''s long):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'You will get something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5c52aa6a-0e84-407e-bbb1-47fb7cf93c5d.png)'
  prefs: []
  type: TYPE_IMG
- en: This can be a good way to check for specific changes, but it can also sometimes
    be a bit tricky (depending on the nature of the log).
  prefs: []
  type: TYPE_NORMAL
- en: 'To show that it''s available for other packages, too, here''s `lsof`, which
    is a lot more sparse:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2045bc58-7d52-49e0-8c00-f75af20d7d20.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Under Debian and Ubuntu, we can use `apt` to accomplish the same thing, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Admittedly, the output isn''t as verbose, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8d5a288e-3d68-47b4-ae2f-82800af7bf82.png)'
  prefs: []
  type: TYPE_IMG
- en: Official sources and mailing Lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Red Hat, through the goodness of their collective hearts, provide a page to
    reference for errata and update news: [https://access.redhat.com/security/updates/advisory](https://access.redhat.com/security/updates/advisory)
  prefs: []
  type: TYPE_NORMAL
- en: There are some important and very helpful links on this page, such as a link
    to the Red Hat **Common Vulnerabilities and Exposures** (**CVE**) database: [https://access.redhat.com/security/security-updates/#/cve](https://access.redhat.com/security/security-updates/#/cve)
  prefs: []
  type: TYPE_NORMAL
- en: If you have a Red Hat login, there's also a link to their own errata page on
    the customer portal.
  prefs: []
  type: TYPE_NORMAL
- en: Mailing lists are a big part of this world, with some going back several decades,
    and you, too, can receive far too much email (most of which you'll never read)!
  prefs: []
  type: TYPE_NORMAL
- en: Most of the big projects have mailing lists (sometimes several of them), and
    it would be next to pointless to subscribe to all of them (for example, why sign
    up to the PowerPC mailing list for the kernel, when you got rid of your New World
    Macintosh in the mid 2000s?)
  prefs: []
  type: TYPE_NORMAL
- en: 'Select the ones that interest you, and that might be useful for administration.
    Security lists are generally a good place to start:'
  prefs: []
  type: TYPE_NORMAL
- en: Red Hat maintains a few at the following at [https://www.redhat.com/mailman/listinfo](https://www.redhat.com/mailman/listinfo).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CentOS has their own mailing list at [https://lists.centos.org/mailman/listinfo/](https://lists.centos.org/mailman/listinfo/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debian have their mailing list at [https://lists.debian.org/](https://lists.debian.org/).
    (It includes handy documentation on which lists you might find useful.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And, of course, Ubuntu has their list at [https://lists.ubuntu.com/](https://lists.ubuntu.com/).
    (It is also nicely formatted, such as Debian.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Good lists to sign up to include announcement lists; for example, the `CentOS-announce`
    list covers general and security information.
  prefs: []
  type: TYPE_NORMAL
- en: Included on the official sources list should be the various publicly viewable
    source trees of projects, and their associated *Issues* sections (in places such
    as GitHub). Be sure to keep an eye on any pet projects that you like the look
    of, or those that might underpin your infrastructure (Terraform, and suchlike).
  prefs: []
  type: TYPE_NORMAL
- en: Other sources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: BBC, HackerNews, The Register, and Reddit have all previously informed me of
    problems that I should have been aware of before reading about them on the front
    page of popular news sites; don't underestimate the mainstream media when it comes
    to wanting to drum up panic.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: These projects are public, and those involved are well aware of the stakes when
    there's a problem. One only has to take a look at the panic caused when big vulnerabilities
    are revealed to appreciate why notification avenues are so widely used and appreciated.
  prefs: []
  type: TYPE_NORMAL
- en: If a project had no means of communicating critical problems with its users,
    it would very quickly find itself inundated with concerned individuals, just wanting
    to know that the software they're using is being kept up to date.
  prefs: []
  type: TYPE_NORMAL
- en: All that we can do in this fight against security issues and breaking changes
    is keep informed, and act swiftly when we need to.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is a lot more, really; check for blogs, such as CentOS ([https://blog.centos.org/](https://blog.centos.org/)),
    and individual mailing lists for other packages and projects.
  prefs: []
  type: TYPE_NORMAL
- en: OpenSSL, for example, is a good one to keep an eye on ([https://www.openssl.org/community/mailinglists.html](https://www.openssl.org/community/mailinglists.html)),
    and I don't say that for any particular heart-health-related reason.
  prefs: []
  type: TYPE_NORMAL
- en: A big one is the kernel mailing list selection, viewable through [https://lkml.org/](https://lkml.org/);
    here, kernel news is generally broken first.
  prefs: []
  type: TYPE_NORMAL
- en: Using snaps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we're going to use our Ubuntu VM.
  prefs: []
  type: TYPE_NORMAL
- en: '**Snaps** (by Canonical) are one of two new kids in the neighborhood. They
    are a method for packaging software in a universal fashion, so that one package
    can be deployed to any OS that supports snaps.'
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing this book, Ubuntu probably has the best support for snaps,
    but Canonical proudly lists installation instructions for quite a few distributions
    on their website (despite the fact that three of these are just downstream Ubuntu
    distros), [https://docs.snapcraft.io/core/install](https://docs.snapcraft.io/core/install).
  prefs: []
  type: TYPE_NORMAL
- en: I am usually pretty harsh on Canonical, so let me just say that I applaud this
    effort. It has been true for a while that the disparate packaging methods on Linux
    are one of the many reasons that some developers stay away, and anything that
    aims to close that gap is a welcome addition to the community.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Jump onto the Ubuntu machine we created earlier, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: On our VM, the `snapd` service will already be started and running (or it should
    be; check with `systemctl`).
  prefs: []
  type: TYPE_NORMAL
- en: Searching out snaps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To search for snaps, we use the `snap` command-line utility. In this example,
    I am going to look for another Canonical product (`lxd`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: We get a few results, variously published by Canonical and a few other names.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s not limited to daemons either; in the following code I''m searching for
    the `aws-cli` tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Note the tick next to the publisher's name; this means that the package is from
    a verified account (in this case, Amazon Web Services).
  prefs: []
  type: TYPE_NORMAL
- en: Installing snaps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The snap that we want has the name `lxd`, making our installation easy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see a progress bar similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/64973e8c-5fab-46ff-a99f-1f945a0ab60d.png)'
  prefs: []
  type: TYPE_IMG
- en: Once finished, you will have the `lxd` container manager installed from a snap.
  prefs: []
  type: TYPE_NORMAL
- en: Listing installed snaps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can list our installed snaps with `snap list`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Interacting with daemon snaps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Because LXD is a daemon, we can enable it by using the `snap` command-line
    tool again; first, we should check the active state of our service, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'It is inactive, but we can activate it (we have the technology), as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Checking the services again, we can see it has started:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Under `systemd`, the service is called `snap.lxd.daemon.service`, if you want
    to use traditional tools to check its status.
  prefs: []
  type: TYPE_NORMAL
- en: 'To prove that it has started and that we can interact with the daemon, we can
    use the bundled `lxc` package, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: You can see that it tries to communicate with the socket; and, while it has
    given us a permission denied error in the preceding snippet, this does serve to
    highlight that the socket exists in the `/var/snap/` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try again, with `sudo`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Awesome!
  prefs: []
  type: TYPE_NORMAL
- en: Removing snaps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finally, we can use our tool to remove `lxd` without prejudice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Snaps work like any other package manager, installing and managing packages
    brought in from a repository on your system.
  prefs: []
  type: TYPE_NORMAL
- en: You'll also have noticed the core installation on our list of installed snaps;
    this is effectively the base platform that snaps work on top of.
  prefs: []
  type: TYPE_NORMAL
- en: '`snapd` is the daemon that underpins snaps; it''s the environment that manages
    the installed snaps, dealing with installs, updates, and deletion of old versions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you install a snap, what you actually download is a read-only `squashfs`
    file that lives in `/var/lib/snapd/snaps/`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: The numbers are snap revision numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'When these `squashfs` images are mounted by `snapd`, you can see them personified
    as loop devices with `df`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also see the specific `mount` information with `mount`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we can navigate into the locations where these snaps are mounted,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'However, because the filesystem is read only, we cannot write anything inside
    of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: Neat, right?
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use our snaps without calling the binaries directly, because of various
    `snap` entries in our `$PATH`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: The `PATH` is the list of defined locations where your shell will look for binaries;
    when you run `ls`, you're locating is the binary somewhere within your `PATH`.
  prefs: []
  type: TYPE_NORMAL
- en: Snaps are also self-contained, meaning that libraries and runtimes are bundled
    into the package (which makes portability between distributions easy).
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you want detailed information about a snap, there's also the `snap info` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the output when the command is run against the `lxd` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: This should tell you most of what you need to know about any particular snap.
  prefs: []
  type: TYPE_NORMAL
- en: See also...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You don't have to search for snaps on the command line, if you live in the 21st
    century.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use the `snapcraft.io` website at [https://snapcraft.io/](https://snapcraft.io/):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b8015e11-f633-4c93-881d-a8456cc0132f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Store section, you will find a visual search, which can help you to
    find what you are after in a friendly, click-button fashion. In the following
    screenshot, I''ve searched for `aws`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fa26d151-e0a0-4776-be9c-0f612b263d75.png)'
  prefs: []
  type: TYPE_IMG
- en: Using Flatpak
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Flatpak (by Alex Larsson and the Flatpak team) is the second in the trendy clique
    of complete-solution package managers. It is also a good way of packaging software
    so that one package can be deployed to any OS that supports Flatpak installations.
    Sound familiar?
  prefs: []
  type: TYPE_NORMAL
- en: Really, though, we are also getting into conflicting technology development
    (yet again) and holy wars (yet again).
  prefs: []
  type: TYPE_NORMAL
- en: To kick things off, I should point out that Flatpak really does emphasize desktop
    applications over server applications, from their complex run commands to the
    fact that they are mostly graphical tools. Snaps are definitely more of a mixture
    between the two worlds.
  prefs: []
  type: TYPE_NORMAL
- en: Obviously if you want to install a GUI on your server, there's nothing stopping
    you, you could even use VNC for management! However, it's not really done, like
    fish fingers and custard.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will continue to use our Ubuntu VM (mostly because it's
    the one I still have open, after having written the last section).
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s no reason why we couldn''t use our Debian or CentOS box, instead;
    a host of other distributions are also supported, including (but not limited to)
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Arch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fedora
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gentoo
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Solus
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Alpine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: openSUSE
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To set up our VM for Flatpak, we have to install it, although it is available
    in the default repositories (potentially after an upgrade, depending on when you''re
    reading this; if you''re reading this prior to 2017, I''m impressed by your temporal-displacement
    abilities, but you should know that the future is dark and full of lemons):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to enable the remote `flathub` repo from [https://flathub.org](https://flathub.org):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can install stuff!
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the purposes of this section, I've chosen the relatively lightweight `vim`
    package to install from Flathub.
  prefs: []
  type: TYPE_NORMAL
- en: Searching for a package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, let''s look for the package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: Again, we have a few results, but the top one is what we're after.
  prefs: []
  type: TYPE_NORMAL
- en: Installing our package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can install the package with a small command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: This can take quite some time to download, and it takes up more space than you
    might expect (despite being a relatively lightweight package).
  prefs: []
  type: TYPE_NORMAL
- en: Running our package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once the installation is complete, you can run your new version of `Vim`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: The package identifier is in three parts: usually `org/com.<company or team>.<app
    name>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s not the prettiest command, but it will drop you into the tried and true
    text editor, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/27891bc3-c8ac-4b71-84bf-9f2e391b7522.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If we look at the versions of the Flatpak installation and the native `Vim`
    install, we can see the difference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: Listing installed packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have something to actually show, we can list our installed `flatpak`
    packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: Note that it also tells us that the package is a `system` package, rather than
    a per-user package.
  prefs: []
  type: TYPE_NORMAL
- en: User installations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Flatpak also has the concept of local user installations, meaning that we can
    install our packages as our user, too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: Removing packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you inevitably get bored with `Vim` and go back to using `ed` for your
    day to day editing needs (because `ed` is the standard text editor), you can remove
    your package easily, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: Here, we're specifically removing the user-installed version; the system one
    will remain.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you install a package using Flatpak, it ends up in one of two places:'
  prefs: []
  type: TYPE_NORMAL
- en: System packages end up in `/var/lib/flatpak`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User packages end up in `~/.local/share/flatpak/`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Looking into these locations, we can find an `app` directory, and within that,
    our package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: Within this directory, there are yet more layers, which house the current version
    of your package and the various binary files.
  prefs: []
  type: TYPE_NORMAL
- en: Packages are built atop runtimes, like those that you saw when you listed installed
    packages earlier. These runtimes are distribution agnostic, meaning that they
    can be installed on all of the Ubuntu, CentOS, and Fedora systems of the world.
  prefs: []
  type: TYPE_NORMAL
- en: If there is something additional required for an application to function, such
    as a specific library, you can bundle that in your package, too.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At the time of writing this book, there are `585` packages available to install
    from `flathub`, with the number growing every day:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also update your applications with one command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: See also...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For those of you that hate `Vim` with a passion, despite its obvious superiority,
    Flathub has you covered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: There are many more packages available, but, as I've said previously, you are
    actually unlikely to find yourself using Flatpak on a server, simply because it's
    a desktop-focused endeavor.
  prefs: []
  type: TYPE_NORMAL
- en: On your own computer, though, snaps and Flatpak packages can be installed side
    by side.
  prefs: []
  type: TYPE_NORMAL
- en: I once tried to use `Solus` as my daily driver, but wanted to ensure that I
    did nothing out of the ordinary with my installation. At the time, `Solus` had
    its own packages, snap support, and Flatpak support. This actually resulted in
    me using specific snaps for managing a Kubernetes setup, Flatpak to install `Slack`,
    and the system's own package manager for everything else; it was a bit of a mess
    by the end, but a consistent mess!
  prefs: []
  type: TYPE_NORMAL
- en: Using Pip, RubyGems, and other package managers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Aside from YUM, Apt, snaps, and Flatpak, there are a host of other package management
    systems. Pip and RubyGems are programming-language related methods of distributing
    packages to systems; there are more than these two, but they're by far the most
    popular right now.
  prefs: []
  type: TYPE_NORMAL
- en: '**P****ip installs packages** (**Pip**) is included by default in recent Python
    installations. Gem is just a play on the fact that it is for packaging Ruby elements;
    it, too, is included in recent Ruby installations.'
  prefs: []
  type: TYPE_NORMAL
- en: We're going to touch on installing software using these package managers.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will continue to use our Ubuntu VM.
  prefs: []
  type: TYPE_NORMAL
- en: 'Install Pip and RubyGems on your Ubuntu machine (Python will already be installed,
    but it''s a separate package for Pip in this instance), as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: Python2 and Python3 are both widely used, although these days, you really shouldn't
    be writing anything new in Python2 (which will be going out of support in 2020).
  prefs: []
  type: TYPE_NORMAL
- en: 'We now want to install `pip`, using the `easy_install3` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: There is a way to install `python3-pip` using `apt`, but this version will be
    frequently out of date, and the whole point of using Pip is that you get the latest
    version of everything; hence why we use `easy_install`. Together with that, if
    you try to upgrade the system-installed version of Pip, it might very well work,
    but you'll be changing system-controlled packages outside of the system-method-of-control...
    phew.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will now run through some basic things that you might do with each of these
    package managers.
  prefs: []
  type: TYPE_NORMAL
- en: Pip
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Starting with Pip, you can check which version you''re running with the `--version`
    argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'You can list which packages you have installed (and their versions) with `list`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'You can search for the package that you want; here, I''m checking for Ansible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: There are a lot of packages in the **Python package index** (**PyPI**), so you
    might get a lot of results from your search; this is where learning some `regex`
    and invoking `grep` can be useful.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once it''s located, we can also install our package, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'Note the lack of `sudo`; this is because we want to install it as our user,
    meaning that the package ends up in a `.local` directory in our home directory
    (`~`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, the `.local/bin` directory is in our `PATH` (if we log out and
    back in):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that we can just run `ansible` from our shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'After our package has been installed, we may find that we actually need an
    older version; thankfully, Pip lets you specify this easily, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'And, at a later date, if we decide that we need the latest version (because
    the old playbook has finally been updated to work without deprecated features),
    we can upgrade, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: RubyGems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Like Pip, we can check which version of RubyGems we have installed with a simple
    `gem` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'To list the installed gems, we can use `list`, funnily enough:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to search for a package, we use `gem search` (we also have the `--exact`
    option in RubyGems, which Pip lacks):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also install (as a user) with `gem install`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that by default, the `.local` gem installation location will not be in
    your `PATH`, but we can call it with its full path from our home directory (to
    be added to our `PATH` at a later date):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'As with Pip, we can install other versions of packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: Note that we used a different path here, dropping into the `/gems/` portion
    of the installation directory to call the package by its version.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you go to `uninstall` the package, you now get a choice, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: Choose to uninstall `14.5.33` (option `2`).
  prefs: []
  type: TYPE_NORMAL
- en: 'We now have one version of `chef` installed, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'Also like with Pip, we can upgrade this, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: Note how it also leaves the old version installed, by default.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pip and RubyGems try to be relatively self-contained, but they're still package
    managers, meaning that all they're effectively doing is querying an upstream repository
    for a package, and then downloading it onto your system.
  prefs: []
  type: TYPE_NORMAL
- en: When you update your `PATH` to update whichever binary location the new executables
    live in, you're able to run the packages that you've just installed.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pip and RubyGems are huge topics, with a large ethereal-blog-post potential
    for each, so it makes sense that there is a lot more to them that we have not
    covered. A couple of the more obvious things to mention will be covered in the
    following sections.
  prefs: []
  type: TYPE_NORMAL
- en: When to use programming-language package managers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, here is the thing.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible and Chef are available in the Ubuntu repositories, carefully tailored
    and packaged for Ubuntu systems the world over.
  prefs: []
  type: TYPE_NORMAL
- en: So, why would I use Pip to install it instead?
  prefs: []
  type: TYPE_NORMAL
- en: It's simple; at the time of writing, the Ansible version in the Ubuntu repositories
    is 2.5.1, and the version in the PyPI repository is 2.7.0, which is quite a significant
    bump.
  prefs: []
  type: TYPE_NORMAL
- en: If you want the latest and greatest features of a program, or newer libraries
    than your distribution ships, you may very well find yourself tempted to install
    outside of Apt, and that's not necessarily a problem. The problem is remembering
    how all these packages are installed, and making sure that you know how to keep
    each up to date.
  prefs: []
  type: TYPE_NORMAL
- en: --user/ --system (pip) and --user-install (gem)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As with Flatpak, we have the option to install packages on either a user level
    or system-wide. For the examples used, I chose to install things locally, meaning
    that the packages will generally only be available to my user by default.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: Python virtualenv
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python has an inherent problem – conflicting package versions – and because
    of this, virtualenv is a thing. Effectively, virtualenv is a way to segregate
    installs so that they don't conflict, and you can (potentially) easily install
    multiple versions of the same package.
  prefs: []
  type: TYPE_NORMAL
- en: One use case for this might be Molecule, a testing framework designed for Ansible
    roles. Versions 1 and 2 of Molecule are incompatible with each other, but you
    could definitely have some Ansible roles in your infrastructure written for version
    1 (which no one is going to update any time soon, because there's more pressing
    issues... there's always more pressing issues.) We have virtualenv though, so
    we can install both Molecule 1 and Molecule 2 without worrying about them conflicting.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As with any other package manager, Pip and RubyGems manage packages.
  prefs: []
  type: TYPE_NORMAL
- en: Some of you will have spotted a problem with this, and it is one that people
    rarely realize can be an issue. If you have multiple package managers on a system,
    each maintaining its own packages and adjusting your `PATH`, you can end up with
    packages installed from the system's package manager and those installed from
    third-party package managers conflicting.
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, you will get name clashes.
  prefs: []
  type: TYPE_NORMAL
- en: I once saw an instance of the Puppet binary `factor` conflicting with another
    binary of the exact same name, causing strange and wonderful problems on a machine –
    that was fun.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency hell (a quick word)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will now take a trip down memory lane; specifically, the author is going
    to curl up into a ball for a couple of hours while he recalls hours of yelling
    at servers for being dumb.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency hell is the notion that a package can have dependencies on things
    that either conflict with other versions of dependent packages or libraries that
    you have installed, or can try to use incompatible versions, for whatever reason.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of Python and Pip, we've already discussed the concept of virtualenv,
    but historically, this has also been a problem in other package managers, too.
    RPM-based distributions are notorious for these issues, developing the term **RPM
    Hell** to specifically reference their problems.
  prefs: []
  type: TYPE_NORMAL
- en: You can also get into a situation where there are a few options for dependencies
    when installing software; programs like Apt attempt to mitigate this by presenting
    several options to the user, and asking them to select which one they want to
    use.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we're only going to run a couple of commands on our VMs, in
    order to look at the output.
  prefs: []
  type: TYPE_NORMAL
- en: 'Jump into your Debian 9 box and ensure Pip is installed and up to date:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, jump into our Ubuntu box and install `pip` by using `apt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'Check the `version`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, `upgrade` it (only on the Ubuntu box), as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: 'Log out (an important step) and check the `version` again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To visualize what dependency problems can look like, take a look at the following.
  prefs: []
  type: TYPE_NORMAL
- en: System-installed and third-party installed versions of Pip
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our Ubuntu box, we installed `pip` by using the system package manager (`apt`)
    only to then use Pip to upgrade itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that `apt` thinks the package looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: 'Our local session thinks that `pip` looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: This is a problem, as future packages could rely on Pip 9 and expect it to be
    installed correctly on the box, despite the different versions.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, what we've actually done is use the system-installed version of
    Pip to install and upgraded the version locally; hence, the reason that the version
    string comes from our `.local` directory, but it's still not an ideal scenario.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency problems in conflicting Pip packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To better understand why virtualenv is a thing, we can look at an installation
    of Molecule.
  prefs: []
  type: TYPE_NORMAL
- en: 'In your Debian instance, install the Molecule testing framework (specifically, `2.15.0`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: 'All being well, the installation should go fine, and you''ll be able to check
    your Molecule version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: 'However, we''re now going to use `install ansible-lint` (the latest version,
    at the time of writing this book):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: 'Our installation works, but in the middle of it, we get a nasty warning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: 'If we check the installed `version`, `ansible-lint` looks good:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if we run our Molecule installation again, we get informed that it
    has helpfully downgraded `ansible-lint` for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: This is obviously an easy example to show you, as there are only two packages
    involved; imagine how hectic and stressful this could get with five, ten, or even
    twenty packages managed by Pip.
  prefs: []
  type: TYPE_NORMAL
- en: Apt's conflict solution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following is an example of Apt detecting dependency problems and refusing
    to carry on with an installation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that if you then install `postfix` by itself and attempt to install `exim`,
    you will be given the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: The line that tells you that `postfix` will be ripped out of your system if
    you proceed is in bold.
  prefs: []
  type: TYPE_NORMAL
- en: Potential solutions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In spite of these annoying (and sometimes tedious) problems, there are some
    solutions to these issues.
  prefs: []
  type: TYPE_NORMAL
- en: We have already mentioned virtualenv, and now, we're going to mention it again,
    just to hammer the point home. Go out and seek knowledge on it, as it could save
    you a severe headache in the future.
  prefs: []
  type: TYPE_NORMAL
- en: Docker is another potential solution, and although the idea of jailing applications
    into their own little environments is nothing new (see Solaris Zones and FreeBSD
    jails), Docker provides a quick and simple interface to utilize Linux kernel features
    for segregating apps and dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple VMs might also be your way forward. It used to be the case that we
    needed to buy one, two, or maybe three servers, and use multiple packages on each
    server; nowadays, that isn't as true, and, while you might still have a handful
    of physical boxes, you're much more likely to be using VMs on each, which provide
    a great way to completely segregate whole operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Package management works because diligent people make it work. Dependency problems
    are still an issue, even though they're mostly transparent to the user these days.
    It becomes more of an issue with the more packages that you support, meaning that
    Debian, with its thousands of packages, has a tough job of making sure each will
    always work, or that conflict is detected before it causes issues.
  prefs: []
  type: TYPE_NORMAL
- en: Let's give a shout out to the hardworking package maintainers in each distribution,
    and thank them for their tireless efforts in ensuring that our systems don't try
    to install packages and libraries that are incompatible with each other.
  prefs: []
  type: TYPE_NORMAL
- en: If you ever have to make a package of your own, best of luck to you!
  prefs: []
  type: TYPE_NORMAL
- en: Compiling from source
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*"Oh, it''s Linux; call me when you''ve finished recompiling your kernel!"*
    This is a statement from every uninformed techy ever.'
  prefs: []
  type: TYPE_NORMAL
- en: Packages aren't the only way to install software on your system; if you have
    the source code (the recipe for the software that you want to install), you can
    compile the program yourself, in your own way!
  prefs: []
  type: TYPE_NORMAL
- en: It's not done very frequently these days, outside of in-house software, as compiling
    software can be a time-consuming and resource-intensive task. The likes of the
    Gentoo users of the world might like it, and there are arguments that it can speed
    up and slim down installations, but these are generally negligible benefits on
    modern hardware.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here, we're going to grab the source code of `htop`, a popular and interactive
    process monitor.
  prefs: []
  type: TYPE_NORMAL
- en: This isn't a sales pitch, but I do happen to like `htop`, and I make a point
    of installing it on my personal systems, as well as systems I manage, when I get
    the chance.
  prefs: []
  type: TYPE_NORMAL
- en: You will need access to the GitHub page of the source code, at [https://github.com/hishamhm/htop](https://github.com/hishamhm/htop).
  prefs: []
  type: TYPE_NORMAL
- en: You will also be using your CentOS VM.
  prefs: []
  type: TYPE_NORMAL
- en: 'Log in to your CentOS VM and install `unzip` and `wget`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: 'Navigate to `/usr/local/src`, the place where we will put source code for locally
    installed software, by convention:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: 'Download the most recent version of the `htop` repository (here, I use `https`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You should now have a `master.zip` file in your directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to `unzip` this, change the ownership for convenience, and jump inside:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside this directory, you''ll find a whole host of files, mostly of the `C`
    variety, but with a few others here and there. One file you''ll almost always
    find in a source directory is a `README`, which is an excellent place to start:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: 'READMEs are always different, but I''ve yet to find a serious project where
    they aren''t good. See the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4a8ac1c9-cdf3-427e-8972-e25735b0540f.png)'
  prefs: []
  type: TYPE_IMG
- en: This file will tell you, in a few words, any dependencies that you need to install,
    and then the appropriate method for installing the package itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we downloaded the sources, we need the `autogen.sh` line from the preceding
    screenshot. If we attempt to run the script, we will be given an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: 'This is because the `autoconf` package isn''t installed; proceed to do so,
    then try the script again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: Another `yum` that tells us the `automake` package isn't installed, so let's
    install it!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: Good! This time, it worked.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `README` suggested checking out the `INSTALL` file; so, let''s take a look
    at that next:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8044d85a-5a3a-4292-8e74-7f3e46a84a0e.png)'
  prefs: []
  type: TYPE_IMG
- en: In quite a few words, this gives us the installation process for most packages
    packaged in this way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in the `README` file, we''re going to try the next bit of the installation
    step, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: We have something else missing; in this case, the error is telling us that a
    C compiler wasn't found.
  prefs: []
  type: TYPE_NORMAL
- en: 'The default C compiler in most systems is GCC, but there are others that may
    or may not work (such as `musl`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: We can go further now, but as the script checks for requirements, we can see
    that we can't find a `libncursesw` installation.
  prefs: []
  type: TYPE_NORMAL
- en: 'It gives us two options: disabling unicode, or installing `libncursesw`. For
    completeness, let''s install the `ncurses-devel` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: Now, we get to the end of the configuration script with no more errors. Hurrah!
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we `make` the package, which is the actual step that compiles the source
    code into usable programs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: 'It can be noisy, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/435c0c82-a066-4420-8155-5fc1f79637df.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In our directory, we now have an `htop` binary, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: 'Give it a whirl:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we need to install the program to its appropriate locations; this is
    done with the `make install` command. This does need `sudo`, as we''re moving
    things out of our local folder and into the rest of the filesystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can run a `whereis` and find out its installed location (although we
    can also see it in the preceding code snippet):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For most Linux programs (certainly of the C variety), this pattern is fairly
    standard. Copy down the source code, configure it with its defaults (or make any
    changes that you want), compile the software, and install it variously on the
    filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `INSTALL` file provides a good overview of the different steps, but in
    short, they look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`configure`: Creates a `Makefile` that contains system-specific options, based
    on your environment. These can be quite long; the `htop` file comes out at 1,422
    lines.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`make`: This is invoked to correctly compile any source code that needs it,
    creating binaries and supplementing files that might be needed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`make install`: This puts the files into their appropriate places.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easy, right?
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Things like the kernel can be compiled too, but will take much longer given
    the sheer number of parts and subsystems that have to be accounted for. Long compile-times
    are the main reason people and projects have defaulted to using pre-compiled binary
    blobs these days (because few people want to wait around for their code to compile,
    unless they're deliberately trying to avoid work.)
  prefs: []
  type: TYPE_NORMAL
- en: Even Gentoo, which is famous for allowing customizability (at the expense of
    installation time), has precompiled binaries that you can install for the larger
    programs, if you don't want to sit around for a week waiting for your code to
    compile.
  prefs: []
  type: TYPE_NORMAL
- en: There's also cross-compiling, which is the act of compiling software for different
    architectures. For example, I may want to compile `htop` for `aarch64` hardware
    on my `x86_64` VM, because it's got 32 cores and my `aarch64` board is a Raspberry
    Pi 3.
  prefs: []
  type: TYPE_NORMAL
- en: See also...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are other ways to compile software, depending on the language used. Go,
    for example, will have you `go get` the package source code that you want to compile,
    but it uses the `make` command to perform the actual build, whereas the Rust programming
    language uses a tool called `cargo`.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will use all three of our virtual machines, adding additional
    repositories to each. This is to showcase how the different package management
    systems do things differently.
  prefs: []
  type: TYPE_NORMAL
- en: Adding additional repositories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are default repositories installed when your system is created; there
    are also wilder and more out-there repositories that may contain that one piece
    of software that you really need (or can't be bothered to compile yourself).
  prefs: []
  type: TYPE_NORMAL
- en: 'Some common repositories are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: EPEL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RPMfusion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remi
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ZFS, on Linux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here, we will look at adding additional repositories, and the ramifications
    of doing so.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can go through this section in any order, but it's probably sensible to
    start at the start, and finish at the finish.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Log in to your VM. We''re going to start with CentOS. To begin, let''s take
    a look at the default repositories that we have to play with, using the `yum repolist`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: We see three repositories enabled by default, `Base`, `Extras`, and `Updates`.
  prefs: []
  type: TYPE_NORMAL
- en: CentOS - Adding the EPEL repository with epel-release
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Extra Packages for Enterprise Linux** (**EPEL**) is one of the more popular
    additional repositories in the CentOS/Red Hat space.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Because of this, it actually has a very easy method for installation, from
    the given repositories:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: 'Looking in our `repo` directory, you''ll now see two new files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: 'And `yum repolist` will show it, too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: Note that `epel-testing` isn't listed; this is because it's disabled, by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use this repository to search for packages that might not be in the
    defaults (such as `htop`, for example):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: CentOS - Adding the ELRepo repository by file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As suggested in the previous section, all that the package installation did
    was add appropriate GPG keys and the YUM configuration files for additional repositories;
    there's nothing stopping you from doing the same thing manually.
  prefs: []
  type: TYPE_NORMAL
- en: ELRepo is a popular repo, mostly due to the fact that it offers more up-to-date
    versions of the Linux kernel, for those people who like the layout and style of
    CentOS but who really want the latest drivers and features that the kernel can
    offer.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to import the repository''s public key, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: It's a good idea to make sure that the key you're installing is legitimate;
    there are various ways of doing this, including checking that TLS certificates
    are legitimate, comparing it with other systems, or ringing up the owner of the
    key and pestering them until they read the whole thing out to you.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we can either download and `yum install` the `rpm` file from
    the `elrepo` site, or we download it ourselves and extract the contents, so that
    we can take a look at what it does:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: The `rpm2cpio` command does what it suggests, and allows us to use `cpio` to
    extract the archive.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we now `cat` the directory that we''ve just unarchived, we can see the file
    that it''s going to drop into our system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: 'There''s more, as there are multiple repo designations in this file. Let''s
    just copy the `elrepo` block and output it to a file of our own making, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the repo has `enabled=1` set, meaning that we can now just run a
    `yum update` to make sure that our system is synced and aware of the upstream
    repository (although if we wanted to permanently disable this repo, we could change
    it to a `0`, and `yum` would ignore it):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we want to, we can also list all of the packages in the repo that we''ve
    just added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: Debian - Adding additional repositories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Debian is famous for having a shed-load of packages available to the end users.
    If you can think of a package, there's a good chance that it's available for installation
    out of the box, or that someone somewhere is working on how to maintain the package
    for you.
  prefs: []
  type: TYPE_NORMAL
- en: FreeBSD is probably the only OS that springs to mind that might have more packages
    available in its base installation.
  prefs: []
  type: TYPE_NORMAL
- en: Because of this famous fact, there's a good chance that you'll never need to
    install additional repositories, but never say never (despite me just doing so).
  prefs: []
  type: TYPE_NORMAL
- en: A good place to look for some unofficial repositories is the maintained unofficial
    page at [https://wiki.debian.org/DebianRepository/Unofficial](https://wiki.debian.org/DebianRepository/Unofficial).
  prefs: []
  type: TYPE_NORMAL
- en: Here, we can find various repositories, including one for Google Chrome, which
    we'll add.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will look at the default `sources.list` file that''s shipped with
    our image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: It looks fairly sparse, with only the `stretch main` and `stretch/updates main`
    repositories enabled.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with YUM, we need to make sure that we have a legitimate GPG key in place;
    Google''s is installed like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to add the repository – in this case, Google Chrome:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: 'Run `sudo apt update` to make sure that your list of available packages is
    up to date:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, do a search for Chrome:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: Voilà!
  prefs: []
  type: TYPE_NORMAL
- en: This is not a Chrome advertisement, either, and actually, the open source version
    of Chrome (Chromium) is already available in the default repositories. I would
    probably advise installing that, instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Mostly, you''ll probably be adding the `contrib` repository, which contains
    non-free software:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: Ubuntu - Adding PPAs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Interestingly, this is one significant place in which the Ubuntu and Debian
    worlds differ. In Ubuntu-land, there's the concept of **Personal Package Archives** (**PPAs**),
    which can be used to install third-party software.
  prefs: []
  type: TYPE_NORMAL
- en: You can install regular repositories, too, but PPAs are arguably a little more
    targeted. Do bear in mind that there's very little stopping anyone from creating
    a PPA, so make sure to follow due diligence before adding just anything.
  prefs: []
  type: TYPE_NORMAL
- en: PPAs can be searched out on the Canonical site, at [https://launchpad.net/ubuntu/+ppas](https://launchpad.net/ubuntu/+ppas).
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll add the LibreOffice Fresh PPA, as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: You may be prompted to accept the additional repository, simply by pressing
    *Enter*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The repository configuration that you just added is in the `apt sources.list.d`
    directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: This means that you can now install the bleeding edge version of LibreOffice!
    You'll be the cool kid of the word processing world at last.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Repositories are generally just places that house packages you might want to
    install. There's nothing special about them, as they're generally web servers
    that react as any might, serving you the contents (package) when you request it.
  prefs: []
  type: TYPE_NORMAL
- en: Adding additional repositories is a fairly common sysadmin activity, usually
    because you're adding your in-house proxy (commonly Artifactory at the moment,)
    or your developers really need the latest version of NodeJS.
  prefs: []
  type: TYPE_NORMAL
- en: Whatever the reason for adding repositories, just remember that basic security
    goes a long way (you are, after all, trusting the upstream not to have anything
    malicious in it), and appreciate that you can create problems for yourself if
    the repository disappears (which has happened, and will continue to happen).
  prefs: []
  type: TYPE_NORMAL
- en: Roundup - security, updating, and package management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's easy to forget about updates. It's comforting to get a system to a stable
    state, where no matter how much it's hammered, it's going to continue to chug
    along, doing what you've told it to do, and nothing more. What's uncomfortable
    is the idea of breaking that perfect peace, and that's where updates come in.
  prefs: []
  type: TYPE_NORMAL
- en: Software doesn't stand still; there are features being developed, security holes
    being patched, and tougher encryption methods being implemented, and all of these
    need to be accounted for by you, the sysadmin.
  prefs: []
  type: TYPE_NORMAL
- en: Package maintainers can do a lot, and they do, but it's up to you to make sure
    that what you're updating is tested, that it won't break anything else in your
    environment, and that those developers that were using an exploit to get their
    code to work on your platform have been thoroughly reprimanded.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of the day, things are likely to go wrong, but that's why development
    and testing environments should exist.
  prefs: []
  type: TYPE_NORMAL
- en: Yes, it was nerve-wracking to perform an update in the past, and that's why
    we came in on weekends and did updates in the middle of the night, when no one
    would notice if it broke for a bit. Those breakages can still happen, but now,
    we've learned from them; we have warnings and erratas and the general public will
    understand if your site has to go offline for a couple of hours to make sure that
    their credit card information doesn't get leaked, thanks to a malicious exploit.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of the day, software is stupid, and it's put together by humans,
    who are fallible. Keep your systems up to date, make sure that you check your
    sources (in other words, don't install random executables from untraveled corners
    of the internet), and make sure that you let your superiors know that yes, you
    might have to take the website offline for a little bit, or shut down their phone
    system, but it's better than appearing on the front page of the BBC website the
    next day.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, if you're really interested in the intricacies of how a distribution
    is built, how the packages all fit together, and why they're built or installed
    in the way that they are, then there are tools out there that can help you to
    learn.
  prefs: []
  type: TYPE_NORMAL
- en: '*Linux from Scratch* is one such tool, effectively a book on the ins and outs
    of building your own version of Linux. It''s not for beginners, and it can be
    frustrating at times (or slightly outdated, as software evolves), but it''s a
    great way to learn why things are the way they are, and I''d encourage everyone
    to perform the Linux from scratch installation at least once in their professional
    careers.'
  prefs: []
  type: TYPE_NORMAL
