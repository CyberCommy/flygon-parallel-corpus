- en: Chapter 1. Building SOAP Web-Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Using Maven for building and running a Spring-WS project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a data contract
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up a Web-Service using `DispatcherServlet`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simplifying the creation of a Web-Service using `MessageDispatcherServlet`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up a Web-Service on JMS transport
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up a Web-Service on E-mail transport
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up a Web-Service on embedded HTTP server transport
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up a Web-Service on XMPP transport
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up a simple endpoint mapping for the Web-Service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up a contract-first Web-Service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up an endpoint by annotating the payload-root
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up a transport-neutral WS-Addressing endpoint
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up an endpoint using an XPath expression
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling the incoming XML messages using DOM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling the incoming XML messages using JDOM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling the incoming XML messages using JAXB2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validating the XML messages on the server side using an interceptor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SOAP (Simple Object Access Protocol) was designed to be language-, transport-,
    and platform-independent, which is an alternative to the old fashioned middleware
    technologies such as CORBA and DCOM. SOAP was also designed to be extensible.
    The standards referred to as WS-* — WS-Addressing, WS-Policy, WS-Security, and
    so on are built on the SOAP protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Web-Services that use SOAP, along with WSDL and XML schema, have become
    the standard for exchanging the XML-based messages. The Spring Web-Services facilitate
    SOAP service development, by providing a comprehensive set of APIs and configurations
    for the creation of flexible Web-Services. The following diagram shows how a Spring-WS
    works when it receives an incoming message (the diagram is in abstract form):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introduction](img/5825_01_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '`MessageDispatcher` is the central point for a Spring Web-Service and dispatches
    Web-Service messages to the registered endpoint. In Spring-WS, request/response
    messages are wrapped inside the `MessageContext` object and the `MessageContext`
    will be passed to the `MessageDispatcher` (response will be set into MessageContext
    after invoking the endpoint). When a message arrives, MessageDispatcher uses the
    request object to get the endpoint. (Mapping a request to an endpoint is called
    **endpoint mapping** and it can be done by using data from beans registration
    within application context, scanning, and autodetection of annotations). Then
    the `MessageDispatcher` by using the endpoint, gets endpopint''s interceptors
    (which range from zero to many) and calls handleRequest method on them.'
  prefs: []
  type: TYPE_NORMAL
- en: An interceptor (`EndpointInterceptor` here), as the name suggests, intercepts
    the request/response to perform some operations prior to (for request)/after (for
    response) invoking the endpoint. This `EndpointInterceptor` gets called before/after
    calling the appropriate endpoint to perform several processing aspects such as
    logging, validating, security, and so on. Next, `MessageDispatcher` gets appropriate
    endpoint adapter for the endpoint method to be called. This adapter offers compatibility
    with various types of endpoint methods. Each adapter is specialized to call a
    method with specific method parameter and return type.
  prefs: []
  type: TYPE_NORMAL
- en: And Finally, `EndpointAdapter` invokes the endpoint's method and transforms
    the response to the desired form and set it into the `MessageContext` object.
    Now the initial message context that was passed to `MessageDispatcher`, contains
    the response object, that will be forwarded to the client (by the caller of `MessageDispatcher)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring-WS only supports the contract-first development style in which creating
    the contract (XSD or WSDL) is the first step. The required steps to build a contract-first
    Web-Service using Spring-WS are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Contract definition (either XSD or WSDL)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Creating endpoint: the class that receives and processes an incoming message.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configuration of Spring beans and the endpoint.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There are two types of endpoints, namely, payload endpoints and message endpoints.
    While message endpoints can access the entire XML SOAP envelop, the payload endpoint
    will only access the payload part of a SOAP envelop, that is, the body of a SOAP
    envelop. In this book, the focus is on creating payload endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, after a recipe for the explanation of creating contract from
    a set of XML messages, the major focus will be on implementing endpoints and its
    related configuration.
  prefs: []
  type: TYPE_NORMAL
- en: For the purpose of illustrating the construction process of Web-Services, this
    book uses a simple business scenario of a fictitious restaurant, Live Restaurant,
    which needs to accept online orders from customers. Live Restaurant decides to
    publish its `OrderService` component as a Web-Service. For simplicity, just two
    operations are considered for the `OrderService` (Java interface).
  prefs: []
  type: TYPE_NORMAL
- en: '![Introduction](img/5825_01_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The project will follow the following domain model:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introduction](img/5825_01_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Each recipe in this book will incrementally build parts of the project to make
    it a complete Web-Service application. The Java project name is `LiveRestaurant`,
    and each recipe will use a slightly different version of the project, with the
    extension `_R-x.x`. For example, the first recipe in this chapter will use `LiveRestaurant_R-1.1`
    for the Web-Service server and `LiveRestaurant_R-1.1-Client for the client` as
    the project name.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Setting up a Web-Service is the goal of this chapter, so more emphasis is on
    explanation of the server-side code and settings. Client-side code is used in
    this chapter for checking the functionality of the server. More about client side
    code, settings, and testing will be discussed in the following chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Using Maven for building and running a Spring-WS project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Recent modern software development, based on enterprise-grade open source technologies,
    requires a new generation of build and project management tools. Such tools can
    make a standard way for building, managing, and deploying small scale to large
    scale applications.
  prefs: []
  type: TYPE_NORMAL
- en: Maven, hosted by the Apache Software Foundation, is a project management and
    automated build and deploy tool. Maven is built upon Ant's features and adds several
    features such as feature dependency and project management. Maven was initially
    used for Java programming, but it can also be used to build and manage projects
    written in other programming languages. In recent years, Maven has been used to
    automate the process of building, managing, and testing the deployments of major
    open source projects.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe details the steps required to set up Maven for building, testing,
    and deploying the projects used in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This recipe requires the installation of the following software or tools:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Java 6 or higher and Maven 3.0.2: For download and installation, refer to [http://maven.apache.org/](http://maven.apache.org/)
    and [http://www.oracle.com/technetwork/java/javase/downloads/index.html](http://www.oracle.com/technetwork/java/javase/downloads/index.html).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add your custom repositories to `settings.xml` under `MAVEN_HOME/conf` or `.m2`
    folders `(MAVEN_HOME` is the folder in which Maven is installed and `.m2` is the
    folder in which Maven downloads its artifacts to).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Later, you can add an extra repository to your custom repositories. You can
    disable this repository by setting `activeByDefault` to `false` (the file that
    contains repositories is in the `resources` folder):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: An alternative way to include the Maven repositories to your Maven build is
    to include repository data in the POM file directly. Samples of both ways to include
    repositories are included under the `Using Maven` folder in the resource bundle
    of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Build and deploy a project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Browse the following Web-Service WSDL file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the browser''s output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output of the Maven command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In order to import a Maven project into an Eclipse IDE:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to the root of the project (\chapterOne\LiveRestaurant_R-1.1) and execute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Then, you can import the Maven project as an Eclipse project.
  prefs: []
  type: TYPE_NORMAL
- en: 'In case Maven cannot find a JAR file, you can use your custom repository using
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`mvn clean package` installs the required components into a local repository
    and creates a WAR/JAR file of the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '`mvn tomcat:run` runs a WAR file of the project on the Tomcat plugin. `mvn
    jetty:run` runs the WAR file of the project on the Jetty plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Creating a data contract
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A WSDL document, known as a service contract, provides a standard way in which
    a Web-Service client and server exchange data. Using WSDL, the client and server
    could be on a different application or platform. XML Schema Definition(XSD), known
    as data contract, describes the structure of the datatypes that are being exchanged
    between the Web-Service server and client. XSD describes the types, fields, and
    any validation on those fields (such as max/min or pattern, and so on). While
    WSDL is specific to the Web-Service and describes a Web-Service's artifacts, such
    as methods and data passed through these methods (WSDL itself uses an XSD for
    that), URL, and so on; XSD only presents the structure of the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'To be able to set up a Spring Web-Service, we need a contract. There are four
    different ways of defining such a contract for XML:'
  prefs: []
  type: TYPE_NORMAL
- en: DTDs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: XML Schema (XSD)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RELAX NG
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Schematron
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DTDs have limited namespace support, so they are not suitable for Web-Services.
    RELAX NG and Schematron certainly are easier than XML Schema. Unfortunately, they
    are not so widely supported across platforms. Spring-WS uses XML Schema.
  prefs: []
  type: TYPE_NORMAL
- en: A data contract is the center of Spring-WS and a service contract can be generated
    from a data contract. The easiest way to create an XSD is to infer it from the
    sample documents. Any good XML editor or Java IDE offers this functionality. Basically,
    these tools use some sample XML documents and generate a schema from it that validates
    them all. In this recipe, we will discuss sample XML data massages and how to
    convert them into a single schema file. The generated schema is used in this book
    as a data contract.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Install Java (as described in the first recipe).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install xmlbeans-2.5.0 from [http://xmlbeans.apache.org/](http://xmlbeans.apache.org/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The resources for this recipe are included in the folder Create Data Contract.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Copy your XML messages `(placeOrderRequest.xml, placeOrderResponse, cancelOrderRequest.xml`,
    and `cancelOrderResponse.xml)` to the `xmlbeans-2.5.0\bin` working folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command creates the `schema0.xsd` schema file. The generated
    schema result certainly needs to be modified, but it''s a great starting point.
    Here is the final polished schema `(orderService.xsd)`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Initially, the input and output sample messages are required. In this book,
    there are four XML messages (placeOrderRequest.xml, `placeOrderResponse, cancelOrderRequest.xml`,
    and `cancelOrderResponse.xml)` and all the recipes use these message data formats
    for communication. `Inst2xsd` generates a schema file from the existing XML sample
    messages. Resources of this recipe are included under the `Create Data Contract`
    folder in the resource bundle of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a Web-Service using DispatcherServlet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring-WS provides one of the easiest mechanisms to develop Web-Services in
    the Java platform. This recipe focuses on building a very simple Web-Service using
    the Spring-MVC `DispatcherServlet` and the components provided by Spring-WS.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, the project''s name is `LiveRestaurant_R-1.2` with the following
    Maven dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '`spring-ws-core-2.0.1.RELEASE.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`log4j-1.2.9.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Copy the service contract from the `resources` folder `(orderService.wsdl).`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an endpoint `(OrderSeviceMessageReceiverEndpoint)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure the endpoint, service contract, `WebServiceMessageReceiverHandlerAdapter,
    MessageDispatcher`, and `WsdlDefinitionHandlerAdapter`, in the server Spring configuration
    file `(Dispatcher-servlet.xml)` .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure `DispatcherServlet` inside the `web.xml` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the server using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'To browse your service WSDL, open the following link inside your browser:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'To test, open a new command window, go to the folder `LiveRestaurant_R-1.2-Client`,
    and run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the server-side output:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`DispatcherServlet` receives all the incoming requests, and based on request
    context, it forwards the request to the endpoint (the general form of a request
    URL is `http://<host>:<port>/<appcontext>/<requestcontext>` (here `appcontext`
    is Liverestaurant and `requestcontext` should start with `/Dispatcher/)`. The
    requests context that ends with `/OrderService` go to `OrderSeviceMessageReceiverEndpoint`
    and requests that end with `*.wsdl` go to `SimpleWsdl11Definition)`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`DispatcherServlet` configured in `web.xml` is responsible for receiving all
    requests with a URL mapping `[/Dispatcher/*]`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: You can change the URL pattern to suit your requirement.
  prefs: []
  type: TYPE_NORMAL
- en: '`DispatcherServlet` plays a major role in intercepting the HTTP requests and
    then loads the Spring bean configuration file. By default, it detects the bean
    configuration file by name`<servlet-name>-servlet.xml`. Since we have named the
    `DispatcherServlet` as `Dispatcher` in `web.xml` file, the server looks for `Dispatcher-servlet.xml`
    as application context filename. You may configure another file, using the following
    context `param` in the `web.xml:`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '`DispatcherServlet` needs separate instances of `WebServiceMessageReceiverHandlerAdapter,
    MessageDispatcher`, and `WsdlDefinitionHandlerAdapter` that in this recipe are
    configured inside `Dispatcher-servlet.xml`. The `DispatcherServlet`, by default,
    delegates to controllers for handling requests, but in the configuration file,
    it is configured to delegate to a `MessageDispatcher` `(WebServiceMessageReceiverHandlerAdapter).
    SaajSoapMessageFactory` is a specific message factory for message creation in
    Spring-WS.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: To let `DispatcherServlet` handle the WSDL contract, `WsdlDefinitionHandlerAdapter`,
    which is registered in the configuration file; it reads the WSDL file source using
    the `WsdlDefinition` implementation `(SimpleWsdl11Definition)` and writes that
    as the result to the `HttpServletResponse`.
  prefs: []
  type: TYPE_NORMAL
- en: '`SimpleUrlHandlerMapping` is to redirect the client requests to the appropriate
    endpoints using the URL patterns. Here the request URL that ends with `*.wsdl`
    will be redirected to `sampleServiceDefinition` (that is, `SimpleWsdl11Definition`
    that uses `OrderService.wsdl` to generate the response), and if the request URL
    contains `/OrderService`, it will be redirected to `OrderSeviceMessageReceiverEndpoint.
    SOAPMessageDispatcher` is to dispatch a SOAP message to the registered endpoint(s)
    `(OrderSeviceMessageReceiverEndpoint)`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can change the URL pattern to suit your requirement.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Setting up a Web-Service using MessageDispatcherServlet* recipe in this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Simplifying the creation of a Web-Service using MessageDispatcherServlet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`MessageDispatcherServlet` is the core component of Spring-WS. With simple
    configuration, a Web-Service can be set up in minutes. This servlet came as a
    simple way to configure an alternative to the Spring-MVC `DispatcherServlet`.
    As in the second recipe, *Setting up a Web-Service using DispatcherServlet*, `DispatcherServlet`
    needs separate instances of `WebServiceMessageReceiverHandlerAdapter, MessageDispatcher`,
    and `WsdlDefinitionHandlerAdapter`. However, `MessageDispatcherServlet` can dynamically
    detect `EndpointAdapters, EndpointMappings, EndpointExceptionResolvers`, and `WsdlDefinition`
    by setting inside the application context.'
  prefs: []
  type: TYPE_NORMAL
- en: Since this is the default method for configuring Spring Web-Services, it will
    be used in later recipes. In this recipe, a very basic implementation of setting
    up a Spring-WS is detailed. More advance implementation will be explained later
    in the recipe *Setting up a contract-first Web-Service*.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, the project''s name is `LiveRestaurant_R-1.3` with the following
    Maven dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '`spring-ws-core-2.0.1.RELEASE.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`log4j-1.2.9.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Copy the service contract from the `resources` folder `(orderService.wsdl)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an endpoint `(OrderSeviceMethodEndpoint)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure the endpoint. The service contract is in the server Spring configuration
    file `(spring-ws-servlet.xml)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure `MessageDispatcherServlet` inside the `web.xml` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the server using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output after the server is run successfully:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'To browse your service WSDL, open the following link in your browser:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'To test, open a new command window, go to the folder `LiveRestaurant_R-1.3-Client`,
    and run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the server-side output:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `MessageDispatcherServlet` is configured in the web configuration file `web.xml:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Downloading the example code**'
  prefs: []
  type: TYPE_NORMAL
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.PacktPub.com](http://www.PacktPub.com). If you
    purchased this book elsewhere, you can visit [http://www.PacktPub.com/support](http://www.PacktPub.com/support)
    and register to have the files e-mailed directly to you.
  prefs: []
  type: TYPE_NORMAL
- en: '`MessageDispatcherServlet` is the central element that handles the incoming
    SOAP requests, with the help of other components `(EndpointAdapters, EndpointMappings,
    EndpointExceptionResolvers`, and `WsdlDefinition)`. It combines the attributes
    of both `DispatcherServlet` and `MessageDispatcher` that dispatch to the appropriate
    endpoint. This is the standard servlet recommended to build Web-Services with
    Spring-WS.'
  prefs: []
  type: TYPE_NORMAL
- en: Since the `MessageDispatcherServlet` is inherited from `FrameworkServlet`, it
    looks for a configuration file named`<servlet-name>-servlet.xml` in the class
    path (you can change the configuration filename using the `context-param, contextConfigLocation`
    settings in the `web.xml`, as described in the recipe *Setting up a Web-Service
    using DispatcherServlet)*. In the example, since the servlet name in the `web.xml`
    file is set to Spring-WS, the file `spring-ws-servlet.xml` is the Web-Services
    configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: '`MessageDispatcherServlet` then looks up for an endpoint mapping element in
    the configuration file, for the purpose of mapping the client requests to the
    endpoint. Here,`<sws:static-wsdl` sets the data contract in the WSDL format. This
    is the element to be configured in `spring-ws-servlet.xml` to set up a Web-Service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The example uses `SimpleMethodEndpointMapping` that maps the client requests
    to `MethodEnpoints`. It maps the incoming request to a method that starts with
    the `handle+root` element of the message `(handle+placeOrderRequest)`. In the
    endpoint class `(OrderSeviceMethodEndpoint), a method with the name handleplaceOrderRequest`
    should be defined.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this method, the parameter source includes the incoming message and input
    parameters to call order service could be extracted from this parameter, then
    the method calls to the `orderService` method and wraps the outgoing message in
    the `StringSource` that is to be sent back to the client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The endpoint mappings will be detailed in the later recipes.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The recipes *Setting up a Web-Service using DispatcherServlet, Setting up a
    simple endpoint mapping for the Web-Service*, and *Setting up a contract-first
    Web-Service* discussed in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a Web-Service on JMS transport
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: HTTP is the most common Web-Service protocol. However, Web-Services are currently
    built on multiple transports, each with different scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: 'JMS was included in Java 2, J2EE by Sun Microsystems in 1999\. Using JMS, systems
    are able to communicate synchronously or asynchronously and are based on point-to-point
    and publish-subscribe models. SOAP over JMS inherits the JSM features and meets
    the following requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: Where asynchronous messaging is required
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Where the message consumers are slower than the producers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To guarantee the delivery of messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To have a publisher/subscriber(multiple) model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When sender/receiver might be disconnected
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Web-Services provide features to set up a Web-Service over JMS protocol
    that is built upon the JMS functionality in the Spring framework. In this recipe,
    how to set up a Spring-WS over JMS is presented.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, the project''s name is `LiveRestaurant_R-1.4` with the following
    Maven dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '`spring-ws-core-2.0.1.RELEASE.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spring-ws-support-2.0.1.RELEASE.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spring-test-3.0.5.RELEASE.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spring-jms-3.0.5.RELEASE.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`junit-4.7.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`xmlunit-1.1.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`log4j-1.2.9.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jms-1.1.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`activemq-core-4.1.1.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this recipe, Apache ActiveMQ is used to set up a JMS server and to create
    JMS server-related objects (queue and broker are used here). Spring-WS family
    JARs provide a functionality to set up a Spring-WS and `spring-jms` and `jms`
    JARs provide the JMS functionality that the Spring-WS, over JMS, is built upon
    it.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create an endpoint `(OrderSeviceMethodEndpoint)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure the `MessageListenerContainer, MessageListener`, and `connectionFactory`
    in the Spring configuration file (`applicationContext.xml`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure `MessageDispatcher` that includes the endpoint mappings inside `applicationContext.xml`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the recipe project using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output once the project runs successfully:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`DefaultMessageListenerContainer` listens to `destinationName` `(RequestQueue)`
    for incoming messages. When a message arrives, this listener will use the message
    factory `(messageFactory)` to extract the message and use the dispatcher `(messageDispatcher)`
    to dispatch the message to the endpoint `(SimplePayloadEndpoint)`.............'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the application context, `WebServiceMessageListener` is a listener inside
    `MessageListenerContainer`. The message container uses `connectionfactory` to
    connect to the destination (RequestQueue):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This listener uses `message Dispatcher` and `messageFactory` to receive incoming
    messages and to send outgoing SOAP messages. Inside `messageDiapatcher`, endpoint''s
    mapping is included, which sets the endpoint `(SimplePayloadEndpoint)` and type
    of endpoint mapping `(PayloadRootQNameEndpointMapping)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The `invoke` method from the endpoint `(SimplePayloadEndpoint)` will be called
    when a request comes to the server, and the response will be returned to be sent
    back to the client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '`JmsTransportWebServiceIntegrationTest` is included in the project to load
    the application context, set up the JMS server, and test the Web-Service. However,
    these details are not discussed here. The client of JMS transport will be discussed
    in the next chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Creating a Web-Service client on JMS transport* recipe discussed in [Chapter
    2](ch02.html "Chapter 2. Building Clients for SOAP Web-Services"), *Building Clients
    for SOAP Web-Services* and the *Exposing Web-Services using JMS as the underlying
    communication protocol* recipe discussed in [Chapter 10](ch10.html "Chapter 10. Spring
    Remoting"),*Spring Remoting.*
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a Web-Service on E-mail transport
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: HTTP is easy to understand and therefore has been most often defined and implemented,
    but it's clearly not the most suitable transport for Web-Services in any scenario.
  prefs: []
  type: TYPE_NORMAL
- en: Web-Service on E-mail transport can take advantage of store-and-forward messaging
    to provide an asynchronous transport for SOAP. In addition, there is no firewall
    concern on e-mail and those applications that are able to communicate together
    don't need web servers to set up a Web-Service. This allows SOAP, over mail transport,
    to be used in a number of scenarios where HTTP is not suitable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The reasons why setting up a Web-Service over HTTP is not suitable and e-mail
    might be a solution as a transport protocol are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: If a system is protected by a firewall, there is no control over the HTTP request/response,
    but e-mail is always is accessible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a system expects no request/response conventional model. For example, publish/subscriber
    model is required.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a request takes too long to complete. For example, if the server has to run
    complex and time-consuming services, the client would get an HTTP timeout error.
    In such a scenario, Web-Service over e-mail is more appropriate.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this recipe, setting up a Web-Service over E-mail transport is presented.
    To load the application context and test the Web-Service, a test class is used.
    This class also starts up and shuts down the server.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, the project''s name is `LiveRestaurant_R-1.5` with the following
    Maven dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '`spring-ws-core-2.0.1.RELEASE.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spring-ws-support-2.0.1.RELEASE.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spring-test-3.0.5.RELEASE.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mail-1.4.1.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mock-javamail-1.6.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`junit-4.7.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`xmlunit-1.1.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up a mail server outside a system that is using JavaMail for testing
    purpose is difficult. Mock JavaMail addresses this issue and provides a pluggable
    component to the system using JavaMail. The system can use this component to send/receive
    e-mails against the temporary in-memory *mailbox*.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create an endpoint `(SimplePayloadEndpoint)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure `MessageReceiver` and `MessageDispatcher` that include endpoint mappings
    inside `applicationContext.xml`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the recipe project using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Messages sent to an address will be saved in an inbox. The message receiver
    `(messageReceiver)` monitors the inbox at continuous intervals and as soon as
    it detects a new E-mail, it reads the E-mail, extracts the message, and forwards
    the message to a message dispatcher `(messageDispatcher)`. The message dispatcher
    will call the `invoke` method inside its default endpoint `(SamplePayloadEndpoint)`,
    and inside the handler method `(invoke)`, the response will be sent back to the
    client.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the application context is being loaded, `MailMessageReceiver` starts
    up a mail receiver and its inbox folder `(imap://server@packtpubtest.com/INBOX)`,
    that is, a temporary in-memory inbox. After loading the application context, the
    `messageReceiver` bean acts as a server monitor for the incoming messages based
    on a pluggable strategy `(monotoringStrategy)` that monitors the `INBOX` folder
    `(imap://server@packtpubtest.com/INBOX)` for new messages on `pollingInterval`
    of 1000 ms. `storeUri` is the location to be monitored for the incoming messages
    `(imap://server@packtpubtest.com/INBOX)` and `transportUri` is the mail server
    for sending the responses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside `messageDiapatcher`, endpoint mapping is included that sets the endpoint
    `(SimplePayloadEndpoint)` and type of the endpoint mapping `(PayloadRootQNameEndpointMapping)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '`SimplePayloadEndpoint` receives a request and returns a fixed dummy response
    using `OrderService`. When a request comes to the server, the `invoke` method
    will be called and the response will be returned that is to be sent back to the
    client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: To test this recipe, a `webServiceTemplate` is used. We will discuss it in the
    next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '`MailTransportWebServiceIntegrationTest` is included in the project to load
    the application context, set up the mail server, and to test the Web-Service.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Creating Web-Service client on E-mail transport* recipe, discussed in [Chapter
    2](ch02.html "Chapter 2. Building Clients for SOAP Web-Services"),*BuildingClients
    for SOAP Web-Services.*
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a Web-Service on embedded HTTP transport
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: External HTTP servers might be able to provide several features, but they are
    not light and they need a configuration to set up.
  prefs: []
  type: TYPE_NORMAL
- en: Spring-WS provides a feature to set up an HTTP-based Web-Service using embedded
    Sun's JRE 1.6 HTTP server. The embedded HTTP server is a light-weight standalone
    server that could be used as an alternative to external servers. While configuration
    of the web server is a must in a conventional external server `(web.xml)`, the
    embedded HTTP server doesn't need any deployment descriptor to operate and its
    only requirement is to configure an instance of the server through the application
    context.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, setting up a Spring Web-Service on the embedded HTTP server
    is presented. Since there is no external HTTP server, a Java class is used to
    load application context and start up the server.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, the project''s name is `LiveRestaurant_R-1.6` with the following
    Maven dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '`spring-ws-core-2.0.1.RELEASE.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`log4j-1.2.9.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Copy the service contract `(OrderService.wsdl)` from the resource folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a service and an implementation of it and annotate its implementation
    with `@Service("serviceName")` `(OrderSevice,OrderServiceImpl)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure the service in the application context `(applicationContext)` that
    is to be scanned and detected automatically.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure the embedded HTTP server inside the application context.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a Java class with the main method to load the application context to set
    up the embedded HTTP server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the server using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'From `LiveRestaurant_R-1.6-Client`, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output when the server runs successfully:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the client-side output:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the application context, `SimpleHttpFactoryBean` creates a simple HTTP server
    (from embedded Sun's JRE 1.6) and it starts the HTTP server on initialization
    and stops it on destruction.
  prefs: []
  type: TYPE_NORMAL
- en: The HTTP server that has a context property sets up a Web-Service with the service
    class `(orderServiceImpl)` set as the endpoint and specifies the URL defined by
    the properties inside the context `(localhost:3478/OrderService)`. This service
    interface is registered within the context property.
  prefs: []
  type: TYPE_NORMAL
- en: However, the service implementation is autodetected using `component-scan. HttpInvokerProxyFactoryBean`
    creates a client's proxy for a specific server URL.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '`IOrderServiceEndPointImpl` and `IOrderServiceEndPoint` are simple service
    interface and implementation classes. `IOrderServiceEndPointImpl` is annotated
    by `@Service` `(orderServiceImpl)` and is to be detected as a service implementation.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '`ServerStartUp.java` is used to load the application context and start up the
    server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Setting up Spring-WS on XMPP transport
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: HTTP is most often used as a Web-Service transport protocol. However, it is
    not able to meet the asynchronous communication requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Web-Service on XMPP transport is capable of asynchronous communication in which
    a client doesn't need to wait for a response from a service; instead, the service
    sends the response to the client when the process is completed. Spring-WS 2.0
    includes XMPP (Jabber) support in which a Web-Service can communicate over the
    XMPP protocol. In this recipe, setting up a Spring-WS on XMPP transport is presented.
    Since there is no external HTTP server, a test class is used to load the application
    context.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, the project''s name is `LiveRestaurant_R-1.7`, which has the
    following Maven dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '`spring-ws-core-2.0.1.RELEASE.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spring-ws-support-2.0.1.RELEASE.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spring-test-3.0.5.RELEASE.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`junit-4.7.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`xmlunit-1.1.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`smack-3.1.0.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create an endpoint `(SamplePlayLoadEndPoint).`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure connection to the XMPP server in the application context `(applicationContext.xml)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure the message receiver in the application context.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the response received:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the application context, the `messageFactory` bean is responsible for creating
    the incoming and outgoing SOAP messages. The `messageReceiver` bean acts as a
    server, using a connection (to `XMPP server:google talk)`, and listens to the
    host on a specific service with a username and password.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the message is sent by the client, it will be forwarded to the endpoint
    `(SamplePlayLoadEndPoint` that is configured within `messageDispatcher)` by the
    message dispatcher and the response will be returned to the client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '`Webservicetemplate` is used here as a client; it will be discussed in the
    next chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: '`SamplePlayLoadEndPoint` just receives a request and returns a response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: A test class is included in the project to load the application context, set
    up the XMPP Web-Service server, and test the Web-Service.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Creating Web-Service client on XMPP transport* recipe discussed in [Chapter
    2](ch02.html "Chapter 2. Building Clients for SOAP Web-Services"),*Clients for
    SOAP Web-Services.*
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a contract-first Web-Service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Generating WSDL and XSD contracts from Java code and setting up a Web-Service
    is called **contract-last development**. The major drawback to this approach is
    the contracts (WSDL or XSD) of the Web-Service could eventually change if there
    are any changes in Java classes. In this way, the client side has to update the
    client-side classes and that always is not favorable. The contract-first approach
    was introduced as an alternative to tackle the contract-last's bottleneck. In
    the contract-first approach, the contract (WSDL or schema) are primary artifacts
    to set up a Web-Service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the advantages of the contract-first approach over contract-last are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Performance: In contract-last, some extra data, that is, serialization of Java
    code might be exchanged between client and server, which decreases the performance,
    while contract-last precisely exchanges the required data and maximizes the performance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Consistency: Different vendors may generate different WSDL in the contract-last
    approach, while the contract-first approach eliminates this problem by standing
    on the same contract.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Versioning: Changing the version of a contract-last Web-Service means changing
    Java classes in both client and server side and that might eventually be expensive
    in case there are a lot of clients that call a Web-Service, while in contract-first,
    since the contract is decoupled from implementation, versioning could be simply
    done by adding a new method implementation in the same endpoint class or using
    a stylesheet to convert an old message format into new message format.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Maintenance/enhancement cost: Changing only a contract is much cheaper than
    changing Java code in both client and server side. In this recipe, we will discuss
    how to set up a contract-first Web-Service using Spring-WS.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, the project''s name is `LiveRestaurant_R-1.8`, with the following
    Maven dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '`spring-ws-core-2.0.1.RELEASE.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jdom-1.0.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Copy the data contract `(orderService.xsd)` from the resources folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an endpoint `(OrderEndpoint)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure the auto-detection of the endpoint using the component scan in the
    server Spring configuration file `(spring-ws-servlet.xml)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure the dynamic generation of WSDL from the data contract `(orderService.xsd)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the server using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Browse to the following link to see the WSDL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Run client from `LiveRestaurant_R-1.8-Client:`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output when the server runs successfully:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The steps of this recipe are the same as that of the recipe *Simplifying the
    creation of a Web-Service using MessageDispatcherServlet*, except the implementation
    of endpoint handling methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'This annotation serves as a specialization of `@Component`, allowing for the
    implementation classes to be autodetected through classpath scanning, which is
    configured in the server application context file `(spring-ws-servlet.xml)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '`OrderEndpoint` is the `endPoint` of this recipe and the `@Endpoint` annotation
    is also the same as `@service`, allowing for the implementation classes to be
    autodetected through classpath scanning. A request with the root element `placeOrderRequest`
    `(localPart = "placeOrderRequest")` and the namespace `http://www.packtpub.com/liverestaurant/OrderService/schema`
    will be forwarded to call the corresponding method `(handlePlaceOrderRequest)`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Other details about annotations and how the request will be mapped to an endpoint
    method are contained in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The following setting in the `spring-ws-servlet.xml` file causes the application
    to automatically generate the WSDL file from the data contract `(orderService.xsd)`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Even though WSDL can be generated automatically from the data contract (XSD),
    Spring-WS recommends avoiding autogeneration of WSDL for these reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: To keep consistency between releases (there might be slight differences among
    autogenerated WSDLs for different versions)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Autogeneration of WSDL is slow, although once generated, WSDL will be cached
    and used later.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Therefore, Spring-WS recommends, while developing, autogenerate WSDL once via
    the browser and save it and use static WSDL to expose the service contract.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The recipes *Setting up an endpoint by annotating the payload-root, Simplifying
    the creation of a Web-Service using MessageDispatcherServlet*, discussed in this
    chapter and the *Creating a Web-Service client on HTTP transport* recipe, discussed
    in [Chapter 2](ch02.html "Chapter 2. Building Clients for SOAP Web-Services"),*Building
    Clients forSOAP Web-Services.*
  prefs: []
  type: TYPE_NORMAL
- en: Also see the recipes discussed in [Chapter 10](ch10.html "Chapter 10. Spring
    Remoting"), *Spring Remoting*, to find out how to set up contract-last Web-Services.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a simple endpoint mapping for the Web-Service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe demonstrates a very simple endpoint mapping that maps a Web-Service
    request to a Java class method.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, the project''s name is `LiveRestaurant_R-1.9`, with the following
    Maven dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '`spring-ws-core-2.0.1.RELEASE.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`log4j-12.9.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The steps of this recipe are the same as that of the previous recipe, *Setting
    up a contract-first Web-Service*, except that the registration of the endpoint,
    that is, method endpoint mapping and is configured in `spring-ws-servlet.xml`.
  prefs: []
  type: TYPE_NORMAL
- en: Define an endpoint `(OrderSeviceMethodEndpoint)` based on the method mapping
    standard `(SimpleMethodEndpointMapping)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure the method endpoint mapping in `spring-ws-servlet.xml`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the `mvn clean package tomcat:run` command and browse to see the WSDL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'To test, open a new command window, go to `Liverestaurant_R-1.9-Client`, and
    run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the server-side output:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`SimpleMethodEndpointMapping` maps from the local name of the request payload
    `(placeOrderRequest)` to the methods of the POJO classes. Here is a sample of
    the request payload (note the local name of the request payload):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: The endpoint bean is registered using the `endpoints` property. This property
    tells you that there should be a method in the `endpoint` class `(OrderServiceEndpoint)`
    with a name that starts with `methodPrefix(handle)` and ends with the request
    payload local name `(placeOrderRequest)`. This increases the flexibility of the
    endpoint naming by using the configuration in `spring-ws-servlet.xml:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: The endpoint method name should match the `handle+request` message root name
    `(handleplaceOrderRequest)`. In the body of the method, we should process the
    request and finally return the response in the form of `javax.xml.transform.Source:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The recipes *Setting up a transport-neutral WS-Addressing endpoint* and *Setting
    up an endpoint by annotating the payload-root*, discussed in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up an endpoint by annotating the payload-root
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring-WS simplifies the creation of complex Web-Services further by its annotation
    features and reduces the code and configuration in XML.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, the project''s name is `LiveRestaurant_R-1.10`, with the following
    Maven dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '`spring-ws-core-2.0.1.RELEASE.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`log4j-12.9.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The steps of this recipe are the same as that of *Setting up a contract-first
    Web-Service* and here we want to describe the endpoint mapping using annotation
    in the `endpoint` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Browse to the following link to see the WSDL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'To test, open a new command window, go to `LiveRestaurant-1.10-Client`, and
    run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the server-side output:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By including component scan and annotation-driven settings in the Spring-WS
    configuration file `(spring-ws-servlet.xml)`, the Spring container will scan the
    entire package for endpoints, services, and dependencies to inject and autowire
    each other to build the Web-Service blocks. You cannot see the adapters and other
    handlers here, since the container smartly picks the right/default adapter, dynamically
    (messageDispatcher runs support method of an adapter from a list of existing adapters
    for the endponit, and if support method returns `true`, that adapter is the right
    adapter):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'The `@Endpoint` annotation of `OrderSeviceAnnotationEndpoint` makes it an endpoint,
    with `PayloadRootAnnotationMethodEndpointMapping`, with the exact pointers to
    the method-endpoint mapping with the method-level annotations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '`@PayloadRoot` helps the `MessageDispatcher` to map the request to the method,
    with the help of an argument annotation, `@RequestPayload`, which specifies the
    exact message payload part of the entire SOAP message as an argument into the
    method (it finds the method by root element of a request equal to `localPart`,
    for example, `placeOrderRequest` or `placeCancelRequest). @RequestPayload` tells
    the container that the argument `RequestPayload` is to be extracted from the SOAP
    message and injected to the method as an argument at runtime.'
  prefs: []
  type: TYPE_NORMAL
- en: The return type annotation, `@ResponsePayload`, instructs `MessageDispatcher`
    that the instance of `javax.xml.transform.Source` is `ResponsePayload`. The smart
    Spring-WS framework detects the type of these objects at runtime and delegates
    to the appropriate `PayloadMethodProcessor`. In this case, it is `SourcePayloadMethodProcessor`,
    since the input argument and the return value are of the type `javax.xml.transform.Source`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The recipes *Setting up a transport-neutral WS-Addressing endpoint* and *Setting
    up a simple endpoint mapping for the Web-Service*, discussed in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a transport-neutral WS-Addressing endpoint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using HTTP transport information inside the XML messages for routing messages
    to endpoints mixes data and operation together, and these messages will be replied
    to for the requested client.
  prefs: []
  type: TYPE_NORMAL
- en: WS-Addressing standardizes routing mechanism by separating routing data and
    including it inside the SOAP headers. WS-Addressing may use its own metadata instead
    of using HTTP transport data for endpoint routing. In addition, a request from
    a client may return to a different client in WS-Addressing. For example, considering
    the following request from a client, the client side can set `ReplyTo` to its
    own address and `FaultTo` to admin the endpoint address. Then, the server will
    send successful messages to the client and fault messages to the admin address
    `[<SOAP-ENV:Envelope xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/">`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: In this recipe, we will set up a Spring-WS using WS-Addressing.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, the project''s name is `LiveRestaurant_R-1.11` with the following
    Maven dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '`spring-ws-core-2.0.1.RELEASE.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`log4j-12.9.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The steps of this recipe are the same as that of *Setting up an endpoint by
    annotating the payload-root*, except for the endpoint class. So, follow the steps
    of the mentioned recipe and define a new endpoint with WS-Addressing standards.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'To test, open a new command window to `Liverestaurant_R-1.11-Client` and run
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the server-side output:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Same as the previous recipe, *Setting up an endpoint by annotating the payload-root*,
    the incoming WS-Addressing SOAP messages will be forwarded to the endpoint `(OrderEndpoint`,
    which is autodetected by `@Endpoint)`. As you can see from the output, a header
    is added to the SOAP envelop that WS-Addressing uses for mapping and dispatching
    purposes of the endpoint method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: In this recipe, the server applies `AnnotationActionEndpointMapping`, which
    uses `@Action` (http://www.packtpub.com/OrderService/OrdReq). `@Action` is similar
    to `@PayloadRoot` for recognizing the handling methods `(handleOrderRequest)`
    in the endpoint `(OrderEndpoint)` .
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The recipe *Creating Web-Service client for WS-Addressing endpoint*, discussed
    in [Chapter 2](ch02.html "Chapter 2. Building Clients for SOAP Web-Services"),
    *Building Clients for SOAP Web-Services*, and the recipe *Setting up an endpoint
    by annotating the payload root*, discussed in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up an endpoint using an XPath expression
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spring-WS allows us to extract the passed parameters in the `endpoint` method''s
    signature using annotations with the XPath expressions. For example, in the `endpoint`
    method''s `handleOrderRequest` (@RequestPayload `Source source)`, if you want
    to find the value of any element in the source object, you have to use Java API
    to extract the value. You can eliminate using Java API in the handler method by
    using XPath in the method''s signature to extract the data from the incoming XML
    data, as shown as follows: `handleOrderRequest(@XPathParam("/OrderRequest/message")
    String message)`.'
  prefs: []
  type: TYPE_NORMAL
- en: This recipe illustrates the usage of XPath expressions in endpoint mapping with
    the help of annotation.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, the project''s name is `LiveRestaurant_R-1.12` with the following
    Maven dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '`spring-ws-core-2.0.1.RELEASE.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`log4j-12.9.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The steps of this recipe are the same as that of *Setting up an endpoint by
    annotating the payload-root*, except for the implementation of endpoint handling
    methods. So, follow the steps of the mentioned recipe and use XPath expressions
    to extract data from incoming message and create a response.
  prefs: []
  type: TYPE_NORMAL
- en: Run the following command from `LiveRestaurant_R-1.12:`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Browse to the following link to see the Web-Service service contract:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'To test, open a new command window, go to `LiveRestaurant_R-1.12-Client`, and
    run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the server-side output:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Passing the method parameter is the same as the recipe *Setting up an endpoint
    by annotating the payload-root*, except that it uses `@XPathParam`, which specifies
    the path of the data in a message that is to be passed as an argument into the
    method. Here `XpathParamMethodArgumentResolver` is responsible for extracting
    the value from the message and passing it to the method.
  prefs: []
  type: TYPE_NORMAL
- en: The annotation `XpathParam` helps the `MethodArgumentResolvers (XpathParamMethodArgumentResolver)`
    to extract information out of the XML and binds a node value to a method argument
    (using `// cause`, the whole message is searched recursively, for example, `//lName`
    searches the whole `placeRequestRequest` message). The same implementation is
    used for the method `cancelOrderRequest:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'The method argument can be any of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`boolean` or `Boolean`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`double` or `Double`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`String`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Node`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NodeList`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The recipe *Setting up an endpoint by annotating the payload-root*, discussed
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Handling the incoming XML messages using DOM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The implementation of the endpoint requires us to get the incoming XML messages
    and extract its data. In Java, there are various methods `(W3C DOM, SAX, XPath,
    JAXB, Castor, XMLBeans, JiBX`, or `XStream)` for extracting data from an input
    XML message, but most of them are not language-neutral.
  prefs: []
  type: TYPE_NORMAL
- en: DOM was created to be language-neutral and initially used for JavaScript manipulation
    of HTML pages. In Java, W3C DOM library is provided to interact with XML data.
    Classes, such as `org.w3c.dom.Document, org.w3c.dom.Element, org.w3c.dom.Node`,
    and `org.w3c.dom.Text` from W3C DOM library, are for extracting data from an input
    XML message.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, W3C DOM is used to extract the data from incoming messages.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, the project''s name is `LiveRestaurant_R-1.13`, with the following
    Maven dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '`spring-ws-core-2.0.1.RELEASE.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`log4j-1.2.9.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The steps of this recipe are the same as that of the recipe *Setting up an endpoint
    by annotating the payload-root*, except for the implementation of the endpoint-handling
    methods. So, follow the steps of the mentioned recipe and use DOM to extract data
    from the incoming message and create the response.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the command `mvn clean package tomcat:run` and browse to the following
    link:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'To test, open a new command window and run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the server-side output:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Passing the method parameter is the same as the recipe *Setting up an endpoint
    by annotating the payload-root*, except that we use `@RequestPayload`, which specifies
    the DOM element of data in a message to be passed as an argument into the method.
    Here, `DomPayloadMethodProcessor` is responsible for extracting the value from
    the message and passing it to the method. Since the return type which is specified
    by `@ResponsePayload` is also a DOM element type, `DomPayloadMethodProcessor`
    is being used as return handler.
  prefs: []
  type: TYPE_NORMAL
- en: The `@PayloadRoot` annotation informs Spring-WS that the `handleCancelOrderRequest`
    method is a handling method for XML messages. The sort of message that this method
    can handle is indicated by the annotation values (the `@RequestPayload` element
    tells it is of the DOM element type). In this case, it can handle XML elements
    that have the `placeOrderRequest` local part and the `http://www.packtpub.com/liverestaurant/OrderService/schema`
    namespace.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code extracts the elements `refNumber, fName`, and `lName` from
    the incoming XML message `(placeOrderRequest)` via the method `getElementsByTagNameNS`.
    Then, it finds and returns the text content of the first item in the `refNumber,
    fName`, and `lName` elements (by `item(0).getTextContent())`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following part of the code creates an outgoing XML message by creating
    the `placeOrderResponse` element (using `document.createElementNS)`. Then, it
    creates the child element `refNumber` (using `document.createElementNS)` and creates
    the text of this element (using `createTextNode and appendChild)`. Then, it appends
    the `refNumber` element to the response element `placeOrderResponse` (using the
    `appendChild` method):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The recipe *Setting up an endpoint by annotating the payload-root*, discussed
    in this chapter and the recipe *Creating a Web-Service client on HTTP transport*,
    discussed in [Chapter 2](ch02.html "Chapter 2. Building Clients for SOAP Web-Services"),*Building
    Clients for SOAP Web-Services.*
  prefs: []
  type: TYPE_NORMAL
- en: Handling the incoming XML messages using JDOM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Implementation of endpoints requires us to get the incoming XML messages and
    extract its data. DOM can fetch the data from an XML document, but it is slow
    and memory consuming and has very basic features.
  prefs: []
  type: TYPE_NORMAL
- en: JDOM document is not built into the memory; it is built on demand (lazy initialization
    design pattern). In addition, JDOM makes navigating through the document tree
    or manipulating the elements easier by providing a standard Java-based collection
    interface. In this recipe, JDOM is used to extract data from incoming messages.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, the project''s name is `LiveRestaurant_R-1.14`, with the following
    Maven dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '`spring-ws-core-2.0.1.RELEASE.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jdom-1.0.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`log4j-1.2.9.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jaxen-1.1.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`xalan-2.7.0.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The steps of this recipe are the same as that of the *Setting up an endpoint
    by annotating the payload-root* recipe, except for the implementation of the endpoint-handling
    methods. So, follow the steps of the aforementioned recipe, use JDOM to extract
    the data from incoming message, and create the response.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Browse to the following link:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'To test, open a new command window and run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the server-side output:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It works in the same way as explained in the previous recipe, except that it
    uses `JDOM` in its method implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following part of the code extracts the values `refNumber, fName`, and
    `lName` from the incoming XML message `(placeOrderRequest)` by using namespace
    and XPath object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'The following part of the code creates an outgoing message by creating the
    `placeOrderResponse` element (using `new Element(...))`. Then, it creates the
    child element `refNumber` (using `new Element(...))` and creates the text of this
    element (using `setText(...))`. Then, it appends the message element to the response
    element `placeOrderResponse` (using the `addContent` method):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The recipes *Setting up an endpoint by annotating the payload-root* and *Handling
    incoming XML Messages using DOM*, discussed in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The recipe *Creating a Web-Service client on HTTP transport*, discussed in [Chapter
    2](ch02.html "Chapter 2. Building Clients for SOAP Web-Services"),*Building Clients
    for SOAP Web-Services.*
  prefs: []
  type: TYPE_NORMAL
- en: Handling the incoming XML messages using JAXB2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Java Architecture for XML Binding (JAXB) is a Java standard for Object-XML marshalling.
    JAXB defines a programmer API for reading and writing Java objects to / from XML
    documents. The object-XML mapping is generally annotated in classes. JAXB provides
    a set of useful annotations with the default values for most of them that make
    this marshalling an easy job.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe demonstrates how to handle the incoming XML message in a Web-Service
    using JAXB in a very simple way. For simplicity and a continuation from the previous
    recipes, the same recipes are re-used with little improvements in converting the
    XML schema into domain classes to demonstrate the usage of JAXB.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, the project''s name is `LiveRestaurant_R-1.15` and has the
    following Maven dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '`spring-ws-core-2.0.1.RELEASE.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`log4j-1.2.9.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The steps of this recipe are the same as that of the recipe *Setting up an endpoint
    by annotating the payload-root*, except for the implementation of the endpoint
    handling methods. So, follow the steps of the aforementioned recipe and use JAXB
    Marshaller/Un-Mashaller to convert payload into/from POJO.
  prefs: []
  type: TYPE_NORMAL
- en: First, we define a set of domain objects we need to marshal to/from XML from
    the data contract `OrderService.xsd` (refer to the recipe *Marshalling with JAXB2*,
    discussed in [Chapter 6](ch06.html "Chapter 6. Marshalling and Object-XML Mapping
    (OXM)"),
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the implementation of the endpoint `(OrderEndpoint)` to use JAXB.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Browse to the following link:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'To test, open a new command window to `Liverestaurant_R-1.15-Client` and run
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the server-side output:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the preceding code, the XML is bound with Java classes at runtime using
    `JAXB`. The incoming XML is converted into Java objects (unmarshalling) and after
    processing the objects, the resultant objects are marshalled back to XML before
    returning to the caller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'The `JAXB` context binds the Java classes passed via the constructor with the
    incoming XML, with the help of annotations in the classes at runtime, which instructs
    the unmarshaller to instantiate and load data from the XML tags into the objects.
    The objects are now passed to the service classes `(OrderServiceImpl)` for processing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: This approach allows the developer to work with Java objects instead of XML
    code with simple marshalling technology.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The recipe *Setting up an endpoint by annotating the payload-root*, discussed
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The recipe *Marshalling with JAXB2*, discussed in [Chapter 6](ch06.html "Chapter 6. Marshalling
    and Object-XML Mapping (OXM)"),*Marshalling and Object-XMLMapping (OXM) — Converting
    POJO to/from XML messages using Marshallers andUn-Marshallers.*
  prefs: []
  type: TYPE_NORMAL
- en: Validating the XML messages at the server side using an interceptor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data contract is a basic concept used to set up a Spring-WS. However, validation
    is a basic requirement before a SOAP message sends/replies on the server side/client
    side.
  prefs: []
  type: TYPE_NORMAL
- en: Spring-WS supports validation of messages on the server side as well as the
    client side. In this recipe, server-side validation is applied and when the incorrect
    request comes to the server or the incorrect response replays from the server
    to the client, it throws an exception.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, the project''s name is `LiveRestaurant_R-1.16` with the following
    Maven dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '`spring-ws-core-2.0.1.RELEASE.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`log4j-1.2.9.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The steps of this recipe are the same as that of *Handling the incoming XML
    messages using DOM*, except for the validation of request/response message.
  prefs: []
  type: TYPE_NORMAL
- en: Modify `spring-ws-servlet.xml` to include `PayloadValidatingInterceptor`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'Browse to the following link:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'To test, open a new command window to `Liverestaurant_R-1.16-Client` and run
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the server-side output:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`spring-ws-servlet.xml` is almost the same, as described in the recipe *Handling
    the incoming XML messages using DOM*, except that it includes the interceptor
    that uses schema for validation, `validateRequest`, and `validateResponse`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'When running the client, two requests will be sent to the server. The first
    one will be processed and the response will be sent back to the client, while
    the second one contains the wrong element (address instead of `addressPrimary)`
    that will send the faulty response back:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The recipe *Setting up an endpoint by annotating the payload-root*, discussed
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The recipe *Creating a Web-Service client on HTTP transport*, discussed in [Chapter
    2](ch02.html "Chapter 2. Building Clients for SOAP Web-Services"),*BuildingClients
    for SOAP Web-Services.*
  prefs: []
  type: TYPE_NORMAL
