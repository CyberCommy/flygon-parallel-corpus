- en: Using Boto3 and Pacu to Maintain AWS Persistence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Establishing persistence in an AWS environment allows you to maintain privileged
    access, even in scenarios where your active attack gets detected and your primary
    means of access to an environment is shut down. It's not always possible to stay
    completely under the radar, so in those situations where we get caught, we need
    a backup plan (or two, or three, or...). Ideally, this backup plan is stealthy
    to establish and stealthy to exercise if we need to gain access to the environment
    again.
  prefs: []
  type: TYPE_NORMAL
- en: There are many techniques and methodologies relating to malware, evasion, and
    persistence that could be applied to this chapter, but we are going to stick with
    the different methods we can abuse in AWS and not necessarily the methodology
    behind a whole red-team-style penetration testing engagement. Persistence techniques
    in AWS differ greatly from traditional types of persistence, such as on a Windows
    server, but those techniques (as we already know) can also be applied to any servers
    within the AWS environment we are attacking.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we are going to focus on persistence within the actual AWS
    environment, rather than on servers that lie within the environment. These types
    of persistence include techniques such as backdoor user credentials, backdoor
    role trust relationships, backdoor EC2 Security Groups, backdoor Lambda functions,
    and more.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Backdooring users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Backdooring role trust relationships
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Backdooring EC2 Security Groups
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Lambda functions as persistent watchdogs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Backdooring users
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we begin, let's define what backdooring really is. In the context of
    this chapter, it means almost exactly what it sounds like in that we are opening
    up a backdoor into an environment so that if the frontdoor is closed, we can still
    get in. In AWS, the backdoor could be any number of things that are covered throughout
    this chapter, and the frontdoor would be our primary means of access to the environment
    (that is, compromised IAM user credentials). We want our backdoors to outlast
    a situation where our compromise is detected by a defender and the compromised
    user is shut down, because we can still hopefully enter through the backdoor in
    that case.
  prefs: []
  type: TYPE_NORMAL
- en: As we have demonstrated and used repeatedly in previous chapters, IAM users
    can be set up with an access key ID and a secret access key that allows them access
    to the AWS APIs. Best practice is to generally use alternative methods of authentication,
    such as **single sign-on** (**SSO**), which grants temporary federated access
    to an environment, but best practices aren't always followed. We will continue
    with a similar scenario to the one we used in the previous chapters, where we
    had the credentials to one IAM user, `Test`. We will also continue with the idea
    that our user has administrator-level access to the environment, through the privilege
    escalation we exploited in [Chapter 10](05397993-74ba-4bae-a6f9-cc0d23f8f420.xhtml), *Privilege
    Escalation of AWS Accounts Using Stolen Keys, Boto3 and Pacu*.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple IAM user access keys
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Each IAM user in an account has a limit of two access key pairs. Our test user
    already has one created, so one more can be created before our limit has been
    hit. Considering the scenario where the keys we have been using are someone else''s
    and we happened to gain access to them, a simple form of persistence we could
    use would be to just create a second set of keys for our user. By doing so, we
    would have two sets of keys for the same user: one that we compromised, and one
    that we created ourselves.'
  prefs: []
  type: TYPE_NORMAL
- en: This is a little too simple, though, because if we were to get detected and
    someone on the defensive side was to just remove our user, it would delete both
    of our methods of access to the environment in one go. We can instead target a
    different privileged user in the environment to create our backdoor keys for.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will want to see what users exist in the account, so we will run
    the following AWS CLI command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This command will return some identifying information about each IAM user in
    the account. Each one of these users is a possible target for our backdoor keys,
    but we need to consider users who already have two sets of access keys. If a user
    already has two sets and someone tries to create a third set, an API error is
    thrown, which could end up being very noisy to a listening defender, ultimately
    getting us caught.
  prefs: []
  type: TYPE_NORMAL
- en: 'I want to target the user `Mike`, who was one of the users returned from our
    AWS CLI command. Before trying t7o add access keys to `Mike`, I will check to
    make sure that he doesn''t already have two sets of access keys with the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the output of that command, and that `Mike`
    already has two sets of access keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3632ae0c-963e-44bc-bfda-da9d5f7d52af.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1: Listing the access keys for Mike shows that he already has two set
    up'
  prefs: []
  type: TYPE_NORMAL
- en: This means that we should not target `Mike`. This is because trying to create
    another set of keys would fail, resulting in an error from the AWS API. A vigilante
    defender may be able to correlate that error to your malicious activity, ultimately
    getting you caught.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is another user that appeared previously with a user name of `Sarah`,
    so let''s check how many access keys she has set up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, the results show up as an empty array, which indicates that there
    are no access keys set up for `Sarah`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cf323cea-9d65-4a23-a590-6c264ce137ff.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2: No access keys show up when we try to list Sarah''s'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we know we can target `Sarah` for our persistence, so let''s run the following
    command to create a new pair of keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The response should look something like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f9abfe8b-34b8-499b-b8ba-b2525f62a482.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3: An access key ID and secret access key that belong to Sarah'
  prefs: []
  type: TYPE_NORMAL
- en: Now we can use the keys that were returned to access any permission associated
    with `Sarah`. Keep in mind that this method can be used for privilege escalation
    in addition to persistence in a scenario where your initial access user has a
    low number of privileges, but `iam:CreateAccessKey` is one of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s store credentials of `Sarah` locally with the AWS CLI so we don''t need
    to worry about them in the meantime. To do so, we can run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Then we can fill in the values that we are prompted for. Similarly, we can add
    these keys into Pacu with the `set_keys` command.
  prefs: []
  type: TYPE_NORMAL
- en: Do it with Pacu
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Pacu has a module that automates this entire process for us as well. This module
    is known as the `iam__backdoor_users_keys` module, and automates the process we
    just went through. To try it out, run the following command within Pacu:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: By default, we will get a list of users to choose from, but alternatively we
    could have supplied a username in the original command.
  prefs: []
  type: TYPE_NORMAL
- en: Now when our original access to the environment is discovered, we have backup
    credentials to a (hopefully highly privileged) user. If we wanted, we could use
    techniques from previous chapters to enumerate the permissions for that user.
  prefs: []
  type: TYPE_NORMAL
- en: Backdooring role trust relationships
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: IAM roles are an integral part of AWS. In the very simplest terms, roles can
    be assumed to supply a specific set of permissions to someone/something for a
    temporary amount of time (the default being 1 hour). This someone or something
    could be a person, an application, an AWS service, another AWS account, or really
    anything that programmatically accesses AWS.
  prefs: []
  type: TYPE_NORMAL
- en: IAM role trust policies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An IAM role has a document associated with it that is known as its trust policy.
    The trust policy is a JSON policy document (for example IAM policies such as `ReadOnlyAccess`
    or `AdministratorAccess`) that specifies who/what can assume that role and under
    what conditions that is allowed or denied. A common trust policy document that
    allows the AWS EC2 service permission to assume a certain role might look like
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This policy allows the EC2 service access to assume the role it belongs to.
    A scenario where this policy might be used is when an IAM role is added to an
    EC2 instance profile, which is then attached to an EC2 instance. Then, temporary
    credentials for the attached role are accessible from within the instance and
    the EC2 service will use it for anything that it needs access to.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some features of IAM roles that work out very nicely for us attackers are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Role trust policies can be updated at will
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Role trust policies can provide access to other AWS accounts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In terms of establishing persistence, this is perfect. That means, generally,
    that all we need to do is update the trust policy of a privileged role in a target
    account to create a trust relationship between that role and our own personal
    attacker AWS account.
  prefs: []
  type: TYPE_NORMAL
- en: In our example scenario, we have two AWS accounts created. One of them (account
    ID `012345678912`) is our own personal attacker account, which means we personally
    registered this through AWS. The other (account ID `111111111111`) is the account
    that we have compromised keys for. We want to establish cross-account persistence
    to guarantee our future access to the environment. This means that even after
    the compromise is detected by a defender, we can still regain access to the environment
    through cross-account methods, allowing us to maintain access to our target environment
    without opening any other security holes in the process.
  prefs: []
  type: TYPE_NORMAL
- en: Finding a suitable target role
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first step in establishing this kind of persistence will be to find a suitable
    role to target. Not all roles allow you to update their trust policy document,
    which means we don't want to target those roles. They are generally service-linked
    roles, which are a unique type of IAM role that is linked directly to an AWS service
    ([https://docs.aws.amazon.com/IAM/latest/UserGuide/using-service-linked-roles.html](https://docs.aws.amazon.com/IAM/latest/UserGuide/using-service-linked-roles.html)).
  prefs: []
  type: TYPE_NORMAL
- en: 'These roles can be quickly identified from the IAM roles page of the AWS web
    console in a few different ways. First, you will likely see that they begin with `AWSServiceRoleFor` in
    their name and will be followed by the AWS service they are for. Another indicator
    is in the trusted entities column of the role list; it will say something like
    `AWS service:<service name>(Service-Linked role)`. If you see the `Service-Linked
    role` note, then you know you cannot update the trust policy document. Finally,
    all AWS service-linked roles will include the path `/aws-service-role/`. No other
    roles are allowed to use that path for a new role:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/928e2843-f15c-4672-a0c7-264f13130378.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4: Two service-linked roles in our test account'
  prefs: []
  type: TYPE_NORMAL
- en: 'Don''t get tricked, though! By only relying on the name to indicate what roles
    are service roles, you could get fooled. The perfect example is the following
    screenshot, where the role `AWSBatchServiceRole` is shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d7081826-2480-44ac-aebf-f8a9289b4375.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The name `AWSBatchServiceRole` clearly would indicate that this role is a service-linked
    role, right? Wrong. If you noticed, there is no `(Service-Linked role)` note after
    `AWS service: batch`. So, this means that we can update the trust policy for this
    role, even though it sounds like a service-linked role.'
  prefs: []
  type: TYPE_NORMAL
- en: In our test environment, we found a role named `Admin`, which should immediately
    scream `high privileged` to you as an attacker, so we are going to target this
    role for our persistence. We don't want to screw anything up in the target environment,
    so we will want to add ourselves to the trust policy, rather than overwrite it
    with our own policy that could potentially screw things up in the environment.
    If we happened to remove access for a certain AWS service, resources that rely
    on that access may begin to fail and we don't want that for many different reasons.
  prefs: []
  type: TYPE_NORMAL
- en: 'The data returned from `iam:GetRole` and `iam:ListRoles` should already include
    the active trust policy document for the role we want under the `AssumeRolePolicyDocument` key
    of the JSON response object. The admin role we are targeting looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: If we look at the value under `AssumeRolePolicyDocument` > `Statement`, we can
    see that there is a single principal allowed to assume this role currently, which
    is the **Amazon Resource Name** (**ARN**), `arn:aws:iam::111111111111:root`. This
    ARN refers to the root user of the account with the ID `111111111111`, which basically
    translates to `any resource in account ID 111111111111`. That includes the root
    user, IAM users, and IAM roles.
  prefs: []
  type: TYPE_NORMAL
- en: Adding our backdoor access
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are now going to add our attacker-owned account as a trust policy to this
    role. First, we will save the value of the `AssumeRolePolicyDocument` key in the
    roles trust policy to a local JSON file (`trust-policy.json`). To add trust to
    our own account without removing the current trust, we can turn the value of the
    `Principal` `AWS` key from a string to an array. This array will include the root
    ARN that already is in place and the root ARN of our attacker account. `trust-policy.json` should
    look like the following now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will update the role with this trust policy using the AWS CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If everything was successful, then the AWS CLI should not return any output
    to the console. Otherwise, you will see an error and a short description of what
    went wrong. If we wanted to confirm that everything went correctly, we could use
    the AWS CLI to `get` that role and view the trust policy document again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The response from that command should include the trust policy you just uploaded.
  prefs: []
  type: TYPE_NORMAL
- en: The only other thing we will need to do is to save the role's ARN somewhere
    locally, so that we don't forget it. In this example, the ARN of our target role
    was `arn:aws:iam::111111111111:role/Admin`. Now everything is done.
  prefs: []
  type: TYPE_NORMAL
- en: Confirming our access
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can test our new method of persistence by trying to `assume` our target
    role from within our own attacker account. There is already a local AWS CLI profile
    named `MyPersonalUser`, which is a set of access keys that belong to my personal
    AWS account. Using those keys, I should be able to run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We only need to supply the ARN of the role we want credentials for and a role
    session name, which can be an arbitrary string value that is associated with the
    temporary credentials that are returned. If everything went as planned, the AWS
    CLI should respond with something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Perfect! Now, what we have done is use our own personal account credentials
    to retrieve credentials for our target AWS account. We can run the same `aws sts` API
    call at any time, as long as we are still a trusted entity, and retrieve another
    set of temporary credentials whenever we want.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could make these keys available to the AWS CLI by modifying our `~/.aws/credentials` file.
    The profile would just require the extra `aws_session_token` key, which would
    end up with the following being added to our credentials file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Then we could manually add those credentials into Pacu or we could import them
    from the AWS CLI to Pacu.
  prefs: []
  type: TYPE_NORMAL
- en: Automating it with Pacu
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Just like the previous section on backdooring users, this can all be easily
    automated! In addition to that, it already has been automated for you, with the
    `iam__backdoor_assume_role` Pacu module. This module accepts three different arguments,
    but we are only going to use two of them. The `--role-names` parameter accepts
    a list of IAM roles to backdoor in our target account and the `--user-arns` parameter
    takes a list of ARNs with which to add a trust relationship for each targeted
    role. If we were to replicate the scenario we just walked through, that means
    we would run the following Pacu command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Pacu will automatically backdoor the `Admin` role and create a trust relationship
    with the ARN that we supplied. The output should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7327d803-84a1-4735-b740-444466a00ed2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5: Running the Pacu iam__backdoor_assume_role module'
  prefs: []
  type: TYPE_NORMAL
- en: If we didn't know what role we wanted to target, we could omit the `--role-names` argument.
    Then Pacu would gather all roles in the account and give us a list to choose from.
  prefs: []
  type: TYPE_NORMAL
- en: A somewhat important side note here, which you may or may not have been wondering
    about, is that trust policy documents do accept wildcards such as the star (*)
    character! Trust policies can be wildcarded so that anything can assume the role,
    and that literally means anything. It is never a good idea to trust everyone with
    IAM roles, especially if you are attacking an account. You don't want to open
    doors into the environment that weren't already there where other attackers might
    be able to slide in. It is important to understand what exactly a wild-carded
    role trust policy means, though, for rare cases when you encounter one like that
    in an account.
  prefs: []
  type: TYPE_NORMAL
- en: Backdooring EC2 Security Groups
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: EC2 Security Groups act as virtual firewalls that manage inbound and outbound
    traffic rules for one or more EC2 instances. Typically, you will find that traffic
    to specific ports on an instance are white-listed to another IP range or Security
    Groups. All access is denied by default and access can be granted by creating
    new rules. As attackers, we can't bypass Security Group rules, but that doesn't
    mean that our access is completely blocked.
  prefs: []
  type: TYPE_NORMAL
- en: All we need to do is add our own Security Group rule to the target Security
    Groups. It will ideally be a rule that allows traffic from our IP address/range
    to a set of ports on the instances that the Security Group applies to. You might
    think that you want to just whitelist access for all ports (`0`-`65535`) and all
    protocols (TCP, UDP, and so on), but in general this is a bad idea because of
    some very basic detections that are out there. It is considered a bad practice
    to allow traffic to every single port in your Security Group, so there are many
    tools out there that will alert on that kind of Security Group rule.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing that detecting when all ports are allowed inbound is a typical best
    practices check, we can refine our access to a subset of common ports. These ports
    might just be a shorter range, such as `0`-`1024`, a single common port such as
    port `80`, a port of a service you know they run on your target's servers, or
    really anything you want.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using our same old `Test` user, let''s say we discovered an EC2 instance that
    we want to attack. This could be through something like just describing EC2 instances
    in the current region with the following AWS CLI command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This command returns quite a bit of information, but the important information
    is the instance ID `(i-08311909cfe8cff10`) of our target, the public IP of our
    target (`2.3.4.5`), and the list of Security Groups that are attached to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'There is a single group attached to the target instance named `corp`; we can
    guess that it stands for corporate. Now we have the name and ID of the Security
    Group, but we want to see what rules already exist on it. We can find this information
    by running the following AWS CLI command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The response from that command should display what inbound and outbound rules
    have been added to the Security Group. The `IpPermissions` key of the response
    contains the inbound traffic rules and the `IpPermissionsEgress` key contains
    the outbound traffic rules. The inbound traffic rules for our target `corp` Security
    Group are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: What we are being shown is that inbound TCP access is allowed from the IP range
    `10.0.0.1/24` to any port in the range `27017` to `27018`. Maybe you recognize
    those ports! Those ports typically belong to MongoDB, a type of NoSQL database.
    The problem is that access is whitelisted to an internal IP range, which means
    we would already need a foothold in the network to be able to access these ports.
    This is where we will add our backdoor Security Group rule so that we can access
    MongoDB directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we can use the `ec2:AuthorizeSecurityGroupIngress` API. We will
    say that our own attacker IP address is `1.1.1.1` and we already know what ports
    we want to open access to, so we can run the following AWS CLI command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: If everything went correctly, you won't see any output from this command, but
    an error will appear if something went wrong. Now that our backdoor rule has been
    successfully applied, every EC2 instance that is in the Security Group we targeted
    should now allow us access. Keep in mind that it is possible to specify `0.0.0.0/0`
    as your IP address range and it will give access to any IP address. As an attacker,
    we don't ever want to do this because it would open doors into the environment
    that other attackers might find and abuse, so we always want to make sure that
    even our backdoor access rules are fine-grained.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can attempt to access MongoDB remotely to test if our backdoor rule
    was successful and hopefully gain access to a previously private MongoDB server.
    The following screenshot shows us connecting to the Mongo database on port `27017`,
    where a couple of misconfigurations of the server work to our benefit. As can
    be seen in the outlined section of the screenshot, access control (authentication)
    is not set up, which means we can read and write to the database without credentials
    being required. The next message shows that the Mongo process is running as root,
    which means that if we were able to perform any kind of file read or code execution
    on the Mongo server, it would be run as the root user:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a765957b-d8e1-44fc-afe1-98fc2732d516.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Again, just like the previous sections, this can be, and already has been,
    automated for you with Pacu! We can target one or more Security Groups, but by
    default, Pacu will backdoor all the groups in the current region with the rule
    that you specify. To replicate the process we just went through, we could run
    the following Pacu command (Pacu uses the Security Group name instead of the ID,
    so we supply `corp` instead):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Then Pacu will add our backdoor rule to the target Security Group. Don''t ever
    forget the `--ip` argument though, because you don''t want to open anything up
    to the World (`0.0.0.0/0`). The following screenshot shows the output of the preceding
    Pacu command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8bbbbcd4-3706-4055-8fa5-69ef058fd30d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6: The output from Pacu when backdooring the corp Security Group'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then if you were to view the rules applied to that Security Group in the AWS
    web console, you would see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9022b74d-78b2-4d7d-b26f-2d16f23e40a1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7: A backdoor rule on our target Security Group'
  prefs: []
  type: TYPE_NORMAL
- en: Using Lambda functions as persistent watchdogs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, creating our persistent backdoors in an account is extremely useful, but
    what if even those get detected and removed from the environment? We can use AWS
    Lambda as a watchdog to monitor activity in the account and to run commands in
    response to certain events, allowing us to react to a defender's actions.
  prefs: []
  type: TYPE_NORMAL
- en: Basically, AWS Lambda is how you run serverless code in AWS. In simple terms,
    you upload your code (whether that is Node.js, Python, or whatever) and set up
    a trigger for your function so that, when that trigger is hit, your code executes
    in the cloud and does something with the incoming data.
  prefs: []
  type: TYPE_NORMAL
- en: 'We attackers can use this to our advantage in many ways. We can use it to alert
    on activity in the account:'
  prefs: []
  type: TYPE_NORMAL
- en: The activity may help us to exploit the account
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It might mean we have been detected by a defender
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are many more things you can do with Lambda functions, but this is what
    we will focus on for now.
  prefs: []
  type: TYPE_NORMAL
- en: Automating credential exfiltration with Lambda
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Starting with the first point in the previous section, we want a Lambda function
    to trigger on an event that might be worthy of exploiting. We will tie this into
    our methods of persistence described earlier in this chapter, so for backdooring
    IAM users, the event that might be worthy of exploiting might be when a new user
    is created. We could trigger our Lambda function with that event (with CloudWatch
    Events), which then runs our code that is set up to automatically add a new set
    of access keys to that user, then exfiltrates those credentials to a server we
    specified.
  prefs: []
  type: TYPE_NORMAL
- en: 'This scenario ties together like this:'
  prefs: []
  type: TYPE_NORMAL
- en: The attacker (us) creates a malicious Lambda function in a target account
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The attacker creates a trigger to run the Lambda function every time a new IAM
    user is created
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The attacker sets up a listener on a server that they control, which will wait
    for credentials
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 2 days pass
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A regular user in the environment creates a new IAM user
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The attacker's Lambda function is triggered
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The function adds a set of access keys to the newly created user
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The function makes an HTTP request to the attacker's server with the credentials
    that were created
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now the attacker just sits back and waits for credentials to flow in to their
    server.
  prefs: []
  type: TYPE_NORMAL
- en: It may seem like a complicated process, but in the simplest terms, you can think
    of it as a persistent method of establishing persistence. We already understand
    how to establish persistence in the first place, so all Lambda adds to the equation
    is the ability to do it continuously.
  prefs: []
  type: TYPE_NORMAL
- en: For a function to trigger an event, such as a user being created, a CloudWatch
    Event rule must be created. A CloudWatch Event rule is a way to basically say—perform
    this action if I see this happen in the environment. For our CloudWatch Event
    rule to work correctly, we also need CloudTrail logging enabled in the `us-east-1`
    region. This is because we are triggered by an IAM event (`iam:CreateUser`), and
    IAM events are only delivered to `us-east-1` CloudWatch Events. In most situations,
    CloudTrail logging will be enabled. It is best practice to enable it across all
    AWS regions, and if CloudTrail isn't enabled, then you are likely in a less-polished
    environment where there are other problems to focus on.
  prefs: []
  type: TYPE_NORMAL
- en: Using Pacu for the deployment of our backdoor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The process of creating the backdoor Lambda function, creating the CloudWatch
    Events rule, and connecting the two would be annoying to do manually every time,
    so that has been automated and integrated into Pacu for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first Pacu module we will look at is called `lambda__backdoor_new_users`,
    and it basically just automates the process of creating a Lambda backdoor that
    backdoors and exfiltrates credentials for newly created users in the environment.
    If we look at the source code of the Lambda function that the Pacu module uses,
    we see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: All the code does is check whether the event that triggered it was an `iam:CreateUser`
    API call, and if so, it will try to use the Python `boto3` library to create credentials
    for that newly created user. Then once that is successful, it will send those
    credentials to the attacker's server, which is indicated by `POST_URL` (Pacu replaces
    that string prior to launching the function).
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the module's code sets up all the required resources *or* deletes
    any backdoors that it knows you launched into the account, sort of like a clean-up
    mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'To receive the credentials that we are creating, we need to start an HTTP listener
    on our own server, as the credentials are `POSTed` in the body. After that, we
    can just run the following Pacu command and hope for credentials to start pouring
    in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: When that Pacu command finishes, the target account should have our Lambda backdoor
    set up now. As soon as someone else in the environment creates a new IAM user,
    we should receive a request back to our HTTP listener with those credentials.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows some of the output from running the `lambda__backdoor_new_users` Pacu
    module:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/482885c6-1634-4167-bc6a-5b3a6127c6c0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, the next screenshot shows the credentials that were POSTed to our HTTP
    server after someone created a user in our target environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fc4f4128-1065-4292-b803-1dd997d58bcf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can see the access key ID and secret access key both were included in the
    body of this HTTP POST request. Now that we have collected keys for a user, we
    could remove our backdoor if we felt that was necessary (you shouldn''t leave
    anything leftover in an environment you are testing against!). To do this, we
    can run the following Pacu command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This command should output something like the following screenshot, which indicates
    it removed the backdoor resources that we previously created:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e7c1f06d-0048-4c4b-9ae4-753254afac30.png)'
  prefs: []
  type: TYPE_IMG
- en: Other Lambda Pacu modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In addition to the `lambda__backdoor_new_users` Pacu module, there are also
    two others:'
  prefs: []
  type: TYPE_NORMAL
- en: '`lambda__backdoor_new_sec_groups`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lambda__backdoor_new_roles`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `lambda__backdoor_new_sec_groups` module can be used to backdoor new EC2
    Security Groups as they are created by white-listing our own IP address, and the `lambda__backdoor_new_roles` module
    will modify the trust relationship of newly created roles to allow us to assume
    them cross-account, then it will exfiltrate the ARN of the role so we can go ahead
    and collect our temporary credentials. Both these modules work like the `lambda__backdoor_new_users` module
    we covered previously in that they deploy resources into the AWS account that
    trigger on the basis of events, and they have clean-up options to remove those
    resources.
  prefs: []
  type: TYPE_NORMAL
- en: The `lambda__backdoor_new_sec_groups` modules uses the EC2 APIs (rather than
    IAM), so it is not necessary for the Lambda function to be created in `us-east-1`; instead
    it should be launched into the region that you would like to backdoor new Security
    Groups in.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have looked at how we can establish a means of persistent
    access to a target AWS environment. This can be done directly, as we have shown
    with something like adding backdoor keys to other IAM users, or we can use more
    long-term methods with services such as AWS Lambda and CloudWatch Events. There
    are many different ways you can establish some kind of persistence in a target
    AWS account, but sometimes it can just take a little research on the target to
    determine where might be a good location.
  prefs: []
  type: TYPE_NORMAL
- en: Lambda provides a very flexible platform from which to react and respond to
    events within our target account, meaning we can establish persistence (or more)
    as resources are created; however just like we have shown by backdooring EC2 Security
    Groups, not every backdoor needs to be based on/within the IAM service and can
    sometimes be a backdoor for alternate kinds of access. This chapter setout to
    show some common methods of persistence in a way that can help you discover other
    methods of persistence in your engagements.
  prefs: []
  type: TYPE_NORMAL
- en: Rather than creating new resources in an account, which may be quite noisy to
    someone paying attention, it is also possible to backdoor existing Lambda functions.
    These attacks are a little bit more specific to the environment you are targeting
    and require a different set of privileges, but can be much stealthier and longer-lasting.
    These methods will be discussed in the next chapter, where we will discuss pentesting
    AWS Lambda, investigate backdoors and data exfiltration from existing Lambda functions,
    and more.
  prefs: []
  type: TYPE_NORMAL
