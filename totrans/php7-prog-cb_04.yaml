- en: Chapter 4. Working with PHP Object-Oriented Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Developing classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extending classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using static properties and methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using namespaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining visibility
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using traits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing anonymous classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will consider recipes that take advantage of the **object-oriented
    programming** (**OOP**) capabilities available in PHP 7.0, 7.1, and above. Most
    of the OOP functionality available in PHP 7.x is also available in PHP 5.6\. A
    new feature introduced in PHP 7 is support for **anonymous classes**. In PHP 7.1,
    you can modify the visibility of class constants.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another radically new feature is the ability to **catch** certain types of error.
    This is discussed in greater detail in [Chapter 13](ch13.html "Chapter 13. Best
    Practices, Testing, and Debugging"), *Best Practices, Testing, and Debugging*.
  prefs: []
  type: TYPE_NORMAL
- en: Developing classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The traditional development approach is to place the class into its own file.
    Typically, classes contain logic that implements a single purpose. Classes are
    further broken down into self-contained functions which are referred to as **methods**.
    Variables defined inside classes are referred to as **properties**. It is recommended
    to develop a test class at the same time, a topic discussed in more detail in
    [Chapter 13](ch13.html "Chapter 13. Best Practices, Testing, and Debugging"),
    *Best Practices, Testing, and Debugging*.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a file to contain the class definition. For the purposes of autoloading
    it is recommended that the filename match the classname. At the top of the file,
    before the keyword `class`, add a **DocBlock**. You can then define properties
    and methods. In this example, we define a class `Test`. It has a property `$test`,
    and a method `getTest()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Best practice**'
  prefs: []
  type: TYPE_NORMAL
- en: It is considered best practice to name the file after the class. Although class
    names in PHP are not case sensitive, it is further considered best practice to
    use an uppercase letter for the first name of a class. You should not put executable
    code in a class definition file.
  prefs: []
  type: TYPE_NORMAL
- en: Each class should contain a **DocBlock** before the keyword `class`. In the
    DocBlock you should include a short description of the purpose of the class. Skip
    a line, and then include a more detailed description. You can also include `@`
    tags such as `@author`, `@license` and so on. Each method should likewise be preceded
    by a DocBlock that identifies the purpose of the method, as well as its incoming
    parameters and return value.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s possible to define more than one class per file, but is not considered
    best practice. In this example we create a file, `NameAddress.php`, which defines
    two classes, `Name` and `Address`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although you can define more than one class in a single file, as shown in the
    preceding code snippet, it is not considered best practice. Not only does this
    negate the logical purity of the file, but it makes autoloading more difficult.
  prefs: []
  type: TYPE_NORMAL
- en: 'Class names are case-insensitive. Duplications will be flagged as errors. In
    this example, in a file `TwoClass.php`, we define two classes, `TwoClass` and
    `twoclass`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'PHP 7.1 has addressed inconsistent behavior in the use of the keyword `$this`.
    Although permitted in PHP 7.0 and PHP 5.x, any of the following uses of `$this`
    will now generate an error as of PHP 7.1, if `$this` is used as:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A parameter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `static` variable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `global` variable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A variable used in `try...catch` blocks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A variable used in `foreach()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As an argument to `unset()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a variable (that is, `$a = 'this'; echo $$a`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Indirectly via reference
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you need to create an object instance but don''t care to define a discreet
    class, you can use the generic `stdClass` which is built into PHP. `stdClass`
    allows you to define properties *on the fly* without having to define a discreet
    class that extends `stdClass`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This facility is used in a number of different places in PHP. As an example,
    when you use **PHP Data Objects** (**PDO**) to do a database query, one of the
    fetch modes is `PDO::FETCH_OBJ`. This mode returns instances of `stdClass` where
    the properties represent database table columns:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Take the example for the `Test` class shown in the preceding code snippet,
    and place the code in a file named `Test.php`. Create another file called `chap_04_oop_defining_class_test.php`.
    Add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will show the initial value of the `$test` property, followed by
    the new value modified by calling `setTest()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The next example has you define two classes, `Name` and `Address` in a single
    file `NameAddress.php`. You can call and use these two classes with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although no errors are generated by the PHP interpreter, by defining multiple
    classes, the logical purity of the file is compromised. Also, the filename doesn't
    match the classname, which could impact the ability to autoload.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output from this example is shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Step 3 also shows two class definitions in one file. In this case, however,
    the objective is to demonstrate that classnames in PHP are case-insensitive. Place
    the code into a file, `TwoClass.php`. When you try to include the file, an error
    is generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To demonstrate the direct use of `stdClass`, create an instance, assign a value
    to a property, and use `var_dump()`to display the results. To see how `stdClass`
    is used internally, use `var_dump()` to display the results of a `PDO` query where
    the fetch mode is set to `FETCH_OBJ`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: See also...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For more information on refinements in PHP 7.1 on the keyword `$this`, please
    see [https://wiki.php.net/rfc/this_var](https://wiki.php.net/rfc/this_var).
  prefs: []
  type: TYPE_NORMAL
- en: Extending classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the primary reasons developers use OOP is because of its ability to re-use
    existing code, yet, at the same time, add or override functionality. In PHP, the
    keyword `extends` is used to establish a parent/child relationship between classes.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the `child` class, use the keyword `extends` to set up inheritance. In the
    example that follows, the `Customer` class extends the `Base` class. Any instance
    of `Customer` will inherit visible methods and properties, in this case, `$id`,
    `getId()` and `setId()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'You can force any developer using your class to define a method by marking
    it `abstract`. In this example, the `Base` class defines as `abstract` the `validate()`
    method. The reason why it must be abstract is because it would be impossible to
    determine exactly how a child class would be validated from the perspective of
    the parent `Base` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If a class contains an **abstract method**, the class itself must be declared
    as `abstract`.
  prefs: []
  type: TYPE_NORMAL
- en: 'PHP only supports a single line of inheritance. The next example shows a class,
    `Member`, which inherits from `Customer`. `Customer`, in turn, inherits from `Base`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'To satisfy a type-hint, any child of the target class can be used. The `test()`
    function, shown in the following code snippet, requires an instance of the `Base`
    class as an argument. Any class within the line of inheritance can be accepted
    as an argument. Anything else passed to `test()` throws a `TypeError`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the first bullet point, a `Base` class and a `Customer` class were defined.
    For the sake of demonstration, place these two class definitions in a single file,
    `chap_04_oop_extends.php`, and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the `$id` property and the `getId()` and `setId()` methods are inherited
    from the parent `Base` class into the child `Customer` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_04_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To illustrate the use of an `abstract` method, imagine that you wish to add
    some sort of validation capability to any class that extends `Base`. The problem
    is that there is no way to know what might be validated in the inherited classes.
    The only thing that is certain is that you must have a validation capability.
  prefs: []
  type: TYPE_NORMAL
- en: Take the same `Base` class mentioned in the preceding explanation and add a
    new method, `validate()`. Label the method as `abstract`, and do not define any
    code. Notice what happens when the child `Customer` class extends `Base`.
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_04_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you then label the `Base` class as `abstract`, but fail to define a `validate()`
    method in the child class, the *same error* will be generated. Finally, go ahead
    and implement the `validate()` method in a child `Customer` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then add the following procedural code to test the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_04_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To show a single line of inheritance, add a new `Member` class to the first
    example of `Base` and `Customer` shown in the preceding step 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an instance of `Member`, and notice, in the following code, that all
    properties and methods are available from every inherited class, even if not directly
    inherited:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_04_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now define a function, `test()`, which takes an instance of `Base` as an argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that instances of `Base`, `Customer`, and `Member` are all acceptable
    as arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_04_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'However, if you try to run `test()` with an object instance that is not in
    the line of inheritance, a `TypeError` is thrown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We can observe this in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_04_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Using static properties and methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PHP lets you access properties or methods without having to create an instance
    of the class. The keyword used for this purpose is **static**.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At its simplest, simply add the `static` keyword after stating the visibility
    level when declaring an ordinary property or method. Use the `self` keyword to
    reference the property internally:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `self` keyword will bind early, which will cause problems when accessing
    static information in child classes. If you absolutely need to access information
    from the child class, use the `static` keyword in place of `self`. This process
    is referred to as **Late Static Binding**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the following example, if you echo `Child::getEarlyTest()`, the output will
    be **TEST**. If, on the other hand, you run `Child::getLateTest()`, the output
    will be **CHILD**. The reason is that PHP will bind to the *earliest* definition
    when using `self`, whereas the *latest* binding is used for the `static` keyword:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In many cases, the **Factory** design pattern is used in conjunction with static
    methods to produce instances of objects given different parameters. In this example,
    a static method `factory()` is defined which returns a PDO connection:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can reference static properties and methods using the **class resolution
    operator** "`::"`. Given the `Test` class shown previously, if you run this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_04_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To illustrate Late Static Binding, based on the classes `Test2` and `Child`
    shown previously, try this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The output illustrates the difference between `self` and `static`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_04_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, to test the `factory()` method shown previously, save the code into
    the `Application\Database\Connection` class in a `Connection.php` file in the
    `Application\Database` folder. You can then try this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see a list of countries pulled from the sample database:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_04_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For more information on Late Static Binding, see this explanation in the PHP
    documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://php.net/manual/en/language.oop5.late-static-bindings.php](http://php.net/manual/en/language.oop5.late-static-bindings.php)'
  prefs: []
  type: TYPE_NORMAL
- en: Using namespaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An aspect that is critical to advanced PHP development is the use of namespaces.
    The arbitrarily defined namespace becomes a prefix to the class name, thereby
    avoiding the problem of accidental class duplication, and allowing you extraordinary
    freedom of development. Another benefit to the use of a namespace, assuming it
    matches the directory structure, is that it facilitates autoloading, as discussed
    in [Chapter 1](ch01.html "Chapter 1. Building a Foundation"), *Building a Foundation*.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To define a class within a namespace, simply add the keyword `namespace` at
    the top of the code file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Best practice**'
  prefs: []
  type: TYPE_NORMAL
- en: As with the recommendation to have only one class per file, likewise you should
    have only one namespace per file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The only PHP code that should precede the keyword `namespace` would be a comment
    and/or the keyword `declare`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'In PHP 5, if you needed to access a class in an external namespace you could
    prepend a `use` statement containing only the namespace. You would need to then
    prefix any class reference within this namespace with the last component of the
    namespace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you could distinctly specify all three classes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'PHP 7 has introduced a syntactical improvement referred to as **group use**
    which greatly improves code readability:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'As mentioned in [Chapter 1](ch01.html "Chapter 1. Building a Foundation"),
    *Building a Foundation*, namespaces form an integral part of the **autoloading**
    process. This example shows a demonstration autoloader which echoes the argument
    passed, and then attempts to include a file based on the namespace and class name.
    This assumes that the directory structure matches the namespace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For illustration purposes, define a directory structure that matches the `Application\*`
    namespace. Create a base folder `Application`, and a sub-folder `Entity`. You
    can also include any sub-folders as desired, such as `Database` and `Generic`,
    used in other chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_04_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, create three `entity` classes, each in their own file, under the `Application/Entity`
    folder: `Name.php`, `Address.php`, and `Profile.php`. We only show `Application\Entity\Name`
    here. `Application\Entity\Address` and `Application\Entity\Profile` will be the
    same, except that `Address` has an `$address` property, and `Profile` has a `$profile`
    property, each with an appropriate `get` and `set` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then either use the autoloader defined in [Chapter 1](ch01.html "Chapter 1. Building
    a Foundation"), *Building a Foundation*, or use the simple autoloader mentioned
    previously. Place the commands to set up autoloading in a file, `chap_04_oop_namespace_example_1.php`.
    In this file, you can then specify a use statement which only references the namespace,
    not the class names. Create instances of the three entity classes `Name`, `Address`
    and `Profile`, by prefixing the class name with the last part of the namespace,
    `Entity`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_04_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, use **Save as** to copy the file to a new one named `chap_04_oop_namespace_example_2.php`.
    Change the `use` statement to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now create class instances using only the class name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run this script, here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_04_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, again run **Save as** and create a new file, `chap_04_oop_namespace_example_3.php`.
    You can now test the **group use** feature introduced in PHP 7:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, when you run this block of code, the output will be the same as the
    preceding output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_04_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Defining visibility
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Deceptively, the word *visibility* has nothing to do with application security!
    Instead it is simply a mechanism to control the use of your code. It can be used
    to steer an inexperienced developer away from the *public* use of methods that
    should only be called inside the class definition.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Indicate the visibility level by prepending the `public`, `protected`, or `private`
    keyword in front of any property or method definition. You can label properties
    as `protected` or `private` to enforce access only through public `getters` and
    `setters`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this example, a `Base` class is defined with a protected property `$id`.
    In order to access this property, the `getId()` and `setId()` public methods are
    defined. The protected method `generateRandId()` can be used internally, and is
    inherited in the `Customer` child class. This method cannot be called directly
    outside of class definitions. Note the use of the new PHP 7 `random_bytes()` function
    to create a random ID.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Best practice**'
  prefs: []
  type: TYPE_NORMAL
- en: Mark properties as `protected`, and define the `publicgetNameOfProperty()` and
    `setNameOfProperty()` methods to control access to the property. Such methods
    are referred to as `getters` and `setters`.
  prefs: []
  type: TYPE_NORMAL
- en: Mark a property or method as `private` to prevent it from being inherited or
    visible from *outside* the class definition. This is a good way to create a class
    as a **singleton**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The next code example shows a class `Registry`, of which there can only be
    one instance. Because the constructor is marked as `private`, the only way an
    instance can be created is through the static method `getInstance()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can mark a method as `final` to prevent it from being overridden. Mark a
    class as `final` to prevent it from being extended.
  prefs: []
  type: TYPE_NORMAL
- en: 'Normally, class constants are considered to have a visibility level of `public`.
    As of PHP 7.1, you can declare class constants to be `protected` or `private`.
    In the following example, the `TEST_WHOLE_WORLD` class constant behaves exactly
    as in PHP 5\. The next two constants, `TEST_INHERITED` and `TEST_LOCAL`, follow
    the same rules as any `protected` or `private` property or method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a file `chap_04_basic_visibility.php` and define two classes: `Base`
    and `Customer`. Next, write code to create instances of each:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that the following code works OK, and is in fact considered the best
    practice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Even though `$id` is `protected`, the corresponding methods, `getId()` and
    `setId()`, are both `public`, and therefore accessible from outside the class
    definition. Here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_04_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following lines of code will not work, however, as `private` and `protected`
    properties are not accessible from outside the class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The following output shows the expected errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_04_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For more information on `getters` and `setters`, see the recipe in this chapter
    entitled *Using getters and setters*. For more information on PHP 7.1 class constant
    visibility settings, please see [https://wiki.php.net/rfc/class_const_visibility](https://wiki.php.net/rfc/class_const_visibility).
  prefs: []
  type: TYPE_NORMAL
- en: Using interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Interfaces are useful tools for systems architects and are often used to prototype
    an **Application Programming Interface** (**API**). Interfaces don't contain actual
    code, but can contain names of methods as well as method signatures.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All methods identified in the `Interface` have a visibility level of `public`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Methods identified by the interface cannot contain actual code implementations.
    You can, however, specify the data types of method arguments.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In this example, `ConnectionAwareInterface` identifies a method, `setConnection()`,
    which requires an instance of `Connection` as an argument:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'To use the interface, add the keyword `implements` after the open line that
    defines the class. We have defined two classes, `CountryList` and `CustomerList`,
    both of which require access to the `Connection` class via a method, `setConnection()`.
    In order to identify this dependency, both classes implement `ConnectionAwareInterface`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Interfaces can be used to satisfy a type hint. The following class, `ListFactory`,
    contains a `factory()` method, which initializes any class that implements `ConnectionAwareInterface`.
    The interface is a guarantee that the `setConnection()` method is defined. Setting
    the type hint to the interface instead of a specific class instance makes the
    `factory` method more generically useful:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'If a class implements multiple interfaces, a **naming collision** occurs if
    method signatures do not match. In this example, there are two interfaces, `DateAware`
    and `TimeAware`. In addition to defining the `setDate()` and `setTime()` methods,
    they both define `setBoth()`. Having duplicate method names is not an issue, although
    it is not considered best practice. The problem lies in the fact that the method
    signatures differ:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: As the code block stands, a fatal error will be generated (which cannot be caught!).
    To resolve the problem, the preferred approach would be to remove the definition
    of `setBoth()` from one or the other interface. Alternatively, you could adjust
    the method signatures to match.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Best practice**'
  prefs: []
  type: TYPE_NORMAL
- en: Do not define interfaces with duplicate or overlapping method definitions.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the `Application/Database` folder, create a file, `ConnectionAwareInterface.php`.
    Insert the code discussed in the preceding step 2.
  prefs: []
  type: TYPE_NORMAL
- en: Next, in the `Application/Generic` folder, create two files, `CountryList.php`
    and `CustomerList.php`. Insert the code discussed in step 3.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, in a directory parallel to the `Application` directory, create a source
    code file, `chap_04_oop_simple_interfaces_example.php`, which initializes the
    autoloader and includes the database parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The database parameters in this example are assumed to be in a database configuration
    file indicated by the `DB_CONFIG_FILE` constant.
  prefs: []
  type: TYPE_NORMAL
- en: 'You are now in a position to use `ListFactory::factory()` to generate `CountryList`
    and `CustomerList` objects. Note that if these classes did not implement `ConnectionAwareInterface`,
    an error would be thrown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output for country list:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_04_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can also use the `factory` method to generate a `CustomerList` object and
    use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output for `CustomerList`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_04_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you want to examine what happens when multiple interfaces are implemented,
    but where the method signature differs, enter the code shown in the preceding
    step 4 into a file, `chap_04_oop_interfaces_collisions.php`. When you try to run
    the file, an error is generated, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_04_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you make the following adjustment in the `TimeAware` interface, no errors
    will result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Using traits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have ever done any C programming, you are perhaps familiar with macros.
    A macro is a predefined block of code that *expands* at the line indicated. In
    a similar manner, traits can contain blocks of code that are copied and pasted
    into a class at the line indicated by the PHP interpreter.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Traits are identified with the keyword `trait`, and can contain properties and/or
    methods. You may have noticed duplication of code when examining the previous
    recipe featuring the `CountryList` and `CustomerList` classes. In this example,
    we will re-factor the two classes, and move the functionality of the `list()`
    method into a `Trait`. Notice that the `list()` method is the same in both classes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Traits are used in situations where there is duplication of code between classes.
    Please note, however, that the conventional approach to creating an abstract class
    and extending it might have certain advantages over using traits. Traits cannot
    be used to identify a line of inheritance, whereas abstract parent classes can
    be used for this purpose.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will now copy `list()` into a trait called `ListTrait`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then insert the code from `ListTrait` into a new class, `CountryListUsingTrait`,
    as shown in the following code snippet. The entire `list()` method can now be
    removed from this class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Any time you have duplication of code, a potential problem arises when you need
    to make a change. You might find yourself having to do too many global search
    and replace operations, or cutting and pasting of code, often with disastrous
    results. Traits are a great way to avoid this maintenance nightmare.
  prefs: []
  type: TYPE_NORMAL
- en: 'Traits are affected by namespaces. In the example shown in step 1, if our new
    `CountryListUsingTrait` class is placed into a namespace, `Application\Generic`,
    we will also need to move `ListTrait` into that namespace as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Methods in traits override inherited methods.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the following example, you will notice that the return value for the `setId()`
    method differs between the `Base` parent class and the `Test` trait. The `Customer`
    class inherits from `Base`, but also uses `Test`. In this case, the method defined
    in the trait will override the method defined in the `Base` parent class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In PHP 5, traits could also override properties. In PHP 7, if the property in
    a trait is initialized to a different value than in the parent class, a fatal
    error is generated.
  prefs: []
  type: TYPE_NORMAL
- en: Methods directly defined in the class that use the trait override duplicate
    methods defined in the trait.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In this example, the `Test` trait defines a property `$id` along with the `getId()`
    methods and `setId()`. The trait also defines `setName()`, which conflicts with
    the same method defined in the `Customer` class. In this case, the directly defined
    `setName()` method from `Customer` will override the `setName()` defined in the
    trait:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Use the `insteadof` keywords to resolve method name conflicts when using multiple
    traits. In conjunction, use the `as` keyword to alias method names.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In this example, there are two traits, `IdTrait` and `NameTrait`. Both traits
    define a `setKey()` method, but express the key in different ways. The `Test`
    class uses both traits. Note the `insteadof` keyword, which allows us to distinguish
    between the conflicting methods. Thus, when `setKey()` is called from the `Test`
    class, the source will be drawn from `NameTrait`. In addition, `setKey()` from
    `IdTrait` will still be available, but under an alias, `setKeyDate()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: From step 1, you learned that traits are used in situations where there is duplication
    of code. You need to gauge whether or not you could simply define a base class
    and extend it, or whether using a trait better serves your purposes. Traits are
    especially useful where the duplication of code is seen in logically unrelated
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate how trait methods override inherited methods, copy the block
    of code mentioned in step 7 into a separate file, `chap_04_oop_traits_override_inherited.php`.
    Add these lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from the output (shown next), the property `$id` is stored as
    an instance of `stdClass()`, which is the behavior defined in the trait:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_04_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To illustrate how directly defined class methods override trait methods, copy
    the block of code mentioned in step 9 into a separate file, `chap_04_oop_trait_methods_do_not_override_class_methods.php`.
    Add these lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from the following output, the `$id` property is stored as an
    integer, as defined in the `Customer` class, whereas the trait defines `$id` as
    an instance of `stdClass`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_04_29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In step 10, you learned how to resolve duplicate method name conflicts when
    using multiple traits. Copy the block of code shown in step 11 into a separate
    file, `chap_04_oop_trait_multiple.php`. Add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice in the following output that `setKey()` yields the output produced from
    the new PHP 7 function, `random_bytes()` (defined in `NameTrait`), whereas `setKeyDate()`
    produces a key using the `date()` and `rand()` functions (defined in `IdTrait`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_04_30.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Implementing anonymous classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PHP 7 introduced a new feature, **anonymous classes**. Much like anonymous functions,
    anonymous classes can be defined as part of an expression, creating a class that
    has no name. Anonymous classes are used in situations where you need to create
    an object *on the fly*, which is used and then discarded.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An alternative to `stdClass` is to define an anonymous class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the definition, you can define any properties and methods (including magic
    methods). In this example, we define an anonymous class with two properties and
    a magic method, `__construct()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: An anonymous class can extend any class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In this example, an anonymous class extends `FilterIterator`, and overrides
    both the `__construct()` and `accept()` methods. As an argument, it accepts `ArrayIterator`
    `$b`, which represents an array of 10 to 100 in increments of 10\. The second
    argument serves as a limit on the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: An anonymous class can implement an interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In this example, an anonymous class is used to generate an HTML color code
    chart. The class implements the built-in PHP `Countable` interface. A `count()`
    method is defined, which is called when this class is used with a method or function
    that requires `Countable`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Anonymous classes can use traits.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This last example is a modification from the preceding one defined immediately.
    Instead of defining a class `Test`, we define an anonymous class instead:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In an anonymous class you can define any properties or methods. Using the preceding
    example, you could define an anonymous class that accepts constructor arguments,
    and where you can access properties. Place the code described in step 2 into a
    test script `chap_04_oop_anonymous_class.php`. Add these `echo` statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output from the anonymous class:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In order to use `FilterIterator` you *must* override the `accept()` method.
    In this method, you define criteria for which elements of the iteration are to
    be included as output. Go ahead now and add the code shown in step 4 to the test
    script. You can then add these `echo` statements to test the anonymous class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, a limit of 50 is established. The original `ArrayIterator`
    contains an array of values, 10 to 100, in increments of 10, as seen in the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_04_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To have a look at an anonymous class that implements an interface, consider
    the example shown in steps 5 and 6\. Place this code in a file, `chap_04_oop_anonymous_class_interfaces.php`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add code that lets you paginate through the HTML color chart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, go ahead and present the HTML color chart as a web page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that you can take advantage of the `Countable` interface by passing
    the instance of the anonymous class into the `count()` function (shown between
    `<H1>` tags). Here is the output shown in a browser window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_04_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Lastly, to illustrate the use of traits in anonymous classes, copy the `chap_04_oop_trait_multiple.php`
    file mentioned in the previous recipe to a new file, `chap_04_oop_trait_anonymous_class.php`.
    Remove the definition of the `Test` class, and replace it with an anonymous class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Remove this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run the code, you will see exactly the same output as shown in the
    preceding screenshot, except that the class reference will be anonymous:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_04_31.jpg)'
  prefs: []
  type: TYPE_IMG
