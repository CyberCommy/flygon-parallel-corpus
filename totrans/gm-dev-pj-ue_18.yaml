- en: 18\. Gameplay Framework Classes in Multiplayer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn where the instances of the gameplay framework
    classes exist in multiplayer. You'll also learn how to use the game state and
    player state classes, as well as some new concepts in the game mode, including
    match states. We'll also cover some useful built-in functionality that can be
    used in different types of games.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you'll be able to use the game state and player
    state classes to store information about the game and about specific players that
    can be accessed by any client. You'll also know how to make the most of the game
    mode class and other related functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we covered *Remote Procedure Calls*, which allow the
    server and the clients to execute remote functions on each other. We also covered
    enumerations and *Bi-Directional Circular Array Indexing*.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we're going to take a look at the most common gameplay framework
    classes and see where their instances exist in a multiplayer environment. This
    is important to understand, so you know which instances can be accessed in a specific
    game instance. An example of this would be that only the server should be able
    to access the game mode instance, so if you were playing Fortnite, a player shouldn't
    be able to access it and modify the rules of the game.
  prefs: []
  type: TYPE_NORMAL
- en: We'll also be covering the game state and player state classes in this chapter.
    As the name implies, these store information about the state of the game and of
    each player that is playing the game. Finally, toward the end of this book, we'll
    cover some new concepts in the game mode, as well as some useful built-in functionality.
  prefs: []
  type: TYPE_NORMAL
- en: We will begin with how gameplay framework classes work in multiplayer.
  prefs: []
  type: TYPE_NORMAL
- en: Gameplay Framework Classes in Multiplayer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Unreal Engine 4 comes with a gameplay framework, which is a set of classes
    that allow you to create games more easily. The gameplay framework does this by
    providing built-in common functionality that is present in most games, such as
    a way to define the game rules (game mode), and a way to control a character (the
    player controller and pawn/character class). When an instance of a gameplay framework
    class is created in a multiplayer environment, it can exist on the server, on
    the clients, and on the owning client, which is the client that has its player
    controller as the owner of that instance. This means that the instances of the
    gameplay framework classes will always fall into one of the following categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Server Only**: The instances of the class will only exist on the server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Server and Clients**: The instances of the class will exist on the server
    and the clients.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Server and Owning Client**: The instances of the class will exist on the
    server and on the owning client.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Owning Client Only**: The instances of the class will only exist on the owning client.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Take a look at the following diagram, which shows each category and the purpose
    of the most common classes on the gameplay framework:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 18.1: The most common gameplay framework classes divided into categories'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_18_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 18.1: The most common gameplay framework classes divided into categories'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go into a bit more detail on each class in the preceding diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Game Mode (Server Only)**: The game mode class defines the rules of the game
    and its instance can only be accessed by the server. If a client tries to access
    it, the instance will always be invalid, in order to prevent clients from changing
    the game rules.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Game State (Server and Clients)**: The game state class stores the state
    of the game and its instance can be accessed both by the server and the clients.
    The game state will be covered in greater depth in a future topic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Player State (Server and Clients)**: The player state class stores the state
    of a player and its instance can be accessed both by the server and the clients.
    The player state will be covered in greater depth in a future topic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pawn (Server and Clients)**: The pawn class is the visual representation
    of a player and its instance can be accessed by the server and the clients.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UGameplayStatics::GetPlayerController` function with an index other than `0`
    (which would return its player controller), the returned instance will always
    be invalid. This means that the server is the only place that has access to all
    of the player controllers. You can find out whether a player controller instance
    is in its owning client by calling the `AController::IsLocalController` function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**HUD (Owning Client Only)**: The HUD class is used as an immediate mode to
    draw basic shapes and text on the screen. Since it''s used for UI, its instance
    is only available on the owning client, because the server and the other clients
    don''t need to know about it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**UMG Widgets (Owning Client Only)**: The UMG widget classes are used to display
    complex UI on the screen. Since it''s used for UI, its instance is only available
    on the owning client, because the server and the other clients don''t need to
    know about it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To help you understand these concepts, we can use Dota 2 as an example. The
    game mode defines that there are different phases of the game (*pre-game for hero
    picking, the actual game, and the post-game with the winner*) and that the end
    goal is to destroy the other team''s ancient. Since it''s a class that is critical
    to gameplay, clients can''t be allowed to access it:'
  prefs: []
  type: TYPE_NORMAL
- en: The game state stores the elapsed time, whether it's day or night, the score
    of each team, and so on, so the server and the clients need to be able to access
    it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The player state stores the name, the hero selected, and the kill/death/assist
    ratio of a player, so the server and the clients need to be able to access it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The pawn would be the hero, the courier, the illusions, and so on, controlled
    by the player, so the server and the clients need to be able to access it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The player controller is what relays the input information to the controlled
    pawn, so only the server and the owning client need to be able to access it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The UI classes (`HUD` and `User` widget) would display all of the information
    on the owning client, so it only needs to be accessed there.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next exercise, you will be displaying the instance values of the most
    common gameplay framework classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 18.01: Displaying the Gameplay Framework Instance Values'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we''re going to create a new C++ project that uses the Third
    Person template, and we''re going to add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: On the owning client, the player controller creates and adds to the viewport
    a simple UMG widget that displays the name of the menu instance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the tick function, the character displays the value of its own instance (as
    a pawn) as well as whether it has a valid instance for the game mode, game state,
    player state, player controller, and HUD.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If needed, you can refer back to *Chapter 1*, *Unreal Engine Introduction*,
    for a recap of the tick function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps will help you complete the exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new `Third Person` template project using `C++` called `GFInstances`
    (*as in Gameplay Framework Instances*) and save it on a location of your choosing.
    Once the project has been created, it should open the editor as well as the Visual
    Studio solution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the editor, create a new `C++` class called `GFInstancePlayerController`
    that is derived from `PlayerController`. Wait for the compilation to end, close
    the editor, and then go back to Visual Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the `GFInstancesCharacter.h` file and declare the protected override for
    the `Tick` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the `GFInstancesCharacter.cpp` file and include `DrawDebugHelpers.h` and
    `PlayerController.h`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `Tick` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Get the instances for the game mode, game state, player controller, and HUD:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, we store the instances for the game mode, game
    state, player controller, and HUD in separate variables, so that we can check
    whether they are valid.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a string for each gameplay framework class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here, we create strings to store the name of the pawn and whether the other
    gameplay framework instances are valid.
  prefs: []
  type: TYPE_NORMAL
- en: 'Display each string on the screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In this code snippet, we print the strings created in the preceding code, which
    indicate the name of the pawn and whether the other gameplay framework instances
    are valid.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we can move on to the `AGFInstancesPlayerController` class, we need
    to tell Unreal Engine that we want to use UMG functionality in order to be able
    to use the `UUserWidget` class. To do this, we need to open `GFInstances.Build.cs`
    and add `UMG` to the `PublicDependencyModuleNames` string array, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: If you try to compile and get errors from adding the new module, then clean
    and recompile your project. If that doesn't work, try restarting your IDE.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `GFInstancesPlayerController.h` and add the protected variables to create
    the UMG widget:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare the protected override for the `BeginPlay` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Open `GFInstancesPlayerController.cpp` and include `UserWidget.h`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `BeginPlay` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Abort the function if it''s not the owning client or if the menu class is invalid:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the widget and add it to the viewport:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Compile and run the code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `Content Browser`, go to the `Content` folder, create a new folder called
    `UI`, and open it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new widget blueprint called `UI_Menu` and open it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `Text Block` called `tbText` to the root canvas panel and set it to be
    a variable by clicking the checkbox `Is Variable` next to its name on the top
    of the Details panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set `tbText` to have `Size To Content` to `true`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Go to the `Graph` section and, in `Event Graph`, implement the `Event Construct`
    in the following manner:![Figure 18.2: The Event Construct that displays the name
    of the UI_Menu instance'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_18_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 18.2: The Event Construct that displays the name of the UI_Menu instance'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the preceding screenshot in full resolution for better viewing
    at the following link: [https://packt.live/38wvSr5](https://packt.live/38wvSr5).'
  prefs: []
  type: TYPE_NORMAL
- en: Save and close `UI_Menu`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to the `Content` folder and create a blueprint called `BP_PlayerController`
    that is derived from `GFInstancesPlayerController`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open `BP_PlayerController` and set the `Menu` `Class` to use `UI_Menu`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save and close `BP_PlayerController`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to the `Content` folder and create a blueprint called `BP_GameMode` that
    is derived from `GFInstancesGameMode`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open `BP_GameMode` and set the `Player Controller` `Class` to use `BP_PlayerController`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save and close `BP_GameMode`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to `Project Settings` and pick `Maps & Modes` from the left panel, which
    is in the `Project` category.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the `Default` `GameMode` to use `BP_GameMode`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Close `Project Settings`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, you can test the project.
  prefs: []
  type: TYPE_NORMAL
- en: Run the code and wait for the editor to fully load.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to `Multiplayer Options` and set the number of clients to `2`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the window size to `800x600`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Play in `New Editor Window (PIE)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you complete this exercise, you will be able to play on each client. You'll
    notice that the characters are displaying whether the instances for the game mode,
    game state, player state, player controller, and HUD are valid. It also displays
    the name of the instance of the pawn.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's analyze the values displayed in the `Server` and `Client 1` windows.
    Let's begin with the `Server` window first.
  prefs: []
  type: TYPE_NORMAL
- en: The Server Window
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the `Server` window, you have the values for `Server Character`, and in the
    background, you have the values for `Client 1 Character`. You should be able to
    see `Server Character`, `Client 1 Character`, and the `UI_Menu` UMG widget in
    the top-left corner. The UMG widget instance is only created for the player controller
    of `Server Character`, since it's the only player controller in this window that
    actually controls a character.
  prefs: []
  type: TYPE_NORMAL
- en: Let's first analyze the values for `Server Character`.
  prefs: []
  type: TYPE_NORMAL
- en: Server Character
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is the character that the listen server, which is a server that also has
    a client integrated that can play the game as well, is controlling. The values
    displayed on this character are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Game Mode = Valid** because the game mode instance only exists in the server,
    which is the current game instance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Game State = Valid** because the game state instance exists on the clients
    and the server, which is the current game instance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Player State = Valid** because the player state instance exists on the clients
    and the server, which is the current game instance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pawn = ThirdPersonCharacter_2** because pawn instances exist on the clients
    and the server, which is the current game instance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Player Controller = Valid** because player controller instances exist on
    the owning client and the server, which is the current game instance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**HUD = Valid** because HUD instances only exist on the owning client, which
    is the case.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we are going to be looking at `Client 1 Character` in the same window.
  prefs: []
  type: TYPE_NORMAL
- en: Client 1 Character
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is the character that `Client 1` is controlling. The values displayed
    on this character are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Game Mode = Valid** because the game mode instance only exists in the server,
    which is the current game instance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Game State = Valid** because the game state instance exists on the clients
    and the server, which is the current game instance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Player State = Valid** because the player state instance exists on the clients
    and the server, which is the current game instance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pawn = ThirdPersonCharacter_0** because pawn instances exist on the clients
    and the server, which is the current game instance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Player Controller = Valid** because player controller instances exist on
    the owning client and the server, which is the current game instance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**HUD = Invalid** because HUD instances only exist on the owning client, which
    is not the case.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Client 1 Window
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the `Client 1` Window, you have the values for `Client 1 Character` and,
    in the background, you have values for `Server Character`. You should see `Client
    1 Character,` `Server Character`, and the `UI_Menu` UMG widget in the top-left
    corner. The UMG widget instance is only created for the player controller of `Client
    1 Character`, since it's the only player controller in this window that actually
    controls a character.
  prefs: []
  type: TYPE_NORMAL
- en: Let's first analyze the values for `Client 1 Character`.
  prefs: []
  type: TYPE_NORMAL
- en: Client 1 Character
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is the character that `Client 1` is controlling. The values displayed
    on this character are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Game Mode = Invalid** because the game mode instance only exists in the server,
    which is not the current game instance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Game State = Valid** because the game state instance exists on the server
    and the clients, which is the current game instance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Player State = Valid** because the player state instance exists on the server
    and the clients, which is the current game instance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pawn = ThirdPersonCharacter_0** because pawn instances exist on the server
    and the clients, which is the current game instance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Player Controller = Valid** because player controller instances exist on
    the server and the owning client, which is the current game instance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**HUD = Valid** because HUD instances only exist on the owning client, which
    is the case.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we are going to be looking at `Server Character` in the same window.
  prefs: []
  type: TYPE_NORMAL
- en: Server Character
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is the character that the listen server is controlling. The values displayed
    on this character are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Game Mode = Invalid** because the game mode instance only exists in the server,
    which is not the current game instance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Game State = Valid** because the game state instance exists on the server
    and the clients, which is the current game instance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Player State = Valid** because the player state instance exists on the server
    and the clients, which is the current game instance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pawn = ThirdPersonCharacter_2** because pawn instances exist on the server
    and the clients, which is the current game instance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Player Controller = Invalid** because player controller instances exist on
    the server and the owning client, which is not the current game instance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**HUD = Invalid** because HUD instances only exist on the owning client, which
    is not the case.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By completing this exercise, you should have a better understanding of where
    each instance of the gameplay framework classes exists and where it doesn't. Next,
    we're going to cover the player state and game state classes, as well as some
    additional concepts on the game mode and useful built-in functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: Game Mode, Player State, and Game State
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we've covered most of the important classes in the gameplay framework,
    including the game mode, player controller, and the pawn. In this chapter, we're
    going to cover the player state, game state, and some additional concepts of the
    game mode, as well as some useful built-in functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: Game Mode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We've already talked about the game mode and how it works, but there are a few
    concepts that haven't yet been covered.
  prefs: []
  type: TYPE_NORMAL
- en: Constructor
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To set the default class values, you can use the constructor like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code lets you specify which classes to use when spawning pawns,
    player controllers, player states, and game states when we are using this game
    mode.
  prefs: []
  type: TYPE_NORMAL
- en: '**Getting the Game Mode Instance**'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to access the game mode instance, you need to get it from the `GetWorld`
    function by using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code allows you to access the current game mode instance so you
    can run functions and consult the values of certain variables. You have to make
    sure to call it only on the server, since this will be invalid on the clients,
    for security reasons.
  prefs: []
  type: TYPE_NORMAL
- en: '**Match States**'
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we''ve only been using the `AGameModeBase` class, which is the most
    basic game mode class in the framework, and although it''s more than enough for
    certain types of games, there are cases where you require a bit more functionality.
    An example of this would be if we wanted to do a lobby system, where the match
    only starts if all players have marked that they were ready. This example wouldn''t
    be possible to do with the `AGameModeBase` class. For these cases, it''s better
    to use the `AGameMode` class instead, which is a child class of `AGameModeBase`
    that adds support to multiplayer matches through the use of match states. The
    way match states work is by using a state machine that can only be in one of the
    following states at a given time:'
  prefs: []
  type: TYPE_NORMAL
- en: '`EnteringMap`: This is the starting state when the world is still loading and
    the actors aren''t ticking yet. It will transition to the `WaitingToStart` state
    once the world finishes loading.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WaitingToStart`: This state is set when the world has finished loading and
    the actors are ticking, although the pawns for the players won''t be spawned because
    the game hasn''t started yet. When the state machine enters this state, it will
    call the `HandleMatchIsWaitingToStart` function. The state machine will transition
    to the `InProgress` state if the `ReadyToStartMatch` function returns `true` or
    if the `StartMatch` function is called somewhere in the code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`InProgress`: This state is where the actual game takes place. When the state
    machine enters this state, it will spawn the pawns for the players, call `BeginPlay`
    on all of the actors in the world, and call the `HandleMatchHasStarted` function.
    The state machine will transition to the `WaitingPostMatch` state if the `ReadyToEndMatch`
    function returns `true` or if the `EndMatch` function is called somewhere in the
    code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WaitingPostMatch`: This state is set when the match ends. When the state machine
    enters this state, it will call the `HandleMatchHasEnded` function. In this state,
    actors still tick, but new players cannot join. It will transition to the `LeavingMap`
    state when it starts unloading the world.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LeavingMap`: This state is set while it''s unloading the world. When the state
    machine enters this state, it will call the `HandleLeavingMap` function. The state
    machine will transition to the `EnteringMap` state when it starts loading the
    new level.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Aborted`: This is a failure state that can only be set by calling the `AbortMatch`
    function, which is used to flag that something went wrong that prevented the match
    from happening.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To help you understand these concepts better, we can use Dota 2 again as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`EnteringMap`: The state machine will be in this state when the map is loading.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WaitingToStart`: The state machine will be in this state once the map is loaded
    and the players are picking their heroes. The `ReadyToStartMatch` function will
    check whether all players have selected their heroes; if they have, then the match
    can start.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`InProgress`: The state machine will be in this state when the game is actually
    underway. The players control their heroes to farm and fight against other players.
    The `ReadyToEndMatch` function will constantly check the health of each ancient
    to see whether one of them was destroyed; if it was, then the match ends.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WaitingPostMatch`: The state machine will be in this state when the game has
    ended and you are seeing the destroyed ancient and showing the final scores for
    each player.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LeavingMap`: The state machine will be in this state when it''s unloading
    the map.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Aborted`: The state machine will be in this state if one of the players failed
    to connect in the initial stage, therefore aborting the whole match.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Respawning the Player**'
  prefs: []
  type: TYPE_NORMAL
- en: When the player dies and you want to respawn it, you typically have two options.
    The first option is to reuse the same pawn instance, manually reset its state
    back to the defaults, and teleport it to the respawn location. The second option
    is to destroy the pawn and spawn a new one, which will already have its state
    reset. If you prefer the latter option, then the `AGameModeBase::RestartPlayer`
    function handles the logic of spawning a new pawn instance for a certain player
    controller for you and places it on a player start.
  prefs: []
  type: TYPE_NORMAL
- en: One important thing to take into consideration is that the function spawns a
    new pawn instance only if the player controller doesn't already possess a pawn,
    so make sure to destroy the controlled pawn before calling `RestartPlayer`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we have the `OnDeath` function that takes the player
    controller of the player that died, destroys its controlled pawn, and calls the
    `RestartPlayer` function to spawn a new instance on a player start. By default,
    the player start actor used will always be the same as the player spawned the
    first time. If you want the function to spawn on a random player start, then you
    need to override the `AGameModeBase::ShouldSpawnAtStartSpot` function and force
    it to `return false`, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code will make the game mode use a random player start instead
    of always using the same.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: For more information about the game mode, please visit [https://docs.unrealengine.com/en-US/Gameplay/Framework/GameMode/#gamemodes](https://docs.unrealengine.com/en-US/Gameplay/Framework/GameMode/#gamemodes)
    and [https://docs.unrealengine.com/en-US/API/Runtime/Engine/GameFramework/AGameMode/index.html](https://docs.unrealengine.com/en-US/API/Runtime/Engine/GameFramework/AGameMode/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: Player State
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The player state class stores the state of a player, such as the current score,
    kills/deaths, and coins picked up. It's mostly used in multiplayer mode to store
    the information that other clients need to know about the player, since they can't
    access its player controller. The most widely used built-in variables are `PlayerName`,
    `Score`, and `Ping`, which give you the name, score, and ping of the player, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'A scoreboard entry on a multiplayer shooter is a good example of how to use
    the player state, because every client needs to know the names, kills/deaths,
    and pings of all the players. The player state instance can be accessed in the
    following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '**AController::PlayerState**'
  prefs: []
  type: TYPE_NORMAL
- en: 'This variable has the player state associated with the controller and it can
    only be accessed by the server and the owning client. The following example will
    demonstrate how to use the variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '**AController::GetPlayerState()**'
  prefs: []
  type: TYPE_NORMAL
- en: 'This function returns the player state associated with the controller and it
    can only be accessed by the server and the owning client. This function also has
    a templated version, so you can cast it to your own custom player state class.
    The following examples will demonstrate how to use the default and template versions
    of this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '**APawn::GetPlayerState()**'
  prefs: []
  type: TYPE_NORMAL
- en: 'This function returns the player state associated with the controller that
    is possessing the pawn and it can be accessed by the server and the clients. This
    function also has a templated version, so you can cast it to your own custom player
    state class. The following examples will demonstrate how to use the default and
    template versions of this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code demonstrates the two ways you can use the `GetPlayerState`
    function. You can use the default `APlayerState` version or the template version
    that casts automatically for you.
  prefs: []
  type: TYPE_NORMAL
- en: '**AGameState::PlayerArray**'
  prefs: []
  type: TYPE_NORMAL
- en: 'This variable stores the player state instances for each player and it can
    be accessed on the server and the clients. The following example will demonstrate
    how to use this variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'To help you understand these concepts better, we can use Dota 2 again as an
    example. The player state would have at least the following variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Name**: The name of the player'
  prefs: []
  type: TYPE_NORMAL
- en: '**Hero**: The selected hero'
  prefs: []
  type: TYPE_NORMAL
- en: '**Health**: The health of the hero'
  prefs: []
  type: TYPE_NORMAL
- en: '**Mana**: The mana of the hero'
  prefs: []
  type: TYPE_NORMAL
- en: '**Stats**: The hero stats'
  prefs: []
  type: TYPE_NORMAL
- en: '**Level**: The level the hero is currently in'
  prefs: []
  type: TYPE_NORMAL
- en: '**Kill / Death / Assist**: The kill/death/assist ratio for the player'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: For more information about the player state, please visit [https://docs.unrealengine.com/en-US/API/Runtime/Engine/GameFramework/APlayerState/index.html](https://docs.unrealengine.com/en-US/API/Runtime/Engine/GameFramework/APlayerState/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: Game State
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The game state class stores the state of the game, including the match's elapsed
    time and the score required to win the game. It's mostly used in multiplayer mode
    to store the information that other clients need to know about the game, since
    they can't access the game mode. The most widely used variable is `PlayerArray`,
    which is an array with the player state of every connected client. A scoreboard
    on a multiplayer shooter is a good example of how to use the game state, because
    every client needs to know how many kills are required to win and also the name
    and ping of each player.
  prefs: []
  type: TYPE_NORMAL
- en: 'The game state instance can be accessed in the following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '**UWorld::GetGameState()**'
  prefs: []
  type: TYPE_NORMAL
- en: 'This function returns the game state associated with the world and can be accessed
    on the server and the clients. This function also has a templated version, so
    you can cast it to your own custom game state class. The following examples will
    demonstrate how to use the default and template versions of this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '**AGameModeBase::GameState**'
  prefs: []
  type: TYPE_NORMAL
- en: 'This variable has the game state associated with the game mode and it can only
    be accessed on the server. The following example will demonstrate how to use the variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '**AGameModeBase::GetGameState()**'
  prefs: []
  type: TYPE_NORMAL
- en: 'This function returns the game state associated with the game mode and it can
    only be accessed on the server. This function also has a templated version, so
    you can cast it to your own custom game state class. The following examples will
    demonstrate how to use the default and template versions of this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'To help you understand these concepts better, we can use Dota 2 again as an
    example. The game state would have the following variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Elapsed Time**: How long the match has been going on for'
  prefs: []
  type: TYPE_NORMAL
- en: '**Radiant Kills**: How many Dire heroes the Radiant team has killed'
  prefs: []
  type: TYPE_NORMAL
- en: '**Dire Kills**: How many Radiant heroes the Dire team has killed'
  prefs: []
  type: TYPE_NORMAL
- en: '**Day/Night Timer**: Used to determine whether it is day or night'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: For more information about the game state, please visit [https://docs.unrealengine.com/en-US/Gameplay/Framework/GameMode/#gamestate](https://docs.unrealengine.com/en-US/Gameplay/Framework/GameMode/#gamestate)
    and [https://docs.unrealengine.com/en-US/API/Runtime/Engine/GameFramework/AGameState/index.html](https://docs.unrealengine.com/en-US/API/Runtime/Engine/GameFramework/AGameState/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: Useful Built-in Functionality
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Unreal Engine 4 comes with a lot of useful functionality built in. Here are
    some examples of some functions and a component that will be useful when developing
    your game:'
  prefs: []
  type: TYPE_NORMAL
- en: '**void AActor::EndPlay(const EEndPlayReason::Type EndPlayReason)**'
  prefs: []
  type: TYPE_NORMAL
- en: 'This function is called when the actor has stopped playing, which is the opposite
    of the `BeginPlay` function. You have the `EndPlayReason` parameter, which tells
    you why the actor stopped playing (if it was destroyed, if you stopped PIE, and
    so on). Take a look at the following example, which prints to the screen the fact
    that the actor has stopped playing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '**void ACharacter::Landed(const FHitResult& Hit)**'
  prefs: []
  type: TYPE_NORMAL
- en: 'This function is called when a player lands on a surface after being in the
    air. Take a look at the following example, which plays a sound when a player lands
    on a surface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '**bool UWorld::ServerTravel(const FString& FURL, bool bAbsolute, bool bShouldSkipGameNotify)**'
  prefs: []
  type: TYPE_NORMAL
- en: This function will make the server load a new map and bring all of the connected
    clients along with it. This is different from using other methods that load maps,
    such as the `UGameplayStatics::OpenLevel` function, because it won't bring the
    clients along; it will just load the map on the server and disconnect the clients.
  prefs: []
  type: TYPE_NORMAL
- en: 'One important thing to take into consideration is that server travel only works
    properly in the packaged version, so it won''t bring the clients along when playing
    in the editor. Take a look at the following example, which gets the current map
    name and uses server travel to reload it and bring along the connected clients:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '**void TArray::Sort(const PREDICATE_CLASS& Predicate)**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `TArray` data structure comes with the `Sort` function, which allows you
    to sort the values of an array by using a `lambda` function that returns whether
    value `A` should be ordered first, followed by value `B`. Take a look at the following
    example, which sorts an integer array from the smallest value to the highest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code will sort the `SortTest` array with the values [43, 1, 23,
    8] from smallest to highest [1, 8, 23, 43].
  prefs: []
  type: TYPE_NORMAL
- en: '**void AActor::FellOutOfWorld(const UDamageType& DmgType)**'
  prefs: []
  type: TYPE_NORMAL
- en: 'In Unreal Engine 4, there is a concept called `Kill Z`, which is a plane on
    a certain value in `Z` (set in the `World Settings` panel), and if an actor goes
    below that `Z` value, it will call the `FellOutOfWorld` function, which, by default,
    destroys the actor. Take a look at the following example, which prints to the
    screen the fact that the actor fell out of the world:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '**URotatingMovementComponent**'
  prefs: []
  type: TYPE_NORMAL
- en: 'This component rotates the owning actor along time with a certain rate on each
    axis, defined in the `RotationRate` variable. To use it, you need to include the
    following header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare the component variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, initialize it in the actor constructor, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, `RotationRate` is set to rotate `90` degrees per second
    on the `Yaw` axis.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 18.02: Making a Simple Multiplayer Pickup Game'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we''re going to create a new C++ project that uses the Third
    Person template and we''re going to add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: On the owning client, the player controller creates and adds to the viewport
    a UMG widget that, for each player, displays the score, sorted from highest to
    lowest, and how many pickups it has collected.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a simple pickup actor class that gives 10 points to the player that picked
    it up. The pickup will also rotate 90 degrees per second on the `Yaw` axis.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set `Kill Z` to `-500` and make the player respawn and lose 10 points every
    time he falls from the world.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The game will end when there are no more pickups available. Once the game ends,
    all characters will be destroyed and, after 5 seconds, the server will do a server
    travel call to reload the same map and bring along the connected clients.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following steps will help you complete the exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new `Third Person` template project using `C++` called `Pickups` and
    save it to a location of your choosing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the project has been created, it should open the editor as well as the
    Visual Studio solution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, let''s create the new C++ classes we''re going to use:'
  prefs: []
  type: TYPE_NORMAL
- en: Create the `Pickup` class that is derived from `Actor`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the `PickupsGameState` class that is derived from `GameState`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the `PickupsPlayerState` class that is derived from `PlayerState`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the `PickupsPlayerController` class that is derived from `PlayerController`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Close the editor and open Visual Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, let's work on the `Pickup` class.
  prefs: []
  type: TYPE_NORMAL
- en: Open `Pickup.h` and clear all existing functions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Declare the protected `Static Mesh` component called `Mesh`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare the protected rotating movement component called `RotatingMovement`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare the protected `PickupSound` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare the protected constructor and `BeginPlay` override:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare the protected `OnBeginOverlap` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Open `Pickup.cpp` and include `PickupsCharacter.h`, `PickupsGameState.h`, `StaticMeshComponent.h`,
    and `RotatingMovementComponent.h`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'In the constructor, initialize the `Static Mesh` component to overlap with
    everything and call the `OnBeginOverlap` function when it''s overlapped:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Still in the constructor, initialize the rotating movement component to rotate
    `90` degrees per second on the `Yaw` axis:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'To finalize the constructor, enable replication and disable the `Tick` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `BeginPlay` function, which binds the begin overlap event to
    the `OnBeginOverlap` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `OnBeginOverlap` function, which checks whether the character
    is valid and has authority, removes the pickup on the game state, plays the pickup
    sound on the owning client, adds `10` points and the pickup to the character.
    Once all of that is done, the pickup destroys itself.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Next, we're going to work on the `PickupsGameState` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `PickupsGameState.h` and declare the protected replicated integer variable
    `PickupsRemaining`, which tells all clients how many pickups remain in the level:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare the protected override for the `BeginPlay` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare the protected `GetPlayerStatesOrderedByScore` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the public `RemovePickup` function, which removes one pickup from
    the `PickupsRemaining` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the public `HasPickups` function, which returns whether there are
    still pickups remaining:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Open `PickupsGameState.cpp` and include `Pickup.h`, `GameplayStatics.h`, `UnrealNetwork.h`,
    and `PlayerState.h`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `GetLifetimeReplicatedProps` function and make the `PickupRemaining`
    variable replicate to all clients:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `BeginPlay` override function and set the value of `PickupsRemaining`
    by getting all of the pickups in the world:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `GetPlayerStatesOrderedByScore` function, which duplicates the
    `PlayerArray` variable and sorts it so that the players with the highest scores
    show up first:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Next, let's work on the `PickupsPlayerState` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `PickupsPlayerState.h`, and declare the protected replicated integer variable
    `Pickups`, which indicates how many pickups a player has collected:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the public `AddPickup` function, which adds one pickup to the `Pickups`
    variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Open `PickupsPlayerState.cpp` and include `UnrealNetwork.h`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `GetLifetimeReplicatedProps` function and make the `Pickups`
    variable replicate to all clients:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Next, let's work on the `PickupsPlayerController` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `PickupsPlayerController.h` and declare the protected `ScoreboardMenuClass`
    variable, which enables the UMG widget we want to use for our scoreboard to be
    selected:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare the protected `ScoreboardMenu` variable, which stores the scoreboard
    UMG widget instance we create on the `BeginPlay` function variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare the protected override for the `BeginPlay` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Open `PickupsPlayerController.cpp` and include `UserWidget.h`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `BeginPlay` override function, which, for the owning client,
    creates and adds the scoreboard UMG widget to the viewport:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s edit the `PickupsGameMode` class:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `PickupsGameMode.h` and replace the `include` for `GameModeBase.h` with
    `GameMode.h`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Make the class derive from `AGameMode` instead of `AGameModeBase`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare the protected game state variable `MyGameState`, which holds the instance
    to the `APickupsGameState` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Move the constructor to the protected area.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Declare the protected override for the `BeginPlay` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare the protected override for the `ShouldSpawnAtStartSpot` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare the protected overrides for the match state functions of the game mode:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare the protected `RestartMap` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Open `PickupsGameMode.cpp` and include `GameplayStatics.h`, `PickupGameState.h`,
    `Engine/World.h`, `TimerManager.h`, and `Engine.h`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `BeginPlay` override function, which stores the `APickupGameState`
    instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `ShouldSpawnAtStartSpot` override function, which indicates that
    we want the players to respawn on a random player start and not always on the
    same one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `HandleMatchHasStarted` override function, which prints to the
    screen, informing players that the game has started:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `HandleMatchHasEnded` override function, which prints to the
    screen, informing players that the game has ended, destroys all characters, and
    schedules a timer to restart the map:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `ReadyToStartMatch_Implementation` override function, which indicates
    that the match can start straight away:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `ReadyToEndMatch_Implementation` override function, which indicates
    that the match ends when the game state has no more pickups remaining:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `RestartMap` function, which indicates that the server travels
    to the same level and brings all clients along (*only in the packaged version*):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's edit the `PickupsCharacter` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `PickupsCharacter.h` and declare the protected sound variables for falling
    and landing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare the protected `override` functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare the public functions that add scores and pickups to the player state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare the public client RPC that plays a sound on the owning client:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Open `PickupsCharacter.cpp` and include `PickupsPlayerState.h`, `GameMode.h`,
    and `GameplayStatics.h`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `EndPlay` override function, which plays the fall sound if the
    character was destroyed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `Landed` override function, which plays the landed sound:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `FellOutOfWorld` override function, which stores the controller,
    removes `10` points from the score, destroys the character (which makes the controller
    invalid), and tells the game mode to restart the player using the previous controller:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `AddScore` function, which adds a score to the `Score` variable
    in the player state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `AddPickup` function, which adds a pickup to the `Pickup` variable
    in our custom player state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `ClientPlaySound2D_Implementation` function, which plays a sound
    on the owning client:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Open `Pickups.Build.cs` and add the `UMG` module to `PublicDependencyModuleNames`,
    like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: If you try to compile and get errors from adding the new module, then clean
    and recompile your project. If that doesn't work, try restarting your IDE.
  prefs: []
  type: TYPE_NORMAL
- en: Compile and run the code until the editor loads.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: First, let's import the sound files.
  prefs: []
  type: TYPE_NORMAL
- en: In `Content Browser`, create and go to the `Content\Sounds` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import `Pickup.wav`, `Footstep.wav`, `Jump.wav`, `Land.wav`, and `Fall.wav`
    from the `Exercise18.02\Assets` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the new files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, let's add the `Play Sound` anim notifies to some of the character's animations.
  prefs: []
  type: TYPE_NORMAL
- en: Open `ThirdPersonJump_Start animation`, located in `Content\Mannequin\Animations`,
    and add a `Play Sound` anim notify at frame `0` using the `Jump` sound.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save and close `ThirdPersonJump_Start`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `ThirdPersonRun` animation, located in `Content\Mannequin\Animations`,
    and add two `Play Sound` anim notifies using the `Footstep` sound at time 0.24
    sec and 0.56 sec.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save and close `ThirdPersonRun`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `ThirdPersonWalk` animation, located in `Content\Mannequin\Animations`,
    and add two `Play Sound` anim notifies using the `Footstep` sound at time 0.24
    sec and 0.79 sec.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save and close `ThirdPersonWalk`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, let's set the sounds for the character blueprint.
  prefs: []
  type: TYPE_NORMAL
- en: Open the `ThirdPersonCharacter` blueprint, located in `Content\ThirdPersonCPP\Blueprints`,
    and set the `Fall` `Sound` and `Land` `Sound` to use the sounds `Fall` and `Land`,
    respectively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save and close `ThirdPersonCharacter`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, let's create the blueprint for the pickup.
  prefs: []
  type: TYPE_NORMAL
- en: Create and open the `Content\Blueprints` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new blueprint called `BP_Pickup` that is derived from the `Pickup`
    class and open it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Configure the `Static Mesh` component in the following way:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To display the Engine content, you need to go to View Options on the bottom
    right of the dropdown for the static mesh and make sure the Show Engine Content
    flag is set to true.
  prefs: []
  type: TYPE_NORMAL
- en: Set the `Pickup` `Sound` variable to use the `Pickup` sound.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save and close `BP_Pickup`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, let's create the scoreboard UMG widgets.
  prefs: []
  type: TYPE_NORMAL
- en: Create and go to the `Content\UI` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new widget blueprint called `UI_Scoreboard_Header`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a text block called `tbName` to the root canvas panel with `Is Variable`
    set to `true`, `Size To Content` set to `true`, `Text` set to `Player Name`, and
    `Color and Opacity` set to use the color `green`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a text block called `tbScore` to the root canvas panel with `Is Variable`
    set to `true`, `Position X = 500`, `Alignment = 1.0, 0.0`, `Size To Content` set
    to `true`, `Text` set to `Score`, and `Color and Opacity` set to use the color
    `green`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a text block called `tbPickups` to the root canvas panel with `Is Variable`
    set to `true`, `Position X = 650`, `Alignment = 1.0, 0.0`, `Size To Content` set
    to `true`, `Text` set to `Pickups`, and `Color and Opacity` set to use the color
    `green`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From the `Hierarchy` panel, select the three new text blocks and copy them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save and close `UI_Scoreboard_Header`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go back to `Content\UI`, create a new UMG widget called `UI_Scoreboard_Entry`,
    and open it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Paste the copied text blocks on the root canvas panel and change them to be
    `white` instead of `green` and make them all variables.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Go to the `Graph` section and create the `Player State` variable with the following
    configuration:![Figure 18.3: Creating the Player State variable'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_18_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 18.3: Creating the Player State variable'
  prefs: []
  type: TYPE_NORMAL
- en: 'Go back to the Designer section and create a bind for `tbName` that does the following:![Figure
    18.4: Displaying the player name'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_18_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 18.4: Displaying the player name'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the preceding screenshot in full resolution for better viewing
    at the following link: [https://packt.live/3pCk9Nt](https://packt.live/3pCk9Nt).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a bind for `tbScore` that does the following:![Figure 18.5: Displaying
    the player score'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_18_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 18.5: Displaying the player score'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the preceding screenshot in full resolution for better viewing
    at the following link: [https://packt.live/3nuckYv](https://packt.live/3nuckYv).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a bind for `tbPickups` that does the following:![Figure 18.6: Displaying
    the pickups count'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_18_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 18.6: Displaying the pickups count'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the preceding screenshot in full resolution for better viewing
    at the following link: [https://packt.live/36pEGMz](https://packt.live/36pEGMz).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a pure function called `Get Typeface` that does the following:![Figure
    18.7: Determining whether the entry should be displayed in bold or regular'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_18_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 18.7: Determining whether the entry should be displayed in bold or regular'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the preceding screenshot in full resolution for better viewing
    at the following link: [https://packt.live/2JW9Zam](https://packt.live/2JW9Zam).'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding code, we use a select node, which can be created by dragging
    a wire from the return value and releasing it on an empty space, and type "select"
    on the filter. From there, we pick the select node from the list. In this specific
    function we use the select node to pick the name of the typeface we're going to
    use, so it should return `Regular` if the player state's pawn is not the same
    as the pawn that owns the widget and `Bold` if it is. We do this to highlight
    in bold the player state entry so that the player knows what their entry is.
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement `Event Construct` in the following way:![Figure 18.8: The Event Graph
    that sets the text for the name, score, and pickups count'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_18_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 18.8: The Event Graph that sets the text for the name, score, and pickups
    count'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the preceding screenshot in full resolution for better viewing
    at the following link: [https://packt.live/2JOdP58](https://packt.live/2JOdP58).'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding code, we set the font for `tbName`, `tbScore`, and `tbPickups`
    to use the `Bold` typeface to highlight which scoreboard entry is relative to
    the player of the current client. For the remainder of the players, use the `Regular` typeface.
  prefs: []
  type: TYPE_NORMAL
- en: Save and close `UI_Scoreboard_Entry`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go back to `Content\UI` and then create a new UMG widget called `UI_Scoreboard`
    and open it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a vertical box called `vbScoreboard` to the root canvas panel with `Size
    To Content` enabled.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a text block to `vbScoreboard` called `tbGameInfo` that has the `Text` value
    defaulted to `Game Info`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to the `Graph` section and create a new variable called `Game State` of the
    `Pickups Game State` type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Implement `Event Construct` in the following way:![Figure 18.9: The Event Construct
    that sets a timer to update'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: the scoreboard every 0.5 seconds
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_18_09.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 18.9: The Event Construct that sets a timer to update the scoreboard
    every 0.5 seconds'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the preceding screenshot in full resolution for better viewing
    at the following link: [https://packt.live/3kemyu0](https://packt.live/3kemyu0).'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding code, we get the game state instance, update the scoreboard,
    and schedule a timer to automatically update the scoreboard every 0.5 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go back to the designer section and make the following bind for `vbScoreboard`:![Figure
    18.10: Displaying the number of pickups remaining in the world'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_18_10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 18.10: Displaying the number of pickups remaining in the world'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the preceding screenshot in full resolution for better viewing
    at the following link: [https://packt.live/38xUDTE](https://packt.live/38xUDTE).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a vertical box to `vbScoreboard` called `vbPlayerStates` with `Is Variable`
    set to `true` and a top padding of `50`, so you should have the following:![Figure
    18.11: The UI_Scoreboard widget hierarchy'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_18_11.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 18.11: The UI_Scoreboard widget hierarchy'
  prefs: []
  type: TYPE_NORMAL
- en: 'Go back to the Graph section and implement the `Update Scoreboard` event in
    the following way:![Figure 18.12: The update scoreboard function, which clears
    and recreates the entry widgets'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_18_12.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 18.12: The update scoreboard function, which clears and recreates the
    entry widgets'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the preceding screenshot in full resolution for better viewing
    at the following link: [https://packt.live/3pf8EeN](https://packt.live/3pf8EeN).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding code, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Clear all of the previous entries in `vbPlayerStates`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a scoreboard header entry and add it to `vbPlayerStates`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loop through all of the player states ordered by score and create an entry for
    each one, as well as adding it to `vbPlayerStates`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Save and close `UI_Scoreboard`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, let's create the blueprint for the player controller.
  prefs: []
  type: TYPE_NORMAL
- en: Go to `Content\Blueprints` and create a new blueprint called `BP_PlayerController`
    that is derived from the `PickupPlayerController` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the new blueprint and set the `Scoreboard Menu` `Class` to use `UI_Scoreboard`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save and close `BP_PlayerController`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, let's create the blueprint for the game mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to `Content\Blueprints` and create a new blueprint called `BP_GameMode`
    that is derived from the `PickupGameMode` class, open it, and change the following
    variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Next, let's configure `Project Settings` to use the new game mode.
  prefs: []
  type: TYPE_NORMAL
- en: Go to `Project Settings` and pick `Maps & Modes` from the left panel, which
    is in the `Project` category.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set `Default GameMode` to use `BP_GameMode`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Close `Project Settings`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, let's modify the main level.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure you have `ThirdPersonExampleMap` opened, located in `Content\ThirdPersonCPP\Maps`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add some cube actors to act as platforms and make sure they have gaps between
    them to force the player to jump on them and possibly fall from the level.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a couple of player start actors to different parts of the map.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add at least 50 instances of `BP_Pickup` and spread them across the entire map.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here is an example of a possible way of configuring the map:![Figure 18.13:
    An example of the map configuration'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_18_13.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 18.13: An example of the map configuration'
  prefs: []
  type: TYPE_NORMAL
- en: Run the code and wait for the editor to fully load.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to `Multiplayer Options` and set the number of clients to `2`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the window size to `800x600`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Play in `New Editor Window (PIE)`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 18.14: The listen Server and Client 1 picking up cubes in the world'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_18_14.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 18.14: The listen Server and Client 1 picking up cubes in the world'
  prefs: []
  type: TYPE_NORMAL
- en: Once you complete this exercise, you will be able to play on each client and
    you'll notice that the characters can collect pickups and gain `10` points just
    by overlapping with them. If a character falls from the level, it will respawn
    on a random player start and lose `10` points.
  prefs: []
  type: TYPE_NORMAL
- en: Once all pickups have been collected, the game will end, and after `5` seconds,
    it will perform a server travel to reload the same level and bring all the clients
    with it (*only in the packaged version*). You can also see that the UI displays
    how many pickups are remaining in the level, as well as the scoreboard with the
    information about the name, score, and pickups for each player.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 18.01: Adding Death, Respawn, Scoreboard, Kill Limit, and Pickups
    to the Multiplayer FPS Game'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this activity, you'll add the concept of death, respawning, and the ability
    to use pickups to the character. We'll also add a way to check the scoreboard
    and a kill limit to the game so that it has an end goal.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps will help you complete this activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `MultiplayerFPS` project from *Activity 17.01*, *Adding Weapons and
    Ammo to the Multiplayer FPS Game*. Compile the code and run the editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, you're going to create the C++ classes that we're going to need. Create
    a C++ class called `FPSGameState`, which is derived from the `GameState` class,
    and has a kill limit variable and a function that returns the player states ordered
    by kills.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a C++ class called `FPSPlayerState`, which is derived from the `PlayerState`
    class, and stores the number of kills and deaths of a player.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a C++ class called `PlayerMenu`, which is derived from the `UserWidget`
    class, and has some `BlueprintImplementableEvent` functions to toggle the scoreboard
    visibility, set the scoreboard visibility, and notify when a player was killed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a C++ class called `FPSPlayerController`, which derives from `APlayerController`,
    that creates the `PlayerMenu` UMG widget instance on the owning client.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a C++ class called `Pickup`, which is derived from the `Actor` class,
    and has a static mesh that rotates 90 degrees per second on the `Yaw` axis, and
    can be picked up by the player on the overlap. Once picked up, it plays a pickup
    sound, and disables collision and visibility. After a certain amount of time,
    it will make it visible and able to collide again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a C++ class called `AmmoPickup`, which is derived from the `Pickup` class,
    and adds a certain amount of an ammo type to the player.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a C++ class called `ArmorPickup`, which is derived from the `Pickup`
    class, and adds a certain amount of armor to the player.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a C++ class called `HealthPickup`, which is derived from the `Pickup`
    class, and adds a certain amount of health to the player.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a C++ class called `WeaponPickup`, which is derived from the `Pickup`
    class, and adds a certain weapon type to the player. If the player already has
    the weapon, it will add a certain amount of ammo.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Edit the `FPSCharacter` class so that it does the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After the character is damaged, checks to see whether it's dead. If it's dead,
    it registers the kill for the killer character and the death of the character,
    as well as respawning the player. If the character is not dead, then it plays
    the pain sound on the owning client.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the character dies and executes the `EndPlay` function, it should destroy
    all of its weapon instances.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the character falls from the world, it will register the death of the player
    and respawn it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the player presses the *Tab* key, it will toggle the visibility of the scoreboard menu.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Edit the `MultiplayerFPSGameModeBase` class so that it does the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Stores the number of kills necessary to win the game.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uses the new player controller, player state, and game state classes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Makes it implement the match state functions so that the match starts immediately
    and ends if there is a player that has the required number of kills.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the match ends, it will perform a server travel to the same level after
    5 seconds.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handles when a player dies by adding the kill (when killed by another player)
    and the death to the respective player state, as well as respawning the player
    on a random player start.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Import `AmmoPickup.wav` from `Activity18.01\Assets` to `Content\Pickups\Ammo`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create `BP_PistolBullets_Pickup` from `AAmmoPickup`, place it in `Content\Pickups\Ammo`,
    and configure it with the following values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Scale: `(X=0.5, Y=0.5, Z=0.5)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Static Mesh: `Engine\BasicShapes\Cube`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Material: `Content\Weapon\Pistol\M_Pistol`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ammo Type: `Pistol Bullets`, Ammo Amount: `25`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Pickup Sound: `Content\Pickup\Ammo\AmmoPickup`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Create `BP_MachineGunBullets_Pickup` from `AAmmoPickup`, place it in `Content\Pickups\Ammo`,
    and configure it with the following values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Scale: `(X=0.5, Y=0.5, Z=0.5)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Static Mesh: `Engine\BasicShapes\Cube`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Material: `Content\Weapon\MachineGun\M_MachineGun`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ammo Type: `Machine Gun Bullets`, Ammo Amount: `50`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Pickup Sound: `Content\Pickup\Ammo\AmmoPickup`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Create `BP_Slugs_Pickup` from `AAmmoPickup`, place it in `Content\Pickups\Ammo`,
    and configure it with the following values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Scale: `(X=0.5, Y=0.5, Z=0.5)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Static Mesh: `Engine\BasicShapes\Cube`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Material: `Content\Weapon\Railgun\M_Railgun`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ammo Type: `Slugs`, Ammo Amount: `5`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Pickup Sound: `Content\Pickup\Ammo\AmmoPickup`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Import `ArmorPickup.wav` from `Activity18.01\Assets` to `Content\Pickups\Armor`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the material `M_Armor` in `Content\Pickups\Armor`, which has `Base Color`
    set to `blue` and `Metallic` set to `1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create `BP_Armor_Pickup` from `AArmorPickup`, place it in `Content\Pickups\Armor`,
    and configure it with the following values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Scale: `(X=1.0, Y=1.5, Z=1.0)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Static Mesh: `Engine\BasicShapes\Cube`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Material: `Content\Pickup\Armor\M_Armor`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Armor Amount: `50`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Pickup Sound: `Content\Pickup\Armor\ArmorPickup`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Import `HealthPickup.wav` from `Activity18.01\Assets` to `Content\Pickups\Health`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the material `M_Health` in `Content\Pickups\Health`, which has `Base
    Color` set to `blue` and `Metallic`/`Roughness` set to `0.5`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create `BP_Health_Pickup` from `AHealthPickup`, place it in `Content\Pickups\Health`,
    and configure it with the following values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Static Mesh: `Engine\BasicShapes\Sphere`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Material: `Content\Pickup\Health\M_Health`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Health Amount: `50`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Pickup Sound: `Content\Pickup\Health\HealthPickup`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Import `WeaponPickup.wav` from `Activity18.01\Assets` to `Content\Pickups\Weapon`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create `BP_Pistol_Pickup` from `AWeaponPickup`, place it in `Content\Pickups\Weapon`,
    and configure it with the following values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Static Mesh: `Content\Pickup\Weapon\SM_Weapon`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Material: `Content\Weapon\Pistol\M_Pistol`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Weapon Type: `Pistol`, Ammo Amount: `25`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Pickup Sound: `Content\Pickup\Weapon\WeaponPickup`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Create `BP_MachineGun_Pickup` from `AWeaponPickup`, place it in `Content\Pickups\Weapon`,
    and configure it with the following values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Static Mesh: `Content\Pickup\Weapon\SM_Weapon`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Material: `Content\Weapon\MachineGun\M_MachineGun`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Weapon Type: `Machine Gun`, Ammo Amount: `50`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Pickup Sound: `Content\Pickup\Weapon\WeaponPickup`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Create `BP_Pistol_Pickup` from `AWeaponPickup`, place it in `Content\Pickups\Weapon`,
    and configure it with the following values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Static Mesh: `Content\Pickup\Weapon\SM_Weapon`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Material: `Content\Weapon\Railgun\M_Railgun`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Weapon Type: `Railgun`, Ammo Amount: `5`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Pickup Sound: `Content\Pickup\Weapon\WeaponPickup`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Import `Land.wav` and `Pain.wav` from `Activity18.01\Assets` to `Content\Player\Sounds`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Edit `BP_Player` so that it uses the `Pain` and `Land` sounds, as well as deleting
    all of the nodes that create and add the `UI_HUD` instance to the viewport in
    the `Begin Play` event.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a UMG widget called `UI_Scoreboard_Entry` in `Content\UI` that displays
    the name, kills, deaths, and ping of `AFPSPlayerState`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a UMG widget called `UI_Scoreboard_Header` that displays the headers
    for the name, kills, deaths, and ping.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a UMG widget called `UI_Scoreboard` that displays the kill limit from
    the game state, a vertical box that has `UI_Scoreboard_Header` as the first entry,
    and then add a `UI_Scoreboard_Entry` for each `AFPSPlayerState` in the game state
    instance. The vertical box will update every 0.5 seconds, through a timer, by
    clearing its children and adding them again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Edit `UI_HUD` so that it adds a new text block called `tbKilled` that starts
    with `Visibility` set to `Hidden`. When the player kills someone, it will make
    the text block visible, display the name of the killed player, and hide after
    1 second.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new blueprint called `UI_PlayerMenu` from `UPlayerMenu` and place it
    in `Content\UI`. Use a widget switcher with an instance of `UI_HUD` in index `0`
    and an instance of `UI_Scoreboard` in index `1`. In the event graph, make sure
    to override the `Toggle Scoreboard`, `Set Scoreboard Visibility`, and `Notify
    Kill` events that were set as `BlueprintImplementableEvent` in C++. The `Toggle
    Scoreboard` event toggles the widget switcher's active index between `0` and `1`,
    the `Set Scoreboard Visibility` event sets the widget switcher's active index
    to `0` or `1`, and the `Notify Kill` event tells the `UI_HUD` instance to set
    the text and fade out the animation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create `BP_PlayerController` from `AFPSPlayerController`, place it in the `Content`
    folder, and set the `PlayerMenuClass` variable to use `UI_PlayerMenu`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Edit `BP_GameMode` and set `Player Controller Class` to use `BP_PlayerController`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `Input` section of `Project Settings`, create an action mapping called
    `Scoreboard` that uses the `TAB` key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Edit the `DM-Test` level so that you have at least three new player starts placed
    in different locations, `Kill Z` to `-500` in `World Settings`, and an instance
    placed of every different pickup.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Expected output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 18.15: The expected output of the activity'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_18_15.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 18.15: The expected output of the activity'
  prefs: []
  type: TYPE_NORMAL
- en: The result should be a project where each client's character can pick up, use,
    and switch between three different weapons. If a character kills another, it should
    register the kill and the death, as well as respawning the character that died
    at a random player start. You should have a scoreboard that displays the name,
    kill count, death count, and ping, for each player. A character can fall from
    the level, which should only count as a death, and respawn at a random player
    start. The character should also be able to pick up the different pickups in the
    level to get ammo, armor, health, and weapons. The game should end when the kill
    limit has been reached by showing the scoreboard and server travel to the same
    level after 5 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution to this activity can be found at: [https://packt.live/338jEBx](https://packt.live/338jEBx).'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned that the gameplay framework class's instances exist
    in some game instances, but not in others. Having that knowledge will help you
    understand which instances can be accessed in a particular game instance. You
    also learned the purpose of the game state and player state classes, as well as
    learning new concepts for the game mode and some useful built-in functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of this chapter, you have made a basic but functional multiplayer
    shooter that can be used as a foundation to build upon. You can add new weapons,
    ammo types, fire modes, pickups, and so on, to make it more feature-complete and
    fun.
  prefs: []
  type: TYPE_NORMAL
- en: Having completed this book, you should now have a better understanding of how
    to use Unreal Engine 4 to make your own games come to life. We've covered a lot
    of topics in this book, ranging from the simple to more advanced. You started
    out by learning how to create projects using the different templates and how to
    use blueprints to create actors and components. You then saw how to create a fully
    functioning Third Person template from scratch by importing and setting up the
    required assets, setting up the animation blueprint and Blend Space, and creating
    your own game mode and character, as well as defining and handling the inputs.
  prefs: []
  type: TYPE_NORMAL
- en: You then moved on to your first project; a simple stealth game that uses game
    physics and collisions, projectile movement components, actor components, interfaces,
    blueprint function libraries, UMG, sounds, and particle effects. Following this,
    you learned how to create a simple side-scrolling game by using AI, Anim Montages,
    and Destructible Meshes. Finally, you discovered how to create a first-person
    multiplayer shooter by using the Server-Client architecture, variable replication,
    and RPCs that come with the Network Framework, and learned how the Player State,
    Game State, and Game Mode classes work.
  prefs: []
  type: TYPE_NORMAL
- en: By working on various projects that use different parts of the engine, you now
    have a strong understanding of how Unreal Engine 4 works, and although this is
    the end of this book, it is just the start of your journey into the world of game
    development using Unreal Engine 4.
  prefs: []
  type: TYPE_NORMAL
