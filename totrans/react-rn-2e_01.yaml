- en: Why React?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you're reading this book, you might already have some idea of what React
    is. You also might have heard a React success story or two. If not, don't worry.
    I'll do my best to spare you from additional marketing literature in this opening
    chapter. However, this is a large book, with a lot of content, so I feel that
    setting the tone is an appropriate first step. Yes, the goal is to learn React
    and React Native. But, it's also to put together a lasting architecture that can
    handle everything we want to build with React today, and in the future.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter starts with a brief explanation of why React exists. Then, we'll
    talk about the simplicity that makes React an appealing technology and how React
    is able to handle many of the typical performance issues faced by web developers.
    Next, we'll go over the declarative philosophy of React and the level of abstraction
    that React programmers can expect to work with. Finally, we'll touch on some of
    the major new features of React 16.
  prefs: []
  type: TYPE_NORMAL
- en: Let's go!
  prefs: []
  type: TYPE_NORMAL
- en: What is React?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I think the one-line description of React on its home page ([https://facebook.github.io/react](https://facebook.github.io/react)))
    is brilliant:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"A JavaScript library for building user interfaces."*'
  prefs: []
  type: TYPE_NORMAL
- en: It's a library for building user interfaces. This is perfect because as it turns
    out, this is all we want most of the time. I think the best part about this description
    is everything that it leaves out. It's not a mega framework. It's not a full-stack
    solution that's going to handle everything from the database to real-time updates
    over web socket connections. We don't actually want most of these pre-packaged
    solutions, because in the end, they usually cause more problems than they solve.
  prefs: []
  type: TYPE_NORMAL
- en: React is just the view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'React is generally thought of as the *view* layer in an application. You might
    have used a library such as Handlebars or jQuery in the past. Just like jQuery
    manipulates UI elements, or Handlebars templates are inserted onto the page, React
    components change what the user sees. The following diagram illustrates where
    React fits in our frontend code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/1df1b7e1-3681-4845-8f34-9e75d6569c10.png)'
  prefs: []
  type: TYPE_IMG
- en: This is literally all there is to React—the core concept. Of course there will
    be subtle variations to this theme as we make our way through the book, but the
    flow is more or less the same. We have some application logic that generates some
    data. We want to render this data to the UI, so we pass it to a React component,
    which handles the job of getting the HTML into the page.
  prefs: []
  type: TYPE_NORMAL
- en: You may wonder what the big deal is, especially since at the surface, React
    appears to be yet another rendering technology. We'll touch on some of the key
    areas where React can simplify application development in the remaining sections
    of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Simplicity is good
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'React doesn''t have many moving parts to learn about and understand. Internally,
    there''s a lot going on, and we''ll touch on these things here and there throughout
    the book. The advantage to having a small API to work with is that you can spend
    more time familiarizing yourself with it, experimenting with it, and so on. The
    opposite is true of large frameworks, where all your time is devoted to figuring
    out how everything works. The following diagram gives a rough idea of the APIs
    that we have to think about when programming with React:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/eae05f1a-d2bc-4099-a59e-06c9d921eb2d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'React is divided into two major APIs. First, there''s the React DOM. This is
    the API that''s used to perform the actual rendering on a web page. Second, there''s
    the React component API. These are the parts of the page that are actually rendered
    by React DOM. Within a React component, we have the following areas to think about:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Data**: This is data that comes from somewhere (the component doesn''t care
    where), and is rendered by the component.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lifecycle**: These are methods that we implement that respond to changes
    in the lifecycle of the component. For example, the component is about to be rendered.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Events**: This is code that we write for responding to user interactions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**JSX**: This is the syntax of React components used to describe UI structures.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don't fixate on what these different areas of the React API represent just yet.
    The takeaway here is that React, by nature, is simple. Just look at how little
    there is to figure out! This means that we don't have to spend a ton of time going
    through API details here. Instead, once you pick up on the basics, we can spend
    more time on nuanced React usage patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Declarative UI structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React newcomers have a hard time coming to grips with the idea that components
    mix markup in with their JavaScript. If you've looked at React examples and had
    the same adverse reaction, don't worry. Initially, we're all skeptical of this
    approach, and I think the reason is that we've been conditioned for decades by
    the **separation of concerns** principle. Now, whenever we see things mixed together,
    we automatically assume that this is bad and shouldn't happen.
  prefs: []
  type: TYPE_NORMAL
- en: The syntax used by React components is called **JSX** (**JavaScript XML**).
    A component renders content by returning some JSX. The JSX itself is usually HTML
    markup, mixed with custom tags for the React components. The specifics don't matter
    at this point; we'll get into details in the coming chapters. What's absolutely
    groundbreaking here is that we don't have to perform little micro-operations to
    change the content of a component.
  prefs: []
  type: TYPE_NORMAL
- en: Although I won't be following the convention in this book, some React developers
    prefer the `.jsx` extension instead of `.js` for their components.
  prefs: []
  type: TYPE_NORMAL
- en: For example, think about using something like jQuery to build your application.
    You have a page with some content on it, and you want to add a class to a paragraph
    when a button is clicked. Performing these steps is easy enough. This is called
    **imperative programming**, and it's problematic for UI development. While this
    example of changing the class of an element in response to an event is simple,
    real applications tend to involve more than three or four steps to make something
    happen.
  prefs: []
  type: TYPE_NORMAL
- en: React components don't require executing steps in an imperative way to render
    content. This is why JSX is so central to React components. The XML-style syntax
    makes it easy to describe what the UI should look like. That is, what are the
    HTML elements that this component is going to render? This is called **declarative
    programming**, and is very well suited for UI development.
  prefs: []
  type: TYPE_NORMAL
- en: Time and data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another area that''s difficult for React newcomers to grasp is the idea that
    JSX is like a static string, representing a chunk of rendered output. This is
    where time and data come into play. React components rely on data being passed
    into them. This data represents the dynamic aspects of the UI. For example, a
    UI element that''s rendered based on a Boolean value could change the next time
    the component is rendered. Here''s an illustration of the idea:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/81ae1649-8ce0-4024-a22e-aad9c53a364b.png)'
  prefs: []
  type: TYPE_IMG
- en: Each time the React component is rendered, it's like taking a snapshot of the
    JSX at that exact moment in time. As your application moves forward through time,
    you have an ordered collection of rendered user interface components. In addition
    to declaratively describing what a UI should be, re-rendering the same JSX content
    makes things much easier for developers. The challenge is making sure that React
    can handle the performance demands of this approach.
  prefs: []
  type: TYPE_NORMAL
- en: Performance matters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using React to build user interfaces means that we can declare the structure
    of the UI with JSX. This is less error-prone than the imperative approach to assembling
    the UI piece by piece. However, the declarative approach does present us with
    one challenge: **performance**.'
  prefs: []
  type: TYPE_NORMAL
- en: For example, having a declarative UI structure is fine for the initial rendering,
    because there's nothing on the page yet. So, the React renderer can look at the
    structure declared in JSX, and render it into the DOM browser.
  prefs: []
  type: TYPE_NORMAL
- en: '**DOM** stands for **Document Object Model**, and represents HTML in the browser
    after it has been rendered. The DOM API is how JavaScript is able to change content
    on the page.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This concept is illustrated in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/acea7504-94d5-4687-b33b-48c3e27a766c.png)'
  prefs: []
  type: TYPE_IMG
- en: On the initial render, React components and their JSX are no different from
    other template libraries. For instance, Handlebars will render a template to HTML
    markup as a string, which is then inserted into the browser DOM. Where React is
    different from libraries such as Handlebars is when data changes and we need to
    re-render the component. Handlebars will just rebuild the entire HTML string,
    the same way it did on the initial render. Since this is problematic for performance,
    we often end up implementing imperative workarounds that manually update tiny
    bits of the DOM. We end up with a tangled mess of declarative templates and imperative
    code to handle the dynamic aspects of the UI.
  prefs: []
  type: TYPE_NORMAL
- en: We don't do this in React. This is what sets React apart from other view libraries.
    Components are declarative for the initial render, and they stay this way even
    as they're re-rendered. It's what React does under the hood that makes re-rendering
    declarative UI structures possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'React has something called the **virtual DOM**, which is used to keep a representation
    of the real DOM elements in memory. It does this so that each time we re-render
    a component, it can compare the new content to the content that''s already displayed
    on the page. Based on the difference, the virtual DOM can execute the imperative
    steps necessary to make the changes. So not only do we get to keep our declarative
    code when we need to update the UI, React will also make sure that it''s done
    in a performant way. Here''s what this process looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/cbf9b28a-c045-438e-b0f5-0e77bb63f85d.png)When you read about React,
    you''ll often see words such as **diffing** and **patching**. Diffing means comparing
    old content with new content to figure out what''s changed. Patching means executing
    the necessary DOM operations to render the new content.'
  prefs: []
  type: TYPE_NORMAL
- en: Like any other JavaScript library, React is constrained by the run-to-completion
    nature of the main thread. For example, if the React internals are busy diffing
    content and patching the DOM, the browser can't respond to user input. As you'll
    see in the last section of this chapter, changes were made to the internal rendering
    algorithms in React 16 to mitigate these performance pitfalls.
  prefs: []
  type: TYPE_NORMAL
- en: The right level of abstraction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another topic I want to cover at a high level before we dive into React code
    is **abstraction**. React doesn't have a lot of it, and yet the abstractions that
    React implements are crucial to its success.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding section, you saw how JSX syntax translates to low-level operations
    that we have no interest in maintaining. The more important way to look at how
    React translates our declarative UI components is the fact that we don't necessarily
    care what the render target is. The render target happens to be the browser DOM
    with React, but it isn't restricted to the browser DOM.
  prefs: []
  type: TYPE_NORMAL
- en: React has the potential to be used for any user interface we want to create,
    on any conceivable device. We're only just starting to see this with React Native,
    but the possibilities are endless. I personally will not be surprised when React
    Toast becomes a thing, targeting toasters that can singe the rendered output of
    JSX on to bread. The abstraction level with React is at the right level, and it's
    in the right place.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram gives you an idea of how React can target more than just
    the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/25d52f31-da33-4d24-bb90-4c61f319fcc8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'From left to right, we have React Web (just plain React), React Native, React
    Desktop, and React Toast. As you can see, to target something new, the same pattern
    applies:'
  prefs: []
  type: TYPE_NORMAL
- en: Implement components specific to the target
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement a React renderer that can perform the platform-specific operations
    under the hood
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Profit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is obviously an oversimplification of what's actually implemented for any
    given React environment. But the details aren't so important to us. What's important
    is that we can use our React knowledge to focus on describing the structure of
    our user interface on any platform.
  prefs: []
  type: TYPE_NORMAL
- en: React Toast will probably never be a thing, unfortunately.
  prefs: []
  type: TYPE_NORMAL
- en: What's new in React 16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, I want to highlight the major changes and the new features
    of React 16\. I'll go into more detail about the given changes as we encounter
    them in the subsequent chapters throughout the book.
  prefs: []
  type: TYPE_NORMAL
- en: Core architecture revamped
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Perhaps the biggest change in React 16 is to the internal reconciliation code.
    These changes don't impact the way that you interact with the React API. Instead,
    these changes were made to address some pain points that were preventing React
    from scaling up in certain situations. For example, one of the main concepts from
    this new architecture is that of a fiber. Instead of rendering every component
    on the page in a run-to-compilation way, React renders fibers—smaller chunks of
    the page that can be prioritized and rendered asynchronously.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a more in depth look at this new architecture, these resources should be
    helpful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/acdlite/react-fiber-architecture](https://github.com/acdlite/react-fiber-architecture)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://reactjs.org/blog/2017/09/26/react-v16.0.html](https://reactjs.org/blog/2017/09/26/react-v16.0.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lifecycle methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React 16 had to revamp some of the lifecycle methods that are available to class
    components. Some lifecycle methods are deprecated and will eventually be removed.
    There are new lifecycle methods to replace them. The main issue is that the deprecated
    lifecycle methods encourage coding in ways that doesn't work well with the new
    async React core.
  prefs: []
  type: TYPE_NORMAL
- en: For more on these lifecycle methods, visit this page: [https://reactjs.org/blog/2018/03/27/update-on-async-rendering.html](https://reactjs.org/blog/2018/03/27/update-on-async-rendering.html).
  prefs: []
  type: TYPE_NORMAL
- en: Context API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React has always provided a context API for developers, but it was always considered
    experimental. Context is an alternative approach to passing data from one component
    to the next. For example, using properties, you can pass data through a tree of
    components that is several layers deep. The components in the middle of this tree
    don't actually use any of these properties—they're just acting as intermediaries.
    This becomes problematic as your application grows because you have lots of props
    in your source that add to the complexity.
  prefs: []
  type: TYPE_NORMAL
- en: The new context API in React 16.3 is more official and provides a way for you
    to supply your components with data at any tree level. You can read more about
    the new context API here: [https://reactjs.org/docs/context.html](https://reactjs.org/docs/context.html).
  prefs: []
  type: TYPE_NORMAL
- en: Rendering fragments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If your React component renders several sibling elements, say three `<p>` elements
    for instance, you would have to wrap them in a `<div>` because React would only
    allow components to return a single element. The only problem with this approach
    is that it leads to a lot of unnecessary DOM structure. Wrapping your elements
    with `<Fragment>` is the same idea as wrapping them with a `<div>`, except there
    won't be any superfluous DOM elements.
  prefs: []
  type: TYPE_NORMAL
- en: You can read more about fragments here: [https://reactjs.org/docs/fragments.html](https://reactjs.org/docs/fragments.html).
  prefs: []
  type: TYPE_NORMAL
- en: Portals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a React component returns content, it gets rendered into its parent component.
    Then, that parent's content gets rendered into its parent component and so on,
    all the way to the tree root. There are times when you want to render something
    that specifically targets a DOM element. For example, a component that should
    be rendered as a dialog probably doesn't need to be mounted at the parent. Using
    a portal, you can control specifically where your component's content is rendered.
  prefs: []
  type: TYPE_NORMAL
- en: You can read more about portals here: [https://reactjs.org/docs/portals.html](https://reactjs.org/docs/portals.html).
  prefs: []
  type: TYPE_NORMAL
- en: Rendering lists and strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Prior to React 16, components had to return either an HTML element or another
    React component as its content. This can restrict how you compose your application.
    For example, you might have a component that is responsible for generating an
    error message. You used to have to wrap these strings in HTML tags in order to
    be considered valid React component output. Now you can just return the string.
    Similarly, you can just return a list of strings or a list of elements.
  prefs: []
  type: TYPE_NORMAL
- en: The blog post introducing React 16 has more details on this new functionality: [https://reactjs.org/blog/2017/09/26/react-v16.0.html](https://reactjs.org/blog/2017/09/26/react-v16.0.html).
  prefs: []
  type: TYPE_NORMAL
- en: Handling errors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Error handling in React can be difficult. Where exactly do you handle errors?
    If a component handles a JavaScript exception and sets an error state on the component
    to true, how do you reset this state? In React 16, there are error boundaries.
    Error boundaries are created by implementing the `componentDidCatch()` lifecycle
    method in a component. This component can then serve as the error boundary by
    wrapping other components. If any of the wrapped components throws an exception,
    the error boundary component can render alternative content.
  prefs: []
  type: TYPE_NORMAL
- en: Having error boundaries in place like this allows you to structure your components
    in a way that best suits your application. You can read more about error boundaries
    here: [https://reactjs.org/docs/error-boundaries.html](https://reactjs.org/docs/error-boundaries.html).
  prefs: []
  type: TYPE_NORMAL
- en: Server-side rendering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Server-side rendering** (**SSR**) in React can be difficult to wrap your
    head around. You''re rendering on the server, then rendering on the client too?
    Since the SSR pattern has become more prevalent, the React team has made it easier
    to work with in React 16\. In addition, there are a number of internal performance
    gains as well as efficiency gains by enabling streaming rendered content to the
    client.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to read more about SSR in React 16, I recommend the following resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://hackernoon.com/whats-new-with-server-side-rendering-in-react-16-9b0d78585d67](https://hackernoon.com/whats-new-with-server-side-rendering-in-react-16-9b0d78585d67)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://reactjs.org/docs/react-dom-server.html](https://reactjs.org/docs/react-dom-server.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you were introduced to React at a high level. React is a library,
    with a small API, used to build user interfaces. Next, you were introduced to
    some of the key concepts of React. First, we discussed the fact that React is
    simple, because it doesn't have a lot of moving parts. Next, we looked at the
    declarative nature of React components and JSX. Then, you learned that React takes
    performance seriously, and that this is how we're able to write declarative code
    that can be re-rendered over and over. Next, you learned about the idea of render
    targets and how React can easily become the UI tool of choice for all of them.
    Lastly, I gave a rough overview of what's new in React 16.
  prefs: []
  type: TYPE_NORMAL
- en: That's enough introductory and conceptual stuff for now. As we make our way
    toward the end of the book, we'll revisit these ideas. For now, let's take a step
    back and nail down the basics, starting with JSX.
  prefs: []
  type: TYPE_NORMAL
- en: Test your knowledge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is a declarative UI structure and how does React support this idea?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A declarative UI is built from components that are all declared before they're
    used. React will fail to render if all components aren't declared upfront.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Declarative UI structures define what the UI component is instead of worrying
    about how it is defined. React supports this idea by allowing components to be
    declared using JSX syntax.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Declarative UI structures are entirely optional in React. You can just as easily
    follow an imperative approach.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does React improve rendering performance?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: React has a virtual DOM that compares changes made to components' data in memory,
    avoiding the browser DOM when possible. React 16 has a new internal architecture
    that allows rendering to be split up into smaller chunks of work and prioritized.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: React sets up web workers so that whenever possible, work is parallelized.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: React doesn't focus on performance, instead relying on incremental browser performance
    improvements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When would you render a fragment?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fragments are used when you need a placeholder in your rendered content.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fragments are used to improve the performance of its child elements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fragments are used to avoid having to render unnecessary DOM elements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Take a look at the following links for more information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://facebook.github.io/react](https://facebook.github.io/react)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/acdlite/react-fiber-architecture](https://github.com/acdlite/react-fiber-architecture)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://reactjs.org/blog/2017/09/26/react-v16.0.html](https://reactjs.org/blog/2017/09/26/react-v16.0.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://reactjs.org/blog/2018/03/27/update-on-async-rendering.html](https://reactjs.org/blog/2018/03/27/update-on-async-rendering.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://reactjs.org/docs/context.html](https://reactjs.org/docs/context.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://reactjs.org/docs/fragments.html](https://reactjs.org/docs/fragments.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://reactjs.org/docs/portals.html](https://reactjs.org/docs/portals.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://reactjs.org/blog/2017/09/26/react-v16.0.html](https://reactjs.org/blog/2017/09/26/react-v16.0.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://reactjs.org/docs/error-boundaries.html](https://reactjs.org/docs/error-boundaries.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://hackernoon.com/whats-new-with-server-side-rendering-in-react-16-9b0d78585d67](https://hackernoon.com/whats-new-with-server-side-rendering-in-react-16-9b0d78585d67)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://reactjs.org/docs/react-dom-server.html](https://reactjs.org/docs/react-dom-server.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/facebook/react/wiki/Sites-Using-React](https://github.com/facebook/react/wiki/Sites-Using-React)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
