- en: Chapter 5. Behavioral Patterns - Strategy, Chain of Responsibility, and Command
    Design Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。行为模式-策略，责任链和命令设计模式
- en: The last group of common patterns we are going to see are the behavioral patterns.
    Now, we aren't going to define structures or encapsulate object creation but we
    are going to deal with behaviors.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到的最后一组常见模式是行为模式。现在，我们不会定义结构或封装对象创建，而是要处理行为。
- en: What's to deal with in behavior patterns? Well, now we will encapsulate behaviors,
    for example, algorithms in the Strategy pattern or executions in the command pattern.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 行为模式中有什么要处理的？嗯，现在我们将封装行为，例如策略模式中的算法或命令模式中的执行。
- en: Correct Behavior design is the last step after knowing how to deal with object
    creation and structures. Defining the behavior correctly is the last step of good
    software design because, all in all, good software design lets us improve algorithms
    and fix errors easily while the best algorithm implementation will not save us
    from bad software design.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 正确的行为设计是在了解如何处理对象创建和结构之后的最后一步。正确定义行为是良好软件设计的最后一步，因为总的来说，良好的软件设计让我们能够轻松改进算法并轻松修复错误，而最佳算法实现将无法拯救我们免受糟糕的软件设计。
- en: Strategy design pattern
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 策略设计模式
- en: The Strategy pattern is probably the easiest to understand of the Behavioral
    patterns. We have used it a few times while developing the previous patterns but
    without stopping to talk about it. Now we will.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 策略模式可能是行为模式中最容易理解的。在开发之前的模式时，我们已经使用了几次，但没有停下来谈论它。现在我们将。
- en: Description
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 描述
- en: The Strategy pattern uses different algorithms to achieve some specific functionality.
    These algorithms are hidden behind an interface and, of course, they must be interchangeable.
    All algorithms achieve the same functionality in a different way. For example,
    we could have a `Sort` interface and few sorting algorithms. The result is the
    same, some list is sorted, but we could have used quick sort, merge sort, and
    so on.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 策略模式使用不同的算法来实现特定功能。这些算法隐藏在接口后面，并且它们必须是可互换的。所有算法以不同的方式实现相同的功能。例如，我们可以有一个`Sort`接口和一些排序算法。结果是相同的，某个列表被排序，但我们可以使用快速排序，归并排序等。
- en: Can you guess when we used a Strategy pattern in the previous chapters? Three,
    two, one... Well, we heavily used the strategy pattern when we used the `io.Writer`
    interface. The `io.Writer` interface defines a strategy to write, and the functionality
    is always the same--to write something. We could write it to the standard out,
    to some file or to a user-defined type, but we do the same thing at the end--to
    write. We just change the strategy to write (in this case, we change the place
    where we write).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 你能猜到我们在前几章中何时使用了策略模式吗？ 三，二，一...嗯，在我们使用`io.Writer`接口时，我们大量使用了策略模式。 `io.Writer`接口定义了写入的策略，功能始终相同-写入某些内容。我们可以将其写入标准输出，写入某个文件或写入用户定义的类型，但最终做的事情是相同的-写入。我们只是改变了写入的策略（在这种情况下，我们改变了写入的位置）。
- en: Objectives
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标
- en: 'The objectives of the Strategy pattern are really clear. The pattern should
    do the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 策略模式的目标非常明确。模式应该做到以下几点：
- en: Provide a few algorithms to achieve some specific functionality
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供一些算法来实现特定功能
- en: All types achieve the same functionality in a different way but the client of
    the strategy isn't affected
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有类型以不同的方式实现相同的功能，但策略的客户端不受影响
- en: The problem is that this definition covers a huge spectrum of possibilities.
    This is because Strategy pattern is actually used for a variety of scenarios and
    many software engineering solutions come with some kind of strategy within. Therefore
    it's better to see it in action with a real example.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于这个定义涵盖了广泛的可能性。这是因为策略模式实际上用于各种场景，并且许多软件工程解决方案都包含某种策略。因此最好通过一个真实的例子来看它的实际应用。
- en: Rendering images or text
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 渲染图像或文本
- en: We are going to do something different for this example. Instead of printing
    text on the console only, we are also going to paint objects on a file.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我们将做一些不同的事情。我们不仅要在控制台上打印文本，还要在文件上绘制对象。
- en: 'In this case, we will have two strategies: console and file. But the user of
    the library won''t have to deal with the complexity behind them.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将有两种策略：控制台和文件。但是库的用户不必处理它们背后的复杂性。
- en: 'The key feature is that the "caller" doesn´t know how the underlying library
    is working and he just knows the information available on the defined strategy.
    This is nicely seen on the following diagram:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 关键特征是“调用者”不知道底层库是如何工作的，他只知道定义的策略上可用的信息。这在下图中很明显：
- en: '![Rendering images or text](img/B05557_05_01-300x136.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![渲染图像或文本](img/B05557_05_01-300x136.jpg)'
- en: In this diagram, we have chosen to print to console but we won´t deal with the
    **ConsoleStrategy** type directly, we´ll always use an interface that represents
    it. The **ConsoleStrategy** type will hide the implementation details of printing
    to console to caller in `main` function. **FileStrategy** hides its implementation details
    as well as any future strategy.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图表中，我们选择打印到控制台，但我们不会直接处理**ConsoleStrategy**类型，我们将始终使用代表它的接口。**ConsoleStrategy**类型将隐藏打印到控制台的实现细节给`main`函数中的调用者。**FileStrategy**也隐藏其实现细节以及任何未来的策略。
- en: Acceptance criteria
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验收标准
- en: 'A strategy must have a very clear objective and we will have two ways to achieve
    it. Our objectives will be as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 策略必须有一个非常明确的目标，我们将有两种实现它的方式。我们的目标将如下：
- en: Provide a way to show to the user an object (a square) in text or image
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供一种方法向用户显示文本或图像中的对象（正方形）
- en: The user must choose between image or text when launching the app
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户在启动应用程序时必须选择图像或文本
- en: The app must be able to add more visualization strategies (audio, for example)
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序必须能够添加更多的可视化策略（例如音频）
- en: If the user selects text, the word *Square* must be printed in the console
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果用户选择文本，则必须在控制台中打印单词* Square *
- en: If the user selects image, an image of a white square on a black background
    will be printed on a file
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果用户选择图像，将在文件上打印一个白色正方形在黑色背景上的图像
- en: Implementation
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实施
- en: 'We aren''t going to write tests for this example as it will be quite complicated
    to check that an image has appeared on the screen (although not impossible by
    using **OpenCV**, an impressive library for computer vision). We will start directly
    by defining our strategy interface that each printing strategy must implement
    (in our case, the file and console types):'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不打算为这个例子编写测试，因为检查图像是否出现在屏幕上将会非常复杂（虽然使用**OpenCV**，一个令人印象深刻的计算机视觉库，这并非不可能）。我们将直接开始定义每个打印策略必须实现的策略接口（在我们的情况下，文件和控制台类型）：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'That''s all. Our strategy defines a simple `Print()` method that returns an
    `error` (the error-returning type is mandatory when dealing with files, for example).
    The types that needs to implement `PrintStrategy` will be called `ConsoleSquare`
    and a `ImageSquare` type:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了。我们的策略定义了一个简单的`Print()`方法，返回一个`error`（在处理文件时，必须返回错误类型）。需要实现`PrintStrategy`的类型将被称为`ConsoleSquare`和`ImageSquare`类型：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `ConsoleSquare` struct doesn''t need any inner field because it will always
    print the word `Square` to the console. The `ImageSquare` struct will store a
    field for the destination of the image file where we will print the square. We
    will start with the implementation of the `ConsoleSquare` type as it is the simplest:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConsoleSquare`结构不需要任何内部字段，因为它将始终将单词`Square`打印到控制台。`ImageSquare`结构将存储一个字段，用于打印正方形的图像文件的目的地。我们将从实现`ConsoleSquare`类型开始，因为它是最简单的：'
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Very easy, but the image is more complex. We won''t spend too much time in
    explaining in detail how the `image` package works because the code is easily
    understandable:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 非常简单，但图像更复杂。我们不会花太多时间详细解释`image`包的工作原理，因为代码很容易理解：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'However, here is a short explanation:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这里有一个简短的解释：
- en: We define a size for the image (`width` and `height` variables) of 800 pixels
    of width and 600 pixels of height. Those are going to be the size limits of our
    image and anything that we write outside of that size won't be visible.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们为图像定义了一个大小（`width`和`height`变量），宽度为800像素，高度为600像素。这些将是我们图像的大小限制，任何超出该大小的内容都将不可见。
- en: The `origin` variable stores an `image.Point`, a type to represent a position
    in any two-dimensional space. We set the position of this point at *(0, 0)*, the
    upper-left corner of the image.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`origin`变量存储一个`image.Point`，表示任何二维空间中的位置的类型。我们将此点的位置设置为*(0, 0)*，即图像的左上角。'
- en: We need a bitmap that will represent our background, here we called it `bgImage`.
    We have a very handy function in the image package to create the `image.RGBA`
    types called `image.NewRGBA`. We need to pass a rectangle to this function so
    that it knows the bounds of the image. A rectangle is represented by two `image.Point`
    types--its upper left corner point (the `Min` field) and its lower right corner
    point (the `Max` field). We use `origin` as the upper-left and a new point with
    the values of `width` and `height` as the lower-right point.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要一个位图来表示我们的背景，这里我们称之为`bgImage`。在图像包中有一个非常方便的函数，用于创建`image.RGBA`类型，称为`image.NewRGBA`。我们需要向此函数传递一个矩形，以便它知道图像的边界。矩形由两个`image.Point`类型表示--它的左上角点（`Min`字段）和它的右下角点（`Max`字段）。我们使用`origin`作为左上角，一个具有`width`和`height`值的新点作为右下角点。
- en: The image will have a gray background color (`bgColor`). This is done by instancing
    a type of `image.Uniform`, which represents a uniform color (hence the name).
    The `image.Uniform` type needs an instance of a `color.Color` interface. A `color.Color`
    type is any type that implements the `RGBA() (r, g, b, a uint32)`  method to return
    a `uint32` value for red, green, blue, and alpha colors (RGBA). Alpha is a value
    for the transparency of a pixel. The `color` package conveniently provides a type
    called `color.RGBA` for this purpose (in case we don't need to implement our own,
    which is our case).
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图像将具有灰色背景颜色（`bgColor`）。这是通过实例化`image.Uniform`类型来实现的，该类型表示均匀颜色（因此得名）。`image.Uniform`类型需要`color.Color`接口的实例。`color.Color`类型是实现`RGBA()
    (r, g, b, a uint32)`方法以返回红色、绿色、蓝色和alpha颜色（RGBA）的`uint32`值的任何类型（RGBA）。 Alpha是像素透明度的值。`color`包方便地提供了一个名为`color.RGBA`的类型（如果我们不需要实现自己的类型，这就是我们的情况）。
- en: When storing an image in certain formats, we have to specify the quality of
    the image. It will affect not only the quality but the size of the file, of course.
    Here, it is defined as 75; 100 is the maximum quality possible that we can set.
    As you can see, we are using the `jpeg` package here to set the value of a type
    called `Options` that simply stores the value of the quality, it doesn't have
    more values to apply.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在存储图像的某些格式时，我们必须指定图像的质量。当然，这不仅会影响质量，还会影响文件的大小。在这里，它被定义为75；100是我们可以设置的最大质量。正如您所看到的，我们在这里使用`jpeg`包来设置一个名为`Options`的类型的值，它只是存储质量的值，没有更多的值可应用。
- en: Finally, the `draw.Print` function writes the pixels on the supplied image (`bgImage`)
    with the characteristics that we have defined on the bounds defined by the same
    image. The first argument of the `draw.Print` method takes the destination image,
    where we used `bgImage`. The second argument is the bounds of the object to draw
    in the destination image, we used the same bounds of the image but we could use
    any other if we wanted a smaller rectangle. The third argument is the color to
    use to colorize the bounds. The `Origin` variable is used to tell where the upper-left
    corner of the bound must be placed. In this case, the bounds are the same size
    as the image so we need to set it to the origin. The last argument specified is
    the operation type; just leave it in the `draw.Src` argument.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，`draw.Print`函数将以我们在相同图像边界上定义的特征写入所提供的图像（`bgImage`）上的像素。`draw.Print`方法的第一个参数接受目标图像，我们使用了`bgImage`。第二个参数是要在目标图像中绘制的对象的边界，我们使用了图像的相同边界，但如果需要更小的矩形，我们也可以使用其他边界。第三个参数是要用于给边界上色的颜色。`Origin`变量用于告诉边界的左上角必须放置在哪里。在这种情况下，边界与图像大小相同，所以我们需要将其设置为原点。指定的最后一个参数是操作类型；只需将其保留在`draw.Src`参数中。
- en: 'Now we have to draw the square. The operation is essentially the same as to
    draw the background but, in this case, we are drawing a square over the previously
    drawn `bgImage`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们必须画正方形。这个操作本质上与绘制背景相同，但在这种情况下，我们是在之前绘制的`bgImage`上绘制一个正方形：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The square will be of 200*200 pixels of red color. When using the method `Add`,
    the `Rect` type origin is translated to the supplied point; this is to center
    the square on the image. We create an image with the square `Rect` and call the
    `Print` function on the `bgImage` image again to draw the red square over it:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 正方形将是200*200像素的红色。使用`Add`方法时，`Rect`类型的原点被转换为提供的点；这是为了将正方形居中放置在图像上。我们使用正方形`Rect`创建一个图像，并再次在`bgImage`图像上调用`Print`函数来绘制红色正方形：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Finally, we will create a file to store the contents of the image. The file
    will be stored in the path supplied in the `DestinationFilePath` field of the
    `ImageSquare` struct. To create a file, we use `os.Create` that returns the `*os.File`.
    As with every file, it must be closed after using it so don't forget to use the
    `defer` keyword to ensure that you close it when the method finishes.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将创建一个文件来存储图像的内容。文件将存储在`ImageSquare`结构的`DestinationFilePath`字段中提供的路径中。要创建文件，我们使用返回`*os.File`的`os.Create`。与每个文件一样，在使用后必须关闭它，因此不要忘记使用`defer`关键字来确保在方法完成时关闭它。
- en: Tip
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: To defer, or not to defer?
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 推迟，还是不推迟？
- en: Some people ask why the use of `defer` at all? Wouldn't it be the same to simply
    write it without `defer` at the end of the function? Well, actually not. If any
    error occurs during the method execution and you return this error, the `Close`
    method won't be executed if it's at the end of the function. You can close the
    file before returning but you'll have to do it in every error check. With `defer,`
    you don't have to worry about this because the deferred function is executed always
    (with or without error). This way, we ensure that the file is closed.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人问为什么要使用`defer`？不使用`defer`在函数末尾简单写入会不会一样？实际上并不是。如果在方法执行期间发生任何错误，并且您返回此错误，则如果它位于函数末尾，则`Close`方法将不会被执行。您可以在返回之前关闭文件，但您必须在每个错误检查中都这样做。使用`defer`，您不必担心这一点，因为延迟函数始终执行（无论有无错误）。这样，我们确保文件被关闭。
- en: 'To parse the arguments, we''ll use the `flag` package. We have used it before
    but let''s recall its usage. A flag is a command that the user can pass when executing
    our app. We can define a flag by using the `flag.[type]` methods defined in the
    `flag` package. We want to read the output that the user wants to use from the
    console. This flag will be called `output`. A flag can have a default value; in
    this case, it will have the value `console` that will be used when printing to
    console. So, if the user executes the program without arguments, it prints to
    console:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解析参数，我们将使用`flag`包。我们以前使用过它，但让我们回顾一下它的用法。标志是用户在执行我们的应用程序时可以传递的命令。我们可以使用`flag.[type]`方法在`flag`包中定义标志。我们想要从控制台读取用户想要使用的输出。这个标志将被称为`output`。标志可以有一个默认值；在这种情况下，当打印到控制台时，它将具有值`console`。
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Our final step is to write the main function:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的最后一步是编写主函数：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Remember that the first thing to do in the main when using flags is to parse
    them using the `flag.Parse()` method! It''s very common to forget this step:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，在使用标志时，主函数中的第一件事是使用`flag.Parse()`方法解析它们！很容易忘记这一步：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We define a variable for the strategy that the user has chosen, called `activeStrategy`.
    But check that the `activeStrategy` variable has the `PrintStrategy` type so it
    can be populated with any implementation of the `PrintStrategy` variable. We will
    set `activeStrategy` to a new instance of `TextSquare` when the user writes the 
    `**--output=console**`  command and an `ImageSquare` when we write the  `**--output=image**`
    command.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为用户选择的策略定义了一个变量，称为`activeStrategy`。但要检查`activeStrategy`变量是否具有`PrintStrategy`类型，以便可以用`PrintStrategy`变量的任何实现来填充它。当用户写入`**--output=console**`命令时，我们将`activeStrategy`设置为`TextSquare`的新实例，并在写入`**--output=image**`命令时设置为`ImageSquare`。
- en: 'Finally, here is the design pattern execution:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这是设计模式的执行：
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Our `activeStrategy` variable is a type implementing `PrintStrategy` and either
    the `TextSquare` or `ImageSquare` classes. The user will choose at runtime which
    strategy he wants to use for each particular case. Also, we could have written
    a factory method pattern to create strategies, so that the strategy creation will
    also be uncoupled from the main function and abstracted in a different independent
    package. Think about it: if we have the strategy creation in a different package,
    it will also allow us to use this project as a library and not only as a standalone
    app.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we will execute both strategies; the `TextSquare` instance will give us
    a square by printing the word `Square` on the console:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'It has worked as expected. Recalling how flags work, we have to use the `--` (double
    dash) and the defined flag, `output` in our case. Then you have two options--using
    `=` (equals) and immediately writing the value for the flag or writing `<space>`
    and the value for the flag. In this case, we have defined the default value of
    output to the console so the following three executions are equivalent:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now we have to try the file strategy. As defined before, the file strategy
    will print a red square to a file as an image with dark gray background:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Nothing happened? But everything worked correctly. This is actually bad practice.
    Users must always have some sort of feedback when using your app or your library.
    Also, if they are using your code as a library, maybe they have a specific format
    for output so it won't be nice to directly print to the console. We will solve
    this issue later. Right now, open the folder `/tmp` with your favourite file explorer
    and you will see a file called `image.jpg` with our red square in a dark grey
    background.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Solving small issues in our library
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have a few issues in our code:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: It cannot be used as a library. We have critical code written in the `main`
    package (strategy creation).
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Solution**: Abstract to two different packages the strategy creation from
    the command-line application.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: None of the strategies are doing any logging to file or console. We must provide
    a way to read some logs that an external user can integrate in their logging strategies
    or formats.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Solution**: Inject an `io.Writer` interface as dependency to act as a logging
    sink.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: Our `TextSquare` class is always writing to the console (an implementer of the `io.Writer`
    interface) and the `ImageSquare` is always writing to file (another implementer
    of the `io.Writer` interface). This is too coupled.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Solution**: Inject an `io.Writer` interface so that the `TextSquare` and
    `ImageSquare` can write to any of the `io.Writer` implementations that are available
    (file and console, but also bytes buffer, binary encoders, `JSON` handlers...
    dozens of packages).'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: 'So, to use it as a library and solve the first issue, we will follow a common
    approach in Go file structures for apps and libraries. First, we will place our
    main package and function outside of the root package; in this case, in a folder
    called `cli`. It is also common to call this folder `cmd` or even `app`. Then,
    we will place our `PrintStrategy` interface in the root package, which now will
    be called the `strategy` package. Finally, we will create a `shapes` package in
    a folder with the same name where we will put both text and image strategies.
    So, our file structure will be like this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '**Root package**: strategy'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'File: `print_strategy.go`'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '**SubPackage**: shapes'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Files: `image.go`, `text.go`, `factory.go`'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '**SubPackage**: cli'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'File: `main.go`'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to modify our interface a bit to fit the needs we have written
    previously:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We have added the `SetLog(io.Writer)` method to add a logger strategy to our
    types; this is to provide feedback to users. Also, it has a `SetWriter` method
    to set the `io.Writer` strategy. This interface is going to be located on the
    root package in the `print_strategy.go` file. So the final schema looks like this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '![Solving small issues in our library](img/B05557_05_02-300x127.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![在我们的库中解决小问题](img/B05557_05_02-300x127.jpg)'
- en: 'Both the `TextSquare` and `ImageSquare` strategies have to satisfy the `SetLog`
    and `SetWriter` methods which simply store some object on their fields so, instead
    of implementing the same twice, we can create a struct that implements them and
    embed this struct in the strategies. By the way, this would be the composite pattern
    we have seen previously:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`TextSquare`和`ImageSquare`策略都必须满足`SetLog`和`SetWriter`方法，这些方法只是简单地在它们的字段上存储一些对象，所以我们可以创建一个实现它们的结构，并将这个结构嵌入到策略中，而不是重复实现两次。顺便说一句，这就是我们之前看到的组合模式：'
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: So now each strategy must have the `PrintOutput` struct embedded if we want
    to modify their `Writer` and `logger` fields.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 所以现在每个策略必须嵌入`PrintOutput`结构，如果我们想修改它们的`Writer`和`logger`字段。
- en: 'We also need to modify our strategy implementation. The `TextSquare` struct now
    needs a field to store the output `io.Writer` (the place where it is going to
    write instead of writing always to the console) and the `log` writer. These two
    fields can be provided by embedding the `PrintOutput` struct. The `TextSquare` struct
    is also stored in the file `text.go` within the shapes package. So, the struct
    is now like this:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要修改我们的策略实现。`TextSquare`结构现在需要一个字段来存储输出的`io.Writer`（它将写入的地方，而不是总是写入控制台）和`log`写入器。这两个字段可以通过嵌入`PrintOutput`结构来提供。`TextSquare`结构也存储在shapes包的文件`text.go`中。因此，该结构现在是这样的：
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'So now the `Print()` method is slightly different because, instead of writing
    directly to the console by using the `println` function, we have to write whichever
    `io.Writer` is stored in the `Writer` field:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 所以现在`Print()`方法略有不同，因为我们不再直接使用`println`函数写入控制台，而是要写入存储在`Writer`字段中的任何`io.Writer`：
- en: '[PRE16]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `bytes.NewReader` is a very useful function that takes an array of bytes
    and converts them to an `io.Reader` interface. We need an `io.Reader` interface
    to use the `io.Copy` function. The `io.Copy` function is also incredibly useful
    as it takes an `io.Reader` (as the second parameter) and pipes it to an `io.Writer`
    (its first parameter). So, we won''t return an error in any case. However, it''s
    easier to do so using directly the `Write` method of `t.Writer`:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`bytes.NewReader`是一个非常有用的函数，它接受一个字节数组并将其转换为`io.Reader`接口。我们需要一个`io.Reader`接口来使用`io.Copy`函数。`io.Copy`函数也非常有用，因为它接受一个`io.Reader`（作为第二个参数）并将其传输到一个`io.Writer`（作为第一个参数）。因此，在任何情况下我们都不会返回错误。然而，直接使用`t.Writer`的`Write`方法更容易：'
- en: '[PRE17]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You can use whichever method you like more. Usually, you will use the `Write`
    method but it's nice to know the `bytes.NewReader` function too.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用你更喜欢的任何方法。通常，你会使用`Write`方法，但了解`bytes.NewReader`函数也很好。
- en: Did you realize that when we use `t.Writer`, we are actually accessing `PrintOutput.Writer`?
    The `TextSquare` type has a `Writer` field because the `PrintOutput` struct has
    it and it's embedded on the `TextSquare` struct.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否注意到当我们使用`t.Writer`时，实际上是在访问`PrintOutput.Writer`？`TextSquare`类型有一个`Writer`字段，因为`PrintOutput`结构体有它，并且它被嵌入到`TextSquare`结构体中。
- en: Tip
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'Embedding is not inheritance. We have embedded the `PrintOutput` struct on
    the `TextSquare` struct. Now we can access `PrintOutput` fields as if they were
    in `TextSquare` fields. This feels a bit like inheritance but there is a very
    important difference here: `TextSquare` is not a `PrintOutput` value but it has
    a `PrintOutput` in its composition. What does it mean? That if you have a function
    that expects a `PrintOutput`, you cannot a pass `TextSquare` just because it has
    a `PrintOutput` embedded.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入不是继承。我们在`TextSquare`结构体中嵌入了`PrintOutput`结构体。现在我们可以像访问`TextSquare`字段一样访问`PrintOutput`字段。这感觉有点像继承，但这里有一个非常重要的区别：`TextSquare`不是`PrintOutput`值，而是在其组合中有一个`PrintOutput`。这是什么意思？如果你有一个期望`PrintOutput`的函数，你不能传递`TextSquare`，只是因为它嵌入了`PrintOutput`。
- en: But, if you have a function that accepts an interface that `PrintOutput` implements,
    you can pass `TextSquare` if it has a `PrintOutput` embedded. This is what we
    are doing in our example.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果你有一个接受`PrintOutput`实现的接口的函数，你可以传递`TextSquare`，如果它嵌入了`PrintOutput`。这就是我们在示例中所做的。
- en: 'The `ImageSquare` struct is now like the `TextSquare`, with a `PrintOutput`
    embedded:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`ImageSquare`结构现在与`TextSquare`类似，都嵌入了`PrintOutput`：'
- en: '[PRE18]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `Print` method also needs to be modified. Now, we aren''t creating a file
    from the `Print` method, as it was breaking the single responsibility principle.
    A file implements an `io.Writer` so we will open the file outside of the `ImageSquare`
    struct and inject it on the `Writer` field. So, we just need to modify the end
    of the `Print()` method where we wrote to the file:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`Print`方法也需要修改。现在，我们不再从`Print`方法中创建文件，因为这违反了单一职责原则。文件实现了`io.Writer`，所以我们将在`ImageSquare`结构体之外打开文件，并将其注入`Writer`字段。因此，我们只需要修改`Print()`方法的结尾，我们在其中写入文件：'
- en: '[PRE19]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If you check our previous implementation, after using `draw`, you can see that
    we used the `Print` method, we created a file with `os.Create` and passed it to
    the `jpeg.Encode` function. We have deleted this part about creating the file
    and we have replaced it with a check looking for a `Writer` in the fields (`if
    i.Writer != nil`). Then, on `jpeg.Encode` we can replace the file value we were
    using previously with the content of the `i.Writer` field. Finally, we are using
    `io.Copy` again to log some message to the `LogWriter` if a logging strategy is
    provided.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你检查我们之前的实现，在使用`draw`之后，你会发现我们使用了`Print`方法，我们用`os.Create`创建了一个文件，并将其传递给`jpeg.Encode`函数。我们已经删除了关于创建文件的部分，并用一个检查替换了它，查找字段中的`Writer`（`if
    i.Writer != nil`）。然后，在`jpeg.Encode`中，我们可以用之前使用的文件值替换`i.Writer`字段的内容。最后，如果提供了日志策略，我们再次使用`io.Copy`来将一些消息记录到`LogWriter`中。
- en: 'We also have to abstract the knowledge needed from the user to create instances
    of implementors of the `PrintStrategy` for which we are going to use a Factory
    method:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要从用户那里抽象出创建`PrintStrategy`实现者实例所需的知识，为此我们将使用工厂方法：
- en: '[PRE20]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We have two constants, one of each of our strategies: `TEXT_STRATEGY` and `IMAGE_STRATEGY`.
    Those are the constants that must be provided to the factory to retrieve each
    square drawer strategy. Our factory method receives an argument `s`, which is
    a string with one of the previous constants.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: Each strategy has a `PrintOutput` type embedded with a default logger to `stdout`
    but you can override it later by using the `SetLog(io.Writer)` methods. This approach
    could be considered a Factory of prototypes. If it is not a recognized strategy,
    a proper message error will be returned.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: 'What we have now is a library. We have all the functionality we need between
    the `strategy` and `shapes` packages. Now we will write the `main` package and
    function in a new folder called `cli`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Again, like before, the `main` function starts by parsing the input arguments
    on the console to gather the chosen strategy. We can use the variable output now
    to create a strategy without Factory:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: With this snippet, we have our strategy or we stop program execution in the
    `log.Fatal` method if any error is found (such as an unrecognized strategy).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we will implement the business needs by using our library. For the purpose
    of the `TextStrategy`, we want to write, for example, to `stdout`. For the purpose
    of the image, we will write to `/tmp/image.jpg`. Just like before. So, following
    the previous statements, we can write:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In the case of `TEXT_STRATEGY`, we use `SetWriter` to set the `io.Writer` to
    `os.Stdout`. In the case of `IMAGE_STRATEGY`, we create an image in any of our
    folders and pass the file variable to the `SetWriter` method. Remember that `os.File`
    implements the `io.Reader` and `io.Writer` interfaces, so it''s perfectly legal
    to pass it as an `io.Writer` to the `SetWriter` method:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Finally, we call the `Print` method of whichever strategy was chosen by the
    user and check for possible errors. Let''s try the program now:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: It has worked as expected. What about the image strategy?
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: If we check in `/tmp/image.jpg`, we can find our red square on the dark background.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: Final words on the Strategy pattern
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have learned a powerful way to encapsulate algorithms in different structs.
    We have also used embedding instead of inheritance to provide cross-functionality
    between types, which will come in handy very often in our apps. You'll find yourself
    combining strategies here and there as we have seen in the second example, where
    we have strategies for logging and writing by using the `io.Writer` interface,
    a strategy for byte-streaming operations.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: Chain of responsibility design pattern
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our next pattern is called **chain of responsibility**. As its name implies,
    it consists of a chain and, in our case, each link of the chain follows the single
    responsibility principle.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: Description
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The single responsibility principle implies that a type, function, method, or
    any similar abstraction must have one single responsibility only and it must do
    it quite well. This way, we can apply many functions that achieve one specific
    thing each to some struct, slice, map, and so on.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: When we apply many of these abstractions in a logical way very often, we can
    chain them to execute in order such as, for example, a logging chain.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: A logging chain is a set of types that logs the output of some program to more
    than one `io.Writer` interface. We could have a type that logs to the console,
    a type that logs to a file, and a type that logs to a remote server. You can make
    three calls every time you want to do some logging, but it's more elegant to make
    only one and provoke a chain reaction.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: But also, we could have a chain of checks and, in case one of them fails, break
    the chain and return something. This is the authentication and authorization middleware
    works.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: Objectives
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The objective of the chain of responsibility is to provide to the developer
    a way to chain actions at runtime. The actions are chained to each other and each
    link will execute some action and pass the request to the next link (or not).
    The following are the objectives followed by this pattern:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 责任链的目标是为开发人员提供一种在运行时链接操作的方法。这些操作相互链接，每个链接将执行某些操作并将请求传递给下一个链接（或不传递）。以下是此模式遵循的目标：
- en: Dynamically chain the actions at runtime based on some input
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在运行时根据某些输入动态地链接操作
- en: Pass a request through a chain of processors until one of them can process it,
    in which case the chain could be stopped
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过一系列处理器传递请求，直到其中一个可以处理它，此时链可能会停止
- en: A multi-logger chain
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多记录器链
- en: 'We are going to develop a multi-logger solution that we can chain in the way
    we want. We will use two different console loggers and one general-purpose logger:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开发一个多记录器解决方案，可以按我们想要的方式进行链接。我们将使用两个不同的控制台记录器和一个通用记录器：
- en: We need a simple logger that logs the text of a request with a prefix *First
    logger* and passes it to the next link in the chain.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要一个简单的记录器，记录带有前缀*First logger*的请求文本，并将其传递给链中的下一个链接。
- en: A second logger will write on the console if the incoming text has the word
    `hello` and pass the request to a third logger. But, if not, the chain will be
    broken and it will return immediately.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二个记录器将在控制台上写入文本，如果传入文本包含单词`hello`，则将请求传递给第三个记录器。但是，如果没有，则链将被中断并立即返回。
- en: A third logger type is a general purpose logger called `WriterLogger` that uses
    an `io.Writer` interface to log.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第三个记录器类型是一个名为`WriterLogger`的通用记录器，它使用`io.Writer`接口进行记录。
- en: A concrete implementation of the `WriterLogger` writes to a file and represents
    the third link in the chain.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`WriterLogger`的具体实现写入文件，代表链中的第三个链接。'
- en: 'The implementation of these steps is described in the following figure:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤的实现如下图所示：
- en: '![A multi-logger chain](img/B05557_05_03.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![多日志链](img/B05557_05_03.jpg)'
- en: Unit test
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试
- en: 'The very first thing to do for the chain is, as usual, to define the interface.
    A chain of responsibility interface will usually have, at least, a  `Next()` method.
    The `Next()` method is the one that executes the next link in the chain, of course:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 链的第一件事，通常是定义接口。责任链接口通常至少有一个`Next()`方法。`Next()`方法是执行链中下一个链接的方法：
- en: '[PRE27]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `Next` method on our example''s interface takes the message we want to
    log and passes it to the following link in the chain. As written in the acceptance
    criteria, we need three loggers:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们示例接口的`Next`方法接受我们想要记录的消息，并将其传递给链中的下一个链接。如验收标准所述，我们需要三个记录器：
- en: '[PRE28]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `FirstLogger` and `SecondLogger` types have exactly the same structure--both
    implement `ChainLogger` and have a `NextChain` field that points to the next `ChainLogger`.
    The `WriterLogger` type is equal to the `FirstLogger` and `SecondLogger` types
    but also has a field to write its data to, so you can pass any `io.Writer` interface
    to it.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`FirstLogger`和`SecondLogger`类型具有完全相同的结构--都实现`ChainLogger`，并具有指向下一个`ChainLogger`的`NextChain`字段。`WriterLogger`类型等同于`FirstLogger`和`SecondLogger`类型，但还具有一个字段用于将其数据写入，因此您可以将任何`io.Writer`接口传递给它。'
- en: 'As we have done before, we''ll implement an `io.Writer` struct to use in our
    testing. In our test file, we define the following struct:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 与以前一样，我们将实现一个`io.Writer`结构以在测试中使用。在我们的测试文件中，我们定义以下结构：
- en: '[PRE29]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We will pass an instance of the `myTestWriter` struct to `WriterLogger` so we
    can track what's being logged on testing. The `myTestWriter` class implements
    the common `Write([]byte) (int, error)` method from the `io.Writer` interface.
    Remember, if it has the `Write` method, it can be used as `io.Writer`. The `Write`
    method simply stored the string argument to the `receivedMessage` field so we
    can check later its value on tests.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将传递`myTestWriter`结构的实例给`WriterLogger`，以便在测试中跟踪被记录的内容。`myTestWriter`类实现了`io.Writer`接口的常见`Write([]byte)
    (int, error)`方法。请记住，如果它具有`Write`方法，它可以被用作`io.Writer`。`Write`方法简单地将字符串参数存储到`receivedMessage`字段中，以便我们稍后在测试中检查其值。
- en: 'This is the beginning of the first test function:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第一个测试函数的开始：
- en: '[PRE30]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Let's describe these few lines a bit as they are quite important. We create
    a variable with a default `myTestWriter` type that we'll use as an `io.Writer` interface
    in the last link of our chain. Then we create the last piece of the link chain,
    the `writerLogger` interface. When implementing the chain, you usually start with
    the last piece on the link and, in our case, it is a `WriterLogger`. The `WriterLogger`
    writes to an `io.Writer` so we pass `myWriter` as `io.Writer` interface.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们稍微描述一下这几行，因为它们非常重要。我们创建一个默认的`myTestWriter`类型的变量，我们将在链的最后一个链接中用作`io.Writer`接口。然后我们创建链的最后一部分，`writerLogger`接口。在实现链时，通常从链的最后一部分开始，在我们的例子中是`WriterLogger`。`WriterLogger`写入`io.Writer`，因此我们将`myWriter`作为`io.Writer`接口传递。
- en: Then we have created a `SecondLogger`, the middle link in our chain, with a
    pointer to the `writerLogger`. As we mentioned before, `SecondLogger` just logs
    and passes the message in case it contains the word `hello`. In a production app,
    it could be an error-only logger.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们创建了一个`SecondLogger`，即我们链中的中间链接，指向`writerLogger`。如前所述，`SecondLogger`只是在包含单词`hello`的情况下记录并传递消息。在生产应用程序中，它可能是仅错误记录器。
- en: 'Finally, the first link in the chain has the variable name chain. It points
    to the second logger. So, to resume, our chain looks like this: `FirstLogger`
    | `SecondLogger` | `WriterLogger`.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，链中的第一个链接具有变量名`chain`。它指向第二个记录器。因此，总结一下，我们的链如下所示：`FirstLogger` | `SecondLogger`
    | `WriterLogger`。
- en: 'This is going to be our default setup for our tests:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是我们测试的默认设置：
- en: '[PRE31]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Continuing with Go 1.7 or later testing signatures, we define an inner test
    with the following description: *three loggers, two of them write to console,
    the second only if it finds the word ''hello'', the third writes to some variable
    if the second found ''hello''*. It''s quite descriptive and very easy to understand
    if someone else has to maintain this code.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 继续使用Go 1.7或更高版本的测试签名，我们定义了一个内部测试，描述如下：*三个记录器，其中两个写入控制台，第二个只有在找到单词'hello'时才写入，第三个只有在第二个找到'hello'时才写入一些变量*。如果有人需要维护这段代码，这是非常描述性的，也很容易理解。
- en: First, we use a message on the `Next` method that will not reach the third link
    in the chain as it doesn't contain the word `hello`. We check the contents of
    the `receivedMessage` variable, that by default is empty, to see if it has changed
    because it shouldn't.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用`Next`方法上的消息，它不会到达链中的第三个链接，因为它不包含`hello`这个词。我们检查`receivedMessage`变量的内容，它默认为空，看看它是否已经改变，因为它不应该改变。
- en: Next, we use the chain variable again, our first link in the chain, and pass
    the message `"Hello\n"`. According to the description of the test, it should log
    using `FirstLogger`, then in `SecondLogger` and finally in `WriterLogger` because
    it contains the word `hello` and the `SecondLogger` will let it pass.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们再次使用链变量，我们链中的第一个链接，并传递消息`"Hello\n"`。根据测试的描述，它应该使用`FirstLogger`进行记录，然后在`SecondLogger`中，最后在`WriterLogger`中，因为它包含`hello`这个词，而`SecondLogger`会让它通过。
- en: 'The test checks that `myWriter`, the last link in the chain that stored the
    past message in a variable called `receivedMessage`, has the word that we passed
    first in the chain: hello. Let''s run it so it fails:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 测试检查`myWriter`，链中存储了过去消息的最后一个链接，是否包含我们在链中首次传递的单词：hello。让我们运行它，看看它是否失败：
- en: '[PRE32]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The test passed for the first check of the test and didn''t for the second
    check. Well... ideally no check should pass before any implementation is done.
    Remember that in test-driven development, tests must fail on the first launch
    because the code they are testing isn''t implemented yet. Go zero-initialization
    misleads us with this passed check on the test. We can solve this in two ways:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 测试通过了测试的第一个检查，但没有通过第二个检查。嗯...理想情况下，在任何实现之前都不应该通过任何检查。请记住，在测试驱动的开发中，测试必须在第一次启动时失败，因为它们正在测试的代码尚未实现。零初始化误导了我们，使得测试通过了。我们可以用两种方法解决这个问题：
- en: 'Making the signature of the `ChainLogger` to return an error: `Next(string)`
    error. This way, we would break the chain returning an error. This is a much more
    convenient way in general, but it will introduce quite a lot of boilerplate right
    now.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`ChainLogger`的签名更改为返回一个错误：`Next(string)` error。这样，我们将通过返回错误来打破链。这通常是一个更方便的方法，但现在会引入相当多的样板代码。
- en: Changing the `receivedMessage` field to a pointer. A default value of a pointer
    is nil, instead of an empty string.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`receivedMessage`字段更改为指针。指针的默认值是nil，而不是空字符串。
- en: 'We will use the second option now, as it''s much simpler and quite effective
    too. So let''s change the signature of the `myTestWriter` struct to the following:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将使用第二个选项，因为它更简单，而且也相当有效。所以让我们将`myTestWriter`结构的签名更改为以下内容：
- en: '[PRE33]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Check that the type of `receivedMessage` has the asterisk (`*`) now to indicate
    that it's a pointer to a string. The `Write` function needed to change too. Now
    we have to check the contents of the `receivedMessage` field because, as every
    pointer, it's initialized to nil. Then we have to store the message in a variable
    first, so we can take the address in the next line on the assignment `(m.receivedMessage
    = &tempMessage)`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 检查`receivedMessage`的类型现在是否有星号（`*`），以指示它是一个指向字符串的指针。`Write`函数也需要更改。现在我们必须检查`receivedMessage`字段的内容，因为像每个指针一样，它被初始化为nil。然后我们必须首先将消息存储在一个变量中，这样我们就可以在赋值的下一行中取地址（`m.receivedMessage
    = &tempMessage`）。
- en: 'So now our test code should change a bit too:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 所以现在我们的测试代码也应该有所改变：
- en: '[PRE34]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now we are checking that `myWriter.receivedMessage` is actually `nil`, so no
    content has been written for sure on the variable. Also, we have to change the
    second if to check first that the member isn''t nil before checking its contents
    or it can throw a panic on test. Let''s test it again:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们正在检查`myWriter.receivedMessage`是否实际上是`nil`，因此可以确定变量上确实没有写入任何内容。此外，我们必须更改第二个if语句，首先检查成员是否为nil，然后再检查其内容，否则测试可能会引发恐慌。让我们再次测试一下：
- en: '[PRE35]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: It fails again and, again, the first half of the test passes correctly without
    implemented code. So what should we do now? We have change the signature of the `myWriter`
    type to make the test fail in both checks and, again, just fail in the second.
    Well, in this case we can pass this small issue. When writing tests, we must be
    very careful to not get too crazy about them; unit tests are tools to help us
    write and maintain code, but our target is to write functionality, not tests.
    This is important to keep in mind as you can get really crazy engineering unit
    tests.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 它再次失败了，而且再次，测试的前半部分在没有实现代码的情况下正确通过了。那么现在我们该怎么办呢？我们必须更改`myWriter`类型的签名，使得测试在两个检查中都失败，而且只在第二个检查中失败。嗯，在这种情况下，我们可以忽略这个小问题。在编写测试时，我们必须非常小心，不要对它们过于疯狂；单元测试是帮助我们编写和维护代码的工具，但我们的目标是编写功能，而不是测试。这一点很重要，因为你可能会对工程化单元测试感到非常疯狂。
- en: Implementation
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实施
- en: 'Now we have to implement the first, second, and third loggers called `FirstLogger`,
    `SecondLogger`, and `WriterLogger` respectively. The `FirstLogger` logger is the
    easiest one as described in the first acceptance criterion: *We need a simple
    logger that logs the text of a request with a prefix First logger: and passes
    it to the next link in the chain*. So let''s do it:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们必须分别实现第一个、第二个和第三个名为`FirstLogger`、`SecondLogger`和`WriterLogger`的记录器。`FirstLogger`记录器是最简单的，正如第一个验收标准中所描述的那样：*我们需要一个简单的记录器，记录请求的文本，并在前缀为First
    logger:的情况下将其传递给链中的下一个链接*。所以让我们来做吧：
- en: '[PRE36]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The implementation is quite easy. Using the `fmt.Printf` method to format and
    print the incoming string, we appended the text `First Logger:` text. Then, we
    check that the `NextChain` type has actually some content and pass the control
    to it by calling its `Next(string)` method. The test shouldn''t pass yet so we''ll
    continue with the `SecondLogger` logger:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'As mentioned in the second acceptance criterion, the `SecondLogger` description
    is: *A second logger will write on the console if the incoming text has the word
    "hello" and pass the request to a third logger*. First of all, it checks whether
    the incoming text contains the text `hello`. If it''s true, it prints the message
    to the console, appending the text `Second logger:` and passes the message to
    the next link in the chain (check previous instance that a third link exists).'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: But if it doesn't contain the text `hello`, the chain is broken and it prints
    the message `Finishing in second logging`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll finalize with the `WriterLogger` type:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The `WriterLogger` struct's `Next` method checks that there is an existing `io.Writer`
    interface stored in the `Writer` member and writes there the incoming message
    appending the text `WriterLogger:` to it. Then, like the previous links, check
    that there are more links to pass the message.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: 'Now the tests will pass successfully:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The first half of the test prints two messages--the `First logger:` message
    that breaks the chain, which is the expected message for the `FirstLogger`. But
    it halts in the `SecondLogger` because no `hello` word has been found on the incoming
    message; that's why it prints the `Finishing in second logging` string.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: The second half of the test receives the message `Hello`. So the `FirstLogger`
    prints and the `SecondLogger` prints too. The third logger doesn't print to console
    at all but to our `myWriter.receivedMessage` line defined in the test.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: What about a closure?
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes it can be useful to define an even more flexible link in the chain
    for quick debugging. We can use closures for this so that the link functionality
    is defined by the caller. What does a closure link look like? Similar to the `WriterLogger`
    logger:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The `ClosureChain` type has a `NextChain`, as usual, and a `Closure` member.
    Look at the signature of the `Closure: func(string)`. This means it is a function
    that takes a `string` and returns nothing.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: The `Next(string)` method for `ClosureChain` checks that the `Closure` member
    is stored and executes it with the incoming string. As usual, the link checks
    for more links to pass the message as every link in the chain.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: 'So, how do we use it now? We''ll define a new test to show its functionality:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The description of this test makes it clear: `"2 loggers, second uses the closure
    implementation".` We simply use two `ChainLogger` implementations and we use the
    `closureLogger` in the second link. We have created a new `myTestWriter` to store
    the contents of the message. When defining the `ClosureChain`, we defined an anonymous
    function directly on the `Closure` member when creating `closureLogger`. It prints
    `"My closure logger! Message: %s\n" with the incoming message replacing "%s"`.
    Then, we store the incoming message on `myWriter`, to check later.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: After defining this new link, we use the third link from the previous test,
    add the closure as the fourth link, and passed the message `Hello closure logger`.
    We use the word `Hello` at the beginning so that we ensure that the message will
    pass the `SecondLogger`.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the contents of `myWriter.receivedMessage` must contain the pased
    text: `Hello closure logger`. This is quite a flexible approach with one drawback:
    when defining a closure like this, we cannot test its contents in a very elegant
    way. Let''s run the tests again:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Look at the third `RUN`: the message passes correctly through the first, second,
    and third links to arrive at the closure that prints the expected  `My closure
    logger! Message: Hello closure logger` message.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: It's very useful to add a closure method implementation to some interfaces as
    it provides quite a lot of flexibility when using the library. You can find this
    approach very often in Go code, being the most known the one of package `net/http`.
    The `HandleFunc` function which we used previously in the structural patterns
    to define a handler for an HTTP request.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Putting it together
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We learned a powerful tool to achieve dynamic processing of actions and state
    handling. The Chain of responsibility pattern is widely used, also to create **Finite
    State Machines** (**FSM**). It is also used interchangeably with the Decorator
    pattern with the difference that when you decorate, you change the structure of
    an object while with the chain you define a behavior for each link in the chain
    that can break it too.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: Command design pattern
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To finish with this chapter, we will see also the **Command** pattern--a tiny
    design pattern but still frequently used. You need a way to connect types that
    are really unrelated? So design a Command for them.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: Description
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Command design pattern is quite similar to the Strategy design pattern but
    with key differences. While in the strategy pattern we focus on changing algorithms,
    in the Command pattern, we focus on the invocation of something or on the abstraction
    of some type.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: A Command pattern is commonly seen as a container. You put something like the
    info for user interaction on a UI that could be `click on login` and pass it as
    a command. You don't need to have the complexity related to the `click on login`
    action in the command but simply the action itself.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: An example for the organic world would be a box for a delivery company. We can
    put anything on it but, as a delivery company, we are interested in managing the
    box instead of its contents directly.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: The command pattern will be used heavily when dealing with channels. With channels
    you can send any message through it but, if we need a response from the receiving
    side of the channel, a common approach is to create a command that has a second,
    response channel attached where we are listening.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, a good example would be a multi-player video game, where every stroke
    of each user can be sent as commands to the rest of the users through the network.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: Objectives
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When using the Command design pattern, we are trying to encapsulate some sort
    of action or information in a light package that must be processed somewhere else.
    It''s similar to the Strategy pattern but, in fact, a Command could trigger a
    preconfigured Strategy somewhere else, so they are not the same. The following
    are the objectives for this design pattern:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Put some information into a box. Just the receiver will open the box and know
    its contents.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delegate some action somewhere else.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The behavior is also explained in the following diagram:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '![Objectives](img/B05557_05_04.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
- en: There we have a **Command** interface with a **Get() interface{}** method. We
    have a type **A** and a type **B**. The idea is that **A** and **B** implement
    the **Command** interface to return themselves as an `interface{}`. As now they
    implement **Command**, they can be used in a **Command handler** which doesn't
    care very much about the underlying type. Now **A** and **B** can travel through
    functions that handles commands or store Commands freely. But **B** handler can
    take an object from any **Command** handler to "unwrap" it and take its **B**
    content as well as **A** command handler with its `A` content.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: We put the information in a box (the **Command**) and delegate what to do with
    it to the handlers of Commands.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: A simple queue
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our first example is going to be pretty small. We will put some information
    into a Command implementer and we will have a queue. We will create many instances
    of a type implementing a Command pattern and we will pass them to a queue that
    will store the commands until three of them are in the queue, at which time it
    will process them.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: Acceptance criteria
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So the ideal acceptance criteria to understand well the implications of the
    Command should reflect somehow the creation of a box that can accept unrelated
    types and the execution of the Command itself:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: We need a constructor of console printing commands. When using this constructor
    with a `string`, it will return a command that will print it. In this case, the
    handler is inside the command that acts as a box and as a handler.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need a data structure that stores incoming commands in a queue and prints
    them once the queue reaches the length of three.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementation
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This pattern is quite simple and we will write a few different examples so
    we''ll implement the library directly to keep things light and short. The classical
    Command design pattern usually has a common type structure with an `Execute` method.
    We are also going to use this structure as it''s quite flexible and simple:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This is generic enough to fill a lot of unrelated types! Think about it--we
    are going to create a type that prints to console when using the `Execute()` method
    but it could print a number or launch a rocket as well! The key here is to focus
    on invocations because the handlers are also in Command. So we need some type
    implementing this interface and printing to the console some sort of message:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The `ConsoleOutput` type implements the `Command` interface and prints to the
    console the member called `message`.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: 'As defined in the first acceptance criterion, we need a `Command` constructor
    that accepts a message string and returns the `Command` interface. It will have
    the signature `func CreateCommand(s string) Command`:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'For the command `queue`, we''ll define a very simple type called `CommandQueue`
    to store in a queue any type implementing the `Command` interface:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The `CommandQueue` type stores an array of the `Commands` interface. When the
    queue array reaches three items, it executes all the commands stored in the queue
    field. If it hasn't reached the required length yet, it just stores the command.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create five commands, enough to trigger the command queue mechanism,
    and add them to the queue. Each time a command is created, the message `Creating
    command` will be printed to the console. When we create the third command, the
    automatic command executor will be launched, printing the first three messages.
    We create and add two commands more, but because we haven''t reached the third
    command again, they won''t be printed and just the `Creating command` messages
    will be printed:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Let''s run the `main` program. Our definition said that the commands are processed
    once every three messages and we will create a total of five messages. The first
    three messages must be printed but not the fourth and fifth because we didn''t
    reach a sixth message to trigger the command processing:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: As you can see, the fourth and fifth messages aren't printed, as expected, but
    we know that the commands were created and stored on the array. They just weren't
    processed because the queue was waiting for one command more to trigger the processor.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: More examples
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The previous example shows how to use a Command handler that executes the content
    of the command. But a common way to use a Command pattern is to delegate the information,
    instead of the execution, to a different object.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, instead of printing to the console, we will create a command that
    extracts information:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'In this case, our `Command` interface will have a method named `Info` that
    will retrieve some information from its implementor. We will create two implementations;
    one will return the time passed since the creation of the command to its execution:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The `time.Since` function returns the time elapsed since the time stored in
    the provided parameter. We returned the string representation of the passed time
    by calling the `String()` method on the `time.Time` type. The second implementation
    of our new `Command` will return the message `Hello World!`:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'And our `main` function will simply create an instance of each type, then waits
    for a second and print the info returned from each `Command`:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The `time.Sleep` function stops the execution of the current goroutine for the
    specified period (a second). So, to recall--the `timeCommand` variable stores
    the time when the program was started and its `Info()` method returns a string
    representation of the time that passed since we give a value to the type to the
    moment were we called the `Info()` method on it. The `helloCommand` variable returns
    the message `Hello World!` when we call its `Info()` method. Here we haven't implemented
    a `Command` handler again to keep things simple but we can consider the console
    as the handler because we can only print ASCII characters on it like the ones
    retrieved by the `Info()` method.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run the `main` function:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Here we are. In this case, we retrieve some information by using the Command
    pattern. One type stores `time` information while the other stores nothing and
    it simply returns the same simple string. Each time we run the `main` function
    will return a different elapsed time, so don't worry if the time doesn't match
    with the one in the example.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: Chain of responsibility of commands
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Do you remember the chain of responsibility design pattern? We were passing
    a `string` message between links to print its contents. But we could be using
    the previous Command to retrieve information for logging to the console. We'll
    mainly reuse the code that we have written already.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Command` interface will be from the type interface that returns a `string`
    from the previous example:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We will use the `Command` implementation of the `TimePassed` type too:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Remember that this type returns the elapsed time from the object creation on
    its `Info() string` method. We also need the `ChainLogger` interface from the
    *Chain of responsibility design pattern* section of this chapter but, this time,
    it will pass Commands on its `Next` method instead of `string`:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'We''ll use just the same type for two links in the chain for simplicity. This
    link is very similar to the `FirstLogger` type from the chain of responsibility
    example, but this time it will append the message `Elapsed time from creation:`
    and it will wait 1 second before printing. We''ll call it `Logger` instead of
    `FirstLogger`:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Finally, we need a `main` function to execute the chain that takes `Command`
    pointers:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Line by line, we create a variable called `second` with a pointer to a `Logger`;
    this is going to be the second link in our chain. Then we create a variable called
    `first`, that will be the first link in the chain. The first link points to the
    `second` variable, the second link in the chain.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: Then, we create an instance of `TimePassed` to use it as the `Command` type.
    The start time of this command is the execution time (the `time.Now()` method
    returns the time in the moment of the execution).
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we pass the `Command` interface to the chain on the `first.Next(command)`
    statement. The output of this program is the following:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The resulting output is reflected in the following diagram: The command with
    the time field is pushed to the first link that knows how to execute Commands
    of any type. Then it passes the Command to the second link that also knows how
    to execute Commands:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: This approach hides the complexity behind each `Command` execution from the
    Command handlers on each link. The functionality hidden behind a Command can be
    simple or incredibly complex but the idea here is to reuse the handler to manage
    many types of unrelated implementations.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: Rounding-up the Command pattern up
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Command is a very tiny design pattern; its functionality is quite easy to understand
    but it's widely used for its simplicity. It looks very similar to the Strategy
    pattern but remember that Strategy is about having many algorithms to achieve
    some specific task, but all of them achieve the same task. In the Command pattern,
    you have many tasks to execute, and not all of them need to be equal.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: So, in short, the Command pattern is about execution encapsulation and delegation
    so that just the receiver or receivers trigger that execution.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have taken our first steps in the Behavioral patterns. The objective of this
    chapter was to introduce the reader to the concept of algorithm and execution
    encapsulation using proper interfaces and structures. With the strategy, we have
    encapsulated algorithms, with the chain of responsibility handlers and with the
    Command design pattern executions.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: Now, with the knowledge we have acquired about the strategy pattern, we can
    uncouple heavily our applications from their algorithms, just for testing, this
    is a very useful feature to inject mocks in different types that would be almost
    impossible to test. But also for anything that could need different approaches
    based on some context (such as shorting a list; some algorithms perform better
    depending on the distribution of the list).
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: The Chain of Responsibility pattern opens the door of middleware of any type
    and plugin-like libraries to improve the functionality of some part. Many open
    source projects uses a Chain of Responsibility to handler HTTP requests and responses
    to extract information to the end user (such as cookies info) or check authentication
    details (I'll let you pass to the next link only if I have you on my database).
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the Command pattern is the most common pattern for UI handling but
    also very useful in many other scenarios where we need some type of handling between
    many unrelated types that are travelling through the code (such as a message passed
    through a channel).
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
