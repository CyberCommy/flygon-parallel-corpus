- en: Chapter 3. ORM and Data Collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Collections and models are the bread and butter of everyday Magento development.
    In this chapter, we will introduce the reader to the Magento ORM system, and we
    will learn how to properly work with data collections and the EAV system. As with
    most modern systems, Magento implements an **Object Relational Mapping** (**ORM**)
    system.
  prefs: []
  type: TYPE_NORMAL
- en: '*Object-relational mapping (ORM, O/RM, and O/R mapping) in computer software
    is a programming technique for converting data between incompatible type systems
    in object-oriented programming languages. This creates, in effect, a "virtual
    object database" that can be used from within the programming language.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Magento Models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Anatomy of a Magento Data Model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: EAV and EAV models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with Direct SQL queries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will also be working with several snippets of code to provide an easy framework
    to experiment and play around with Magento.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that the interactive examples in this chapter assume you are working with
    either the default Magento installation inside the VagrantBox or a Magento installation
    with sample data.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this purpose, I have created the **Interactive Magento Console** (**IMC**),
    which is a shell script specially created for this book and inspired by Ruby''s
    own **Interactive Ruby Console** (**IRB**). Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we will need to do is to install the IMC. To do so, download
    the source files from [https://github.com/amacgregor/mdg_imc](https://github.com/amacgregor/mdg_imc)
    and extract them under your Magento test installation. The IMC is a simple Magento
    shell script that will allow us to test our code in real time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you extracted the script, log in to the shell of your virtualbox.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we will need to navigate to our Magento root folder. If you are using
    the default vagrant box, the installation is already provided; the root folder
    is located under `/srv/www/ce1720/public_html/`, and we navigate to it by running
    the following command line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can start the IMC by running the following command line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: If everything is installed successfully, we should see a new line starting with
    `magento >`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Magento Model Anatomy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we learned in the previous chapter, Magento Data Models are used to manipulate
    and access the data. The model layer is divided into two fundamental types, simple
    models and EAV, where:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Simple Models**: These model implementations are simple mappings of one object
    to one table, meaning that our object attributes match each field and our table
    structure'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Entity Attribute Value Models (EAV)**: These type of models are used to describe
    entities with a dynamic number of attributes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that it is important to clarify that not all Magento Models extend or Mage
    use the ORM. Observers are a clear example of simpler Model classes that are not
    mapped to a specific database table or entity.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to that, each Model type is formed by the following layers:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Model class**: Here is where most of our business logic resides. Models are
    used to manipulate the data, but they don''t access it directly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resource Model class**: Resource Models are used to interact with the database
    on behalf of our models. They are in charge of the actual CRUD operations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Model Collection class**: Each Data Model has a collection class; collections
    are objects that hold a number of individual Magento Model instances.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'CRUD stands for the four basic types of database operations: create, read,
    update, and delete.'
  prefs: []
  type: TYPE_NORMAL
- en: Magento Models don't contain any logic for communicating with the database;
    they are database agnostic. Instead, this code resides in the Resource Model layer.
  prefs: []
  type: TYPE_NORMAL
- en: This gives Magento the capacity to support different types of databases and
    platforms. Although currently only MySQL is officially supported, it is entirely
    possible to write a new resource class for a new database without touching any
    of the Model logic ones.
  prefs: []
  type: TYPE_NORMAL
- en: '![Magento Model Anatomy](graphics/3060OS_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s experiment now by instantiating a product object and setting some of
    its properties by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start the Magento interactive console running under your Magento staging installation
    root:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Our first step is going to create a new product object instance by typing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We can confirm whether this is a blank instance of the product class by running:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We should see the following as a successful output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to know more about the class methods, we can run the following command
    line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This will return an array with all the available methods inside the class.
    Let''s try to run the following snippet of code and modify a product price and
    name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: On the first line of code, we are instantiating a specific object, then we are
    proceeding to retrieve the name attribute from the object. Next, we are setting
    the price and name, and finally are saving the object.
  prefs: []
  type: TYPE_NORMAL
- en: If we open our Magento Product class `Mage_Catalog_Model_Product`, the first
    thing that we will notice is that while both `getName()` and `getPrice()` are
    defined inside our class, the `setPrice()` and `setName()` functions are not defined
    anywhere.
  prefs: []
  type: TYPE_NORMAL
- en: But why and more importantly, how is Magento magically defining each of the
    product object setter and getter methods? While `getPrice()` and `getName()` are
    indeed defined, there is no definition for any of the getter and setter methods
    for product attributes, such as color or manufacturer.
  prefs: []
  type: TYPE_NORMAL
- en: It's magic – methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Well, it happens that the Magento ORM system is indeed using magic; or to be
    precise, one of the PHP's more powerful features for implementing its getters
    and setters, the `magic __call()` method. Magento methods that are used inside
    Magento are used to set, unset, check, or retrieve data.
  prefs: []
  type: TYPE_NORMAL
- en: When we try to call a method, which does not actually exist in our corresponding
    class, PHP will look into each of the parent classes for a declaration of that
    method. If we can't find the function on any of the parent classes, it will use
    its last resort and try to use a `__call()` method, and if found, Magento (or
    PHP for that matter) will call the magic method, thus passing the requested method
    name and its arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the Product model doesn''t have a `__call()` method defined, but it gets
    one from the `Varien_Object` class from which all Magento models inherit from.
    The inheritance tree for the `Mage_Catalog_Model_Product` class is given in the
    following flowchart:'
  prefs: []
  type: TYPE_NORMAL
- en: '![It''s magic – methods](graphics/3060OS_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Every Magento Model inherits from the `Varien_Object` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a closer look at the `Varien_Object` class:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the file located in `magento_root/lib/Varien/Object.php`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Varien_Object` class not only has a `__call()` method but also two deprecated
    methods, `__set()` and `__get()`; these two are replaced by the `__call()` method
    and thus are no longer used.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Inside the `__call()` method, we have a switch that will handle not only getters
    and setters but also the `unset` and `has` functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we start a debugger and follow the calls of our snippet code to the `__call()`
    method, we can see that it receives two arguments: the method name for example
    `setName()` and the arguments from the original call.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Interestingly, Magento tries to match the corresponding method type based on
    the first three letters of the method being called; this is done when the switch
    case argument calls the substring function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The first thing that is called inside each case is the `_underscore()` function,
    which takes as parameter anything after the first three characters in the method
    name; following our example, the argument passed would be `Name`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `__underscore()` function returns a data key. This key is then used by
    each of the cases to manipulate the data. There are four basic data operations,
    each used on the corresponding switch case:'
  prefs: []
  type: TYPE_NORMAL
- en: '`setData($parameters)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getData($parameters)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unsetData($parameters)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isset($parameters)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of these functions will interact with the `Varien_Object` data array and
    will manipulate it accordingly. In most cases, a magic set/get method will be
    used to interact with our object attributes; only in a few exceptions where additional
    business logic is required, getters and setters will be defined. In our example,
    they are `getName()` and `getPrice()`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We will not enter details of what the price function is actually doing, but
    it clearly illustrates that additional logic might be required for certain parts
    of the models.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: On the other hand, the `getName()` getter wasn't declared because of the need
    of implementing special logic but by the need of optimizing a crucial part of
    Magento. The `Mage_Catalog_Model_Product getName()` function can be potentially
    called hundreds of times per page load and is one of the most commonly used functions
    across Magento; after all, what kind of e-commerce platform would it be if it
    was not centered around products?
  prefs: []
  type: TYPE_NORMAL
- en: Frontend and backend alike will call the `getName()` function at one point or
    another. For example, if we load a category page with 24 products, that is, 24
    separate calls to the `getName()` function, each of these calls will look for
    a `getName()` method on each of the parent classes, and then, when we try to use
    `magic __call()` method, it will result in losing precious milliseconds.
  prefs: []
  type: TYPE_NORMAL
- en: Resource Models contain all the database-specific logic, and they instantiate
    the specific read and write adapters for their corresponding data source. Let's
    go back to our example working with products and take a look at the product Resource
    Model located at `Mage_Catalog_Model_Resource_Product`.
  prefs: []
  type: TYPE_NORMAL
- en: '![It''s magic – methods](graphics/3060OS_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Resource models come in two different types: Entity and MySQL4\. The latter
    being a pretty standard one-table/one-model association, while the former is far
    more complicated.'
  prefs: []
  type: TYPE_NORMAL
- en: EAV Model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: EAV stands for entity, attribute, and value, it is probably the most difficult
    concept for new Magento developers to grasp. While the EAV concept is not unique
    to Magento, it is rarely implemented on modern systems, on top of that, Magento
    implementation is not a simple one.
  prefs: []
  type: TYPE_NORMAL
- en: '![EAV Model](graphics/3060OS_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: What is EAV?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to understand what EAV is and what its role within Magento is, we need
    to break down it into the parts of the EAV model.
  prefs: []
  type: TYPE_NORMAL
- en: '**Entity**: The entity represents the data items (objects) inside Magento products,
    customers, categories, and orders. Each entity is stored in the database with
    a unique ID.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Attribute**: These are our object properties. Instead of having one column
    per attribute on the product table, attributes are stored on separates sets of
    tables.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Value**: As the name implies, it is simply the value link to a particular
    attribute.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This design pattern is the secret behind Magento's flexibility and power, allowing
    entities to add and remove new properties without having to do any changes to
    the code or templates.
  prefs: []
  type: TYPE_NORMAL
- en: Whereas model can be seen as a vertical way of growing our database (new attributes
    add more rows), the traditional model would involve a horizontal grow pattern
    (new attributes add more columns) that would result in a schema redesign every
    time new attributes are added.
  prefs: []
  type: TYPE_NORMAL
- en: The EAV model not only allows the fast evolution of our database, but also,
    it is more efficient, because it only works with non-empty attributes, avoiding
    the need to reserve additional space in the database for null values.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are interested in exploring and learning more about the Magento database
    structure, I highly recommend you to visit [www.magereverse.com](http://www.magereverse.com).
  prefs: []
  type: TYPE_NORMAL
- en: Adding a new product attribute is as simple as going to the Magento backend
    and specifying the new attribute type, be it color, size, brand, and so on. The
    opposite is also true, because we can get rid of unused attributes on our products
    or customer models.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more information on managing attributes, visit [http://www.magentocommerce.com/knowledge-base/entry/how-do-attributes-work-in-magento](http://www.magentocommerce.com/knowledge-base/entry/how-do-attributes-work-in-magento).
  prefs: []
  type: TYPE_NORMAL
- en: 'Magento Community Edition currently has eight different types of EAV objects:'
  prefs: []
  type: TYPE_NORMAL
- en: Customer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customer address
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Products
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Product categories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Orders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Invoices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Credit memos
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shipments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Magento Enterprise Edition has one additional type called RMA item, which is
    part of the **Return Merchandise Authorization** (**RMA**) system.
  prefs: []
  type: TYPE_NORMAL
- en: All this flexibility and power is not free, and there is a price to pay; implementing
    the EAV model results in having our entity data distributed on a large number
    of tables, for example, just the Product Model is distributed on around 40 different
    tables.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram only shows a few of the tables involved in saving the
    information of Magento products:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What is EAV?](graphics/3060OS_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Another major downside of EAV is the loss of performance when retrieving large
    collections of EAV objects and an increase on the database query complexity. Since
    the data is more fragmented (stored in more tables), selecting a single record
    involves several joins.
  prefs: []
  type: TYPE_NORMAL
- en: Let's continue using Magento products as our example and manually build the
    query for retrieving a single product.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you have PHPMyAdmin or MySQL Workbench installed on your development environment,
    you can experiment with the following queries. Each can be downloaded from PHPMyAdmin
    ([http://www.phpmyadmin.net/](http://www.phpmyadmin.net/)) and MySQL Workbench
    ([http://www.mysql.com/products/workbench/](http://www.mysql.com/products/workbench/)).
  prefs: []
  type: TYPE_NORMAL
- en: 'The first table that we will need to use is the `catalog_product_entity`. We
    can consider this as our main product EAV table since it contains the main entity
    records for our products:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What is EAV?](graphics/3060OS_03_06_revised.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s query the table by running the following SQL query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The table contains the following fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '`entity_id`: This is our product unique identifier and is used internally by
    Magento.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`entity_type_id`: Magento has several different types of EAV models, products,
    customers, and orders, and these are just some of them. Identifying each by type
    allows Magento to retrieve the attributes and values from the appropriate tables.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`attribute_set_id`: Products attributes can be grouped locally into attribute
    sets. Attribute sets allow even further flexibility on the product structure since
    products are not forced to use all available attributes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`type_id`: There are several different types of products in Magento: simple,
    configurable, bundled, downloadable, and grouped products, each with unique settings
    and functionality.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sku`: **Stock Keeping Unit** (**SKU**) is a number or code used to identify
    each unique product or item for sale in a store. This is a user-defined value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`has_options`: This is used to identify if a product has custom options.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`required_options`: This is used to identify if any of the custom options are
    required.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`created_at`: This is a row creation date.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`updated_at`: This shows the last time the row was modified.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now we have a basic understanding of the product entity table, and we also know
    that each record represents a single product in our Magento store, but we don't
    have much information about that product beyond the SKU and the product type.
  prefs: []
  type: TYPE_NORMAL
- en: So, where are the attributes stored? And how does Magento know the difference
    between a product attribute and a customer attribute?
  prefs: []
  type: TYPE_NORMAL
- en: 'For that, we need to take a look at the `eav_attribute` table by running the
    following SQL query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'As a result, we will not only see the product attributes but also attributes
    corresponding to the customer model, order model, and so on. Fortunately, we already
    have a key for filtering the attributes from this table. Let''s run the following
    query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This query is telling the database to only retrieve the attributes where the
    `entity_type_id` columns are equal to the product `entity_type_id(4)`. Before
    moving on, let''s analyze the most important fields inside the `eav_attribute`
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '`attribute_id`: This is the unique identifier for each attribute and primary
    key of the table.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`entity_type_id`: This field relates each attribute to a specific EAV model
    type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`attribute_code`: This field is the name or key of our attribute and is used
    to generate the getters and setters for our magic methods.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`backend_model`: The backend model manages loading and storing data into the
    database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`backend_type`: This field specifies the type of value stored into the backend
    (database).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`backend_table`: This field is used to specify if the attribute should be stored
    on a special table instead of the default EAV tables.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`frontend_model`: The frontend model handles the rendering of the attribute
    element into a web browser.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`frontend_input`: Similar to the frontend model, the frontend input specifies
    the type of input field the web browser should render.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`frontend_label`: This field is the label/name of the attribute as it should
    be rendered by the browser.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`source_model`: The source models are used to populate an attribute with possible
    values. Magento comes with several predefined source models for countries, yes
    or no values, regions, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retrieving the data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At this point, we have successfully retrieved a product entity and the specific
    attributes that apply to that entity, and now it is time to start retrieving the
    actual values. In order to simply execute the example (and the query), we will
    only try to retrieve the name attribute of our products.
  prefs: []
  type: TYPE_NORMAL
- en: 'But how do we know on which table our attribute values are stored? Well, thankfully,
    Magento is following a naming convention for naming the tables. If we inspect
    our database structure, we will notice that there are several tables using the
    `catalog_product_entity` prefix:'
  prefs: []
  type: TYPE_NORMAL
- en: '`catalog_product_entity`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`catalog_product_entity_datetime`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`catalog_product_entity_decimal`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`catalog_product_entity_int`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`catalog_product_entity_text`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`catalog_product_entity_varchar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`catalog_product_entity_gallery`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`catalog_product_entity_media_gallery`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`catalog_product_entity_tier_price`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: But, wait, how do we know which is the right table to query for our name attribute
    values? If you were paying attention, we've already seen the answer. Do you remember
    that the `eav_attribute` table had a column called `backend_type`?
  prefs: []
  type: TYPE_NORMAL
- en: 'Magento EAV stores each attribute on a different table based on the backend
    type of that attribute. If we want to confirm the backend type of our name, we
    can do so by running the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'And we should see, as a result, that the backend type is `varchar` and that
    the values for this attribute are stored in the `catalog_product_entity_varchar`
    table. Let''s inspect this table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Retrieving the data](graphics/3060OS_03_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `catalog_product_entity_varchar` table is formed by only six columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '`value_id`: The attribute value is the unique identifier and a primary key'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`entity_type_id`: This value belongs to the entity type ID'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`attribute_id`: This is a foreign key that relates the value with our `eav_entity`
    table'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`store_id`: This is a foreign key matching an attribute value with a storeview'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`entity_id`: This is a foreign key to the corresponding entity table; in this
    case, it is `catalog_product_entity`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`value`: This is the actual value that we want to retrieve'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Depending on the attribute configuration, we can have it as a global value,
    meaning it applies across all store views or a value per storeview.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we finally have all the tables that we need to retrieve the product
    information, we can build our query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '![Retrieving the data](graphics/3060OS_03_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As result of our query, we should see a result set with three columns: `product_id`,
    `product_name`, and `product_sku`. So, let''s step back for a second in order
    to get product names with SKUs. With raw SQL, we would have to write a five-line
    SQL query, and we would only be retrieving two values from our products: from
    one single EAV value table if we wanted to retrieve a numeric field, such as price,
    or from a text value, such as product.'
  prefs: []
  type: TYPE_NORMAL
- en: If we didn't have an ORM in place, maintaining Magento would be almost impossible.
    Fortunately, we do have an ORM in place, and most likely, you will never need
    to deal with raw SQL for working with Magento.
  prefs: []
  type: TYPE_NORMAL
- en: 'That said, let''s see how can we retrieve the same product information by using
    the Magento ORM:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our first step is going to instantiate a product collection:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we will specifically tell Magento to select the name attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now sort the collection by name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'And, finally, we will tell Magento to load the collection:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The end result is a collection of all products in the store sorted by name;
    we can inspect the actual SQL query by running:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: With the help of only three lines of code, we are able to tell Magento to grab
    all the products in the store to specifically select the name, and finally, order
    the products by the name.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The last line, `$collection->getSelect()->__toString()`, allows us to see the
    actual query that Magento is executing on our behalf.
  prefs: []
  type: TYPE_NORMAL
- en: 'The actual query being generated by Magento is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the ORM and the EAV models are wonderful tools that not only
    put a lot of power and flexibility on hands of the developers, but they also do
    it in a way that is comprehensive and easy to use.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Magento collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you look back to the previous code example, you might notice that we've not
    only instantiated a Product model, but also we've called the `getCollection()`
    method. The `getCollection()` method is part of the `Mage_Core_Model_Abstract`
    class, meaning that every single model inside Magento can call this method.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All collections inherit from `Varien_Data_Collection`.
  prefs: []
  type: TYPE_NORMAL
- en: A Magento collection is basically a model that contains other models. So, instead
    of using an array for holding a collection of products, we could use a Product
    collection instead. Collections not only provide a convenient data structure for
    grouping models but also provide special methods that we can use to manipulate
    and work with collection of entities.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the most useful collection methods are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`addAttributeToSelect`: To add an attribute to entities in a collection, `*`
    can be used as a wildcard to add all available attributes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`addFieldToFilter`: To add an attribute filter to a collection, this function
    is used on regular, non-EAV models'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`addAttributeToFilter`: This method is used to filter a collection of EAV entities'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`addAttributeToSort`: This method is used to add an attribute to sort order'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`addStoreFilter`: This method is used to store an availability filter; it includes
    the availability product'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`addWebsiteFilter`: This method is used to add a website filter to a collection'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`addCategoryFilter`: This method is used to specify a category filter for a
    product collection'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`addUrlRewrite`: This method is used to add URL rewrites data to a product'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setOrder`: This method is used to set the sorting order of a collection'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Those are just a few of the collection methods available; each collection implements
    different unique methods depending on the entity type they correspond to. For
    example, the customer collection `Mage_Customer_Model_Resource_Customer_Collection`
    has a unique method called `groupByEmail()` , which has the name that correctly
    implies and groups the entities inside of a collection by e-mail.
  prefs: []
  type: TYPE_NORMAL
- en: As with previous examples, we will continue working with the product models,
    and in this case, the product collection.
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with Magento collections](graphics/3060OS_03_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In order to illustrate better how we can use collection, we will be working
    on the following common product scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: Get product collection only from a specific category.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get new products since X date.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get Bestseller products.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Filter product collection by visibility.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Filter products without image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add multiple sort orders.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get product collection only from a specific category
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first thing most developers try to do when starting with Magento is to load
    a product collection with products from only a specific category, and while I
    have seen many approaches by using `addCategoryFilter()` or `addAttributeToFilter()`
    , the reality is that, for most cases, the approach is much simpler and a bit
    counter-intuitive to what we have learned so far.
  prefs: []
  type: TYPE_NORMAL
- en: 'The easiest way of doing it is not by getting a product collection first and
    then filtering by a category but actually instantiating our target category and
    getting the product collection from there. Let''s run the following snippet of
    code on IMC:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We can find the `getProductCollection()` method declaration inside the `Mage_Catalog_Model_Category`
    class. Let''s take a better look at this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the function does nothing more than instantiating a Resource
    Model for the product collection, that is, setting the store to the current store
    ID and passing the current category to the `addCategoryFilter()` method.
  prefs: []
  type: TYPE_NORMAL
- en: This is one of those decisions that was taken to optimize Magento performance,
    and frankly to simplify the life of the developers working with it, since in most
    cases a category is going to be available one way or the other.
  prefs: []
  type: TYPE_NORMAL
- en: Get new products added since X date
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So, now that we know how to get a product collection from a specific category,
    let''s see whether we are able to apply filters to the resulting products and
    only to the retrieved ones matching our conditions; in this particular case, we
    will request all the products that were added after December 2012\. Following
    our previous example code, we can filter our collection by product creation date
    by running the following code on IMC:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'It is simple, isn''t it? We could even add an additional condition and get
    the products added between two dates. Let''s say we only want to retrieve the
    products that were created in the month of December:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Magento''s `addFieldToFilter` supports the following conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Attribute code | SQL condition |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `eq` | `=` |'
  prefs: []
  type: TYPE_TB
- en: '| `neq` | `!=` |'
  prefs: []
  type: TYPE_TB
- en: '| `like` | `LIKE` |'
  prefs: []
  type: TYPE_TB
- en: '| `nlike` | `NOT LIKE` |'
  prefs: []
  type: TYPE_TB
- en: '| `in` | `IN ()` |'
  prefs: []
  type: TYPE_TB
- en: '| `nin` | `NOT IN ()` |'
  prefs: []
  type: TYPE_TB
- en: '| `is` | `IS` |'
  prefs: []
  type: TYPE_TB
- en: '| `notnull` | `NOT NULL` |'
  prefs: []
  type: TYPE_TB
- en: '| `null` | `NULL` |'
  prefs: []
  type: TYPE_TB
- en: '| `moreq` | `>=` |'
  prefs: []
  type: TYPE_TB
- en: '| `gt` | `>` |'
  prefs: []
  type: TYPE_TB
- en: '| `lt` | `<` |'
  prefs: []
  type: TYPE_TB
- en: '| `gteq` | `>=` |'
  prefs: []
  type: TYPE_TB
- en: '| `lteq` | `<=` |'
  prefs: []
  type: TYPE_TB
- en: 'We can try other types of filters, for example, let''s use the following code
    on IMC after adding our creating date filter, so we can retrieve only visible
    products:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The visibility attribute is a special attribute used by products to control
    where products are shown; it has the following values:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Not visible individually**: It has a value 1'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Catalog**: It has a value 2'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Search**: It has a value 3'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Catalog and Search**: It has a value 4'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get Bestseller products
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To try to get the Bestseller products for a specific category, we would need
    to step up our game and do a join with the `sales_order` table. Retrieving Bestseller
    products will come in handy later on for creating a special category or custom
    reporting; we can run the following code on IMC:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Let's analyze what's happening on the third line of our snippet. `getSelect()`
    is a method inherited directly from `Varien_Data_Collection_Db`, which returns
    the variable where the `Select` statement is stored in addition to the collections
    that provide methods for specifying a join and a group without having to write
    any SQL.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is not the only way of adding a join to a collection. There is, in fact,
    a cleaner way of doing it by using the `joinField()` function. Let''s rewrite
    our previous code to make use of this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Filter product collection by visibility
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is extremely easy to do with the help of the `addAttributeToFilter` .
    Magento products have a system attribute called visibility, which has four possible
    number values ranging from 1 to 4\. We are interested only in showing products
    whose visibility is 4; meaning, it can be seen both in the search results and
    the catalog. Let''s run the following code in IMC:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: If we change the visibility code, we can compare the different collections results.
  prefs: []
  type: TYPE_NORMAL
- en: Filter products without images
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Filtering products without images comes in handy when you are dealing with a
    third-party import system, which can sometimes be unreliable. As with everything
    we have done so far, product images are the attributes of our product.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'By adding that extra filter, we require products to have a small image specified;
    by default, Magento has three products: image types, thumbnail, and `small_image`
    and image. These three types are used on different parts of the application. We
    could even set up a stricter rule for products if we wanted to.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Only products that have all the three types of images will be included in our
    collection. Try experimenting by filtering with the different image types.
  prefs: []
  type: TYPE_NORMAL
- en: Add multiple sort orders
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Finally, let''s take our collection and sort it first by stock status and then
    by price, from highest to lowest. In order to retrieve the stock status information,
    we will use a method unique to the stock status resource model called `addStockStatusToSelect()`,
    which will take care of generating the corresponding SQL for our collection query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Inside this query, Magento will sort products by the salable status that is
    either true or false, and by price; the end result is that all the available products
    will show the first ordered ones from the most expensive to the cheapest ones,
    and then, the out-of-stock products will be shown from the most expensive to the
    cheapest.
  prefs: []
  type: TYPE_NORMAL
- en: Experiment with different sort order combinations to see how Magento organizes
    and orders the product collections.
  prefs: []
  type: TYPE_NORMAL
- en: Using Direct SQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have learned how Magento data models and the ORM system provide a
    clean and simple way to access, store, and manipulate our data. Before we jump
    right into this section, learn about the Magento database adapters, and how to
    run raw SQL queries, I feel it is important that we understand why you should
    avoid as much as possible to use what you are about to learn in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Magento is an extremely complex system, and as we've also learned in the previous
    chapter, a framework is driven in part by events; just saving a product will trigger
    different events, each doing a different task. This will not happen if you decide
    to just create a query and update a product directly. So, as developers, we have
    to be extremely careful and sure whether there is a justifiable reason for going
    outside the ORM.
  prefs: []
  type: TYPE_NORMAL
- en: That said, there are, of course, scenarios when being able to work with the
    database directly comes in extremely handy and is actually simpler than working
    with the Magento models. For example, when updating a product attribute globally
    or changing a product collection status, we could load a product collection and
    loop through each of the individual products updating and saving them. While this
    would work fine on a smaller collection, as soon we start growing and working
    with a larger dataset, our performance would start to drop and the script would
    take several seconds to execute.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, a direct SQL query will execute much faster, usually under
    1 second, depending on the dataset size and the query being executed.
  prefs: []
  type: TYPE_NORMAL
- en: Out of the box, Magento will take care of all the heavy lifting of having to
    establish a connection to the database by using the `Mage_Core_Model_Resource`
    model; Magento makes two types of connections available to us, `core_read` and
    `core_write`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by instantiating a resource model and two connections, one for
    reading and the other for writing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Even if we are working with direct SQL queries, thanks to Magento, we don't
    have to worry about setting up the connection to the DB beyond instantiating a
    resource model and the proper type of connection.
  prefs: []
  type: TYPE_NORMAL
- en: Reading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s test our read connection by executing the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Although this query works, it will return all the products in the `catalog_product_entity`
    table. But what will happen if we try to run this same code on a Magento installation
    that uses table prefixes? Or what if Magento suddenly changes the table name in
    the next upgrade? This code is not portable or easily maintainable. Fortunately,
    the resource model provides another handy method called `getTableName()`.
  prefs: []
  type: TYPE_NORMAL
- en: '`getTableName()` method will take a factory name as a parameter, and based
    on the configuration established by the `config.xml`, it will not only find out
    the right table but will also verify that table exists in the DB. Let''s update
    our code to use `getTableName()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We are also using the `fetchAll()` method. This will return all the rows of
    our query as an array, but this is not the only option available; we also have
    `fetchCol()` and `fetchOne()` at our disposal. Let''s have a look at the following
    functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`fetchAll`: This function retrieves all the rows returned by the original query'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fetchOne`: This function will return only the values from the first database
    row returned by the query'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fetchCol`: This function will return all the rows returned by the query but
    only the first rows; this is useful if you only want to retrieve a single column
    with unique identifiers such as products IDs or SKUs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we've mentioned before, saving a model, be it a product, category, customer,
    and so on, in Magento can be relatively slow due to the amount of observers and
    events triggered in the backend.
  prefs: []
  type: TYPE_NORMAL
- en: 'But if we are only looking to update simple static values, updating large collections
    can be a painfully slow process if done through the Magento ORM. Let''s say, for
    example, we want to make all the products on the site out of stock. Instead of
    doing it through the Magento backend or creating a custom script that iterates
    through a collection of all the products, we can simply perform the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we have learned about:'
  prefs: []
  type: TYPE_NORMAL
- en: Magento Models, their inheritance, and purpose
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How Magento uses resource and collection models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The EAV model and its importance within Magento
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How the EAV works and the structure that is used inside the database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What the Magento ORM model is and how it is implemented
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to work with Direct SQL and the Magento resource adapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The chapters so far have been more theoretic than practical; this has been done
    with the intention of guiding you through the complexity of Magento and providing
    you with the tools and knowledge that you will require for the rest of the book.
    For the rest of the book, we will take a more hands-on approach and start building
    extensions incrementally, applying all the concepts we have learned so far.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will start getting our feet wet and develop our first
    Magento extension.
  prefs: []
  type: TYPE_NORMAL
