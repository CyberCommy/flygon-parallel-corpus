- en: MongoDB, Mongoose, and REST APIs – Part 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you're finally going to move out of the `playground` folder,
    and we're going to start playing with Mongoose. We'll be connecting to our MongoDB
    database, creating a model, talking about what exactly a model is, and finally,
    we'll be saving some data to the database using Mongoose.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Mongoose
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We're not going to need any of the files we currently have open in the `playground`
    directory, so we can go ahead and close them. We're also going to wipe the `TodoApp`
    database using Robomongo. The data inside of Robomongo is going to be a little
    different than the data we'll be using going forward, and it's best to start with
    a clean slate. There is no need to create the database after you drop it because
    if you remember, MongoDB is going to automatically create the database once you
    start writing data to it. With this in place, we can now explore Mongoose, and
    the first thing I always like to do is check out the website.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can check the website out by going to [mongoosejs.com](http://mongoosejs.com/):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/882fe839-f4d9-4eee-8119-1169fcfc4185.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, you can find examples, guides, a full list of plugins, and a ton of great
    resources. The read the docs resource is the one I use the most. It includes tutorial-like
    guides that have examples, as well as documentation covering every single feature
    of the library. It really is a fantastic resource.
  prefs: []
  type: TYPE_NORMAL
- en: If you ever want to learn about something or want to use a feature we don't
    cover in the book, I highly recommend coming to this page, taking the examples,
    copying and pasting some code, playing around with it, and figuring out how it
    works. We're going to be covering most of the essential Mongoose features right
    now.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up root of the project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first thing we need to do before we can actually use Mongoose in our project
    is install it. Over in the Terminal, I''m going to install it using `npm i`, which
    is short for `npm install`. The module name itself is called `mongoose`, and we''ll
    be installing the most recent version, which is going to be version `5.0.6`. We''re
    going to tack on the `--save` flag since we will need Mongoose for both production
    and testing purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Once we run this command, it's going to go off and do its thing. We can move
    into Atom and start creating the files we're going to need to run our application.
  prefs: []
  type: TYPE_NORMAL
- en: First up, let's make a folder in the root of the project. This folder is going
    to be called `server`, and everything related to our server is going to get stored
    in the `server` folder. The first file we're going to create is going to be called
    `server.js`. This is going to be the root of our application. When you want to
    start up your Node app, you're going to run this file. This file will get everything
    ready to go.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we need to do inside of `server.js` is load in Mongoose. We're
    going to make a variable called `mongoose`, and we're going to acquire it from
    the `mongoose` library.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have the mongoose variable in place, we need to go ahead and connect
    to the database because we can't start writing data to the database until Mongoose
    knows how to connect.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting mongoose to database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The process of connecting is going to be pretty similar to what we did inside
    of our MongoDB scripts; for example, the `mongodb-connect` script. Here, we called
    `MongoClient.connect`, passing in a URL. What we're going to do for Mongoose is
    call `mongoose.connect`, passing in the exact same URL; `mongodb` is the protocol,
    call in `//`. We're going to be connecting to our `localhost` database on port
    `27017`. Next up is going to be our `/`, followed by the database name, and we'll
    continue to use the `TodoApp` database, which we used over in the `mongodb-connect`
    script.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This is where the two functions differ. The `MongoClient.connect` method takes
    a callback, and that is when we have access to the database. Mongoose is a lot
    more complex. This is good, because it means our code can be a lot simpler. Mongoose
    is maintaining the connection over time. Imagine I try to save something, `save
    new something`. Now obviously, by the time this save statement runs, `mongoose.connect`
    is not going to have had time to make a database request to connect. That's going
    to take a few milliseconds at least. This statement is going to run almost right
    away.
  prefs: []
  type: TYPE_NORMAL
- en: Behind the scenes, Mongoose is going to be waiting for the connection before
    it ever actually tries to make the query, and this is one of the great advantages
    of Mongoose. We don't have to micromanage the order in which things happen; Mongoose
    takes care of that for us.
  prefs: []
  type: TYPE_NORMAL
- en: There is one more thing I want to configure just above `mongoose.connect`. We've
    been using promises in this course, and we're going to continue using them. Mongoose
    supports callbacks by default, but callbacks really aren't how I like to program.
    I prefer promises as they're a lot simpler to chain, manage, and scale. Right
    above the `mongoose.connect` statement, we're going to tell Mongoose which promise
    library we want to use. If you're not familiar with the history of promises, it
    didn't have to always be something built into JavaScript. Promises originally
    came from libraries like Bluebird. It was an idea a developer had, and they created
    a library. People started using it, so much so that they added it to the language.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, we need to tell Mongoose that we want to use the built- in promise
    library as opposed to some third-party one. We''re going to set `mongoose.Promise`
    equal to `global.Promise`, and this is something we''re only going to have to
    do once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We're just going to put these two lines in `server.js`; we don't have to add
    them anywhere else. With this in place, Mongoose is now configured. We've connected
    to our database and we've set it up to use promises, which is exactly what we
    want. The next thing we're going to do is create a model.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the todo model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, as we have already talked about, inside of MongoDB, your collections can
    store anything. I could have a collection with a document that has an age property,
    and that's it. I could have a different document in the same collection with a
    property name; that's it. These two documents are different, but they're both
    in the same collection. Mongoose likes to keep things a little more organized
    than that. What we're going to do is create a model for everything we want to
    store. In this example, we'll be creating a Todo model.
  prefs: []
  type: TYPE_NORMAL
- en: Now, a Todo is going to have certain attributes. It's going to have a `text`
    attribute, which we know is a string; it's going to have a `completed` attribute,
    which we know is a Boolean. These are things we can define. What we're going to
    do is create a Mongoose model so Mongoose knows how to store our data.
  prefs: []
  type: TYPE_NORMAL
- en: Right below the `mongoose.connect` statement, let's make a variable called `Todo`,
    and we're going to set that equal to `mongoose.model`. The `model` is the method
    we're going to use to create a new model. It takes two arguments. The first one
    is the string name. I'm going to match the variable name on the left, `Todo`,
    and the second argument is going to be an object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This object is going to define the various properties for a model. For example,
    the Todo model is going to have a `text` property, so we can set that up. Then,
    we can set text equal to an object, and we can configure exactly what text is.
    We can do the same thing for `completed`. We''re going to have a completed property,
    and we''re going to want to specify certain things. Maybe it''s required; maybe
    we have custom validators; maybe we want to set the type. We''re also going to
    add one final one, `completedApp`, and this is going to let us know when a Todo
    was completed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: A `createdApp` property might sound useful, but if you remember the MongoDB
    `ObjectId`, that already has the `createdAt` timestamp built in, so there's no
    reason to add a `createdApp` property here. `completedAt`, on the other hand,
    is going to add value. It lets you know exactly when you have completed a Todo.
  prefs: []
  type: TYPE_NORMAL
- en: From here, we can start specifying the details about each attribute, and there's
    a ton of different options available inside of the Mongoose documentation. For
    now though, we're going to keep things really simple by specifying the type for
    each, for example, `text`. We can set `type` equal to `String`. It's always going
    to be a string; it wouldn't make sense if it was a Boolean or a number.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Next, we can set a type for `completed`. It needs to be a Boolean; there's no
    way around that. We're going to set `type` equal to `Boolean`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The last one we have is `completedAt`. This is going to be a regular old Unix
    timestamp, which means it''s just a number, so we can set the `type` for `completedAt`
    equal to `Number`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'With this in place, we now have a working Mongoose model. It''s a model of
    a Todo that has a few properties: `text`, `completed`, and `completedAt`.'
  prefs: []
  type: TYPE_NORMAL
- en: Now in order to illustrate exactly how we create instances of this, we're going
    to go ahead and just add one Todo. We're not going to worry about fetching data,
    updating data, or deleting data, although that is stuff that Mongoose supports.
    We'll be worrying about that in the following sections, as we start building out
    the individual routes for our API. For now, we're going to go over just a very
    quick example of creating a brand-new Todo.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a brand-new Todo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I'm going to make a variable called `newTodo`, although you could call it anything
    you like; the name here is not important. What is important though is that you
    run the Todo function. This is what comes back from `mongoose.model` as a constructor
    function. We want to add the `new` keyword in front of it because we're creating
    a new instance of `Todo`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the `Todo` constructor function does take an argument. It''s going to
    be an object where we can specify some of these properties. Maybe we know that
    we want `text` to equal something like `Cook dinner`. Right in the function, we
    can specify that. `text` equals a string, `Cook dinner`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We haven't required any of our attributes, so we could just stop here. We have
    a `text` property; that's good enough. Let's go ahead and explore how to save
    this to the database.
  prefs: []
  type: TYPE_NORMAL
- en: Saving the instance to the database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating a new instance alone does not actually update the MongoDB database.
    What we need to do is call a method on `newTodo`. This is going to be `newTodo.save`.
    The `newTodo.save` method is going to be responsible for actually saving `text` to
    the MongoDB database. Now, `save` returning a promise, which means we can tack
    on a `then` call and add a few callbacks.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll add the callbacks for when the data either gets saved or when an error
    occurs because it can''t save for some reason. Maybe the connection failed, or
    maybe the model is not valid. Either way, for now we''ll just print a little string,
    `console.log(Unable to save todo)`. Up above, in the success callback, we''re
    actually going to get that Todo. I can call the argument `doc`, and I can print
    it to the screen, `console.log`. I''ll print a little message first: `Saved todo`,
    and the second argument will be the actual document:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We've configured Mongoose, connecting to the MongoDB database; we've created
    a model, specifying the attributes we want Todos to have; we created a new Todo;
    and finally, we saved it to the database.
  prefs: []
  type: TYPE_NORMAL
- en: Running the Todos script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''re going to run the script from the Terminal. I''m going to kick things
    off by running `node`. The file we''re running is in the `server` directory, and
    it''s called `server.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/ed659d0a-1b42-4d15-a9ad-630e16843426.png)'
  prefs: []
  type: TYPE_IMG
- en: When we run the file, we get `Saved todo`, meaning that things went well. We
    have an object right here with an `_id` property as expected; the `text` property,
    which we specified; and the `__v` property. The `__v` property means version,
    and it comes from Mongoose. We'll talk about it later, but essentially it keeps
    track of the various model changes over time.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we open up Robomongo, we''re going to see the exact same data. I''m going
    to right-click the connection and refresh it. Here, we have our `TodoApp`. Inside
    of the `TodoApp` database, we have our `todos` collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b21da561-c5a1-4a56-8a79-7b8f11564915.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Notice that Mongoose automatically lowercased and pluralized Todo. I''m going
    to view the documents:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/992de390-402a-4e3b-8587-0738a485e9d1.png)'
  prefs: []
  type: TYPE_IMG
- en: We have our one document with the text equal to Cook dinner, exactly what we
    created over inside of Atom.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a second Todo model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have one Todo created using our Mongoose model. What I want you to do is
    make a second one, filling out all three values. This means you're going to make
    a new Todo with a `text` value, a `completed` Boolean; go ahead and set that to
    `true`; and a `completedAt` timestamp, which you can set to any number you like.
    Then, I want you to go ahead and save it; print it to the screen if it saves successfully;
    print an error if it saves poorly. Then, finally, run it.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing I would have done is made a new variable down below. I'm going
    to make a variable called `otherTodo`, setting it equal to a `new` instance of
    the `Todo` model.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: From here, we can pass in our one argument, which is going to be the object,
    and we can specify all of these values. I can set `text` equal to whatever I like,
    for example, `Feed the cat`. I can set the `completed` value equal to `true`,
    and I can set `completedAt` equal to any number. Anything lower than 0, like -1,
    is going to go backwards from 1970, which is where 0 is. Anything positive is
    going to be where we're at, and we'll talk about time-stamps more later. For now,
    I'm going to go with something like `123`, which would basically be two minutes
    into the year 1970.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: With this in place, we now just need to call `save`. I'm going to call `otherTodo.save`.
    This is what's actually going to write to the MongoDB database. I am going to
    tack on a `then` callback, because I do want to do something once the save is
    complete. If the `save` method worked, we're going to get our `doc`, and I'm going
    to print it to the screen. I'm going to use that pretty-print system we talked
    about earlier, `JSON.stringify`, passing in the actual object, `undefined`, and
    `2`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'You don''t need to do this; you can print it in any way you like. Next up,
    I''m going to print a little message if things go poorly: `console.log(''Unable
    to save'', e)`. It''ll pass along that error object, so if someone''s reading
    the logs, they can see exactly why the call failed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'With this in place, we can now comment out that first Todo. This is going to
    prevent another one from being created, and we can rerun the script, running our
    brand-new Todo creation calls. In the Terminal, I''m going to shut down the old
    connection and start up a new one. This is going to create a brand-new Todo, and
    we have it right here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b3fac07c-6fb7-4586-8126-aaf2bec1881b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `text` property equals `Feed the cat`. The `completed` property sets to
    the Boolean `true`; notice there''s no quotes around it. The `completedAt` equals
    the number `123`; once again, no quotes. I can also go into Robomongo to confirm
    this. I''m going to refetch the Todos collection, and now we have two Todos:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/13ecf179-7f79-4fc2-b3ff-3f9d73ba92bc.png)'
  prefs: []
  type: TYPE_IMG
- en: On the right-hand side of the Values column, you'll also notice the Type column.
    Here, we have int32 for completedAt and the __v property. The completed property
    is a Boolean, text is a String, and the _id is an ObjectId type.
  prefs: []
  type: TYPE_NORMAL
- en: There's a lot of useful information hidden inside of Robomongo. If you want
    something, they most likely have it built in. That's it for this one. We now know
    how to use Mongoose to make a connection, create a model, and finally save that
    model to the database.
  prefs: []
  type: TYPE_NORMAL
- en: Validators, Types, and Defaults
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you're going to learn how to improve your Mongoose models.
    This is going to let you add things like validation. You can make certain properties
    be a requirement, and you can set up smart defaults. So, if something like completed
    is not provided, you can have a default value that gets set. All of this functionality
    is built into Mongoose; we just have to learn how to use it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate why we''d want to set this stuff up, let''s scroll to the bottom
    of our `server` file and remove all of the properties on the `new Todo` we created.
    Then, we''re going to save the file and move into the Terminal, running the script.
    That''s going to be `node` in the `server` directory, and the file is going to
    be called `server.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run it, we get our new Todo, but it only has the version and ID properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a2ac5284-4e03-4f07-a75f-b419eaad74f6.png)'
  prefs: []
  type: TYPE_IMG
- en: All of the properties we specified in the model, `text`, `completed`, and `completedAt`,
    are nowhere to be found. That's a pretty big problem. We should not be adding
    Todos to the database if they don't have a `text` property, and things like `completed`
    should have smart defaults. No-one's going to create a Todo item if they already
    completed it, so completed should default to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: Mongoose validators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now in order to get started, we''re going to pull up two pages in the Mongoose
    documentation, just so you know where this stuff lives if you ever want to dive
    deeper in the future. First up, we''re going to look up the validators. I''m going
    to google `mongoose validators`, and this is going to show us all of the default
    validation properties we have built in:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7a3739ae-5156-4ac0-b21a-7a9f721ba7a7.png)'
  prefs: []
  type: TYPE_IMG
- en: For example, we can set something as `required`, so if it's not provided it's
    going to throw an error when we try to save that model. We can also set up validators
    for things like numbers and strings, giving a `min` and `max` value or a `minlength`/`maxlength`
    value for a string.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other page we''re going to look at is the Schemas page. To get to this,
    we''re going to google `mongoose schemas`. This is the first one, the `guide.html`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/212abfaf-82d2-4a8f-bbaf-957f2b7b764b.png)'
  prefs: []
  type: TYPE_IMG
- en: On this page, you're going to see something slightly different from what we've
    been doing so far. They call `new Schema`, setting up all of their properties.
    This is not something we've done yet, but we will in the future. For now, you
    can consider this object, the `Schema` object, identical to the one we have over
    in Atom that we pass in as the second argument to our `mongoose.model` call.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing the Todo text property
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To kick things off, let's customize how Mongoose treats our `text` property.
    Currently, we tell Mongoose that we want it to be a string, but we don't have
    any validators. One of the first things we can do for the `text` property is set
    `required` equal to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'When you set `required` equal to `true`, the value must exist, so if I were
    to try to save this Todo it would fail. And we can prove this. We can save the
    file, head over to the Terminal, shut things down, and restart it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c5664fc4-40e1-47a2-baff-0973a8305dc2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We get an unreadable error message. We''ll dive into this in a second, but
    for now all you need to know is that we''re getting a validation error: Todo validation
    failed, and that is fantastic.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, aside from just making sure the `text` property exists, we can also set
    up some custom validators. For strings, for example, we have a `minlength` validator,
    which is great. You shouldn''t be able to create a Todo whose text is an empty
    string. We can set `minlength` equal to the minimum length, which we''re is going
    to be `1` in this case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, even if we do provide a `text` property in the `otherTodo` function, let''s
    say we set `text` equal to an empty string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: It's still going to fail. It is indeed there but it does not pass the minlength
    validator, where the `minlength` validator must be `1`. I can save the `server`
    file, restart things over in the Terminal, and we still get a failure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now aside from `required` and `minlength`, there are a couple other utilities
    that are around in the docs. One good example is something called `trim`. It''s
    fantastic for strings. Essentially, `trim` trims off any white space in the beginning
    or end of your value. If I set `trim` equal to `true`, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s going to remove any leading or trailing white space. So if I try to create
    a Todo whose `text` property is just a bunch of spaces, it''s still going to fail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The `trim` property is going to remove all of the leading and trailing spaces,
    leaving an empty string, and if I rerun things, we still get a failure. The text
    field is invalid. If we do provide a valid value, things are going to work as
    expected. Right in the middle of all of the spaces in `otherTodo`, I''m going
    to provide a real Todo value, which is going to be `Edit this video`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'When we try to save this Todo, the first thing that''s going to happen is the
    spaces in the beginning and the end of the string are going to get trimmed. Then,
    it''s going to validate that this string has a minimum length of 1, which it does,
    and finally, it will save the Todo to the database. I''m going to go ahead and
    save `server.js`, restart our script, and this time around we get our Todo:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/85a25e58-55ab-40e6-b209-73bbca30dd1e.png)'
  prefs: []
  type: TYPE_IMG
- en: The `Edit this video` text shows up as the `text` property. Those leading and
    trailing spaces have been removed, which is fantastic. Using just three properties,
    we were able to configure our `text` property, setting up some validation. Now,
    we can do similar stuff for `completed`.
  prefs: []
  type: TYPE_NORMAL
- en: Mongoose defaults
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For `completed`, we're not going to `require` it because the completed value
    is most likely going to default to `false`. What we can do instead is set the
    `default` property, giving this `completed` field a default value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now `completed`, as we talked about earlier in the section, should default
    to `false`. There''s no reason to create a Todo if it''s already done. We can
    do the same thing for `completedAt`. If a Todo starts off not completed, then
    `completedAt` is not going to exist. It is only going to exist when the Todo has
    been completed; it''s going to be that timestamp. What I''m going to do is set
    `default` equal to `null`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Awesome. Now, we have a pretty good schema for our Todo. We''re going to validate
    that the text is set up properly by the user, and we are going to set up the `completed`
    and `completedAt` values by our-self since we can just use defaults. With this
    in place, I can now rerun our `server` file, and here we get a better default
    Todo:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/676dd86c-d8d0-4581-80c2-fbeac54bba33.png)'
  prefs: []
  type: TYPE_IMG
- en: We have the `text` property and the user provided, which has been validated
    and trimmed. Next, we have `completed` set to `false` and `completedAt` set to
    `null`; this is fantastic. We now have a foolproof schema that has good defaults
    and validation.
  prefs: []
  type: TYPE_NORMAL
- en: Mongoose types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you''ve been playing around with the various types, you might have noticed
    that if you set a `type` equal to something other than the type you specified,
    in certain cases it does still work. For example, if I try to set `text` equal
    to an object, I''m going to get an error. It''s going to say hey, you tried to
    use a string, but an object showed up instead. However, if I try to set `text`
    equal to something like a number, I''m going to go with `23`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This is going to work. That''s because Mongoose is going to cast your number
    into a string, essentially wrapping it in quotes. The same thing is going to be
    true with the Boolean. If I pass in a Boolean like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting string is going to be `"true"`. I''m going to go ahead and save
    the file after setting `text` equal to `true`, and run the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/495fb8a4-dddd-40ae-b13a-667020db4ba5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When I do it, I get `text` equal to `true`, as shown in the preceding screenshot.
    Notice it is indeed wrapped in quotes. It''s important to be aware that typecasting
    does exist inside of Mongoose. It can easily trip you up and cause some unexpected
    errors. For now though, I am going to set `text` equal to a proper string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Creating a Mongoose user model for authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we're going to create a brand-new Mongoose model. First up, you're going
    to make a new `User` model. Eventually, we're going to use this for authentication.
    It's going to store stuff like an email and a password, and the Todos are going
    to be associated with that `User` so when I create one, only I can edit it.
  prefs: []
  type: TYPE_NORMAL
- en: We'll look into all these, but for now, we're going to keep things really simple.
    On the `User` model, the only property that you need to set up is the `email`
    property. We'll set up others like `password` later, but it's going to be done
    a little differently since it needs to be secure. For now, we'll just stick with
    `email`. I want you to `require` it. I also want you to `trim` it, so if someone
    adds spaces before or after, those spaces go away. Last but not least, go ahead
    and set the `type` equal to a `String`, set type, and set `minlength` of `1`.
    Now, obviously, you'll be able to pass in a string that's not an email. We'll
    explore custom validation a little later. This is going to let us validate that
    the email is an email, but for now this is going to get us on the right track.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have your Mongoose model created, I want you to go ahead and try to
    create a new `User`. Create one without the `email` property, and then make one
    with the email property, making sure that when you run the script, the data shows
    up as expected over in Robomongo. This data should show up in the new `Users`
    collection.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the email property
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first thing I'm going to do is make a variable to store this new model,
    a variable called `User`, and I'm going to set that equal to `mongoose.model`,
    which is how we can make our new `User` model. The first argument, as you know,
    needs to be the string model name. I'm going to use the exact same name as I specified
    over in the variable, although it could be different. I just like to keep things
    using this pattern, where the variable equals the model name. Next up, as the
    second argument, we can specify the object where we configure all the properties
    a `User` should have.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Now as I mentioned previously, we'll be adding others later, but for now, adding
    support for an `email` property will be good enough. There's a few things I want
    to do on this email. First up, I want to set the `type`. An email is always going
    to be a string, so we can set that `type` equal to `String`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Next up, we're going to `require` it. You can't make a user without an email,
    so I'll set `required` equal to `true`. After required, we're going to go ahead
    and `trim` that email. If someone adds spaces before or after it, it's clearly
    a mistake, so we'll go ahead and remove those for the `User` model, making our
    application just a little more user-friendly. Last but not least, what we want
    to do is set up a `minlength` validator. We'll be setting up custom validation
    later, but for now `minlength` of `1` is going to get the trick done.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Now, I am going to go ahead and create a new instance of this `User` and save
    it. Before I run the script though, I will be commenting out our new Todo. Now,
    we can make a new instance of this `User` model. I'm going to make a variable
    called `user` and set it equal to `new User`, passing in any values we want to
    set on that user.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'I''m going to run it with nothing at first, just to make sure the validation
    is working. Next to the user variable, I can now call `user.save`. The `save`
    method returns a promise, so I can tack on a `then` callback. I''m going to add
    a success case for this one, and an error handler. The error handler will get
    that error argument, and the success case will get the doc. If things go well,
    I''ll print a message using `console.log(''User saved'', doc)`, followed by the
    `doc` argument. No need to format it for this example. I''ll do the same thing
    for the error handler, using `console.log(''Unable to save user'')` followed by
    the error object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we''re creating a user with no properties, we would expect the error
    to print. I''m going to save `server.js` and restart the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/16d912d6-c907-453e-8235-935e68105d61.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We get our error. It''s a validation error called Path ''email'' is required.
    Mongoose is letting us know that we do indeed have an error. The email does need
    to exist, since we set `required` equal to `true`. I''m going to go ahead and
    put a value, setting `email` to my email, `andrew@example.com`, and I''ll put
    a few spaces afterwards:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This time around, things should go as expected and `trim` should be trimming
    the end of that email, removing all of the spaces, and that''s exactly what we
    get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dd0d3bfd-cd05-4808-b38d-b3fa153e95d7.png)'
  prefs: []
  type: TYPE_IMG
- en: The `User` was indeed saved, which is great, and the `email` has been properly
    formatted. Now obviously, I could have put a string in like `123`, and it would
    have worked because we don't have custom validation set up just yet, but we have
    a pretty good starting point. We have the `User` model, and we have our `email`
    property set up and ready to go.
  prefs: []
  type: TYPE_NORMAL
- en: With this in place, we are now going to start creating the API. In the next
    section, you're going to install a tool called **Postman**, which is going to
    help us test our HTTP requests, and then we're going to create our very first
    route for our Todo REST API.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Postman
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you're going to learn how to use Postman. Postman is an essential
    tool if you're building a REST API. I have never worked with a team or on a project
    where Postman was not heavily used by every developer involved. Postman lets you
    create HTTP requests and fire them off. This makes it really easy to test that
    everything you're writing is working as expected. Now obviously, we will also
    be writing automated tests, but using Postman lets you play around with data and
    see how things work as you move through your API. It really is a fantastic tool.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re going to head over to the browser and go to [getpostman.com](https://www.getpostman.com/),
    and here we can grab their application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/835b7f36-2f52-4f8f-933e-ae187b98caf2.png)'
  prefs: []
  type: TYPE_IMG
- en: Now I'm going to be using the Chrome application. To install it, all you have
    to do is install the Chrome app from the Chrome store, click Add to Chrome, and
    it should bring you over to the page where you can open up the application. Now,
    to open up Chrome apps, you have to go to this kind of weird URL. It's `chrome://apps`.
    Here, you can view all of your apps, and we can just open up Postman by clicking
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Now as I mentioned previously, Postman lets you make HTTP requests, so we're
    going to go ahead and make a few to play around with the user interface. You do
    not need to make an account, and you do not need to sign up for a paid plan. The
    paid plans are targeted towards teams of developers who need advanced features.
    We are just making basic requests on our machine; we don't need cloud storage
    or anything like that. I'm going to skip account creation, and we can go right
    to the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we can set up our request; this is what happens in the panel:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d92b060a-975c-4a9b-a969-974129f1781e.png)'
  prefs: []
  type: TYPE_IMG
- en: And, in the white space, we'll be able to view the result. Let's go ahead and
    make a request to Google.
  prefs: []
  type: TYPE_NORMAL
- en: Making an HTTP request to Google
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the URL bar, I''m going to type `http://google.com`. We can click Send to
    send off that request. Make sure you have GET chosen as your HTTP method. When
    I fire off the request, it comes back, and all of the data that comes back is
    shown in the white space:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/30fd6a5f-765a-4304-b3fe-1d288de8d437.png)'
  prefs: []
  type: TYPE_IMG
- en: We have things like the Status code; we have a 200, meaning things went great;
    we have the Time, which took about a quarter of a second; we have Headers, which
    are coming back from Google; we have Cookies, but there's none in this case; and
    we have our Body data. The body for `google.com` is an HTML website. For the most
    part, the bodies that we'll be sending and getting in Postman are going to be
    JSON since we're building out the REST API.
  prefs: []
  type: TYPE_NORMAL
- en: Illustrating working of the JSON data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So to illustrate how JSON data works, we're going to make a request to the geocoding
    URL that we used earlier in the course. If you remember, we were able to pass
    in a location and we got some JSON back, describing things like the latitude and
    longitude, and the formatted address. Now this should still be in your Chrome
    history.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you deleted your history, you can go ahead and put [https://maps.googleapis.com/maps/api/geocode/json?address=1301+lombard+st+philadelphia](https://maps.googleapis.com/maps/api/geocode/json?address=1301+lombard+st+philadelphia) in
    the address bar. This is the URL I''ll be using; you can simply copy it, or you
    can grab any JSON API URL. I''m going to copy it to the clipboard, head back into
    Postman, and swap out the URL with the URL I just copied:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/51563b05-4b16-4b54-b205-919769dc5aca.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, I can go ahead and fire off the request. We get our JSON data, which is
    fantastic:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/071bf0f7-f6a7-435e-8579-509ed52a4808.png)'
  prefs: []
  type: TYPE_IMG
- en: We're able to see exactly what comes back when we make this request, and this
    is how we're going to be using Postman.
  prefs: []
  type: TYPE_NORMAL
- en: We'll use Postman to make requests, add Todos, delete Todos, get all of our
    Todos, and log in; all of that stuff is going to happen right in here. Remember,
    APIs don't necessarily have a frontend. Maybe it's an Android app; maybe it's
    an iPhone app or a web app; maybe it's another server. Postman gives us a way
    to interact with our API, making sure it works as expected. We have all of the
    JSON data that comes back. In the Raw view, which is under Body, we have the raw
    data response. Essentially, it's just unprettified; there is no formatting, there
    is no colorization. We also have a Preview tab. The Preview tab is pretty useless
    for JSON. When it comes to JSON data., I always stick with the Pretty tab, which
    should be the default.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have Postman installed and we know a little bit about how to use
    it, we're going to move on to the next section, where we will actually create
    our first request. We'll be firing off a Postman request to hit the URL we're
    going to create. This is going to let us make new Todos right from Postman or
    any other application, whether it's a web app, a mobile app, or another server.
    That's all coming up next, so just make sure you have Postman installed. If you
    were able to do everything in this section, you are ready to continue.
  prefs: []
  type: TYPE_NORMAL
- en: Resource Creation Endpoint - POST /todos
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you're going to create your `HTTP POST` route for adding new
    Todos. Before we dive into that, we're first going to refactor everything we have
    in `server.js`. We have database configuration stuff which should live somewhere
    else and we have our models, which should also live in separate files. The only
    thing we want in `server.js` is our Express route handlers.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring the server.js file to create POST todos route
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To get started, inside of the `server` folder, we''re going to make a new folder
    called `db`, and inside of the `db` folder we''ll make a file where all of this
    Mongoose configuration will happen. I''m going to call that file `mongoose.js`,
    and all we need to do is take our Mongoose configuration code right here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Cut it out, and to move it over into `mongoose.js`. Now, we need to export
    something. What we''re going to export is the `mongoose` variable. So essentially,
    when someone requires the mongoose.js file, they''re going to have Mongoose configured
    and they''re going to get it —they''re going to get back the `mongoose` variable
    that comes from the library. I''m going to set `module.exports` equal to an object,
    and on that object we''ll set `mongoose` equal to `mongoose`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Now as we know, in ES6, this can be simplified. If you have a property and
    a variable with the same name you can shorten it, and we can take things a step
    further and put it all on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have the Mongoose configuration in a separate file, and that file can
    be required in the `server.js` file. I''m going to pull off the mongoose property
    using ES6 destructuring. Essentially, we''re creating a local variable called
    `mongoose` equal to the mongoose property on the object, and that object is going
    to be the return result from requiring the file we just created. It''s in the
    `db` directory and it''s called `mongoose.js`, and we can leave off that extension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Now that Mongoose lives in its own place, let's do the same thing for `Todo`
    and `User`. This is going to happen in a new folder in a server called `models`.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the Todo and Users file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Inside of `models`, we''re going to create two files, one for each model. I''m
    going to make two new files called `todo.js`, and `user.js`. We can take the todos
    and Users models from the `server.js` file and simply copy and paste them into
    their appropriate files. Once the model''s copied, we can remove it from `server.js`.
    The Todos model is going to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The `user.js` model is going to look like this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: I'm also going to remove everything we have so far, since those examples in
    server.js aren't necessary anymore. We can simply leave our mongoose import statement
    up at the top.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside of these model files, there are a few things we need to do. First up,
    we will call the `mongoose.model` in both Todos and Users files, so we still need
    to load in Mongoose. Now, we don''t have to load in the `mongoose.js` file we
    created; we can load in the plain old library. Let''s make a variable. We''ll
    call that variable `mongoose`, and we''re going to `require(''mongoose'')`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing that we need to do is export the model, otherwise we can''t
    use it in files that require this one. I''m going to set `module.exports` equal
    to an object, and we''ll set the `Todo` property equal to the `Todo` variable;
    this is exactly what we did over in `mongoose.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'And we''re going to do the exact same thing in `user.js`. Inside of `user.js`,
    up at the top, we''ll create a variable called `mongoose` requiring `mongoose`,
    and at the bottom we''ll export the `User` model, `module.exports`, setting it
    equal to an object where `User` equals `User`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Now, all three of our files have been formatted. We have our three new files
    and our one old one. The last thing left to do is load in `Todo` and `User`.
  prefs: []
  type: TYPE_NORMAL
- en: Loading Todo and User file in server.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the `server.js` file, let''s make a variable using destructuring call `Todo`,
    setting it equal to `require(''./models/todo'')`, and we can do the exact same
    thing for `User`. Using ES6 destructuring, we''re going to pull off that `User`
    variable, and we''re going to get it from the object that comes back from a call
    to `require`, requiring `models/user`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: With this in place, we are now ready to get going. We have the exact same setup,
    only it's been refactored, and this is going to make it a lot easier to test,
    update, and manage. The `server.js` file is just going to be responsible for our
    routes.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the Express application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, to get started, we're going to need to install Express. We've already done
    that in the past, so over in the Terminal all we need to do is run  `npm i` followed
    by the module name, which is `express`. We'll be using the most recent version,
    `4.16.2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re also going to be installing a second module, and we can actually type
    that right after the first one. There''s no need to run `npm install` twice. This
    one is called the `body-parser`. The `body-parser` is going to let us send JSON
    to the server. The server can then take that JSON and do something with it. `body-parser`
    essentially parses the body. It takes that string body and turns it into a JavaScript
    object. Now, with `body-parser`, we''re going to be installing version `1.18.2`,
    the most recent version. I''m also going to provide the `--save` flag, which is
    going to add both Express and `body-parser` to the dependencies section of `package.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Now, I can go ahead and fire off this request, installing both modules, and
    over inside of `server.js`, we can start configuring our app.
  prefs: []
  type: TYPE_NORMAL
- en: 'First up, we have to load in those two modules we just installed. As I mentioned
    previously, I like to keep a space between local imports and library imports.
    I''m going to use a variable called `express` to store the Express library, namely `require(''express'')`.
    We''re going to do the same thing for `body-parser` with a variable called `bodyParser`,
    setting it equal to the return result from requiring `body-parser`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we can set up a very basic application. We''re going to make a variable
    called `app`; this is going to store our Express application. I''m going to set
    this equal to a call to `express`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'And we''re also going to call `app.listen`, listening on a port. We will be
    deploying this to Heroku eventually. For now though, we''re going to have a local
    port, port `3000`, and we''ll provide a callback function that''s going to fire
    once the app is up. All we''re going to do is use `console.log` to print `Started
    on port 3000`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Configuring the POST route
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we have a very basic server. All we have to do is start configuring our
    routes, and as I promised, the one we're going to be focusing on in this section
    is the POST route. This is going to let us create new Todos. Now, inside of your
    REST APIs, there's the basic CRUD operations, CRUD being Create, Read, Update,
    and Delete.
  prefs: []
  type: TYPE_NORMAL
- en: When you want to create a resource, you use the `POST HTTP` method, and you
    send that resource as the body. This means that when we want to make a new Todo,
    we're going to send a JSON object over to the server. It's going to have a `text`
    property, and the server is going to get that `text` property, create the new
    model, and send the complete model with the ID, the completed property, and `completedAt`
    back to the client.
  prefs: []
  type: TYPE_NORMAL
- en: 'To set up a route, we need to call `app.post`, passing in the two arguments
    we''ve used for every single Express route, which are our URL and our callback
    function that get called with the `req` and `res` objects. Now, the URL for a
    REST API is really important, and there is a lot of talk about the proper structure.
    For resources, what I like to do is use `/todos`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: This is for resource creation, and this is a pretty standard setup. `/todos`
    is for creating a new Todo. Later on, when we want to read Todos, we'll use the
    `GET` method, and we will use `GET` from `/todos` to get all Todos or `/todos`,
    some crazy number, to get an individual Todo by its ID. This is a very common
    pattern, and it's the one we're going to be using. For now though, we can focus
    on getting the body data that was sent from the client.
  prefs: []
  type: TYPE_NORMAL
- en: Getting body data from the client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To do this, we have to use the `body-parser` module. As I mentioned previously,
    `body-parser` is going to take your JSON and convert it into an object, attaching
    it onto this `request` object. We''re going to configure the middleware using
    `app.use`. The `app.use` takes the middleware. If we''re writing custom middleware,
    it''ll be a function; if we''re using third-party middleware, we usually just
    access something off of the library. In this case, it''s going to be `bodyParser.json`
    getting called as a function. The return value from this JSON method is a function,
    and that is the middleware that we need to give to Express:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'With this in place, we can now send JSON to our Express application. What I''d
    like to do inside of the `post` callback is simply `console.log` the value of
    `req.body`, where the body gets stored by `bodyParser`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: We can now start up the server and test things out inside of Postman.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the POST route inside Postman
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Terminal, I''m going to use `clear` to clear the Terminal output, and
    then I''ll run the app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The server is up on port 3000, which means we can now head into Postman:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6a953c9e-1aaa-46b5-9fbe-b41a776ebcf2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Inside of Postman, we''re not going to be making a `GET` request like we did
    in the previous section. This time, what we''re going to be doing is making a
    POST request, which means we need to change the HTTP method to POST, and type
    the URL. That''s going to be `localhost:3000` for the port, `/todos`. This is
    the URL that we want to send our data to:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4febabfd-5ae5-42f9-9a10-fc88a754d192.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now in order to send some data to the application, we have to go to the Body
    tab. We''re trying to send JSON data, so we''re going to go to raw and select
    JSON (application/json) from the drop-down list on the right-hand side:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6a0475dd-eab4-40a1-add7-f4e0db4de205.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now we have our Header set. This is the Content-Type header, letting the server
    know that JSON is getting sent. All of this is done automatically with Postman.
    Inside of Body, the only piece of information I''m going to attach to my JSON
    is a `text` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can click Send to fire off our request. We''re never going to get a
    response because we haven''t responded to it inside of `server.js`, but if I head
    over to the Terminal, you see we have our data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f9371b46-fd66-4a0d-939f-fe21b9551ad7.png)'
  prefs: []
  type: TYPE_IMG
- en: This is the data we created inside of Postman. It's now showing up in our Node
    application, which is fantastic. We are one step closer to actually creating that
    Todo. The only thing left to do inside of the post handler is to actually create
    the Todo using the information that comes from the `User`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an instance of Mongoose model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Inside `server.js`, let''s make a variable called `todo` to do what we''ve
    done previously, creating an instance of a Mongoose model. We''re going to set
    it equal to `new Todo`, passing in our object and passing in the values we want
    to set. In this case, we just want to set `text`. We''re going to set text to
    `req.body`, which is the object we have, and then we''re going to access the `text`
    property, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Next up, we're going to call `todo.save`. This is going to actually save the
    model to the database, and we're going to be providing a callback for a success
    case and an error case.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Now if things go well, we''re going to be sending back the actual Todo which
    is going to show up in the then callback. I''m going to get the `doc`, and right
    inside of the callback function, I''m going to use `res.send` to send the doc
    back. This is going to give the `User` really important information, things like
    the ID and the `completed` and `completedAt` properties, which were not set by
    the `User`. If things go poorly and we get an error, that''s fine too. All we''re
    going to do is use `res.send` to send that error back:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: We'll be modifying how we send errors back a little later. For now, this code
    is going to work just great. We can also set an HTTP status.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up HTTP status code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you remember, HTTP statuses let you give someone some information about
    how the request went. Did it go well? Did it go poorly? That kind of thing. You
    can get a list of all the HTTP statuses available to you by going to [httpstatuses.com](https://httpstatuses.com/).
    Here, you can view all of the statuses that you can set:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6da92bd6-eedd-4b4d-b992-f2aae3128ab9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The one that''s set by default by Express is `200`. This means that things
    went OK. What we''re going to be using for an error is code `400`. A `400` status
    means there was some bad input, which is going to be the case if the model can''t
    be saved. Maybe the `User` didn''t provide a `text` property, or maybe the text
    string was empty. Either way, we want to send a `400` back, and that''s going
    to happen. Right before we call `send`, all we''re going to do is call `status`,
    passing in the status of `400`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: With this in place, we are now ready to test out our `POST /todos` request over
    inside of Postman.
  prefs: []
  type: TYPE_NORMAL
- en: Testing POST /todos inside of Postman
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I''m going to restart the server in the Terminal. You could start this up with
    `nodemon` if you like. For the moment, I''ll be manually restarting it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re now up on localhost 3000, and inside of Postman, we can make the exact
    same request we made earlier. I''m going to click on Send:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/776c1611-1339-44e4-b558-bc348e3afa13.png)'
  prefs: []
  type: TYPE_IMG
- en: We get a Status of 200\. This is fantastic; it's the default status, which means
    things went great. The JSON response is exactly what we expected. We have our
    `text` that we set; we have the `_id` property which was generated; we have `completedAt`,
    which is set to `null`, the default; and we have `completed` set to `false`, the
    default.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could also test what happens when we try to create a Todo without the proper
    information. For example, maybe I set a `text` property equal to an empty string.
    If I send this over, we now get a 400 Bad Request:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cb3f9133-cfef-4f45-932b-624493eef4f1.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, we have a bunch of validation code saying that the `Todo validation failed`.
    Then, we can go into the `errors` object to get the specific error. Here, we can
    see the `text` field failed, and the `message` is `Path 'text' is required`. All
    of this information can help someone fix their request and make a proper one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now if I head over into Robomongo, I''m going to refresh the collection for
    `todos`. Look at the last one, and it is indeed the one we created in Postman:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bbc69aa2-e621-4fe9-8387-10ac561c4a4d.png)'
  prefs: []
  type: TYPE_IMG
- en: The text is equal to This is from postman. With this in place, we now have our
    very first HTTP endpoint set up for the Todo REST API.
  prefs: []
  type: TYPE_NORMAL
- en: Now I haven't talked exactly about what REST is. We're going to talk about that
    later. For now, we're going to focus on creating these endpoints. The REST version
    will come up a little later when we start adding authentication.
  prefs: []
  type: TYPE_NORMAL
- en: Adding more Todos to the database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Over inside of Postman, we can add a few more Todos, which is what I''m going
    to do. `Charge my phone`—I don''t think I''ve ever needed to be reminded of that
    one—and we''ll add `Take a break for lunch`. In the Pretty section, we see the
    `Charge my phone` Todo was created with a unique ID. I''m going to send off the
    second one, and we''ll see that the `Take a break for lunch` Todo was created:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a4b7b887-ce27-47db-9bc9-12faf509399a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Over inside of Robomongo, we can give our `todos` collection a final refresh.
    I''m going to expand those last three items, and they are indeed the three items
    we created in Postman:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e9e6b7a1-ffa1-4d96-83d3-f4cc1172b560.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that we have some meaningful work done in our project, let''s go ahead
    and commit our changes. As you can see over in Atom, the `server` directory is
    green, meaning that it hasn''t been added to Git, and the `package.json` file
    is orange, which means that it''s been modified, even though Git is tracking it.
    Over in the Terminal we can shut down the server, and I always like to run `git
    status` to do a sanity check:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ccbaae0a-9862-411f-a8b5-5bd8aa2ac2b3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, everything does look as expected. I can it using `git add .` to add everything,
    followed by one more sanity check:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b349702a-b07e-406a-a056-911068914b44.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, we have our four new files in the `server` folder, as well as our `package.json`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, it''s time to make that commit. I''m going to create a quick commit. I''m
    using the `-am` flag, which usually adds modified files. Since I already used
    add, I can simply use the `-m` flag, like we''ve been doing all the way through
    the course. A good message for this one would be something like `Add POST /todos
    route and refactor mongoose`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: With the commit in place, we can now wrap things up by pushing it up to GitHub,
    making sure it's backed up, and making sure it's available for anyone else collaborating
    on the project. Remember, creating a commit alone does not get it up on GitHub;
    you've got to push that with another command, namely `git push`. With that in
    place, it's now time to move on to the next section, where you will be testing
    the route you just created.
  prefs: []
  type: TYPE_NORMAL
- en: Testing POST /todos
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you're going to learn how to set up the test suite for the
    Todo API, similar to what we did in the `test` section, and we'll be writing two
    test cases for `/todos`. We're going to verify that when we send the correct data
    as the body, we get a `200` back with the completed doc, including the ID; and,
    if we send bad data, we expect a `400` back with the error object.
  prefs: []
  type: TYPE_NORMAL
- en: Installing npm modules for testing POST /todos route
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now before we can do any of this, we have to install all of those modules we
    installed in the `test` section, `expect` for assertions, `mocha` for the entire
    test suite, `supertest` to test our Express routes, and `nodemon`. The `nodemon`
    module is going to let us create that `test-watch` script we had, so we can automatically
    restart the test suite. Now I know you have `nodemon` installed globally, but
    since we are using it inside of a `package.json` script, it's a great idea to
    install it locally as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re going to run `npm i` with `expect` version `22.3.0`, the most recent.
    Next up is going to be `mocha`. The most recent version is `5.0.1`. After that
    is `nodemon` version `1.15.0`, and last but not least is `supertest` at version
    `3.0.0`. With this in place, all we have to do is tack on that `--save-dev` flag.
    We want to save these, but not as regular dependencies. They''re for testing purposes
    only, so we''re going to save them as `devDependencies`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can go ahead and run this command, and once it's done we'll be able
    to start setting up the test files inside of Atom.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the test files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Atom, inside my `package.json` file, I now have my `devDependencies` listed
    out:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/17f9d742-f3d4-4e21-870d-edcfd2448fc6.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, my output for this command might look a little different than yours. npm
    is caching some of my modules that I've installed recently, so as you can see
    in the preceding screenshot, it's just grabbing the local copy. They did indeed
    get installed though, and I can prove that by opening up the `node_modules` folder.
  prefs: []
  type: TYPE_NORMAL
- en: We're now going to create a folder inside the `server` where we can store all
    of our test files, and this folder is going to be called `tests`. The only file
    we're going to worry about creating for this section is a test file for `server.js`.
    I'm going to make a new file in tests called `server.test.js`. This is the extension
    we'll be using for test files in the chapter. Inside of the `server.test` file,
    we can now kick things off by requiring a lot of those modules. We're going to
    require the `supertest` module and `expect`. The `mocha` and `nodemon` modules
    do not need to be required; that's not how they're used.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `const expect` variable we''ll get will be equal to `require(''expect'')`,
    and we''ll do the exact same thing for `supertest`, using `const`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have these in place, we need to load in some of our local files.
    We need to load in `server.js` so we have access to the Express app since we need
    that for super-test, and we also want to load in our Todo model. As you'll see
    a little later, we're going to be querying the database, and having access to
    this model is going to be necessary. Now the model already exports something,
    but `server.js` currently exports nothing. We can fix this by adding `module.exports`
    to the very bottom of the `server.js` file, setting it equal to an object. On
    that object, all we're going to do is set the `app` property equal to the `app`
    variable, using the ES6 object syntax.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: With this in place, we are now ready to load those two files in.
  prefs: []
  type: TYPE_NORMAL
- en: Loading the test files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First up, let's go ahead and create a local variable called `app`, and we're
    going to be using ES6 destructuring to pull it off of the return result from requiring
    the server file. Here, we're going to start by getting the relative path. Then,
    we're going to go back one directory from `tests` into `server`. The filename
    is simply `server` without the extension. We can do the exact same thing for the
    Todo model as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re going to make a constant called `Todo`. We''re using ES6 destructuring
    to pull that off of the export, and the file is from the relative path, back a
    directory. Then we have to go into the `models` directory, and finally, the filename
    is called `todo`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: And now that we have all of this loaded in, we are ready to create our `describe`
    block and add our test cases.
  prefs: []
  type: TYPE_NORMAL
- en: Adding describe block for the test cases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I''m going to use `describe` to group all of the routes. I''m going to have
    multiple test cases for some routes, and it''s nice to add a `describe` block
    so you can quickly glance at the test output in the Terminal. The `describe` block
    for POST Todos will simply be called `POST /todos`. Then, we can add our arrow
    function (`=>`), and inside of here we can start laying out our test cases. The
    first test is going to verify that when we send the appropriate data, everything
    goes as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can add our callback function, and this function is going to take the
    `done` argument because this is going to be an asynchronous test. You have to
    specify `done`, otherwise this test is not going to work as expected. In the callback
    function, what we're going to do is create a variable called `text`. This is the
    only setup data we really need. We just need a string, and we're going to use
    that string throughout. Go ahead and give this any value you like. I'm going to
    use `Test todo text`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Now it's time to start making that request via `supertest`. We only made `GET`
    requests previously, but `POST` requests are just as easy.
  prefs: []
  type: TYPE_NORMAL
- en: Making the POST requests via supertest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''re going to call request, passing in the app we want to make the request
    on. Next up, we''re going to call `.post`, which sets up a `POST` request. We''re
    going to go to `/todos`, and the new thing we''re going to do is actually send
    data. In order to send data along with the request as the body we have to call
    `send`, and we''re going to pass in an object. This object is going to get converted
    to JSON by `supertest`, so there''s no need for us to worry about that—just another
    great reason to use the `supertest` library. We''re going to set `text` equal
    to the `text` variable shown previously, and we can use the ES6 syntax to get
    that done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Now that we've sent the request, we can start making assertions about the request.
  prefs: []
  type: TYPE_NORMAL
- en: Making assertions about the POST request
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll start with the status. I'm going to `expect` that the status equals `200`,
    which should be the case when we send across valid data. After this, we can go
    ahead and make an assertion about the body that comes back. We want to make sure
    the body is an object and that it has the `text` property equal to the one we
    specified previously. That's exactly what it should be doing when it sends the
    body back.
  prefs: []
  type: TYPE_NORMAL
- en: 'Over inside of `server.test.js`, we can get that done by creating a custom
    `expect` assertion. If you can recall, our custom `expect` calls do get passed
    in the response, and we can use that response inside of the function. We''re going
    to `expect` that the response body has a `text` property and that the `text` property
    equals using `toBe`, the `text` string we have defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'If that''s the case, great; this will pass. If not, that''s fine too. We''re
    just going to throw an error and the test will fail. The next thing we need to
    do is call end to wrap things up, but we''re not quite done yet. What we want
    to do is actually check what got stored in the MongoDB collection, and this is
    why we loaded in the model. Instead of passing `done` into end like we did previously,
    we''re going to pass in a function. This function will get called with an error,
    if any, and the response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: This callback function is going to allow us to do a few things. First up, let's
    handle any errors that might have occurred. This will be if the status wasn't
    `200`, or if the `body` doesn't have a `text` property equal to the `text` property
    we sent in. All we have to do is check if an error exists. If an error does exist,
    all we're going to do is pass it into `done`. This is going to wrap up the test,
    printing the error to the screen, so the test will indeed fail. I'm also going
    to `return` this result.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Now, returning it doesn't do anything special. All it does is stop the function
    execution. Now, we're going to make a request to the database fetching all the
    Todos, verifying that our one `Todo` was indeed added.
  prefs: []
  type: TYPE_NORMAL
- en: Making a request to fetch the Todos from the database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To do that, we have to call `Todo.find`. Now, `Todo.find` is really similar
    to the MongoDB native `find` method we used. We can call it with no arguments
    to fetch everything in that collection. In this case, we'll be fetching all of
    the Todos. Next up, we can attach a `then` callback. We're going to get this function
    called with all `todos`, and we can make some assertions about that.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we're going to assert that the Todo we created does exist. We'll
    get started by expecting `todos.length` to `toBe` equal to the number `1`, because
    we've added one Todo item. We're going to make one more assertion. We're going
    to `expect` that that one and only item has a `text` property equal to using `toBe`,
    the `text` variable we have in server.test.js.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'If both of these pass, then we can be pretty sure that everything worked as
    expected. The status code is correct, the response is correct, and the database
    looks correct as well. Now it''s time to call `done`, wrapping up the test case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: We're not done quite yet. If either of these fail, the test is still going to
    pass. What we have to do is tack on a `catch` call.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the catch call for the error handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `catch` is going to get any errors that might occur inside of our callback.
    Then, we''re going to be able to take that error argument, and using an arrow
    function, we''re going to be able to pass it into `done`, just like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Notice here I'm using the statement syntax as opposed to the arrow function
    expression syntax. With this in place, our test case is now good to go. We have
    a great test case, and all we need to do is set up the `scripts` in `package.json`
    to actually run it.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up test scripts in package.json
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we run the test, we''re going to set up the `scripts`, just like we
    did in the test section. We''re going to have two: `test`, which just runs the
    tests; and `test-watch`, which runs the test script through `nodemon`. This means
    that any time we change our app, the tests will rerun.'
  prefs: []
  type: TYPE_NORMAL
- en: Right in `test`, we'll be running `mocha`, and the only other argument we need
    to provide is the globbing pattern for the test files. We're going to fetch everything
    in the `server` directory, which could be in a subdirectory (which it will be
    later), so we'll use two stars (`**`). It can have any file name, as long as it
    ends with the `.test.js` extension.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Now for `test-watch`, all we''re going to do is run `nodemon`. We''re going
    to be using the `--exec` flag to specify a custom command to run inside of single
    quotes. The command we''re going to run is `npm test`. The `test` script on its
    own is useful, and `test-watch` simply reruns the `test` script every time something
    changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: There is still a major flaw we need to fix before we can move on. As you may
    have noticed, inside of the `server.test` file, we make a really big assumption.
    We assume that there's nothing already in the database. We assume this because
    we expect the Todos to be a length of 1 after adding 1, which means that we assumed
    it started at 0\. Now this assumption is not going to be correct. If I were to
    run the test suite right now, it would fail. I already have Todos in the database.
    What we're going to do is add a testing life cycle method in the `server.test`
    file. This one is called `beforeEach`.
  prefs: []
  type: TYPE_NORMAL
- en: Adding testing life cycle method in server.test.js file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `beforeEach` method is going to let us run some code before every single
    test case. We're going to use `beforeEach` to set up the database in a way that's
    useful. For now, all we're going to do is make sure the database is empty. We're
    going to pass in a function, that function is going to get called with a `done`
    argument, just like our individual test cases are.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'This function is going to run before every test case and it''s only going to
    move on to the test case once we call `done`, which means we can do something
    asynchronous inside of this function. What I''m going to do is call `Todo.remove`,
    which is similar to the MongoDB native method. All we need to do is pass in an
    empty object; this is going to wipe all of our Todos. Then, we can tack on a `then`
    callback, and inside of the `then` callback we''re going to call `done`, just
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can also shorten this using the expression syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: With this in place, our database is going to be empty before every request,
    and now our assumption is correct. We're assuming we start with 0 Todos, and we
    will indeed start with 0 Todos since we just deleted everything.
  prefs: []
  type: TYPE_NORMAL
- en: Running the test suite
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I''m going to go ahead and move into the Terminal, clear the Terminal output,
    and now we can start running the test suite by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'This is going to start up `nodemon` which will start up the test suite, and
    right here we get one test passing, should create a new todo:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f0070bec-b83e-418e-9b90-edf39bd6f374.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can verify that everything is working as expected by tweaking some values.
    I can add on `1` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Just to prove that it is actually doing what it says it's doing. You can see
    that we're getting an error because the two are not equal.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same thing holds true with our status. If I change the status to something
    else, like `201`, the test suite is going to rerun and it is going to fail. Last
    but not least, down below, if I change `toBe` to `3` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: It's going to fail because we're always wiping the database, and therefore the
    only correct value here would be `1`. Now that we have this in place, we can add
    our second test case. This is going to be the test case that verifies that a Todo
    does not get created when we send bad data.
  prefs: []
  type: TYPE_NORMAL
- en: Test case: should not create todo with invalid body data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To get started with this one, we will be using `it` to create a brand-new test
    case. The text for this one could be something like `should not create todo with
    invalid body data`. We can pass in our callback with the `done` argument, and
    start making our super-test request.
  prefs: []
  type: TYPE_NORMAL
- en: 'This time around, there is no need to make a `text` variable since we''re not
    going to be passing text into it. What we''re going to be doing is passing in
    nothing at all:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Now, what I'd like you to do is make a request just like we did previously.
    You're going to make a `POST` request to the same URL, but instead you're going
    to send `send` as an empty object. This empty object is going to cause the test
    to fail because we won't be able to save the model. Then, you're going to expect
    we get a `400`, which would be the case, we send a 400 in the server.js file.
    You don't need to make any assumptions about the body that comes back.
  prefs: []
  type: TYPE_NORMAL
- en: 'Last but not least, you are going to use the following format; we pass a callback
    to end, check for any errors, and then make some assumptions about the database.
    The assumption you''re going to make is that the length of `todos` is `0`. Since
    the preceding code block does not create a Todo, no Todos should be there. The
    `beforeEach` function is going to run before every test case, so the Todo that
    gets created in `should create a new todo` is going to get deleted before our
    case runs. Go ahead and set that up. Make the request and verify that the length
    is 0\. You don''t need to have the assertion in the previous test case, since
    this assertion asserts something about the array, and the array is going to be
    empty. You can also leave the following assertion off:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Since we're not going to make any assertions about the body. When you're done,
    save the test file. Make sure both of your tests pass.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing I''m going to do is call `request`, passing in our `app`. We
    want to make another post request, so I''ll call `.post` again, and the URL is
    also going to be the same. Now at this point, we are going to be calling `.send`,
    but we''re not going to be passing invalid data. The whole point of this test
    case is to see what happens when we pass in invalid data. What should happen is
    we should get a `400`, so I''m going to `expect` that a `400` response is what
    comes back from the server. Now we don''t need to make any assertions about the
    body, so we can go ahead and move on to `.end`, where we''re going to pass in
    our function that gets called with the `err` argument, if any, and `res`, just
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we want to do is handle any potential errors. If there is an error we''re
    going to `return`, which stops the function from executing, and we''re going to
    call `done`, passing in that error so the test properly fails:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Making assertions about the length of the Todos collection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we can fetch from the database and make some assertions about the length
    of the Todos collection. I'm going to use `Todo.find` to fetch every single Todo
    inside of the collection. Then, I'll tack on a `then` callback, so I can do something
    with that data. In this case, I'll get the `todos`, and I'm going to assert something
    about its length. We're going to `expect` that `todos.length` equals `toBe` the
    number `0`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'There should be no Todos in the database before this test case runs, and since
    we''re sending in bad data, this test case should not create any Todos. We can
    now call `done` and we can also tack on our `catch` callback, which we''re going
    to need to do just like we did previously. We are going to call `catch`, taking
    that error argument and passing it into `done`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'And now, we are done. I can save the file. This is going to restart `nodemon`,
    which is going to restart our test suite. What we should see is our two test cases,
    both of them passing. Over in the Terminal, we get just that. We have two test
    cases for `POST /todos`, and both are indeed passing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9b7eb6b6-3f5b-4b0d-a3a5-3dec02aac70a.png)'
  prefs: []
  type: TYPE_IMG
- en: It took a little while to set up the basic test suite in this section, but in
    the future as we add more routes, testing is going to be much easier. We're not
    going to have to set up the infrastructure; we're not going to need to create
    the test scripts or install new modules.
  prefs: []
  type: TYPE_NORMAL
- en: Making commit for POST /todos route
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The last thing to do is make a commit. We added some meaningful code, so we''re
    going to want to save that work. If I run `git status`, you can see we have a
    few changed files as well as some untracked ones, so I will use `git add .` to
    add all of those to the next commit. Now, I can use `git commit` with the `-m`
    flag to actually make the commit. A good commit message for this one would be
    `Test POST /todos route`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: I'm going to make the commit, and lastly, I'll be pushing this up to GitHub
    using `git push`. You can use `git push` for this particular case. I need to go
    ahead and use `git push --force`, which is going to overwrite everything on GitHub.
    This is only something I need to do in this specific situation. You should just
    be running `git push`. Once you run that, your code should get pushed up to GitHub,
    and you are done. We have two test cases for our route, and it's time to move
    on and add a new route. The next route is going to be a `GET` request to fetch
    all Todos.
  prefs: []
  type: TYPE_NORMAL
- en: List Resources - GET /todos
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With our test suite in place, it's now time to create our second route, the
    `GET /todos` route, which will be responsible for returning all of your Todos.
    This is useful for any Todo application.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the GET /todos route
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first screen you''re probably going to show a user is a list of all of
    their Todos. This is the route you would use to get that information. It''s going
    to be a `GET` request so I''m going to use `app.get` to register the route handler,
    and the URL itself is going to match the URL we have, `/todos`, because we want
    to get all of the Todos. Later on when we get an individual Todo, the URL will
    look something like `/todos/123`, but for now we''re going to match it with the
    POST URL. Next up, we can add our callback right above `app.listen` in `server.js`;
    this is going to give us our request and response objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: All we need to do is get all of the Todos in the collection, which we've already
    done in the test file. Inside of `server.test.js`, we used `Todo.find` to fetch
    all of the Todos. We're going to use that same technique right here, but we're
    not passing in a query; we want to return everything.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: Later on when we add authentication you'll get back just the `Todos` you created,
    but for now, without authentication you're going to get everything in the `Todos`
    collection back.
  prefs: []
  type: TYPE_NORMAL
- en: Next up, we're going to attach a `then` call. This `then` call is going to take
    two functions, the success case function when the promise gets resolved, and a
    function that gets fired when the promise gets rejected. The success case will
    get called with all of the `todos` and all we're going to do is send that information
    back using `res.send`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'We could pass in the `todos` array, but this is not the best way to get the
    job done. When you pass back an array you''re kind of locking yourself down. If
    you want to add on another property, whether it''s a custom status code or some
    other data, you can''t because you have an array. The better solution would be
    to create an object, and on that object specify `todos`, setting it equal to the
    `todos` array using ES6:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'This would let you add other properties later on. For example, I could add
    some sort of custom status code setting it equal to whatever I like. By using
    an object as opposed to sending an array back, we''re opening ourselves up to
    a more flexible future. With this in place, our success case is good to go. The
    only thing we need to do to wrap this one up is handle errors, and the error handler
    is going to look exactly like the one we used previously, `res.status`. We''re
    going to be sending back a `400` and we''ll be sending back the error object that
    got passed into the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have this in place, we can go ahead and start up our server and
    test things out over inside of Postman.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the GET /todos route
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I''m going to fire up the server using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside of Postman, we can get started by creating some Todos. Currently, our
    application and the tests for the application use the same database. The `beforeEach`
    method call we ran in the last section unfortunately wiped everything, which means
    we have no data to fetch. The first thing I''m going to do in Postman is try to
    fetch the data we should get back an empty array, which should still work. The
    URL is going to be `localhost:3000/todos` and it is indeed going to be a GET request.
    I can click Send, which is going to fire off the request, and we get our data
    back:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/34dbc53f-5ac8-4bcd-87f9-143839ddf738.png)'
  prefs: []
  type: TYPE_IMG
- en: We have an object, we have our `todos` property, and we have our empty array,
    which is expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, as you may have noticed, manually configuring a route every single time
    you want to use it gets pretty tedious, and we''re going to be using a lot of
    the same routes over and over again. With Postman, we can actually create a collection
    of routes so we can re-fire requests without having to manually enter all of the
    information. Over on the right-hand side, I can click the drop-down arrow next
    to Save and click Save As. Here, I can give my request a little bit of detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ac4b8cb6-153b-417c-96cd-269e9679134e.png)'
  prefs: []
  type: TYPE_IMG
- en: I'm going to change the Request Name to `GET /todos`; this is the naming convention
    I like to use, the HTTP method followed by the URL. We can leave the description
    blank for now, and we can create a new collection since we don't have any. The
    Postman Echo collection is an example collection Postman gives you to explore
    this feature. We're going to make one called `Todo App`. Now, anytime we want
    to run that command, all we do is we go to Collections, click GET /todos, click
    Send, and the request fires.
  prefs: []
  type: TYPE_NORMAL
- en: Let's go ahead and set up a `POST` request to create a Todo, and then we'll
    run that, save it, and rerun `GET` to make sure it returns the newly created Todo.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Post request to create a todo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create the `POST` request, if you recall, we have to change the method to
    POST and the URL will be the same, `localhost:3000/todos`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/49eb0feb-7dd5-4958-9e2c-01e98e4a4b11.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, in order for this request to succeed, we also have to pass along a Body
    tab. This one is going to be a raw JSON body. Here, we can specify the data we''d
    like to send. In this case, the only data property we''re going to send is `text`,
    and I''ll set this to `Something to do from postman`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can go ahead and fire this off, and down below we get our newly created
    Todo with a 200 status code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e5588bc3-06ee-437a-8df9-f71995efcf4a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Which means everything went well. We can save this to our collections so we
    can easily rerun this one later. I''m going to change the Request Name to `POST
    /todos`, following that same syntax. Then, I can then select an existing collection,
    the Todo App collection, and save it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8c148816-7449-49fd-9c48-d2b819286d1c.png)'
  prefs: []
  type: TYPE_IMG
- en: Now I can simply click the request, using *command* + *enter*, or clicking the
    Send button, to fire off the request, and I get my `todos` array—everything looks
    great.
  prefs: []
  type: TYPE_NORMAL
- en: 'I can always click POST, add a second one, tweak it if I like, adding the number
    `2`, and then I can use *command* + *enter* to fire that one off. I can rerun
    the `GET` request and I have my two `todos` in the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e15ee861-0822-44b8-8e3a-9006edc40d0e.png)'
  prefs: []
  type: TYPE_IMG
- en: With this in place, our `GET /todos` request is now complete. We also set up
    our collection in Postman, making it really easy to fire off any of these HTTP
    requests much faster.
  prefs: []
  type: TYPE_NORMAL
- en: 'I''m going to go ahead and wrap this section up by making a commit over in
    the Terminal. I''m going to shut the server down and run `git status`. This time
    around, you''ll see that we just have one file and it is modified, which means
    instead of using `git add`, we can simply use `git commit` with the `-a` flag.
    The `-a` flag adds all modified files to the next commit. It does not work for
    new, untracked files, but modified files are perfectly fine. Then, I can tack
    on the `-m` flag to specify my commit message. A good one for this will be `Add
    GET /todos route`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: Last up, we're going to push it up to GitHub using `git push`, and now we are
    done. In the next section, we'll write test cases for `GET /todos`.
  prefs: []
  type: TYPE_NORMAL
- en: Testing GET /todos
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With our `GET /todos` route now in place, it is time to add a test case for
    it. Now, before we can actually write the test case, we have to deal with a different
    problem. The first thing we do inside of our `server.test` file is delete all
    the Todos, and this happens before every single test. The `GET /todos` route pretty
    much lives off the fact that there are Todos it can return. It will handle Node
    Todos, but for our test case, we want some data in that database.
  prefs: []
  type: TYPE_NORMAL
- en: In order to add this data, what we're going to do is modify `beforeEach`, adding
    some seed data. This means that our database is still going to be predictable;
    it's always going to look exactly the same when it starts, but it will have some
    items in it.
  prefs: []
  type: TYPE_NORMAL
- en: Adding seed data for the GET /todos test case
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, in order to do that, the first thing that we''re going to do is make up
    an array of dummy Todos. These Todos only need the `text` property since everything
    else is going to get populated by Mongoose. I can create a constant called `todos`,
    setting it equal to an array, and we''re going to have an array of objects where
    each object has a `text` property. For example, this one could have a text of `First
    test todo`, and then I can add on a second object as the second item in the array,
    with a `text` property equal to `Second test todo`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: Now before we can actually write the test case, we have to modify `beforeEach`
    using a brand new Mongoose method called `insertMany`, which takes an array, as
    shown in the preceding code block, and inserts all of those documents into the
    collection. This means that we are going to need to tweak the code real quick.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of having a simple arrow function that calls `done`, I''m going to
    tack on some curly braces and inside of the callback function, we''re going to
    call `Todo.insertMany` and we''re going to call `insertMany` with the array we
    defined in the preceding code block. This is going to insert all of the Todos
    in this array, our two Todos, and then we can do something like call `done`. I''m
    going to return the response, which is going to let us chain callbacks, and then
    I can tack on a `then` method, where I can use a really simple expression-based
    arrow function. All I''m going to do is call `done` using the expression syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s go ahead and run the test suite. I''ll warn you now, the other
    tests are going to have problems because the numbers that they assert are now
    going to be incorrect. Over in the Terminal, I''m going to start up the test suite
    by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: Once that test suite gets started, I'm going to move back into Atom and as you
    can see, as promised, both of the test cases failed. We expected `3` to be `1`
    and we expected `2` to be `0`. Everything is now off by `2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To fix this, we''re going to use two different techniques. Inside the server.test.js
    file, in the Post todos test, for the first test, we''re going to do is only going
    to find Todos where the `text` property equals to the `Test todo text`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that the resulting length is still going to be `1` and the first
    item should still have a `text` property equal to the text above. For the second
    test, we''re going to leave the `find` call the way it is; instead, we''re going
    to make sure that the length of the database is `2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'There should only be two documents in the Todos collection because that''s
    all we added, and this was testing a failure so a third one should not have been
    added. With this in place, you can see our two test cases are now passing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5938a07e-7023-4bbc-8d15-0354b7666740.png)'
  prefs: []
  type: TYPE_IMG
- en: We're now ready to move on and add a new `describe` block in the test case.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a describe block to the test case
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I''m going to add a `describe` block, which is going to describe the `GET /todos`
    route, passing in our arrow function, and then we can add our single test case,
    `it(''should get all todos'', )`. Now, in this case, all `todos` refer to the
    two Todos we just added previously. I''m going to pass in an arrow function with
    the `done` argument and we are good to go. All we have to do is start the super
    test request—I''m going to `request` something on the express application—this
    is going to be a GET request so we''ll call `.get`, passing in the URL `/todos`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: With this in place, we're now ready to make our assertions; we're not sending
    any data in the request body, but we are going to make some assertions about what
    comes back.
  prefs: []
  type: TYPE_NORMAL
- en: Adding assertions to the test case
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We're going to `expect` that a `200` comes back and we're also going to create
    a custom assertion, expecting something about the body. We'll provide our callback
    function with the response and we're going to `expect` that `res.body.todos` has
    a length of `2`, `.toBe(2)`. Now that we have this in place, all we have to do
    is tack on an `end` call, and pass in `done` as the argument.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: There is no need to provide a function to end, because we're not doing anything
    asynchronously.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this in place, we are now good to go. We can save the `server.test` file.
    This is going to rerun the test suite using `nodemon`; we should see our new test
    and it should be passing. In the Terminal, we get just that:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d04de850-8dd9-43c5-8f4b-f04d8d8571ea.png)'
  prefs: []
  type: TYPE_IMG
- en: We have our section for `POST /todos`; both of these tests are passing and we
    have our section for `GET /todos`, and the one test is indeed passing. Now if
    I change the status to `201`, the test is going to fail because that's not the
    status that came back. If I change the length to `3`, it's going to fail because
    we only added 2 Todos in as the seed data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''re done, let''s go ahead and make a commit, saving this code.
    I''m going to shut down the `test-watch` script, run a `git status` command, and
    we have two modified files, which means I can use `git commit` with the `-a` flag
    and the `-m` flag. Remember, the `-a` flag adds modified files to the next commit.
    A good message for this commit is going to be `Add tests for GET /todos`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: I'm going to make the commit, push it up to GitHub, and then we are done.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we worked on setting up mongoose, connecting mongoose to the
    database. We created few Todos model and run the test script. Next, we looked
    into mongoose validators, Defaults and types, and customize todo model properties
    such as test, completed and completedAt. Then, we looked in the basics of Postman
    and made HTTP request to Google. We also looked into configuring some todo routes,
    mainly POST /todos and GET /todos. We also looked into creating test cases and
    testing these routes.
  prefs: []
  type: TYPE_NORMAL
- en: With this in place, we are ready to move on to adding a brand new route, which
    is coming up in the next chapter.
  prefs: []
  type: TYPE_NORMAL
