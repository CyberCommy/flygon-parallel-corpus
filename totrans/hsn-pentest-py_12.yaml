- en: Reverse Engineering Windows Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will look at how to perform reverse engineering with Windows
    applications. We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Fuzzing Windows applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Windows and assembly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Windows and stack buffer overflow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Windows and heap buffer overflow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Formatting string bugs in Windows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debuggers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s take a look at the debuggers that we are going to cover in this chapter
    for Windows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Immunity debugger**: This is one of the best known debuggers that runs in
    a Windows environment and debugs Windows applications. It can be downloaded from
    [https://www.immunityinc.com/products/debugger/](https://www.immunityinc.com/products/debugger/) and
    comes as an executable that can be run directly:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/99762647-1633-411f-ac78-d433260892d0.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Olly debugger**: It is possible to simply download the Olly debugger from [http://www.ollydbg.de/](http://www.ollydbg.de/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/eac337e6-ad53-400d-8625-9dcf12a1a868.png)'
  prefs: []
  type: TYPE_IMG
- en: Fuzzing Windows applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Fuzzing, as we discussed in the previous chapter, is a technique used to discover
    bugs in applications that make the application crash when presented with an input
    that was not anticipated by the application.
  prefs: []
  type: TYPE_NORMAL
- en: To start off this exercise, let's set up VirtualBox, and use Windows as the
    operating system. In the lab Windows 7 machine, let's go ahead and install vulnerable
    software called **vulnserver**. If you do a Google search for `vulnserver download`,
    you will get the link to the vulnerable server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now load the `vulnserver` in VirtualBox and run it as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c12c1857-6eba-469b-9e71-647f37d9a26a.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's now try to connect the Linux host machine to the Windows machine to connect
    to the `vul` server.
  prefs: []
  type: TYPE_NORMAL
- en: 'The tool we can use for fuzzing is zzuf, which can be used with Linux-based
    systems. To check whether the tool is available, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/86e76679-2f8b-4fae-9c56-6463fd0cbc19.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s see whether it crashes when we enter a long string. We can check this
    by passing the `aaaaaa` string to the code and can see that it does not break.
    The other way is to run the `help` command, where we pass the `help` command and
    return back to the Terminal, so that we can recursively do it in a loop. This
    is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e6521c01-c09e-4271-bbb6-9824e5795647.png)'
  prefs: []
  type: TYPE_IMG
- en: It should be noted that if we wish to execute a command with `echo`, we can
    put that command in backticks `<command>` and the output of that command will
    be appended to the `echo` print string, for example: `echo 'hello' `python -c
    'print "a"*5'``.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use this technique in order to crash the target server, as the output
    of the command executed will be appended to the output of `echo`, and the output
    of `echo` goes as an input to the server through Netcat. We will execute the following
    code to see whether the vulnerable server crashes for a really long string:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ec17126b-0386-4e18-b98d-1c3de47f8959.png)'
  prefs: []
  type: TYPE_IMG
- en: We can clearly see that on executing the preceding command, the program prints `UNKNOWN
    COMMAND`. Basically, what's happening here is that `aaaaaa` is getting split across
    multiple lines and the input is sent to Netcat as follows: `echo hello aaaaaaaaaaaaaaaaaaa
    | nc …`. In the next line, the remaining `aaaa` are printed, which throws the
    `UNKNOWN COMMAND` error.
  prefs: []
  type: TYPE_NORMAL
- en: Let's try to redirect the printed output to some text file and then use `zzuf`
    with it to actually crash or fuzz the target vulnerable software.
  prefs: []
  type: TYPE_NORMAL
- en: 'Zzuf is a tool that takes a large string as an input, such as `aaaaaaaaaaaaaaaaaaaaaaaaa`.
    It randomly places special characters at various places in the string and produces
    an output such as `?aaaa@??aaaaaaaaaaa$$`. We can specify as a percentage how
    much of the input should be modified, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e77287d6-a6db-4f9b-9814-a89371ca0ec6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s use zzuf with the produced file, `fuzz.txt`, and see what the outcome
    is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00792288-d705-4522-9d70-d9ab6f5f43b7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can specify the percentage as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8fea92e7-e1db-413b-9a2d-3ddeccc488b9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Note that it is not the `HELP` command of the `vul` server that is vulnerable,
    it is the `GMON ./:/` command. We don''t want our zzuf tool to change the `GMON
    ./:/` part of the command, so we specify `-b` (the bytes option) with `zzuf` to
    tell it to skip the initial 12 bytes as shown in the following screenshots:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ab127506-ea8d-4e19-85d0-de7d0b4d4c69.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/5684510c-3909-4bd3-8855-e2dc5271c612.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s try to give this file content as an input to the `vul` server and see
    what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a6f43126-e85a-47f9-874e-366b1855cefc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'It can be seen that the output produced by the zzuf tool crashed the `vul`
    server at the other end. Note that the special characters that the zzuf tool generates
    are well known attack payload characters that are commonly used for fuzzing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/91d27170-f32e-4500-89d4-6962b22a6a94.png)'
  prefs: []
  type: TYPE_IMG
- en: We will now see how can we use a script in order to try to crash the `vul` server.
    We will also use the Olly debugger on our Windows machine in order to see where
    exactly the code breaks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start the Olly debugger as admin, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/be9ca5ad-d1f8-408e-9068-d261fbf7c751.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We will now attach the running server with the Olly debugger. Go to **File** | **Attach**.
    This will open all the running processes. We must go to vulnserver and attach
    it. Once we click on **Attach**, we get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a4ddecbe-9433-4c8d-bd23-3c7f9abe1bdb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s go back to the Linux machine and launch the script that we created:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4f39af92-7721-4d49-87fc-5355ab0041da.png)'
  prefs: []
  type: TYPE_IMG
- en: The moment we execute the `python fuzz.py` command, we don't see anything on
    the Python console.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, in the attached process in the Olly debugger, at the bottom right,
    we see a yellow message saying **Paused**, which means that the execution of the
    attached process/server is paused:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b043dd4b-bc84-4577-8bd6-3aacb6b09c24.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s click on the play button. This executes some code and pauses at another
    breakpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/44e51191-f652-473a-9c36-af5544e1c72e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'It should be noted that at the bottom of the screen it says `Access violation` when
    writing to the location `017Dxxxx`. This means that an exception was encountered
    and the program crashed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3f876ff5-c42a-4090-a78f-cb3c2fbfb632.png)'
  prefs: []
  type: TYPE_IMG
- en: Windows and assembly
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will learn about assembly language. Our objective is to
    take C code, translate it to an assembly language, and take a look at what happens.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the sample C code that we will be loading and using in order
    to learn about assembly language:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ec412315-e82b-4950-a83e-dd05899c8c9c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We will run this piece of code in the immunity debugger, compiling it to a
    file called `Bufferoverflow.exe`. Let''s start by opening it with the immunity
    debugger:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dedae68a-edbc-4c52-bb80-0be7935c88bd.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that at the top right, we have a **Registers** section. The first register,
    `EAX`, is the accumulator. In a computer's CPU, an accumulator is a register in
    which the intermediate arithmetic and the logic results are stored. In the top
    left, we have the actual assembly code, while in the bottom left, we get the memory
    dump used by the program. The bottom right contains the stack area of the program
    that we are inspecting.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we scroll down to position `00401290`, we can see the `PUSH` command. We
    can also see the ASCII string `Functionfunction`, then the integer hexadecimal
    value. This is in reverse order, as the processor here is an Intel processor which
    uses little -endian notation, whereby  the lower order byte comes first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7685ab34-35c9-432e-b8fb-990695805168.png)'
  prefs: []
  type: TYPE_IMG
- en: The previous screenshot shows the stack/code part of our `functionFunction` function,
    and each statement of this segment represents a statement of the original code
    that we had.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we scroll down a little further, we will see the actual main method and
    the function calls made from there. This is shown next. In the highlighted area
    is the function call to the actual `functionFunction` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/006a8325-644a-4a05-a991-c7789f5231f4.png)'
  prefs: []
  type: TYPE_IMG
- en: The main function returns `0`, which is what is shown by the assembly-level
    language as we are moving `0` to the EAX register. Similarly, in the previous
    screenshot, we were moving the value `1` to EAX.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now go to **Debug** and click on **Arguments**. From here, we will supply
    the command-line argument to the assembly code so that we can run it without any
    errors in the debugger:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0c0c4eff-0555-4690-9ca6-7d9ee59b87ab.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We then need to set certain break points to understand the debugger, the program
    control, and the sequence flow more thoroughly. We will put a break point at the
    beginning of the main method, as specified by the code shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/14b61521-7705-4085-9954-4908e5bd2df1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The break point is highlighted in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/283ce7e7-f565-4c01-8c3d-80c8e1cda940.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Note that once we run the application, the code actually stops when it hits
    this line. This is what is meant by a break point:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4d24053f-ca57-4ae1-8400-5a36bc0727d1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'At the bottom right of the screen, the area we see is the stack area. As we
    know, every method has a dedicated area of execution, where all the local parameters
    are stored and where the code is executed. This is the area that we define as
    a stack. The first statement of the stack points towards the place where the program
    control is supposed to return after the successful execution of the whole method
    block. Note that we have four options on the top of the screen, which are **Step
    over**, **Step onto**, **Trace onto**, and **Trace over**. We will explore these
    options as we progress. Let''s go ahead and call step into, and see what happens
    with the stack and the debuggers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/019fc4a9-d704-463e-a17a-b851c86f8b1a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Calling the step into function actually took the control to next line on the
    debugger. While that is happening, different values are added to the program variables.
    Note that the following line is going to call the `functionFunction` function, as
    specified:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/26d70cf9-0526-4014-a425-4ed9b5e09afc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Notice that the previous address at which the function call from the main function
    to the `functionFunction` function will happen is from the `004012EA` memory address
    of the main function. When the function is called, the stack allocated to `functionFunction`
    must contain the return address, such that once it finishes its execution, it
    knows where exactly it is supposed to return:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/62ecee8e-890e-4d8f-b73d-7a639f83808f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'It can be seen on the right that the EIP register is holding the `00401EA` address.
    Note that at the bottom right, the address of the statement itself is `0060FD0`
    over on the stack. Let''s hit next and see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e49153f7-9453-48e4-b7f2-5b2702c2008d.png)'
  prefs: []
  type: TYPE_IMG
- en: It can be seen that the moment the function is called, its stack gets updated
    and says that the code should return to the `004012EF` address after the execution.
    The `004012EF` address is the next instruction address of the main function, `functionFunction`.
    Note that since the IP contains the address of the next instruction to be executed,
    it now contains the `00401290` address, which is the starting address of the `Functionfunction` function.
    Once it finishes its execution, the contents from the top of the stack will be
    popped (`004012EF`) and the IP will be updated with this address so that the program
    execution is retrieved from where it stopped last.
  prefs: []
  type: TYPE_NORMAL
- en: 'After clicking on next twice, we see that the first statement, assigning the
    integer value to a variable in our `functionFunction` method, will get executed.
    Finally, when we hit or reach the return statement or the end of the `functionFunction` method, we
    will see that the stack top will contain the return address shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b174c3f3-eb3e-4d45-9b7e-0f3449d97f9f.png)'
  prefs: []
  type: TYPE_IMG
- en: We can hit next until the program exits from the main method. This is how the
    program will execute under normal circumstances, which we call behaved execution.
    In the next section, we'll see how to make the program misbehave.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see what would happen at the code level of the assembly language when
    we overflow the buffer by providing an argument that exceeds the expected length.
    We''ll add more than nine characters in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dfb45afc-5ddf-49ca-99f2-a21e634b21e6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We will now keep the break point at the main method, as we had earlier. We
    will reach the break point when we run the code, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9e1655f4-5874-4245-9063-16bfd0c25041.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the next line, we will copy the value `112233` to the local variable. We
    will then call the `Functionfunction` function where the `bufferoverflow` actually takes
    place when we do a `strcpy` on the supplied argument to a local buffer of a size
    of `10`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/84c7b8df-c026-4f13-a0b9-2c19c423372a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As shown in the preceding screenshot, the string that we passed is placed in
    the register and will be passed to `functionFunction`. The line after the highlighted
    line is the actual function call:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b204e0a1-d9ea-4fd5-8aca-4b4359b41e8d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'It can be seen in the highlighted line that the operation being executed is `strcpy(Localstring2,param)`,
    which means the value of the EAX register will be moved to the location `SS:[EBP
    +8]`. The moment we execute the preceding command, we will notice that the large
    value we gave will be loaded at the stack. We can see this at the bottom right of
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f17604eb-d2ec-41d6-ab96-4b3d5c18b114.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, the next line that will be executed will be the `strcpy` function after
    the one that is currently highlighted. We can see the stack of the `strcpy` function
    at the bottom right:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0532e48f-9ac2-4ff6-9970-b31eebf5c0b5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'There are a few buffers and memory locations in the `strcpy` function. When
    we write the value to a buffer of a length of 10, the buffer overflows and the
    remainder of the value gets spilled and written to the other memory locations
    of the stack. In other words, the other memory locations in the stack get overwritten
    by the spilled content. In this case, the memory location that contained the return
    address of the stack (once the execution was finished) would get overwritten and
    thus the code will end with an exception. This is what actually happens behind
    the scenes, as demonstrated in the following screenshot. At the bottom of the
    screenshot, we can see the access violation exception depicting this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0eda79ff-2c5e-4825-befd-6ea37550331b.png)'
  prefs: []
  type: TYPE_IMG
- en: Exploiting buffer overflows in Windows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is a known buffer overflow vulnerability in the SLMail 5.5.0 Mail Server
    software. Let''s download the application (from the following URL: [https://slmail.software.informer.com/5.5/](https://slmail.software.informer.com/5.5/))
    and install it in Windows by double-clicking the `exe` installer. Once installed,
    run it inside a Windows 7 VM, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1b3cc5c9-fa3d-492f-bb14-f3f26c4efb78.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s now attach our running program to an immunity debugger and use a simple
    Python fuzzer to crash the program, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2a6d93c9-123a-44da-9484-57645bbd470e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following screenshot depicts the loaded code once we have clicked on **Attach**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a17119b9-b04d-4bdb-9d6e-6f4c97a88845.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s use a simple fuzzer written in Python to try to break this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b13b2a87-5990-4d56-93e6-edb8c4aa22d9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s run the code to see where it breaks the email application and what
    the buffer values at the time of the crash are:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/44567dfa-40c1-4020-99a1-351cc20bd4dc.png)'
  prefs: []
  type: TYPE_IMG
- en: It can be seen that somewhere between byte number `2700` and `2900` the access
    violation exception occurs. At this point, the values of the EIP instruction register
    are overwritten by a passed string of `A`, whose hexadecimal value is `41414141`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order for us to figure out the exact location within a payload of `2900`
    bytes, we will make use of the Metasploit `generate.rb` module as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a689b76b-126d-4efd-b167-a5697760fdd0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s place this uniquely generated string in a piece of Python code to rerun
    the exploit for us so that we can see the unique value inside the EIP at the time
    of the crash:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1f3f607c-b515-479d-8fa6-842091349b33.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s restart the service in Windows and attach it to the debugger again.
    Finally, we will run our Python code to exploit it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/29672b62-2de3-4c45-95ae-f0fd5ca467a2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'It can clearly be seen that at the time of the crash, the value inside the
    EIP register is `39694438`. This will be the address that can tell us the offset
    of the payload, which can be computed as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6f6255f2-c601-4e7d-b6ac-15805a5046d6.png)'
  prefs: []
  type: TYPE_IMG
- en: It can be seen that the exact offset that causes the crash happens to be at
    `2606`. At the time of the crash, all the values passed are stored in the ESP register,
    which makes ESP a potential candidate to hold our payload. If we send a payload
    up to 2600 bytes and then try to inject an instruction in EIP that makes a jump
    to the ESP, it will be the payload that will get executed. There are two methods
    to do this. We know that the EIP holds the address of the next instruction to
    be executed and as can be seen, the address of the ESP register at the time of
    the crash is `01C8A128`. The thought that would intuitively come to our mind is
    to simply place this address after 2600 bytes, but due to **Address space layout
    randomization** (**ASLR**), which is a memory protection process for operating
    systems that guards against buffer overflow attacks by randomizing the location
    where system executables are loaded into the memory, this straightforward technique
    will not work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, let''s look for a memory address that will have an instruction such
    as JMP ESP. Since this location is outside the stack, it will not be impacted
    by ASLR whenever the program crashes. We will be using the `mona` script, which
    comes with an immunity debugger as a Python module and is used to search throughout
    the DLL process for any instructions, which in our case would be the hexadecimal
    equivalent of `jmp esp`. The mona script can be downloaded from [https://github.com/corelan/mona](https://github.com/corelan/mona),
    and can be directly placed at the following path within Windows: `C:\Program Files\Immunity
    Inc\Immunity Debugger\PyCommands`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s compute the hexadecimal equivalent of `jmp esp` using a Metasploit Ruby
    script as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1170644b-80eb-4e22-b683-1adc9806c0db.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We will therefore be searching for `\xff\xe4` within the immunity debugger
    and the `mona` script to find the `jmp` location as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cb4986e8-b335-494e-ba8a-d0f9695698f3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We get many hits, but let''s take the first one, which is `0x5f4a358f`. The
    next step would be to generate the exploit code to give us a reverse shell on
    our machine and place that exploit code in a custom Python script to send the
    payload to the server. It should be noted that while generating the exploit code,
    we are going to encode it and escape certain bad characters to ensure it works
    properly:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/14470d44-58b2-42d9-abc7-8b9eb0678fee.png)'
  prefs: []
  type: TYPE_IMG
- en: 'With the preceding payload generated, let''s create a Python script that will
    cause the exploit. We will use our previously discovered location for `jmp esp`
    via the `mona` script. It should also be noted that since the payload is encoded,
    a few bytes will be used for decoding and a few bytes will be used for padding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when we attach the running instance of the service or the process to our
    debugger and execute the script we created, we get the reverse shell from the
    victim machine that has `bufferoverflow`. This is depicted here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e2d10261-b3b6-4e64-950e-bf039f7395ba.png)'
  prefs: []
  type: TYPE_IMG
- en: This is how we exploit buffer overflow vulnerabilities in Windows.
  prefs: []
  type: TYPE_NORMAL
- en: If we go ahead and compile the program (given in the heap buffer overflow section
    of the previous chapter) in a native Windows environment and run it with a long
    argument, we can then exploit heap buffer overflow in Windows.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We demonstrated the same steps here as in the previous chapter, but in a Windows
    environment. The concepts are largely the same between Windows and Linux environments,
    but the implementation of stacks and registers may vary a little. For this reason,
    it is important to be well versed in exploitation in both environments. In the
    next chapter, we will develop exploits in Python and also in Ruby to extend the
    capabilities of the Metasploit framework.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How can we automate the process of exploiting buffer overflow vulnerabilities
    in Windows?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What can we do to avoid advanced protections being imposed by operating systems,
    such as disabling code execution on a stack in Windows?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why are registers different in Windows and in Red Hat?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Stack buffer overflow SLmail: [https://www.exploit-db.com/exploits/638/](https://www.exploit-db.com/exploits/638/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Heap buffer overflow: [https://www.win.tue.nl/~aeb/Windows/hh/hh-11.html](https://www.win.tue.nl/~aeb/Windows/hh/hh-11.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'String format vulnerabilities: [https://null-byte.wonderhowto.com/how-to/security-oriented-c-tutorial-0x14-format-string-vulnerability-part-i-buffer-overflows-nasty-little-brother-0167254/](https://null-byte.wonderhowto.com/how-to/security-oriented-c-tutorial-0x14-format-string-vulnerability-part-i-buffer-overflows-nasty-little-brother-0167254/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
