- en: Chapter 4. The Adventure Begins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will create a fun little action adventure game that will
    build upon our foundational knowledge. We will start with an animated player character
    that can navigate the world and has a short range melee attack. The game world
    will consist of multiple rooms, and the player will be able to move from one room
    to another while keeping all their stats. We will place all the code for the player
    controls and deal with wall collision in a single script to create a more efficient
    project.
  prefs: []
  type: TYPE_NORMAL
- en: 'As can be seen in the next screenshot, the theme of this game is the horrors
    of high school, and there will be three enemies in the world with basic artificial
    intelligence: a Ghost Librarian, a Brawl, and a Coach. The Ghost Librarian will
    appear if the player approaches its resting place and will chase the player until
    it gets too far away, and then return to where it came from. The Brawl will wander
    through the room on a path, and if it spots the player, it will increase in size
    and velocity. The Coach is the protector of trophies and will navigate the world
    on its own. If it sees the player it will pursue while avoiding walls and other
    Coaches, and if it is close enough it will melee attack the player.'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Adventure Begins](img/4100OT_04_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Creating animated characters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, the player objects we have created have been very basic. In [Chapter
    1](ch01.html "Chapter 1. Getting to Know the Studio with Your First Game"), *Getting
    to Know the Studio with Your First Game*, the player had no animation. In [Chapter
    3](ch03.html "Chapter 3. Shoot ''em Up: Creating a Side-scrolling Shooter"), *Shoot
    ''em Up: Creating a Side-scrolling Shooter*, the ship had animation, but always
    faced to the right. In this chapter, we are going to have a character that can
    move in four directions and have an animated sprite for each direction. We will
    also implement a melee attack that can be used in the direction the character
    is facing.'
  prefs: []
  type: TYPE_NORMAL
- en: Simplifying the character movement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are four separate sprites necessary for the player character's walk cycle.
    We will walk through the first one and then you can create the other three.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by creating a new project called `Chapter_04`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a Sprite and name it `spr_Player_WalkRight`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Load `Chapter 4/Sprites/ Player_WalkRight.gif` with **Remove Background** checked.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set **Origin** to **Center**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Modify Mask** to open the **Mask Properties** editor, and select
    the radio button of **Full image** under **Bounding Box**. The will set the collision
    box to be the entire sprite as shown in the following screenshot:![Simplifying
    the character movement](img/4100OT_04_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **OK**. Repeat this process to load `spr_Player_WalkLeft`, `spr_Player_WalkUp`,
    and `spr_Player_WalkDown`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an Object, `obj_Player`, and assign `spr_Player_WalkRight` as the Sprite.
    It actually doesn't matter which of the player sprites we set here, as we will
    be using code to change what sprite is being displayed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We need to set up some initial variables, so create a new Script, `scr_Player_Create`,
    and write the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The first two variables are placeholders for the speed and direction of the
    player. This will be useful as we can affect these values without affecting the
    object's local `mySpeed` and `myDirection` variables for things, such as a knockback
    effect in which the object would be facing one direction while moving in the other.
    The variable `isAttacking` will be used to indicate when we have initiated combat,
    and `isWalking` will indicate when the player is moving. Next, we have the global
    variable `health`, which is set to 100 percent. Finally, we set the animation
    speed at 50 percent, so that the walk cycle plays properly.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To know more about GameMaker: Studio''s built-in variables and functions, check
    out the GameMaker User Manual by clicking on **Help** | **Contents**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can go onto the player movement. Instead of having multiple scripts
    for each key, we are going to simplify the code by placing all the controls into
    a single script. Create a new Script, `scr_Player_Step`, and we will start with
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We start by setting `isWalking` to `false`, so that it becomes the default state
    of what the player is doing. After that we are checking whether the keyboard has
    the right arrow key (`vk_right`), currently pressed down, and we check whether
    there is a solid object to the right of the current position. The `place_free`
    function will return whether the specified point is collision free. If the player
    is able to move and the key is pressed, we then move to the right and set the
    direction to zero to indicate right. We change the sprite to the right facing
    walk cycle, and then we change `isWalking` to `true`, which will overwrite the
    first line of code where we set it to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: Repeat this code for each of the remaining three directions and adjust accordingly.
    Each one should look at what key is being held, and see if there is any collision
    ahead from that position.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We have one more thing to do before the movement controls are complete. If
    the player is not moving, we want the animation to stop and start playing again
    once it starts moving. At the end of the script, add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We created the variable `isWalking` to switch between a walking and stopped
    state. If the player is moving, the sprite will animate. If the player isn't moving,
    we stop the animation as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code should look like the following when it is complete:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Apply these scripts to the appropriate events, a **Create** event for `scr_Player_Create`,
    and a **Step** event for `scr_Player_Step`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The player is ready to move and animate properly, but we won't be able to fully
    test out the code without adding in some solid obstacles. Let's make a wall.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Sprite, `spr_Wall`, load `Chapter 4/Sprites/Wall.png`, and uncheck
    **Remove Background**. We are using a PNG file, as this wall is slightly transparent
    which will be useful later when we decorate the room.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Object, `obj_Wall`, and set the sprite to `spr_Wall`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check the box for **Solid**. The wall is now identified as being a collidable
    object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Room and name it `Sandbox`. We will use this room for testing out
    features.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place a single instance of `obj_Player` somewhere in the center of the room.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place instances of `obj_Wall` around the perimeter of the room, and add a few
    extra sections as can be seen in the following screenshot:![Simplifying the character
    movement](img/4100OT_04_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the game. The player at this point should be able to move around the room
    freely in the open areas, and stop when they collide with a wall.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implementing a melee attack
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have the player movement functioning we can move onto the attack.
    The attack we are creating needs to only affect objects in front of the player
    character. To achieve this we will create a melee attack object that will spawn
    on command and remove itself from the game on its own.
  prefs: []
  type: TYPE_NORMAL
- en: Create a Sprite, `spr_Player_Attack`, and load `Chapter 4/Sprites/Player_Attack.gif`
    with **Remove Background** checked. This is an animated Sprite that will represent
    a swinging melee attack.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We want the collision area to affect the entire height of the sprite, but not
    the entire width. Click on **Modify Mask** and in the **Mask Properties** editor,
    select the radio button for **Manual** under **Bounding Box**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Adjust the **Bounding Box** values for **Left**: `0`, **Right**: `24`, **Top**:
    `0` and **Bottom**: `4`. The end result should look like the following screenshot.
    Click on **OK**.![Implementing a melee attack](img/4100OT_04_03.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We want this object to always spawn in front of the player. One of the easiest
    ways to ensure this is to have this object rotate along with the player. To achieve
    this, set **Origin** to **X:** `-16` **Y:** `24`. Setting the X coordinate off
    to the left means that this object will have a 16 pixel offset when spawned. We
    can then rotate the attack to match the player's direction.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an Object, `obj_Player_Attack`, and assign `spr_Player Attack` as its
    Sprite.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set **Depth** to `-100`. **Depth** determines whether an instance of an object
    is drawn on-screen behind or above another object. Setting it to a negative value
    means that it will draw on top of any object with a higher depth value. Setting
    the value to `-100` allows us to have other objects with depths between the default
    `0` and `-99` without needing to worry about readjusting things later.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new Script, `scr_Player_Attack_Create` with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here is where we rotate the image to face the same direction as the player,
    which with the offset origin we set means it will be in front of the player. We
    also slow the animation speed down and set an alarm for six frames. This alarm
    will remove the attack object when it goes off. Finally we tell the player that
    it is attacking.
  prefs: []
  type: TYPE_NORMAL
- en: Add a **Create** event in `obj_Player_Attack` and attach this script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s move onto the alarm script, `scr_Player_Attack_Alarm`. It will not only
    need to remove the attack, but it also needs to let the player know that it is
    gone and that they can attack once again. We only need two lines of code to do
    all this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We can talk directly to the player's `isAttacking` variable and set it back
    to `false`. Then we destroy the instance of the melee attack. Attach this script
    to an **Alarm 0** event.
  prefs: []
  type: TYPE_NORMAL
- en: 'All we need to do now is to get the player to spawn an instance of the attack.
    Reopen `scr_Player_Step` and at the bottom, add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `keyboard_check_pressed` function only activates on the actual pressing
    down action of a key, as opposed to being in the down position, and in this case,
    we are checking for the *Z* key. There are no special commands for the various
    letters on the keyboard, so we need to use the `ord` function that returns the
    corresponding ASCII code for the character it has been passed. We also check to
    see if the player is currently not attacking already. If that is all true, we
    spawn the attack, and that attack will change the `isAttacking` variable to true,
    so that this only happens once.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When using the `ord` function, always use capital letters, or it may give the
    wrong number!
  prefs: []
  type: TYPE_NORMAL
- en: Run the game. You should be able to tap the *Z* key and see the distinctive
    swinging motion in front of the player no matter which way the character is facing
    as shown in the following screenshot. The player is now ready for battle!![Implementing
    a melee attack](img/4100OT_04_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigating between rooms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An adventure game would be quite boring if everything took place in one incredibly
    large room. Not only is it not very efficient, but the world will also lack the
    feeling of exploration. Switching from one room to another is easy to do, but
    it does pose a problem.
  prefs: []
  type: TYPE_NORMAL
- en: The first issue is retaining the player stats, such as health, from one room
    to the next. One solution to this is to activate **persistence** on the player.
    Persistence means that we only need to place a single instance of an object in
    a room, and from that point onwards it will remain in the game world.
  prefs: []
  type: TYPE_NORMAL
- en: The second issue is where to place the player in a room with multiple entry
    points. If the player isn't persistent, we can place the player in the room, but
    it would always start in the same spot. If the player is persistent, then when
    they change rooms they will remain at the exact same coordinates they were at
    in the previous room. This means we are going to need to relocate the player to
    a position of our choice in each room.
  prefs: []
  type: TYPE_NORMAL
- en: This could end up being a lot of work if your game is going to have a lot of
    rooms. There is a simple way to solve this by creating self-aware teleporters
    and the use of room creation code.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the rooms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's start by building a few rooms, starting with a title screen.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Room and in the **Settings**, name it `TitleScreen`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Background, `bg_Title`, and load `Chapter 4/Backgrounds/Title.png`
    with **Remove Background** left unchecked.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Backgrounds** tab of `TitleScreen`, apply `bg_Title` as **Background
    0** and check **Visible at Start**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create another Room and name it `C04_R01`. The names here represent the chapter
    and the room, as in Chapter 4, Room 1.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set **Width** and **Height** to `1024`. This will allow us to have lots of space
    to explore.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We don't want to see everything in the room all at once, therefore we need to
    constrain the view. Click on the **Views** tab and check the box for **Enable
    the Use of Views**. Select **View 0** and check the box for **Visible when room
    starts**. This will activate the camera system for the room.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will also want the view to focus on the player and move with it. Still in
    the **Views** tab, select `obj_Player` under **Object following** and set **Vbor:**
    and **Hbor:** to `200`. This will make the camera follow the player and leave
    a buffer of 200 pixels around the edges of the view. Look at the following screenshot
    to ensure you have everything set up correctly:![Setting up the rooms](img/4100OT_04_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create two more rooms `C04_R02`, and `C04_R03` with the same settings we just
    used with `C04_R01`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Resource tree, reorder the room by dragging `Sandbox` down to the bottom
    and `TitleScreen` to the very top. It should look like the following screenshot:![Setting
    up the rooms](img/4100OT_04_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally with all three rooms, create a labyrinth using the wall objects. The
    design isn't important at the moment; just make sure that the player would be
    able to get from one side to the other. An example of what it could look like
    can be seen in the following screenshot:![Setting up the rooms](img/4100OT_04_07.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating Room Portals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to change rooms we are going to create reusable Portals. Each portal
    actually consists of two separate objects, a **Start** object and an **Exit**
    object. The Start object will represent the landing pad for where the player should
    be placed when they enter a room. The Exit object is the teleporter that changes
    what room the player is in. We will utilize four unique portals which will allow
    us to have one door on each side of the map if we want.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the room teleportation system to work we are going to need to use some
    global variables, which need to be initialized at the start of the game. Create
    a new Script, `scr_Globals_StartGame`, with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We create global variables for the four portals and give them a zero value to
    start. We also keep track of the last room we were in, so that we know what portal
    we need to go to in the new room.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Object, `obj_Globals`, add a **Game Start** event, and attach this
    script. This object does not need a sprite, as it is a data object only.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place a single instance of `obj_Globals` into `TitleScreen`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We need to be able to enter the game from the title screen, so let''s create
    a quick fix by adding a **Draw** event and creating a new Script, `scr_Globals_Draw`,
    and with this code add the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here we are just writing some white, centered text letting the player know how
    they can start the game. We use the special variable `vk_anykey` to see if the
    keyboard has been pressed, and if it has, we go to the next room as ordered in
    the Resource tree.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You don't always have to close your scripts, as the game will run even if multiple
    script windows are open.
  prefs: []
  type: TYPE_NORMAL
- en: Let's make some portals! Create a new Sprite, `spr_Portal_A_Start`, load `Chapter
    4/Sprites/Portal_A_Start.png`, and uncheck **Remove Background**. Center the origin
    and then click on **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Object, `obj_Portal_A_Start`, set the Sprite to `spr_Portal_A_Start`.
    This is the landing pad that we will move the player to when they enter into a
    room. It does not need any code, so click on **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Sprite, `spr_Portal_A_Exit`, and load `Chapter 4/Sprites/Portal_A_Exit.png`,
    with **Remove Background** unchecked and the origin centered.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Object, `obj_Portal_A_Exit`, and set the Sprite accordingly. This
    is the actual teleporter and we will change rooms upon collision with the player.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For an `obj_Player` event, create a new Script, `scr_Portal_A_Exit_Collision`,
    and write the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Before we can teleport we need to set the last room to the room the player is
    currently in. To do this we use the built-in variable `room`, which stores the
    index number of the room the game is currently displaying. After that we go to
    the room that this portal's global variable indicates we should go to.
  prefs: []
  type: TYPE_NORMAL
- en: Repeat steps 5 to 9 for portals B, C, and D making sure to change all the appropriate
    values to reflect the proper portal name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The portals are complete and we can add them into the rooms. It is not necessary
    to utilize all four portals in every room; you just need a minimum of one Start
    and one Exit. When placing these objects in the room, it is important that there
    be only one of the same type of portal used. The Start portal should always be
    placed in the playable area and ensure that the Exit can only be accessed from
    one direction. You should also make sure that if one room has **PORTAL A** at
    the bottom, the room it is to enter should have the **PORTAL A** on top, as can
    be seen in the following screenshot. This will help the player understand where
    they are in the world.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating Room Portals](img/4100OT_04_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now comes the interesting part. We need to change the global portal values in
    each room and we don't want to have a massive script that checks all rooms to
    see what is happening. Instead, we can use **Creation Code** in the rooms themselves
    to change these values upon the player entering. Let's try this out by making
    Portal A in `C04_R01` go to `C04_R02` and vice-versa.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `C04_R01` **Settings** tab, click on **Creation Code** to open a code
    editor and write the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We set **PORTAL A** to be the second room. All the other portals are not being
    used, so we set the variables to zero. Every room needs to have all of these variables
    set to some value, either a specific room or zero, otherwise it can cause errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `C04_R02` **Settings** tab, click on **Creation Code** to open a code
    editor and write the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now we have set PORTAL A to the first room, which makes sense. If we go through
    that portal, we should be able to go back through it. Feel free to change these
    settings to apply to all the portals you want.
  prefs: []
  type: TYPE_NORMAL
- en: Teleporting a persistent player
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The rooms have all been built and are ready to go. All that is left for us is
    to have the player move from room to room. Let's start by making the player persistent,
    so that we only need one in the game.
  prefs: []
  type: TYPE_NORMAL
- en: Open `obj_Player` and check **Persistent**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we need to relocate the player to the proper portal. We will create a
    new Script, `scr_Player_RoomStart`, with this code on a **Room Start** event for
    `obj_Player`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'When the player enters a room we check to see which portal is associated with
    the room the player just exited from. We then move the player to the appropriate
    landing pad. To make sure the player is built correctly, its properties should
    look like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Teleporting a persistent player](img/4100OT_04_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Place an instance of the player into `C04_R01`. Do not put the player into any
    other room or you will end up with multiple instances of the player in the game.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the game. We should be able to move around the first room and go through
    PORTAL A, which will take us to the PORTAL A landing pad in the second room. With
    this system, a game could have hundreds of rooms and there only ever needs to
    be four portals to manage.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Bringing enemies to life
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Enemies are more than just obstacles to be avoided. Good enemies give the player
    a sense that there is some underlying **artificial intelligence** (**AI**). The
    enemies seem to know when you are near, can chase you around walls, and wander
    on their own. In this chapter we will create three creatures that will inhabit
    the world, each with their own unique AI.
  prefs: []
  type: TYPE_NORMAL
- en: Summoning the Ghost Librarian
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first creature will consist of two parts: the overdue BookPile and the
    Ghost Librarian that protects it. If the player approaches a BookPile, a Ghost
    will spawn and chase the player. If the player gets too far away from the Ghost,
    the Ghost will return to the BookPile that spawned it. If the player attacks the
    Ghost, it will disappear and respawn from the BookPile. If the player destroys
    the BookPile, the Ghost it spawned will be destroyed as well.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with the BookPile. Create a new Sprite, `spr_BookPile`, and load
    `Chapter 4/Sprites/BookPile.gif` with **Remove Background** checked.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Center the origin and click on **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will also want a scary noise to alert the player of the danger. Create a
    new Sound, `snd_GhostMoan`, and load `Chapter 4/Sounds/GhostMoan.wav`. Click on
    **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Object, `obj_BookPile`, and assign `spr_BookPile` as the Sprite.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We don't want the player to be able to walk through the BookPile, so check the
    box for **Solid**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will need to initialize some variables, so create a new Script, `scr_BookPile_Create`,
    and write the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The first variable sets the value for how close the player needs to be to become
    active and the second variable is Boolean that will determine if this BookPile
    has spawned a Ghost or not.
  prefs: []
  type: TYPE_NORMAL
- en: Add a **Create** event and apply this script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next we need a new Script, `scr_BookPile_Step`, which will be applied to a
    **Step** event and contain the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The first line of the code is incredibly important. Here we are checking to
    see if the player exists before we do anything else. If the player does exist,
    we check if the distance to the player object is within the range, and whether
    this BookPile has spawned a Ghost yet. If the player is within range and hasn't
    spawned anything, we spawn a Ghost. We will also send the unique ID of this BookPile,
    using the `self` variable, into the ghost so it knows where it came from. Next
    we play the Ghost moaning sound, making sure that it does not loop. Finally, we
    indicate that we have spawned a Ghost by changing the `hasSpawned` variable to
    `true`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The only element remaining is to add an `obj_Player_Attack` event with a new
    Script, `scr_BookPile_Collision`, and write the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Once again, we start by checking to see if a Ghost has spawned from this BookPile
    and is still in existence. If it is, we destroy that Ghost and then remove the
    BookPile itself. The BookPile is now complete and should look like the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Summoning the Ghost Librarian](img/4100OT_04_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now we need to build the Ghost. For this we will need to bring in two sprites,
    one for the spawning and one for the chase. Create sprites with **Remove Background**
    checked for `spr_Ghost` and `spr_Ghost_Spawn`, and load `Chapter 4/Sprites/Ghost.gif`
    and `Chapter 4/Sprites/Ghost_spawn.gif`, respectively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In both the sprites, center the origin.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the **Depth:** field to `-50` so that the ghost will appear over most objects,
    but below the player attack object. There is nothing else we need to do, so click
    on **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Object, `obj_Ghost`, and apply `spr_Ghost_Spawn` as the Sprite.
    This will make the spawn animation the initial sprite, and then we will change
    it to the regular Ghost through code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We have several variables that we need to initialize in a new Script, `scr_Ghost_Create`,
    as seen in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We set variables for the movement speed, the range the Ghost will track within,
    who spawned the Ghost, (which we will change through the BookPile),and one for
    whether the Ghost has returned to the BookPile. Notice that the range of the Ghost
    is larger than the range of the BookPile. This will ensure that the Ghost starts
    chasing the player immediately. We then set the animation speed and set an alarm
    for six steps which we will use to change sprites.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add an **Alarm0** event and then apply a new script, `scr_Ghost_Alarm0`, that
    has the following line of code to change sprites:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We are now ready to start implementing some artificial intelligence. The Ghost
    is going to be the most basic enemy that will chase the player through the room,
    including passing through walls and other enemies, until the player gets out of
    range. At that point the Ghost will float back to the BookPile it came from.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start with chasing the player. Create a new script, `scr_Ghost_Step`,
    and write the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: After checking to ensure that the player is alive, we create a variable that
    will hold the distance from the Ghost to the player. The reason we have created
    a `targetDist` variable is that we will be needing this information a few times
    and this will save us from having to recheck the distance each time we have an
    `if` statement. We then compare the distance to the chase range and if the player
    is within range, we move towards the player. The `move_towards_point` function
    calculates the direction and applies a velocity to the object in that direction.
  prefs: []
  type: TYPE_NORMAL
- en: Add a **Step** event and apply this script. We will be continuing to add code
    to this script, but it will function properly already.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's take a moment to test everything we have done so far. First, in the Resource
    tree, move `Sandbox` up to the near top, so that it is the room immediately after
    the title screen. Open the `Sandbox` room and place a couple of instances of `obj_BookPile`
    around the edges as shown in the following screenshot:![Summoning the Ghost Librarian](img/4100OT_04_11.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the game. If you get too close to a BookPile, a single Ghost will spawn
    from it and it will slowly chase the player. If the player gets too far away from
    the Ghost, the Ghost will continue moving in the direction it was last heading
    in and will eventually go offscreen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s get the Ghost to return to its BookPile. In `scr_Ghost_Step`, within
    the braces for the player existence check, add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: First we check to see if the player is out of range and that the Ghost isn't
    near its own BookPile. Here we are using `distance_to_point`, so that we are checking
    the origin of the BookPile rather than the edges of the collision area that `distance_to_object`
    would look for. If this is all true, the Ghost will start moving back to its BookPile.
  prefs: []
  type: TYPE_NORMAL
- en: Let's run the game again. As before, the Ghost will chase the player, and if
    the player gets too far away, the Ghost will return to its BookPile.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'There is an issue with the fact that the Ghost ends up ping-ponging over the
    top of the BookPile. This is due to the Ghost having velocity-based speed and
    not having any code telling it to stop. We can fix this by adding this code after
    the last `else if` statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Here we have a final `else` statement that will execute if the player is out
    of range and the Ghost is near its BookPile. We start by stopping the speed of
    the Ghost. Then we check to see if it can dissolve. If so, we tell the BookPile
    that the Ghost can be spawned again, we change the sprite back to the spawn animation,
    and by setting the `image_speed` to `-1` it will play that animation in reverse.
    We also set another alarm, so that we can remove the Ghost from the world and
    deactivate the dissolve check.
  prefs: []
  type: TYPE_NORMAL
- en: 'Altogether the entire `scr_Ghost_Step` should look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'One last Script is needed, `scr_Ghost_Alarm1`, that is attached to an **Alarm
    1** event and has one line of code to remove the instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The Ghost is almost complete. It spawns, chases the player, and returns to its
    BookPile, but what happens if it catches the player? With this Ghost we will want
    it to smash into the player, cause some damage, and then vanish in a puff of smoke.
    For this we will need to create a new asset for the dead Ghost.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Sprite, `spr_Ghost_Dead`, and load `Chapter 4/Sprites/Ghost_Dead.gif`
    with **Remove Background** checked.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Center the origin and click on **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Object, `obj_Ghost_Dead`, and apply the Sprite.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In a new Script, `scr_Ghost_Dead_AnimEnd`, write the following line of code
    and attach it to an **Animation End** event:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The **Animation End** event will execute code when the last image of the Sprite
    is played. In this case, we have a poof of smoke animation that at the end will
    remove the object from the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'All we need now is to reopen `obj_Ghost` and add an **obj_Player** event with
    a new script, `scr_Ghost_Collision`, with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We start by removing five points of health, and then telling the Ghost''s BookPile
    that it can be respawned. Next we create the Ghost death object which will hide
    the real Ghost when we remove it from the game. If everything is built correctly,
    it should look like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Summoning the Ghost Librarian](img/4100OT_04_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Run the game. The Ghost should now function exactly as designed. It will spawn
    and chase the player. If it catches the player it will cause damage and disappear.
    If the player gets away, the Ghost will return to its BookPile and dissolve out
    of existence. Great work!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: One last thing, as the room is meant to be a sandbox for experimenting in and
    not part of the actual game, we should clean up the room to prepare for the next
    enemy.
  prefs: []
  type: TYPE_NORMAL
- en: Open the `Sandbox` room and remove all instances of the BookPiles.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Building a wandering Brawl
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next enemy we will create is a Brawl that will wander around the room. If
    the player gets too close to this enemy, the Brawl will become enraged by growing
    larger and moving faster, though it won't leave its path. Once the player is out
    of range, it will calm back down and shrink to its original size and speed. The
    player won't be able to kill this enemy, but the Brawl will damage the player
    if there is contact.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the Brawl, we will be utilizing a path and we will need three sprites:
    one for the normal state, one for the transition of states, and another for the
    enraged state.'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Sprite, `spr_Brawl_Small`, and load `Chapter 4/Sprites/Brawl_Small.gif`
    with **Remove Background** checked. This is the Sprite for the normal state. Center
    the origin and click on **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create another new Sprite, `spr_Brawl_Large`, and load `Chapter 4/Sprites/Brawl_Large.gif`
    with **Remove Background** checked. We need to center the origin, so that the
    Brawl will scale properly with this image. The enraged state is twice the size
    of the normal state.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We also need to undergo transition between these two states, so let's create
    a new Sprite, `spr_Brawl_Change` and load `Chapter 4/Sprites/Brawl_Change.gif`,
    still with **Remove Background** checked. Don't forget to center the origin.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next we need a path for the Brawl to follow. Create a new Path and name it `pth_Brawl_01`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We want the Brawl to move smoothly, so check **Smooth Curve** under **Connection
    Kind** and change the **Precision** to `8`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To see what we can do with paths, let's make the Path in the shape of a figure
    eight as can be seen in the following screenshot:![Building a wandering Brawl](img/4100OT_04_13.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's also create a new Sound, `snd_Brawl`, and load `Chapter 4/Sounds/Brawl.wav`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Object, `obj_Brawl`, and apply `spr_Brawl_S` as the default Sprite.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We'll start with initializing some variables in a Create event script, `scr_Brawl_Create`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The first variable sets the base speed of the Brawl. The next three variables
    are checks for the transformation and enraged states, and whether it has attacked.
    Next, we set the animation speed and then we play the Brawl sound, and in this
    case we want the sound to loop. Finally, we set the Brawl onto the path with a
    speed of two; when it hits the end of the path it will loop and most importantly,
    the path is set to absolute, which means it will run based as designed in the
    Path editor.
  prefs: []
  type: TYPE_NORMAL
- en: We can now start working on the AI of the Brawl. Create a new script for a **Step**
    event named `scr_Brawl_Step` and we will start by getting the movement working.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Here we start by rotating the Sprite itself to face in the proper direction.
    This will work, because we have the Sprite images facing to the right, which is
    the same as zero degrees. Next, we check to see if the Brawl is big or not. If
    the Brawl is the enraged version, we set the path speed to be the base speed times
    two. Otherwise, we set the speed to the default base speed.
  prefs: []
  type: TYPE_NORMAL
- en: Place an instance of the Brawl anywhere in the room and run the game. The Brawl
    should move around the figure eight and properly face in the proper direction.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we will add in the first transformation, becoming enraged. Right after
    the previous line of code, add:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We start by making sure the player exists, and then we check to see if the player
    is within range. If the player is in range, we check to see if we have become
    enraged or not. If the Brawl hasn't grown yet, we use the `collision_line` function
    to see if the Brawl can actually see the player or not. This function draws a
    line between two points, in this case the location of the Brawl and the player
    positions, and determines if an instance of an object, or a wall crosses that
    line. If the Brawl can see the player, we change the sprite to the transformation
    sprite, set an alarm so we can finalize the transformation, and indicate that
    the Brawl has grown.
  prefs: []
  type: TYPE_NORMAL
- en: Let's create a script `scr_Brawl_Alarm0` for an **Alarm 0** event with the code
    that will switch to the enraged sprite and indicate that the Brawl is now full
    size.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Run the game to make sure that the code is working. The Brawl should remain
    small until it can clearly see the player, in which case it will then transform
    into the large, enraged Brawl.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We have the Brawl growing larger, now we need to calm it down and have it shrink.
    Back in `scr_Brawl_Step`, add an `else` statement on the distance check, which
    would be before the final brace and add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: If the player is out of range, this `else` statement will become active. We
    check to see if the Brawl is still enraged. If it is, we change the Sprite to
    the transformation, set a second alarm, and indicate that the Brawl is back to
    normal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the full `scr_Brawl_Step` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Duplicate the `scr_Brawl_Alarm0` script, name it `scr_Brawl_Alarm1`, and adjust
    the values as shown in the following code. Remember to add this as an **Alarm
    1** event.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Run the game and confirm that the Brawl grows larger and faster when the player
    is near and in sight, and returns to normal when out of range.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The only thing we have left is the attack. Create a new Script, `scr_Brawl_Collision`,
    for a **obj_Player** event with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: If the player collides with the Brawl for the first time, we remove 10 points
    of health and set an alarm for two seconds that will allow the Brawl to attack
    again.
  prefs: []
  type: TYPE_NORMAL
- en: 'To wrap up the Brawl, all we need is the final **Alarm 2** event with a new
    Script, `scr_Brawl_Alarm2`, that contains the following line of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The Brawl is now complete and functions as designed. If everything is implemented
    correctly, the object properties should look like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building a wandering Brawl](img/4100OT_04_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Remove any instances of `obj_Brawl` from the `Sandbox` room, so that we can
    start fresh for the final enemy.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating the Coach
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The final enemy we will create, the Coach, is going to be the most challenging
    opponent yet. This enemy will move all around the room, randomly going from trophy
    to trophy to make sure it is still there. If it sees the player, it will chase
    them and if it gets close enough, it will have a melee attack. If the player escapes,
    it will wait for a moment before returning to duty. The Coach has a body, so it
    will need to go around obstacles and even avoid other coaches. This also means
    that it can die if the player is able to attack it.
  prefs: []
  type: TYPE_NORMAL
- en: As this enemy is guarding something, we will start by creating the trophy. Create
    a new Sprite, `spr_Trophy`, and load `Chapter 4/Sprites/Trophy.gif` with **Remove
    Background** checked.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Object, `obj_Trophy`, and apply `scr_Trophy` as its Sprite.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As this is an animated sprite, we will want to add a **Create** event and have
    it not animate by writing the following code in a new Script, `scr_Trophy_Create`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This is all we need for now for the trophy, so click on **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Much like the player, we will need four sprites for the four directions this
    enemy will move in.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Sprite, `spr_Coach_WalkRight`, and load `Chapter 4/Sprites/Coach_WalkRight.gif`
    with **Remove Background** checked.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Center the origin, click on **Modify Mask**, and check **Full image** under
    **Bounding Box**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat this process for `spr_Coach_LWalkLeft`, `spr_Coach_WalkDown`, and `spr_Coach_WalkUp`
    sprites.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Object, `obj_Coach`, and apply `spr_Coach_WalkRight` as its Sprite.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are going to be dynamically creating paths for this enemy, so that it can
    navigate to the trophies on its own. We also want it to avoid obstacles and other
    enemies. This isn't too difficult to achieve, but it is going to require a lot
    of setup on initialization.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new Script, `scr_Coach_Create`, apply it to a **Create** event, and
    then we will start with some basic variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Once again we start by setting the speed of the object. Then we have four variables
    representing the various states we will need to check, all set to `false`. We
    also set the animation speed for the sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Next we need to set up the pathing system which will utilize some of GameMaker's
    **motion planning** functions. The basic concept here is that we create a grid
    that covers the area we want to be able to move the enemy in. We then locate all
    the objects we want the enemy to avoid, such as walls, and mark those areas of
    the grid as forbidden. We can then assign a start and goal location in the free
    area and create a path between them while avoiding obstacles.
  prefs: []
  type: TYPE_NORMAL
- en: 'Still in `scr_Coach_Create`, add the following code to the end of the script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The first thing needed is an empty path that we can use for all future paths.
    Next we create a grid that will set the dimensions of the pathing map. The `mp_grid_create`
    attribute has parameters for where it's located in the world, how many grids in
    width and height, and the size of each grid cell. In this case, we start in the
    grid in the upper-left corner and cover the entire room in 32 pixel increments.
    Dividing the room dimensions by 32 means that this will work in any size room
    without having to adjust the code. Finally, we take all instances of the wall
    found in the room and add it to the grid as areas where pathing is not allowed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to find a destination for the Coach to go. Continue adding the
    following code at the end of the script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We start by getting a rounded random number that is based on the amount of trophies
    in the room. Notice that we subtracted one from the number of trophies. We need
    to do this because in the following line of code, we are searching for a specific
    instance using the `instance_find` function. This function is pulling from an
    array and the first item in an array always starts with a zero. Lastly, we have
    created a second variable for when we want to change destinations.
  prefs: []
  type: TYPE_NORMAL
- en: 'All we have to do now is make a path and use it. Add the following code at
    the end of the script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Here we select the grid we created and the empty path, and have a new path created
    that goes from the Coach's position to the targeted location and will not go on
    diagonals. Then we set the Coach into motion and this time, when it hits the end
    of the path, it will come to a stop. The final value in the `path_start` function
    sets the path to absolute, which we want in this case as the path is created dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the entire `scr_Coach_Create` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Open up Sandbox, and place two instances of `obj_Coach` in the corners and three
    instances of `obj_Trophy` as seen in the following screenshot:![Creating the Coach](img/4100OT_04_15.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the game. You should see the coaches randomly select a trophy and move towards
    it. Try and restart it a few times to see the different paths each Coach takes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With the basic setup complete, we can move on to the AI. We will start by switching
    the sprites based on the direction of movement. Create a new Script, `scr_Coach_Step`,
    apply it to a **Step** event and write the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Here we are changing the Sprite based on the direction of the instance as it
    moves. We can do this here, because we are not allowing diagonal movement on the
    path.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will get the Coach to watch for the player, and if spotted, they will
    leave their path in pursuit. Add the following code after the Sprite change code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Once again we are using a variable to hold the value of how far away the player
    is to save us some coding time and minimize function calls. If the player is within
    range and not within striking distance, we do a sightline check. The `collision_line`
    function returns the ID of any wall instance that the line crosses. If it does
    not intersect with any wall instances, it will return a special variable called
    `noone`. If the player is in sight, we end the path the Coach is following, and
    start moving towards the player. The `mp_potential_step` function will make an
    object move in the desired direction while avoiding obstacles, and in this case
    we are avoiding all instances. Finally we indicate that the Coach is chasing the
    player.
  prefs: []
  type: TYPE_NORMAL
- en: 'This works well for starting the chase, but what if the player escapes? Let''s
    have the Coach wait for a moment and then go back to patrolling. Add an `else`
    statement to the sightline check with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: This `else` statement states that if the player cannot be seen and the Coach
    is chasing, it will set an alarm for finding a new destination, tell it to wait,
    and the chase is over.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have set an alarm, so let''s create a new Script, `scr_Coach_Alarm0`, and
    apply it to an **Alarm 0** event. Write the following code in the script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: We start with a `while` loop checking to see if the next location is the same
    as the old location. This will ensure that the Coach always moves to another trophy.
    Just as we did in the initial setup, we select a new target and set the current
    location variable. We also create a Path and start moving on it, which means the
    Coach is no longer waiting.
  prefs: []
  type: TYPE_NORMAL
- en: We have one last element we need to add to the chase sequence, the attack. If
    the Coach gets close enough to the player, it should melee attack the player.
    For this we need to first create a new Sprite, `spr_Coach_Attack`, with `Chapter
    4/Sprites/Coach_Attack.gif` loaded and **Remove Background** checked.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Just like the player''s attack, set **Origin** to **X:** `-16`, **Y:** `24`
    and adjust the **Bounding Box** values to **Left**: `0`, **Right**: `24`, **Top**:
    `0`, and **Bottom**: `4`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Object, `obj_Coach_Attack`, apply the Sprite to it, and set **Depth**
    to `-100`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a **Create** event and apply a new Script, `scr_Coach_Attack_Create`, with
    code to control the animation speed, set an alarm to remove the instance, and
    a variable that we can turn on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Add an **Alarm 0** event with a new Script, `scr_Coach_Attack_Alarm0`, that
    removes the instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, add an **obj_Player** event, and apply a new Script, `scr_Coach_Attack_Collision`
    with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: If this is the first collision, we remove a point of health and then deactivate
    this check.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are done with the attack. Now to have it activated in the Coach, reopen
    `scr_Coach_Step` and add the attack code as an `else if` statement, after the
    last brace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: If the Coach is near the player and has not attacked yet, we create an instance
    of the Coach Attack. We then rotate the attack Sprite to face the same direction
    as the Coach. An alarm is set for three seconds to allow for a breather before
    this code can be run again.
  prefs: []
  type: TYPE_NORMAL
- en: We need an **Alarm 1** event to reset the attack, so create a new script, `scr_Coach_Alarm1`
    and turn off the attack.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Run the game. The Coach will now chase the player, and if it gets close enough
    to the player it will attack.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Coach is now only doing half of its job, chasing the player. We still need
    to add in the regular patrol duties. Currently, if the Coach doesn't see the player
    and it gets to the end of the path, it stops and does nothing again. It should
    only wait a few seconds and then move on to the next trophy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Reopen `scr_Coach_Step` and add an `else` statement to the very end of the
    script with this code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: This `else` statement means that the player is out of range. We then check to
    see if the Coach is waiting or not. If it isn't waiting, but is within eight pixels
    of its targeted trophy, we set the alarm for choosing a new destination for two
    seconds, end the path to stop movement, and state that we are now waiting.
  prefs: []
  type: TYPE_NORMAL
- en: Run the game and you should see the coaches, when not chasing the player, stopping
    near a trophy, pausing for a moment, and then moving to another trophy.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'There is an issue, however, if both coaches go to the same trophy. Sometimes
    they will both overlap each other. Let''s fix that by adding the following code
    after the distance check for the trophy:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The first thing we need to do is do a variable check to see if the Coach needs
    to avoid something. If it does, we use the `mp_potential_step` function which
    will move an instance towards a specified goal while attempting to avoid certain
    objects, or in this case, all instances.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to set up the condition for when avoidance should occur. Immediately
    after the last code is inserted, write the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: First we check to see if an instance of the Coach is nearby and it hasn't tried
    to avoid it. If that is true then we take the Coach off of its path and start
    to avoid. We follow this with an `else if` statement checking to see if we are
    far enough away from another Coach that we were trying to avoid. If so, we set
    a new path to the destination, start moving on it, and end the avoidance.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is still one little issue remaining, which you can see if you run the
    game for a while. Sometimes two coaches will get too close together and they both
    stop. This is because they are trying to avoid each other, but are actually touching
    and can''t let go. At the very end of the `scr_Coach_Step` Script, write the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: This will check to see if two instances of the Coach are colliding with each
    other. If they are, we set the `x` and `y` coordinates to the special variables
    `xprevious` and `yprevious`, which represent the position of the instance in the
    previous step. Once they have taken a step back, we can then attempt to move around
    them again.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Coach is now complete. To check to see if you have all the code for `scr_Coach_Step`
    written correctly, here it is in its completed form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Adding finishing details to the game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The game is now functionally complete, but there are a few elements left to
    polish up. To start, the player takes damage but never dies, nor is there a **heads-up
    display** (**HUD**) to show this. Let's create a quick Overlord.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Object, `obj_Overlord`, with no sprite applied and persistence
    is checked.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a **Draw GUI** event and a new Script for it, `scr_Overlord_DrawGUI`, with
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: First, we use the function `draw_healthbar` which you can see has a lot of parameters.
    The first four are the size and placement of a rectangular bar. Next is the variable
    to be used for how full the bar is, in our case, the global health variable. The
    next three are the background color, and the min/max colors. Next is the direction
    the bar should fall, zero being to the left. The final two Booleans are for drawing
    the background and border that we want.
  prefs: []
  type: TYPE_NORMAL
- en: After that we do a health check and if the player should be dead, we remove
    the player, return to the frontend, and then remove the Overlord itself. It is
    important to remove any persistent instances in the world or they won't go away!
  prefs: []
  type: TYPE_NORMAL
- en: Place a single instance of `obj_Overlord` into `C04_R01`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Populate the rooms with a variety of enemies. If we use the Brawl we will either
    need to create a room that works with the path we created, or even better, redraw
    the path to fit our room layout.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure the `Sandbox` room is moved back to the bottom of the Resource tree
    and run the game. We should see the health bar at the top of the screen and if
    you take damage, the health bar should go down. If the player takes too much damage,
    the game will end and return to the frontend.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'All that is left is to create levels, paint the world with a tile set, and
    add some background music. At this point you should know how to do that, so we
    will leave it up to you. We have supplied some additional assets for this purpose
    in the `Chapter 4` folder. You should have something that looks like the following
    screenshot when you are done:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding finishing details to the game](img/4100OT_04_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Congratulations on completing your second game! We learned how to simplify the
    player controls by placing the keyboard checks and collision forecasting into
    a single script. We covered several ways to deal with Sprite animation from rotating
    the image to setting what sprites should be displayed. We dealt with global variables
    and used them to implement a room transitioning system. We covered some new object
    properties in depth and persistence. Then we spent some time dealing with artificial
    intelligence through the use of proximity detection and path finding. We even
    discovered how to make an object navigate a room on its own while avoiding obstacles.
  prefs: []
  type: TYPE_NORMAL
- en: With the skills you have honed in this chapter, you will now be able to build
    games with multiple rooms with enemies that appear to think. It's your turn now
    to extend this game by adding more unique enemies, have the trophy open, and spawn
    loot. Have fun and explore your new found abilities!
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter we are going to build an epic boss fight for a platformer
    style game. There will be guns and lasers, and lots of fun. We will be starting
    to make our code more efficient by looking at creating reusable scripts, and learning
    how to structure our code systematically. All of this will help us to make our
    games faster and easier, so let's get going!
  prefs: []
  type: TYPE_NORMAL
