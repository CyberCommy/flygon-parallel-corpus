- en: Chapter 8. Spring with OSGI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**OSGI** is a short form **Open Service Gateway Intiative**. It''s a specification
    consisting of a modular system and service platform for the dynamic deployment
    of modules. As per the specification, the application can be broken down into
    modules and deployed independently. When we think of developing an OSGI application,
    it means that we need to use the OSGI API available to develop the application.
    The second step would be to deploy it in the OSGI container. So, while developing
    applications in OSGI, we can break the application into modules and independently
    deploy them, and then uninstall; we can also have various versions of the application
    running in parallel. In this chapter, we shall see how Spring supports the OSGI
    bundled development and the deployment of its application. We shall first start
    with OSGI and then gradually move over to Springs''s support.'
  prefs: []
  type: TYPE_NORMAL
- en: OSGI containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'OSGI containers must implement a set of services, and a contract is established
    between the OSGI container and application. All the following mentioned OSGI containers
    are open source:'
  prefs: []
  type: TYPE_NORMAL
- en: '**KnoplerFish**: The Knopler framework can be easily installed and it is easier
    to bundle and deploy modules in the container. The Bundle applications need a
    `.manifest` file and build `.xml` file. It''s mandatory to have the framework.
    JAR file should be available in the Java build path. The Bundle that needs to
    be deployed in the KnoplerFish container will have a class that implements the
    `BundleActivator` interface. The interface comes with `start()` and `stop()` methods
    that needs to be implemented. Usually a thread class is also created, and the
    thread is started in the `BundleActivator` interface implementation class''s start
    method, and stopped in the stop method. You can also create an OSGI service by
    creating an interface and implementation class. The service can be registered
    in the `BundleActivator` class'' `start()` method. That is the class that implements
    the `BundleActivator` interface. There are `ServiceListeners` and `ServiceTrackers`
    to monitor the OSGI services in the container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Equinox**: This is an implementation of the core OSGI framework. It provides
    various optional OSGI services. Eclipse offers an OSGI plugin to develop OSGI
    bundled applications. Eclipse offers a JAR file which can be easily installed,
    using Eclipse''s install start, stop command.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Apache Felix**: Apache Felix is another OSGI container from Apache projects.
    Felix has various subprojects which can be plugged in. It also supports a similar
    way of application development, as explained under Knoplerfish. It also has a
    Maven bundle plugin.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OSGI usage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let us list the key usages of OSGI framework:'
  prefs: []
  type: TYPE_NORMAL
- en: The framework offers modularity of the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The framework implements bundle based architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiple versions of the same project can be made to run in parallel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can also integrate the OSGI applications and OSGI bundles into web containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are also a few challenges of making it work with the front end of web
    applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are lot of frameworks, at least four frameworks, available for developing
    POJO applications on top of OSGI specification
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The size of the OSGI bundle is relatively small
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring integration with OSGI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring provides complete support for OSGI development. The OSGI module support
    was called Spring OSGI, and it is presently updated with a new set of libraries
    and versions called Spring Dynamic Modules. A Spring Dynamic Module allows you
    to write Spring applications on top of an OSGI framework. One of its challenges
    is to make simple POJOs to seamlessly work with the OSGI framework and to integrate
    Spring Beans as an OSGI service. Spring Beans can be exported as an OSGI services
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The Spring dynamic programming model provides API programming and Spring Beans
    are visible across bundles. The Spring dynamic model provides us with the dependency
    injection across bundles, and with all the support for OSGI from the Spring dynamic
    service, handling has become easier.
  prefs: []
  type: TYPE_NORMAL
- en: Every bundle will ideally have a separate application context. The application
    context is created and destroyed with the start and stop of the bundle. These
    context files are present under META-INF.
  prefs: []
  type: TYPE_NORMAL
- en: 'A typical bundle structure is depicted in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Spring integration with OSGI](img/7320OS_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The following image depicts how OSGI modules can be part of web applications
    and how each bundle interacts with the OSGI framework. You can also see that there
    are many web applications on the web container which access the application bundles
    as services using the OSGI framework.
  prefs: []
  type: TYPE_NORMAL
- en: '![Spring integration with OSGI](img/7320OS_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Spring Dynamic Modules and OSGI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let us look at how Spring Dynamic Modules work. Spring comes with its OSGI integration
    framework, which has a class called `extender`. This checks for all existing bundles
    and marks the bundles which are powered by Spring. The extender marks a bundle
    as Spring compatible only if it has Spring context manifest header or an XML file
    in `META-INF`/`spring` folder. All the preceding steps are triggered on start
    up and the extender package is available on `org.springframeork.osgi.bundle.extender`.
    Now, we have to know why Spring dynamic modules mark the Spring powered bundles.
    The bundles with Spring configuration files are further converted to an application-context
    object. The extender not only marks the Spring powered bundles to create an application-context
    object, but also checks if the bundle is importing any OSGI services. If any such
    bundle is found exporting an external service, then such beans are moved to the
    OSGI shared service registry. The extender registers bundles that export OSGI
    services with a listener and events. OSGI is also tested with Equinox, Felix and
    KnoplerFish.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the steps to be followed when setting up Spring DM in Eclipse
    IDE:'
  prefs: []
  type: TYPE_NORMAL
- en: Download Spring DM; look out for the latest Spring OSGI DM.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extract the ZIP file into the local directory; call it `c:\OSGI-SPRING`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new workspace while starting Eclipse.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import all the necessary JAR files and all the Spring DM JAR files by choosing
    the **Plugin Development** option, or the **Install plug-in** option in Java.
    Ensure that you have all the following mentioned plugins in the Eclipse environment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`org.springframeork.osgi.bundle.core`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`org.springframeork.osgi.bundle.extender`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`org.springframeork.osgi.bundle.io`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`org.springframeork.bundle.spring.aop`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`org.springframeork.bundle.spring.beans`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`org.springframeork.bundle.spring.context`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`org.springframeork.bundle.spring.core`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`org.springframeork.bundle.spring.jdbc`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`org.springframeork.bundle.spring.tx`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`org.springframeork.osgi.aopalliance.osgi`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simple applications with OSGI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, let us first develop a simple OSGI application. We shall create
    two bundles—one which provides the service to print a string and another bundle
    which would consume the service at an equal interval of time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following is the first bundle:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Exporting the service using activator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now, we have the first bundle ready and we shall use Maven to build it. We also
    need the Maven bundle plugin to build the XML file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: To build it, a simple `mvn install` command is sufficient.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, let us try to consume the service:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we must again create an activator for the consumer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Integrating Spring Dynamic Modules with OSGI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, let us demonstrate how we can integrate Spring Dynamic Modules
    to work with an OSGI application. Spring Dynamic Modules (Spring DM) makes the
    development of OSGI-based applications a lot easier. We can easily inject the
    services like any other Spring beans.
  prefs: []
  type: TYPE_NORMAL
- en: 'We shall look at the following dependencies required to integrate Spring Dynamic
    Modules:'
  prefs: []
  type: TYPE_NORMAL
- en: OSGI services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `BundleActivator` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Context.xml` file configuration to inject in the service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is the list of dependencies that needs to be made available in
    the application classpath:'
  prefs: []
  type: TYPE_NORMAL
- en: '`com.springsource.net.sf.cglib-2.1.3.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`com.springsource.org.aopalliance-1.0.0.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`log4j.osgi-1.2.15-SNAPSHOT.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`com.springsource.slf4j.api-1.5.0.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`com.springsource.slf4j.log4j-1.5.0.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`com.springsource.slf4j.org.apache.commons.logging-1.5.0.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`org.springframework.aop-3.x.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`org.springframework.beans-3.x.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`org.springframework.context-3.x.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`org.springframework.core-3.x.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spring-osgi-core-1.2.1.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spring-osgi-extender-1.2.1.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spring-osgi-io-1.2.1.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, let us create a simple `HelloWorldService` interface class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Next, we shall implement the `service` class. This is class does a simple
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We shall write an activator class which needs to activate the service `BundleActivator`.
    The `ProviderActivator` class that we need to call is `HelloWorldService`. We
    are actually registering the service. However, using the Spring DM integration
    makes things simple for us with a configuration. We don't need this integration
    class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We just have to create a `provider-context.xml` file in the folder `META-INF`/`spring`.
    This is a simple context in XML file, but we use a new namespace to register the
    service - [http://www.springframework.org/schema/osgi](http://www.springframework.org/schema/osgi).
    So, let us start:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The only thing specific to OSGI is the `osgi:service` declaration. This line
    indicates that we need to register the `HelloWorldService` as an OSGI service,
    using the interface `HelloWorldService` as the name of the service.
  prefs: []
  type: TYPE_NORMAL
- en: If you put the context file in the `META-INF`/`spring` folder, it will be automatically
    detected by the Spring Extender and an application context will be created.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now go to the consumer bundle. In the first phase, we created that consumer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let us write the `BundleActivator` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The injection is not necessary anymore. We can keep the start of the timer here,
    but, once again, we can use the features of the framework to start and stop the
    timer.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let us delete the activator and create an application context to create
    the consumer and start it automatically, and put it in the `META-INF`/`spring`
    folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We used the `init` method and `destroy` method attributes to start and stop
    the time with the framework, and we use the `constructor-arg` to inject the reference
    in to the service. The reference to the service is obtained using the `osgi:reference`
    field and using the interface as a key to the service.
  prefs: []
  type: TYPE_NORMAL
- en: That's all we have to do with this bundle. A lot more simple than the first
    version isn't it? And more than the simplification, you can see that the sources
    aren't depending on either OSGI or Spring Framework; this is plain Java and is
    a great advantage.
  prefs: []
  type: TYPE_NORMAL
- en: The Maven POM files are the same as in the first phase, except that we can cut
    the dependency to OSGI.
  prefs: []
  type: TYPE_NORMAL
- en: 'The provider:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The consumer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'And we can build the two bundles using the Maven install. So, let us test our
    stuff in Felix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In conclusion, Spring DM really makes the development with OSGI easier. With
    Spring DM, you can also start bundles. It also allows you to make web bundles
    and to use the services of the OSGI compendium easily.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have developed a simple OSGI application. We also demonstrated
    how Spring DM supports the OSGI development, reduces the creation of files, and
    makes things easier with configuration.
  prefs: []
  type: TYPE_NORMAL
