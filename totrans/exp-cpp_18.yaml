- en: Using C++ in Machine Learning Tasks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Artificial intelligence** (**AI**) and **machine learning** (**ML**) have
    become more and more popular recently. From a simple food delivery website to
    complex industrial robots, AI has been declared as one of the main features powering
    software and hardware. While, most of the time, the terms are used to make the
    product look more serious, some companies are intensively researching and incorporating
    AI into their systems.'
  prefs: []
  type: TYPE_NORMAL
- en: Before we go further, take into account the fact that this chapter is a gentle
    introduction to ML from a C++ programmer's perspective. For more comprehensive
    literature, refer to the list of books at the end of the chapter. In this chapter,
    we will introduce the concepts of AI and ML. While it is preferred to have a mathematical
    background, we almost don't use any math in this chapter. If you are planning
    to enlarge your skillset and dive into ML, you must consider studying mathematics
    first.
  prefs: []
  type: TYPE_NORMAL
- en: Besides introducing the concepts, the chapter also provides examples of tasks
    in ML. We are going to implement them and give you a basic idea of how you should
    research and move forward with solving more complex tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in the chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to AI and ML in general
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Categories and applications of ML
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing a C++ class for calculations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Neural network structure and implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regression analysis and clustering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The g++ compiler with the `-std=c++2a`  option is used to compile the examples
    throughout the chapter. You can find the source files used in this chapter at [https://github.com/PacktPublishing/Expert-CPP](https://github.com/PacktPublishing/Expert-CPP).
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to AI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The simplest definition of AI is robots acting like humans. It is the intelligence
    demonstrated by machines. And here goes the discussion around the definition of
    intelligence. How can we define it for machines, and at what level should we shout
    out loud that we are dealing with an intelligent machine?
  prefs: []
  type: TYPE_NORMAL
- en: If you are not familiar with the different tests to verify the intelligence
    of a machine, one of the popular ways to do so is the Turing test. The idea is
    to have an interrogator asking questions to two people, one of them being a machine
    and the other a human. If the interrogator can't make a clear distinction between
    those two, the machine should be considered intelligent.
  prefs: []
  type: TYPE_NORMAL
- en: The Turing test is named after Alan Turing. The test was introduced in his paper
    *Computing Machinery and Intelligence* in 1950\. He proposed using the imitation
    game to determine whether a machine thinks like a human.
  prefs: []
  type: TYPE_NORMAL
- en: 'The people being interrogated are behind a wall so that the interrogator can''t
    see them. The interrogator then asks several questions to both the participants.
    The following diagram demonstrates how the interrogator communicates with the
    human and the machine, but can''t physically see them:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/34dd7f9a-7753-4539-9a3a-526fa0f79ee3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When you start diving into the field of AI, the definition of intelligence
    gets more and more vague. Questions can be asked to a machine in any form: in
    text, in audio, in visual form, and so on. There are numerous things that might
    never be available in machines, such as the look on their face. Sometimes people
    understand each other''s mood by the look on their faces. You can''t be sure whether
    a robot will understand or will even be able to imitate the mood on its face.
    No one taught us to look angry when we are angry. No one taught us to have emotions.
    They are just there. It''s hard to tell whether some day, something similar might
    be achieved for machines.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When speaking about AI, most of the time we presume it''s about a robot that
    talks and behaves similar to humans. But when you try to dissect it as a programmer,
    you meet a lot of sub-fields, each of which takes a lot of time to understand.
    Many of the fields have a lot of tasks in progress or are in the early research
    phase. Here are some of the sub-fields in AI that you might be interested in focusing
    on in your career:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Computer vision**: Designing algorithms for visual object recognition and
    understanding objects by analyzing their visual representation. It''s easy for
    humans to spot a familiar face in the crowd, but implementing a similar functionality
    for machines might take a lot of time to gain accuracy equal to humans.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Natural language processing** (**NLP**): A linguistic analysis of text by
    machines. It has applications in various segments, such as machine translation.
    Imagine the computer completely understands human written text so that we can
    tell it what to do instead of spending months learning a programming language.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Knowledge reasoning**:This might seem the obvious goal for machines to behave
    intelligently. Knowledge reasoning is concerned with making machines reason and
    provide solutions based on the information they have; for example, provide a diagnosis
    by examining medical conditions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ML**: A field of study of algorithms and statistical models used by machines
    to perform tasks without explicit instructions. Instead of direct instructions,
    ML algorithms rely on patterns and inference. That said, ML allows machines to
    do the job on their own, without human involvement.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's discuss the preceding sub-fields separately and then concentrate on ML.
  prefs: []
  type: TYPE_NORMAL
- en: Computer vision
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Computer vision is a comprehensive field of study and has a lot of ongoing research
    projects. It is concerned with almost everything related to visual data processing.
    It has wide applications in various areas; for example, face recognition software
    processing data from various cameras spread over the city to find and determine
    criminal suspects, or optical character recognition software that produces text
    from images containing it. Combined with some **augmented reality **(**AR**) technologies,
    the software is able to translate text in images to language familiar to the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Study in this field is making progress by the day. Combined with AI systems,
    computer vision is the field that makes machines perceive the world as we do.
    A simple task for us, however, is challenging to implement in terms of computer
    vision. For example, when we see an object in an image, we easily spot its dimensions.
    For example, the following image represents the front view of a bicycle:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1e417264-3431-4087-a127-a74603e541bf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Even if we don''t mention that it''s a bicycle, it''s not so hard for a human
    to determine it. It''s obvious for us that the black bold line at bottom center
    is the front wheel of the bicycle. It''s hard to tell the computer to understand
    that it is a wheel. All the computer sees is a collection of pixels, some of which
    have the same color:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1f146977-eca9-4201-8f08-c4874284568e.png)'
  prefs: []
  type: TYPE_IMG
- en: Besides understanding the wheel of the bicycle, it also should deduce that this
    bicycle must have another wheel that is not visible in the image. And again, we
    might have a guess for the approximate size of the bicycle, while it's a comprehensive
    task for the computer to determine it from the image. That said, the simple thing
    in our perspective might become a real challenge in computer vision.
  prefs: []
  type: TYPE_NORMAL
- en: We suggest using the OpenCV library for computer vision tasks. It is a cross-platform
    library written in C and C++. OpenCV represents a set of functions aimed at real-time
    computer vision, including ,but not limited to, facial recognition, gesture recognition,
    motion understanding, motion tracking, and other features.
  prefs: []
  type: TYPE_NORMAL
- en: Typical tasks in computer vision include object recognition, identification,
    and detection. Object recognition is the understanding that the object is a vehicle
    from the preceding image. Identification is the recognizing of an individual instance
    of an object, for example, the wheel of the bicycle in the preceding image. Object
    detection tasks might include finding corrupted areas of a bicycle from its image.
    All of these tasks combined with ML algorithms might comprise a comprehensive
    software that understands its surroundings close to the way humans do.
  prefs: []
  type: TYPE_NORMAL
- en: NLP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another interesting field of study is NLP. NLP makes efforts to make computers
    understand human languages. A more generalized approach is automatic speech recognition
    and natural language understanding; a key feature of virtual assistants. Today,
    it''s not magic anymore to talk with your phone and ask it to search for something
    on the web, for example. All of the process is powered by complex algorithms in
    speech and text analysis. The following diagram shows the high-level view of the
    process happening behind the conversational agents:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2afbe1d3-4236-437b-8728-a7a864c33172.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Many language processing tasks are related to the web. A search engine processing
    the user input to search among millions of documents on the web is one of the
    top applications of NLP. In the next chapter, we are diving a lot deeper into
    search engine design and implementation. One of the main concerns in search engine
    design is processing the text data. The search engine cannot just store all the
    websites and respond to the user for the first match for the query. There are
    numerous tasks in NLP that have complex implementations. Suppose that we are designing
    a program that is fed with a text document and we should output sentences within
    the document. Recognizing the beginning and the end of a sentence is one of the
    complex tasks. The following sentence is a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The program will output two sentences:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In terms of a coding task, we just search for the . (dot) character at the end
    and make sure the first word started with the capital letter. How would the program
    behave if one of the sentences had the following form?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As there is an exclamation point at the end of the sentence, we should revisit
    our program to add another rule for recognizing the ending of a sentence. What
    if a sentence ends like this?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: One by one, more and more rules and definitions are introduced to have a fully
    functional sentence extractor. Leveraging ML moves us to a smarter direction when
    solving NLP tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Another language-related task is machine translation that, which automatically
    translates a document from one language to another. Also, note that building a
    comprehensive NLP system will benefit other fields of study, such as knowledge
    reasoning.
  prefs: []
  type: TYPE_NORMAL
- en: Knowledge reasoning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Knowledge reasoning is making computers think and reason in a similar way to
    humans. Imagine having a conversation with a machine, starting like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We can program the machine to answer specific questions or understand complex
    text input by user, but it''s a lot harder to make the machine reason based on
    previous experience. For example, the following reasoning is one of the goals
    of the study:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: While it might seem easy to spot the connection between catching a cold and
    the rain, it takes a lot of effort for the program to deduce it. It must associate
    the rain with cold and having a temperature with catching a cold. It also should
    remember the previous input to use it for intelligently keeping the dialog.
  prefs: []
  type: TYPE_NORMAL
- en: All of the preceding mentioned fields of study are exciting areas for a programmer
    to dive deeper. Finally, ML in general is something that sits at the fundament
    for all other fields in terms of designing algorithms and models for each specific
    application.
  prefs: []
  type: TYPE_NORMAL
- en: ML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ML takes us to a whole new level of making machines execute tasks the way humans
    do, maybe even better. Compared to the fields we introduced previously, the goal
    of ML is to build systems that are able to do things without specific instructions.
    In the journey of inventing artificially intelligent machines, we should take
    a closer look at human intelligence. When it is born, a child doesn't express
    intelligent behavior but starts to slowly become familiar with the surrounding
    world. There is no recorded evidence of any 1-month-old child solving differential
    equations or composing music. In the same way a child learns and discovers the
    world, ML is concerned with building the foundational models that directly perform
    the tasks, but rather are able to learn how to do it. That's the fundamental difference
    between setting the system to carry out predefined instructions and letting it
    figure it out on its own.
  prefs: []
  type: TYPE_NORMAL
- en: When a child starts walking, taking things, talking, and asking questions, they
    are gaining knowledge about the world step by step. She or he takes a book, tries
    its flavor, and sooner or later stops chewing books as something edible. Years
    pass and the child now opens the pages of the book and looks for images in it
    and the little figures comprising the text. A few more years pass and, the child
    starts to read them. Over the years, the brain gets more and more complicated
    and creates more and more connections between its neurons. The child becomes an
    intelligent human being.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine a system that has some magical algorithms and models in it. After feeding
    it with a bunch of data, it will be able to understand more and more, the same
    way the child gets to know the world by processing the input data in the form
    of visual data (looking through their eyes), or smell, or flavor. Later on, by
    developing a way to ask questions, the child gets to understand words and associates
    those words with objects in the real world, and even intangible concepts. ML systems
    act almost in the same way. They process the input data and produce some output
    that conforms to the results expected by us. The following diagram illustrates
    the idea:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e1574aeb-59e5-4890-a1cb-0c31e04315f3.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's now dive deeper into ML. As always, the best way to understand something
    new is to try to implement it first.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding ML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ML is a big field of study with a lot of research in progress and is expanding
    rapidly. To understand ML, we should first understand the nature of learning.
    Thinking and reasoning are the key concepts that make us – humans – special. The
    core of ML is to make the system learn and use the knowledge to act upon tasks.
    You might recall your first steps in studying programming. We are sure it wasn't
    easy. You had to learn new concepts, build abstractions, and make your brain understand
    what's going on under the hood of program execution. After that, you were supposed
    to build complex systems using those small building blocks described in primers
    as keywords, instructions, conditional statements, functions, classes, and so
    on.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, an ML program differs from the programs we usually create. Take a
    look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The simple precedent program does what we instructed it to do. It contains
    several simple instructions that lead to the variable `c` representing the sum
    of `a` and `b`. We can modify the function to take user input as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding function will never gain any intelligence. It doesn''t matter
    how many times we call the `calculate()` function. It also doesn''t matter what
    numbers we provide as its input. The function represents a collection of instructions.
    We might say even a collection of hardcoded instructions. That is, the function
    will never modify its own instructions to behave differently based on the input.
    However, we can introduce some logic; let''s say we make it return 0 each time
    it receives negative numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The conditional statement introduced the simplest form of a decision that the
    function makes based on its input. We can add more and more conditionals so that
    the function will grow and have a complex implementation. However, no number of
    conditional statements will make it smarter because it is not something that the
    code comes up with its own. And here comes the limit that we face when dealing
    with programs. They don't think; they act as we programmed them to act. We are
    the ones who decide how they must behave. And they always obey. Well, as long
    as we didn't introduce bugs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, imagine an ML algorithm in action. Suppose the `calculate()` function
    has some magic in it, so that it returns a value based on the input. Let''s say
    it has the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Now, suppose that we are calling `calculate()` and passing `2` and `4` as its
    arguments, hoping that it will calculate their sum and return `6`. Also, imagine
    that we can somehow tell it whether the result is what we expected. After a while,
    the function behaves in a way that it understands how to use those input values
    and return their sum. The following class that we are building represents our
    first steps toward understanding ML.
  prefs: []
  type: TYPE_NORMAL
- en: Designing an algorithm that learns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following class represents a calculation machine. It comprises four arithmetic
    operations and expects that we provide examples of how it should calculate the
    input values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Before using the `calculate()` function, we should provide a list of examples
    for the `setExamples()` function. Here''s a sample of the examples that we provide
    to `CalculationMachine`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The first two numbers in each line represent the input arguments; the third
    number is the result of the operation. The `setExamples()`  function is how the
    `CalculationMachine` learns to use the correct arithmetic function. The same way
    we can guess what''s going on from the preceding examples, the same way  `CalculationMachine`
    tries to find the best fit for its operations. It goes through examples and defines
    which of the functions it should use when `calculate()` is called. The implementation
    is similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from the preceding example, the function calls all the arithmetic
    functions and compares their return value with the example output. Each time the
    result is correct, it increases the count of correct answers for the specific
    function. Finally, the function having the maximum number of correct answers is
    assigned to `fptr_` that is used by the `calculate()` function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We have devised a simple learning algorithm. The `setExamples()` function might
    be renamed `setDataSet()` or `trainWithExamples()` or something similar. The point
    of the example with `CalculationMachine` is that we define a model and algorithm
    working with it and we can call it ML. It learns from data. Or, even better, it
    learns from experiences. Each record in the vector of examples that we provided
    to `CalculationMachine` can be regarded as an experience. We say that the performance
    of the calculation improves with experience. That is, the more we provide examples,
    the more it becomes confident in choosing the right function to perform the task.
    And the task is calculating the value based on two input arguments. The process
    of learning itself is not the task. Learning is what leads to performing the task.
    Tasks are usually described as how the system should process an example, where
    an example is a collection of features. Although, in ML terms, an example is represented
    as a vector (mathematical) where each entry is another feature, the choice of
    the vector data structure is just a coincidence. As one of the fundamental principles
    is the training of the system, ML algorithms can be categorized as supervised
    or unsupervised. Let's examine their differences and then establish various applications
    of ML systems.
  prefs: []
  type: TYPE_NORMAL
- en: Categories of ML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following diagram illustrates the categorization of ML:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/57c4aa6a-343d-43e9-8060-f24d62dee7b3.png)'
  prefs: []
  type: TYPE_IMG
- en: Categorization of ML algorithms depends on the kind of experience they have
    during the learning process. We usually call the collection of examples a *dataset*.
    Some books also use the term *data points*. A dataset is basically a collection
    of data representing anything useful to the target system. It might include measurements
    of weather for periods of time, a list of prices for the stock of some company
    or companies, or any other set of data. While the dataset might be unprocessed
    or so-called raw, there are also datasets having additional information for each
    contained experience. In the `CalculationMachine` example, we used a raw dataset,
    although we already programmed the system to recognize that the first two values
    are the operands of the operation and the third value is its result. As already
    mentioned, we categorize ML algorithms into supervised and unsupervised.
  prefs: []
  type: TYPE_NORMAL
- en: Supervised learning algorithms learn from labeled datasets; that is, each record
    contains additional information describing the data. `CalulcationMachine` is an
    example of a supervised learning algorithm. Supervised learning is also known
    as **training with an instructor**. The instructor teaches the system using the
    dataset.
  prefs: []
  type: TYPE_NORMAL
- en: 'The supervised learning algorithm will be able to label new unknown data after
    learning from experiences  provided. The following diagram describes it best:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3c11cb39-8e0b-48ed-af2b-e498f0345c35.png)'
  prefs: []
  type: TYPE_IMG
- en: A good example of an application of supervised learning algorithms is the spam
    filter in email applications. Users label emails as spam or not and the system
    then tries to find patterns in new incoming emails to detect potential spam emails.
  prefs: []
  type: TYPE_NORMAL
- en: 'The example with `CalculationMachine` is another case for supervised learning.
    We fed it with the following dataset:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We programmed `CalculationMachine` to read the first two numbers as input arguments,
    and the third number as the output produced by a function applied to the input.
    This way, we provided necessary information on what exactly the system should get
    as a result.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unsupervised learning algorithms are even more complex— they process the dataset
    containing a bunch of features and then try to find useful properties of the features.
    Unsupervised learning algorithms are mostly left alone to define what''s in the
    dataset on their own. In terms of intelligence, an unsupervised learning approach
    meets the description of an intelligent creature more than supervised learning
    algorithms. In contrast, supervised learning algorithms are trying to predict
    which input values map to the output values, while unsupervised algorithms perform
    several operations to discover patterns in a dataset. Following the same association
    in the preceding diagram, the following diagram describes an unsupervised learning
    algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3957f1b0-47f6-4f5f-9fd7-d789c436e981.png)'
  prefs: []
  type: TYPE_IMG
- en: Examples of applications of unsupervised learning algorithms are recommendation
    systems. We will be discussing one in the next chapter, where we design a web
    search engine. Recommendation systems analyze user activity to recommend similar
    data, for example, movie recommendations.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from the preceding illustration, there is also *reinforcement
    learning*. This is the category of algorithms that learns from mistakes. There
    is a feedback loop between the learning system and its experiences so that reinforcement
    learning algorithms interact with an environment. It might make a lot of mistakes
    in the beginning and, after processing the feedback, correct itself to improve
    the algorithm. The learning process becomes part of task execution. Imagine that `CalculationMachine` receives
    only input numbers but not the result of the calculation. For each experience,
    it will produce a result by applying one of the arithmetic operations and then
    receive a feedback. Let's say it subtracts the numbers and then modifies itself
    to calculate the sum based on the feedback.
  prefs: []
  type: TYPE_NORMAL
- en: Applications of ML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Understanding the categorization of ML helps apply it better to various kinds
    of tasks. There is a wide range of tasks that can be solved with ML. We have already
    mentioned *classification* as one of the tasks solved with ML algorithms. Basically,
    classification is the process of filtering and ordering the input to specify the
    categories the input belongs to. Solving classification with ML usually means
    that it produces a function that maps input to specific output. Outputting a probability
    distribution over classes is also a type of classification task. One of the best
    examples of a classification task is object recognition. The input is a set of
    pixel values (in other words, an image) and the output is a value identifying
    the object in the image. Imagine a robot that can recognize different kinds of
    tools and deliver them to workers on command.;that is, a mechanic working in garage
    has an assistant robot that is able to recognize a screwdriver and bring it on
    command.
  prefs: []
  type: TYPE_NORMAL
- en: More challenging is classification with missing inputs. In the preceding example,
    it's similar to asking the robot to bring something to screw the bolts. When some
    of the input is missing, the learning algorithm must operate with more than one
    function to achieve a successful result. For example, the assistant robot might
    bring pliers first and then come up with a screwdriver as the correct solution.
  prefs: []
  type: TYPE_NORMAL
- en: Similar to classification is *regression*, where the system is asked to predict
    a numerical value given some input that is provided. The difference is the format
    of the output. An example of a regression task is prediction of future prices
    of stocks. These and other applications of ML are making it rapidly grow as a
    field of study. Learning algorithms are not just a list of conditional statements
    as they might feel at first. They are based on more comprehensive constructs modeled
    after human brain neurons and their connections. This leads us to the next section,
    the study of **artificial neural networks** (**ANNs**).
  prefs: []
  type: TYPE_NORMAL
- en: Neural networks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Neural networks are designed to recognize patterns. They are modeled after
    the human brain; more specifically, we speak about neurons of the brain and their
    artificial counterparts – artificial neurons. A neuron in the human brain is illustrated
    in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2ae9ed94-046b-41d3-b973-d49240e60d96.png)'
  prefs: []
  type: TYPE_IMG
- en: A neuron communicates with other neurons via *synapses*. The basic functionality
    of a neuron is processing a portion of data and producing signals based on that
    data. In programming terms, a neuron takes a set of inputs and produces an output.
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s why the following diagram makes it clear why an artificial neuron is
    similar to the human brain neuron structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c5ab77e8-d399-4ea8-8266-87af81434f8b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'An ANN is a much simplified model of a natural neural network. It represents
    a group of interconnected nodes, each node representing a model after a neuron.
    Each node connection can transmit signals similar to synapses in biological brain
    neurons. Neural networks are a set of algorithms that help to cluster and classify.
    As you can see from the preceding diagram, the neural network consists of three
    layers:'
  prefs: []
  type: TYPE_NORMAL
- en: Input layer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hidden layer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Output layer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The input and output layers speak for themselves; the initial inputs are external
    data, for example, images, audio, or text files. The output is the accomplishment
    of the task, such as classification of the text content or the recognized objects
    in images. The hidden layer is what makes the network produce reasonable results.
    The transition of input to output goes through the hidden layer, which does the
    heavy analyzing, processing, and modifications necessary to produce the output.
  prefs: []
  type: TYPE_NORMAL
- en: Consider the preceding diagram; it shows that a neuron can have multiple input
    and output connections. Usually, each connection has a weight that specifies the
    importance of the connection. The layering in the preceding diagram tells us that
    neurons in each layer are connected to neurons of the immediately preceding and
    immediately following layers. You should note that there might be several hidden
    layers between the input and output layers. While the primary purpose of input
    and output layers is reading external data and returning calculated (or deduced)
    output, the purpose of hidden layers is to adapt by learning. Learning also involves
    adjusting connections and weights aiming to improve the output accuracy. This
    is the part where ML comes to play. So, if we create a complex neural network
    with several hidden layers ready to learn and improve, we get an AI system. For
    example, let's examine the clustering problem and then move on to regression analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Clustering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Clustering is concerned with grouping a set of objects to distribute them in
    groups of similar objects. Also known as **cluster analysis**, it is a set of
    techniques and algorithms intended to group similar objects together, producing
    clusters. The simplest illustrative introduction would be grouping a set of colored
    objects into different groups consisting of objects of the same color, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3ef57b1e-05f2-4d19-a942-b7d6b85c8d95.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Although we are discussing AI tasks in this chapter, we suggest you first try
    to solve problems with the knowledge base that you have so far. That is, let''s
    think about how we would categorize objects by similarity. First of all, we should
    have a basic idea of what the object will look like. In the preceding example,
    an object  `shape`,  `color`, dimensions (`width` and `height` for a 2D object),
    and so on. Without going much deeper, a basic object representation might look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s consider the fact that values for color and shapes are in a some range
    of predefined values. We could use enumerations for better readability. Clustering
    analysis involves analyzing objects to categorize them somehow. The first thing
    that comes to mind is having a function that accepts a list of objects. Let''s
    try to define one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Think for a moment about the implementation details. We need to define the
    clustering points. It might be the color, or the type of the shape. The challenging
    thing is that it might be unknown. That said, to cover everything just in case,
    we categorize objects for every property as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Objects with a similar color or shape are grouped together in a hash table.
    While the preceding code is rather simple, it bears the basic idea for grouping
    objects by some similarity criterion. What we did in the previous example is more
    likely to be described as hard clustering. An object either belongs to a cluster
    or it doesn't. On the contrary, soft clustering (also known as **fuzzy clustering**)
    describes an object's belonging to a cluster to a certain degree.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the similarity of objects for the shape property could be defined
    by the result of a function applied to the objects. That is, the function defines
    whether object A and object B have a similar shape if, let's say, object A's shape
    is a square and object B's shape is a rhombus. That means we should update the
    logic in the previous example to compare objects against several values and define
    their shape as a group. By developing this idea further, we will sooner or later
    arrive at different strategies and algorithms of clustering, such as K-means clustering.
  prefs: []
  type: TYPE_NORMAL
- en: Regression analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Regression analysis is concerned with finding the deviations for one value
    from another. The simplest way of understanding regression analysis is through
    the graphs for functions in mathematics. You might recall the graph for the function
    f(x) = y:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/378390fd-c0b2-4a73-86ea-cc2108a8afa0.png)'
  prefs: []
  type: TYPE_IMG
- en: For every value of `x`, the function results in a fixed value for `y`. Regression
    analysis is somewhat similar to the preceding graph as it is concerned with finding
    a relationship between variables. More specifically, it estimates relationships
    between a dependent variable and several independent variables. The dependent
    variable is also know as an **outcome**, while the independent variables are also referred
    to as **features**. The number of features might be one.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most common form of regression analysis is linear regression. It looks
    similar to the preceding graph. Here''s an example representing the relationship
    between hours spent on testing programs and the number of bugs discovered in the
    release version:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/85954804-fb7b-4621-8295-dd72845621b6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'There are two types of regression: a negative regression is the one shown in
    the preceding diagram, as the independent values decrease while the dependent
    variable increases. Positive regressions, on the contrary other hand, have increasing
    values for independent variables.'
  prefs: []
  type: TYPE_NORMAL
- en: Regression analysis in ML is used as a way of forecasting. You might develop
    a program to predict an outcome based on the values for dependent variables. As
    you have already guessed so far, ML is a big field with a wide range of topics.
    Although programmers tend to use math as little as possible, ML makes it impossible.
    You still need to grasp some of the math subjects to get the most out of ML. Regression
    analysis strongly depends on math statistics.
  prefs: []
  type: TYPE_NORMAL
- en: C++ and ML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's now no longer a secret that ML is more about math than programming. Computer
    science has its roots in mathematics and, in the early years, computer scientists
    were mathematicians first. You might be familiar with several eminent scientists,
    including Alan Turing, John von Neuman, Claude Shannon, Norbert Wiener, Niklaus
    Wirth, Donald Knuth, and many others. All of them are mathematicians with a special
    love for technology. During its development, computer programming became a more
    friendly field to newcomers. In the last two or three decades, a computer programmer
    stopped being forced to learn math before developing useful programs. Languages
    evolved into more and more high-level tools that allow almost everyone to code.
  prefs: []
  type: TYPE_NORMAL
- en: There are plenty of frameworks that make the job easier for programmers. It
    now takes a matter of weeks to grasp some framework or a high-level programming
    language and create a new program. Programs, however, tend to repeat themselves.
    It's not so hard to build something nowadays because there are a lot of patterns
    and best practices that help us along the way. The role of mathematics has been
    pushed back and more and more people become programmers without even the slightest
    need to use math. That's not actually an issue; it's more like a natural flow
    for the technology to evolve. In the end, the aim for technology is to make the
    human living more comfortable. The same relates to engineers. While, back in the
    1960s, engineers at NASA made calculations using computers, they were not computers
    as we know them today. Those were real human beings with this special specialty
    called being a *computer*, although being a computer meant being great in mathematics
    and solving equations much faster than others.
  prefs: []
  type: TYPE_NORMAL
- en: Now we are part of the new age in computer science where mathematics is back
    again. ML engineers are now using mathematics the same way mathematicians used
    programming languages in the 1970s or 1980s. It's now not enough to know a programming
    language or a framework to devise a new algorithm or incorporate ML into your
    applications. You should also be good at least in some sub-fields of mathematics,
    such as linear algebra, statistics, and probability theory.
  prefs: []
  type: TYPE_NORMAL
- en: Almost the same logic applies to C++. Modern languages provide a wide range
    of functionality out of the box, while C++ developers are still striving to design
    flawless programs with manual memory management. If you do some quick research
    into the field of ML, you will find that most of the libraries or examples out
    there are using Python. At first, this might be seen as the default language to
    use in ML tasks. However, ML engineers are starting to touch a new threshold in
    evolution – performance. This threshold is not new; lots of tools out there are
    still using C++ in parts where they need performance. Game development, operating
    systems, mission-critical systems, and many other fundamental areas are using
    C++ (and C) as the *de facto* standard. It's now time for C++ to conquer a new
    area. Our best advice to the reader would be to study both ML and C++ because
    it is slowly becoming critical for ML engineers to incorporate C++ to get the
    best performance out there.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have introduced ML with its categories and applications. It is a rapidly
    growing field of study having numerous applications in building intelligent systems.
    We have categorized ML into supervised, unsupervised, and reinforcement learning
    algorithms. Each of the categories have their applications in solving tasks such
    as classification, clustering, regression, and machine translation.
  prefs: []
  type: TYPE_NORMAL
- en: We have implemented a simple learning algorithm that defines a calculation function
    based on experiences provided as an input. We called it a dataset that we used
    to train the system. Training with datasets (called **experiences**) is one of
    the key properties in ML systems.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we introduced and discussed ANNs applied to recognize patterns. ML
    and neural networks go hand in hand in solving tasks. The chapter provides you
    with the necessary introduction to the field along with several examples of tasks
    so that you can spend some time diving into the topic. This will help you to have
    a general idea of AI and ML as it's becoming increasingly necessary for engineers
    in real-world application development. In the next chapter, we will learn how
    to implement a dialog-based search engine.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is ML?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the differences between supervised and unsupervised learning algorithms?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Give some examples of ML applications.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How would you modify the `CalculationMachine` class to change its behavior after
    training it with a different set of experiences?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the purpose of neural networks?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Artificial Intelligence and Machine Learning Fundamentals*, at [https://www.packtpub.com/big-data-and-business-intelligence/artificial-intelligence-and-machine-learning-fundamentals](https://www.packtpub.com/big-data-and-business-intelligence/artificial-intelligence-and-machine-learning-fundamentals)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Machine Learning Fundamentals*, at [https://www.packtpub.com/big-data-and-business-intelligence/machine-learning-fundamentals](https://www.packtpub.com/big-data-and-business-intelligence/machine-learning-fundamentals)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Hands-On Machine Learning for Algorithmic Trading, *at [https://www.packtpub.com/big-data-and-business-intelligence/hands-machine-learning-algorithmic-trading](https://www.packtpub.com/big-data-and-business-intelligence/hands-machine-learning-algorithmic-trading)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
