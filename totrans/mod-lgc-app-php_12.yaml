- en: Chapter 12. Replace Includes in Classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even though we have Model View Controller separation now, we may still have
    many include calls in our classes. We want our legacy application to be free from
    the artifacts of its include-oriented heritage, where merely including a file
    causes logic to be executed. To do so, we will need to replace include calls with
    method calls throughout our classes.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For the purposes of this chapter, we will use the term include to cover not
    just `include` but also `require`, `include_once`, and `require_once`.
  prefs: []
  type: TYPE_NORMAL
- en: Embedded include Calls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s say we extracted some action logic with an embedded `include` to a *Controller*
    method. The code receives information on a new user, calls an `include` to perform
    some common validation functionality, and then deals with success or failure of
    validation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an example of what the included file might look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Let us ignore for now the specifics of the validation code. The point here is
    that the `include` file and any code using it are both tightly coupled to each
    other. Any code using the file has to initialize a `$user` variable before including
    it. Any code using the file also has an expectation of getting two new variables
    introduced into its scope (`$user_messages` and `$user_is_valid`).
  prefs: []
  type: TYPE_NORMAL
- en: We want to decouple this logic so that the logic in the `include` file does
    not intrude on the scope of the class methods in which is it used. We do this
    by extracting the logic of the `include` file to a class of its own.
  prefs: []
  type: TYPE_NORMAL
- en: The Replacement process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The difficulty of extracting includes to their own classes depends on the number
    and complexity of the `include` calls remaining in our class files. If there are
    very few includes and they are relatively simple, the process will be easy to
    complete. If there are many complex interdependent includes, the process will
    be relatively difficult to work through.
  prefs: []
  type: TYPE_NORMAL
- en: 'In general, the process is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Search the `classes/` directory for an `include` call in a class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For that `include` call, search the entire codebase to find how many times the
    included file is used.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If the included file is used only once, and only in that one class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the contents of the included file code as-is directly over the `include`
    call.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Test the modified class, and delete the include file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Refactor the copied code so that it follows all our existing rules: no globals,
    no `new`, inject dependencies, return instead of output, and no `include` calls.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If the included file is used more than once:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the contents of the included file as-is to a new class method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Replace the discovered `include` call with inline instantiation of the new class
    and invocation of the new method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Test the class in which the `include` was replaced to find coupled variables;
    add these to the new method signature by reference.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Search the entire codebase for `include` calls to that same file, and replace
    each with inline instantiation and invocation; spot check modified files and test
    modified classes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete the original `include` file; unit test and spot check the entire legacy
    application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write a unit test for the new class, and refactor the new class so that it
    follows all our existing rules: no globals, no superglobals, no `new`, inject
    dependencies, return-not-output, and no includes.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, replace each inline instantiation of the new class in each of our class
    files with dependency injection, testing along the way.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Commit, push, notify QA.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat until there are no `include` calls in any of our classes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Search for include Calls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, as we did in a much earlier chapter, we use our project-wide search
    facility to find `include` calls. In this case, search only the `classes/` directory
    with the following regular expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This should give us a list of candidate `include` calls in the `classes/` directory.
  prefs: []
  type: TYPE_NORMAL
- en: We pick a single `include` file to work with, then search the entire codebase
    for other inclusions of the same file. For example, if we found this candidate
    `include` ...
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We would search the entire codebase for `include` calls to the file name `baz.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We search only for the file name because, depending on where the `include` call
    is located, the relative directory paths might lead to the same file. It is up
    to us to determine which of these `include` calls reference the same file.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have a list of `include` calls that we know lead to the same file, we
    count the number of calls that include that file. If there is only one call, our
    work is relatively simple. If there is more than one call, our work is more complex.
  prefs: []
  type: TYPE_NORMAL
- en: Replacing a Single include Call
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If a file is used as the target of an `include` call only once, it is relatively
    easy to remove the `include`.
  prefs: []
  type: TYPE_NORMAL
- en: First, we copy the entire contents of the `include` file. We move back to the
    class where the `include` occurs, delete the `include` call, and paste the entire
    contents of the `include` file in its place.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we run the unit tests for the class to make sure it still works properly.
    If they fail, we rejoice! We have found errors to be corrected before we continue.
    If they pass, we likewise rejoice, and move on.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the `include` call has been replaced, and the file contents have been
    successfully transplanted to the class, we delete the include file. It is no longer
    needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we can return to our class file where the newly transplanted code
    lives. We refactor it according to all the rules we have learned so far: no globals
    or superglobals, no use of the `new` keyword outside of factories, inject all
    needed dependencies, return values instead of generating output, and (recursively)
    no `include` calls. We run our unit tests along the way to make sure we do not
    break any pre-existing functionality.'
  prefs: []
  type: TYPE_NORMAL
- en: Replacing Multiple include Calls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If a file is used as the target of multiple `include` calls, it will take more
    work to replace them.
  prefs: []
  type: TYPE_NORMAL
- en: Copy include file to Class Method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, we will copy the `include` code to a class method of its own. To do this,
    we need to pick a class name appropriate to the purpose of the included file.
    Alternatively, we may name the class based on the path to the included file so
    we can keep track of where the code came from originally.
  prefs: []
  type: TYPE_NORMAL
- en: As for the method name, we again pick something appropriate to the purpose of
    the `include` code. Personally, if the class is going to contain only a single
    method, I like to co-opt the `__invoke()` method for this. However, if there end
    up being multiple methods, we need to pick a sensible name for each one.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have picked a class name and method, we create the new class in the
    proper file location, and copy the `include` code directly into the new method.
    (We do not delete the include file itself just yet.)
  prefs: []
  type: TYPE_NORMAL
- en: Replace the original include Call
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have a class to work with, we go back to the `include` call we discovered
    in our search, replace it with an inline instantiation of the new class, and invoke
    the new method.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, say the original calling code looked like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'If we extracted the `include` code to a `Validator\NewUserValidator` class
    as its `__invoke()` method body, we might replace the `include` call with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using inline instantiation in a class violates one of our rules regarding dependency
    injection. We do not want to use the `new` keyword outside of factory classes.
    We do so here only to facilitate the refactoring process. Later, we will replace
    this inline instantiation with injection.
  prefs: []
  type: TYPE_NORMAL
- en: Discover coupled variables through testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have now successfully decoupled the calling code from the `include` file,
    but this leaves us with a problem. Because the calling code executed the `include`
    code inline, the variables needed by the newly-extracted code are no longer available.
    We need to pass into the new class method all the variables it needs for execution,
    and to make its variables available to the calling code when the method is done.
  prefs: []
  type: TYPE_NORMAL
- en: To do so, we run the unit tests for the class that called the `include`. The
    tests will reveal to us what variables are needed by the new method. We can then
    pass these into the method by reference. Using a reference makes sure that both
    blocks of code are operating on the exact same variables, just as if the `include`
    was still being executed inline. This minimizes the number of changes we need
    to make to the calling code and the newly extracted code.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, say we have extracted the code from an `include` file to this
    class and method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'When we test the class that calls this code in place of an `include`, the tests
    will fail, because the `$user` value is not available to the new method, and the
    `$user_messages` and `$user_is_valid` variables are not available to the calling
    code. We rejoice at the failure, because it tells us what we need to do next!
    We add each missing variable to the method signature by reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We then pass the variables to the method from the calling code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We continue running the unit tests until they all pass, adding variables as
    needed. When all the tests pass, we rejoice! All the needed variables are now
    available in both scopes, and the code itself will remain decoupled and testable.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Not all variables in the extracted code may be needed by the calling code, and
    vice versa. We should let the unit testing failures guide us as to which variables
    need to be passed in as references.
  prefs: []
  type: TYPE_NORMAL
- en: Replace other include Calls and Test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have decoupled our original calling code from the `include` file,
    we need to decouple all other remaining code from the same file. Given our earlier
    search results, we go to each file and replace the relevant `include` call with
    an inline instantiation of the new class. We then add a line that calls the new
    method with the needed variables.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we may be replacing code within classes, or within non-class files
    such as view files. If we replace code in a class, we should run the unit tests
    for that class to make sure the replacement does not break anything. If we replace
    code in a non-class file, we should run the test for that file if it exists (such
    as a view file test), or else spot check the file if no tests exist for it.
  prefs: []
  type: TYPE_NORMAL
- en: Delete the include file and test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once we have replaced all `include` calls to the file, we delete the file. We
    should now run all of our tests and spot checks for the entire legacy application
    to make sure that we did not miss an `include` call to that file. If a test or
    spot check fails, we need to remedy it before continuing.
  prefs: []
  type: TYPE_NORMAL
- en: Write a test and refactor
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that the legacy application works just as it used to before we extracted
    the `include` code to its own class, we write a unit test for the new class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have a passing unit test for the new class, we refactor the code in
    that class according to all the rules we have learned so far: no globals or superglobals,
    no use of the `new` keyword outside of factories, inject all needed dependencies,
    return values instead of generating output, and (recursively) no `include` calls.
    We continue to run our tests along the way to make sure we do not break any pre-existing
    functionality.'
  prefs: []
  type: TYPE_NORMAL
- en: Convert to Dependency Injection and test
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When the unit test for our newly refactored class passes, we proceed to replace
    all our inline instantiations with dependency injection. We do so only in our
    class files; in our view files and other non-class files, the inline instantiation
    is not much of a problem
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we may see this inline instantiation and invocation in a class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We move the `$validator` to a property injected via the constructor, and use
    the property in the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now we need to search the codebase and replace every instantiation of the modified
    class to pass the new dependency object. We run our tests as we go to make sure
    everything continues to operate properly.
  prefs: []
  type: TYPE_NORMAL
- en: Commit, Push, Notify QA
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At this point we have either replaced a single `include` call, or multiple `include`
    calls to the same file. Because we have been testing along the way, we can now
    commit our new code and tests, push it all to common repository, and notify QA
    that we have new work for them to review.
  prefs: []
  type: TYPE_NORMAL
- en: Do ... While
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We begin again by searching for the next `include` call in a class file. When
    all `include` calls have been replaced by class method invocations, we are done.
  prefs: []
  type: TYPE_NORMAL
- en: Common QuestionsCan one class receive logic from many include files?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the examples, we show the `include` code being extracted to a class by itself.
    If we have many related `include` files, it may be reasonable to collect them
    into the same class, each with their own method name. For example, the *NewUserValidator*
    logic might be only one of many user-related validators. We can reasonably imagine
    the class renamed as *UserValidator* with such methods as `validateNewUser()`,
    `validateExistingUser()`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: What about include calls originating in non-class files?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In our search for `include` calls, we look only in the `classes/` directory
    for the originating calls. It is likely that there are `include` calls that originate
    from other locations as well, such as the `views/`.
  prefs: []
  type: TYPE_NORMAL
- en: For the purposes of our refactoring, we don't particularly care about `include`
    calls that originate outside our classes. If an `include` is called only from
    non-class files, we can safely leave that `include` in its existing state.
  prefs: []
  type: TYPE_NORMAL
- en: Our main goal here is to remove `include` calls from class files, not necessarily
    from the entire legacy application. At this point, it is likely that most or all
    `include` calls outside our classes are part of the presentation logic anyway.
  prefs: []
  type: TYPE_NORMAL
- en: Review and next steps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After we have extracted all the include calls from our classes, we will have
    finally removed one of the last major artifacts of our legacy architecture. We
    can load a class without any side effects, and logic is executed only as a result
    of invoking a method. This is a big step forward for us.
  prefs: []
  type: TYPE_NORMAL
- en: We can now begin paying attention to overarching end-to-end architecture of
    our legacy application.
  prefs: []
  type: TYPE_NORMAL
- en: 'As things stand now, the entire legacy application is still located in the
    web server document root. Users browse to each page script directly. This means
    that the URLs are coupled to the file system. In addition, each page script has
    quite a bit of repeated logic: load a setup script, instantiate a controller using
    dependency injection, invoke the controller, and send the response.'
  prefs: []
  type: TYPE_NORMAL
- en: Our next major goal, then, is to begin using a Front Controller in our legacy
    application. The front controller will be composed of some bootstrapping logic,
    a router, and a dispatcher. This will decouple our application from the file system
    and allow us to start removing our page scripts entirely.
  prefs: []
  type: TYPE_NORMAL
- en: But before we do so, we need to separate the public resources in our application
    from the non-public resources.
  prefs: []
  type: TYPE_NORMAL
