- en: Clock and Time Management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Linux time management subsystem manages various time-related activities
    and keeps track of timing data such as current time and date, time elapsed since
    system boot up (system uptime) and timeouts, for example, how long to wait for
    a particular event to be initiated or terminated, locking the system after a timeout
    period has elapsed, or raising a signal to kill an unresponsive process.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two types of timing activities handled by the Linux time management
    subsystem:'
  prefs: []
  type: TYPE_NORMAL
- en: Keeping the current time and date
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maintaining timers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Time representation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Depending on the use cases, time is represented in three different ways in
    Linux:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Wall time (or real time):** This is the actual time and date in the real
    world, such as 07:00 AM, 10 Aug 2017, and is used for timestamps on files and
    packets sent through the network.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Process time:** This is the time consumed by a process in its life span.
    It includes the time consumed by the process in user mode and the time consumed
    by the kernel code when executing on behalf of the process. This is useful for
    statistical purposes, auditing, and profiling.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Monotonic time:** This is the time elapsed since system bootup. It''s ever
    incrementing and monotonic in nature (system uptime).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'These three times are measured in either of the following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Relative time:** This is the time relative to some specific event, such as
    7 minutes since system bootup, or 2 minutes since last input from user.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Absolute time:** This is a unique point in time without any reference to
    a previous event, such as 10:00 AM, 12 Aug 2017\. In Linux, absolute time is represented
    as the number of elapsed seconds since 00:00:00 midnight of 1 January 1970 (UTC)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wall time is ever incrementing (unless it has been modified by the user), even
    between reboots and shutdowns, but process time and system uptime start from some
    predefined point in time (*usually zero*) every time a new process is created
    or when the system starts.
  prefs: []
  type: TYPE_NORMAL
- en: Timing hardware
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Linux relies on appropriate hardware devices to maintain time. These hardware
    devices can be categorized broadly into two types: system clock and timers.'
  prefs: []
  type: TYPE_NORMAL
- en: Real-time clock (RTC)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Keeping track of the current time and date is very crucial, not just to let
    the user know about it but to use it as a timestamp for various resources in the
    system, specifically, files present in secondary storage. Every file has metadata
    information such as the date of creation and last modification date, and every
    time a file is created or modified, these two fields are updated with the current
    time in the system. These fields are used by several apps to manage files such
    as to sort, group, or even delete them (if the file hasn't been accessed a for
    long time). The *make* tool uses this timestamp to determine whether a source
    file has been edited since the last time it accessed it; only then is it compiled,
    otherwise left untouched.
  prefs: []
  type: TYPE_NORMAL
- en: The system clock RTC keeps track of the current time and date; backed by an
    additional battery, it continues to tick even when the system is turned off.
  prefs: []
  type: TYPE_NORMAL
- en: RTC can raise interrupts on IRQ8 periodically. This feature can be used as an
    alarm facility, by programming the RTC to raise interrupt on IRQ8 when it reaches
    a specific time. In IBM-compatible PCs, the RTC is mapped to the 0x70 and 0x71
    I/O ports. It can be accessed through the `/dev/rtc` device file.
  prefs: []
  type: TYPE_NORMAL
- en: Timestamp counter (TSC)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a counter implemented in every x86 microprocessor by means of a 64-bit
    register called TSC the register. It counts the number of clock signals arriving
    on the CLK pin of the processor. The current counter value can be read by accessing
    the TSC register. The number of ticks counted per second can be calculated as
    1/(clock frequency); for a 1 GHz clock it translates to once every nanosecond.
  prefs: []
  type: TYPE_NORMAL
- en: 'Knowing the duration between two consecutive ticks is very crucial. The fact
    that one processor clock''s frequency might not be the same as others makes it
    vary across processors. CPU clock frequency is calculated during system boot by
    the `calibrate_tsc()` callback routine of the x86_platform_ops structure defined
    in the `arch/x86/include/asm/x86_init.h` header file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This data structure manages other timing operations too, such as getting time
    from the RTC through `get_wallclock()` or setting time on the RTC through the
    `set_wallclock()` callback.
  prefs: []
  type: TYPE_NORMAL
- en: Programmable interrupt timer (PIT)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are certain tasks that need to be carried out by the kernel at regular
    intervals, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: Updating the current time and date (at midnight)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating the system running time (uptime)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keeping track of the time consumed by each process so that they don't exceed
    the time allotted to run on the CPU
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keeping track of various timer activities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In order to carry out these tasks, interrupts must be periodically raised. Every
    time this periodic interrupt is raised, the kernel knows it's time to update the
    aforementioned timing data. The PIT is the piece of hardware responsible for issuing
    this periodic interrupt, called timer interrupt. The PIT keeps on issuing timer
    interrupts on IRQ0 periodically at approximately 1000 Hz frequency, once every
    millisecond. This periodic interrupt is called the **tick** and the frequency
    at which it's issued is called the **tick rate**. The tick rate frequency is defined
    by the kernel macro **HZ** and is measured in hertz.
  prefs: []
  type: TYPE_NORMAL
- en: 'System responsiveness depends on the tick rate: the shorter the ticks, the
    more responsive a system would be, and vice versa. With shorter ticks, `poll()`
    and `select()` system calls will have a faster response time. However, the considerable
    drawback of a shorter tick rate is that the CPU will be working in kernel mode
    (executing the interrupt handler for the timer interrupt) most of the time, leaving
    less time for user-mode code (programs) to execute on it. In a high-performance
    CPU, it wouldn''t be much of an overhead, but in slower CPUs, the overall system
    performance would be affected considerably.'
  prefs: []
  type: TYPE_NORMAL
- en: To reach a balance between response time and system performance, a tick rate
    of 100 Hz is used in most machines. Except for *Alpha* and *m68knommu*, which
    use a 1000 Hz tick rate, the rest of the common architectures, including *x86*
    (arm, powerpc, sparc, mips, and so on) use a 100 Hz tick rate. Common PIT hardware
    found in *x86* machines is Intel 8253\. It's I/O mapped and accessed through addresses
    0x40 â€“ 0x43\. The PIT is initialized by `setup_pit_timer()`, defined in the `arch/x86/kernel/i8253.c`
    file*:*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This calls `clockevent_i8253_init()` internally, defined in `<drivers/clocksource/i8253.c>`*:*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: CPU local timer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PIT is a global timer, and interrupts raised by it that can be handled by any
    CPU in an SMP system. In some cases, having such a common timer is beneficial,
    whereas in other cases, a per-CPU timer is more desirable. In an SMP system, keeping
    process time and monitoring allotted time slices to a process in each CPU would
    be much easier and efficient with a local timer.
  prefs: []
  type: TYPE_NORMAL
- en: Local APIC in recent x86 microprocessors embeds such a CPU local timer. A CPU
    local timer can issue interrupts either once or periodically. It uses a 32-bit
    timer and can issue interrupts at a very low frequency (this wider counter allows
    more ticks to occur before an interrupt is raised). The APIC timer works with
    the bus clock signal. The APIC timer is quite similar to PIT except that it's
    local to the CPU, has a 32-bit counter (PIT has a 16-bit one), and works with
    the bus clock signal (PIT uses its own clock signal).
  prefs: []
  type: TYPE_NORMAL
- en: High-precision event timer (HPET)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The HPET works with clock signals in excess of 10 Mhz, issuing interrupts once
    every 100 nano seconds, hence the name high-precision. HPET implements a 64-bit
    main counter to count at such a high frequency. It was co-developed by Intel and
    Microsoft for the need of a new high-resolution timer. HPET embeds a collection
    of timers. Each of them is capable of issuing interrupts independently, and can
    be used by specific applications as assigned by the kernel. These timers are managed
    as groups of timers, where each group can have a maximum of 32 timers in it. An
    HPET can implement maximum of 8 such groups. Each timer has a set of *comparator*
    and *match register***.** A timer issues an interrupt when the value in its match
    register matches the value of the main counter. Timers can be programmed to generate
    interrupts either once or periodically.
  prefs: []
  type: TYPE_NORMAL
- en: Registers are memory mapped and have relocatable address space. During system
    bootup, the BIOS sets up the registers' address space and passes it to the kernel.
    Once the BIOS maps the address, it's seldom remapped by the kernel.
  prefs: []
  type: TYPE_NORMAL
- en: ACPI power management timer (ACPI PMT)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The ACPI PMT is a simple counter that has a fixed frequency clock at 3.58 Mhz.
    It increments on each tick. The PMT is port mapped; the BIOS takes care of address
    mapping in the hardware initialization phase during bootup. The PMT is more reliable
    than the TSC, as it works with a constant clock frequency. The TSC depends on
    the CPU clock, which can be underclocked or overclocked as per the current load,
    resulting in time dilation and inaccurate measurements. Among all, the HPET is
    preferable since it allows very short time intervals if present in the system.
  prefs: []
  type: TYPE_NORMAL
- en: Hardware abstraction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Every system has at least one clock counter. As with any hardware device in
    a machine, this counter too is represented and managed by a structure. Hardware
    abstraction is provided by `struct clocksource`**,** defined in the `include/linux/clocksource.h`
    header file. This structure provides callbacks to access and handle power management
    on the counter through the `read`, `enable`, `disable`, `suspend`, and `resume`
    routines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Members `mult` and `shift` are useful in obtaining elapsed time in relevant
    units.
  prefs: []
  type: TYPE_NORMAL
- en: Calculating elapsed time
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Until this point we know that in every system there is a free-running, ever-incrementing
    counter, and all time is derived from it, be it wall time or any duration. The
    most natural idea here to calculate the time (seconds elapsed since the start
    of counter) would be dividing the number of cycles provided by this counter with
    the clock frequency, as expressed in the following formula:'
  prefs: []
  type: TYPE_NORMAL
- en: Time (seconds) = (counter value)/(clock frequency)
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a catch with this approach, however: it involves division (which works
    on an iterative algorithm, making it the slowest among the four basic arithmetic
    operations) and floating point calculations, which might be slower on certain
    architectures. While working with embedded platforms, floating point calculations
    are evidently slower than they are on PC or server platforms.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So how do we overcome this issue? Instead of division, time is calculated using
    multiplication and bitwise shift operations. The kernel provides a helper routine
    that derives the time this way. `clocksource_cyc2ns()`, defined in `include/linux/clocksource.h`,
    converts the clocksource cycles to nanoseconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here, the parameter cycles is the number of elapsed cycles from the clock source,
    `mult` is the cycle-to-nanosecond multiplier, while `shift` is the cycle-to-nanosecond
    divisor (power of two). Both these parameters are clock source dependent. These
    values are provided by the clock source kernel abstraction discussed earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Clock source hardware are not accurate all the time; their frequency might vary.
    This clock variation causes time drift (making the clock run faster or slower).
    In such cases, the variable *mult* can be adjusted to make up for this time drift.
  prefs: []
  type: TYPE_NORMAL
- en: 'The helper routine `clocks_calc_mult_shift()`**,** defined in `kernel/time/clocksource.c`,
    helps evaluate `mult` and `shift` factors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Time duration between two events can be calculated as shown in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Linux timekeeping data structures, macros, and helper routines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will now broaden our awareness by looking at some key timekeeping structures,
    macros, and helper routines that can assist programmers in extracting specific
    time-related data.
  prefs: []
  type: TYPE_NORMAL
- en: Jiffies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*The* `jiffies` variable holds the number of ticks elapsed since system bootup.
    Every time a tick occurs, *jiffies* is incremented by one. It''s a 32-bit variable,
    meaning for a tick rate of 100 Hz, overflow will occur in approximately 497 days
    (and in 49 days, 17 hours for a 1000 Hz tick rate).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To overcome this issue, a 64-bit variable `jiffies_64` is used instead, which
    allows for thousands of millions of years before the overflow occurs. The `jiffies`
    variable is equated to the 32 least significant bits of `jiffies_64`. The reason
    for having both `jiffies` and `jiffies_64` variables is that in 32-bit machines,
    a 64-bit variable can not be accessed atomically; some synchronization is required
    in order to avoid any counter update while these two 32-bit halves are processed.
    The function `get_jiffies_64()` defined in the `/kernel/time/jiffies.c` source
    file returns the current value of `jiffies`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'While working with `jiffies`, it''s crucial to take into account the possibility
    of wraparound, because it leads to unpredictable results while comparing two time
    events. There are four macros that serve this purpose, defined in `include/linux/jiffies.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: All these macros return Boolean values; parameters **a** and **b** are time
    events to be compared. If a happens to be the time after b, `time_after()` returns
    true, otherwise false. Conversely, if **a** happens to be before **b**, `time_before()`
    returns true, else false. Both `time_after_eq()` and `time_before_eq()` return
    true if both a and b are equal. Jiffies can be converted to other time units such
    as milliseconds, microseconds, and nanoseconds using routines `jiffies_to_msecs()`,
    `jiffies_to_usecs()`, defined in `kernel/time/time.c`, and `jiffies_to_nsecs()`,
    in `include/linux/jiffies.h`*:*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Other conversion routines can be explored in the `include/linux/jiffies.h` file.
  prefs: []
  type: TYPE_NORMAL
- en: Timeval and timespec
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Linux, the current time is maintained by keeping the number of seconds elapsed
    since midnight of January 01, 1970 (called epoch); the second elements in each
    of these represent the time elapsed since the last second in microseconds and
    nanoseconds, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Time (counter value) read from the clock source needs to be accumulated and
    tracked somewhere; the structure `struct tk_read_base`, defined in `include/linux/timekeeper_internal.h,`
    serves this purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The structure `struct timekeeper`**,** defined in `include/linux/timekeeper_internal.h,`
    keeps various timekeeping values. It''s the primary data structure to maintain
    and manipulate the timekeeping data for different timelines, such as monotonic
    and raw:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Tracking and maintaining time
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Timekeeping helper routines `timekeeping_get_ns()` and `timekeeping_get_ns()`
    help get the correction factor (delta t) between universal time and terrestrial
    time in nanoseconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The routine `logarithmic_accumulation()` updates mono, raw, and xtime timelines;
    it accumulates shifted intervals of cycles into a shifted interval of nanoseconds.
    The routine `accumulate_nsecs_to_secs()` accumulates the nanoseconds in the `xtime_nsec`
    field of `struct tk_read_base` into `xtime_sec` of `struct timekeeper`. These
    routines help keep track of the current time in the system, and are defined in
    `kernel/time/timekeeping.c`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Another routine `update_wall_time()`, defined in `kernel/time/timekeeping.c,`
    is responsible for maintaining the wall time. It increments the wall time using
    the current clock source as reference.
  prefs: []
  type: TYPE_NORMAL
- en: Tick and interrupt handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To provide the programming interface, the clock device generating the ticks
    is abstracted through the structure `struct clock_event_device`, defined in `include/linux/clockchips.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `event_handler` is the appropriate routine, assigned by the framework
    to be called by the low-level handler to run the tick. Depending on the configuration,
    this `clock_event_device` could be `periodic`*,* `one-shot,` or `ktime` based*.*
    Out of these three, the appropriate operating mode for the tick device is set
    through the `unsigned int features` field, using any of these macros:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Periodic mode configures the hardware generate the tick once every *1/HZ* seconds,
    while one-shot mode makes the hardware generate the tick after the passage of
    a specific number of cycles from the current time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Depending on the use cases and the operating mode, event_handler could be any
    of these three routines:'
  prefs: []
  type: TYPE_NORMAL
- en: '`tick_handle_periodic()`*,* which is the default handler for periodic ticks
    and is defined in `kernel/time/tick-common.c`*.*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tick_nohz_handler()` is the low-resolution interrupt handler, used in low
    res mode. It''s defined in `kernel/time/tick-sched.c`*.*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hrtimer_interrupt()` is used in high res mode and is defined in `kernel/time/hrtimer.c`.
    Interrupts are disabled when it''s called.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A clock event device is configured and registered through the routine `clockevents_config_and_register()`,
    defined in `kernel/time/clockevents.c.`
  prefs: []
  type: TYPE_NORMAL
- en: Tick devices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `clock_event_device` abstraction is for the core timing framework; we need
    a separate abstraction for tick devices per CPU; this is achieved through the
    structure `struct tick_device` and macro `DEFINE_PER_CPU()`*,* defined in `kernel/time/tick-sched.h`
    and `include/linux/percpu-defs.h`, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: A `tick_device` could be either periodic or one shot. It's set through the `enum
    tick_device_mode`*.*
  prefs: []
  type: TYPE_NORMAL
- en: Software timers and delay functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A software timer allows a function to be invoked on expiry of a time duration.
    There are two types of timers: dynamic timers used by the kernel and interval
    timers used by the user-space processes. Apart from software timers, there is
    another type of commonly used timing function called delay functions. Delay functions
    implement a precise loop, which is executed as per (usually as many times as the)
    delay function''s argument.'
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic timers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Dynamic timers can be created and destroyed at any time, hence the name dynamic
    timers. Dynamic timers are represented by the `struct timer_list` object, defined
    in `include/linux/timer.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: All timers in a system are managed by a doubly linked list, and are sorted in
    order of their expiry time, represented by the expires field. The expires field
    specifies the time duration, after which the timer expires. As soon as the current
    `jiffies` value matches or exceeds this field's value, the timer decays. Through
    the entry field, a timer is added into this timer linked list. The function field
    points to the routine to be invoked on expiry of the timer and the data field
    holds the parameter to be passed to the function, if needed. The expires field
    is constantly compared with `jiffies_64` values to determine whether the timer
    has expired or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'A dynamic timer can be created and activated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new `timer_list` object, let's say `t_obj`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initialize this timer object using macro `init_timer(&t_obj)`, defined in `include/linux/timer.h.`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initialize the function field with the function's address to be invoked on expiry
    of the timer. If the function requires a parameter, initialize the data field
    too.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the timer object is already added to a timer list, update the expires field
    by calling the function `mod_timer(&t_obj, <timeout-value-in-jiffies>)`*,* defined
    in `kernel/time/timer.c`*.*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If not, initialize the expires field and add the timer object into the timer
    list using `add_timer(&t_obj)`*,* defined in `/kernel/time/timer.c`*.*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The kernel removes a decayed timer from its timer list automatically, but there
    are other methods too to remove a timer from its list. The `del_timer()` and `del_timer_sync()`
    routines and the macro `del_singleshot_timer_sync()` defined in `kernel/time/timer.c`
    help in doing so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '`del_timer()` removes both active and inactive timers. Particularly useful
    in SMP systems, `del_timer_sync()` deactivates the timer and waits until the handler
    has finished executing on other CPUs.'
  prefs: []
  type: TYPE_NORMAL
- en: Race conditions with dynamic timers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This approach, however, is applicable to uni-processor systems only. In an
    SMP system, it''s quite possible that when the timer is stopped, its function
    might already be running on another CPU. In such a scenario, resources will be
    released as soon as the `del_timer()` returns, while the timer function is still
    manipulating them on other CPU; not a desirable situation at all. `del_timer_sync()`
    fixes this problem: after stopping the timer, it waits until the timer function
    completes its execution on the other CPU. `del_timer_sync()` is useful in cases
    where the timer function can reactivate itself. If the timer function doesn''t
    reactivate the timer, a much simpler and faster macro, `del_singleshot_timer_sync()`,
    should be used instead.'
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic timer handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Software timers are complex and time consuming, and therefore should not be
    handled by the timer ISR. Rather they should be performed by a deferrable bottom-half
    softirq routine called `TIMER_SOFTIRQ` *,* and its routine is defined in `kernel/time/timer.c`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Delay functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Timers are useful when the timeout period is relatively long; in all other use
    cases where a shorter duration is desired, delay functions are used instead. While
    working with hardware such as storage devices (namely *flash memory* and *EEPROM*),
    it's is very crucial for the device driver to wait until the device finishes the
    hardware operations such as writing and erasing, which in most cases is in the
    range of a few microseconds to milliseconds. Going ahead and executing other instructions
    without waiting for the hardware to complete such operations would result in unpredictable
    read/write operations and data corruption. In cases such as these, delay functions
    come in handy. The kernel provides such short delays by means of the `ndelay()`*,*
    `udelay()`, and `mdelay()` routines and macro, which receive arguments in nanoseconds,
    microseconds, and milliseconds, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following functions can be found in `include/linux/delay.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'These functions can be found in `arch/ia64/kernel/time.c`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: POSIX clocks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'POSIX provides software timers to multithreaded and real-time user space applications,
    known as POSIX timers. POSIX provides the following clocks:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CLOCK_REALTIME`: This clock represents the real time in the system. Also known
    as the wall time, it''s similar to the time from a wall clock and used for timestamping
    as well as providing actual time to the user. This clock is modifiable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CLOCK_MONOTONIC`: This clock keeps the time elapsed since the system bootup.
    It''s ever increasing and non modifiable by any process or user. Due to its monotonic
    nature, it''s the the preferred clock to determine the time difference between
    two time events.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CLOCK_BOOTTIME`: This clock is identical to CLOCK_MONOTONIC; however, it includes
    time spent in suspend.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These clocks can be accessed and modified (if the selected clock allows it)
    through the following POSIX clock routines, defined in the `time.h` header:'
  prefs: []
  type: TYPE_NORMAL
- en: '`int clock_getres(clockid_t clk_id, struct timespec *res);`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int clock_gettime(clockid_t clk_id, struct timespec *tp);`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int clock_settime(clockid_t clk_id, const struct timespec *tp);`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The function `clock_getres()` gets the resolution (precision) of the clock
    specified by *clk_id*. And if the resolution is non-null, it stores it in the
    `struct timespec` pointed to by the resolution. Functions `clock_gettime()` and
    `clock_settime()` read and set the time of the clock specified by *clk_id*. *clk_id*
    could be any of the POSIX clocks: `CLOCK_REALTIME`, `CLOCK_MONOTONIC`, and so
    on.'
  prefs: []
  type: TYPE_NORMAL
- en: '`CLOCK_REALTIME_COARSE`'
  prefs: []
  type: TYPE_NORMAL
- en: '`CLOCK_MONOTONIC_COARSE`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Each of these POSIX routines has corresponding system calls, namely `sys_clock_getres(),
    sys_ clock_gettime()`, and `sys_clock_settime`*.* So every time any of these routines
    is invoked, a context switching occurs from user mode to kernel mode. If calls
    to these routines are frequent, context switching can result in low system performance.
    To avoid context switching, two coarse variants of the POSIX clock were implemented
    as the vDSO (virtual Dynamic Shared Object) library:'
  prefs: []
  type: TYPE_NORMAL
- en: vDSO is a small shared library with selected kernel space routines that the
    kernel maps into the address space of user-space applications so that these kernel-space
    routines can be called by them in process from user space directly. The C library
    calls the vDSOs, so the user space applications can be programmed in the usual
    way through standard functions and the C library will utilize the functionalities
    available through vDSO without engaging any syscall interface, thus avoiding any
    user mode-kernel mode context switching and syscall overhead. Being an vDSO implementation,
    these coarse variants are faster and have a resolution of 1 milliseconds.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked in detail at most of the routines that the kernel
    provides to drive time-based events, in addition to comprehending the fundamental
    aspects of Linux time, its infrastructure, and its measurement. We also briefly
    looked at POSIX clocks and some of their key time access and modification routines.
    Effective time-driven programs however rest on careful and calculated use of these
    routines.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will briefly look at the management of dynamic kernel
    modules.
  prefs: []
  type: TYPE_NORMAL
