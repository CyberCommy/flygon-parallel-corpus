- en: Adding Functionality with Decoration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll continue to address this remark: *If you like design
    patterns, use Java, not Go*. We''ll do so with the help of the decorator and strategy
    patterns.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our goal in this chapter is to understand:'
  prefs: []
  type: TYPE_NORMAL
- en: Go's Reader and Writer interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why designing using the interface composition is better than type hierarchy
    design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to design with and implement the Decorator Pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inversion of Control (IoC) by implementing an IoC framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to set up a request timeout using a proxy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to apply the Strategy Pattern when load balancing requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to understand easy-metrics graphs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to implement a simple yet effective logger using standard library interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to enrich HTTP requests with logging using dependency injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use channels to control the flow of events in a concurrent program
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A better way to extend our application's functionality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interface composition
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Much like a writer composes a book from a set of chapters or a chapter from
    a set of sections, as Go programmers, we can compose our software applications
    using functional composition.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b40bf8c2-82ef-433b-aedf-b3a69ddee63d.png)'
  prefs: []
  type: TYPE_IMG
- en: We can take the functional composition approach to design a software solution
    that enables us to design complex APIs from a set of smaller ones.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in the Viva La Duck example from the previous chapter, we composed
    the `SurvivalBehaviors` interface from two smaller ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Nothing is difficult. Complex things are simply built upon smaller, simpler
    things! When we approach all our software design problems from this perspective,
    we are able to more easily model the real world--our applications become much
    easier to read and reason about.
  prefs: []
  type: TYPE_NORMAL
- en: Go's complimentary Reader and Writer interfaces
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To help us appreciate how Go encourages composition, let''s look at Go''s complimentary
    `Reader` and `Writer` interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: What can we observe from these interface declarations? Simplicity.
  prefs: []
  type: TYPE_NORMAL
- en: They both have a single method that takes a single parameter and returns a single
    result (along with the requisite error value).
  prefs: []
  type: TYPE_NORMAL
- en: What does that buy us? For starters, we can compose broad interfaces by simply
    adding simpler interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Example usages of the Reader and Writer interfaces
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `Hash` interface from Go''s standard library is composed of the `io.Writer`
    interface and four others. Therefore, `Hash` can be used anywhere the `io.Writer`
    interface is required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Design with Duck Typing
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: As mentioned in the previous chapter, this is known as Duck Typing. It's a powerful
    design pattern. A thing is defined not by its type hierarchy but by its behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example of a `File` interface from the `github.com/couchbase/moss`
    package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s another example of it from Go''s `mime/multipart` project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: When composing with interfaces, keep things as simple as possible. Similarly,
    function signatures should be designed to only accept the smallest possible interface
    required to get the job done.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note the application of the single responsibility principle and open/close
    principle in action: our software should be open for extension but closed for
    modifications.'
  prefs: []
  type: TYPE_NORMAL
- en: More reasons to design using interfaces
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As if that's not enough reason to design using interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also get access to a plethora of functionality. For example, when working
    with readers and writers, we get the following for free:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Free functionality** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `io.Copy` |'
  prefs: []
  type: TYPE_TB
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `io.LimitReader` |'
  prefs: []
  type: TYPE_TB
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `io.MultiReader` |'
  prefs: []
  type: TYPE_TB
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `io.RuneReader` |'
  prefs: []
  type: TYPE_TB
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `io.ReadSeeker` |'
  prefs: []
  type: TYPE_TB
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `io.MultiWriter` |'
  prefs: []
  type: TYPE_TB
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `bufio.ScanBytes` | `ScanBytes` is a split function for a Scanner that returns
    each byte as a token. |'
  prefs: []
  type: TYPE_TB
- en: '| `bufio.ScanLines` | `ScanLines` is a split function for a Scanner that returns
    each line of text, stripped of any trailing end-of-line marker. The returned line
    may be empty. The end-of-line marker is one optional carriage return, followed by
    one mandatory newline. In regular expression notation, it is `\r?\n`. The last
    non-empty line of input will be returned even if it has no newline. |'
  prefs: []
  type: TYPE_TB
- en: '| `bufio.ScanRunes` | `ScanRunes` is a split function for a Scanner that returns
    each UTF-8-encoded rune as a token. The sequence of runes returned is equivalent
    to that of a range loop over the input as a string, which means that erroneous
    UTF-8 encodings translate to `U+FFFD = "\xef\xbf\xbd"`. Because of the `Scan`
    interface, this makes it impossible for the client to distinguish correctly encoded
    replacement runes from encoding errors. |'
  prefs: []
  type: TYPE_TB
- en: '| `ioutil.ReadDir` | `ReadDir` reads the directory named by `dirname` and returns a
    list of directory entries sorted by filename. |'
  prefs: []
  type: TYPE_TB
- en: '| `ioutil.ReadFile` | The`addKeyFromFileToConfigMap` adds a key with the given
    name to a `ConfigMap`, populating the value with the content of the given file
    path; alternatively, it returns an error. |'
  prefs: []
  type: TYPE_TB
- en: That's a lot of out-of-the-box functionality that we didn't have to test and
    code. Reusing Go standard library interfaces and functions is nearly always a
    win!
  prefs: []
  type: TYPE_NORMAL
- en: Using the Reader and Writer interfaces
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s exercise what we''ve learned about the `io.Reader` and `io.Writer` interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Recall that the `Reader` interface looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'When we implement the `Read` method, our `titlizeReader` struct now satisfies
    the `Reader` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Our `titlizeReader` type will capitalize the first word in the sentence and
    change all the subsequent letters to lowercase. As we iterate through each byte,
    we check its ASCII value. The ASCII value of `A` is `97`. The decimal value of `a` is
    `65`. So, 97 minus 65 equals 32\.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here we use the string''s `NewReader` method to create an `io.Reader` interface
    from the string, which is `"this IS a tEsT"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We individually assigned the reader value on each line. We could have performed
    this in one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We use three Readers: one from the strings package, another free one used to
    truncate our string to 12 characters, and the one we wrote ourselves.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Given that we have separated our logic into individual function calls, Go''s
    concurrency constructs enable us to process them independently to improve performance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We use the `os.Stdout` writer to output our results to standard output (our
    terminal console).
  prefs: []
  type: TYPE_NORMAL
- en: Since we are using the Reader and Writer interfaces, we get to use the `io.Copy` interface
    for free.
  prefs: []
  type: TYPE_NORMAL
- en: With `Readers` and `Writers` interfaces, we are able to process streams piece
    by piece. Granted, our example only used a 14-character string, but we could have
    handled more data than could fit in RAM at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: '**Gang of Four** (**GOF**) refers to four authors who wrote the *Design Patterns:
    Elements of Reusable Object-Oriented Software* ([https://en.wikipedia.org/wiki/Design_Patterns](https://en.wikipedia.org/wiki/Design_Patterns))
    book. Though the examples in the book are in SmallTalk and C++, the book is frequently referenced
    by many resourceful developers as they build object-oriented software. Languages
    such as Java, which supports inheritance, can greatly benefit from all the patterns in
    the GOF book. Not all patterns are equally important for Go. Though, as we saw
    in the previous chapter, we can definitely benefit from the structural Decorator
    pattern and the behavioral Strategy pattern.'
  prefs: []
  type: TYPE_NORMAL
- en: Decorator pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Though it is easier to write quality Go code--than quality Java code--without
    an understanding of the GOF design patterns, it doesn't mean that we, as Go developers,
    cannot benefit from GOF's insight.
  prefs: []
  type: TYPE_NORMAL
- en: We'll soon see how we can put the Decorator pattern to good use in Go.
  prefs: []
  type: TYPE_NORMAL
- en: Type hierarchy UML
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is the type hierarchy UML that we might have created while designing the
    Decorator pattern back in the day that we used object-oriented languages:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/43befe07-31c7-4d0e-aa19-3204ab6f8e03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This is the design work needed to represent the same Decorator pattern using
    Go:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4e1cc3d4-ee2b-4571-8661-7dd8255c3d7a.png)'
  prefs: []
  type: TYPE_IMG
- en: '"Less is exponentially more"'
  prefs: []
  type: TYPE_NORMAL
- en: '- Rob Pike'
  prefs: []
  type: TYPE_NORMAL
- en: How Procedural design compares to functional Inversion of Control (IoC)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The client request is wrapped by the `Authorization`, `LoadBalancing`, `Logging`,
    and `FaultTolerance` decorators. When a client request is executed, the functionality
    in those decorators will be injected into the flow by our Decorator framework,
    as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fa33d7d5-376b-43dd-ada6-49a48f85f800.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In procedural programming, the `main()` function would be in control of the
    flow of logic. The code would be monolithic and tightly coupled. For example,
    to implement `Authorization`, the programmer would insert the following line somewhere
    before the request is performed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The logic of `FaultTolerance` and `LoadBalancing` would likely look like spaghetti
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'By programming the Decorator functions, we adhere to the client interface as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Each decorator will be a separate function-specific component.
  prefs: []
  type: TYPE_NORMAL
- en: Procedural design example
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Procedural programming is like interacting with a Bash script in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In procedural design, user interaction is predefined and sequential in nature.
  prefs: []
  type: TYPE_NORMAL
- en: Functional IoC example
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Contrast the text-based Bash script example to a web application where the
    user is in control:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f265452e-0db3-431c-8c40-79f2f1e195f7.png)'
  prefs: []
  type: TYPE_IMG
- en: In a GUI application, control is inverted. Instead of the program forcing the
    next user interaction, the user is mostly in control of what happens next. The
    IoC container is a web application framework that runs an event loop and handles
    the callback when the user clicks on controls, such as an item in the drop-down
    list or a submit button.
  prefs: []
  type: TYPE_NORMAL
- en: For some J2EE applications, IoC can also come in the form of XML configuration
    files that are injected into a Spring framework.
  prefs: []
  type: TYPE_NORMAL
- en: In a product shopping example, dependencies would be things such as Select Product
    or Enter Shipping Address. In our decorator implementation, dependencies include `Authorization`,
    `LoadBalancing`, etc., each of which decorate the request.  Our IoC container
    is the decorator framework where functions like `Authorization` and `LoadBalancing` implement
    the Client interface.
  prefs: []
  type: TYPE_NORMAL
- en: A decorator implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our decorator pattern example will be runnable, so we'll put it in the `main`
    package and define a `main()` function.
  prefs: []
  type: TYPE_NORMAL
- en: We use the easy-metrics package for recording and displaying our metrics. It
    comes out of the box with a nice GUI for displaying statistics.
  prefs: []
  type: TYPE_NORMAL
- en: We also import the decorator package and preface that import with a dot (.)
    in order to access the identifiers in the decorator package, in the local file
    block without a qualifier.
  prefs: []
  type: TYPE_NORMAL
- en: The main.go file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s have a look at the contents of `main.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This is what the imports looked like before using the init script and its aliases
    (and glide):'
  prefs: []
  type: TYPE_NORMAL
- en: '`import (`'
  prefs: []
  type: TYPE_NORMAL
- en: '`. . .`'
  prefs: []
  type: TYPE_NORMAL
- en: '`    "time"`'
  prefs: []
  type: TYPE_NORMAL
- en: '`    "github.com/l3x/fp-in-go/chapter5/02_decorator/easy_metrics"`'
  prefs: []
  type: TYPE_NORMAL
- en: '`    . "github.com/l3x/fp-in-go/chapter5/02_decorator"`'
  prefs: []
  type: TYPE_NORMAL
- en: '`)`'
  prefs: []
  type: TYPE_NORMAL
- en: I never liked long repository paths in my imports. I suppose it's time to give
    this technique a name. Let's call it **Keep It Simple Stupid-Glide** (**KISS-Glide**).
  prefs: []
  type: TYPE_NORMAL
- en: We define a host as a constant because we will always run this example code
    on our local workstation. We'll keep things simple and use the HTTP protocol (no
    SSL).
  prefs: []
  type: TYPE_NORMAL
- en: 'Our example uses a proxy server and also uses Go''s standard library HTTP server
    implementation to listen to handle requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1510e263-6b38-43eb-aab8-4c0b08598798.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Any function named `init()` will be executed before the `main()` function.
    We define default port numbers for our two servers and permit the user to specify
    different ports at runtime using the `flag` package, which implements command-line
    flag parsing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll implement a simple logger that will:'
  prefs: []
  type: TYPE_NORMAL
- en: Provide log file tracing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide `Debug`, `Info`, and `Error` log levels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Permit us to specify which log level(s) we want
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enable us to more easily swap out our underlying logging framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The decorator/simple_log.go file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Our logger leverages Go''s `Logger` package, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'A simple logger exports one function, namely `InitLog`, which the calling package
    uses to enable the logging features:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Example InitLog calls
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Here we pass the name of our trace file, called `trace-log.txt`, which will
    receive all of the logging output. We don''t want `Debug` information, but we
    do want Info and Error output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This time we pass nil for the name of our trace log file, which tells our logger
    not to create a trace log file. We do want `Debug`, `Info`, and `Error` data displayed
    to standard out in our terminal console.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'When we specify `traceFileName`, we''ll need to create an `io.MultiWriter`
    interface to send the output to two places at the same time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We'll preface each log line with `DEBUG`, `INFO`, or `ERROR` to indicate its
    log level.
  prefs: []
  type: TYPE_NORMAL
- en: Back to our main package
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The first line of our `main` block calls our `InitLog` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We use the `INFO` level to indicate which our server is listening.
  prefs: []
  type: TYPE_NORMAL
- en: 'We launch our server using a Goroutine, and since this is the `main()` function,
    we use the `log.Fatal` method, which is equivalent to `println` with a panic.
    This is because if we fail to start our server at this point, there are no buffers
    to flush, no outstanding defer statements, and no temporary files to process.
    We also wait for a second in order to give our server time to start:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we declare our request using `req`, which we''ll later execute `NumRequests`
    times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'In our example, we use a proxy server to pass all our requests through. This
    gives us the flexibility to handle proxy-level processing on a per-call basis.
    Our simple example does no such processing, but we do specify a proxy timeout
    of 1 second:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Our client uses the decorator pattern to wrap our `proxyTimeoutClient` client
    with the `Authorization`, `LoadBalancing`, `Logging`, and `FaultTolerance` functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We do not modify our client implementation, rather extend its functionality
    (remember the open/close principle?):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This is a declarative form of programming. There is no code ceremony. We chain
    our function calls, passing only the minimally required information to configure
    its behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get the load balancing working locally, you can add the following line to
    your `/etc/hosts` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we define our job. We pass our client, request, the number of requests
    to process, and the time to wait before processing each request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In order to better comprehend the statistics, later in the easy-metrics web
    app, we'll set the `IntervalSecs` value to 10\. There will 10 seconds between
    each of our 10 request-processing attempts.
  prefs: []
  type: TYPE_NORMAL
- en: 'We set our start time and kick off our job processing with `job.Run()`. The
    `Run` function uses the `sync` package to wait until all the running jobs have
    completed before returning the control, at which time we print out how long the
    request-processing bit took:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Once our processing is complete, we call `DisplayResults` from the `easy_metrics`
    package, which displays a message like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Our server needs to keep running so that we can visit the easy-metrics URL to
    view our statistics with the user-friendly easy-metrics web app.
  prefs: []
  type: TYPE_NORMAL
- en: 'We create a channel to capture the *Ctrl* + *C* key sequence, which will signal
    our program to stop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Understanding our statistics using the easy-metrics GUI
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The next few screenshots will display our terminal console and our web browser
    at `http://127.0.0.1:3000/easy-metrics?show=Stats` immediately after executing
    Go''s `main.go` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/82ea0d7d-2b0b-428a-adda-c83953238d38.png)'
  prefs: []
  type: TYPE_IMG
- en: In the following sections, we'll split this image into three parts.
  prefs: []
  type: TYPE_NORMAL
- en: Quick look at the Dot Init update
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'This is what our terminal looks like using the KISS-Glide toolset:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f545f78a-c8e3-4a99-aeb1-03d9ba7f9f12.png)'
  prefs: []
  type: TYPE_IMG
- en: KISS-Glide makes it simpler and requires less typing to achieve the same result.
    That's a win-win situation.
  prefs: []
  type: TYPE_NORMAL
- en: When I originally wrote this chapter, I used the standard `go get`, `go build`, and `go
    run main.go` commands. As the projects became more complicated (requiring more
    third-party dependencies), I found it helpful to create the KISS-Glide tool. Later,
    I returned to all the projects and simplified them using the KISS-Glide tool.
    Feel free to use any dependency management tool and build and run your Go applications
    as you prefer. That's one of the great things about Go. As long as tool makers
    adhere to standard Go conventions, such as using the `GOPATH`, and not break other
    Go tools, such as `go test`, `go doc`, and `go vet`, it's all good. I prefer simple,
    yet powerful (KISS-Glide).
  prefs: []
  type: TYPE_NORMAL
- en: Easy-metrics - 1 of 3
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'This first screenshot is more about what we see in our terminal console than
    the easy-metrics GUI:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dc50e34b-e581-4b4b-aea3-76c947724d25.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The first two lines of output come from our `main.go` file. The next three
    lines come from this decorator: `Logging(log.New(InfoHandler, "client: ", log.Ltime)),`.'
  prefs: []
  type: TYPE_NORMAL
- en: Each line is prefaced with either `INFO` or client. The `client` lines indicate
    an individual request attempt. The `INFO`lines indicate whether the initial request,
    which could have been tried twice, succeeded or failed.
  prefs: []
  type: TYPE_NORMAL
- en: The decorator/decorator.go file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s look at our `decorator.go` implementation. It''s in the `02_decorator`
    directory, and the package name is `decorator`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The `ClientFunc` function is a function type that implements the `Client` interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also define two additional methods that act as the getter and setter for
    the `ratelimitDuration` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we define the `Decorator` function type to wrap our  `Client` with additional
    behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: A framework to inject dependencies
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Next, we'll look closer at the implementation of our IoC container framework.
  prefs: []
  type: TYPE_NORMAL
- en: We'll see that by wrapping decorators, which implement the `Client` interface,
    around our core client call and using the decorator pattern, our framework is
    able to extend our application functionality in a modular and easy-to-understand
    manner.
  prefs: []
  type: TYPE_NORMAL
- en: The `Decorator` notation indicates that this is a variadic parameter that can
    take any number of values. Remember our call in `main` where we passed in our
    decorators?
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping a client request with decorators (in main)
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Our `Decorate` function extends our client's functionality by iterating over
    each decorator in order.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that there are several ways to implement this wrapping functionality.
    We could have used recursion, line-by-line wrapping, or inline wrapping like we
    did earlier in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Using a variadic parameter in conjunction with a range construct, when we are
    unsure of the number of decorators we need to wrap, is probably the best choice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Authorization decorator
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Our first decorator is `Authorization`. We call the `Header` helper function
    that adds the `Authorization` header with the given token to each request at runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Logging decorator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Logging` decorator takes a pointer to the log from the `Logger` package,
    from Go''s standard library. Note that we are able to pass our custom `InfoHandler`
    since we chose to implement it using the `io.Writer` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: We execute the `Printf` command just before running the client's `Do` method.
  prefs: []
  type: TYPE_NORMAL
- en: LoadBalancing decorator
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We leverage the strategy pattern to implement our load balancing decorator.
  prefs: []
  type: TYPE_NORMAL
- en: The `LoadBalancing` decorator applies the strategy pattern to apply the logic
    that determines which backend server will receive the next incoming client request.
  prefs: []
  type: TYPE_NORMAL
- en: Strategy pattern
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The strategy pattern uses composition rather than inheritance to choose which
    behavior is executed. The behavior in our example implements a load balancing
    algorithm. Production implementations of the strategy pattern often have an administrative
    application that is used to choose which strategy it selected during runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c57721b9-cc68-4e21-aad5-c27ef7b2e134.png)'
  prefs: []
  type: TYPE_IMG
- en: Rather than using the context of the request or configuration instructions from
    an administrative application to selecting our load balancing strategy, we hardcode
    our example to use the `RoundRobin` behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The first parameter, `RoundRobin`, is the selected strategy. We pass the `RoundRobin`
    function We pass the iterating `RoundRobin` function in order over the backend
    server's host addresses. They are passed over the variadic parameter, namely backends.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of using a request to gather context to determine the strategy to employ,
    we define a `Director` function type that takes the request. We select the `RoundRobin`
    strategy and modify the request''s embedded URL member to specify the server to
    connect to:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/336ad8ee-8536-4859-88dc-19feef128350.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following is the `RoundRobin` function where we make the `r.URL.Host` assignment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Alternatively, if we had defined other load balancing strategies, such as **Least
    Loaded** or **Random**, we'd only need to implement that function and pass it
    to our `LoadBalancing` function as its director.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `LoadBalancing` function returns a decorator that spreads client requests
    across multiple backend servers, based on the given director, that is, `RoundRobin`
    in our example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Director` modifies each HTTP request to follow the chosen load balancing
    strategy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have our `FaultTolerance` decorator that extends a client with
    fault tolerance, based on the given attempts and backoff time duration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: We only want the `backing off` information output to our trace file, so we use
    our `Debug.Println` function.
  prefs: []
  type: TYPE_NORMAL
- en: Notice what each decorator has in common? They provide additional functionality
    and eventually call `c.Do(r)`. Some provide the additional functionality before
    calling `c.Do(r)`; some could do it before and after the call.
  prefs: []
  type: TYPE_NORMAL
- en: Inversion of control and dependency injection
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This is a form **Dependency Injection** (**DI**). DI is where a service; for
    example, `FaultTolerance`, is passed to a dependent object--for instance, the
    client--where it is used.
  prefs: []
  type: TYPE_NORMAL
- en: This can also be considered **Inversion of Control** (**IoC**)  (DI is a subset
    of IoC). It's the director function that we pass into the `LoadBalancing` function
    that provides the flow of control. This determines which backend server to direct
    the request to.
  prefs: []
  type: TYPE_NORMAL
- en: IoC is a design principle where a framework determines the flow of control.
    Contrast that to procedural programming, where the custom code determines the
    application's flow of control in a predetermined manner.
  prefs: []
  type: TYPE_NORMAL
- en: Our first failure
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Our first failure consisted of three requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/751abca4-5784-4272-bac2-69184f0733c7.png)'
  prefs: []
  type: TYPE_IMG
- en: Easy metrics - 2 of 3
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Our easy-metrics graph shows when the requests occurred and their average response
    time:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c9af36f3-1262-457e-b1e1-bcceb669e0f2.png)'
  prefs: []
  type: TYPE_IMG
- en: When you open the easy-metrics web application, move your mouse pointer over
    the lines for more context information. For example, when you move your mouse
    where the red arrow is pointing in the preceding screenshot, you'll see that another
    request occurred at that point.
  prefs: []
  type: TYPE_NORMAL
- en: Groking our trace log file
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In order to get a deeper understanding of why our attempts failed, we can look
    in our trace file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Groking is an old Scots term meaning to look at somebody while they''re eating
    in the hope that they''ll give you some of their food. In our case, we''ll be
    looking intently at a trace log file in hope of getting some morsel of understanding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the call to our call to the `FaultTolerance` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The key lines from our `FaultTolerance` decorator are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: This indicates that if we don't succeed at first, we'll try again twice and
    wait for a second between each attempt.
  prefs: []
  type: TYPE_NORMAL
- en: 'The work is performed in the `metrics.go` file. Note that work can take anywhere
    from 0 to 5,000 milliseconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, recall that we set our per request timeout to 1 second when we defined
    `proxyTimeoutClient`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: We tried thrice and none of our attempts took less than a second, so our first
    set of requests resulted in a failure.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the graph
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The rest of the graph shows multiple requests. We''ll focus on the following
    two:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b51e53c3-9447-4543-96e8-67ed2f58dd6b.png)'
  prefs: []
  type: TYPE_IMG
- en: Notice that in the first set of requests, in green, we made three attempts.
    Note also, in red, the requests were load-balanced, in a round-robin manner, among `web03`,
    `web01`, and `web02`. `INFO` indicates a `FAILURE!`.
  prefs: []
  type: TYPE_NORMAL
- en: The first request of the next set of requests began 10 seconds later and was
    sent to the `web03` backend server. `INFO` indicates `SUCCESS!`
  prefs: []
  type: TYPE_NORMAL
- en: Easy metrics - 3 of 3
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We can see the `FAILURE!` and `SUCCESS!` requests in the following easy-metrics
    graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4fa3b422-3f1d-47a5-9110-25cbbdf54183.png)'
  prefs: []
  type: TYPE_IMG
- en: Examining the trace log
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Similar to the failed attempts we saw earlier, none of the three requests were
    performed in under a second. Thus, they failed.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, the next request will take only 0.495 seconds and it will immediately
    succeed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The last thing to observe in this trace output are the two lines that indicate
    how many requests have been performed:`> 8 requests done`.
  prefs: []
  type: TYPE_NORMAL
- en: Since this is `DEBUG` output, we don't need to guess which file and line this
    output came from.
  prefs: []
  type: TYPE_NORMAL
- en: The decorator/requestor.go file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `DEBUG` output leads us to our last go source file, namely `requestor.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The response struct is used to record the duration and any error from running
    our request. When we capitalize names of symbols, for example, the "J" in our
    struct named `Job` in the following code, we are telling Go to export it. When
    we import a package we will only be able to access exported symbols.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The private field, `responses`, is a channel of response pointers with a buffer
    that has a size equal to `NumRequests`.
  prefs: []
  type: TYPE_NORMAL
- en: The job variable declared  in main()
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'It begins with a capital `J` to export it. We use it in our main function to
    declare the total number of requests we want to run as well as how long to wait
    between making each request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Back to the requestor.go file
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'After the Job struct definition comes the `displayProgress` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Every 500 milliseconds, `displayProgress` checks to see whether a new response
    has been processed. It does this by checking the size of the job''s response channel.
    If it finds a new response, it prints out a line like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: It will continue to loop until a value is received on the `stopChan` channel.
  prefs: []
  type: TYPE_NORMAL
- en: Using channels to manage the life cycle
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We use three channels to manage the life cycle of our requestor component:'
  prefs: []
  type: TYPE_NORMAL
- en: '`responseChan chan *response`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stopChan chan struct{}`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`interruptChan := make(chan os.Signal, 1)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every 5,000 milliseconds, we check `responseChan` to see whether we've received
    a new response. If so, we print a message indicating that the request is completed.
  prefs: []
  type: TYPE_NORMAL
- en: First, `stopChan` is used to stop the running of the `displayProgress` function.
  prefs: []
  type: TYPE_NORMAL
- en: Then, `interruptChan` is used to signal everything to shut down when the user
    presses *Ctrl* + *C*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Run` method of `Job` makes all the requests, displays summary results,
    and blocks until all responses are received:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: We start by creating `responseChan` as a buffered channel with a size equal
    to the number of requests to process. Next, we create `stopChan` as a channel
    of empty structs. We use the empty struct because it takes up no space. We've
    seen in `displayProgress` that we are not concerned with the value in the channel.
    As long as anything, even the empty struct, is received on `stopChan`, that's
    enough to signal that it's time to stop processing. We launch`j.displayProgress(stopChan)`
    as a Goroutine.
  prefs: []
  type: TYPE_NORMAL
- en: 'We create `interruptChan` in a way it is unbuffered (with a size of 1). Since
    we want to catch `SIGTERM`, which is the default signal sent by the kill command
    (*Ctrl* + *C*), and since we wish this to work for both Unix and Windows systems,
    we use `syscall.SIGTERM` as the third parameter to `signal.Notify`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Our Goroutine blocks wait for a signal from `interruptChan`. If one is received,
    it will send an empty struct instance to `stopChan` and then close `j.responseChan`
    and finally run `os.Exit(130)`, indicating a fatal error caused by *Ctrl* + *C*.
  prefs: []
  type: TYPE_NORMAL
- en: 'For every `intervalSecs`, we add 1 to `WaitGroup` and launch the next request.
    Once we''ve iterated `j.NumRequests` times, we break out of our loop and run `wg.Wait()`.
    This blocks until all the requests have completed processing. Note that the last
    line of each request-processing Goroutine is the `wg.Done()` function, which is
    used to decrements the `WaitGroup` counter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: All requests done
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When the `WaitGroup` counter reaches zero, `wg.Wait()` is unblocked and the
    processing continues to the next line, where we pass an instance of the empty
    struct to `stopChan`. As we''ve seen previously, `stopChan` signals to the `displayProgress`
    method of `Job` to stop processing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Lastly, we use our `Debug` logger to print `All requests done.` and close `responseChan` of `Job`.
  prefs: []
  type: TYPE_NORMAL
- en: Launching our makeRequest goroutine
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Our `Run` method launches a Goroutine `j.NumRequests` times. Each Goroutine
    runs this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The `makeRequest` function is called in a goroutine and passed to the client.
    We use our `Debug` logger to indicate that we are about to make a request and
    record the start time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: The key line is `resp, err := c.Do(j.Request)`.
  prefs: []
  type: TYPE_NORMAL
- en: Our DI framework in action
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This is when we actually perform the request. This is when all the decorators
    are executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: The decorators are executed in order. `Authorization` goes first, followed by
    `LoadBalancing`, `Logging`, and `FaultTolerance`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We create our IoC framework by defining the client interface with a single
    `Do` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Wrap each decorator around a return `c.Do(r)` statement that fires once the
    following line is executed in the `makeRequest` method of `Job`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: We created a simple framework for controlling the execution and enriching each
    HTTP request with our decorators wrapped around the client interface. This is
    IoC, and as we see, it's not too complicated.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3b327730-dfb9-41d6-b2e5-617baead5fd6.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we learned how no design or bad design using type hierarchies can
    lead to technical debt. We studied the decorator pattern and learned a great way
    to extend the functionality of our application using IoC.
  prefs: []
  type: TYPE_NORMAL
- en: We saw multiple examples of single method interfaces and learned to appreciate
    the fact that less is more and that good design is worthwhile.
  prefs: []
  type: TYPE_NORMAL
- en: Hopefully, by the end of this chapter, we can all agree that we can leverage
    design patterns to write better Go code.
  prefs: []
  type: TYPE_NORMAL
- en: In our next chapter, we'll use the adapter design pattern and other functional
    programming techniques to design and build better APIs.
  prefs: []
  type: TYPE_NORMAL
