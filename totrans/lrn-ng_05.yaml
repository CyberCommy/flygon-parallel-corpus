- en: Enhancing Our Components with Pipes and Directives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we built several components that rendered data on
    screen with the help of input and output properties. We will leverage the knowledge
    in this chapter to take our components to the next level with the use of directives
    and pipes. In a nutshell, while pipes give us the opportunity to digest and transform
    the information we bind in our templates, directives allow us to conduct more
    ambitious functionalities where we can access the host element properties and
    also bind our very own custom event listeners and data bindings.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will:'
  prefs: []
  type: TYPE_NORMAL
- en: Have a comprehensive overview of the built-in directives of Angular
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discover how we can refine our data output with pipes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See how we can design and build our own custom pipes and directives
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leverage built-in objects for manipulating our templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Put all the preceding topics and many more into practice to build a fully interactive
    to-do items table
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Directives in Angular
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Angular defines directives as components without views. In fact, a component
    is a directive with an associated template view. This distinction is used because
    directives are a prominent part of the Angular core and each (plain directives
    and component directives) needs the other to exist. Directives can basically affect
    the way HTML elements or custom elements behave and display their content.
  prefs: []
  type: TYPE_NORMAL
- en: Core directives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's take a closer look at the framework's core directives, and then you will
    learn how to build your own directives later on in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: NgIf
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As the official documentation states, the `ngIf` directive removes or recreates
    a portion of the DOM tree based on an expression. If the expression assigned to
    the `ngIf` directive evaluates to `false`, then the element is removed from the
    DOM. Otherwise, a clone of the element is reinserted into the DOM. We could enhance
    our countdown timer by leveraging this directive, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: When our timer reaches 0, the paragraph that displays the `Time up!` text will
    be rendered on the screen. You have probably noticed the asterisk that prepends
    the directive. This is because Angular embeds the HTML control marked with the
    `ngIf` directive (and all its HTML subtrees, if any) in a`<ng-template>`tag, which
    will be used later on to render the content on the screen. Covering how Angular
    treats templates is definitely out of the scope of this book, but let's just point
    out that this is syntactic sugar provided by Angular to act as a shortcut to other,
    more verbose syntax based on template tags.
  prefs: []
  type: TYPE_NORMAL
- en: Perhaps you are wondering what difference does it make to render some chunk
    of HTML on screen with `*ngIf="conditional"`rather than with `[hidden]="conditional"`.
    The former will clone and inject pieces of templated HTML snippets in the markup,
    removing it from the DOM when the condition evaluates to `false`, while the latter
    does not inject or remove any markup from the DOM. It simply sets the visibility
    of the already existing chunk of HTML annotated with that DOM attribute.
  prefs: []
  type: TYPE_NORMAL
- en: NgFor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `ngFor` directive allows us to iterate through a collection (or any other
    iterable object) and bind each of its items to a template of our choice, where
    we can define convenient placeholders to interpolate the item data. Each instantiated
    template is scoped to the outer context, where the loop directive is placed, so
    we can access other bindings. Let''s imagine we have a component named `Staff`:
    it features a field named employees, which represents an array of `Employee` objects.
    We can enlist those employees and job titles in this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As we can see in the example provided, we turn each item fetched from the iterable
    object on each loop into a local reference so that we can easily bind this item
    in our template. A thing to highlight is that the expression starts with the keyword
    `let`.
  prefs: []
  type: TYPE_NORMAL
- en: This directive observes changes in the underlying iterable object and will add,
    remove, or sort the rendered templates as items are added, removed, or reordered in
    the collection.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced looping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Besides from just looping all the items in a list, it is possible to keep track
    of other usable properties as well. Every property can be used the same way by
    us adding another statement after the declaration of the items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '**First/last**, this is a Boolean that keeps track of whether we are on the
    first or last item in our loop, should we want to render that item differently.
    It can be accessed in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '**Index**, is a number to tell us what index we are on; it starts at 0.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Even/odd** is a Boolean to indicate whether we are even on an even or odd
    index.'
  prefs: []
  type: TYPE_NORMAL
- en: '**TrackBy**, to explain what `trackBy` does, let''s first talk about the problem
    it attempts to solve. The problem is that the data the  `*ngFor`is pointing to
    may change, elements may be added or removed, and even the whole list may be replaced.
    The naive approach to the adding/removing of elements is to carry out create/remove
    on the DOM tree for all those elements. If same naive approach is used for displaying
    a new list instead of the old list we used to display this, it will be very expensive
    and slow. Angular deals with this by keeping DOM elements in memory because creation
    is costly. Internally, Angular uses something called object identity to keep track
    of every item in a list. `trackBy`, however, allows you to change from object
    identity to a specific property on your item. The default object identity is good
    in most cases, but if you start experiencing performance problems consider changing
    what property on your item `*ngFor` should look at like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Else
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Else is a new construct per Angular 4.0 and is a short hand you can use to
    help you with conditional statements. Imagine you have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Our use case here is pretty clear; if we have a person set then display its
    name, otherwise show a default text. We can write this in another way using `else`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'What''s happening here is how we define our conditional:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We are saying if `person` is set then go ahead, if not display the template `noperson`
    . `noperson`   can be applied to a normal HTML element as well as an   `ng-template`.
  prefs: []
  type: TYPE_NORMAL
- en: Applying style
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are three ways to apply styling in your markup:'
  prefs: []
  type: TYPE_NORMAL
- en: Interpolation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NgStyle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NgClass
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interpolation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This version is about using the curly brackets and have them resolve what class/classes
    should be applied. You would write an expression that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This reads as if your item has a selected property then apply the CSS class
    selected, or else apply empty string, which is no class. While this might be sufficient
    in a lot of cases, it has drawbacks especially if more than one style needs to
    be applied as there is more than one condition that needs checking.
  prefs: []
  type: TYPE_NORMAL
- en: Interpolation expression is considered costly in terms of performance, and is
    normally discouraged.
  prefs: []
  type: TYPE_NORMAL
- en: NgStyle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As you probably have guessed already, this directive allows us to bind CSS
    styles by evaluating a custom object or expression. We can bind an object whose
    keys and values map CSS properties, or just define specific properties and bind
    data to them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If our component defines the `myColor` and `myFontWeight` properties with the
    `red` and `bold` values, respectively, the color and weight of the text will change
    accordingly. The directive will always reflect the changes made within the component,
    and we can also pass an object instead of binding data on a per property basis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: NgClass
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Similar to `ngStyle`, `ngClass` allows us to define and toggle class names
    programmatically in a DOM element using a convenient declarative syntax. This
    syntax has its own intricacies, however. Let''s see each one of the three case
    scenarios available for this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: For instance, we can use a string type so that if `myClassNames` contains a
    string with one or several classes delimited by a space, all of them will be bound
    to the paragraph.
  prefs: []
  type: TYPE_NORMAL
- en: We can use an array as well so that each element will be added.
  prefs: []
  type: TYPE_NORMAL
- en: Last but not least, we can use an object in which each key corresponds to a
    CSS class name referred to by a Boolean value. Each key name marked as `true`
    will become an active class. Otherwise, it will be removed. This is usually the
    preferred way of handling class names.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is an alternate syntax to `ngClass`, which is in the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In short it is a comma separated version where it will apply a class when a
    condition is `true`. More than one class can be applied if more than one condition
    is `true`. It would look something like this if used in a more realistic scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting markup could be the following if `jedi.side` has the value `light`
    then add CSS class light to the span element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: NgSwitch, ngSwitchCase, and ngSwitchDefault
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `ngSwitch` directive is used to switch templates within a specific set depending
    on the condition required for displaying each one. The implementation follows
    several steps; therefore, three different directives are explained in this section.
  prefs: []
  type: TYPE_NORMAL
- en: The `ngSwitch` will evaluate a given expression and then toggle and display
    those child elements marked with an`ngSwitchCase` attribute directive, whose value
    matches the value thrown by the expression defined in the parent `ngSwitch`element.
    A special mention is required about the children element marked with the `ngSwitchDefault`directive
    attribute. This attribute qualifies the template that will be displayed when no
    other value defined by its `ngSwitchCase` siblings matches the parent conditional
    expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll see all of this in an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The parent `[ngSwitch]`parameter evaluates the `weatherForecastDay` context
    variable, and each nested`ngSwitchCase`directive will be tested against it. We
    can use expressions instead, but we want to wrap `ngSwitchCase` in brackets so
    that Angular can properly evaluate its content as context variables instead of
    taking it as a text string.
  prefs: []
  type: TYPE_NORMAL
- en: Coverage for the `NgPlural` and `NgPluralCase` sits outside of the scope of
    this book, but basically provide a convenient way to render or remove templates
    DOM blocks that match a switch expression, either strictly numeric or just a string,
    in a similar fashion to how the `ngSwitch` and `ngSwitchWhen` directives do.
  prefs: []
  type: TYPE_NORMAL
- en: Manipulating template bindings with pipes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, we saw how we can use directives to render content depending on the data
    that our component classes manage, but there is another powerful feature that
    we will be using thoroughly in our daily practice with Angular. We are talking
    about pipes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pipes allow us to filter and funnel the outcome of our expressions on a view
    level to transform or just better display the data we are binding. Their syntax
    is pretty simple, basically consisting of the pipe name following the expression
    that we want to transform, separated by a pipe symbol (hence the name):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we are displaying an uppercase greeting on the screen.
    Since we do not know whether the name will be in uppercase or not, we ensure a
    consistent output by transforming the value of the name whenever it is not an
    uppercase version at the view level. Pipes are chainable, and Angular has a wide
    range of pipe types already baked in. As we will see further in this chapter,
    we can also build our own pipes to fine-grain data output in cases where the built-in
    pipes are simply not enough.
  prefs: []
  type: TYPE_NORMAL
- en: The uppercase/lowercase pipe
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The name uppercase/lowercase pipe says it all. As in the example provided previously,
    this pipe sets the string output in uppercase or lowercase. Insert the following
    code anywhere in your view and check out the output for yourself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The decimal, percent, and currency pipes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Numeric data can come in a wide range of flavors, and this pipe is especially
    convenient when it comes to better formatting and localizing the output. These
    pipes use the Internationalization API, and therefore they are reliable in Chrome
    and Opera browsers only.
  prefs: []
  type: TYPE_NORMAL
- en: The decimal pipe
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The decimal pipe will help us define the grouping and sizing of numbers using
    the active locale in our browser. Its format is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `number_expression` is a number and `digitInfo` has the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Each binding would correspond to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`minIntegerDigits`: The minimum number of integer digits to use. It defaults
    to 1.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`minFractionDigits`: The minimum number of digits after the fraction. It defaults
    to 0.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`maxFractionDigits`: The maximum number of digits after the fraction. It defaults
    to 3.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Keep in mind that the acceptable range for each of these numbers and other
    details will depend on your native internationalization implementation. Let''s
    try to explain how this works by creating the following component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Here we have an example of four different expressions that showcases us manipulating
    the number, fractions as well as locale. In the first case, we don't give any
    instructions other than to use the `number`pipe. In the second example, we are
    are specifying the number of fractions as well as numbers to show, by typing number: `'2.1-5'`.
    This means we show the two number on the left side of the fraction marker and
    5 on the right side. Because we only we have a 3 to the left we need to pad it
    with a zero. On the right side we just show 5 decimals. In the third example,
    we instruct it to show 7 numbers to the left and 5 to the right of the fraction
    marker. This means we need to pad the left side with 6 zeros. This also means
    that the thousand markers are being added. Our fourth example demonstrates the
    locale functionality. We see that the displayed result is space character for
    thousand separator and comma instead of point as fraction sign.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one thing to remember, though; for locale setting to work, we need
    to install the correct locale in our root module. The reason is that Angular only
    have en-US locale set up from the beginning. It is quite easy to add more locales
    though.  We need to add the following code to `app.module.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The percent pipe
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The percent pipe formats a number as local percent. Other than this, it inherits
    from the number pipe so that we can further format the output to provide a better
    integer and decimal sizing and grouping. Its syntax is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The currency pipe
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This pipe formats a number as a local currency, providing support for selecting
    the currency code such as USD for the US dollar or EUR for the euro and setting
    up how we want the currency info to be displayed. Its syntax is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding statement, `currencyCode` is obviously the ISO 4217 currency
    code, while `display` is a string that
  prefs: []
  type: TYPE_NORMAL
- en: can either be `code`, assume the value `symbol` or `symbol-narrow`. The value `symbol-narrow`indicates
    whether to use the currency symbol (for example, `$`). The value `symbol` instructs
    to use the currency code (for example, USD) in the output. Similar to the decimal
    and percent pipes, we can format the output to provide a better integer and decimal
    sizing and grouping through the `digitInfo` value, we can also format based on
    locale.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following, example, we demonstrate all three forms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The slice pipe
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The purpose of this pipe is equivalent to the role played by `Array.prototype.slice()`
    and `String.prototype.slice()` when it comes to subtracting a subset (slice) of
    a collection list, array, or string, respectively. Its syntax is pretty straightforward
    and follows the same conventions as those of the aforementioned `slice()` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Basically, we configure a starting index where we will begin slicing either
    the items array or the string on an optional end index, which will fall back to
    the last index on the input when omitted.
  prefs: []
  type: TYPE_NORMAL
- en: Both start and end arguments can take positive and negative values, as the JavaScript
    `slice()` methods do. Refer to the JavaScript API documentation for a full rundown
    on all of the available scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Last but not least, please note that when operating on a collection, the returned
    list is always a copy—even when all elements are being returned.
  prefs: []
  type: TYPE_NORMAL
- en: The date pipe
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You must have already guessed that the date pipe formats a date value as a
    string based on the requested format. The time zone of the formatted output will
    be the local system time zone of the end user''s machine. Its syntax is pretty
    simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The expression input must be a date object or a number (milliseconds since
    the UTC epoch). The format argument is highly customizable and accepts a wide
    range of variations based on date-time symbols. For our convenience, some aliases
    have been made available as shortcuts to the most common date formats:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''medium''`: This is equivalent to `''yMMMdjms''` (for example, Sep 3, 2010,
    12:05:08 PM for en-US)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''short''`: This is equivalent to `''yMdjm''` (for example, 9/3/2010, 12:05
    PM'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: for en-US)
  prefs: []
  type: TYPE_NORMAL
- en: '`''fullDate''`: This is equivalent to `''yMMMMEEEEd''` (for example, Friday,
    September 3, 2010 for en-US)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''longDate''`: This is equivalent to `''yMMMMd''` (for example, September
    3, 2010)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''mediumDate''`: This is equivalent to `''yMMMd''` (for example, Sep 3, 2010
    for en-US)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''shortDate''`: This is equivalent to `''yMd''` (for example, 9/3/2010 for
    en-US)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''mediumTime''`: This is equivalent to `''jms''` (for example, 12:05:08 PM
    for en-US)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''shortTime''`: This is equivalent to `''jm''` (for example, 12:05 PM for
    en-US)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `json` pipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The JSON pipe
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'JSON is probably the most straightforward pipe in its definition; it basically
    takes an object as an input and outputs it in JSON format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The output using the Json pipe is the following `{ "name": "chris", "age":
    38, "address": { "street": "Oxford Street", "city": "London" } }`. This shows
    that the pipe has turned single quotes to double quotes and thereby produced valid
    JSON. So, why do we need this? One reason is debugging; it''s a nice way to see
    what a complex object contains and have it nicely printed to the screen. As you
    can see from the preceding field `person`, it contains some simple properties
    but also the complex `address`property. The deeper the object is the nicer it
    is, to have the json pipe.'
  prefs: []
  type: TYPE_NORMAL
- en: The i18n pipes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As part of Angular's strong commitment to providing a strong internationalization
    toolset, a reduced set of pipes targeting common i18n use cases have been made
    available. This book will only cover the two major ones, but it is quite likely
    that more pipes will be released in the future. Please refer to the official documentation
    for further information after finishing this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The i18nPlural pipe
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `i18nPlural` pipe has a simple usage, where we just evaluate a numeric
    value against an object mapping different string values to be returned depending
    on the result of the evaluation. This way, we can render different strings on
    our template depending if the numeric value is zero, one, two, more than *N*,
    and so on. The syntax is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look at how this could look for a numeric field `jedis` on your component
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can have this mapping as a field of our component controller class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We even bind the numeric value evaluated in the expression by introducing the
    `'#'` placeholder in the string mappings. When no matching value is found, the
    pipe will fall back to the mapping set with the key `'other'`.
  prefs: []
  type: TYPE_NORMAL
- en: The i18nSelect pipe
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `i18nSelect` pipe is similar to the`i18nPlural` pipe, but it evaluates
    a string value instead. This pipe is perfect for localizing text interpolations
    or providing distinct labels depending on state changes, for instance. For example,
    we could recap on our timer and serve the UI in different languages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'In our controller class, we can populate `localizedLabelsMap`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: It is important to note that we can put this convenient pipe to use in use cases
    other than localizing components, but to provide string bindings depending on
    map keys and the like. Same as the `i18nPlural` pipe, when no matching value is
    found, the pipe will fall back to the mapping set with the `'other' `key.
  prefs: []
  type: TYPE_NORMAL
- en: The async pipe
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, we manage observable data or only data that is handled asynchronously
    by our component class, and we need to ensure that our views promptly reflect
    the changes in the information once the observable field changes or asynchronous
    loading has been accomplished after the view has been rendered. The async pipe
    subscribes to an observable or promise and returns the latest value it has emitted.
    When a new value is emitted, the async pipe marks the component to be checked
    for changes. We will return to this concept in [Chapter 7](113fea8a-41c0-4884-95ad-ac95ee0c4c65.xhtml), *Asynchronous
    Data Services with Angular*.
  prefs: []
  type: TYPE_NORMAL
- en: Putting it all together in a task list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you have learned all the elements that allow you to build full-blown
    components, it's time to put all of this fresh knowledge into practice. In the
    next pages, we are going to build a simple task list manager. In it, we will see
    a tasks table containing the to-do items we need to build.
  prefs: []
  type: TYPE_NORMAL
- en: We will also queue up tasks straight from the backlog of tasks available. This
    will help showing the time required to accomplish all the queued tasks and see
    how many tasks are defined in our working agenda.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up our main HTML container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before building the actual component, we need to set up our work environment
    first and in order to do so, we will reuse the same HTML boilerplate file we used
    in the previous component. Please set aside the work you''ve done so far and keep
    the `package.json`, `tsconfig.json`, `typings.json`, and `index.html` files we
    used in previous examples. Feel free to reinstall the modules required in case
    you need to, and replace the contents of the body tag in our `index.html` template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'In a nutshell, we have just updated the title of the header layout above our
    new `<tasks>` custom elements, which replaces the previous `<timer>`. You might
    want to update the `app.module.ts` file and make sure to point out tasks as a
    component that can be visible outside of our module by entering it in the `exports`
    key array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s highlight here that the application has two modules so far: our root
    module called `AppModule` and our `TaskModule`. Our root module should import
    our `TaskModule` like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Building our task list table with Angular directives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create an empty `tasks.ts` file. You might want to use this newly created file
    to build our new component from scratch and embed on it the definitions of all
    the accompanying pipes, directives, and components we will see later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Real-life projects are never implemented this way, since our code must conform
    to the "one class, one file" principle, taking advantage of ECMAScript modules
    for gluing things together. [Chapter 6](93b8f637-859e-4e12-aaa0-4cec5f02c2c3.xhtml),
    *Building an Application with Angular Components*, will introduce you to a common
    set of good practices for building Angular applications, including strategies
    for organizing your directory tree and your different elements (components, directives,
    pipes, services, and so on) in a sustainable way. This chapter, on the contrary,
    will leverage `tasks.ts` to include all the code in a central location and then
    provide a bird's eye view of all the topics we will cover now without having to
    go switching across files. Bear in mind that this is in fact an anti-pattern,
    but for instructional purposes, we will take this approach in this chapter for
    the last time. The order in which elements are declared within the file is important.
    Refer to the code repository in GitHub if exceptions rise.
  prefs: []
  type: TYPE_NORMAL
- en: Before moving on with our component, we need to import the dependencies required,
    formalize the data model we will use to populate the table, and then scaffold
    some data that will be served by a convenient service class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s begin by adding to our `tasks.ts` file the following code block, importing
    all the tokens we will require in this chapter. Pay special attention to the tokens
    we are importing from the Angular library. We have covered components and input
    already, but all the rest will be explained later in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'With the dependency tokens already imported, let''s define the data model for
    our tasks, next to the block of imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The schema of a `Task` model interface is pretty self-explanatory. Each task
    has a name, a deadline, a field informing how many units need to be shipped, and
    a Boolean field named `queued` that defines if that task has been tagged to be
    done in our next session.
  prefs: []
  type: TYPE_NORMAL
- en: You might be surprised that we define a model entity with an interface rather
    than a class, but this is perfectly fine when the entity model does not feature
    any business logic requiring implementation of methods or data transformation
    in a constructor or setter/getter function. When the latter is not required, an
    interface just suffices since it provides the static typing we require in a simple
    and more lightweight fashion.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need some data and a service wrapper class to deliver such data in
    the form of a collection of `Task` objects. The `TaskService` class defined here
    will do the trick, so append it to your code right after the `Task` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'This data store is pretty self-explanatory: it exposes a `taskStore`property
    returning an array of objects conforming to the `Task` interface (hence benefiting
    from static typing) with information about the name, deadline, and time estimate.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a data store and a model class, we can begin building an Angular
    component that will consume this data source to render the tasks in our template
    view. Insert the following component implementation after the code you wrote before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we have defined and instantiated through the bootstrap function
    a new component named `TasksComponent` with the selector `<tasks>` (we already
    included it when we were populating the main `index.html` file, remember?). This
    class exposes two properties: today''s date and a tasks collection that will be
    rendered in a table contained in the component''s view, as we will see shortly.
    To do so, it instantiates in its constructor the data source that we created previously,
    mapping it to the array of models typed as `Task` objects represented by the tasks
    field. We also initialize the today property with an instance of the JavaScript
    built-in `Date` object, which contains the current date.'
  prefs: []
  type: TYPE_NORMAL
- en: As you have seen, the component selector does not match its controller class
    naming. We will delve deeper into naming conventions at the end of this chapter,
    as a preparation for [Chapter 6](93b8f637-859e-4e12-aaa0-4cec5f02c2c3.xhtml),
    *Building an Application with Angular Components*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create the stylesheet file now, whose implementation will be really
    simple and straightforward. Create a new file named `tasks.css` at the same location
    where our component file lives. You can then populate it with the following styles
    ruleset:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This newly created stylesheet is so simple that it might seem a bit too much
    to have it as a standalone file. However, this comes as a good opportunity to
    showcase in our example the functionalities of the `styleUrls` property of the
    component metadata.
  prefs: []
  type: TYPE_NORMAL
- en: 'Things are quite different in regards to our HTML template. This time we will
    not hardcode our HTML template in the component either, but we will point to an
    external HTML file to better manage our presentation code. Please create an HTML
    file and save it as `tasks.html` in the same location where our main component''s
    controller class exists. Once it is created, fill it in with the following HTML
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: We are basically creating a table that features a neat styling based on the
    Bootstrap framework. Then, we render all our tasks using the always convenient
    `ngFor` directive, extracting and displaying the index of each item in our collection as
    we explained while overviewing the `ngFor` directive earlier in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Please look at how we formatted the output of our task's name and deadline interpolations
    by means of pipes, and how conveniently we display (or not) an ellipsis to indicate
    when the text exceeds the maximum number of characters we allocated for the name
    by turning the HTML hidden property into a property bound to an Angular expression.
    All this presentation logic is topped with a red label, indicating whether the
    given task is due whenever its end date is prior to this day.
  prefs: []
  type: TYPE_NORMAL
- en: You have probably noticed that those action buttons do not exist in our current
    implementation. We will fix this in the next section, playing around with state
    in our components. Back in [Chapter 1](17474bca-f7f9-41ec-ab4c-5f7ac741c0c9.xhtml),
    *Creating Our Very First Component in Angular*, we touched upon the click event
    handler for stopping and resuming the countdown, and then delved deeper into the
    subject in [Chapter 4](41335dde-9066-4998-a0a9-3c42f97cdd9e.xhtml), *Implementing
    Properties and Events in Our Components*, where we covered output properties.
    Let's continue on our research and see how we can hook up DOM event handlers with
    our component's public methods, adding a rich layer of interactivity to our components.
  prefs: []
  type: TYPE_NORMAL
- en: Toggling tasks in our task list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Add the following method to your `TasksComponent` controller class. Its functionality
    is pretty basic; we just literally toggle the value of the queued property for
    a given `Task` object instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we just need to hook it up with our view buttons. Update our view to include
    a click attribute (wrapped in braces so that it acts as an output property) in
    the button created within the `ngFor` loop. Now that we will have different states
    in our `Task` objects, let''s reflect this in the button labels by implementing
    an`ngSwitch` structure all together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Our brand new button can execute the `toggleTask()`method in our component class,
    passing as an argument the `Task` object that corresponds to that iteration of
    `ngFor`. On the other hand, the preceding `ngSwitch` implementation allows us
    to display different button labels and icons depending on the state of the `Task`
    object at any given time.
  prefs: []
  type: TYPE_NORMAL
- en: We are decorating the newly created buttons with font icons fetched from the
    Glyphicons font family. The icons are part of the Bootstrap CSS bundle we installed
    previously and are in no means related to Angular. Feel free to skip its use or
    to replace it by another icon font family.
  prefs: []
  type: TYPE_NORMAL
- en: Execute the code as it is now and check out the results yourself. Neat, isn't
    it? But, maybe we can get more juice from Angular by adding more functionality
    to the task list.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying state changes in our templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we can pick the tasks to be done from the table, it would be great
    to have some kind of visual hint of how many units we are meant to ship. The logic
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The user reviews the tasks on the table and picks the ones to be done by clicking
    on each one
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every time a row is clicked, the underlying `Task` object state changes and
    its Boolean queued property is toggled
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The state change is reflected immediately on the surface by displaying a `queued`
    label on the related task item
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The user gets prompt information of the amount of units they need to ship and
    a time estimation to deliver them all
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We see how a row of icons are displayed above the table, displaying the sum
    of all units from all the tasks set to be done
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This functionality will have to react to the state changes of the set of `Task`
    objects we're dealing with. The good news is that thanks to Angular's very own
    change detection system, making components fully aware of state changes is extremely
    easy.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, our very first task will be to tweak our `TasksComponent` class to include
    some way to compute and display how many tasks are queued up. We will use that
    information to render or not a block of markup in our component where we will
    inform how many tasks we have lined up and how much aggregated time it will take
    to accomplish them all.
  prefs: []
  type: TYPE_NORMAL
- en: 'The new `queuedTasks`field of our class will provide such information, and
    we will want to insert a new method named `updateQueuedTasks()` in our class that
    will update its numeric value upon instantiating the component or enqueueing tasks.
    On top of that, we will create a key/value mapping that we can use later on to
    render a more expressive title header depending on the amount of queued tasks
    thanks to the `I18nPlural` pipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The `updateQueuedTasks()` method makes use of JavaScript''s native `Array.filter()` and `Array.reduce()`methods
    to build a list of queued tasks out of the original task''s collection property.
    The `reduce` method applied over the resulting array gives us the total number
    of units to ship. With a stateful computation of the number of queued units to
    ship now available, it''s time to update our template accordingly. Go to `tasks.html`and
    inject the following chunk of HTML right before the `<h4>Tasks backlog</h4>` element.
    The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The preceding block renders an informative header title at all times, even when
    no tasks have been queued up. We also bind that value in the template and use
    it to estimate through an expression binding the amount of minutes required to
    go through each and every session required.
  prefs: []
  type: TYPE_NORMAL
- en: We are hardcoding the duration of each task in the template. Ideally, such constant
    values should be bound from an application variable or a centralized setting.
    Don't worry, we will see how we can improve this implementation in the next chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Save your changes and reload the page, and then try to toggle some task items
    on the table to see how the information changes in real time. Exciting, isn't
    it?
  prefs: []
  type: TYPE_NORMAL
- en: Embedding child components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, let's start building a tiny icon component that will be nested inside the `TasksComponent`component.
    This new component will display a smaller version of our big icon, which we will
    use to display on the template the amount of tasks lined up to be done, as we
    described earlier in this chapter. Let's pave the way towards component trees,
    which we will analyze in detail in [Chapter 6](93b8f637-859e-4e12-aaa0-4cec5f02c2c3.xhtml),
    *Building an Application with Angular Components*. For now, just include the following
    component class before the `TasksComponent`   class you built earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Our component will expose a public property named task in which we can inject
    a`Task`object. The component will use this `Task`object binding to replicate the
    image rendered in the template as many times as sessions are required by this
    task in its `hoursLeft` property, all this by means of an `ngFor` directive.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our `tasks.ts` file, inject the following block of code before our`TasksComponent`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we continue and iterate over our component, it is important to ensure
    we register our component with a module, so that other constructs may know its
    existence, so they can use said component in their template. We register it by
    adding it to the `declarations` property of its module object like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Now that the `TaskModule` knows about our component, we can continue and improve
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Our new `TaskIconsComponent` features a pretty simple implementation, with a
    very intuitive selector matching its camel-cased class name and a template where
    we duplicate the given `<img>`tag as many times as objects are populated in the
    icons array property of the controller class, which is populated with the native
    fill method of the `Array` object in the JavaScript API (the fill method fills
    all the elements of an array with a static value passed as an argument), within`ngOnInit()`.
    Wait, what is this? Shouldn't we implement the loop populating the icons array
    member in the constructor instead?
  prefs: []
  type: TYPE_NORMAL
- en: This method is one of the life cycle hooks that we will overview in the next
    chapter, and probably the most important one. The reason why we populate the icons
    array field here and not in the constructor method is because we need each and
    every data-bound property to be properly initialized before proceeding to run
    the for loop. Otherwise, it will be too soon to access the input value task since
    it will return an undefined value.
  prefs: []
  type: TYPE_NORMAL
- en: The `OnInit` interface demands an `ngOnInit()`method to be integrated in the
    controller class that implements such -interface, and it will be executed once
    all input properties with a binding defined have been checked. We will take a
    bird's eye overview of component lifecycle hooks in [Chapter 6](93b8f637-859e-4e12-aaa0-4cec5f02c2c3.xhtml),
    *Building an Application with Angular Components*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Still, our new component needs to find its way to its parent component. So,
    let''s insert a reference to the component class in the directives property of
    the`TasksComponent` decorator settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Our next step will be to inject the `<task-icons>`element in the `TasksComponent`
    template. Go back to `tasks.html` and update the code located inside the conditional
    block meant to be displayed when `hoursLeft`is greater than zero. The code is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'There is still some room for improvement though. Unfortunately, the icon size
    is hardcoded in the `TaskIconsComponent`template and that makes it harder to reuse
    that component in other contexts where a different size might be required. Obviously,
    we could refactor the `TaskIconsComponent` class to expose a `size` input property
    and then bind the value received straight into the component template in order
    to resize the image accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we just need to update the implementation of `tasks.html` to declare
    the value we need for the size:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Please note that the `size`attribute is not wrapped between brackets because
    we are binding a hardcoded value. If we wanted to bind a component variable, that
    attribute should be properly declared as `[size]="{{mySizeVariable}}"`.
  prefs: []
  type: TYPE_NORMAL
- en: We inserted a new DOM element that will show up only when we have hours left.
    We displayed an actual header telling us how many hours we have left, by binding
    the `hoursLeft` property in an H3 DOM element, plus a total estimation in minutes
    for accomplishing all of this contained in the `{{ hoursLeft * 25 }}` expression.
  prefs: []
  type: TYPE_NORMAL
- en: The `ngFor` directive allows us to iterate through the tasks array. In each
    iteration, we render a new `<task-icons>` element.
  prefs: []
  type: TYPE_NORMAL
- en: We bound the `Task` model object of each iteration, represented by the `queuedTask`
    reference, in the task input property of the`<task-icons>` in the loop template.
  prefs: []
  type: TYPE_NORMAL
- en: We took advantage of the `<task-icons>` element to include additional mouse
    event handlers that point to the following paragraph, which has been flagged with
    the `#tooltip`local reference. So, every time the user hovers the mouse over the
    task icon, the text beneath the icons row will display the respective task name.
  prefs: []
  type: TYPE_NORMAL
- en: We ran the extra mile, turning the size of the icon rendered by `<task-icons>`into
    a configurable property as part of the component API. We now have icons that get
    updated in real time as we toggle the information on the table. New problems have
    arisen, however. Firstly, we are displaying icon components matching the hours
    left of each task, without filtering out those that are not queued. On the other
    hand, the overall estimation of time required to achieve all our tasks displays
    the gross number of minutes, and this information will make no sense as we add
    more tasks to the working plan.
  prefs: []
  type: TYPE_NORMAL
- en: Perhaps, it's time to amend this. It's a good thing that custom pipes have come
    to the rescue!
  prefs: []
  type: TYPE_NORMAL
- en: Building our own custom pipes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already seen what pipes are and what their purpose is in the overall
    Angular ecosystem, but now we are going to dive deeper into how we can build our
    own set of pipes to provide custom transformations to data bindings.
  prefs: []
  type: TYPE_NORMAL
- en: Anatomy of a custom pipe
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Pipes are very easy to define. We essentially need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Import `Pipe` and `PipeTransform`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement the `PipeTransform` interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add the `Pipe` component to modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The full code for implementing the `Pipe` would look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Let's break down the code in the upcoming subsections.
  prefs: []
  type: TYPE_NORMAL
- en: Imports
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We import the following constructs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Defining our pipe
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Pipe` is a decorator that takes an object literal; we need to at least
    give it a name property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that once used, we will refer to its name property like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The `PipeTransform` is an interface that we need to implement. We can easily
    do so by adding it to our class like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we can see that we have a transform method, but also the first argument
    being the value itself and the rest is `args`, an array with any number of arguments
    you provide it. We''ve already shown how to use this `Pipe`, but if supplying
    arguments, it looks a little bit different, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: It is worth noting that for every argument we supply, it ends up in the `args`
    array and we separate it with a colon.
  prefs: []
  type: TYPE_NORMAL
- en: Registering it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To make a construct usable, in this case a pipe, you need to tell the module
    it exists. Just like with components, we need to add to the declarations property
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The pure property
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can add a property to our `@Pipe` decorator, `pure`, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '"Why would we do that in the first place?" you ask. Well, there are situations
    where this might be necessary. If you have a pipe that works on primitives like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'We don''t have an issue. However, if it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'We might have a problem. Consider the following code in a component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Imagine that we have the following `Pipe` implementation to go with it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'This would at first be the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'However, you expect the output to change to `Chris 38` after 3 seconds, but
    it doesn''t. The pipe only looks at whether the reference have changed or not.
    In this case, it hasn''t because the object is still the same, but a property
    on the object has changed. A way to tell it to react to changes is to specify
    the `pure` property, like we did in the beginning. So, we update our `Pipe` implementation
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we suddenly see the change happen. A word of caution though. This actually
    means the `transform` method is called every time the change detection cycle is
    being triggered. So, this might actually be damaging for performance. You could
    try and cache the value if setting the `pure` property, but you could also try
    to work with reducers and immutable data to solve this in a better way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code would change the reference and our Pipe wouldn't kill performance.
    All in all, it's good to know what the pure property does, but be careful.
  prefs: []
  type: TYPE_NORMAL
- en: A custom pipe to better format time output
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Watching the gross number of minutes summed up when lining up tasks to be done
    is not very intuitive, so we need a way to deconstruct this value into hours and
    minutes. Our pipe will have the name `formattedTime` and will be implemented by
    the `formattedTimePipe` class, whose unique transform method receives a number
    representing a total number of minutes and returns a string (proving that pipes
    do not need to return the same type as they receive in the payload) in a readable
    time format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'We should not skip the opportunity to highlight that the naming convention
    for pipes is, the same as we saw with components, the name of the pipe class with
    the `Pipe` suffix plus a selector matching that name without the suffix. Why this
    mismatch between the pipe controller''s class name and the selector? It is common
    practice to prefix the selector strings of our custom pipes and directives with
    a custom prefix in order to prevent collisions with other selectors defined by
    third party pipes and directives:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we just need to tweak the HTML in the `tasks.html` template file to
    ensure that our EDT expression is properly formatted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Now, reload the page and toggle some tasks. The estimated time will be properly
    rendered in hours and minutes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we must not forget to add our `Pipe` construct to its module `tasks.module.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Filtering out data with custom filters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we noticed already, we are displaying at this moment an icon component for
    each and every task in the collection served from the tasks service, without filtering
    out what tasks are marked as queued and which aren't. Pipes provide a convenient
    way to map, transform, and digest data bindings, so we can leverage its functionalities
    for filtering out the tasks binding in our `ngFor` loop to return only those tasks
    that are marked as queued.
  prefs: []
  type: TYPE_NORMAL
- en: 'The logic will be pretty simple: since the tasks binding is an array of `Task`
    objects, we just need to make use of the `Array.filter()` method to fetch only
    those `Task` objects whose queued property is set to `true`. We might run the
    extra mile and configure our pipe to take one Boolean argument, indicating whether
    we want to filter out queued or unqueued tasks. The implementation of these requirements
    is as follows, where you can see again the conventions in place for the selector
    and class names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'The implementation is pretty straightforward, so we will not get into detail
    about it here. However, there is something that is worth highlighting at this
    stage: this is an impure pipe. Bear in mind that the tasks binding is a collection
    of stateful objects that will change in length and content as the user toggles
    tasks on the table. For that reason, we need to instruct the pipe to take advantage
    of Angular''s change detection system so its output is checked by the latter on
    every cycle regardless of whether its input has changed or not. Configuring the
    pure property of the pipe decorator as `false` will do the trick then.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we just need to update the pipes property of the component using this
    pipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, update the `ngFor` block in `tasks.html` to properly filter out the unqueued
    tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Please check how we configured the pipe as `queuedOnly: true`. Replacing the
    Boolean parameter value by `false` will give us the chance to enlist the tasks
    pertaining to the queues we have not picked.'
  prefs: []
  type: TYPE_NORMAL
- en: Save all your work and reload the page, toggling some tasks then. You will see
    how our overall UI reacts to the latest changes accordingly, and we only enlist
    the icons pertaining to the amount of hours left of queued tasks only.
  prefs: []
  type: TYPE_NORMAL
- en: Building our own custom directives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Custom directives encompass a vast world of possibilities and use cases, and
    we would need an entire book for showcasing all the intricacies and possibilities
    they offer.
  prefs: []
  type: TYPE_NORMAL
- en: In a nutshell, directives allow you to attach advanced behaviors to elements
    in the DOM. If a directive has a template attached, then it becomes a component.
    In other words, components are Angular directives with a view, but we can build
    directives with no attached views that will be applied to already existing DOM
    elements, making its HTML contents and standard behavior immediately accessible
    to the directive. This applies to Angular components as well, where the directive
    will just access its template and custom attributes and events when necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Anatomy of a custom directive
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Declaring and implementing a custom directive is pretty easy. We just need
    to import the `Directive` class to provide decorator functionalities to its accompanying
    controller class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we define a controller class annotated by the `@Directive`decorator,
    where we will define the directive selector, input and output properties (if required),
    optional events applied to the host element, and injectable provider tokens, should
    our directive''s constructor require specific types to be instantiated by the
    Angular injector when instancing itself (we will cover this in detail in [Chapter
    6](93b8f637-859e-4e12-aaa0-4cec5f02c2c3.xhtml), *Building an Application with
    Angular Components*):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s warm up by creating a very simple directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'And to use it is as simple as typing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: We use two actors here, `ElementRef` and `Renderer2`, to manipulate the underlying
    element. We could use `elementRef.nativeElement` directly, but this is discouraged
    as this might break server side rendering or when interacting with service workers.
    Instead, we do all manipulations using an instance of `Renderer2`.
  prefs: []
  type: TYPE_NORMAL
- en: Notice how we don't type the square bracket, but only the selector name.
  prefs: []
  type: TYPE_NORMAL
- en: A quick recap of what we did here was to inject the `ElementRef` and access
    the `nativeElement` property, which is the actual element. We also put a `@Directive`decorator
    on a class just like we do with components and pipes. The main mindset to have
    when creating directives is to think reusable functionality that not necessarily
    relates to a certain feature. The topic chosen previously was highlighting, but
    we could build other functionalities such as tooltip and collapsible or infinite
    scrolling features with relative ease.
  prefs: []
  type: TYPE_NORMAL
- en: 'Properties and decorators'' such as selector, `@Input()`, or `@Output()`(same
    with inputs and outputs) will probably resonate to you from the time when we overviewed
    the component decorator spec. Although we haven''t mentioned all the possibilities
    in detail yet, the selector may be declared as one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`element-name`: Select by element name'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.class`: Select by class name'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[attribute]`: Select by attribute name'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[attribute=value]`: Select by attribute name and value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`not(sub_selector)`: Select only if the element does not match the'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sub_selector`'
  prefs: []
  type: TYPE_NORMAL
- en: '`selector1`, `selector2`: Select if either `selector1` or `selector2` matches'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In addition to this, we will find the host parameter, which specifies the events,
    actions, properties, and attributes pertaining to the host element (that is, the
    element where our directive takes action) that we want to access from within the
    directive. We can therefore take advantage of this parameter to bind interaction
    handlers against the container component or any other target element of our choice,
    such as window, document, or body. In this way, we can refer to two very convenient
    local variables when writing a directive event binding:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$event`: This is the current event object that triggered the event.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$target`: This is the source of the event. This will be either a DOM element
    or an Angular directive.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Besides events, we can update specific DOM properties that belong to the host
    component. We just need to link any specific property wrapped in braces with an
    expression handled by the directive as a key-value pair in our directive's host
    definition.
  prefs: []
  type: TYPE_NORMAL
- en: The optional host parameter can also specify static attributes that should be
    propagated to a host element, if not present already. This is a convenient way
    of injecting HTML properties with computed values.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Angular team has also made available a couple of convenient decorators
    so that we can more expressively declare our host bindings and listeners straight
    on the code, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: In the next chapters, we will cover the configuration interface of directives
    and components in more detail, paying special attention to its life cycle management
    and how we can easily inject dependencies into our directives. For now, let's
    just build a simple, yet powerful, directive that will make a huge difference
    to how our UI is displayed and maintained.
  prefs: []
  type: TYPE_NORMAL
- en: Listening to events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we were able to create our first directive, but it wasn''t very interesting.
    Adding the ability to listen to events, however, would make it more interesting,
    so let''s do that. We will need to use a helper called `HostListener` to listen
    to events, so we start by importing that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'The next thing we need to do is to use it as a decorator and decorate a method;
    yes, a method, not a class. That would look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Clicking on an element using this directive will lead to an alert window showing
    up. It was quite painless to add events, so let''s try to add the events `mouseover` and `mouseleave`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: This gives us a directive that makes the background `red` on `mouseover` and
    reverts back to `yellow` when the mouse cursor leaves the component.
  prefs: []
  type: TYPE_NORMAL
- en: Adding input data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our directive is quite static on what colors are being used for what, so let''s
    ensure that they can be set from the outside. To add the first input, we need
    to use our old friend the `@Input` decorator, but instead of giving it no parameters
    as input as we are used to, we need to supply the name of the directive itself
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we have taken care of the first input; we did that with the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: But, how do we add more inputs to our directive? We'll cover that in the next
    subsection.
  prefs: []
  type: TYPE_NORMAL
- en: Adding more than one input property
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So you want to add another input, that is relatively easy as well. We just
    add a property to our HTML element like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'And in the code we type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'We notice, however, that we have no color until we do our first `mousenter`
    + `mouseleave` and the reason for that is that the constructor runs before our
    `defaultColor` property has been set. To fix that, we need to set up the input
    a bit differently. We need to use a property instead like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: To recap this section on using input, it is clear that we can use the `@Input`
    decorator for both one as well as several inputs. The first input, however, should
    refer to the selector name of the directive and the second is the name of the
    attribute you give it.
  prefs: []
  type: TYPE_NORMAL
- en: A second example – error validation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s take this new found knowledge on directives and build a directive that
    indicates that a field is erroneous. We take erroneous to mean we color elements
    and display an error text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'And to use it we just type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Building a task tooltip custom directive
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have built a highlight directive as well as an error displaying directive.
    We've learned how to deal with events as well as multiple inputs.
  prefs: []
  type: TYPE_NORMAL
- en: 'A short word on tooltip. A tooltip appears when we hover over an element. What
    you normally do to achieve that is to set the title property on the element like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'There are several approaches to build tooltips generally over such a component.
    One way is to bind to the `title` property like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if you have more logic in mind it might not be so nice to add all
    that in the markup, so at this point, we can create a directive to hide away the
    tooltip bit like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'And using it would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'However, there is another approach we can take to this. What if we wanted to
    alter the `innerText` of another element while hovering over an element? That''s
    quite easy to do, we just need to feed our directive the other element and update
    its `innerText` property like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'This of course means we need to update our directive a little bit to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: A word about naming conventions for custom directives and pipes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Talking about reusability, the common convention is to prepend a custom prefix
    to the selector. This prevents conflicts with other selectors defined by other
    libraries that we might be using in our project. The same applies to pipes as
    well, as we highlighted already when introducing our very first custom pipe.
  prefs: []
  type: TYPE_NORMAL
- en: Ultimately, it is up to you and the name convention you embrace, but it is generally
    a good idea to establish a naming convention that prevents this from happening.
    A custom prefix is definitely the easier way.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have reached this point, it is fair to say that you know almost
    everything it takes to build Angular components, which are indeed the wheels and
    the engine of all Angular 2 applications. In the forthcoming chapters, we will
    see how we can design our application architecture better, and therefore manage
    dependency injection throughout our components tree, consume data services, leverage
    the new Angular router to show and hide components when required, and manage user
    input and authentication.
  prefs: []
  type: TYPE_NORMAL
- en: Nevertheless, this chapter is the backbone of Angular development, and we hope
    that you enjoyed it as much as we did when writing about template syntax, component
    APIs based on properties and events, view encapsulation, pipes, and directives.
    Now, get ready to assume new challenges—we are about to move from learning how
    to write components to discovering how we can use them to build bigger applications,
    while enforcing good practices and rational architectures. We will see all this
    in the next chapter.
  prefs: []
  type: TYPE_NORMAL
