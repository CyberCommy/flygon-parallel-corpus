- en: Chapter 13. Modularity in Java 9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will take advantage of one of the new features added to
    Java 9 to allow us to modularize the source code and easily manage dependencies.
    We will:'
  prefs: []
  type: TYPE_NORMAL
- en: Refactor existing code to take advantage of object-oriented programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Organize object-oriented code with the new modularity in Java 9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create modular source code in Java 9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compile multiple modules with the Java 9 compiler
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run modularized code with Java 9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refactoring existing code to take advantage of object-oriented programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we start writing object-oriented code from scratch, we can take advantage
    of everything we learned in the previous chapters and all the features included
    in Java 9\. As the requirements evolve, we will have to make changes to the interfaces
    and the classes to further generalize or specialize them, edit them, and create
    new ones. The fact that we started our project with an object-oriented approach
    will make it easy to make the necessary adjustments to the code.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, we are extremely lucky and we have the chance to follow best practices
    as soon as we kick off a project. However, many other times we aren't so lucky
    and we have to work on projects that didn't follow best practices. In these cases,
    instead of following the same bad practices that generated error-prone, repetitive,
    and difficult-to-maintain code, we can use the features provided by our favorite
    IDE and additional helper tools to refactor existing code, and generate object-oriented
    code that promotes code reuse and allows us to reduce maintenance headaches.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, imagine that we have to develop a Web Service that allows us to
    work with 3D models and render them on a 2D image with a specific resolution.
    The requirements specify that the first two 3D models that we will have to render
    with our Web Service are a sphere and a cube. The Web Service must allow us to
    change the following parameters of a perspective camera that allows us to see
    a specific part of the 3D world rendered on a 2D screen:'
  prefs: []
  type: TYPE_NORMAL
- en: Position (*X*, *Y*, and *Z* values)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Direction (*X*, *Y*, and *Z* values)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Up vector (*X*, *Y*, and *Z* values)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Perspective field of view in degrees
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Near clipping plane
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Far clipping plane
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Imagine that other developers started working on the project and generated a
    single Java file with a class wrapper that declares two static methods. One of
    these methods renders a cube and the other method renders a sphere. These methods
    receive all the necessary arguments to render each 3D figure, including all the
    necessary parameters to determine the 3D figure's location and size, and configure
    the perspective camera and a directional light.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following lines show an example of the declaration of the class named `Renderer`
    with two static methods: `renderCube` and `renderSphere`. The first one sets up
    and renders a cube, and the second one sets up and renders a sphere. It is very
    important to understand that the sample code doesn''t follow best practices and
    we will refactor it. Take into account that the two static methods have a lot
    of code in common. The code file for the sample is included in the `java_9_oop_chapter_13_01`
    folder, in the `example13_01.java` file.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Each static method requires a huge number of parameters. Now, let's imagine
    we have new requirements for our Web Service. We have to add code to render additional
    shapes, and add different types of cameras and lights. In addition, we have to
    work in an **IoT** (**Internet of Things**) project in which we have to reuse
    shapes in a computer vision application, and therefore, we want to take advantage
    of the code we have for our Web Service and share the code base with this new
    project. In addition, we have to work on another project that will run on a powerful
    IoT board, specifically a member of the Intel Joule series that will run a rendering
    service and will use its 4K video output capabilities to display the generated
    graphics. We will use the powerful quad-core CPU included in this board to run
    the local rendering service and, in this case, we won't be calling the Web Service.
  prefs: []
  type: TYPE_NORMAL
- en: Many applications have to share many pieces of code and our code must be ready
    for new shapes, cameras, and lights. The code can easily become a really big mess,
    repetitive, and difficult to maintain. Of course, the previously shown code is
    already difficult to maintain. Hence, we will refactor the existing code, and
    we will create many interfaces and classes to create an object-oriented version
    that we will be able to expand based on new requirements and reuse in our different
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have been working with JShell to run our code samples. This time,
    we will create one Java source code file for each interface or class. In addition,
    we will organize these files into the new modules introduced in Java 9\. Finally,
    we will compile these modules and run a console application. You can use your
    favorite editor or IDE to create the different code files. Remember that you can
    download the indicated code files and you don't have to type any code.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create the following public interfaces, abstract classes, and concrete
    classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Vector3d`: This concrete class represents a mutable 3D vector with `int` values
    for `x`, `y`, and `z`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Rendereable`: This interface specifies the requirements for an element that
    has a location and can be rendered.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SceneElement`: This abstract class implements the `Rendereable` interface,
    and represents any element that has a location and can be rendered. All the scene
    elements will inherit from this abstract class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Light`: This abstract class inherits from `SceneElement` and represents a
    light in the scene that must provide a description of its properties.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DirectionalLight`: This concrete class inherits from `Light` and represents
    a directional light that has a specific color.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Camera`: This abstract class inherits from `SceneElement` and represents a
    camera in the scene.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PerspectiveCamera`: This concrete class inherits from `Camera` and represents
    a perspective camera that has a direction, an up vector, a field of view, a near
    clipping plane, and a far clipping plane.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Shape`: This abstract class inherits from `SceneElement`, and represents a
    shape in the scene that can be rendered with an active camera and receives multiple
    lights.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Sphere`: This concrete class inherits from `Shape` and represents a sphere.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Cube`: This concrete class inherits from `Shape` and represents a cube.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Scene`: This concrete class represents the scene with an active camera, shapes,
    and lights. We can use an instance of this class to compose a scene and render
    it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Example01`: This concrete class will declare a main static method that will
    use a `PerspectiveCamera`, a `Sphere`, a `Cube`, and a `DirectionalLight` to create
    a `Scene` instance and call its render method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will declare each of the previously enumerated interfaces, abstract classes,
    and concrete classes in a file with the `.java` extension and with the same name
    as the type we declare. For example, we will declare the `Vector3d` class in the
    `Vector3d.java` file, also known as the Java source file.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is a good practice and a common convention to declare a single public interface
    or class in a Java source file with the same name as the type we declare. The
    Java compiler will generate an error in a case where we declare more than one
    public type in a Java source file.
  prefs: []
  type: TYPE_NORMAL
- en: Organizing object-oriented code with the new modularity in Java 9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we have just a few interfaces and classes, hundreds of lines of object-oriented
    code are easy to organize and maintain. However, as the number of types and lines
    of code start to increase, it is necessary to follow some rules to organize the
    code and make it easy to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: A very well-written object-oriented code can generate a maintenance headache
    if it isn't organized in an effective way. We don't have to forget that a well-written
    object-oriented code promotes code reuse.
  prefs: []
  type: TYPE_NORMAL
- en: In our example, we will have just a few interfaces, abstract classes, and concrete
    classes. However, we must imagine that we will have a huge number of additional
    types to support the additional requirements. Hence, we will end up with dozens
    of classes related to the mathematical operations required to render the elements
    that compose a scene, additional types of lights, new types of cameras, classes
    related to these new lights and cameras, and dozens of additional shapes and their
    related classes.
  prefs: []
  type: TYPE_NORMAL
- en: We will create many modules to allow us to create units of software that have
    a name, require other modules, and export a public API that is usable and accessible
    by other modules. When a module requires other modules, it means that this module
    depends on the modules listed as requirements. The name for each module will follow
    the same conventions we usually use for packages in Java.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Other modules can only access the public types that a module exports. If we
    declare a public type within a module but we don't include it in the exported
    API, we won't be able to access it outside of the module. We have to avoid circular
    dependencies when we create module dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create the following eight modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '`com.renderer.math`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`com.renderer.sceneelements`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`com.renderer.lights`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`com.renderer.cameras`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`com.renderer.shapes`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`com.renderer.shapes.curvededges`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`com.renderer.shapes.polyhedrons`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`com.renderer`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, whenever we need to work with lights, we will explore the types declared
    in the `com.renderer.lights` module. Whenever we need to work with 3D shapes with
    curved edges, we will explore the types declared in the `com.renderer.shapes.curvededges`
    module.
  prefs: []
  type: TYPE_NORMAL
- en: Each module will declare the classes and interfaces in a package that will have
    the same name as the module name. For example, the `com.renderer.cameras` module
    will declare classes in the `com.renderer.cameras` package. A **package** is a
    grouping of related types. Each package generates a namespace that declares a
    scope. Thus, we will work with packages in combination with modules.
  prefs: []
  type: TYPE_NORMAL
- en: The following table summarizes the modules we will create, and the interfaces,
    abstract classes, and concrete interfaces that we will declare within each module.
    In addition, the table specifies the list of modules that each module requires.
  prefs: []
  type: TYPE_NORMAL
- en: '| Module name | Declared public types | Module requirements |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `com.renderer.math` | `Vector3d` | `-` |'
  prefs: []
  type: TYPE_TB
- en: '| `com.renderer.sceneelements` | `Rendereable``SceneElement` | `com.renderer.math`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `com.renderer.lights` | `Light``DirectionalLight` | `com.renderer.math``com.renderer.sceneelements`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `com.renderer.cameras` | `Camera``PerspectiveCamera` | `com.renderer.math``com.renderer.sceneelements`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `com.renderer.shapes` | `Shape` | `com.renderer.math``com.renderer.sceneelements``com.renderer.lights``com.renderer.cameras`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `com.renderer.shapes.curvededges` | `Sphere` | `com.renderer.math``com.renderer.lights``co`
    `m.renderer.shapes` |'
  prefs: []
  type: TYPE_TB
- en: '| `com.renderer.shapes.polyhedrons` | `Cube` | `com.renderer.math``com.renderer.lights``com.renderer.shapes`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `com.renderer` | `Scene``Example01` | `com.renderer.math``com.renderer.cameras``com.renderer.lights``com.renderer.shapes``com.renderer.shapes.curvededges``com.renderer.shapes.polyhedrons`
    |'
  prefs: []
  type: TYPE_TB
- en: It is very important to notice that all the modules also require the `java.base`
    module that exports all of the platform's core packages such as `java.io`, `java.lang`,
    `java.math`, `java.net`, and `java.util`, among others. However, every module
    depends implicitly on the `java.base` module, and therefore, there is no need
    to include it in the dependency list when we declare the new modules and specify
    their required modules.
  prefs: []
  type: TYPE_NORMAL
- en: The next diagram shows the module graph in which the modules are nodes and a
    dependency of one module on another one is a directed edge. We don't include `java.lang`
    in the module graph.
  prefs: []
  type: TYPE_NORMAL
- en: '![Organizing object-oriented code with the new modularity in Java 9](img/00101.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We won't work with any specific IDE to create all the modules. This way, we
    will understand the directory structure and all the required files. Then, we can
    take advantage of the features included in our favorite IDE to easily create new
    modules and their necessary directory structure.
  prefs: []
  type: TYPE_NORMAL
- en: There is a convention that specifies that the source code for the module must
    be located in a directory with the same name as the module name. For example,
    the module named `com.renderer.math` must be located in a directory named `com.renderer.math`.
    We have to create a module descriptor for each desired module, that is, a source
    code file named `module-info.java`, within the root folder for the module. This
    file specifies the module name, the modules that are required, and the packages
    that the module exports. The exported packages will be visible by the modules
    that require the module.
  prefs: []
  type: TYPE_NORMAL
- en: Then, it is necessary to create subdirectories for each name separated by a
    dot (`.`) in the module name. For example, we will create the `com/renderer/math`
    directories (`com\renderer\math` sub-folders in Windows) within the `com.renderer.math`
    directory. The Java source files that declare the interfaces, abstract classes,
    and concrete classes for each module will be located in these sub-folders.
  prefs: []
  type: TYPE_NORMAL
- en: We will create a base directory named `Renderer` with a sub-folder named `src`
    that will include all the source code for our modules. So, we will have `Renderer/src`
    (`Renderer\src` in Windows) as our base directory for the source code. Then, we
    will create a folder for each module with the `module-info.java` file and the
    sub-folders with the Java source code files. The following directory structure
    shows the final contents we will have within the `Renderer/src` (`Renderer\src`
    in Windows) directory. The file names are highlighted.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Creating modular source code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now it is time to start creating the necessary directory structures, and write
    the code for the `module-info.java` files and the source Java files for each module.
    We will create the `com.renderer.math` module.
  prefs: []
  type: TYPE_NORMAL
- en: Create a directory named `Renderer` and a `src` sub-directory. We will use `Renderer/src`
    (`Renderer\src` in Windows) as our base directory for the source code. However,
    take into account that you don't need to create any folder in a case where you
    download the source code.
  prefs: []
  type: TYPE_NORMAL
- en: Now create the `com.renderer.math` directory in `Renderer/src` (`Renderer\src`
    in Windows). Add the following lines to a file named `module-info.java` in the
    recently created sub-folder. The next lines compose the module descriptor for
    a module named `com.renderer.math`. The code file for the sample is included in
    the `java_9_oop_chapter_13_01/Renderer/src/com.renderer.math` sub-folder, in the
    `module-info.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `module` keyword followed by the module name `com.renderer.math` begins
    the module declaration. The lines included within the curly braces specify the
    module body. The `exports` keyword followed by the package name `com.renderer.math`
    indicates that this module exports all the public types declared within the `com.renderer.math`
    package.
  prefs: []
  type: TYPE_NORMAL
- en: Create the `com/renderer/math` (`com\renderer\math` in Windows) folders in `Renderer/src`
    (`Renderer\src` in Windows). Add the following lines to a file named `Vector3d.java`
    in the recently created sub-folder. The next lines declare the public `Vector3d`
    concrete class as a member of the `com.renderer.math` package. We will use the
    `Vector3d` class instead of working with separate values for `x`, `y`, and `z`.
    The `package` keyword followed by the package name indicates the package in which
    the class will be included.
  prefs: []
  type: TYPE_NORMAL
- en: The code file for the sample is included in the `java_9_oop_chapter_13_01/Renderer/src/com.renderer.math/com/renderer/math`
    sub-folder, in the `Vector3d.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now create the `com.renderer.sceneelements` directory in `Renderer/src` (`Renderer\src`
    in Windows). Add the following lines to a file named `module-info.java` in the
    recently created sub-folder. The next lines compose the module descriptor for
    a module named `com.renderer.sceneelements`. The code file for the sample is included
    in the `java_9_oop_chapter_13_01/Renderer/src/com.renderer.sceneelements` sub-folder,
    in the `module-info.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `module` keyword followed by the module name, `com.renderer.sceneelements`
    begins the module declaration. The lines included within the curly braces specify
    the module body. The `requires` keyword followed by a module name, `com.renderer.math`,
    indicates that this module requires the types exported in the previously declared
    `com.renderer.math` module. The `exports` keyword followed by the package name,
    `com.renderer.sceneelements`, indicates that this module exports all the public
    types declared within the `com.renderer.sceneelements` package.
  prefs: []
  type: TYPE_NORMAL
- en: Create the `com/renderer/sceneelements` (`com\renderer\sceneelements` in Windows)
    folders in `Renderer/src` (`Renderer\src` in Windows). Add the following lines
    to a file named `Rendereable.java` in the recently created sub-folder. The next
    lines declare the public `Rendereable` interface as a member of the `com.renderer.sceneelements`
    package. The code file for the sample is included in the `java_9_oop_chapter_13_01/Renderer/src/com.renderer.sceneeelements/com/renderer/sceneelements`
    sub-folder, in the `Rendereable.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Add the following lines to a file named `SceneElement.java` in the recently
    created sub-folder. The next lines declare the public `SceneElement` abstract
    class as a member of the `com.renderer.sceneelements` package. The code file for
    the sample is included in the `java_9_oop_chapter_13_01/Renderer/src/com.renderer.sceneelements/com/renderer/sceneelements`
    sub-folder, in the `SceneElement.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `SceneElement` abstract class implements the previously defined `Rendereable`
    interface. The class represents a 3D element that is part of a scene and has a
    location specified with a `Vector3d`. The class is the base class for all the
    scene elements that require a location in the 3D space.
  prefs: []
  type: TYPE_NORMAL
- en: Now create the `com.renderer.lights` directory in `Renderer/src` (`Renderer\src`
    in Windows). Add the following lines to a file named `module-info.java` in the
    recently created sub-folder. The next lines compose the module descriptor for
    a module named `com.renderer.lights`. The code file for the sample is included
    in the `java_9_oop_chapter_13_01/Renderer/src/com.renderer.lights` sub-folder,
    in the `module-info.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous lines declare the `com.renderer.lights` module and specifies that
    the module requires two modules: `com.renderer.math` and `com.renderer.sceneelements`.
    The `exports` keyword followed by the package name, `com.renderer.lights`, indicates
    that this module exports all the public types declared within the `com.renderer.lights`
    package.'
  prefs: []
  type: TYPE_NORMAL
- en: Create the `com/renderer/lights` (`com\renderer\lights` in Windows) folders
    in `Renderer/src` (`Renderer\src` in Windows). Add the following lines to a file
    named `Light.java` in the recently created sub-folder. The next lines declare
    the public `Light` abstract class as a member of the `com.renderer.lights` package.
    The class inherits from the `SceneElement` class and declares an abstract `getPropertiesDescription`
    method that must return a `String` with the description for all the properties
    that the light has. The concrete classes that inherit from the `Light` class will
    be responsible for providing the implementation for this method. The code file
    for the sample is included in the `java_9_oop_chapter_13_01/Renderer/src/com.renderer.lights/com/renderer/lights`
    sub-folder, in the `Light.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Add the following lines to a file named `DirectionalLight.java` in the recently
    created sub-folder. The next lines declare the public `DirectionalLight` concrete
    class as a member of the `com.renderer.lights` package. The code file for the
    sample is included in the `java_9_oop_chapter_13_01/Renderer/src/com.renderer.lights/com/renderer/lights`
    sub-folder, in the `DirectionalLight.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `DirectionalLight` concrete class inherits from the previously defined `Light`
    abstract class. The `DirectionalLight` class represents a directional light, and
    provides an implementation for both the `render` and `getPropertiesDescription`
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: Now create the `com.renderer.cameras` directory in `Renderer/src` (`Renderer\src`
    in Windows). Add the following lines to a file named `module-info.java` in the
    recently created sub-folder. The next lines compose the module descriptor for
    a module named `com.renderer.cameras`. The code file for the sample is included
    in the `java_9_oop_chapter_13_01/Renderer/src/com.renderer.cameras` sub-folder,
    in the `module-info.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous lines declare the `com.renderer.cameras` module and specifies
    that the module requires two modules: `com.renderer.math` and `com.renderer.sceneelements`.
    The `exports` keyword followed by the package name, `com.renderer.cameras`, indicates
    that this module exports all the public types declared within the `com.renderer.cameras`
    package.'
  prefs: []
  type: TYPE_NORMAL
- en: Create the `com/renderer/cameras` (`com\renderer\cameras` in Windows) folders
    in `Renderer/src` (`Renderer\src` in Windows). Add the following lines to a file
    named `Camera.java` in the recently created sub-folder. The next lines declare
    the public `Camera` abstract class as a member of the `com.renderer.cameras` package.
    The class inherits from the `SceneElement` class. The class represents a 3D camera.
    It is the base class for all cameras. In this case, the class declaration is empty,
    and we only declare it because we know that there will be many types of cameras.
    In addition, we want to be able to generalize the common requirements for all
    types of cameras in the future, as we did for the lights. The code file for the
    sample is included in the `java_9_oop_chapter_13_01/Renderer/src/com.renderer.cameras/com/renderer/cameras`
    sub-folder, in the `Camera.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Add the following lines to a file named `PerspectiveCamera.java` in the recently
    created sub-folder. The next lines declare the public `PerspectiveCamera` concrete
    class as a member of the `com.renderer.cameras` package. The code file for the
    sample is included in the `java_9_oop_chapter_13_01/Renderer/src/com.renderer.cameras/com/renderer/cameras`
    sub-folder, in the `PerspectiveCamera.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `PerspectiveCamera` concrete class inherits from the previously defined
    `Camera` abstract class. The `PerspectiveCamera` class represents a perspective
    camera with many getter and setter methods for the camera's properties. The class
    provides an implementation for the `render` method that displays all the details
    for the created camera and the values for its different properties.
  prefs: []
  type: TYPE_NORMAL
- en: Now create the `com.renderer.shapes` directory in `Renderer/src` (`Renderer\src`
    in Windows). Add the following lines to a file named `module-info.java` in the
    recently created sub-folder. The next lines compose the module descriptor for
    a module named `com.renderer.shapes`. The code file for the sample is included
    in the `java_9_oop_chapter_13_01/Renderer/src/com.renderer.shapes` sub-folder,
    in the `module-info.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous lines declare the `com.renderer.shapes` module and specifies that
    the module requires four modules: `com.renderer.math`, `com.renderer.sceneelements`,
    `com.renderer.lights`, and `com.renderer.cameras`. The `exports` keyword followed
    by the package name, `com.renderer.shapes`, indicates that this module exports
    all the public types declared within the `com.renderer.shapes` package.'
  prefs: []
  type: TYPE_NORMAL
- en: Create the `com/renderer/shapes` (`com\renderer\shapes` in Windows) folders
    in `Renderer/src` (`Renderer\src` in Windows). Add the following lines to a file
    named `Shape.java` in the recently created sub-folder. The next lines declare
    the public `Shape` abstract class as a member of the `com.renderer.shapes` package.
    The code file for the sample is included in the `java_9_oop_chapter_13_01/Renderer/src/com.renderer.shapes/com/renderer/shapes`
    sub-folder, in the `Shape.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Shape` class inherits from the `SceneElement` class. The class represents
    a 3D shape and is the base class for all the 3D shapes. The class defines the
    following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`setActiveCamera`: This public method receives a `Camera` instance and saves
    it as the active camera.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setLights`: This public method receives a `List<Light>` and saves it as the
    list of lights that must be considered to render the shape.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isValidForRender`: This protected method returns a `boolean` value indicating
    whether the shape has an active camera and at least one light. Otherwise, the
    shape is not valid for being rendered.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`generateConsideringLights`: This protected method returns a `String` with
    the lights that are being considered to render the shape, with their locations
    and their properties descriptions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each subclass of the `Shape` class that will represent a specific 3D shape will
    provide an implementation for the `render` method. We will code these subclasses
    in two additional modules.
  prefs: []
  type: TYPE_NORMAL
- en: Now create the `com.renderer.shapes.curvededges` directory in `Renderer/src`
    (`Renderer\src` in Windows). Add the following lines to a file named `module-info.java`
    in the recently created sub-folder. The next lines compose the module descriptor
    for a module named `com.renderer.curvededges`. The code file for the sample is
    included in the `java_9_oop_chapter_13_01/Renderer/src/com.renderer.curvededges`
    sub-folder, in the `module-info.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous lines declare the `com.renderer.shapes` module and specifies that
    the module requires three modules: `com.renderer.math`, `com.renderer.lights`,
    and `com.renderer.shapes`. The `exports` keyword followed by the package name,
    `com.renderer.shapes.curvededges`, indicates that this module exports all the
    public types declared within the `com.renderer.shapes.curvededges` package.'
  prefs: []
  type: TYPE_NORMAL
- en: Create the `com/renderer/shapes/curvededges` (`com\renderer\shapes\curvededges`
    in Windows) folders in `Renderer/src` (`Renderer\src` in Windows). Add the following
    lines to a file named `Sphere.java` in the recently created sub-folder. The next
    lines declare the public `Sphere` concrete class as a member of the `com.renderer.shapes.curvededges`
    package. The code file for the sample is included in the `java_9_oop_chapter_13_01/Renderer/src/com.renderer.shapes.curvededges/com/renderer/shapes/curvededges`
    sub-folder, in the `Sphere.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `Sphere` class inherits from the `Shape` class and requires a radius value
    in the constructor in addition to the `Vector3d` instance that specifies the location
    for the sphere. The class provides an implementation for the `render` method that
    checks the value returned by the `isValidForRender` method. If the method returns
    `true`, the sphere is valid for being rendered, and the code builds a message
    with the sphere radius, its location, and the lights that are being considered
    when rendering the sphere. The code calls the `generateConsideringLights` method
    to build the message.
  prefs: []
  type: TYPE_NORMAL
- en: Now create the `com.renderer.shapes.polyhedrons` directory in `Renderer/src`
    (`Renderer\src` in Windows). Add the following lines to a file named `module-info.java`
    in the recently created sub-folder. The next lines compose the module descriptor
    for a module named `com.renderer.polyhedrons`. The code file for the sample is
    included in the `java_9_oop_chapter_13_01/Renderer/src/com.renderer.polyhedrons`
    sub-folder, in the `module-info.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous lines declare the `com.renderer.polyhedrons` module and specifies
    that the module requires three modules: `com.renderer.math`, `com.renderer.lights`,
    and `com.renderer.shapes`. The `exports` keyword followed by the package name,
    `com.renderer.shapes.polyhedrons`, indicates that this module exports all the
    public types declared within the `com.renderer.shapes.polyhedrons` package.'
  prefs: []
  type: TYPE_NORMAL
- en: Create the `com/renderer/shapes/polyhedrons` (`com\renderer\shapes\polyhedrons`
    in Windows) folders in `Renderer/src` (`Renderer\src` in Windows). Add the following
    lines to a file named `Cube.java` in the recently created sub-folder. The next
    lines declare the public `Cube` concrete class as a member of the `com.renderer.shapes.polyhedrons`
    package. The code file for the sample is included in the `java_9_oop_chapter_13_01/Renderer/src/com.renderer.shapes.polyhedrons/com/renderer/shapes/polyhedrons`
    sub-folder, in the `Cube.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `Cube` class inherits from the `Shape` class and requires an `edgeLength`
    value in the constructor in addition to the `Vector3d` that specifies the location
    for the cube. The class provides an implementation for the `render` method that
    checks the value returned by the `isValidForRender` method. If the method returns
    `true`, the cube is valid for being rendered and the code builds a message with
    the cube's edge length, its location, and the lights that are being considered
    when rendering the cube. The code calls the `generateConsideringLights` method
    to build the message.
  prefs: []
  type: TYPE_NORMAL
- en: Now create the `com.renderer` directory in `Renderer/src` (`Renderer\src` in
    Windows). Add the following lines to a file named `module-info.java` in the recently
    created sub-folder. The next lines compose the module descriptor for a module
    named `com.renderer`. The code file for the sample is included in the `java_9_oop_chapter_13_01/Renderer/src/com.renderer`
    sub-folder, in the `module-info.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous lines declare the `com.renderer` module and specifies that the
    module requires six modules: `com.renderer.math`, `com.renderer.cameras`, `com.renderer.lights`,
    `com.renderer.shapes`, `com.renderer.shapes.curvededges`, and `com.renderer.shapes.polyhedrons`.
    The `exports` keyword followed by the package name, `com.renderer`, indicates
    that this module exports all the public types declared within the `com.renderer`
    package.'
  prefs: []
  type: TYPE_NORMAL
- en: Create the `com/renderer` (`com\renderer` in Windows) folders in `Renderer/src`
    (`Renderer\src` in Windows). Add the following lines to a file named `Scene.java`
    in the recently created sub-folder. The next lines declare the public `Scene`
    concrete class as a member of the `com.renderer` package. The code file for the
    sample is included in the `java_9_oop_chapter_13_01/Renderer/src/com.renderer/com/renderer`
    sub-folder, in the `Scene.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `Scene` class represents the scene to be rendered. The class declares an
    `activateCamera` protected field that holds a `Camera` instance. The `lights`
    protected field is a `List` of `Light` instances, and the `shapes` protected field
    is a `List` of `Shape` instances that compose the scene. The `addLight` method
    adds the `Light` instance received as an argument to the `List<Light>lights`.
    The `addShape` method adds the `Shape` instance received as an argument to the
    `List<Shape> shapes`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `render` method calls the render method for the active camera and all the
    lights. Then, the code performs the following actions for each shape: sets its
    active camera, sets the lights, and calls the `render` method.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, add the following lines to a file named `Example01.java` in the recently
    created sub-folder. The next lines declare the public `Example01` concrete class
    as a member of the `com.renderer` package. The code file for the sample is included
    in the `java_9_oop_chapter_13_01/Renderer/src/com.renderer/com/renderer` sub-folder,
    in the `Example01.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `Example01` class is the main class for our test application. The class
    just declares a `static` method named `main` that receives an array of `String`
    named `args` as an argument. Java will call this method when we execute the application
    and will pass the arguments in the `args` parameter. In this case, the code in
    the `main` method doesn't take into account any specified argument.
  prefs: []
  type: TYPE_NORMAL
- en: The main method creates a `PerspectiveCamera` instance with the necessary parameters,
    and then creates a `Shape` and a `Cube` named `shape` and `cube`. Then, the code
    creates a `DirectionalLight` instance named `light`.
  prefs: []
  type: TYPE_NORMAL
- en: The next line creates a `Scene` instance with `camera` as the value for the
    `activeCamera` argument. Then, the code calls the `scene.addShape` method twice
    with `sphere` and `cube` as arguments. Finally, the code calls `scene.addLight`
    with `light` as an argument and calls the `scene.render` method to display the
    messages generated by the simulated render process.
  prefs: []
  type: TYPE_NORMAL
- en: Compiling multiple modules with the Java 9 compiler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create a sub-folder named `mods` within the base directory named `Renderer`.
    This new sub-folder will replicate the directory structure that we created in
    the `Renderer/src` (`Renderer\src` in Windows) folder. We will run the Java compiler
    to generate a Java class file for each Java source file. A Java class file will
    contain Java bytecode that can be executed on the **Java Virtual Machine**, also
    known as the **JVM**. We will have a file with the `.class` extension for each
    Java source file with the `.java` extension, including the module descriptors.
    For example, after we successfully use the Java compiler to compile the `Renderer/src/com.renderer.math/com/renderer/math/Vector3d.java`
    source file, the compiler will generate a `Renderer/mods/com.renderer.math/com/renderer/math/Vector3d.class`
    file with Java bytecode (known as a Java class file). In Windows, we must use
    a backslash (`\`) as the path separator instead of the slash (`/`).
  prefs: []
  type: TYPE_NORMAL
- en: Now, open a Terminal window on macOS or Linux, or Command Prompt in Windows,
    and go to the `Renderer` folder. Make sure the `javac` command is included in
    the path, and that it is the Java compiler for Java 9 and not for previous Java
    versions that aren't compatible with the modules introduced in Java 9.
  prefs: []
  type: TYPE_NORMAL
- en: In macOS or Linux, run the following command to compile all the modules we have
    recently created and place the generated Java class files in a directory structure
    within the `mods` folder. The `-d` option specifies where to place the generated
    class files and the `--module-source-path` option indicates where to find the
    input source files for multiple modules.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In Windows, run the following command to achieve the same goal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The following directory structure shows the final contents we will have within
    the `Renderer/mods` (`Renderer\mods` in Windows) directory. The Java class files
    generated by the Java compiler are highlighted.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Run modularized code with Java 9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Finally, we can use the `java` command to launch the Java application. Go back
    to the Terminal window on macOS or Linux, or a Command Prompt in Windows, and
    make sure you are in the `Renderer` folder. Make sure the `java` command is included
    in the path, and that it is the `java` command for Java 9 and not for previous
    Java versions that aren't compatible with the modules introduced in Java 9.
  prefs: []
  type: TYPE_NORMAL
- en: In macOS, Linux or Windows, run the following command to load the compiled modules,
    resolve the `com.renderer` module, and run the `main` static method for the `Example01`
    class declared in the `com.renderer` package. The `--module-path` option specifies
    the directory in which the modules can be found. In this case, we just specify
    the `mods` folder. However, we may include many directories separated by a semicolon
    (`;`). The `-m` option specifies the initial module name to resolve followed by
    a slash (`/`) and the name of the main class to execute.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The following lines show the generated output after executing the previous command
    that runs the `main` static method for the `Example01` class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In previous Java versions we could aggregate many Java class files, and their
    associated metadata and resources into a compressed file with the `.jar` extension,
    known as a **JAR** (**Java Archive**) file. We can also package modules as modularJARs
    that include the `module-info.class` file within the compressed file in the top-level
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, we can use the Java linking tool (`jlink`) to create a customized
    runtime image with only the modules that are required for our application. This
    way, we can take advantage of whole-program optimizations and generate a custom
    runtime image that will run on top of the JVM.
  prefs: []
  type: TYPE_NORMAL
- en: Test your knowledge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By default, a module requires:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `java.base` module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `java.lang` module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `java.util` module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'There is a convention that specifies that the source code for a Java 9 module
    must be located in a directory with:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The same name as the main class exported by the module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The same name as the module name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The same name as the main type exported by the module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Which of the following source code files is a module descriptor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`module-def.java`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`module-info.java`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`module-data.java`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Which of the following keywords must be followed by the module name in the
    module descriptor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`name`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`module-name`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`module`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `exports` keyword followed by a package name in the module descriptor indicates
    that the module exports:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All the classes declared within the package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All the types declared within the package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All the public types declared within the package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned to refactor existing code to take full advantage
    of object-oriented code with Java 9\. We have prepared the code for future requirements,
    reduce maintenance costs, and maximized code reuse.
  prefs: []
  type: TYPE_NORMAL
- en: We learned to organize object-oriented code. We created many Java source files.
    We declared interfaces, abstract classes, and concrete classes in different Java
    source files. We took advantage of the new modularity features included in Java
    9 to create many modules that have dependencies on different modules and exported
    specific types. We learned to declare modules, compile them to Java bytecode,
    and launch an application outside of JShell.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have learned to write object-oriented code in Java 9, you are ready
    to use everything you learned in real-life desktop applications, mobile apps,
    enterprise applications, Web Services, and web applications. These applications
    will maximize code reuse, simplify maintenance, and they will be always ready
    for future requirements. The fact that you can use JShell to easily prototype
    new interfaces and classes will boost your productivity as an object-oriented
    Java 9 developer.
  prefs: []
  type: TYPE_NORMAL
