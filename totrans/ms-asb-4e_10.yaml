- en: '*Chapter 8*: Composing Reusable Ansible Content with Roles'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For many projects, a simple, single **Ansible** playbook may suffice. As time
    goes on and projects grow, additional playbooks and variable files are added,
    and task files may be split. Other projects within an organization may want to
    reuse some of the content, and either the projects get added to the directory
    tree or the desired content may get copied across multiple projects. As the complexity
    and size of the scenario grow, something more than a loosely organized handful
    of playbooks, task files, and variable files is highly desired. Creating such
    a hierarchy can be daunting and may explain why many Ansible implementations start
    off simple and only become more organized once the scattered files become unwieldy
    and a hassle to maintain. Making the migration can be difficult and may require
    rewriting significant portions of playbooks, which can further delay reorganization
    efforts.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover best practices for composable, reusable, and
    well-organized content within Ansible. The lessons learned in this chapter will
    help developers design Ansible content that grows well with the project, avoiding
    the need for difficult redesign work later. The following is an outline of what
    we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Task, handler, variable, and playbook inclusion concepts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Roles (structures, defaults, and dependencies)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing top-level playbooks to utilize roles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sharing roles across projects (dependencies via Galaxy; Git-like repositories)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To follow the examples presented in this chapter, you will need a Linux machine
    running **Ansible 4.3** or newer. Almost any flavor of Linux should do—for those
    interested in specifics, all the code presented in this chapter was tested on
    **Ubuntu Server 20.04 Long-Term Support** (**LTS**) unless stated otherwise, and
    on Ansible 4.3\.
  prefs: []
  type: TYPE_NORMAL
- en: 'The example code that accompanies this chapter can be downloaded from GitHub
    at this link: [https://github.com/PacktPublishing/Mastering-Ansible-Fourth-Edition/tree/main/Chapter08](https://github.com/PacktPublishing/Mastering-Ansible-Fourth-Edition/tree/main/Chapter08).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the Code in Action: [https://bit.ly/3E0mmIX](https://bit.ly/3E0mmIX).'
  prefs: []
  type: TYPE_NORMAL
- en: Task, handler, variable, and playbook inclusion concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first step to understanding how to efficiently organize an Ansible project
    structure is to master the concept of including files. The act of including files
    allows content to be defined in a topic-specific file that can be included in
    other files one or more times within a project. This inclusion feature supports the
    concept of **Don't Repeat Yourself** (**DRY**).
  prefs: []
  type: TYPE_NORMAL
- en: Including tasks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Task files are **YAML Ain't Markup Language** (**YAML**) files that define one
    or more tasks. These tasks are not directly tied to any particular play or playbook;
    they exist purely as a list of tasks. These files can be referenced by **playbooks**
    or other task files by way of the `include` operator. Now, you might expect the
    `include` operator to be a keyword of Ansible in its own right—however, this is
    not the case; it is actually a module just like `ansible.builtin.debug`. For conciseness,
    we will refer to it in this chapter as the `include` operator, but when we say
    this, your code will actually contain the **Fully Qualified Collection Name**
    (**FQCN**—see [*Chapter 2*](B17462_02_Final_JC_ePub.xhtml#_idTextAnchor047), *Migrating
    from Earlier Ansible Versions*), which is `ansible.builtin.include`. You'll see
    this in action very shortly, so don't worry—this will all make sense soon! This
    operator takes a path to a task file, and as we learned in [*Chapter 1*](B17462_01_Final_JC_ePub.xhtml#_idTextAnchor015), *The System
    Architecture and Design of Ansible*, the path can be relative to the file referencing
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate how to use the `include` operator to include tasks, let''s create
    a simple play that includes a task file with some debug tasks within it. First,
    let''s write our playbook file, which we''ll call `includer.yaml`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''ll create a `more-tasks.yaml` file you can see referenced in the
    `include` statement. This should be created in the same directory that holds `includer.yaml`.
    The code is illustrated in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can execute our playbook with the following command to observe the
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If all goes well, you should see output similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1 – Executing an Ansible playbook that includes a separate task
    file'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_08_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.1 – Executing an Ansible playbook that includes a separate task file
  prefs: []
  type: TYPE_NORMAL
- en: 'We can clearly see our tasks from the `include` file execution. Because the `include` operator
    was used within the play''s `tasks` section, the included tasks were executed
    within that play. In fact, if we were to add a task to the play after the `include` operator,
    as illustrated in the following code snippet, we would see that the order of execution
    follows as if all the tasks from the included file existed at the spot the `include` operator
    was used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run our modified playbook using the same command as before, we will see
    the task order we expect, as the following screenshot demonstrates:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2 – Demonstrating the order of task execution in a playbook that
    uses the include operator'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_08_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.2 – Demonstrating the order of task execution in a playbook that uses
    the include operator
  prefs: []
  type: TYPE_NORMAL
- en: By breaking these tasks into their own file, we could include them multiple
    times or in multiple playbooks. If we ever have to alter one of the tasks, we only have
    to alter a single file, no matter how many places this file gets referenced.
  prefs: []
  type: TYPE_NORMAL
- en: Passing variable values to included tasks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes, we want to split out a set of tasks but have those tasks act slightly differently
    depending on the variable data. The `include` operator allows us to define and
    override variable data at the time of inclusion. The scope of the definition is
    only within the included task file (and any other files that file may itself include).
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate this capability, let''s create a new scenario in which we need
    to touch a couple of files, each in their own directory path. Instead of writing
    two file tasks for each file (one to create a directory and another to touch the
    file), we''ll create a task file with each task that will use variable names in
    the tasks. Then, we''ll include the task file twice, each time passing different
    data in. First, we''ll do this with the `files.yaml` task file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''ll modify our `includer.yaml` playbook to include the task file we''ve
    just created, passing along variable data for the `path` and `file` variables,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Variable definitions provided when including files can either be in the inline
    format of `key=value` or in the illustrated YAML format of `key: value` inside
    a `vars` hash.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When we run this playbook, we''ll see four tasks get executed: the two tasks
    from within the included `files.yaml` file twice. The second set should result
    in only one change as the path is the same for both sets, and should be created
    the first time the task is executed. Run the playbook with added verbosity so
    that we can see a little more about what''s going on under the hood, by using
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The output from running this playbook should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.3 – Running a playbook where a task file is included twice with
    different variable data'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_08_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.3 – Running a playbook where a task file is included twice with different
    variable data
  prefs: []
  type: TYPE_NORMAL
- en: As can be seen here, the code to create a leading path and a file is being reused,
    just with different values each time, making our code really efficient to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: Passing complex data to included tasks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When wanting to pass complex data to included tasks, such as a list or hash,
    an alternative syntax can be used when including the file. Let''s repeat the previous
    scenario, only this time instead of including the task file twice, we''ll include
    it once and pass a hash of the paths and files in. First, we''ll recreate the `files.yaml` file,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we''ll alter our `includer.yaml` playbook to provide the file''s hash
    in a single `ansible.builtin.include` statement, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run this new playbook and task file as before, we should see a similar
    but slightly different output, the end result of which is the `/tmp/foo` directory
    already in place and the two `herp` and `derp` files being created as empty files
    (touched) within, as the following screenshot shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.4 – Passing complex data to an included task file in an Ansible
    play'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_08_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.4 – Passing complex data to an included task file in an Ansible play
  prefs: []
  type: TYPE_NORMAL
- en: Using this manner of passing in a hash of data allows the growth of a set of
    things created without having to grow the number of `include` statements in the
    main playbook.
  prefs: []
  type: TYPE_NORMAL
- en: Conditional task includes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Similar to passing data into included files, conditionals can also be passed
    into included files. This is accomplished by attaching a `when` statement to the `include` operator.
    This conditional does not cause Ansible to evaluate the test to determine whether
    the file should be included; rather, it instructs Ansible to add the conditional
    to each and every task within the included file (and any other files the said
    file may include).
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: It is not possible to conditionally include a file. Files will always be included;
    however, a task condition can be applied to every task within.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s demonstrate this by modifying our first example that includes simple
    debug statements. We''ll add a conditional and pass along some data for the conditional
    to use. First, let''s modify the `includer.yaml` playbook, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s modify `more-tasks.yaml` to loop over the `a_list` variable in
    each task, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s run the playbook with the same command as before and see our new
    output, which should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.5 – Applying conditionals to all tasks in an included file'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_08_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.5 – Applying conditionals to all tasks in an included file
  prefs: []
  type: TYPE_NORMAL
- en: We can see a skipped iteration per task, the iteration where `item` was evaluated
    to a `false` Boolean. It's important to remember that all hosts will evaluate
    all included tasks. There is no way to influence Ansible to not include a file
    for a subset of hosts. At most, a conditional can be applied to every task within
    an `include` hierarchy so that included tasks may be skipped. One method to include
    tasks based on host facts is to utilize the `ansible.builtin.group_by` action
    plugin to create dynamic groups based on host facts. Then, you can give the groups
    their own plays to include specific tasks. This is an exercise left up to you.
  prefs: []
  type: TYPE_NORMAL
- en: Tagging included tasks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When including task files, it is possible to tag all tasks within the file.
    The `tags` key is used to define one or more tags to apply to all tasks within
    the `include` hierarchy. The ability to tag at `include` time can keep the task
    file itself unopinionated about how the tasks should be tagged and can allow for
    a set of tasks to be included multiple times but with different data and tags
    passed along.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: Tags can be defined at the `include` statement or at the play itself to cover
    all includes (and other tasks) in a given play.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a simple demonstration to illustrate how tags can be used. We''ll
    start by editing our `includer.yaml` file to create a playbook that includes a
    task file twice, each with a different tag name and different variable data. The
    code is illustrated in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we''ll update `more-tasks.yaml` to do something with the data being provided,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run this playbook without selecting tags, we''ll see this task run twice,
    as the following screenshot shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.6 – Running a playbook with tagged include tasks, but without any
    tag-based filtering enabled'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_08_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.6 – Running a playbook with tagged include tasks, but without any tag-based
    filtering enabled
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can select which tag to run—say, the second tag—by altering our `ansible-playbook` arguments,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In this instance, we should see only that occurrence of the included task being
    run, as the following screenshot shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.7 – Running a playbook with tagged include tasks, only running tasks
    tagged "second"'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_08_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.7 – Running a playbook with tagged include tasks, only running tasks
    tagged "second"
  prefs: []
  type: TYPE_NORMAL
- en: Our example used the `--tags` command-line argument to indicate which tagged
    tasks to run. A different argument, `--skip-tags`, allows expressing the opposite—or
    in other words, which tagged tasks not to run.
  prefs: []
  type: TYPE_NORMAL
- en: Task inclusions with loops
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Task inclusions can be combined with loops as well. When adding a `loop` instance
    to a task inclusion (or a `with_` loop if using a version of Ansible earlier than
    2.5), the tasks inside the file will be executed with the `item` variable, which
    holds the place of the current loop''s value. The entire `include` file will be
    executed repeatedly until the loop runs out of items. Let''s update our example
    play to demonstrate this, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to update our `more-tasks.yaml` file to make use of the loop `item`
    variable, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'When executed with increased verbosity, we can tell that tasks `1` and `2` are
    executed a single time for each `item` variable in the loop, as the following
    screenshot shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.8 – Running an included task file in a loop'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_08_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.8 – Running an included task file in a loop
  prefs: []
  type: TYPE_NORMAL
- en: 'Looping on **inclusion** is a powerful concept, but it does introduce one problem.
    What if there were tasks inside the included file that have their own loops? There
    will be a collision of the `item` variable, creating unexpected outcomes. For
    this reason, the `loop_control` feature was added to Ansible in version 2.1\.
    Among other things, this feature provides a method to name the variable used for the loop,
    instead of the default of `item`. Using this, we can distinguish between the `item` instance
    that comes outside the inclusion from any `item` variables used inside the `include`
    statement. To demonstrate this, we''ll add a `loop_var` loop control to our outer `include`
    statement, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside `more-tasks.yaml`, we''ll have a task with its own loop, making use
    of `include_item` and the local `item` variable, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'When executed, we see that `task 1` is executed twice per inclusion loop and
    that the two `loop` variables are used, as the following screenshot shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.9 – Running a nested loop within an included task file, avoiding
    loop variable name collision'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_08_09.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.9 – Running a nested loop within an included task file, avoiding loop
    variable name collision
  prefs: []
  type: TYPE_NORMAL
- en: Other loop controls exist as well, such as `label`, which will define what is
    shown on the screen in the task output for the `item` value (useful for preventing large data
    structures from cluttering the screen), and `pause`, providing the ability to
    pause for a defined number of seconds between each loop.
  prefs: []
  type: TYPE_NORMAL
- en: Including handlers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Handlers** are essentially tasks. They''re a set of potential tasks triggered
    by way of notifications from other tasks. As such, handler tasks can be included
    just as regular tasks can. The `include` operator is legal within the `handlers` block.'
  prefs: []
  type: TYPE_NORMAL
- en: Unlike with task inclusions, variable data cannot be passed along when including
    `handler` tasks. However, it is possible to attach a conditional to a `handler`
    inclusion, to apply the conditional to every `handler` task within the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create an example to demonstrate this. First, we''ll create a playbook
    that has a task that will always change, and that includes a `handler` task file
    and attaches a conditional to that inclusion. The code is illustrated in the following
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: When evaluating a variable that may be defined outside a playbook, it's best
    to use the `bool` filter to ensure that strings are properly converted to their
    Boolean meaning.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we''ll create a `handlers.yaml` file to define our `handler` task, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'If we execute this playbook without providing any further data, we should see
    our `handler` task trigger, as the following screenshot shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.10 – Using the include operator to run a handler from a task file'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_08_10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.10 – Using the include operator to run a handler from a task file
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s run the playbook again; this time, we''ll define `foo` as `extra-var` (overriding
    every other instance of it) and set it to `false` in our `ansible-playbook` execution
    arguments, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, the output will look somewhat different, as the following screenshot
    shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.11 – Running the same play but this time forcing the foo conditional
    variable to false'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_08_11.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.11 – Running the same play but this time forcing the foo conditional
    variable to false
  prefs: []
  type: TYPE_NORMAL
- en: As `foo` evaluates to `false`, our included handler gets skipped in this run
    of the playbook.
  prefs: []
  type: TYPE_NORMAL
- en: Including variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Variable** data can also be separated into loadable files. This allows for
    the sharing of variables across multiple plays or playbooks or the inclusion of
    variable data that lives outside the project directory (such as secret data).
    Variable files are simple **YAML-formatted** files providing keys and values.
    Unlike task inclusion files, variable inclusion files cannot include more files.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Variables can be included in three different ways: via `vars_files`, via `include_vars`,
    or via `--extra-vars` (`-e`).'
  prefs: []
  type: TYPE_NORMAL
- en: vars_files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `vars_files` key is a play directive. It defines a list of files to read
    from to load variable data. These files are read and parsed at the time the playbook
    itself is parsed. Just as with including tasks and handlers, the path is relative
    to the file referencing the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example play that loads variables from a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to create a `variables.yaml` file in the same directory as our
    playbook, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the playbook with our usual command will show that the `varname` variable
    value is properly sourced from the `variables.yaml` file, as the following screenshot
    shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.12 – Including variables in a play using the vars_files directive'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_08_12.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.12 – Including variables in a play using the vars_files directive
  prefs: []
  type: TYPE_NORMAL
- en: This is, of course, a very simple example, but it clearly demonstrates the ease
    of importing variables from a separate file.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic vars_files inclusion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In certain scenarios, it may be desirable to parameterize the variable files
    to be loaded. It is possible to do this by using a variable as part of the filename;
    however, the variable must have a value defined at the time the playbook is parsed,
    just as when using variables in task names. Let''s update our example play to
    load a variable file based on the data provided at execution time, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when we execute the playbook, we''ll provide the value for `varfile` with
    the `-e` argument, using a command like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.13 – Dynamically loading a variables.yaml file at playbook runtime'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_08_13.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.13 – Dynamically loading a variables.yaml file at playbook runtime
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the variable value needing to be defined at execution time, the
    file to be loaded must also exist at execution time. This rule applies even if
    the file is generated by the Ansible playbook itself. Let's suppose that an Ansible
    playbook consists of four plays. The first play generates a YAML variable file.
    Then, further down, the fourth play references this file in a `vars_file` directive.
    Although it might initially appear as though this would work, the file does not
    exist at the point of execution (that is, when `ansible-playbook` is first run),
    and hence an error will be reported.
  prefs: []
  type: TYPE_NORMAL
- en: include_vars
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A second method to include variable data from files is via the `include_vars` module.
    This module will load variables as a `task` action and will be done for each host.
    Unlike most modules, this module is executed locally on the Ansible host; therefore,
    all paths are still relative to the play file itself. Because the variable loading
    is done as a task, the evaluation of variables in the filename happens when the
    task is executed. Variable data in the filename can be host-specific and defined
    in a preceding task. Additionally, the file itself does not have to exist at execution
    time; it can be generated by a preceding task as well. This is a very powerful
    and flexible concept that can lead to very dynamic playbooks if used properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before getting ahead of ourselves, let''s demonstrate simple usage of `include_vars` by
    modifying our existing play to load the variable file as a task, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Execution of the playbook remains the same as in the previous example, where
    we specified the value for the `varfile` variable as an extra variable. Our output
    differs only slightly from previous iterations, as the following screenshot shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.14 – Running a playbook utilizing the include_vars statement'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_08_14.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.14 – Running a playbook utilizing the include_vars statement
  prefs: []
  type: TYPE_NORMAL
- en: Just as with other tasks, looping can be done to load more than one file in
    a single task. This is particularly effective when using the special `with_first_found` loop
    to iterate through a list of increasingly more generic filenames until a file
    is found to be loaded.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s demonstrate this by changing our play to use gathered host facts to
    try to load a variable file specific to the distribution, specific to the distribution
    family, or, finally, a default file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The execution should look very similar to previous runs, only this time we''ll
    see a fact-gathering task, and we will not pass along extra variable data in the
    execution. The output should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.15 – Dynamically including the first valid variables file found
    in an Ansible play'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_08_15.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.15 – Dynamically including the first valid variables file found in
    an Ansible play
  prefs: []
  type: TYPE_NORMAL
- en: We can also see from the output which file was found to load. In this case, `variables.yaml` was
    loaded, as the other two files did not exist. This practice is commonly used to
    load variables that are operating system-specific to the host in question. Variables
    for a variety of operating systems can be written out to appropriately named files.
    By utilizing the `ansible_distribution` variable, which is populated by fact-gathering,
    variable files that use `ansible_distribution` values as part of their name can
    be loaded by way of a `with_first_found` argument. A default set of variables
    can be provided in a file that does not use any variable data as a failsafe, as
    we did here in our `variables.yaml` file.
  prefs: []
  type: TYPE_NORMAL
- en: extra-vars
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The final method to load variable data from a file is to reference a file path
    with the `--extra-vars` (or `-e`) argument to `ansible-playbook`. Normally, this
    argument expects a set of `key=value` data; however, if a file path is provided
    and prefixed with the `@` symbol, Ansible will read the entire file to load variable
    data. Let''s alter one of our earlier examples, where we used `-e`, and instead
    of defining a variable directly on the command line, we''ll include the variable
    file we''ve already written out, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'When we provide a path after the `@` symbol, the path is relative to the current
    working directory, regardless of where the playbook itself lives. Let''s execute
    our playbook and provide a path to `variables.yaml`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.16 – Including a variables.yaml file through the extra variables
    command-line parameter'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_08_16.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.16 – Including a variables.yaml file through the extra variables command-line
    parameter
  prefs: []
  type: TYPE_NORMAL
- en: Here, we can see that once again our `variables.yaml` file was included successfully,
    but, as you can see from the previous code, it is not even mentioned in the playbook
    itself—we were able to load it in its entirety through the `-e` flag.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: When including a variable file with the `--extra-vars` argument, the file must
    exist at `ansible-playbook` execution time.
  prefs: []
  type: TYPE_NORMAL
- en: Variable inclusion is incredibly powerful in Ansible—but what about playbooks
    themselves? Here, things are a bit different, and as the chapter progresses, we
    will look at how to make effective use of reusable tasks and playbook code, thus
    encouraging good programming practices with Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: Including playbooks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Playbook files can include other whole playbook files. This construct can be
    useful to tie together a few independent playbooks into a larger, more comprehensive
    playbook. Playbook inclusion is a bit more primitive than task inclusion. You
    cannot perform variable substitution when including a playbook, you cannot apply
    conditionals, and you cannot apply tags, either. The playbook files to be included
    must exist at the time of execution as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Prior to Ansible 2.4, playbook inclusion was achieved using the `include` keyword—however,
    this was removed in Ansible 2.8, and so it should not be used. Instead, you should
    now use `ansible.builtin.import_playbook`. This is a play-level directive—it cannot
    be used as a task. However, it is very easy to use. Let''s define a simple example
    to demonstrate this. First, let''s create a playbook that will be included, called `includeme.yaml`.
    Here''s the code to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'As you will no doubt recognize by now, this is a complete standalone playbook
    and we could run it in isolation using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'A successful run will produce output like that shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.17 – Running our playbook to be included first as a standalone playbook'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_08_17.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.17 – Running our playbook to be included first as a standalone playbook
  prefs: []
  type: TYPE_NORMAL
- en: 'However, we can also import this into another playbook. Modify the original
    `includer.yaml` playbook so that it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We then run it using this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that both debug messages are displayed, and the imported playbook
    is run after the initial task, which is the sequence we defined in the original
    playbook. The following screenshot shows this in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.18 – Running a playbook that includes a second playbook'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_08_18.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.18 – Running a playbook that includes a second playbook
  prefs: []
  type: TYPE_NORMAL
- en: In this way, it is very easy to reuse whole playbooks without needing to restructure
    them into the format of roles, task files, or otherwise. Note, however, that this
    feature is subject to active development in Ansible, so it is recommended that
    you always refer to the documentation to ensure you can achieve the results you
    are looking for.
  prefs: []
  type: TYPE_NORMAL
- en: Roles (structures, defaults, and dependencies)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With a functional understanding of the inclusion of variables, tasks, handlers,
    and playbooks, we can move on to the more advanced topic of **roles**. Roles bring
    together these different facets of Ansible code creation to provide a fully independent
    collection of variables, tasks, files, templates, and modules that can be reused
    over again in different playbooks. Although not limited as such by design, it
    is normal practice for each role to be typically limited to a particular purpose
    or desired end result, with all the necessary steps to reach that result either
    within the role itself or through dependencies (in other words, further roles
    that themselves are specified as dependencies of a role). It is important to note
    that roles are not playbooks, and there is no way to directly execute a role.
    Roles have no settings for which host(s) the role will apply to. Top-level playbooks
    are the glue that binds the hosts from your inventory to roles that should be
    applied to those hosts. As we saw in [*Chapter 2*](B17462_02_Final_JC_ePub.xhtml#_idTextAnchor047),
    *Migrating from Earlier Ansible Versions*, roles can also be part of Ansible collections.
    As we have already looked at the structure of collections in this earlier chapter,
    in this section we will focus in greater depth on how to construct the roles themselves.
  prefs: []
  type: TYPE_NORMAL
- en: Role structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Roles** have a structured layout on the **filesystem**. This structure exists
    to provide automation around including tasks, handlers, variables, modules, and
    role dependencies. The structure also allows for the easy reference of files and
    templates from anywhere within the role.'
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 2*](B17462_02_Final_JC_ePub.xhtml#_idTextAnchor047), *Migrating
    from Earlier Ansible Versions*, we look at how to reference roles from collections.
    They do not have to be used as part of a collection, however, and assuming you
    are working with roles outside of this context, they all live in a subdirectory
    of a playbook directory structure below the `roles/` directory. This is, of course,
    configurable by way of the `roles_path` general configuration key, but let's stick
    to the defaults. Each role is itself a directory tree. The role name is the directory
    name within `roles/`. Each role can have a number of subdirectories with special
    meanings that are processed when a role is applied to a set of hosts.
  prefs: []
  type: TYPE_NORMAL
- en: A role may contain all these elements or as few as just one of them. Missing
    elements are simply ignored. Some roles exist just to provide common handlers
    across a project. Other roles exist as a single dependency point that in turn
    just depends on numerous other roles.
  prefs: []
  type: TYPE_NORMAL
- en: Tasks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The task file is the core part of a role, and if `roles/<role_name>/tasks/main.yaml` exists,
    then all the tasks within this file (and indeed any other files it includes) will
    be loaded in the play and executed.
  prefs: []
  type: TYPE_NORMAL
- en: Handlers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Similar to tasks, handlers are automatically loaded from `roles/<role_name>/handlers/main.yaml`,
    if the file exists. These handlers can be referenced by any task within the role,
    or by any tasks within any other role that lists this role as a dependency.
  prefs: []
  type: TYPE_NORMAL
- en: Variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are two types of variables that can be defined in a role. There are role
    variables, loaded from `roles/<role_name>/vars/main.yaml`, and there are role
    defaults, loaded from `roles/<role_name>/defaults/main.yaml`. The difference between
    `vars` and `defaults` has to do with precedence order. Refer to [*Chapter 1*](B17462_01_Final_JC_ePub.xhtml#_idTextAnchor015), *The System
    Architecture and Design of Ansible,* for a detailed description of the order.
    **Role defaults** are the lowest-order variables. Literally any other definition
    of a variable will take precedence over a role default. Role defaults can be thought
    of as placeholders for actual data, a reference of which variables a developer
    may be interested in defining with site-specific values. **Role variables**, on
    the other hand, have a higher order of precedence. Role variables can be overridden,
    but they are generally used when the same dataset is referenced more than once
    within a role. If the dataset is to be redefined with site-local values, then
    the variable should be listed in the role defaults rather than the role variables.
  prefs: []
  type: TYPE_NORMAL
- en: Modules and plugins
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A role can include custom modules as well as plugins. While we are in the transitionary
    phase to Ansible 4.0 and beyond, this is still supported, but you will no doubt
    have noticed that collections can also include custom **modules** and **plugins**.
    At the current time, where you place your modules and plugins will depend upon
    the target version of Ansible you are writing your role for. If you wish to maintain
    backward compatibility with the 2.x releases, then you should place modules and
    plugins into your role directory structure, as described here. If you only want
    compatibility with Ansible releases 3.0 and later, you could consider placing
    them in a collection instead. Note, however, that with the move to collections,
    your plugins and modules are less likely to be accepted into the `ansible-core`
    package, unless they provide what is considered core functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Modules (if present in a role) are loaded from `roles/<role_name>/library/` and
    can be utilized by any task in the role, or indeed by any later role in the play.
    It is important to note that modules provided in this path will override any other
    copies of the same module name, and once again it is important to reference modules
    using FQCNs wherever possible to avoid any unexpected results.
  prefs: []
  type: TYPE_NORMAL
- en: 'Plugins will automatically be loaded if found inside of a role, in one of the
    following subdirectories:'
  prefs: []
  type: TYPE_NORMAL
- en: '`action_plugins`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lookup_plugins`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`callback_plugins`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`connection_plugins`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`filter_plugins`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`strategy_plugins`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cache_plugins`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`test_plugins`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`shell_plugins`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependencies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Roles can express a **dependency** upon another role. It is a common practice
    for sets of roles to all depend on a common role for tasks, handlers, modules,
    and so on. Those roles may depend upon only having to be defined once. When Ansible
    processes a role for a set of hosts, it first looks for dependencies listed in `roles/<role_name>/meta/main.yaml`.
    Should any be defined, then those roles will be processed immediately and the
    tasks contained in those roles will be executed (after checking for any dependencies
    also listed within them). This process carries on until all dependencies have
    been established and loaded (and tasks executed where present) before Ansible
    results to starting on the initial role tasks. Remember—dependencies are always
    executed before the role itself. We will describe role dependencies in more depth
    later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Files and templates
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Task and handler modules can reference files using only relative paths within
    `roles/<role_name>/files/`. The filename can be provided without any prefix (although
    this is allowed if you wish) and will be sourced from `roles/<role_name>/files/<relative_directory>/<file_name>`.
    Modules such as `ansible.builtin.template`, `ansible.builtin.copy`, and `ansible.builtin.script`
    are three typical ones that you will see many examples of, taking advantage of
    this useful feature.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, templates used by the `ansible.builtin.template` module can be referenced
    relatively within `roles/<role_name>/templates/`. The following code sample uses
    a relative path to load the `derp.j2` template from the full `roles/<role_name>/templates/herp/derp.j2` path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In this way, it is easy to organize files within the standard role directory
    structure and still access them easily from within the role without having to
    type in long and complex paths. Later in this chapter, we'll introduce you to
    the `ansible-galaxy role init` command, which will help you build skeleton directory
    structures for new roles with even greater ease—see the *Role sharing* section
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: Putting it all together
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To illustrate what a full role structure might look like, here is an example
    role by the name of `demo`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: When creating a role, not every directory or file is required. Only files that
    exist will be processed. Thus, our example of a role does not require or use handlers;
    the entire `handlers` part of the tree could simply be left out.
  prefs: []
  type: TYPE_NORMAL
- en: Role dependencies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As stated before, roles can depend on other roles. These relationships are
    called dependencies and they are described in a role''s `meta/main.yaml` file.
    This file expects a top-level data hash with a key of `dependencies`; the data
    within is a list of roles. You can see an illustration of this in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: In this example, Ansible will fully process the `common` role first (and any
    dependencies it may express) before continuing with the `apache` role and then
    finally starting on the role's tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Dependencies can be referenced by name without any prefix if they exist within
    the same directory structure or live within the configured `roles_path` configuration
    key. Otherwise, full paths can be used to locate roles, as illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: When expressing a dependency, it is possible to pass along data to the dependency.
    The data can be variables, tags, or even conditionals.
  prefs: []
  type: TYPE_NORMAL
- en: Role dependency variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Variables that are passed along when listing a dependency will override values
    for matching variables defined in `defaults/main.yaml` or `vars/main.yaml`. This
    can be useful for using a common role, such as an `apache` role, as a dependency
    while providing site-specific data, such as which ports to open in the firewall
    or which `apache` modules to enable. Variables are expressed as additional keys
    to the role listing. Thus, continuing our hypothetical example, consider that
    we need to pass some variables to both the `common` and `apache` role dependencies
    we discussed, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: When providing dependency variable data, two names are reserved and should not
    be used as role variables: `tags` and `when`. The former is used to pass tag data
    into a role, and the latter is used to pass a conditional into a role.
  prefs: []
  type: TYPE_NORMAL
- en: Tags
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Tags can be applied to all the tasks found within a dependency role. This functions
    much in the same way as tags being applied to included task files, as described
    earlier in this chapter. The syntax is simple: the `tags` key can be a single
    item or a list. To demonstrate, let''s further expand our theoretical example
    by adding some tags, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: As with adding tags to the included task files, all the tasks found within a
    dependency (and any dependency within that hierarchy) will gain the provided tags.
  prefs: []
  type: TYPE_NORMAL
- en: Role dependency conditionals
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'While it is not possible to prevent the processing of a dependency role with
    a conditional, it is possible to skip all the tasks within a dependency role hierarchy
    by applying a conditional to a dependency. This mirrors the functionality of task
    inclusion with conditionals as well. The `when` key is used to express the conditional.
    Once again, we''ll grow our example by adding a dependency to demonstrate the
    syntax, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `apache` role will always be processed, but tasks within
    the role will only run when the `backend_server` variable contains the `apache` string.
  prefs: []
  type: TYPE_NORMAL
- en: Role application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Roles are not plays. They do not possess any opinions about which hosts the
    role tasks should run on, which connection methods to use, whether to operate
    serially, or any other play behaviors described in [*Chapter 1*](B17462_01_Final_JC_ePub.xhtml#_idTextAnchor015), *The System
    Architecture and Design of Ansible*. Roles must be applied inside a play within
    a playbook, where all these opinions can be expressed.
  prefs: []
  type: TYPE_NORMAL
- en: To apply a role within a play, the `roles` operator is used. This operator expects
    a list of roles to apply to the hosts in the play. Much like describing role dependencies,
    when describing roles to apply, data can be passed along, such as variables, tags,
    and conditionals. The syntax is exactly the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate applying roles within a play, let''s create a simple role and
    apply it to a simple playbook. First, let''s build a role named `simple`, which
    will have a single `debug` task in `roles/simple/tasks/main.yaml` that prints
    the value of a role default variable defined in `roles/simple/defaults/main.yaml`.
    First, let''s create a task file (in the `tasks/` subdirectory), as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''ll write our default file with a single variable, `derp`, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'To execute this role, we''ll write a playbook with a single play to apply the
    role. We''ll call our playbook `roleplay.yaml`, and it''ll live at the same directory
    level as the `roles/` directory. The code is illustrated in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: If no data is provided with the role, an alternative syntax that just lists
    the roles to apply can be used, instead of the hash. However, for consistency,
    I feel it's best to always use the same syntax within a project.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll reuse our `mastery-hosts` inventory from earlier chapters and execute
    the playbook in the normal manner (we don''t need any added verbosity here), by
    running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.19 – Running our simple role from a playbook using the default role
    variable data'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_08_19.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.19 – Running our simple role from a playbook using the default role
    variable data
  prefs: []
  type: TYPE_NORMAL
- en: 'Thanks to the magic of roles, the `derp` variable value was automatically loaded
    from the role defaults. Of course, we can override the default value when applying
    the role. Let''s modify our playbook and supply a new value for `derp`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, when we execute (using the same command as used previously), we''ll
    see `newval` as the value for `derp`, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.20 – Running the same role but this time overriding the default
    variable data at the play level'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_08_20.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.20 – Running the same role but this time overriding the default variable
    data at the play level
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiple roles can be applied within a single play. The `roles:` key expects
    a list value. Just add more roles to apply more roles, as shown here (this next
    example is theoretical and is left as an exercise for you):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: This playbook will load a total of four roles—`simple`, `second_role`, `third_role`,
    and `another_role`—and each will be executed in the sequence in which they are
    listed.
  prefs: []
  type: TYPE_NORMAL
- en: Mixing roles and tasks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Plays that use roles are not limited to just roles. These plays can have tasks of
    their own, as well as two other blocks of tasks: `pre_tasks` and `post_tasks`
    blocks. In a break to the task execution order we have looked at throughout this
    book, the order in which these tasks are executed is not dependent upon which
    order these sections are listed in the play itself; instead, there is a strict
    order to block execution within a play. See [*Chapter 1*](B17462_01_Final_JC_ePub.xhtml#_idTextAnchor015), *The System
    Architecture and Design of Ansible,* for details on the playbook order of operations.
  prefs: []
  type: TYPE_NORMAL
- en: '**Handlers** for a play are flushed at multiple points. If there is a `pre_tasks` block,
    handlers are flushed after all `pre_tasks` blocks are executed. Then, the roles and tasks blocks
    are executed (roles first, then tasks, regardless of the order they are written
    in the playbook), after which the handlers will be flushed again. Finally, if
    a `post_tasks` block exists, the handlers will be flushed once again after all
    `post_tasks` blocks have executed. Of course, handlers can be flushed at any time
    with the `meta: flush_handlers` call. Let''s expand on our `roleplay.yaml` file
    to demonstrate all the different times at which handlers can be triggered, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll also modify our simple role''s tasks to notify the `say hi` handler
    as well, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: This only works because the `say hi` handler has been defined in the play that
    is calling the `simple` role. If the handler is not defined, an error will occur.
    It's best practice to only notify handlers that exist within the same role or
    any role marked as a dependency.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running our playbook again using the same command as in the previous examples
    should result in the `say hi` handler being called a total of three times: once
    for `pre_tasks` blocks, once for roles and tasks, and once for `post_tasks` blocks,
    as the following screenshot demonstrates:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.21 – Running a playbook to demonstrate mixing roles and tasks, and
    handler execution'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_08_21.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.21 – Running a playbook to demonstrate mixing roles and tasks, and
    handler execution
  prefs: []
  type: TYPE_NORMAL
- en: While the order in which `pre_tasks`, `roles`, `tasks`, and `post_tasks` blocks
    are written into a play does not impact the order in which those sections are
    executed, it's best practice to write them in the order in which they will be
    executed. This is a visual cue to help remember the order and to avoid confusion
    when reading the playbook later.
  prefs: []
  type: TYPE_NORMAL
- en: Role includes and imports
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With Ansible version 2.2, a new `ansible.builtin.include_role` action plugin
    was made available as a technical preview. Then, in **Ansible version 2.4**, this
    concept was further developed by the addition of the `ansible.builtin.import_role` plugin.
    We will refer to these plugins without their FQCNs for conciseness.
  prefs: []
  type: TYPE_NORMAL
- en: These plugins are used in a task to include and execute an entire role directly
    from a task. The difference between the two is subtle but important—the `include_role` plugin
    is considered dynamic, meaning the code is processed during runtime when the task
    referencing it is encountered.
  prefs: []
  type: TYPE_NORMAL
- en: The `import_role` plugin, on the other hand, is considered static, meaning all
    imports are preprocessed at the time the playbook is initially parsed. This has
    various impacts on their use in playbooks—for example, `import_role` cannot be
    used in loops, while `include_role` can.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: Full details of the trade-offs between importing and including can be found
    in the official Ansible documentation here: [https://docs.ansible.com/ansible/latest/user_guide/playbooks_reuse.html](https://docs.ansible.com/ansible/latest/user_guide/playbooks_reuse.html).
  prefs: []
  type: TYPE_NORMAL
- en: In the previous edition of this book, these plugins were considered a technical
    preview—however, they are now part of the `ansible.builtin` collection and so
    can now be considered stable and used for your code as you see fit.
  prefs: []
  type: TYPE_NORMAL
- en: Role sharing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the advantages of using roles is the ability to share a role across plays,
    playbooks, entire project spaces, and even across organizations. Roles are designed
    to be self-contained (or to clearly reference dependent roles) so that they can
    exist outside of a project space where the playbook that applies the role lives.
    Roles can be installed in shared paths on an Ansible host, or they can be distributed
    via source control.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible Galaxy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Ansible Galaxy** ([https://galaxy.ansible.com/](https://galaxy.ansible.com/)),
    as we discussed in [*Chapter 2*](B17462_02_Final_JC_ePub.xhtml#_idTextAnchor047),
    *Migrating from Earlier Ansible Versions*, is a community hub for finding and
    sharing Ansible roles and collections. Anybody can visit the website to browse
    these and reviews; plus, users who create a login can provide reviews of the roles
    they''ve tested. Roles from Galaxy can be downloaded using the `ansible-galaxy` utility
    provided with Ansible.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ansible-galaxy` utility can connect to and install roles from the Ansible
    Galaxy website. This utility will default to installing roles into `/etc/ansible/roles`.
    If `roles_path` is configured or if a runtime path is provided with the `--roles-path`
    (or `-p`) option, the roles will be installed there instead. If any roles have
    been installed to the `roles_path` option or the provided path, `ansible-galaxy`
    can list those and show information about those as well. To demonstrate the usage
    of `ansible-galaxy`, let''s use it to install a role for installing and managing
    Docker on Ubuntu from Ansible Galaxy into the `roles` directory we''ve been working
    with. Installing roles from Ansible Galaxy requires `username.rolename`, as multiple
    users may have uploaded roles with the same name. To work through an example,
    we will use the `docker_ubuntu` role from the `angstwad` user, as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.22 – Locating an example community-contributed role on Ansible Galaxy'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_08_22.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.22 – Locating an example community-contributed role on Ansible Galaxy
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now make use of this role by referencing `angstwad.docker_ubuntu` in
    a play or another role''s dependencies block. However, let''s get started by demonstrating
    how we can install this in our current working directory. We''ll first off create
    a `roles/` directory, and then install the aforementioned role into this directory
    with the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we''ve installed our example role, we can query it (and any other roles
    that might exist in the `roles/` directory) using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also query information about the role such as the description, creator,
    version, and so on locally using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot gives an idea of the kind of output you can expect
    from the two preceding commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.23 – Querying installed roles with the ansible-galaxy command'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_08_23.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.23 – Querying installed roles with the ansible-galaxy command
  prefs: []
  type: TYPE_NORMAL
- en: 'The output has been truncated to save space in the book, and there is much
    more useful information if you scroll through the output. Some of the data being
    displayed by the `info` command lives within the role itself, in the `meta/main.yml` file.
    Previously, we''ve only seen dependency information in this file, and it may not
    have made much sense to name the directory `meta`, but now we see that other metadata
    lives in this file as well, as the following screenshot shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.24 – An example of the metadata that can be placed in the meta/main.yml
    file of a role'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_08_24.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.24 – An example of the metadata that can be placed in the meta/main.yml
    file of a role
  prefs: []
  type: TYPE_NORMAL
- en: The `ansible-galaxy` tool can also help with the creation of new roles. The `role
    init` method will create a skeleton directory tree for the role, as well as populating the `meta/main.yml` file
    with placeholders for Galaxy-related data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s demonstrate this capability by creating a new role in our working directory
    named `autogen`, using this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'If you examine the directory structure this command creates, you will see all
    the directories and placeholder files needed to create a brand-new role, as the
    following screenshot illustrates:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.25 – Creating a skeletal empty role using the ansible-galaxy tool'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_08_25.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.25 – Creating a skeletal empty role using the ansible-galaxy tool
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that where we have used the `-p` switch in the past for specifying the
    local `roles/` directory, we have to use the `--init-path` switch instead with
    the `init` command. For roles that are not suitable for Ansible Galaxy, such as
    roles dealing with in-house systems, `ansible-galaxy` can install directly from
    a Git **Uniform Resource Locator** (**URL**). Instead of just providing a role
    name to the `install` method, a full Git URL with an optional version can be provided.
    For example, if we wanted to install the `foowhiz` role from our internal Git
    server, we could simply run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Without version information, the `master` branch will be used. Without name
    data, the name will be determined from the URL itself. To provide a version, append
    a comma and the version string that Git can understand, such as a tag or branch
    name—for example, `v1`, as illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'A name for the role can be added with another comma followed by the `name`
    string, as illustrated in the following code snippet. If you need to supply a
    name but do not wish to supply a version, an empty slot is still required for
    the version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Roles can also be installed directly from tarballs as well, by providing a URL
    to the tarball in lieu of a full Git URL or a role name to fetch from Ansible
    Galaxy.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you need to install many roles for a project, it''s possible to define
    multiple roles to download and install in a YAML-formatted file that ends with `.yaml` (or `.yml`).
    The format of this file allows you to specify multiple roles from multiple sources
    and retain the ability to specify versions and role names. In addition, the source
    control method can be listed (currently, only `git` and `hg` are supported). You
    can see an example of this in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'To install all the roles within a file, use the `--roles-file` (`-r`) option
    with the `role install` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: In this manner, it is very easy to gather all your role dependencies prior to
    running your playbooks, and whether the roles you need are publicly available
    on Ansible Galaxy or held in your own internal source control management system,
    this simple step can greatly speed along playbook deployment while supporting
    code reuse.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible provides the capability to divide content logically into separate files.
    This capability helps project developers not repeat the same code over and over
    again. Roles within Ansible take this capability a step further and wrap some
    magic around the paths to the content. Roles are tunable, reusable, portable,
    and shareable blocks of functionality. Ansible Galaxy exists as a community hub
    for developers to find, rate, and share roles as well as collections. The `ansible-galaxy` command-line
    tool provides a method to interact with the Ansible Galaxy site or other role-sharing
    mechanisms. These capabilities and tools help with the organization and utilization
    of common code.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you learned all about inclusion concepts relating to tasks,
    handlers, variables, and even entire playbooks. Then, you expanded on this knowledge
    by learning about roles—their structure, setting default variable values, and
    handling role dependencies. You then proceeded to learn about designing playbooks
    to utilize roles effectively and applying options such as tags that roles otherwise
    lack. Finally, you learned about sharing roles across projects using repositories
    such as Git and Ansible Galaxy.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll cover useful and effective troubleshooting techniques
    to help you when your Ansible deployments run into trouble.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Which Ansible module can be used to run tasks from a separate external task
    file when a playbook is run?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) `ansible.builtin.import`
  prefs: []
  type: TYPE_NORMAL
- en: b) `ansible.builtin.include`
  prefs: []
  type: TYPE_NORMAL
- en: c) `ansible.builtin.tasks_file`
  prefs: []
  type: TYPE_NORMAL
- en: d) `ansible.builtin.with_tasks`
  prefs: []
  type: TYPE_NORMAL
- en: 'Variable data can be passed to an external task file when it is called:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) True
  prefs: []
  type: TYPE_NORMAL
- en: b) False
  prefs: []
  type: TYPE_NORMAL
- en: 'The default name of the variable containing the current loop value is:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) `i`
  prefs: []
  type: TYPE_NORMAL
- en: b) `loop_var`
  prefs: []
  type: TYPE_NORMAL
- en: c) `loop_value`
  prefs: []
  type: TYPE_NORMAL
- en: d) `item`
  prefs: []
  type: TYPE_NORMAL
- en: When looping over external task files, it is important to consider setting which
    special variable to prevent loop variable name collisions?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) `loop_name`
  prefs: []
  type: TYPE_NORMAL
- en: b) `loop_item`
  prefs: []
  type: TYPE_NORMAL
- en: c) `loop_var`
  prefs: []
  type: TYPE_NORMAL
- en: d) `item`
  prefs: []
  type: TYPE_NORMAL
- en: 'Handlers are generally run:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) Once, at the end of the play
  prefs: []
  type: TYPE_NORMAL
- en: b) Once each, at the end of the `pre_tasks`, `roles/tasks`, and `post_tasks`
    sections of the play
  prefs: []
  type: TYPE_NORMAL
- en: c) Once each, at the end of the `pre_tasks`, `roles/tasks`, and `post_tasks`
    sections of the play and only when notified
  prefs: []
  type: TYPE_NORMAL
- en: d) Once each, at the end of the `pre_tasks`, `roles/tasks`, and `post_tasks`
    sections of the play and only when imported
  prefs: []
  type: TYPE_NORMAL
- en: 'Ansible can load variables from the following external sources:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) Static `vars_files` inclusion
  prefs: []
  type: TYPE_NORMAL
- en: b) Dynamic `vars_files` inclusion
  prefs: []
  type: TYPE_NORMAL
- en: c) Through the `include_vars` statement
  prefs: []
  type: TYPE_NORMAL
- en: d) Through the `extra-vars` command-line parameter
  prefs: []
  type: TYPE_NORMAL
- en: e) All of the above
  prefs: []
  type: TYPE_NORMAL
- en: 'Roles obtain their name from the role directory name (for example, `roles/testrole1`
    has the name `testrole1`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) True
  prefs: []
  type: TYPE_NORMAL
- en: b) False
  prefs: []
  type: TYPE_NORMAL
- en: 'If a role is missing the `tasks/main.yml` file, Ansible will:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) Abort the play with an error
  prefs: []
  type: TYPE_NORMAL
- en: b) Skip the role entirely
  prefs: []
  type: TYPE_NORMAL
- en: c) Still reference any other valid parts of the role, including metadata, default
    variables, and handlers
  prefs: []
  type: TYPE_NORMAL
- en: d) Display a warning
  prefs: []
  type: TYPE_NORMAL
- en: 'Roles can have dependencies on other roles:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) True
  prefs: []
  type: TYPE_NORMAL
- en: b) False
  prefs: []
  type: TYPE_NORMAL
- en: 'When you specify a tag for a role, Ansible''s behavior is to:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) Apply the tag to the entire role
  prefs: []
  type: TYPE_NORMAL
- en: b) Apply the tag to each task within the role
  prefs: []
  type: TYPE_NORMAL
- en: c) Skip the role entirely
  prefs: []
  type: TYPE_NORMAL
- en: d) Only execute tasks from a role with the same tag
  prefs: []
  type: TYPE_NORMAL
