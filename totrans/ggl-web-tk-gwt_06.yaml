- en: Chapter 6. Browser Effects with JSNI and JavaScript Libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will learn how to create user interfaces that can utilize
    cool browser effects provided by some well-known third-party JavaScript libraries.
    We will take advantage of the JavaScript Native Interface (JSNI) provided by GWT
    to wrap these existing JavaScript libraries and use them in our GWT applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'The tasks that we will address are:'
  prefs: []
  type: TYPE_NORMAL
- en: Moo.Fx
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rico Rounded Corners
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rico Color Selector
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Script.aculo.us effects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is JSNI?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'JSNI provides a way to mix JavaScript code with Java code. It is similar in
    concept to the Java Native Interface (JNI) provided by Sun''s Java environment.
    JNI enables your Java code to call C and C++ methods. JSNI enables your Java code
    to call into JavaScript methods. It is very powerful technique that lets us access
    low-level JavaScript code directly from Java code, and opens the door to a wide
    variety of uses and possibilities listed below:'
  prefs: []
  type: TYPE_NORMAL
- en: Call JavaScript code from Java
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Call Java code from JavaScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Throw exceptions that cross the Java/JavaScript boundaries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Access Java fields from JavaScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'However, this powerful technique should be used carefully, as JSNI code may
    not be portable across browsers. The current implementation of the GWT compiler
    will also not be able to perform any optimizations on JSNI code. JSNI methods
    must always be declared native, and the JavaScript code that is placed in the
    JSNI method must be placed in a comment block that is specially formatted. So
    each JSNI method will consist of two parts—a native method declaration, and the
    JavaScript code for the method embedded inside a specially formatted code block.
    Here is an example of a JSNI method that calls the `alert()` JavaScript method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the above example, the JavaScript code is embedded in a '/*-{' and '}-*/'
    block. Another thing to be aware of is the use of the `$wnd` and `$doc` variables.
    GWT code always runs inside a nested frame inside the browser, so you cannot access
    the window or document objects in the normal way inside your JSNI code. You must
    use the `$wnd` and `$doc` variables, which are automatically initialized by GWT
    to refer to the window and document objects for the host page. The GWT compiler
    can check our JSNI code. So if you run it in web mode and compile your application,
    the compiler will flag any errors in your JSNI code. This is a nice way to debug
    JSNI code, as these errors will not be displayed until run time when you are running
    in hosted mode. In this chapter, we are going to use JSNI to wrap some third-party
    JavaScript libraries, and use the cool browser effects provided by them, inside
    our GWT user interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the recent versions of GWT, JSNI functions sometimes do not work in hosted
    mode, but work fine when deployed.
  prefs: []
  type: TYPE_NORMAL
- en: Moo.Fx
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Moo.fx` is a super lightweight and fast JavaScript library that provides several
    cool effects for web applications ([http://moofx.mad4milk.net](http://moofx.mad4milk.net)).
    It is compact and works in all the major web browsers. We are going to use JSNI
    to wrap some of the effects provided by the `Moo.fx` library and use these effects
    in our GWT application.'
  prefs: []
  type: TYPE_NORMAL
- en: Time for Action—Using JSNI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are going to use the JSNI provided by the GWT framework to wrap the `Moo.fx`
    library and intermingle Java and JavaScript to use its functionality in our GWT
    user interface.
  prefs: []
  type: TYPE_NORMAL
- en: Add the prototype and `Moo.fx` JavaScript files that will be needed by our application
    to the module's HTML file—`Samples.html`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Create a new Java class named `MooFx.java` in the `com.packtpub.gwtbook.samples.client.util`
    package that wraps the `Moo.fx` JavaScript library effects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new JSNI method in `MooFx.java` for creating an `opacity.fx` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Add a JSNI method for toggling the opacity effect.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Add a private JSNI method that takes a parameter string of options and converts
    it into a JavaScript object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Add a static Java method for creating a height effect, which uses the above
    `buildOptions()` to build a JavaScript object for passing on the options to a
    JSNI method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Add a new JSNI method that will create the height effect object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Add a new JSNI method for toggling the height effect.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Add a static Java method for creating a width effect, which uses the above `buildOptions()`
    to build a JavaScript object for passing on the options to a JSNI method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Add a new JSNI method that will create the width effect object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Add a new JSNI method for toggling the width effect.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Create the user interface for this application in a new Java file named `MooFxEffectsPanel.java`
    in the `com.packtpub.gwtbook.samples.client.panels` package. Add an HTML fragment
    that contains an outer `div` element with an inner `div` element that contains
    a paragraph element with text. Add three different variables containing this fragment.
    Also add an element for each effect.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Create three buttons, one for toggling each `Moo.fx` effect.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Register an event handler to listen for clicks on each of the buttons, and call
    the appropriate method for toggling the effect.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Create a `DeferredCommand` that creates each of the effect objects when it executes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In the constructor, add the buttons and `divs` for each effect to the work panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Finally, create a little info panel that displays descriptive text about this
    application, so that we can display this text when this sample is selected in
    the list of available samples in our `Samples` application. Add the info panel
    and the work panel to a dock panel, and initialize the widget.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Here is a screenshot of the application. Click on each button to see the effect
    in action.
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for Action—Using JSNI](img/1007_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: What Just Happened?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The main effects provided by the `Moo.fx` library are:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Opacity: Modify the opacity or transparency of an element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Height: Modify the height of an element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Width: Modify the width of an element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this sample, we created a Java class named `MooFx`, which wrapped the `Moo.fx`
    JavaScript library using JSNI. We created a native method named `opacity()` for
    instantiating an opacity object. In this method, we call the JavaScript constructor
    for the opacity object and return the resulting object, which is of type `Element`.
    We store this in a variable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We then create a native method named `toggleOpacity()` for toggling the opacity
    of an element from one state to another. This method uses the variable that we
    stored earlier and calls the toggle method on it to change its current state.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We create `height()` and `width()` Java methods that are passed a string parameter
    containing the options that need to be provided to the `Moo.fx` height and width
    constructors. These two methods use a native method named `buildOptions()` to
    create the JavaScript object containing the options, which will then be passed
    on to the native method for creating the height and width. The `buildOptions()`
    method parses the provided string, and creates a JavaScript object and sets its
    properties and the property values. We again utilize the `eval()` function to
    set the properties and return the object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The returned JavaScript options object is passed on to the native `height()`
    and `width()` methods to create the respective effect objects similar to the `opacity()`
    method. We then add native methods for toggling the height and width. That is
    all we have to do to wrap the library in an easy-to-use Java class!
  prefs: []
  type: TYPE_NORMAL
- en: In the user interface, we create an HTML object with an outer `div` that contains
    an inner `div` with a paragraph of text. The HTML widget enables us to create
    arbitrary HTML and add it to a panel. We used the HTML widget in this sample,
    but we can also create the same element using the methods in the DOM object in
    the GWT framework. In the next sample, we will use that functionality, so that
    we are familiar with the different tools provided by GWT. We also create three
    buttons, one each for toggling each of the effects. Event handlers are registered
    with each of these buttons to listen for clicks and then call the appropriate
    toggle method for the specified effect. In the method for creating the effect,
    we use the `getElementById()` on the DOM object to get the `div` element that
    we are interested in. We needed to do this, as we do not have access to the `div`
    that we added to the panel. The `div` that we were interested in was added to
    the panel as part of the HTML widget.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We then toggle the requisite effect on the element.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The effects themselves are constructed by calling the respective constructors
    for the effects inside `DeferredCommand`. The elements that we have added are
    not available yet by using their ID, until the event handlers have all completed.
    The `DeferredCommand` runs after they have all completed, and this ensures that
    our element has been added to the DOM and can be accessed by using its ID. We
    get the element, create an effect, and associate it with the element.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We have successfully accessed the library from Java in our GWT application,
    and can reuse these effects everywhere. In the `ColorSelector` sample later in
    this chapter, we will use one of the `Moo.fx` effects in combination with effects
    form other libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Rico Rounded Corners
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Elements on a web page with rounded corners are visually much more attractive
    than straight corners and are aesthetically more appealing. It is also one of
    the hottest design trends in the look and feel of web applications. Rico ([http://openrico.org/rico/home.page](http://openrico.org/rico/home.page))
    is another fine JavaScript library that has great support for this and makes it
    extremely easy to use. It also provides a great deal of functionality, but we
    are only wrapping and using the rounded corners effects part of Rico. We are only
    using labels in this sample for applying the rounded corners, but you can also
    apply it to text paragraphs and several other HTML elements. In this example we
    will wrap the rounded corners effect from Rico and use it in our application to
    display several labels with different types of rounded corners.
  prefs: []
  type: TYPE_NORMAL
- en: Time for Action—Supporting the Labels
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are going to wrap the `Rico` library and provide support for labels with
    rounded corners in our GWT user interface.
  prefs: []
  type: TYPE_NORMAL
- en: Add the prototype and Rico JavaScript files that will be needed by our application
    to the module's HTML file—`Samples.html`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Create a new Java class named `Rico.java` in the `com.packtpub.gwtbook.samples.client.util`
    package that will wrap the `rico` JavaScript library effects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new JSNI method in `Rico.java` for rounding the corner of a widget.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Add a private JSNI method that takes a parameter of string options and converts
    it into a JavaScript object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Add a static Java method for creating a rounded corner, which uses the above
    `buildOptions()` to build a JavaScript object for passing on the options to a
    JSNI method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Add a static Java method for creating a rounded corner without passing any options,
    and using the defaults.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Create the user interface for this application in a new Java file named `RoundedCornersPanel.java`
    in the `com.packtpub.gwtbook.samples.client.panels` package. Create a grid with
    three rows and two columns. We will add labels to this grid.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Add six labels that will have six different rounded corners applied to them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Call the method to create the rounded corner for each of the labels, passing
    it different options to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Add the labels to the grid.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Finally, create a little info panel that displays descriptive text about this
    application, so that we can display this text when this sample is selected in
    the list of available samples in our `Samples` application. Add the info panel
    and the work panel to a dock panel, and initialize the widget.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a screenshot displaying labels with different types of rounded corners:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for Action—Supporting the Labels](img/1007_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: What Just Happened?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We created a Java class that uses JSNI to provide access to the rounded corners
    functionality in the `Rico` JavaScript library. We create a `buildOptions()` method
    like in the previous sample, which can accept a parameter that contains a string
    with options, and add those options as properties on a native JavaScript object.
    This options object is then passed to a JSNI method that calls the `corner()`
    method in the Rico library for the provided element.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In the user interface, we create a grid, and add six labels to it. Each of these
    labels has a different type of rounded corner applied to it. Rico supports rounded
    corners on all four sides or a specific side. It can also create corners in the
    compact form, where the corners are slightly less rounded than the default version.
    You can even round two or three corners and leave the fourth one square. Rico
    provides other methods that you can wrap and use in your application in addition
    to the rounded corners. The procedure is very similar to what we have done so
    far and is usually just a matter of implementing all the methods from the JavaScript
    library that you are interested in. In the next sample, we will wrap some more
    functionality in Rico and use it in a color selector application.
  prefs: []
  type: TYPE_NORMAL
- en: Rico Color Selector
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have successfully wrapped the rounded corners effect from Rico in the previous
    example. In this section, we are going to add support for accessing color information
    using Rico's Color object. We will wrap this functionality using JSNI and then
    create a color selector application that uses Rico color objects along with the
    `Moo.fx` effects that we created earlier in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Time for Action—Wrapping the Color Methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will wrap the `color` methods in the `Rico` library and use them to create
    an application for selecting colors.
  prefs: []
  type: TYPE_NORMAL
- en: Add a new JSNI method in `Rico.java` for creating a `color` object with provided
    `red, green`, and `blue` values, and apply it to the element provided.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Add a new JSNI method in `Rico.java` for getting the hex value of a Rico color
    object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Create the user interface for this application in a new Java file named `ColorSelectorPanel.java`
    in the `com.packtpub.gwtbook.samples.client.panels` package. Create a grid with
    three rows and three columns. Create three text fields for entering the values,
    along with the work panel and `divs` for the color box and the color text.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: In the constructor, initialize the grid, and default the values in each of the
    text boxes to zero.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Register an event handler to listen for keyboard events.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Create a paragraph element for displaying the selected color.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Create the element for displaying the hex value of the selected color.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Create a `DeferredCommand` for initializing the height effect from `Moo.fx`
    and for setting the initial selected color as (0, 0, 0).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Add an `onKeyPress()` handler to display the selected color when the user types
    in the new RGB values, and apply the height effect to the `div` displaying the
    hex value of the selected color.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Finally, create a little info panel that displays descriptive text about this
    application, so that we can display this text when this sample is selected in
    the list of available samples in our `Samples` application. Add the info panel
    and the work panel to a dock panel, and initialize the widget.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Here is the application. Type in new values of RGB, and watch the selected color
    being displayed as soon as you stop typing, and the hex value for the current
    color displayed with a slide up and slide down window effect!
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for Action—Wrapping the Color Methods](img/1007_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: What Just Happened?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We first enhance our Rico wrapper class from the previous sample, to add access
    to the color functionality. Rico provides us with the ability to create a color
    object by using a set of red, green, and blue values. Once this color object is
    constructed, its hex value can be retrieved as a string. We add a JSNI method
    to create a color object. Inside this method, we create the `Rico.Color` object
    and then set the background of the provided element to the newly created color.
    The color object is stored in a variable with the name of the variable being the
    same as the ID of the element. We use the `eval()` method to dynamically create
    the variable and to set the background color. We set the `backgroundColor` DHTML
    property for the element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: We also create a JSNI method that can return the hex value of the background
    color of the provided element.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: In the user interface, we create a grid and populate it with three text boxes
    for entering the color values, and some identifiers for each field. We use the
    DOM object for creating various elements in this sample, instead of using an HTML
    widget. The DOM object contains several static methods for creating various elements
    and for manipulating the Document Object Model of the web page. We create two
    `div` elements and a paragraph element and add them to the panel in the page.
    These will be used for creating the element that will have the height effect applied
    to it to slide up and down the `div` before displaying the hex value of the selected
    color. Since the `workPanel` is a GWT widget, we call the `getElement()` method
    provided on all the widgets to get access to the underlying DOM element, and then
    append the `div` element to it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: We once again use a `DeferredCommand` to set the initial hex value of the current
    color and to set up the height effect object from `Moo.fx`. Since we are using
    a paragraph element to display the string with the color hex value, we have to
    set its inner text using the DOM object. If we used a GWT widget instead, we would
    set the value by calling the `setText()` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Finally, in the `onKeyPress()` method we first toggle the height of the `colordiv`,
    so the element slides up. Then we schedule a timer to go off in 500 milliseconds,
    and when the timer fires, we create a new color object with the current values
    in the red, green, and blue text boxes, set the text of the `colorText` element
    to the hex value of this color, and then toggle the height of the `colordiv` so
    it slides down to display this value. The timer is necessary to slow it down a
    little, so you can clearly see the transition and the effect.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Script.aculo.us Effects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Script.aculo.us` ([http://script.aculo.us/](http://script.aculo.us/)) is an
    amazing JavaScript library written by Thomas Fuchs that enables all kinds of snazzy
    transitions and visual effects inside the web page. It is a cross-browser-compatible
    library that is built on top of the prototype JavaScript framework. It is also
    one of the most popular Web 2.0 libraries that is widely used in a variety of
    applications and is, most notably, also included in the Ruby On Rails web framework.
    `Script.aculo.us` effects are integrated and provided by the `Effect` class, which
    is a part of this library. We will use this class to invoke and use the various
    effects in our GWT application. Unlike the other sections in this chapter, we
    will not use JSNI here, but we will show how to use an existing wrapper library
    inside our application to provide some nice browser effects.'
  prefs: []
  type: TYPE_NORMAL
- en: Time for Action—Applying Effects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `gwt-widget` library is a terrific group of extensions and enhancements
    to the GWT framework maintained by Robert Hanson ([http://gwt-widget.sourceforge.net/](http://gwt-widget.sourceforge.net/)).
    It provides a Java class that wraps the effects, and we will use this class in
    our application. We will add a grid with two rows and four columns, each containing
    a small image file, and apply one effect to each of the images.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to reference the `gwt-widgets` module that provides the Java wrapper
    for the library. This is leveraging the module inheritance feature of GWT. We
    will go into an explanation of this concept in the *What Just happened?* section
    of this sample. Follow the steps given below to add the grid:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following entry to the existing `Samples.gwt.xml` file in the `com.packtpub.gwtbook.samples`
    package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the prototype and `Script.aculo.us` JavaScript files that are used by the
    above module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Create the user interface for this application in a new Java file named `ScriptaculousEffectsPanel.java`
    in the `com.packtpub.gwtbook.samples.client.panels` package. Create a grid with
    two rows and four columns. Create eight images, and eight buttons, and a work
    panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Add the button and image for the fade effect to a `VerticalPanel` and add the
    panel to the grid.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Add an event handler for listening to the click on the fade effect button, and
    call the appropriate `Script.aculo.us` effect.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Add the button and image for the shake effect to a `VerticalPanel` and add the
    panel to the grid.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Add an event handler for listening to the click on the shake effect button,
    and call the appropriate `Script.aculo.us` effect.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Add the button and image for the grow effect to a `VerticalPanel` and add the
    panel to the grid.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Add an event handler for listening to the click on the grow effect button, and
    call the appropriate `Script.aculo.us` effect.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Add the button and image for the blind up effect to a `VerticalPanel` and add
    the panel to the grid.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Add an event handler for listening to the click on the blind up effect button,
    and call the appropriate `Script.aculo.us` effect.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Add the button and image for the puff effect to a `VerticalPanel` and add the
    panel to the grid.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Add an event handler for listening to the click on the puff effect button, and
    call the appropriate `Script.aculo.us` effect.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Add the button and image for the shrink effect to a `VerticalPanel` and add
    the panel to the grid.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Add an event handler for listening to the click on the shrink effect button,
    and call the appropriate `Script.aculo.us` effect.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Add the button and image for the pulsate effect to a `VerticalPanel` and add
    the panel to the grid.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Add an event handler for listening to the click on the pulsate effect button,
    and call the appropriate `Script.aculo.us` effect.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Finally, create a little info panel that displays descriptive text about this
    application, so that we can display this text when this sample is selected in
    the list of available samples in our `Samples` application. Add the info panel
    and the work panel to a dock panel, and initialize the widget.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Add the `gwt-widgets.jar` to the buildpath in Eclipse so it can find the referenced
    classes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here are the various effects that we have in this application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for Action—Applying Effects](img/1007_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Click on each button to see the respective effect applied to the image.
  prefs: []
  type: TYPE_NORMAL
- en: What Just Happened?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Modules are XML files that contain the configuration settings for a GWT project.
    We have already seen and used the one for our `Samples` project. This is the file
    where we have referenced the external JavaScript files used by our application,
    along with entries for the RPC services used by our application, etc. GWT modules
    also have the ability to inherit from other modules. This enables the inheriting
    module to use resources that are declared in the inherited module. It prevents
    the issue of duplicate resource mapping and promotes reuse, making it easy to
    package GWT libraries as modules and distribute them and reuse them across projects.
    We can specify the module to be inherited from, by using the `inherits` tag and
    providing the fully qualified name of the module. All GWT applications must inherit
    from the `com.google.gwt.user.User` module, which provides the core web toolkit
    items. In this example we inherit from the `org.gwtwidgets.WidgetLibrary` that
    provides the `Script.aculo.us` effects class that we used in our application.
    Here is how we defined this inheritance in the `Samples.gwt.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Script.aculo.us` effects are divided into two different types—Core effects
    and Combination effects. The core effects are the foundation of the library and
    the combination effects mix and use the core effects to create combination effects.
    The core effects in this library are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Opacity:** Sets the transparency of an element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scale:** Scales an element smoothly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Move By:** Moves an element by the given amount of pixels.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Highlight:** Draws attention to an element by changing its background color
    and flashing it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Parallel:** Multiple effects are applied in parallel to the element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The above core effects are mixed together to create the following combination
    effects:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Fade:** Fades an element away.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Puff:** Makes an element disappear in a cloud of smoke.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Shake:** Moves an element repeatedly to the left and right.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Blind Down:** Simulates a window blind coming down over an element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Blind Up:** Simulates a window blind going up over an element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pulsate:** Fades an element in and out and makes it appear to be pulsating.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Grow:** Grows an element in size.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Shrink:** Reduces an element in size.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Squish:** Reduces an element by shrinking it to its left.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fold:** First reduces an element to its top, then to its left, and eventually
    makes it disappear.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We position an image and a button inside each grid cell. When the button is
    clicked, we apply an effect to the image element that is above the button. We
    invoke an effect by providing the widget object to the desired effect method in
    the `org.gwtwidgets.client.wrap.Effect` class. All the methods in this class are
    static and each `Script.aculo.us` effect has a correspondingly named method in
    this class. So in order to fade an element, we call the `Effect.fade()` method
    and provide it with the image widget to which to apply the effect. These transitions
    are a very nice way to add dazzle to our application and provide a better user
    experience. You can also mix and match the provided effects in different ways
    to create and use customized effects.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have covered several JavaScript libraries and their use in GWT applications.
    A very important thing to be aware of while using all these libraries is that
    including a lot of JavaScript will increase the bloat that has to be loaded by
    the browser and will almost certainly increase page load times, and make things
    run slower. So use the visual effects sparingly and do not go overboard with them.
    Another caveat is the lack of portability when using JSNI for your application.
    This can cause your application to work quite differently in different versions
    of browsers.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter we have learned about JSNI. We utilized JSNI to wrap the `Moo.fx`
    library and used its effects. We also wrapped different pieces of the `Rico` library
    and utilized it to create rounded corners for labels and a color selector application.
    We used the `Script.aculo.us` effects provided by the `gwt-widgets` library. We
    used an existing library in this case to provide the effects. We also learned
    how to use module inheritance in GWT.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to learn how to create custom GWT widgets
    that can be shared across projects.
  prefs: []
  type: TYPE_NORMAL
