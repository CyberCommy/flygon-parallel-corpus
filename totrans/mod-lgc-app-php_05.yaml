- en: Chapter 5. Replace global With Dependency Injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, all of our classes and functions have been consolidated to a
    central location, and all related `include` statements have been removed. We would
    prefer to start writing tests for our classes, but it is very likely that we have
    a lot of `global` variables embedded in them. These can cause a lot of trouble
    via action at a distance where modifying a `global` in one place changes its value
    in another place. The next step, then, is to remove all uses of the `global` keyword
    from our classes, and inject the necessary dependencies instead.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**What Is Dependency Injection?**'
  prefs: []
  type: TYPE_NORMAL
- en: Dependency injection means that we push our dependencies into a class from the
    outside, instead of pulling them into a class while inside the class. (U sing
    `global` pulls a variable into the current scope from the global scope, so it
    is the opposite of injection.) Dependency injection turns out to be very straightforward
    as a concept, but is sometimes difficult to adhere to as a discipline.
  prefs: []
  type: TYPE_NORMAL
- en: Global Dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To start with a naive example, let''s say an `Example` class needs a database
    connection. Here we create the connection inside a class method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We are creating the `Db` dependency inside the method that needs it. There
    are several problems with this. Some of them are:'
  prefs: []
  type: TYPE_NORMAL
- en: Every time we call this method, we create a new database connection, which may
    strain our resources.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we ever need to change the connection parameters, we need to modify them
    in every place we create a connection.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is difficult to see from the outside of this class what its dependencies
    are.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After writing code like this, many developers discover the `global` keyword,
    and realize they can create the connection once in a setup file, then pull it
    in from the global scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Even though we are still pulling in the dependency, this technique solves the
    problem of multiple database connections using up limited resources, since the
    same database connection is reused across the codebase. The technique also makes
    it possible to change our connection parameters in a single location, the `setup.php`
    file, instead of several locations. However, one problem remains, and one is added:'
  prefs: []
  type: TYPE_NORMAL
- en: We still cannot see from the outside of the class what its dependencies are.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the `$db` variable is ever changed by any of the calling code, that change
    is reflected throughout the codebase, leading to debugging trouble.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last point is a killer. If a method ever sets `$db = 'busted';` then the
    `$db` value is now a string, and not a database connection object, throughout
    the entire codebase. Likewise, if the `$db` object is modified, then it is modified
    for the entire codebase. This can lead to very difficult debugging sessions.
  prefs: []
  type: TYPE_NORMAL
- en: The replacement process
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Thus, we want to remove all `global` calls from the codebase to make it easier
    to troubleshoot, and to reveal the dependencies in our classes. Here is the general
    process we will use to replace `global` calls with dependency injection:'
  prefs: []
  type: TYPE_NORMAL
- en: Find a `global` variable in one of our classes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Move all `global` variables in that class to the constructor and retain their
    values as properties, and use the properties instead of the globals.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Spot check that the class still works.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Convert the `global` calls in the constructor to constructor parameters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Convert all instantiations of the class to pass the dependencies.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Spot check, commit, push, and notify QA.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat with the next `global` call in our class files, until none remain.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this process, we work *one class at a time* and not *one variable at a time*.
    The former is much less time-consuming and more unit-oriented than the latter.
  prefs: []
  type: TYPE_NORMAL
- en: Find a global variable
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is easy with a project-wide search function. We search for `global` within
    the central class directory location, and get back a list of class files with
    that keyword in them.
  prefs: []
  type: TYPE_NORMAL
- en: Convert global variables to properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s say that our search revealed an `Example` class with code something
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We now move the global variable to a property that gets set in the constructor,
    and convert the `fetch()` method to use the property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If there are multiple `global` calls inside the same class, we should convert
    all of them to properties in that class. We want to work *one class at a time*
    as this makes later parts of this process easier.
  prefs: []
  type: TYPE_NORMAL
- en: Spot check the class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have converted `global` calls to properties in this one class, we
    need to test the application to make sure it still works. However, since there
    is no formal testing system in place yet, we pseudo-test or spot check by browsing
    to or otherwise invoking files that use the modified class.
  prefs: []
  type: TYPE_NORMAL
- en: If we like, we can make an interim commit here once we are sure the application
    still works. We will not push to the central repository or notify QA just yet;
    all we want is a point to which we can roll back if later changes need to be undone.
  prefs: []
  type: TYPE_NORMAL
- en: Convert global properties to constructor parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once we ascertain that the class works with the properties in place, we need
    to convert the `global` calls in the constructor to use passed parameters instead.
    Given our `Example` class above, the converted version might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: All we have done here is remove the `global` call, and added a constructor parameter.
    We need to do this for every `global` in the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Since the `global` is for a particular class of object, we typehint the parameter
    to that class (in this case `Db`). If possible, we should typehint to an interface
    instead, so if the `Db` object implements a *DbInterface*, we should typehint
    to *DbInterface*. This will help with testing and later refactoring. We may also
    typehint to `array` or `callable` as appropriate. Not all `global` calls are for
    typed values, so not all parameters will need typehints (e.g., when the parameter
    is expected to be a string).
  prefs: []
  type: TYPE_NORMAL
- en: Convert instantiations to use parameters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: After converting `global` variables to constructor parameters, we will find
    that every instantiation of the class throughout the legacy application is now
    broken. This is because the constructor signature has changed. With that in mind,
    we now need to search *the entire codebase* (not just the classes) for instantiations
    of the class, and change the instantiations to the new signature.
  prefs: []
  type: TYPE_NORMAL
- en: 'To search for instantiations, we use our project-wide search facility to find
    uses of the `new` keyword with our class name using a regular expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The expression searches for the `new` keyword, followed by at least one character
    of whitespace, followed by a terminating non-word character (such as a parenthesis,
    space, or semicolon).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Formatting Issues**'
  prefs: []
  type: TYPE_NORMAL
- en: Legacy codebases are notorious for having messed-up formatting, which means
    this expression is imperfect in some situations. The expression as given here
    may not find instantiations where, for example, the `new` keyword is on one line,
    and the class name is the very next thing but is on the next line, not the same
    line.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class Aliases With use**'
  prefs: []
  type: TYPE_NORMAL
- en: 'In PHP 5.3 and later, classes may be aliased to another class name with a use
    statement, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, we need to do two searches: one for use `\s+Example\s+as` to
    discover the various aliases, and a second search for the new keyword with the
    alias.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As we discover instantiations of the class in the codebase, we modify them
    to pass the parameters as needed. If, for example, a page script looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to add the parameter to the instantiation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The new instantiations need to match the new constructor signature, so if the
    constructor takes more than one parameter, we need to pass all of the parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Spot check, Commit, Push, Notify QA
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have reached the end of the conversion process for this class. We need to
    spot check the converted instantiations now, but (as always) this is not an automated
    process, so we need to run or otherwise invoke the files with the changed code.
    If there are problems, go back and fix them.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have done so, and are sure there are no errors, we can commit the changed
    code, push it to our central repository, and notify QA that it needs to run its
    test suite over the legacy application.
  prefs: []
  type: TYPE_NORMAL
- en: Do ... While
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: That is the process to convert a single class from using `global` calls to using
    dependency injection. Go back through the class files and find the next class
    with a `global` call and begin the process again. Continue to do so until there
    are no more `global` calls in the classes.
  prefs: []
  type: TYPE_NORMAL
- en: Common Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What if we find a global in a static method?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes we will find that a static class method uses a `global` variable
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This is a problem because there is no constructor to which we can move the `global`
    variable as a property. There are two options here.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first option is to pass all the needed globals as parameters on the static
    method itself, thereby changing the signature of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We would then search the codebase for all uses of `Foo::doSomething(` and pass
    the `$bar` value each time. For that reason, I suggest adding the new parameters
    to the *beginning* of the signature, rather than to the end, because it makes
    search-and-replace much easier. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Search for:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The second option is to change the class so that it must be instantiated, and
    make all the methods instance methods. The class, after conversion, might look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we would need to:'
  prefs: []
  type: TYPE_NORMAL
- en: Search the codebase for all `Foo::` static calls;
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create instances of `Foo` with its `$bar` dependency (e.g., `$foo = new Foo($bar);`)
    before those static calls are made, and
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Replace calls of `Foo::doSomething()` with `$foo->doSomething()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is there an alternative conversion process?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The process described above is a class-by-class process, where we first move
    the globals in a single class to the constructor, then change from global properties
    to instance properties in that class, and finally change instantiations of that
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, we might choose a modified process:'
  prefs: []
  type: TYPE_NORMAL
- en: Change all global variables to properties in all classes, then test/commit/push/QA.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change all global properties to constructor parameters *in all classes*, and
    change instantiations *of all classes*, then test/commit/push/QA.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This may be a reasonable alternative for smaller codebases, but it comes with
    some problems, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: The search for `global` calls becomes a little more difficult while converting
    globals to properties, because we will see the `global` keyword in both the converted
    and unconverted classes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The commits for each major step will be much larger and harder to read.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For these reasons and others, I think it's better to stay with the process as
    described. It works with large and small codebases, and keeps incremental changes
    in smaller easier-to-read portions.
  prefs: []
  type: TYPE_NORMAL
- en: What about class names in variables?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes we will find that classes are instantiated based on variable values.
    For example, this creates an object based on the value of the `$class` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: If `$type` is `Blog`, then the `$record` object will be of the class `Blog_Record`.
  prefs: []
  type: TYPE_NORMAL
- en: This kind of thing is very difficult to discover when searching for class instantiations
    to convert to using constructor parameters. I'm afraid I have no good advice for
    automatically finding these kinds of instantiations. The best we can do is to
    search for `new\s+\$` without any class name, and modify the calls individually
    by hand.
  prefs: []
  type: TYPE_NORMAL
- en: What about superglobals?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Superglobals represent a challenging special case when removing global variables.
    They are automatically global within every scope, so they carry all the drawbacks
    of globals. We won't find them with a search for the `global` keyword (although
    we can search for them by name). Because they truly are global, we need to remove
    them from our classes just as much as we need to remove the `global` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: We could pass a copy of each superglobal into the class when we need it. In
    cases where we need only one this might be fine, but frequently we need two or
    three or more superglobals. In addition, passing a copy of `$_SESSION` will not
    work as expected; PHP uses the actual superglobal of `$_SESSION` for writing session
    data, so changes to the copy will not be honored.
  prefs: []
  type: TYPE_NORMAL
- en: As a solution, we can use a `Request` data structure class. The `Request` encapsulates
    a copy of each of the non-`$_SESSION` superglobals. At the same time, the `Request`
    maintains a reference to `$_SESSION` so that changes to the object property are
    honored by the real `$_SESSION` superglobal.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that the `Request` is not an HTTP request object per se. It is merely a
    representation of the request environment for PHP, including server, environment,
    and session values, many of which are not found in HTTP messages.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, say we have a class that uses `$_POST`, `$_SERVER`, and `$_SESSION`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: To replace these calls, we first create a shared `Request` object in our setup
    code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then decouple from the superglobals by injecting that shared `Request`
    object in to any class that needs it, and use the `Request` properties instead
    of the superglobals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If it is important to maintain changes to the superglobal values across scopes,
    be sure to use the same `Request` object throughout the application. Modifications
    to the values in one `Request` object will not be reflected in a different `Request`
    object, except for `$session` values (because they are all references to `$_SESSION`).
  prefs: []
  type: TYPE_NORMAL
- en: What about $GLOBALS?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is one more superglobal that PHP provides: `$GLOBALS`. Using this superglobal
    inside our classes and methods should be treated as a use of the `global` keyword.
    For example, `$GLOBALS[''foo'']` is the equivalent of `global $foo`. We should
    remove it from our classes in just the same way as we do with uses of `global`.'
  prefs: []
  type: TYPE_NORMAL
- en: Review and next steps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, we have removed all `global` calls in our classes, as well as
    all uses of superglobals. This is another big improvement in the quality of our
    codebase. We know that variables can be modified locally and not affect other
    parts of the codebase.
  prefs: []
  type: TYPE_NORMAL
- en: However, our classes may still have hidden dependencies in them. In order to
    make our classes more testable, we need to discover and reveal those dependencies.
    That is the subject of the next chapter.
  prefs: []
  type: TYPE_NORMAL
