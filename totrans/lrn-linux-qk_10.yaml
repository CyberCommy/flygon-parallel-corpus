- en: Analyzing and Manipulating Files
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn various Linux commands that will help you analyze
    and manipulate files. You will learn how to compare two files and get the file
    size. You will also learn how to reveal the type of a file and display the number
    of characters, words, and lines in a file. Furthermore, you will learn how to
    sort files, remove duplicate lines, and much more!
  prefs: []
  type: TYPE_NORMAL
- en: Spot the difference
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can use the `diff` command to compare the contents of two files and highlight
    the differences between them.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate, let’s first make a copy of the file `facts.txt` named `facts2.txt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let’s append the line `"Brazil is a country."` to the file `facts2.txt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, run the `diff` command on both files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Cool! It outputs the difference between the two files, which in this case, is
    the line `Brazil is a country.`
  prefs: []
  type: TYPE_NORMAL
- en: Viewing file size
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can use the `du` command to view file size. **du** stands for **disk usage**.
    If you want to see how many bytes are in a file, you can run the `du` command
    with the `-b` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `facts.txt` file has `210` bytes. One character is equal to one byte in
    size, so now you know that the `facts.txt` file has exactly `210` characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use the `-h` option, which will print the file size in a human-readable
    format. For example, to view the size of the `dir1` directory and its contents,
    you can run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Counting characters, words, and lines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The word count `wc` command is yet another very handy command. It counts the
    number of lines, words, and characters in a file. For example, to display the
    number of lines in the file `facts.txt`, you can use the `-l` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'There are a total of `12` lines in the file `facts.txt`. To display the number
    of words, you can use the `-w` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'So there is a total of `37` words in the file `facts.txt`. To display the number
    of characters (bytes), you can use the `-c` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'There is a total of `210` characters in the file `facts.txt`. Without any options,
    the `wc` command will display the number of lines, words, and characters side
    by side:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Viewing the file type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can determine a file’s type by using the `file` command. For example, if
    you want to determine the type of the file `/var`, you can run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'And as you would expect, the output shows that `/var` is a directory. If you
    want to show the type of the `facts.txt` file, you can run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The output shows that `facts.txt` is an ASCII text file.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT IS ASCII?**'
  prefs: []
  type: TYPE_NORMAL
- en: '**ASCII**, which is short for **American Standard Code for Information Interchange**, is
    a code for representing `128` English characters as numbers, with each letter
    assigned a number from `0` to `127`.'
  prefs: []
  type: TYPE_NORMAL
- en: Your computer doesn’t understand human language (letters), just numbers! And
    so each character in the English language is translated to a number. Your computer
    sees any text file as just a bunch of numbers piled together!
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s create a soft link named `soft.txt` to the `facts.txt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'And run the `file` command on `soft.txt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, it shows that `soft.txt` is a symbolic (soft) link to `facts.txt`.
  prefs: []
  type: TYPE_NORMAL
- en: Sorting files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can use the `sort` command to sort text files. For example, you can view
    the `facts.txt` file in sorted alphabetical order by running the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use the `-r` option to sort in reverse order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: You can also use the `-n` option to sort by numerical values rather than literal
    values.
  prefs: []
  type: TYPE_NORMAL
- en: Showing unique lines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can use the `uniq` command to omit repeated lines in a file. For example,
    notice that the line `Cherries are red.` is included four times in the file `facts.txt`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To view `facts.txt` without repeated lines, you can run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that `Cherries are red.` is still shown twice in the output. That’s
    because the `uniq` command only omits repeated lines but not duplicates! If you
    want to omit duplicates, you have to `sort` the file first and then use a pipe
    to apply the `uniq` command on the sorted output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Boom! We have successfully omitted repeated and duplicate lines.
  prefs: []
  type: TYPE_NORMAL
- en: Searching for patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `grep` command is one of the most popular and useful commands in Linux.
    You can use `grep` to print the lines of text that match a specific pattern. For
    example, if you want to only display the lines that contain the word `green` in
    `facts.txt`, you can run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, it only printed the two lines that contain the word `green`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `grep` command can also be very useful when used with pipes. For example,
    to only list the `txt` files in your home directory, you can run the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use the `-i` option to make your search case-insensitive. For example,
    if you want to print the lines that contain the word `Earth` in `facts.txt`, then
    use the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This will show no result because `grep` is case-sensitive by default. However,
    if you pass the `-i` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: It will make the search case-insensitive, and hence it will display the line
    `Earth is round.`
  prefs: []
  type: TYPE_NORMAL
- en: The stream editor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can use the stream editor command `sed` to filter and transform text. For
    example, to substitute the word `Sky` with the word `Cloud` in `facts.txt`, you
    can run the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the output, the word `Sky` is replaced with `Cloud`. However,
    the file `facts.txt` is not edited. To overwrite (edit) the file, you can use
    the `-i` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the change is reflected in the file.
  prefs: []
  type: TYPE_NORMAL
- en: Translating characters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can use the `tr` command to translate characters. I am not talking about
    translating to different languages here; instead, I am using the second meaning
    of the word translate, that is, to change from one form to another.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you read the `man` page of the `tr` command, you will see in the description
    that it: **Translate[s]**, **squeeze[s]**, **and/or delete[s]** **characters from
    standard input, writing to standard output**. And so the `tr` command doesn’t
    accept any arguments.'
  prefs: []
  type: TYPE_NORMAL
- en: 'One popular use of the `tr` command is to change lower case letters to upper
    case (or vice versa). For example, if you want to display all the words in `facts.txt`
    in upper case, you can run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also display all the words in lower case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use the `-d` option to delete characters. For example, to remove
    all spaces in `facts.txt`, you can run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '**A COOL TIP**'
  prefs: []
  type: TYPE_NORMAL
- en: The `tr` command doesn’t change (edit) the contents of the file. It just writes
    the changes to the standard output. However, you can use output redirection to
    store the output into another file.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, running the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'will store the output of the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: into the file `upper.txt`.
  prefs: []
  type: TYPE_NORMAL
- en: Cutting text
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you want to view only a part (or a section) of a file, then the `cut` command
    can prove very helpful. For instance, you can see that each line in the `facts.txt`
    file consists of several words that are separated by a single space. If you only
    want to view the first word in each line (first column/field), then you can run
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The `-d` option is the delimiter, and it has to be a single character. In this
    case, I chose the delimiter to be the space character `' '`. I also used the `-f1`
    option to view only the first field (column).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to view the third word of each line (third field), then you can
    use `-f3` instead of `-f1` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also select more than one field at a time. For example, to view the
    first and the third word of each line, you can use `-f1,3`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Text processing with awk
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`awk` is a very powerful tool you can use in Linux to analyze and process text.
    In fact, `awk` is not like any command you have learned so far, and that’s because
    `awk` is actually a programming language. You will find books that are solely
    written to explain and discuss the use of `awk`. However, I am only going to show
    you the very basics of `awk` here, and you can dig further on your own.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use `awk` to achieve the same functionality as the `cut` command. For
    example, to view the first word of each line in the file `facts.txt`, you can
    run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice we didn’t need to specify the space character `'' ''` as a delimiter
    as we did with the `cut` command and that’s because `awk` is smart enough to figure
    it out on its own. You can also view more than one field at a time; for example,
    to view the first and the second word of each line, you can run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: One advantage `awk` has over `cut` is that `awk` is smart enough to separate
    the file into different fields even if there is more than one character separating
    each field. The `cut` command only works if the file has a single delimiter like
    a single space, a colon, a comma, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate, create a file named `animals.txt` and insert these four lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Do not edit the format; keep the spaces messed up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Now, if you try to use the `cut` command to only show the third word in each
    line, it will fail because there is more than one space separating each word.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, `awk` is smart enough to figure it out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the third word in each line is displayed. You can also use
    `awk` to search for patterns, just like the `grep` command. For example, to print
    the lines that contain the word `red` in `facts.txt`, you can run the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Wildcard characters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The wildcard characters are special characters in Linux, and they are used
    to specify a group (class) of characters. `Table 13` lists all the Linux wildcards:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Wildcard** | **What it does** |'
  prefs: []
  type: TYPE_TB
- en: '| `*` | Matches any character(s). |'
  prefs: []
  type: TYPE_TB
- en: '| `?` | Matches any single character. |'
  prefs: []
  type: TYPE_TB
- en: '| `[characters]` | Matches the characters that are members of the set characters.
    For example, `[abc]` will match the characters `a`, `b`, or `c`. |'
  prefs: []
  type: TYPE_TB
- en: '| `[!characters]` | Matches any character that is not a member of the set characters.
    It is basically the negation of `[characters]`. For example, `[!abc]` will match
    any character that is not `a`, `b`, or `c`. |'
  prefs: []
  type: TYPE_TB
- en: '| `[[:class:]]` | Matches any character that is a member of the character class.
    |'
  prefs: []
  type: TYPE_TB
- en: 'Table 13: Linux wildcards'
  prefs: []
  type: TYPE_NORMAL
- en: 'You have already seen character classes before when we were discussing the
    `tr` command. Remember `[:lower:]` and `[:upper:]` represent lower and upper case
    letters, these are two examples of character classes. `Table 14` lists the most
    common character classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Character Class** | **What it represents** |'
  prefs: []
  type: TYPE_TB
- en: '| `[:alnum:]` | Represents all the alphanumeric letters, that is, any letter
    or number. |'
  prefs: []
  type: TYPE_TB
- en: '| `[:alpha:]` | Represents all alphabetic letters, that is, any letter. |'
  prefs: []
  type: TYPE_TB
- en: '| `[:digit:]` | Represents all digits, that is, any number. |'
  prefs: []
  type: TYPE_TB
- en: '| `[:lower:]` | Represents any lower case letter. |'
  prefs: []
  type: TYPE_TB
- en: '| `[:upper:]` | Represents any upper case letter. |'
  prefs: []
  type: TYPE_TB
- en: 'Table 14: Character classes'
  prefs: []
  type: TYPE_NORMAL
- en: 'Ok, enough with all that theory! Let’s look at some examples. You can use the
    `*` wildcard to list all the `txt` files in your home directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to list only the filenames that begin with the letter `f`, you
    can use `f*`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to list the filenames that contain three letters followed by a
    `.txt` extension, then you can use the `?` wildcard:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use more than one wildcard at the same time. For example, if you
    want to list only the filenames that begin with the letter `a` or `f`, you can
    use the `[af]` wildcard followed by the `*` wildcard:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use set negations, for example, to list all the `.txt` filenames
    that begin with any letter other than `f`, you can run use `[!f]*`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, before we do some examples of character classes, let’s create the following
    four files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if you want to list the filenames that end with an upper case letter,
    you can use the character class `[:upper:]` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the character class itself is also surrounded by brackets.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to list the filenames that begin with a digit (number), you can
    use the character class `[:digit:]` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: And the only match was the file `7wonders`.
  prefs: []
  type: TYPE_NORMAL
- en: Regular expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up until now, we have been using wildcards with filenames. **Regular expressions**
    (**Regex** for short) is another Linux feature that will allow you to search for
    a specific pattern in text files. Regex is also often used with the `grep` command.
  prefs: []
  type: TYPE_NORMAL
- en: '`Table 15` lists the most common regular expressions and their uses:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Regex** | **What it does** |'
  prefs: []
  type: TYPE_TB
- en: '| `*` | Matches zero or more of the preceding characters or expressions. |'
  prefs: []
  type: TYPE_TB
- en: '| `+` | Matches one or more of the preceding characters or expressions. |'
  prefs: []
  type: TYPE_TB
- en: '| `.` | Matches any single character. Same as the `?` wildcard. |'
  prefs: []
  type: TYPE_TB
- en: '| `^` | Matches the following expression at the beginning of the line. For
    example, `^dog` will match all lines that begin with the word `dog`. |'
  prefs: []
  type: TYPE_TB
- en: '| `$` | Matches the preceding expression at the end of the line. For example,
    `bird$` will match all lines that end with the word `bird`. |'
  prefs: []
  type: TYPE_TB
- en: '| `\` | Used as an escape character to match a special character following
    the backslash. For example, `\*` matches a star (asterisk). |'
  prefs: []
  type: TYPE_TB
- en: '| `[characters]` | Matches the characters that are members of the set characters.
    For example, `[abc]` will match the characters `a`,`b`, or `c`. |'
  prefs: []
  type: TYPE_TB
- en: '| `[^characters]` | Matches any character that is not a member of the set characters.
    It is basically the negation of `[characters]`. For example, `[!abc]` will match
    any character that is not `a`,`b`, or `c`. |'
  prefs: []
  type: TYPE_TB
- en: '| `{x,y}` | Matches `x` to `y` occurrences of the preceding expression. |'
  prefs: []
  type: TYPE_TB
- en: '| `{x}` | Matches exactly `x` occurrences of the preceding expression. |'
  prefs: []
  type: TYPE_TB
- en: '| `{x,}` | Matches `x` or more occurrences of the preceding expression. |'
  prefs: []
  type: TYPE_TB
- en: '| `{,x}` | Matches no more than `x` occurrences of the preceding expression.
    |'
  prefs: []
  type: TYPE_TB
- en: 'Table 15: Regular expressions'
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, that’s a long list of regular expressions. Let’s do some practice with
    them. Create a file named `practice.txt` that contains the following text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: To use regular expressions with the `grep` command, you can either use the `-E`
    option or the `egrep` command. The `egrep` command is simply an alias to `grep
    -E`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, notice that the `***` regex is different from the `***` wildcard. To realize
    the difference, run the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'This will give the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0d507805-036b-437b-a485-843fb7e3717a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1: The * regex'
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that `d*g` didn’t match the word `dog`; instead, it matched with:'
  prefs: []
  type: TYPE_NORMAL
- en: '`g` (zero occurrences of d)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dg` (one occurrence of d)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ddg` (two occurrences of d)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dddg` (three occurrences of d)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That’s because the `** *regex` matches zero or more of the preceding characters
    or expressions, unlike the `*** wildcard`, which matches any character.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to match one or more occurrences of `d` followed by `g`, you can use the
    regex `d+g`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'To match the special character `*`, you can use the backslash between single
    or double quotes as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'To match any pattern that contains the letter `m` followed by any single character,
    then the letter `n`, you can run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'To match the lines that begin with the word `man`, you can run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'To match the lines that end with the word `man`, you can run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use character classes as well. For example, to search for all the lines
    that contain at least one digit, you can run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also search for a specific pattern like telephone numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: This will search for the lines that contain three digits followed by a dash,
    then three digits followed by another dash, then another three digits.
  prefs: []
  type: TYPE_NORMAL
- en: 'I know you think `regex` is complicated, and it’s hard to remember all of that,
    you are right! That’s why there is a `man` page that has all the regular expressions
    we discussed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Also, the `grep` man page includes explanations for all the regular expressions
    discussed in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Knowledge check
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For the following exercises, open up your Terminal and try to solve the following
    tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Display the size (in bytes) of the file `/etc/hostname`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Display only the group names in the file `/etc/group`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Display the total number of lines in the file `/etc/services`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Display only the lines that contain the word "bash" in the file `/etc/passwd`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Display the output of the `uptime` command in all uppercase letters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
