- en: Node.js and MongoDB
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have heard of the **MEAN** stack: MongoDB, Express, Angular, and Node.js,
    or the **MERN** stack: MongoDB, Express, React, and Node.js. The missing piece
    that we have yet to discuss is MongoDB. Let’s explore how this NoSQL database
    can be used directly from Express. We''ll be constructing the next iteration of
    our starship game that we started in [Chapter 13](57b3ea57-b927-47f6-b07e-d1dd11796e1a.xhtml), *Using
    Express*, except this time using MongoDB and incorporating a bit of testing!'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Using MongoDB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing with Jest
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing and retrieving data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wiring your API together
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Be prepared to work with the code provided in the `chapter-18` directory of
    the repository: [https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-18](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-18).
    As we''ll be working with command-line tools, also make sure to have your Terminal
    or command-line shell available. We''ll need a modern browser and a local code
    editor.'
  prefs: []
  type: TYPE_NORMAL
- en: Using MongoDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The base premise behind MongoDB that makes it different from other types of
    structured key/value pair databases is that it''s *schemaless*: you can insert
    arbitrary **documents** of unstructured data without concern for what another
    entry in the database looks like. A document in NoSQL parlance is something already
    familiar to us: a JavaScript object!'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a document:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that it''s a basic JavaScript object; more specifically, it''s JSON,
    which means it can also support nested data. Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'So how does this differ from MySQL? Consider this MySQL schema:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/078e1d97-f520-4a0e-bcfb-bd3bbbc984f9.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 18.1 – An example of a MySQL database table structure
  prefs: []
  type: TYPE_NORMAL
- en: If you're familiar with SQL databases, you know that each field type in a database
    table must be specifically typed. When retrieving from a SQL-type database, we
    use **S****tructured Query Language** (**SQL**). Just as our tables are structured,
    so are our queries.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to create our database tables before using them, and in SQL it''s advised
    not to change their structure once created without doing some additional cleanup
    work. Here''s how we would create our preceding table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now, for MongoDB, we *won't* be constructing tables with predefined datatypes
    and lengths. Instead, we will insert JSON blobs into our database as **documents**.
    The idea behind MongoDB is very similar to when we used Firebase in [Chapter 17](655b37ac-84df-4d2b-abda-b9c88fe9f6f2.xhtml),
    *Security and Keys,* inserting JSON and querying it, even with multiple nested
    JSON objects versus storing, cross-joining, and querying multiple tables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine that we have the following two documents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'How do we insert them into our database? This would be with MySQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The answer with MongoDB is actually much easier than SQL, because we can place
    arrays easily and not have to worry about datatypes or ordering the data! We can
    just shove in the document without worrying about anything else, which is more
    likely to be how we receive it from the frontend:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, for example, to get all active administrators from the preceding `admins` table, we
    would write something like this in MySQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `first_name` and `last_name` fields are pre-defined as type `VARCHAR` (variable
    characters) with a maximum length of 50 characters. `admin_role` and `status`
    are `ENUM` (enumerated types) with predefined possible values (like a dropdown
    selection list on a site). However, here''s how we would construct our query in
    MongoDB:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We won't go *too* deep into MongoDB syntax here as it's a bit out of scope for
    this book and we'll only be using simple queries. With that being said, we should
    understand a bit more before we get started.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the list of mongo commands we''ll use while making our game:'
  prefs: []
  type: TYPE_NORMAL
- en: '`find`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`findOne`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`insertOne`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`updateOne`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`updateMany`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Fairly manageable, right? We can break down many MongoDB commands into the
    following general syntactical structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<dbHandle>.<collectionName>.<method>(query, projection)`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, `query` and `projection` are objects that dictate our usage of MongoDB.
    For example, in our preceding statement, `{ status: ''active'', admin_role: ''admin''
    }` is our query to specify that we want those fields to equal those values. The
    projection in this example specifies what we want to return.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's dive into our project.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first thing we can do is download MongoDB Community Server from [https://MongoDBdb.com](https://mongodb.com).
    When you have it installed, navigate to the `chapter-18/starships` directory from
    our GitHub repository and let''s try to get it started:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: If you have everything installed correctly, you should see a flurry of notification
    messages, ending with one that says something similar to `[initandlisten] waiting
    for connections on port 27017`. If all does *not* go as planned, spend some time
    to ensure your installation is working properly. A useful tool is MongoDB Compass,
    a GUI tool for connecting to MongoDB. Be sure to check permissions and that the
    appropriate ports are open, as we'll use port `27017` (MongoDB's default port)
    for connections.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will be a lab exercise to take our starship game to the next level.
    Here''s what we''ll be building:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/d1e3f192-dd3e-4e85-bfab-0aa9736880b6.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 18.2 – Creating our fleet
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we''re going to wire it to MongoDB and actually execute gameplay in this
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a8cc72ad-3d1c-4b9a-8413-94d1bd2be86b.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 18.3 – Attack the enemy!
  prefs: []
  type: TYPE_NORMAL
- en: We'll be using a simplified version of MERN and using vanilla JavaScript instead
    of React, relying on Express to render our HTML in a less controlled manner than
    React. Maybe *JEMN stack* would be a good name?
  prefs: []
  type: TYPE_NORMAL
- en: Before we get to writing actual code, let's examine the setup of the project
    and get started with testing!
  prefs: []
  type: TYPE_NORMAL
- en: Testing with Jest
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the `starships` directory, you'll find the completed game. Let's dissect
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the directory listing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We're going to take a little bit of a different approach here than our other
    projects and implement a very light cycle of **Test-Driven Development** (**TDD**).
    TDD is the practice of writing tests that *fail*, before writing your code that
    works. While we're not implementing true TDD, the idea of guiding our thought
    process using testing is what we'll be doing.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll be using Jest as our testing framework. Let''s look at the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `tests` directory, create a new file named `test.test.js`. The first
    `test` is the name for our test suite, and the convention of ending files in `.test.js` indicates
    to the testing framework that this is a test suite to execute. Inside the file,
    create this test script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the test with `node_modules/.bin/jest test.test.js` (be sure you''ve already
    run `npm install`!). You''ll get output from the test suite similar to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We've just written our first test suite! It simply says "I expect 1 to equal
    1\. If it does, pass the test. If not, fail the test." Pretty powerful for five
    lines of code, right? OK, maybe not, but this will provide us with the scaffolding
    for all of our other tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the MongoDB model: `models/mongo.js`*:*'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, we''re just setting up our MongoDB connection. Make sure you still
    have your MongoDB connection running now:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'As with all good database connection code, we''re executing our code in a *try/catch*
    block to be sure that our connection is made correctly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Sneak peek: we''re going to be using this `MongoDB.js` file from our tests
    and models. The `module.exports` line specifies which functions are exported from
    this file and exposed to other parts of our program. We''ll be using this export
    directive consistently throughout our program: when we want to expose a method,
    we''ll use an export.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Return to `test.test.js` and include our MongoDB model at the beginning of
    the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s get a little fancier with our test suite. Augment the suite with
    the following code *inside* our `describe` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'And add the following case after our simple test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Then run it with the same command as before: `node_modules/.bin/jest test.test.js`.
  prefs: []
  type: TYPE_NORMAL
- en: What's happening here? First of all, before every individual test in our test
    suite, we're specifying to connect to the database as per the method we wrote
    in our MongoDB model. After everything is done, tear down the database and disconnect.
  prefs: []
  type: TYPE_NORMAL
- en: And what happens when we run it? An epic failure!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We should be expecting an error because we haven''t yet *inserted* any information
    into a collection named `names` (or any other data!). Welcome to TDD: we wrote
    a test that fails before we wrote the code to make it pass.'
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, our next step in the process is to actually insert some data! Let's
    do that.
  prefs: []
  type: TYPE_NORMAL
- en: Storing and retrieving data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s work with a test suite that I wrote to help make sure that our MongoDB
    connection is a bit more robust and includes inserting data into the database
    and then testing to be sure it exists:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Examine `test/setup.model.test.js`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run `node_modules/.bin/jest setup`, we''ll see success because the `insertRandomNames()`
    method exists from our setup model. So let''s take a look at our setup model (`models/setups.js`)
    and see what it''s doing to populate the database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Not too bad! We have one exported method that inserts names into the database
    based on a JSON file of "random" starship names that I''ve provided. The file
    is read and then put into the database as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Since we're not getting too far into the guts of MongoDB itself, suffice to
    say that this line translates to "in the `names` collection (even if it doesn't
    yet exist), set the `names` key to equal the JSON. Update or insert as necessary".
  prefs: []
  type: TYPE_NORMAL
- en: We can now populate our database with ship names that we'll use from here on
    out. Execute `npm run install-data`.
  prefs: []
  type: TYPE_NORMAL
- en: So far, so good! There are many files in this project, so we won't walk through
    *all* of them; let's examine a representational sample.
  prefs: []
  type: TYPE_NORMAL
- en: Models, views, and controllers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Model-View-Controller** (**MVC**) paradigm is what we're using here within
    Express. While not really necessary in Express, I find the logical separation
    of concerns is useful and easier to work with than monolithic types of undifferentiated
    files. Before we go too far, I will mention that MVC could be considered an outdated
    pattern, as it does create some additional dependencies between layers. With that
    being said, the ideas behind an architectural paradigm that separates logic into
    discrete actors are sound in MVC. You may hear **MV*** used instead, which basically
    should be read as "model, view, and whatever that binds them together." MV* is
    more popularly used these days in certain frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: 'The MVC construction separates the logic of the program into three parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Models** deal with data interaction.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Views** handle the presentation layer.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Controllers** handle data manipulation and serve as the glue between the
    models and the views.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here''s a visual representation of the design pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/6dc14b9e-b9c3-44da-bcc4-8f344c7fdb12.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 18.4 – The MVC paradigm's lifecycle
  prefs: []
  type: TYPE_NORMAL
- en: One of the more important parts to understand about this separation of concerns
    is that the View layer and the Controller layer are *never* supposed to interact
    directly with the Datastore; that honor is reserved for the models.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s look at a view:'
  prefs: []
  type: TYPE_NORMAL
- en: '*views/index.hbs*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Express is controlling our views, and we''re using Handlebars to handle our
    templating logic and loops. While simple in syntax, Handlebars is powerful and
    can greatly simplify our lives. In this case, we''re testing for and looping over
    the `ships` variable in order to create a table of the `ships` we have or to send
    a message that the fleet is empty. How does our view get `ships`? It''s given
    to the view from our **controller** by way of our **route**. Here''s what that
    looks like for this portion:'
  prefs: []
  type: TYPE_NORMAL
- en: '*routes/index.js*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Why are we using `var` here instead of `const` or `let`? And why the semicolons?
    The answer is this: at the time of writing, the Express scaffolding tool still
    uses `var` and semicolons. It''s always a best practice to standardize, but in
    this example I wanted to call attention to this fact. Feel free to standardize
    on the newer syntax as we work forward.'
  prefs: []
  type: TYPE_NORMAL
- en: 'And now for the `getFleet` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*controllers/ships.js*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Because this is a simple example, our controller doesn''t do much besides getting
    information from the model, which queries MongoDB. Let''s take a look at that:'
  prefs: []
  type: TYPE_NORMAL
- en: '*models/ships.js*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The setup function dictates the connection to MongoDB (note the async/await
    setup!) and our fleet is either from the enemy or our fleet collection. The `return`
    line contains a convenience to sort the fleet by alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we're going to keep the controllers fairly simple and rely
    on the model to do the heavy lifting. This is a stylistic decision, though it's
    good to pick one side of the application to do the majority of your work.
  prefs: []
  type: TYPE_NORMAL
- en: It's time to look at the program from end to end.
  prefs: []
  type: TYPE_NORMAL
- en: Wiring your API together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To further understand the gameplay, we''ll walk through the steps involved
    in firing a torpedo from a ship:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Locate the frontend JavaScript in `public/javascripts/play.js`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we''ve made a click handler on the `fire` buttons in our interface and
    identified our weapon and target ship:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This line might take a bit of unpacking. We''re making an AJAX call to our
    Node application from our JavaScript with certain query string parameters: `attacker`,
    `target`, and `weapon`. We''re also expecting JSON to be returned from our application.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember that our backticks allow us to *compose* a string with variables in `${
    }`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We're using **object destructuring** to extract each piece of the information
    contained within `data.target`. This is a bit more efficient than defining them
    one by one or even with a loop, right?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Our target ship has been destroyed if `scuttled` is `true`, so let''s communicate
    that to the user. We''re going to edit the values of our ship in either case:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'So that''s the frontend code. If we look at our `app.js` file, we can see that
    our AJAX call to `/play` goes to the `playRouter` from an `app.use` statement.
    Therefore, our next stop is the router:'
  prefs: []
  type: TYPE_NORMAL
- en: '*routes/play.js*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Since our URL was constructed from `/play/fire`, we know that the second `router.get`
    statement is the one handling our request. Onward to the controller and its `fire`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*controllers/ships.js*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we see the glue between the controller and the model.
    First of all, we''re getting the target and source ships. Why do you think I decided
    to use `let` for the target and `const` for the source? If you reasoned that the
    target will need to be mutable, you''re right: when we use the `registerDamage`
    method on our target, it''ll be more efficient to rewrite the variable instead
    of creating a new one.'
  prefs: []
  type: TYPE_NORMAL
- en: Before we look at our model's `registerDamage` method, acknowledge that the
    return path so far is that the controller will return to the route that returns
    to our frontend script.
  prefs: []
  type: TYPE_NORMAL
- en: Onward!
  prefs: []
  type: TYPE_NORMAL
- en: '*models/ships.js*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Now *here* is where we're actually communicating with our database. We can see
    that we're retrieving our target, registering damage to its shields and possibly
    its hull, setting those values in MongoDB, and eventually returning the target
    ship's information back through the controller to eventually arrive at our frontend
    JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: We're going to update one item in the collection to state whether it's an enemy
    ship or in our fleet, and set the shield strength and hull damage.
  prefs: []
  type: TYPE_NORMAL
- en: Exporting functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By now you may have noticed that some of the model methods, such as `registerDamage`,
    are prefaced with `exports` while others, such as `eliminateExistingShips`, are
    not. One aspect of good design in complex JavaScript applications is encapsulating
    the functions that are not designed to be used outside of a certain context. When
    prefaced with `exports`, a function can be invoked from a different context, such
    as from our controller. If it's not designed to be exposed to the rest of the
    application; in essence, it's a private function. The concept of exporting a variable
    is similar to the concept of scope in that we're making sure to keep our application
    clean and expose only the useful bits of the program.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we take a look at `eliminateExistingShips`, we can see it''s just a helper
    function used by `createRandom` to make sure we''re not assigning the same ship
    registry number or name to two different ships. We can see this usage here in
    `createRandom`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '*more code... then:*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: To make sure that our ship's registry number is unique to our fleet, we'll use
    a `while` loop to keep updating the ship's registry number until it's not one
    that already exists. Using the `eliminateExistingShips` helper function, we return
    and destructure the names and registries that already exist in our fleet so that
    we do not create duplicate registries.
  prefs: []
  type: TYPE_NORMAL
- en: 'We haven''t used `while` loops often, as they are often blocking points in
    a program and can be easily misused. With that being said, this is a good use
    case for a `while` loop: it ensures that our program cannot continue unless the
    ship''s registry is unique. With a randomization multiplier of 10,000, it''s unlikely
    that a duplicate random registry will be generated twice in a row, or more, so
    a `while` loop is appropriate.'
  prefs: []
  type: TYPE_NORMAL
- en: So, to export or not to export, that is the question. The answer depends on
    whether we need to use the function outside of its immediate scope. If there's
    no use for the function in another part of the program, then we shouldn't export
    it. In this case, our need to identify whether a ship's details already exist
    in the fleet is really only useful in our `ships` model, so we'll refrain from
    exporting it.
  prefs: []
  type: TYPE_NORMAL
- en: Improving our program
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As you read through the `ships` model and controller, I''m sure you can find
    areas for improvement. For example, the way I''ve written the switches for understanding
    whether the ship was in our fleet or the enemy fleet is a bit rigid: it wouldn''t
    be able to accommodate three separate fleets in one battle. Every programmer creates
    **technical debt**, or small errors or inefficiencies in code. This then necessitates
    **refactoring**, the practice of altering code to make it better. Don''t be fooled
    into thinking you''ve ever written *The Perfect Program*—such a thing does not
    exist. Improvement and continual iteration are part of the programming process.'
  prefs: []
  type: TYPE_NORMAL
- en: There is a major caveat to refactoring, however, and that's something often
    called a **contract**. When designing a backend designed to be used by the frontend,
    and when different parties are writing different parts of a system, it's important
    to be in sync with each other and the premise and needs of the program as a whole.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take, for example, our frontend JavaScript code. If we enumerate the
    endpoints it''s using, we''ll see four endpoints being used:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/ships`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '``/ships/${e.currentTarget.closest(''tr'').dataset.ship}``'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '``/ships/random``'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/play/fire?attacker=${e.target.closest(''td'').dataset.attacker}&target=${target}&weapon=${weapon}``'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At a minimum, when we refactor our backend code, we should assume a contractual
    obligation to change neither the path of these endpoints nor the expectation of
    datatype(s) to be received.
  prefs: []
  type: TYPE_NORMAL
- en: One way we can help make our code more future-proof is *inline documentation*
    using a loose standard called JSDoc. The creation of documentation from code comments
    is a long-standing practice and comment structures exist for many languages in
    order to facilitate a standard. In cases such as APIs, often a helper program
    is run against the source code to generate standalone documentation, often as
    a small HTML/CSS microsite. You may have encountered unrelated programs with similarly
    styled online documentation. There's a good possibility those unrelated documentation
    sites were generated from code by the same mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: 'Why is this important in a chapter about MongoDB? Well, documentation isn''t
    only a need for database usage; rather, it is important when creating any type
    of program that has multiple moving parts. Consider the last endpoint in the preceding
    list: `/play/fire?attacker=${e.target.closest(''td'').dataset.attacker}&target=${target}&weapon=${weapon}``.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The fire endpoint takes three parameters: `attacker`, `target`, and `weapon`.
    But what are those parameters? What do they look like—are they objects? Strings?
    Booleans? Arrays? Additionally, if we''re going to accept user-generated data,
    we need to be a bit more careful than we have been, because of **GIGO**: **Garbage
    In, Garbage Out**. If we populate our database with bad data, the best we can
    expect is a broken program. In fact, the worst we can expect is a security **compromise**:
    the leaking of database or server credentials or malicious code execution. Let''s
    talk about security.'
  prefs: []
  type: TYPE_NORMAL
- en: Security
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you''re familiar with SQL, you may be familiar with a security vulnerability
    known as **SQL Injection**. Good information on web application security best
    practices can be found at [owasp.org](http://owasp.org). The **Open Web Application
    Security Project** (**OWASP**) is a community-driven initiative to catalog and
    educate users on the security vulnerabilities present in web applications in order
    that we can more effectively combat against malicious hackers. If you''ve ever
    had your email, social account, or website hacked, you know the pain that ensues—digital
    identity theft. OWASP''s listing for SQL injection is here: [https://owasp.org/www-community/attacks/SQL_Injection](https://owasp.org/www-community/attacks/SQL_Injection).'
  prefs: []
  type: TYPE_NORMAL
- en: So why are we talking about SQL if we're using a NoSQL database in the form
    of MongoDB? Because *SQL injection doesn't exist in MongoDB*. "GREAT!", you might
    say, "My security woes are solved!" This, unfortunately, is not the case. Coupled
    with the idea of refactoring to improve efficiency of an application, refactoring
    to mitigate security intrusion vectors is an important part of being responsible
    for a web application. I've worked at a company that was hacked—and it was because
    of less than five characters placed into a URL. This enabled a hacker to break
    the operation of the web application and perform arbitrary SQL commands. Sanitizing
    and refactoring for security all user-generated content is an essential part of
    web security. Now, we haven't done that for this application because I trust you're
    not going to hack your own machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Wait. Didn''t I just say that SQL injection doesn''t exist with MongoDB? Yes,
    and NoSQL databases have their equivalent method of attack: **code and command
    injection**. Because we haven''t sanitized, or verified the integrity of, our
    user input, it''s possible for our application to store and use arbitrary code
    that''s been submitted and stored in our database. While a full primer on JavaScript
    security is not within scope of this book, do keep it in mind. The long story
    short is to sanitize, or verify the validity of, your user-generated input.'
  prefs: []
  type: TYPE_NORMAL
- en: And with that, let's wrap up this chapter. Just remember to stay safe when writing
    MongoDB applications in the wild!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JavaScript doesn't exist in isolation! MongoDB is a great companion to JavaScript
    as it is designed to be object-oriented and relies on a JavaScript-friendly querying
    syntax. We've learned the principles behind TDD, worked with the MVC paradigm,
    and expanded our game a bit more.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with all coding exercises, be sure to consider the use cases when using
    a database such as MongoDB: while MongoDB''s syntax isn''t vulnerable to SQL injections,
    it is still vulnerable to other types of injections that can compromise your application.'
  prefs: []
  type: TYPE_NORMAL
- en: Hopefully, our starship game is interesting enough for you to keep developing
    it. Our next (and final) chapter wraps together our principles of JavaScript development
    and polishes our game.
  prefs: []
  type: TYPE_NORMAL
