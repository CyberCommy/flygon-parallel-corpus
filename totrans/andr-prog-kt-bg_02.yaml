- en: Chapter 2. Kotlin, XML, and the UI Designer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At this stage, we have a working Android development environment and we have
    built and deployed our first app. It is obvious, however, that code autogenerated
    by Android Studio is not going to make the next top-selling app on Google Play.
    We need to explore this autogenerated code so that we can begin to understand
    Android and then learn how to build on this useful template. With this aim in
    mind, we will do the following in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: See how to get technical feedback from our apps.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examine the Kotlin code and **User Interface** (**UI**) XML code from our first
    app.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get our first taste of using the Android UI designer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write our first Kotlin code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn some core Kotlin fundamentals and how they relate to Android.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First, let's see how to get feedback from our apps.
  prefs: []
  type: TYPE_NORMAL
- en: Examining the log output
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we mentioned that our app was running in debug mode
    on the emulator or real device; this is so that we can monitor it and get feedback
    when things go wrong. So, where is all this feedback?
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed a lot of scrolling text at the bottom of the Android
    Studio window. If not, click on the **logcat** tab, as shown by the highlighted
    area labeled as **1** in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Note that the emulator must be running, or a real device must be attached in
    debugging mode, for you to see the following window. Furthermore, if you restarted
    Android Studio for some reason and have not yet executed the app, then the **logcat**
    window will be empty. Refer to the first chapter to get the app running on an
    emulator or a real device:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Examining the log output](img/B12806_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can drag the window to make it taller, just as you can in most other Windows
    applications, if you want to see more.
  prefs: []
  type: TYPE_NORMAL
- en: This window is called **logcat**, or, sometimes, it is referred to as **console**.
    It is our app's way of telling us what is going on underneath what the user sees.
    If the app crashes or has errors, the reason or clues will appear here. If we
    need to output debugging information, we can do so here as well.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you just cannot work out why your app is crashing, copying and pasting a
    bit of the text from logcat into Google will often reveal the reason.
  prefs: []
  type: TYPE_NORMAL
- en: Filtering the logcat output
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You might have noticed that most, if not all, of the content of logcat is almost
    unintelligible. That's OK; right now, we are only interested in errors that will
    be highlighted in red and the debugging information that we will learn about next.
    In order to see less of the superfluous text in our **logcat** window, we can
    turn on some filters to make things clearer.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous screenshot, I highlighted two more areas, as **2** and **3**.
    Area **2** is the drop-down list that controls the first filter. Left-click on
    it now and change it from **Verbose** to **Info**. We have cut down the text output
    significantly. We will see how this is useful when we have made some changes to
    our app and redeployed it. We will do this after we have explored the code and
    the assets that make up our project. Also, double-check that the area labeled
    as **3** says **Show only the selected application**. If it doesn't, left-click
    on it and change it to **Show only the selected application**.
  prefs: []
  type: TYPE_NORMAL
- en: Now we can look at what Android Studio has automatically generated for us, and
    then we can set about changing and adding to the code to personalize it beyond
    what we got from the project creation phase.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the project's Kotlin code and the main layout's XML code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are going to look at the resource files containing the code that defines
    our simple UI layout and the file that has our Kotlin code. At this stage, we
    won't try to understand it all, as we need to learn some more basics before it
    makes sense to do so. What we will see, however, is the basic content and structure
    of both files, so we can reconcile their content with what we already know about
    Android resources and Kotlin.
  prefs: []
  type: TYPE_NORMAL
- en: Examining the MainActivity.kt file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s take a look at the Kotlin code first. You can see this code by left-clicking
    on the `MainActivity.kt` tab, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Examining the MainActivity.kt file](img/B12806_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As we are not looking at the intricate details of the code, an annotated screenshot
    is more useful than reproducing the actual code in text form. Regularly refer
    to the following screenshot while reading this section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Examining the MainActivity.kt file](img/B12806_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The first thing to note is that I have added a few empty lines in among the
    code to space things out and present a clearer image.
  prefs: []
  type: TYPE_NORMAL
- en: Code folding (hiding) in Android Studio
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, look at the left-hand side of the window in Android Studio (not the preceding
    screenshot) and observe all the **+** and **-** buttons on the left-hand side
    of the editor that can collapse and expand parts of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Code folding (hiding) in Android Studio](img/B12806_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: I have collapsed some parts of the code, and have left other parts visible.
    So, what you can see on your screen is slightly different to what you will see
    if you look at the preceding screenshot. In Android Studio, play with the **+**
    and **–** buttons for a while to practice hiding and unhiding sections of the
    code. You might be able to get your screen to look like the preceding screenshot,
    but this is not a requirement to continue. The technical term for hiding code
    like this is called **folding** .
  prefs: []
  type: TYPE_NORMAL
- en: The package declaration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Part **1** is called the **package declaration** and, as you can see, it is
    the package name that we chose when we created the project, preceded by the word
    `package`. Every Kotlin file will have a package declaration at the top.
  prefs: []
  type: TYPE_NORMAL
- en: Importing classes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Part **2** is six lines of code that all begin with `import`. After `import,`
    we can see there are various dot-separated words. The last word of each line is
    the name of the class that line imports into our project, and all the earlier
    words in each line are the packages and subpackages that contain these classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, this next line imports the `AppCompatActivity` class from the
    `androidx.appcompat.app` package and subpackages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This means that in our project, we will have access to these classes. In fact,
    it is these classes that the autogenerated code uses to make our simple app, which
    we saw in action in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We will not discuss all of these classes in this chapter. It is just the idea
    that we can do this importing of classes that gives us access to more functionality
    that is significant right now. Note that we can add extra classes from any package
    at any time, and we will do so when we improve upon our app shortly.
  prefs: []
  type: TYPE_NORMAL
- en: The class declaration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Part **3** of our code is called the **class declaration**. Here is that line
    in full; I have highlighted one part of it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The class declaration is the start of a class. Notice that the highlighted part,
    `MainActivity`, is the name that was autogenerated when we created the project
    and is also the same as the `MainActivity.kt` filename. This is as we would expect,
    having discussed Kotlin classes previously.
  prefs: []
  type: TYPE_NORMAL
- en: The colon (`:`) means that our class called `MainActivity` will be of the type
    `AppCompatActivity`. This indicates that although there are not that many lines
    of code in this file, we are also using more code that we don't see that comes
    from the `AppCompatActivity` class. All this and more will become clear in [Chapter
    10,](ch10.html "Chapter 10. Object-Oriented Programming") *Object-Oriented Programming*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, for part **3**, look at the opening curly brace at the end of the
    line: `{`. Now look at the bottom of the screenshot at part **4** of our code.
    This closing curly brace (`}`) denotes the end of the class. Everything in between
    the opening and closing curly braces, `{...},` is part of the class.'
  prefs: []
  type: TYPE_NORMAL
- en: Functions inside the class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now look at part **5** of the code. Here is that line of code in full, with
    the key part for our current discussion highlighted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This is a function **signature**. The highlighted part, `onCreate`, is the function
    **name**. The Kotlin `fun` keyword makes it clear that this is the start of a
    function. We make a function execute its code by using its name. We say we are
    **calling** a function when we do this.
  prefs: []
  type: TYPE_NORMAL
- en: Although we will not concern ourselves now with the parts of the code on either
    side of the function name, you might have noticed `Bundle`, one of the classes
    that we imported in part **2** of our code. If we remove that related `import`
    line, Android Studio will not know what the `Bundle` class is, and it will be
    unusable and highlighted in red underline as an error.
  prefs: []
  type: TYPE_NORMAL
- en: Our code will then not compile and run. Notice that the very last thing in the
    line of the preceding code is an opening curly brace (`{`). This denotes the start
    of the code contained within the `onCreate` function. Now jump to part **6** of
    our code and you will see a closing curly brace (`}`). You might have guessed
    that this is the end of the function. Everything in between the opening and closing
    curly braces of the `onCreate` function is the code that executes when the function
    is called.
  prefs: []
  type: TYPE_NORMAL
- en: We do not need to go into what this code does yet but, as an overview, it sets
    up the appearance and layout of the app by referring to some resource files that
    were autogenerated by Android Studio when we created the project. I have highlighted
    these resource files with an outline in the previous screenshot labeled **9**.
  prefs: []
  type: TYPE_NORMAL
- en: Parts **7** and **8** are also functions that I have collapsed to make the screenshot
    and this discussion more straightforward. Their names are `onCreateOptionsMenu`
    and `onOptionsItemSelected`.
  prefs: []
  type: TYPE_NORMAL
- en: We know enough about our Kotlin code to make some progress. We will see this
    code again and change it later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: A summary of the Kotlin code so far
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is true that, contained within the preceding code, there is some complex
    syntax. However, what we are doing is building up just enough knowledge about
    this code, so that we can work within it and begin to make rapid progress in learning
    Kotlin and Android without having to read hundreds of pages of Kotlin theory first.
    By the end of the book, all the code will make sense. But in order to make quick
    progress now, we just need to accept that some of the details will remain a mystery
    for a little while longer.
  prefs: []
  type: TYPE_NORMAL
- en: Examining the main layout file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now we will look at just one of the many `.xml` files. There are several different
    layout files and we will meet them all throughout the course of this book, but
    let's start with the most significant one that decides the appearance of our app.
  prefs: []
  type: TYPE_NORMAL
- en: Left-click on the `content_main.xml` tab next to the `MainActivity.kt` tab that
    we have been discussing.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the main window on the right-hand side, you will see the **Design** view
    of our app, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Examining the main layout file](img/B12806_02_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Most of the work that we do throughout the book when we design apps will be
    done in this design view. It is important, however, to know what is going on behind
    the scenes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The design view is a graphical representation of the XML code contained in
    the `content_main.xml` file. Click on the **Text** tab (as outlined near the bottom-left
    in the previous screenshot) to see the XML code that forms the layout. I have
    annotated a screenshot of the XML text so that we can discuss it next:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Examining the main layout file](img/B12806_02_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The first thing to note is that this file does not represent the entire layout.
    It does, however, represent most of the surface area and the **Hello World** message
    in the center. Also, on the left-hand side, we can see the now familiar **+**
    and **–** icons so that we can fold and unfold sections of the code.
  prefs: []
  type: TYPE_NORMAL
- en: UI layout elements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If we first look at the part of the code labeled **1**, we can see that the
    very first thing is `…ConstraintLayout...`. A `ConstraintLayout` element is a
    UI element that is used to wrap other parts of the UI.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are more technical and specific ways to refer to the different "elements"
    of our user interface designs. As we progress, we will introduce terminology such
    as widget, view, and view-group, as well.
  prefs: []
  type: TYPE_NORMAL
- en: When we add a new element to a UI in Android, we always start a line with a
    left angle bracket (`<`) followed by the element's name.
  prefs: []
  type: TYPE_NORMAL
- en: The code that follows this rather long and cumbersome-looking line defines the
    **attributes** that this element will have. This can include dozens of different
    things, depending upon the type of UI element it is. Here, among a bit of other
    XML, we can see things such as `layout_width`, `layout_height`, and `showIn`.
    All these attributes define how the `ConstraintLayout` element will appear on
    the user's screen. The attributes for the `ConstraintLayout` element end at the
    first right angle bracket (`>`), labeled **1b**.
  prefs: []
  type: TYPE_NORMAL
- en: If we look at the bottom of our XML screenshot, we will see the code labeled
    **2**. This code, `</…ConstraintLayout>`, marks the end of the `ConstraintLayout`
    element Anything in between the closing right angle bracket (`>`) of the element's
    attributes and the `</…ConstraintLayout>` code that defines its end is considered
    a **child** of the element. So, we can see that our `ConstraintLayout` element
    has (or contains) a child. Let's take a look at that child now.
  prefs: []
  type: TYPE_NORMAL
- en: UI text elements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Using what we have just learned, we can devise that the UI element that starts
    at position **3** in the screenshot is called a `TextView` element. Just like
    its parent, it starts with a left angle bracket (`<`) and its name: `<TextView...`.
    If we look further into our `TextView` element, we can see that it has several
    attributes. It has a `text` attribute that is set to `"Hello world!"`. This, of
    course, is the exact text that our app shows to the user. It also has `layout_width`
    and `layout_height` attributes that are both set to `"wrap_content"`. This tells
    the `TextView` element that it can take up as much space as the content it has
    needs, but no more. As we will see throughout the book, there are many more attributes
    available for this and other UI elements.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that the code at the **4** position on our XML screenshot is `/>`. This
    marks the end of the `TextView` element. This is slightly different to how the
    end of the `ConstraintLayout` element was written. When an element in XML has
    no children, we can just end it like this: `/>`. When the element has children
    and its end comes further on in the code from where its attributes are defined,
    it is much clearer to end the element by repeating its name like this: `</…ConstraintLayout>`.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You might be wondering why the element name for the `TextView` element is short
    and concise (simply, `TextView`), yet the full name for the `ConstraintView` element
    is preceded by apparent complicated clutter (`androidx.constraintlayout.widget.ConstraintLayout`).
    This `ConstraintLayout` element is a special version of the layout that is used
    to ensure our app's compatibility with older versions of Android. As we will see
    in a minute, when we add buttons to the app, most elements have simple and concise
    names.
  prefs: []
  type: TYPE_NORMAL
- en: We will edit this code in the next section and learn more about the attributes,
    as well as explore another type of UI element – that is, a `Button` element.
  prefs: []
  type: TYPE_NORMAL
- en: Adding buttons to the main layout file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here, we will add a couple of buttons to the screen and will then explore a
    quick way to make them do something. We will add a button in two different ways;
    first, using the visual designer, and second, by adding to and editing the XML
    code directly.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a button via the visual designer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To get started adding our first button, switch back to the design view by clicking
    on the **Design** tab underneath the XML code that we have just been discussing.
    The button is highlighted in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a button via the visual designer](img/B12806_02_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Notice that in the left-hand side of the layout, we have a window that is called
    **Palette**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a button via the visual designer](img/B12806_02_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The palette window is divided into two parts. The left-hand list has the categories
    of the UI elements and allows you to select a category, while the right-hand side
    shows you all the available UI elements from the currently selected category.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure that the **Common** category is selected, as shown in the previous
    screenshot. Now, left-click and hold on the **Button** widget, and then drag it
    onto the layout somewhere near the top and center.
  prefs: []
  type: TYPE_NORMAL
- en: 'It doesn''t matter if it is not exact; however, it is good to practice to get
    it right. So, if you are not happy with the position of your button, then you
    can left-click on it to select it on the layout and then tap the *Delete* key
    on the keyboard to get rid of it. Now you can repeat the previous step until you
    have one neatly placed button that you are happy with, as demonstrated in the
    following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a button via the visual designer](img/B12806_02_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At this point, we can run the app on the emulator or on a real device, and the
    button will be there. If we click on it, there will even be a simple animation
    to represent the button being pressed and released. Feel free to try this now
    if you like.
  prefs: []
  type: TYPE_NORMAL
- en: To start making the app more interesting, we are going to edit the attributes
    of our button using the **Attributes** window.
  prefs: []
  type: TYPE_NORMAL
- en: Editing the button's attributes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Make sure the button is selected by left-clicking on it. Now find the **Attributes**
    window to the right of the editing window, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Editing the button''s attributes](img/B12806_02_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding screenshot, you can see that we have access to some, although
    not all, of the button's attributes. To reveal more of the attributes, click on
    the **View all attributes** link (indicated in the preceding screenshot).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you can see the full details of the button and we can set about editing
    it. It might seem surprising to see the substantial number of attributes that
    something as apparently simple as a button has. This is a sign of the versatility
    and power that the Android API provides for UI manipulation. Look at the following
    screenshot that shows the full attributes list for our recently added button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Editing the button''s attributes](img/B12806_02_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Furthermore, notice that even the previous screenshot doesn't show everything,
    and you can use the scroll bar on the right of the **Attributes** window to reveal
    even more attributes.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, there is a large array of different attributes that we can
    edit right here in the UI designer. In [Chapter 12](ch12.html "Chapter 12. Connecting
    Our Kotlin to the UI and Nullability"), *Connecting our Kotlin to the UI and Nullability*,
    we will also edit and manipulate these attributes using our Kotlin code. For now,
    we will edit just one attribute. Scroll down the **Attributes** window until you
    see the **onClick** attribute and then left-click on it to select it for editing,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Editing the button''s attributes](img/B12806_02_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The attributes are in alphabetical order and **onClick** can be found about
    two thirds of the way down the lengthy list.
  prefs: []
  type: TYPE_NORMAL
- en: Type `topClick` in the **onClick** attribute's edit box and press *Enter* on
    the keyboard. Be sure to use the same case, including the slightly counterintuitive
    lowercase `t` and upper-case `C`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Attributes** window will look like the next screenshot when you are done:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Editing the button''s attributes](img/B12806_02_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: What we have done here is named the Kotlin function in our code that we want
    to call (or execute) when this button is clicked on by the user. The name is arbitrary
    but, as this button is on the top part of the screen, the name seems meaningful
    and easy to remember. The odd casing that we used is a convention that will help
    us to keep our code clear and easy to read. We will see the benefits of this as
    our code gets longer and more complicated.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, the `topClick` function doesn't exist yet. Android Studio is very
    helpful, but there are some things that we need to do for ourselves. We will write
    this function using Kotlin code after we have added a second button to our UI.
    You can run the app at this point, and it will still work, but if you click on
    the button, the app will crash and you will get an error message, because the
    function does not exist.
  prefs: []
  type: TYPE_NORMAL
- en: Examining the XML code for the new button
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we add our final button for this project, click on the **Text** tab
    underneath the editor to switch back to seeing the XML code that makes our UI:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Examining the XML code for the new button](img/B12806_02_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Notice that there is a new block of code amongst the XML code that we examined
    earlier. Here is a screenshot of the new block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Examining the XML code for the new button](img/B12806_02_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Notice the following details, which should correspond to what we know about
    XML and Android UI elements:'
  prefs: []
  type: TYPE_NORMAL
- en: The new code starts with the `<Button` text and ends with `/>.`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The new code has a range of attributes that define the button, including `layoutWidth`
    and `layoutHeight.`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code includes the `onClick` attribute that we added with a value of `"topClick".`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `topClick` value of the `onClick` attribute is underlined in red, showing
    an error because the function does not exist yet.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The start and end of the code representing the button is enclosed within the
    `ConstraintLayout` element.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `dp` is a unit of measurement/distance and will be discussed in more depth
    in [Chapter 5](ch05.html "Chapter 5. Beautiful Layouts with CardView and ScrollView"),
    *Beautiful Layouts with CardViewand ScrollView*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hover the mouse cursor over the underlined `topClick` value to reveal the details
    of the problem, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Examining the XML code for the new button](img/B12806_02_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We can confirm that the issue is that Android Studio expects a function called
    `topClick` to be implemented within our code. We will do this as soon as we have
    added that second button.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a button by editing the XML code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just for variety, and to prove that we can, we will now add another button using
    only the XML code, and not the UI designer. Most of the time, we will use the
    UI designer, but this quick exercise should cement the relationship between the
    UI designer and the underlying XML code in your mind.
  prefs: []
  type: TYPE_NORMAL
- en: We will achieve this by copying and pasting the code for the existing button.
    We will then make some minor edits to the pasted code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Left-click just before the button code that starts `<Button`. Notice that the
    beginning and end of the code now has a slight highlight:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a button by editing the XML code](img/B12806_02_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This has identified the part of the code that we want to copy. Now, left-click
    and drag to select all the button code, including the highlighted start and end,
    as shown in the next screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a button by editing the XML code](img/B12806_02_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Press the *Ctrl* + *C* keyboard combination to copy the highlighted text. Place
    the cursor below the existing button code and tap the *Enter* key a few times
    to leave some additional empty lines.
  prefs: []
  type: TYPE_NORMAL
- en: 'Press the *Ctrl* + *V* keyboard combination to paste the button code. At this
    point, we have two buttons; however, there are a couple of problems:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a button by editing the XML code](img/B12806_02_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We have an additional error in both blocks of code that represent our buttons.
    The `id` attribute (in both blocks) is underlined in red. The reason for this
    error is that both buttons have an `id` attribute that is the same. The `id` attribute
    is supposed to distinguish a UI element from all other UI elements, so they must
    not be the same. Let's try and fix that.
  prefs: []
  type: TYPE_NORMAL
- en: Giving the buttons unique id attributes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We could solve the problem by calling the second button as `button2,` but it
    will be more meaningful to change them both. Edit the code in the first button
    to give it an `id` attribute of `buttonTop`. To do so, identify this following
    line of code (in the first button):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, change the line of code to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Notice the lowercase `b` in `button` and the uppercase `T` in `Top`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now identify this line of code in the second button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, change the line of code to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The errors on the `id` attribute lines are gone. At this point, you might think
    that we can move on to solving our missing function problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if you run the app and take a quick glance at it, you will see that
    we only appear to have one button. Not only that, but the buttons are not in the
    places that we expected them to be in, either:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Giving the buttons unique id attributes](img/B12806_02_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The reason for this is that we haven't explicitly positioned them, so they have
    defaulted to the top-left of the screen. The position we see on the **Design**
    tab is just a design-time position. So, let's change that now.
  prefs: []
  type: TYPE_NORMAL
- en: Positioning the two buttons in the layout
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The reason we can only see one button is that both buttons are in the same
    position. The second button is exactly covering the first button. So, even in
    the **Design** tab (feel free to take a look), the buttons are still sat on top
    of each other, although they are in the middle of the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Positioning the two buttons in the layout](img/B12806_02_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You might be wondering why the UI layout tool was designed in this apparently
    counterintuitive way; the reason is flexibility. As you will see in the next two
    chapters, not only is it possible to position UI elements differently at design
    time to when the app is running, but there is also a range of different layout
    schemes that the app designer (that's you) can choose from to suit their plans.
    This flexibility results in a little awkwardness while learning about Android,
    and great design power once you have got past this awkwardness. But don't worry,
    we will move a step at a time until you have this thing beaten.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will make Android Studio solve the problem for us automatically by first
    adding to our code, and then using the UI designer. First, let''s get the design
    time layout right. In the code for the second button, locate this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now edit it to be the same as the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Depending upon exactly where you positioned your first button, the values in
    Android Studio will likely be different to the values just discussed. If the second
    button is around 70dp higher than the first button, then you can proceed with
    this exercise.
  prefs: []
  type: TYPE_NORMAL
- en: This subtle change will move the second button down a little, but only for design
    time. If you look in the **Design** tab, the button is positioned neatly underneath
    the first button, but if you run the app on the emulator, they are both still
    in the top-left corner of the screen and are on top of one another.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch to the **Design** tab and find the **Infer Constraints** button that
    is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Positioning the two buttons in the layout](img/B12806_02_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on the **Infer Constraints** button. Android Studio will edit the XML
    code. Let''s take a brief look at what has happened behind the scenes. From the
    end of both of the sections of code representing the buttons, the following lines
    of code were removed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: These two lines of code were what positioned the buttons horizontally (`…absoluteX`)
    and vertically (`…absoluteY`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Android Studio also added four lines of code to the first button, and three
    lines of code to the second button. Here is the code that was added near the start
    of the first button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Exact values of `dp` might vary depending on precisely where you placed your
    buttons.
  prefs: []
  type: TYPE_NORMAL
- en: 'This code causes the button to have a margin of `30` on the top. But on the
    top of what exactly? Look at the following three lines of code that were added
    at the end of the first button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Notice the new attributes of `layout_constraintEnd_toEndOf`, `layout_constraintStart_toStartOf`,
    and `layout_constraintTop_toTopOf`. The value that is assigned to each of these
    attributes is `"parent"`. This causes the first button to be positioned relative
    to the parent UI element. The parent is the layout that contains everything else;
    in this case, the parent is the `ConstraintLayout` element.
  prefs: []
  type: TYPE_NORMAL
- en: Now look at the three lines of code added to the second (bottom) button.
  prefs: []
  type: TYPE_NORMAL
- en: 'Near the start of the code, we see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Again, exact values of `dp` might vary depending on precisely where you placed
    your buttons.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end of the code for the second button, we see the following two extra
    lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This means that the second button is positioned with a margin of 22 relative
    to `buttonTop`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now run the app and you will see that we have two distinct buttons. One has
    an `id` attribute of `buttonTop,` and it is above the other button with an `id`
    attribute of `buttonBottom`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Positioning the two buttons in the layout](img/B12806_02_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Clearly, there is more to layouts than I have alluded to so far, but you have
    had your first glance at the options provided by Android Studio to design the
    UI of our apps. We will be taking a closer look at `ConstraintLayout`, as well
    as exploring more layout options in [Chapter 4,](ch04.html "Chapter 4. Getting
    Started with Layouts and Material Design") *Getting Started with Layouts and Material
    Design*.
  prefs: []
  type: TYPE_NORMAL
- en: We want to make one more alteration to our XML code.
  prefs: []
  type: TYPE_NORMAL
- en: Making the buttons call different functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Switch back to the **Text** tab and identify this next line of code in the
    second (`buttonBottom`) button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, edit the code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Now we have two buttons, one above the other. The top one has an `id` attribute
    of `buttonTop` and an `onClick` attribute with a value of `topClick`. The other
    has an `id` attribute of `buttonBottom` and an `onClick` attribute with a value
    of `bottomClick`.
  prefs: []
  type: TYPE_NORMAL
- en: These last XML code changes now mean we need to supply two functions (`topClick`
    and `bottomClick`) in our Kotlin code.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is technically OK for two buttons to call the same function when they are
    clicked on – it is not a syntax error. However, most buttons do have distinct
    purposes, so this exercise will be more meaningful if our buttons do different
    things.
  prefs: []
  type: TYPE_NORMAL
- en: We will do that soon, but before we do, let's learn a little bit more about
    Kotlin comments and look at some Kotlin code that we can write to send messages
    to the user, and to ourselves for debugging purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Leaving comments in our Kotlin code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In programming, it is always a clever idea to write messages known as code
    comments, and sprinkle them liberally amongst your code. This is to remind us
    what we were thinking at the time we wrote the code. To do this, you simply append
    a double forward slash and then type your comment, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition, we can use comments to comment out a line of code. Suppose we
    have a line of code that we temporarily want to disable; we can do so by adding
    two forward slashes, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using comments to comment out code should only be a temporary measure. Once
    you have found the correct code to use, commented-out code should be cut to keep
    the code file clean and organized.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at two separate ways to send messages in Android, and then
    we can write some functions that will send messages when our UI buttons are pressed.
  prefs: []
  type: TYPE_NORMAL
- en: Coding messages to the user and the developer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the introduction to this chapter and in the previous chapter, we talked a
    bit about using other people's code, specifically via the classes and their functions
    of the Android API. We saw that we could do some quite complex things with fairly
    insignificant amounts of code (such as talking to satellites).
  prefs: []
  type: TYPE_NORMAL
- en: To get us started on coding, we are going to use two different classes from
    the Android API that allow us to output messages. The first class, `Log`, allows
    us to output messages to the logcat window. The second class, `Toast`, is not
    a tasty breakfast treat, but it will produce a toast-shaped pop up message for
    our app's user to see.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code we need to write to send a message to logcat:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Exactly why this works will become clearer in [Chapter 10](ch10.html "Chapter 10. Object-Oriented
    Programming"), *Object-Oriented Programming*, but for now, we just need to know
    that whatever we put between the two sets of quote marks will be output to the
    logcat window. We will see where to put this type of code shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code we need to write in order to send a message to the user''s
    screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This is a very convoluted-looking line of code and exactly how it works, again,
    will not become clear until [Chapter 9](ch09.html "Chapter 9. Kotlin Functions"),
    *Kotlin Functions*. The important thing here is that whatever we put between the
    quote marks will appear in a pop-up message to our users.
  prefs: []
  type: TYPE_NORMAL
- en: Let's put some code (like we have just seen) into our app for real.
  prefs: []
  type: TYPE_NORMAL
- en: Writing our first Kotlin code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, we now know the code that will output to logcat or the user's screen. However,
    where do we put the code? To answer this question, we need to understand that
    the `onCreate` function in `MainActivity.kt` executes as the app is preparing
    to be shown to the user. So, if we put our code at the end of this function, it
    will run just as the user sees it; that sounds good.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We know that to execute the code in a function, we need to **call** it. We have
    wired our buttons up to call a couple of functions, such as `topClick` and `bottomClick`.
    Soon, we will write these functions. But who or what is calling `onCreate`? The
    answer to this mystery is that Android itself calls `onCreate` in response to
    the user clicking on the app icon to run the app. In [Chapter 6,](ch06.html "Chapter 6. The
    Android Lifecycle") *The Android Lifecycle*, we will look deeper, and it will
    be clear what exactly the code executes and when. You don't need to completely
    comprehend this now; I just wanted to give you an overview of what was going on.
  prefs: []
  type: TYPE_NORMAL
- en: Let's quickly try this out; switch to the `MainActivity.kt` tab in Android Studio.
  prefs: []
  type: TYPE_NORMAL
- en: We know that the `onCreate` function is called just before the app starts for
    real. Let's copy and paste some code into the `onCreate` function of our Hello
    World app and see what happens when we run it.
  prefs: []
  type: TYPE_NORMAL
- en: Adding message code to the onCreate function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Find the closing curly brace (`}`) of the `onCreate` function and add the highlighted
    code shown in the following code block. In the code, I haven''t shown the complete
    content of the `onCreate` function, but instead, I have used `…` to indicate a
    number of lines of code not being shown. The important thing is to place the new
    code (shown in full) right at the end, but before the closing curly brace (`}`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the instances of `Toast` and `Log` are highlighted in red in Android
    Studio. They are errors. We know that `Toast` and `Log` are classes and that classes
    are containers for code.
  prefs: []
  type: TYPE_NORMAL
- en: The problem is that Android Studio doesn't know about them until we tell it.
    We must add an `import` directive for each class. Fortunately, this is semi-automatic.
  prefs: []
  type: TYPE_NORMAL
- en: Left-click on `Toast`; now hold the *Alt* key and tap *Enter*. You need to do
    this step twice, once for `Toast`, and once for `Log`. Android Studio adds the
    `import` directives at the top of the code with our other imports, and the errors
    are gone.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Alt* + *Enter* is just one of many useful keyboard shortcuts. The following
    is a keyboard shortcut reference for Android Studio. More specifically, it is
    for the IntelliJ Idea IDE, which Android Studio is based on. Bookmark this web
    page; it will be invaluable over the course of this book: [http://www.jetbrains.com/idea/docs/IntelliJIDEA_ReferenceCard.pdf](http://www.jetbrains.com/idea/docs/IntelliJIDEA_ReferenceCard.pdf).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Scroll to the top of `MainActivity.kt` and look at the added `import` directives.
    Here they are for your convenience:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Run the app in the usual way and look at the output in the **logcat** window.
  prefs: []
  type: TYPE_NORMAL
- en: Examining the output
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following is a screenshot of the output in the logcat window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Examining the output](img/B12806_02_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Looking at the logcat, you can see that our message – **Done creating the app**
    – was output, although it is mixed up amongst other system messages that we are
    currently not interested in. If you watched the emulator when the app first starts,
    you will also see the neat pop-up message that the user will see:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Examining the output](img/B12806_02_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You might be wondering why the messages were output at the time that they were.
    The simple answer is that the `onCreate` function is called just before the app
    starts to respond to the user. It is common practice amongst Android developers
    to put code in this function to get their apps set up and ready for user input.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will go a step further and write our own functions that are called by
    our UI buttons. We will place similar `Log` and `Toast` messages inside them.
  prefs: []
  type: TYPE_NORMAL
- en: Writing our own Kotlin functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's go straight on to writing our first Kotlin functions with some more `Log`
    and `Toast` messages inside them.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now will be a good time, if you haven't done so already, to get the download
    bundle that contains all the code files. You can view the completed code for each
    chapter. For example, the completed code for this chapter can be found in the
    `Chapter02` folder. I have further subdivided the `Chapter02` folder into `kotlin`
    and `res` folders (for Kotlin and resource files). In chapters with more than
    one project, I will divide the folders further to include the project name. You
    should view these files in a text editor. My favorite is Notepad++, a free download
    from [https://notepad-plus-plus.org/download/](https://notepad-plus-plus.org/download/).
    Code viewed in a text editor is easier to read than directly from the book, especially
    the paperback version, and even more so where the lines of code are long. The
    text editor is also a great way to select sections of the code to copy and paste
    into Android Studio. You could open the code in Android Studio, but then you risk
    mixing up my code with the autogenerated code of Android Studio.
  prefs: []
  type: TYPE_NORMAL
- en: Identify the closing curly brace (`}`) of the `MainActivity` class.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that you are looking for the end of the entire class, not the end of the
    `onCreate` function, as in the previous section. Take your time to identify the
    new code and where it goes among the existing code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside that curly brace, enter the following code that is highlighted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the two instances of `View` are in red, indicating an error. Simply
    use the *Alt* + *Enter* keyboard combination to import the `View` class and remove
    the errors.
  prefs: []
  type: TYPE_NORMAL
- en: Deploy the app to a real device or emulator in the usual way and start tapping
    the buttons so that we can observe the output.
  prefs: []
  type: TYPE_NORMAL
- en: Examining the output
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At last, our app does something! We can see that the function names we defined
    in the button `onClick` attribute are indeed called when the buttons are clicked
    on; the appropriate messages are added to the **logcat** window; and the appropriate
    `Toast` messages are shown to the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Admittedly, we still don''t understand why `Toast` and `Log` really work, nor
    do we fully comprehend the `(v: View)` parts of our function''s syntax, or the
    rest of the autogenerated code. This will become clear as we progress. As stated
    previously, in [Chapter 10](ch10.html "Chapter 10. Object-Oriented Programming"),
    *Object-Oriented Programming*, we will take a deep dive into the world of classes
    and, in [Chapter 9](ch09.html "Chapter 9. Kotlin Functions"), *Kotlin* *Functions*,
    we will master the rest of the syntax associated with functions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the logcat output; you can see that a log entry was made from
    the `onCreate` function just as before, as well as from the two functions that
    we wrote ourselves, each time you clicked on a button. In the following screenshot,
    you can see that I clicked on each button three times:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Examining the output](img/B12806_02_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you are now familiar with where to find the **logcat** window, in future,
    I will present the logcat output as trimmed text as it is clearer to read:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following screenshot, you can see that the top button has been clicked
    on and that the `topClick` function was called, triggering the pop-up `Toast`
    message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Examining the output](img/B12806_02_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Throughout this book, we will regularly output to logcat, so that we can see
    what is going on behind the UI of our apps. `Toast` messages are more for notifying
    the user that something has occurred. This might be a download that has completed,
    a new email has arrived, or some other occurrence that needs their attention.
  prefs: []
  type: TYPE_NORMAL
- en: Frequently asked questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Q.1) Can you remind me what functions are?
  prefs: []
  type: TYPE_NORMAL
- en: A) Functions are containers for our code that can be executed (called) from
    other parts of our code.
  prefs: []
  type: TYPE_NORMAL
- en: Q.2) Like the first, I found this chapter tough going. Do I need to re-read
    it?
  prefs: []
  type: TYPE_NORMAL
- en: A) No, if you managed to build the app, you have made enough progress to handle
    all of the next chapter. All the blanks in our knowledge will be steadily filled
    in and replaced with glorious moments of realization as the book progresses.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have achieved a lot in this exercise. It is true that much of the XML code
    is still generally incomprehensible. That's OK, because in the next two chapters,
    we will be really getting to grips with the visual designer and learning more
    about the XML code, although, ultimately, our aim is to use the XML code as little
    as possible.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen how, when we drag a button onto our design, the XML code is generated
    for us. Also, if we change an attribute in the **Attributes** window then, again,
    the XML code is edited for us. Furthermore, we can type (or, in our case, copy
    and paste) the XML code directly to create new buttons on our UI or edit existing
    ones.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen as well as written our first Kotlin code, including comments that
    help us document our code, and we have even added our own functions to output
    debugging messages to logcat and pop-up `Toast` messages to the user.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will take a full guided tour of Android Studio to see
    exactly where different things get done. Additionally, we will gain an understanding
    of how our project's assets, such as files and folders, are structured and how
    we can manage them. This will prepare us for a more in-depth look at UI design
    in [Chapter 4](ch04.html "Chapter 4. Getting Started with Layouts and Material
    Design"), *Getting Started with layouts and Material Design* and [Chapter 5](ch05.html
    "Chapter 5. Beautiful Layouts with CardView and ScrollView"), *Beautiful Layouts
    with CardView and ScrollView*, when we will build some significant real-world
    layouts for our apps.
  prefs: []
  type: TYPE_NORMAL
