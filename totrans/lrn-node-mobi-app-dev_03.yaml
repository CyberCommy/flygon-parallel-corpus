- en: Chapter 3. Creating an API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: No matter how sophisticated your backend is, it will most likely be of no use
    unless you can make its services available to your clients in some way. The most
    common way to do so is through an **Application Programming Interface** (**API**)—a
    set of well-defined access methods for your backend. Through this, you allow clients
    to request data, perform calculations, and request other services offered by it.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will look at how to construct such an API according to the
    widely used **Representational State Transfer** (**REST**) architecture. We will
    cover the theoretical basics of REST and then see how to implement its condensed
    version using Node.js according to our needs. We will round up by accessing the
    API via a REST client in order to see how it works in action.
  prefs: []
  type: TYPE_NORMAL
- en: Learning outcomes of the RESTful API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After reading this chapter, you will understand what a RESTful API is and how
    it is structured. You will also have gained a thorough understanding of how to
    define data access points in Node.js and work with these through a REST client.
  prefs: []
  type: TYPE_NORMAL
- en: RESTing easy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the greatest challenges of the Internet age has always been to make networked
    services talk to each other in a uniform and efficient manner. It is the reason
    behind why we have developed a plethora of communications protocols that we depend
    on today, such as the all-important TCP/IP stack. Protocols like these make formal
    communication between applications a straightforward process, at least as far
    as the actual bytes on the wire are concerned.
  prefs: []
  type: TYPE_NORMAL
- en: However, there is no single de facto specification for how applications should
    communicate data abstractions to each other. Raw TCP/IP only understands the exchange
    of data packets; it knows nothing about abstractions such as customers, orders
    or products. To raise the abstraction level and build an interface that allows
    intuitive communication with our backend, we will have to rely on a custom implementation
    of one or more architectural patterns in order to get what we want. Today, there
    are several such patterns in wide usage. You may already be familiar with terms
    such as SOAP, WSDL, and perhaps even our target here—REST.
  prefs: []
  type: TYPE_NORMAL
- en: It's all hypermedia
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: REST is an architectural pattern where two or more applications exchange resources
    among themselves through a set of operations on these resources. The resources
    are sets of data types that all the involved applications, such as products, customers,
    and so on, know about. For example, a client application can either ask a server
    application to give it a list of all the resources of a given kind that it stores,
    or ask the server to register a new instance of a given resource in its database.
    All such operations are communicated only by using the standard HTTP protocol,
    which makes the process both intuitive and easy to implement.
  prefs: []
  type: TYPE_NORMAL
- en: At the heart of the RESTful communication are the common HTTP verbs—**GET**,
    **POST**, **PUT**, and **DELETE**. In terms of the popular **CRUD** (**Create/Read/Update/Delete**)
    acronym, **C** corresponds to **POST**, **R** to **GET**, **U** to **PUT**, and
    finally **D** to, well, **DELETE**. If you are familiar with HTTP, you will already
    know that these verbs represent different request types sent between two HTTP-speaking
    applications. For example, when you type `www.google.com` in the URL field of
    your browser and press the *Enter* key, the browser will issue a `GET` request
    to the server the URL is bound to, asking it to return whatever data is located
    at server. Typically, this data is in a standard format such as **HTML**, **XML**,
    or **JSON**. In the same way, when you fill out a form on a webpage and press
    the **submit** button (or its equivalent), a request is sent to the server through
    a `POST` request, which carries the request data that you entered for the server
    to process.
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned before, REST functions by using these verbs to communicate operations
    on various resources that the involved parties know about. For example, in our
    case, we may want to tell a server the following by using the RESTful requests:'
  prefs: []
  type: TYPE_NORMAL
- en: Fetch all the products that are available on the server (the verb is `GET`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fetch the product with an ID of `abcd1234` (the verb is `GET`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Place a new order with a product named `abcd1234` for a customer with an ID
    of `xyz456` (the verb is `POST`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update the price of the product with an ID of `abcd1234` to 500 million dollars
    (the verb is `PUT`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delete the product with an ID of `abcd1234` since nobody is buying it anymore
    (the verb is `DELETE`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By convention, REST uses the following common base URL structure for requests
    operating on a given resource (elements in the brackets are optional):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'For our product example, a RESTful base URL for this resource is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`http://myserver.com/myapi/v1/products`'
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, we will demonstrate how such actions are carried out
    in practice using the HTTP verbs.
  prefs: []
  type: TYPE_NORMAL
- en: GET
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the context of REST, a GET request always indicates a retrieval operation.
    Thus, we say that the GET requests are the only non-mutating ones among the common
    verbs, since they do not change the state of the associated resource on the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'In REST, there are two standard GET operations that any API should ideally
    implement:'
  prefs: []
  type: TYPE_NORMAL
- en: GET all
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following are the key features of the GET all operation:'
  prefs: []
  type: TYPE_NORMAL
- en: It sends a blank GET request to the base URL for the resource
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It returns all the resources of a given type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An example of resources that are given by the GET all operation is `http://myserver.com/myapi/v1/products`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GET by ID
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following are the key features of the GET by ID operation:'
  prefs: []
  type: TYPE_NORMAL
- en: It returns the resource with the specific ID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An example of this type of operation is `http://myserver.com/myapi/v1/products/abcd1234`
    (using the path parameters) or `http://myserver.com/myapi/v1/products?id=abcd1234`
    (using the query parameters)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whether you should use path parameters or query parameters is entirely up to
    you, and it is not mandated by the REST conventions. Here, and for the remainder
    of the book, we will use query parameters, since this is the normal HTTP way of
    doing things and a bit easier to understand and implement.
  prefs: []
  type: TYPE_NORMAL
- en: POST
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: POST requests are used in order to create new instances of a given resource.
    Normally, a conventional REST server will provide documentation about the fields
    of the resource that you need to specify for the creation to succeed.
  prefs: []
  type: TYPE_NORMAL
- en: PUT
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: PUT is used in order to create or update a resource. It works almost identically
    to POST, with the exception that if you supply a resource ID with your request,
    the server will first find that specific resource and then replace each field
    of that resource with the equivalent field in your request.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider a situation where your server has a resource of the product
    type, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s suppose that you submit a `PUT` request with the following form data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The same resource will have the following state on the server after the transaction
    concludes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: DELETE
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: DELETE is used in order to, well, delete a resource on the server. All you need
    to do is supply the resource ID in your request. For example, sending a `DELETE`
    request to `http://myserver.com/myapi/v1/products/abcd1234` will delete the product
    with an ID of `abcd1234` on the server.
  prefs: []
  type: TYPE_NORMAL
- en: Building a RESTful API with Node.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have covered the basics of REST, let's put it into practice and
    build an API for `OrderBase`, which was constructed in the previous chapter. If
    you have not done so already, please take a moment to review the code that we
    wrote there in order to make sure that you understand what happens between our
    API and the database in this example.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the RESTful API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Start with creating a workspace for our server. On your drive, create a folder
    named `order_api`, step into this folder, and create and execute the file named
    `api.js`. Finally, open a terminal and execute the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As we saw in the previous chapter, this will give you a few questions to answer
    in order to bootstrap the Node.js server. When the questions ask you for the entry
    point, be sure to specify `api.js`, since this is the main file that your server
    configuration will be read from.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you will need to import the database interface module that we created
    in [Chapter 2](ch02.html "Chapter 2. Configuring Persistence with MongoDB"), *Configuring
    Persistence with MongoDB*. To do so, first install the `mongodb` driver:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you can import the module itself in two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Copy and paste the `database.js` file from the previous chapter into the current
    directory and add `var database = require('./database');` to the top of your `api.js`
    file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add `var database = require([pathToDatabase])` to the top of your `api.js` file,
    where `[pathToDatabase]` is the full system path to your `database.js` file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once this is done, open the `api.js` file. Let's start adding some code for
    our API.
  prefs: []
  type: TYPE_NORMAL
- en: The HTTP module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first thing we will need is a way to actually open up the Node.js instance
    to the network and enable it to communicate over the HTTP protocol, since this
    will be the core driver of our API's functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to achieve this, we will include the standard HTTP module in our server.
    Add the following line to the top of your `api.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This will cause Node.js to load the HTTP module, a powerful component that can
    be used to listen for and process HTTP requests as well as send responses to the
    clients.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, with the module in place, let''s hotwire Node.js to start listening and
    respond to simple HTTP requests. Add the following to your file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: That's it! If this is your first time using the HTTP module, you may be surprised
    at how simple this setup is. It is not everyday that you write a fully functioning
    HTTP server in seven lines of code! Node.js is just that good.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s give the server a run to make sure that it is working alright. Open
    your favorite browser and navigate to *http://localhost:8080*. You will see the
    following line of text:'
  prefs: []
  type: TYPE_NORMAL
- en: '**I am a fledgling API, and I am alright**'
  prefs: []
  type: TYPE_NORMAL
- en: All is well. We are now ready to start making our API do something more interesting
    than just show the same text over and over. However, let's take a closer look
    first at how the HTTP module actually works and services requests.
  prefs: []
  type: TYPE_NORMAL
- en: Dissecting the HTTP server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Looking at our server code, we are really just doing the following two things:'
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the event loop for our server is what it should do whenever an HTTP
    request comes in. This is done by invoking the `http.createServer()` method, which
    takes a callback function as a parameter, which will be executed for each incoming
    request.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Bind the server to a given network port in the host machine and start listening
    for incoming connections on that port.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The interesting bit of the first item is the callback function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This method takes two arguments, `req` and `res`. As you may have guessed, they
    refer to the HTTP *request* and the associated *response*. The `req` parameter
    will contain all the data associated with the incoming HTTP request, such as origin,
    headers, payload, cookies, and more. The `res` parameter is the HTTP response,
    which will be emitted back to the caller when the method is returned.
  prefs: []
  type: TYPE_NORMAL
- en: You may wonder why the response is passed as a parameter to a function that
    obviously handles incoming requests. This is a matter of design. The `res` parameter
    is actually created outside the function and passed to it so that you can do what
    modifications you see fit to it before the HTTP module takes control again, finalizes
    it, and sends it back to the sender.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our function, we do only the following two things:'
  prefs: []
  type: TYPE_NORMAL
- en: We set the response code of the response to *200*, indicating a successful request
    cycle.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We append a string to the body (that is, the payload) of the response`—"I am
    a fledgling API, and I am alright"`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That's it as regards handling and responding to requests (really!).
  prefs: []
  type: TYPE_NORMAL
- en: Let's put this to use and start returning something more interesting.
  prefs: []
  type: TYPE_NORMAL
- en: Returning JSON
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Normally, REST APIs will support serving data in several different formats,
    such as JSON and XML. For the sake of simplicity, we will only focus on JSON here.
    This makes sense in the context of what we have seen so far, where everything
    high and low is JavaScript - and JSON-oriented anyway.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thankfully, returning a JSON object to our caller is almost trivial; we just
    need to make a few adjustments inside our callback function:'
  prefs: []
  type: TYPE_NORMAL
- en: Specify the content type of the response as JSON
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Convert the JSON object that we want to send back to a string
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The first adjustment is done by modifying the `Content-Type` header of our
    response. In your code, you have the following code line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'You can change this to the following code line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This additional parameter, passed to the `writeHead()` method, is a JSON object
    with custom values for headers in the response object. If you don't specify headers,
    the HTTP module will generally set sensible defaults, but you should always be
    explicit when you are certain about what a header should be set to. Here, we want
    to make it clear to the client that we are sending them a JSON object as a response,
    and we set the `Content-Type` header accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'To address the second item, let''s first add a JSON object to send back to
    the client. After the `res.writeHead()` method, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to turn this JSON object into a string in order to package it
    into the response. To do so, we can use the native Javascript `JSON.stringify()`
    method. As expected, this method takes a JSON object and returns a string representation
    of that object. Modify the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Change the preceding line to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re done! Save your changes, restart the Node.js instance (just close and
    start it again), and refresh your browser window for the server. You will see
    the text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We now have a full-fledged, JSON-serving HTTP server ticking. It's about time
    that we got down to the serious stuff.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing our GET handlers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's begin by implementing basic GET methods for our resources. You may recall
    that we mentioned before that a good REST API should at least implement two of
    them—GET by ID and GET all. Since we like to be standards-compliant, that is what
    we will use here.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a router
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our first order of business is to provide a way for our Node.js instance to
    differentiate between the different URLs that it receives requests for. Until
    now, our server only had to handle requests to its root URL (`http://localhost:8080/`),
    but in order to do something more interesting, we want to be able to generate
    custom responses for more specific URLs, such as `http://localhost:8080/api/products`.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, Node.js again provides an out-of-the-box way to achieve this—the
    URL module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following just after the `var http = require(''http'');` line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This will import the URL module. We can now use it to break down the incoming
    requests and take action depending on how their URLs are structured.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the `http.createServer()` call to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we introduced two new methods, `findAllProducts` and `findProductById`.
    These are utility methods, which we will define separately. Along with them, we
    will define some generic helper methods to help make data access less cumbersome
    for us. Go ahead and add the following before the `createServer()` call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The generic methods are straightforward. They simply make use of the MongoDB
    interface that we created in [Chapter 2](ch02.html "Chapter 2. Configuring Persistence
    with MongoDB"), *Configuring Persistence with MongoDB*, in order to retrieve either
    all the documents from a specific collection, or just a single document by its
    ID. The specific product methods make use of these generic methods in order to
    find products in this fashion.
  prefs: []
  type: TYPE_NORMAL
- en: For the sake of brevity, we do not implement similar methods for the customer
    and order here; they are identical to the ones used for the product. Just change
    the name of the resource and add appropriate paths inside the `createServer()`
    method. You can see the complete example in the source code accompanying the book.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing our POST handlers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will now move on to adding handlers to create new instances of a resource.
    To do so, we need to distinguish not only between the URLs, but also between the
    request types. Modify your `createServer()` invocation so that it looks like the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we have introduced another handler method, `insertProduct()`. We
    define it, along with its corresponding generic method, like we did before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Again, the implementation of this functionality for the other resources is the
    same, with the exception of the name. We do not replicate them here.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the DELETE and PUT handlers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Handling DELETE and PUT is analogous to handling a GET and POST request respectively,
    with the exception of the method being changed. Thus, we recommend that you refer
    to the accompanying source code to see the full implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Until now, we have used a normal browser to poke at our API and see what it
    returns. However, this is far from optimal. Most browsers only make it easy to
    send GET requests, whereas an HTML form or something similar to it is needed in
    order to send POST requests. Let's not even get started with the DELETE and PUT
    requests.
  prefs: []
  type: TYPE_NORMAL
- en: To test the REST API, it is a much better idea to use a dedicated REST client,
    which will give you more options, make it easier to send requests, and thoroughly
    analyze responses. A very popular (and free) tool is Postman, which is a Chrome
    extension. It runs on all major operating systems. You can download it for free
    from [https://www.getpostman.com/](https://www.getpostman.com/). The install process
    is very straightforward, and it will not be covered here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have installed Postman, start it up. Let''s post away at our API.
    First, let''s try asking the backend to send us all the products that it currently
    stores. Enter the products'' root URL in Postman''s URL field, make sure that
    GET is selected among the methods in the combobox to the right, and then click
    on the **Send** button. You should get something that looks like the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing the API](img/B04653_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s try to POST a new product to the backend. Keep the same URL, but
    change the method to POST in the combobox to the right. Next, add some data before
    sending; select **Raw** from the button group under the URL field and enter the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing the API](img/B04653_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on **Send** to fire off the request (note how much easier this is than
    using a plain browser). Finally, let''s pull all the products again in order to
    make sure that the new product was indeed added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing the API](img/B04653_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: That's it! Our API is working, and we are ready to start moving towards some
    serious usage.
  prefs: []
  type: TYPE_NORMAL
- en: Moving forward
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we studied the bare bones and built our API from scratch by
    using only the functionality provided by the core Node.js modules themselves.
    We did this in order to show you how Node.js works in reality and to avoid binding
    you to any given framework that already does the things that we implemented here,
    in case you use another one in your own career.
  prefs: []
  type: TYPE_NORMAL
- en: 'That being said, as an addendum, we would still like to point you to some frameworks
    that we ourselves recommend in order to build powerful APIs quickly with Node.js:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Express.js**: Express is a framework that can be used to build robust, complete
    web applications using Node.js. It comes with a host of powerful features, including
    an advanced router, which makes it very easy to handle incoming requests based
    on the URL (forget about the switch and if statements like we did here), extract,
    parse, and validate data, connect to external data sources, and much more.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Express.js is largely seen as the de facto framework for Node.js, and it has
    a large community and plugins available for it, making it easy to find help and
    extra functionality as needed.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more information on this framework, visit [http://expressjs.com/](http://expressjs.com/).
  prefs: []
  type: TYPE_NORMAL
- en: '**Loopback.js**: This was developed by the same team that created Express.js.
    Loopback.js is an Express.js derivative, which is designed solely for the creation
    of APIs. It comes with a powerful terminal interface, where you can quickly create
    and modify resources, relations between resources, security, and much more. Loopback
    automatically generates full RESTful APIs for your resources, which means that
    you have to write almost no code for cases, such as the examples that we looked
    at in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more information about this framework, visit [http://loopback.io](http://loopback.io)/.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You should now have a good understanding of the basic concepts of RESTful APIs
    as well as how you can implement them using Node.js and access them from a network.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will continue improving our API and show how to secure
    it in order to prevent unauthorized access to your resources.
  prefs: []
  type: TYPE_NORMAL
