- en: '*Chapter 8*: Certificate Services on Linux'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we'll cover several topics that involve using certificates
    in securing or encrypting traffic, and in particular configuring and using various
    **Certificate Authority** (**CA**) servers in Linux.
  prefs: []
  type: TYPE_NORMAL
- en: We'll cover the basics of how these certificates can be used, and then progress
    on to building a certificate server. Finally, we'll look at security considerations
    around certificate services, both in protecting CA infrastructures and using **Certificate
    Transparency** (**CT**) to enforce the trust model, and for inventory/audit or
    reconnaissance within an organization.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What are certificates?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Acquiring a certificate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a certificate—web server example
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a private Certificate Authority
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Securing your Certificate Authority infrastructure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Certificate Transparency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Certificate automation and the **Automated Certificate Management Environment**
    (**ACME**) protocol
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OpenSSL` cheat sheet'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we've completed this chapter, you'll have a working private CA on your
    Linux host, with a good idea of how certificates are issued and how to both manage
    and secure your CA, whether you are using it in a lab or a production environment.
    You'll also have a solid understanding of how a standard certificate handshake
    works.
  prefs: []
  type: TYPE_NORMAL
- en: Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we can continue to use the same Ubuntu **virtual machine**
    (**VM**) or workstation that we've been using to date, as this is a learning exercise.
    Even in sections where we're acting as both a CA and a certificate applicant,
    the examples in this section can all be completed on this single host.
  prefs: []
  type: TYPE_NORMAL
- en: Given that we're building a certificate server, though, if you are using this
    guide to help in building a production host, it's strongly suggested that you
    build this on a separate host or VM. A VM is preferred for a production service—read
    the *Securing your CA infrastructure* section for more on this recommendation.
  prefs: []
  type: TYPE_NORMAL
- en: What are certificates?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Certificates are essentially *attestations of truth*—in other words, a certificate
    is a document that says, *trust me, this is true*. This sounds simple, and in
    some ways it is. But in other ways, the various uses of certificates and deploying
    a CA infrastructure securely is a significant challenge—for instance, we''ve seen
    some spectacular failings in public CAs in recent years: companies whose only
    business was securing the certificate process couldn''t get it right when under
    scrutiny. We cover the challenges and solutions in securing CAs in more detail
    later in this chapter, in the *Securing your CA infrastructure* and *CT* sections.'
  prefs: []
  type: TYPE_NORMAL
- en: At the root of things, workstations and servers have a list of CAs that they
    trust. This trust is delivered using cryptographically signed documents that are
    the public certificates of each of those CAs, which are stored in a specific place
    on a Linux or Windows host.
  prefs: []
  type: TYPE_NORMAL
- en: When you browse to a web server, for instance, that local *certificate store*
    is referenced to see if we should trust the web server's certificate. This is
    done by looking at the public certificate of that web server and seeing if it
    was signed by one of your trusted CAs (or a subordinate of one of your trusted
    CAs). The use of *child* or *subordinate* CAs for actual signing is common—each
    public CA wants to protect its *root* CA as much as possible, so *subordinate
    CAs* or *issuing CAs* are created, which are the ones that the public internet
    sees.
  prefs: []
  type: TYPE_NORMAL
- en: Organizations can create their own CAs, to be used for authentication and authorization
    between their users, servers, workstations, and network infrastructure. This keeps
    that trust *within the family*, so to speak—completely under the control of the
    organization. It also means that the organization can use internal and free certificate
    services rather than paying for hundreds or thousands of workstations or user
    certificates.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know what a certificate is, let's look at how they are issued.
  prefs: []
  type: TYPE_NORMAL
- en: Acquiring a certificate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the following diagram, an application—for instance, a web server—needs a
    certificate. This diagram looks complex, but we''ll break it down into simple
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1 – Certificate signing request (CSR) and issuing a certificate'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16336_08_001.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.1 – Certificate signing request (CSR) and issuing a certificate
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s walk through the steps involved in creating a certificate, right from
    the initial request to having a certificate ready to install in the target application
    (*Steps 1-6*), as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The process starts by creating a CSR. This is simply a short text file that
    identifies the server/service and the organization that is requesting the certificate.
    This file is cryptographically "obfuscated"—while the fields are standardized
    and are just text, the final result is not human-readable. Tools such as OpenSSL,
    however, can read both CSR files and certificates themselves (see the *OpenSSL
    cheat sheet* section at the end of this chapter if you need examples of this).
    The text information for a CSR includes some—or all—of these standard fields:![](img/B16336_08_Table_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The preceding list is not an exhaustive list of fields that can be used in a
    CSR, but these are the ones most commonly seen.
  prefs: []
  type: TYPE_NORMAL
- en: The reason we need all this information is so that when a client connects to
    the service that's using a certificate (for instance, a web server using **HyperText
    Transfer Protocol Secure** (**HTTPS**) and **Transport Layer Security** (**TLS**)),
    the client can verify that the server name being connected to matches the CN field
    or one of the SAN entries.
  prefs: []
  type: TYPE_NORMAL
- en: This makes it important that the CA operator verifies this information. For
    a public-facing certificate, this is done by the operator/vendor verifying the
    company name, email, and so on. Automated solutions accomplish this by verifying
    that you have administrative control over the domain or host.
  prefs: []
  type: TYPE_NORMAL
- en: Still sticking with *Figure 8.1*, this text information is next cryptographically
    combined with the public key of the applicant, to form the `CSR` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The now-completed CSR is sent to the CA. When the CA is a public CA, this is
    often done via a website. Automated public CAs such as **Let's Encrypt** often
    use the ACME **application programming interface** (**API**) for communications
    between the applicant and the CA. In higher-stake implementations, *Steps 3* and
    *6* might use secure media, physically handed off between trusted parties using
    formal *chain-of-custody* procedures. The important thing is that the communication
    between the applicant and the CA uses some secure method. While less secure methods
    such as email are possible, they are not recommended.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the CA, the identity information (we're still following the information flow
    in *Figure 8.1*) is validated. This can be an automated or a manual process, depending
    on several factors. For instance, if this is a public CA, you may already have
    an account, which would make a semi-automated check more likely. If you don't
    have an account, this check is most likely manual. For a private CA, this process
    may be entirely automated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once validated, the validated CSR is cryptographically combined with the CA's
    private key to create a final certificate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This certificate is then sent back to the applicant and is ready for installation
    into the application where it will be used.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that the applicant's private key is never used in this transaction—we'll
    see where it gets used in the TLS key exchange (in the very next section of this
    chapter).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand how a certificate is created or issued, how does an application
    use a certificate for trusting a service or encrypting session traffic? Let's
    look at the interaction between a browser and a TLS-protected website to see how
    this works.
  prefs: []
  type: TYPE_NORMAL
- en: Using a certificate – web server example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When asked, most people would say that the most common use for certificates
    is to secure websites, using the HTTPS protocol. While this may not be the most
    common use for certificates in today's internet, it certainly remains the most
    visible. Let's discuss how a web server's certificate is used to provide trust
    in the server and help establish an encrypted HTTPS session.
  prefs: []
  type: TYPE_NORMAL
- en: If you remember our *applicant* in our CSR example, in this example that applicant
    is the website [www.example.com](http://www.example.com), which might reside on
    the web server, for instance. We'll start our example where the previous session
    left off—the certificate is issued and is installed on the web server, ready for
    client connections.
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 1**: The client makes an initial HTTPS request to the web server, called
    a **CLIENT HELLO** (*Figure 8.2*).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this initial *Hello* exchange, the client sends the following to the server:'
  prefs: []
  type: TYPE_NORMAL
- en: The TLS versions that it supports
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The encryption ciphers that it supports
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This process is illustrated in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2 – TLS communication starts with a client hello'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16336_08_002.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.2 – TLS communication starts with a client hello
  prefs: []
  type: TYPE_NORMAL
- en: The web server replies by sending its certificate. If you remember, the certificate
    contains several bits of information.
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 2**: The web server replies by sending its certificate (*Figure 8.3*).
    If you remember, the certificate contains several bits of information, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The text information that states the identity of the server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The public key of the web server/service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The identity of the CA
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The server also sends the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Its supported TLS versions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Its first proposal on the cipher (usually the highest-strength cipher in the
    client list that the server supports)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The process is illustrated in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.3 – TLS exchange: server hello is sent and certificate is validated
    by the client'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16336_08_003.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.3 – TLS exchange: server hello is sent and certificate is validated
    by the client'
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 3**: The client receives this certificate and the rest of the information
    (called the server hello), and then (shown next in *Figure 8.4*) validates a few
    pieces of information, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Is the identity of the server that I requested in the certificate that I just
    received (usually this will be in the CN field or the SAN field)?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does today's date/time fall between the certificate's *after* and *before* dates
    (that is, has the certificate expired)?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do I trust the CA? It will verify this by looking in its certificate store,
    where the public certificates of several CAs are typically located (several public
    CAs, and often one or more private CAs that are used within the organization).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The client also has the opportunity to check if the certificate has been revoked,
    by sending a request to an **Online Certificate Status Protocol** (**OCSP**) server.
    The older method of checking a **certificate revocation list** (**CRL**) is still
    supported but is not used much anymore—this list was proven to not scale well
    with thousands of revoked certificates. In modern implementations, the CRL normally
    consists of public CA certificates that have been revoked rather than regular
    server certificates.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *trust* and *revocation* checks are extremely important. These validate
    that the server is who it claims to be. If these checks aren't done, then anyone
    could stand up a server claiming to be your bank, and your browser would just
    let you log in to those malicious servers. Modern-day phishing campaigns often
    try to *game the system* by *lookalike domains* and other methods to get you to
    do just that.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Step 4**: If the certificate passes all the checks on the client side, the
    client will generate a pseudo-random symmetric key (called a pre-master key).
    This is encrypted using the server''s public key and sent to the server (as shown
    in *Figure 8.4*). This key will be used to encrypt the actual TLS session.'
  prefs: []
  type: TYPE_NORMAL
- en: The client is allowed to modify the cipher at this point. The final cipher is
    a negotiation between the client and the server—keep that in mind, as we'll dig
    a bit deeper into this when we talk about attacks and defenses. Long story short—the
    client normally doesn't change the cipher because the server has picked one that
    came from the client's list in the first place.
  prefs: []
  type: TYPE_NORMAL
- en: 'The process is illustrated in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.4 – Client key exchange and the server gets one last chance to change
    the cipher'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16336_08_004.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.4 – Client key exchange and the server gets one last chance to change
    the cipher
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 5**: After this step, the server gets one last chance to change the
    cipher as well (still in *Figure 8.4*). This step usually doesn''t happen, and
    cipher negotiation is usually completed. The pre-master key is now final and is
    called the master secret.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 6**: Now that the certificate verification is all done and the ciphers
    and symmetric key are all agreed on, communications can proceed. Encryption is
    done using the symmetric key from the previous step.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is illustrated in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.5 – Negotiation is complete and communication proceeds using the
    master secret (key) for encryption'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16336_08_005.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.5 – Negotiation is complete and communication proceeds using the master
    secret (key) for encryption
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two important things to note in this exchange that are implied but
    not spelled out yet, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Once the negotiation completes, the certificate is no longer used—encryption
    is done using the negotiated master secret key.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: During a normal negotiation, the CA is not needed. This will become an important
    point later, when we start discussing securing our organization's CA infrastructure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have a better understanding of how certificates work (at least in
    this one use case), let's build a Linux-based CA for our organization. We'll do
    this a few different ways to give you some options in your own organization. We'll
    also use a CA in the next chapter, [*Chapter 9*](B16336_09_Final_NM_ePub.xhtml#_idTextAnchor153),
    *RADIUS Services for Linux*, so this is an important set of examples to follow
    closely.
  prefs: []
  type: TYPE_NORMAL
- en: Building a private Certificate Authority
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Building a private CA starts with the same decision we''ve faced with each
    of our infrastructure packages: *Which CA package should we use?* As with so many
    server solutions, there are several to pick from. A few options are outlined here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**OpenSSL** technically gives us all the tools we need to write our own scripts
    and maintain our own directory structure of **public key infrastructure** (**PKI**)
    bits and pieces. You can create root and subordinate CAs, make a CSR, and then
    sign those certificates to make real certificates. In practice, while this approach
    is universally supported, it ends up being a bit too far on the manual side of
    the spectrum for most people.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Certificate Manager** is a CA bundled with Red Hat Linux and related distributions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**openSUSE** and related distributions can use the native **Yet another Setup
    Tool** (**YaST**) configuration and management tool as a CA.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Easy-RSA** is a set of scripts that are essentially a wrapper around the
    same OpenSSL commands.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Smallstep** implements more automation—it can be configured as a private
    ACME server and can easily allow your clients to request and fulfill their own
    certificates.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LetsEncrypt` GitHub page and written in Go.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, there are a reasonably large number of CA packages out there.
    Most of the older ones are wrappers around various OpenSSL commands. The newer
    ones have additional automation in place, specifically around the ACME protocol,
    which was pioneered by `LetsEncrypt`. Links to the documentation for each of the
    packages mentioned previously are in this chapter's *Further reading* list. As
    the most widely deployed Linux CA, we'll build our example CA server using OpenSSL.
  prefs: []
  type: TYPE_NORMAL
- en: Building a CA with OpenSSL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Because we're only using commands that are included in almost every Linux distribution,
    there is nothing to install before we start our CA build using this method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start this process, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll create a location for the CA. The `/etc/ssl` directory should
    already exist in your host''s file structure, we''ll add two new directories to
    that by running the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, keep in mind that as certificates are issued, the CA needs to keep track
    of serial numbers (usually sequential), and also some details about each certificate
    as it''s issued. Let''s start the serial numbers in a `serial` file, at `1`, and
    create an empty `index` file to further track certificates, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''ll edit the existing `/etc/ssl/openssl.cnf` configuration file and
    navigate to the `[CA_default]` section. This section in the `default` file looks
    like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Next, we'll create a self-signed root certificate. This is normal for the root
    of a private CA. (In a public CA, you would create a new CSR and get it signed
    by another CA, to provide a *chain* to a trusted root.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Since this is an internal CA for an organization, we normally choose a long
    life for this so that we''re not rebuilding the entire CA infrastructure every
    year or two. Let''s choose 10 years (3,650 days). Note that this command asks
    for a passphrase (don''t lose this!) as well as other information that will identify
    the certificate. Note in the following code snippet that the `openssl` command
    creates a private key for the CA (`cakey.pem`) and the root certificate (`cacert.pem`)
    in one step. When prompted, use your own host and company information to fill
    in the requested values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In this final step, we'll move the key and root certificate to the correct locations.
    Note that you'll need `sudo` rights again to do this.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Your CA is now open for business! Let's proceed on to create a CSR and sign
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Requesting and signing a CSR
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s create a test CSR—you can do this on the same example host that we''ve
    been working with. First, create a private key for this certificate, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Keep track of that passphrase as it will be required when the time comes to
    install the certificate! Also, note that the key has a `2048`-bit modulus—that
    is the minimum value you should expect to see or use for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Passphrases for certificate keys are important and very sensitive information
    and you should store them someplace secure—for instance, if you plan on renewing
    that certificate when it expires (or before that, hopefully), you're going to
    need that passphrase to complete the process. Rather than keep it in a plain text
    file, I'd suggest using a password vault or a password manager to store these
    important passphrases.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that many daemon-style services will need a key and certificate without
    a passphrase (Apache web server, Postfix, and many other services) in order to
    auto-start without intervention. If you are creating a key for such a service,
    we''ll strip out the passphrase to create an *insecure key*, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s rename the keys—the `server.key` *secure* key becomes `server.key.secure`,
    and the `server.key.insecure` *insecure* key becomes `server.key`, as shown in
    the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Whichever *style* of key we are creating (with or without a passphrase), the
    final file is `server.key`. Using this key, we can now create a CSR. This step
    requires a different passphrase that will be required to sign the CSR, as illustrated
    in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have the CSR in the `server.csr` file, it''s ready to be signed.
    On the certificate server (which happens to be the same host for us, but this
    won''t be typical), take the `CSR` file and sign it with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This will generate several pages of output (not shown) and ask for a couple
    of confirmations. One of these confirmations will be the passphrase that we supplied
    when the CSR was created previously. When all is said and done, you'll see the
    actual certificate scroll by as the last section of the output. You'll also notice
    that since we didn't specify any dates, the certificate is valid starting from
    now, and is set to expire 1 year from now.
  prefs: []
  type: TYPE_NORMAL
- en: 'The certificate we just signed is stored in `/etc/ssl/newcerts/01.pem`, as
    illustrated in the following code snippet, and should be ready for use by the
    requesting service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As we progress, the issued certificates will increment to `02.pem`, `03.pem`,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note in the following code snippet that the `index` file has been updated with
    the certificate details, and the `serial number` file has been incremented, ready
    for the next signing request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: With a CA example completed and operating with a test certificate issued, let's
    look at how you might secure your CA infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: Securing your Certificate Authority infrastructure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are several best practices that are usually recommended to protect your
    CA. Some of the "legacy" advice is specific to individual CAs, but with virtualization
    becoming common in most data centers, this brings with it additional opportunities
    to streamline and secure CA infrastructures.
  prefs: []
  type: TYPE_NORMAL
- en: Legacy tried-and-true advice
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The traditional advice for securing an organization's certificate infrastructure
    takes advantage of the fact that it is only used when certificates are being issued.
    If you have a good administrative handle on when new certificates will be needed,
    you can simply power off your CA server when it's not needed.
  prefs: []
  type: TYPE_NORMAL
- en: If you need more flexibility, you can create a hierarchal certificate infrastructure.
    Create a root CA for your organization, whose only job is to sign certificates
    that are used to create a subordinate CA (or possibly multiple subordinates).
    These subordinates are then used to create all client and server certificates.
    The root CA can then be powered off or otherwise taken offline, except for patching.
  prefs: []
  type: TYPE_NORMAL
- en: If an organization is particularly concerned with securing their CA, special-purpose
    hardware such as a **hardware security module** (**HSM**) can be used to store
    the private key and CA certificate of their CA offline, often in a safety-deposit
    box or some other offsite, secure location. Commercial examples of an HSM would
    include Nitrokey HSM or YubiHSM. NetHSM is a good example of an open source HSM.
  prefs: []
  type: TYPE_NORMAL
- en: Modern advice
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The preceding advice is all 100% still valid. The new piece of the puzzle that
    we see helping secure our CAs in a modern infrastructure is server virtualization.
    What this means in most environments is that every server has one or more image
    backups stored on local disk, due to how VMs are backed up. So, if a host is damaged
    beyond repair, whether that's from malware (usually ransomware) or some drastic
    configuration error, it's a matter of 5 minutes or so to roll the whole server
    back to the previous night's image or, in the worst case, an image from two nights
    before.
  prefs: []
  type: TYPE_NORMAL
- en: All that is lost in this recovery would be the server data about any certificates
    that were issued in that *lost* interval, and if we refer again back to how a
    session is negotiated, that server data is never actually used in setting up a
    session. This means that this *trip back in time* that the server took for recovery
    doesn't impact any of the clients or servers that use the issued certificates
    for negotiating encryption (or authentication, which we'll see when we get to
    [*Chapter 9*](B16336_09_Final_NM_ePub.xhtml#_idTextAnchor153), *RADIUS Services
    for Linux*).
  prefs: []
  type: TYPE_NORMAL
- en: In a smaller environment, depending on the situation, you can easily secure
    your infrastructure with only a single CA server—just keep image backups so that
    if you need to restore, that byte-for-byte image is available and can be rolled
    back in minutes.
  prefs: []
  type: TYPE_NORMAL
- en: In a larger environment, it can still make good sense to have a hierarchal model
    for your CA infrastructure—for instance, this can make mergers and acquisitions
    much easier. A hierarchal model helps to maintain the infrastructure as a single
    organization, while making it simpler to bolt CAs for multiple business units
    under a single master. You can then use **operating system** (**OS**)-based security
    to limit the *splatter zone* in the case of a malware incident in one division
    or another; or, in a day-to-day model, you can use that same OS security to limit
    administrative access to certificates between business units, if that's needed.
  prefs: []
  type: TYPE_NORMAL
- en: The main risk in depending on image backups to protect your CA infrastructure
    goes back to how CA servers are traditionally used—in some environments, certificates
    might be required only infrequently. If, for instance, you keep a week's worth
    of server image backups locally but it takes you a month (or several months) to
    realize that the script or patch that you applied has imploded your CA server,
    then recovering from backups can become problematic. This is handled nicely by
    more widespread use of certificates (for instance, in authenticating wireless
    clients to wireless networks), and automated certificate-issuing solutions such
    as Certbot and the ACME protocol (pioneered by the Let's Encrypt platform). These
    things, especially in combination, mean that CAs are becoming more and more frequently
    used, to the point that if a CA server is not operating correctly, it's now likely
    that the situation will escalate in hours or days, rather than in weeks or months.
  prefs: []
  type: TYPE_NORMAL
- en: CA-specific risks in modern infrastructures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Certificate Authority* or *CA* is not a term that comes up in casual conversation
    at parties, or even in the break room at work. What this means is that if you
    give your CA server a hostname of `ORGNAME-CA01`, while the `CA01` part of the
    name makes the server obviously important to you, don''t count on the `CA` in
    the hostname being obvious to anyone else. For instance, it most likely won''t
    be a red flag for your manager, a programmer, the person filling in for you when
    you''re on vacation, or the summer student that has the hypervisor root password
    for some reason. If you are a consultant, there might be no-one who actually works
    in the organization that knows what the CA does.'
  prefs: []
  type: TYPE_NORMAL
- en: What this means is that, especially in virtualized infrastructures, we see CA
    VMs being (sort of) accidentally deleted from time to time. It happens frequently
    enough that when I build a new CA VM, I will usually call it `ORGNAME-CA01 – DO
    NOT DELETE, CONTACT RV`, where `RV` represents the initials of the admin who owns
    that server (in this case, it would be me).
  prefs: []
  type: TYPE_NORMAL
- en: It might make good sense to put alerts in place when any server VM is deleted,
    advising whoever is on the administration team for that host—this will give you
    another layer of if not defense, then at least a timely notification so that you
    can recover quickly.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, implementing **role-based access control** (**RBAC**) on your hypervisor
    infrastructure is on everyone's best-practice list. Only the direct admins for
    any particular server should be able to delete, reconfigure, or change the power
    state of that server. This level of control is easily configurable in modern hypervisors
    (for instance, VMware's vSphere). This at least makes it that much more difficult
    to accidentally delete a VM.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've got some security practices in place to protect our CA, let's
    look at CT, both from an attacker's point of view and that of an infrastructure
    defender.
  prefs: []
  type: TYPE_NORMAL
- en: Certificate Transparency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reviewing the opening paragraphs of the chapter, recall that one of the major
    *jobs* of a CA is *trust*. Whether it is a public or a private CA, you have to
    trust a CA to verify that whoever is requesting a certificate is who they say
    they are. If this check fails, then anyone who wants to represent [yourbank.com](http://yourbank.com)
    could request that certificate and pretend to be your bank! That would be disastrous
    in today's web-centric economy.
  prefs: []
  type: TYPE_NORMAL
- en: When this trust does fail, the various CAs, browser teams (Mozilla, Chrome,
    and Microsoft especially), and OS vendors (primarily Linux and Microsoft) will
    simply delist the offending CA from the various OS and browser-certificate stores.
    This essentially moves all of the certificates issued by that CA to an *untrusted*
    category, forcing all of those services to acquire certificates from elsewhere.
    This has happened a few times in the recent past.
  prefs: []
  type: TYPE_NORMAL
- en: DigiNotar was delisted after it was compromised, and the attackers got control
    of some of its key infrastructure. A fraudulent `*.`[google.com](http://google.com)—note
    that the `*` is what makes this certificate a wildcard that can be used to protect
    or impersonate any host in that domain. Not only was that fraudulent wildcard
    issued—it was then used to intercept real traffic. Needless to say, everyone took
    a dim view of this.
  prefs: []
  type: TYPE_NORMAL
- en: Between 2009 and 2015, the Symantec CA issued a number of **test certificates**,
    including for domains belonging to Google and Opera (another browser). When this
    came to light, Symantec was subject to more and more stringent restrictions. At
    the end of the day, Symantec's staff repeatedly skipped steps in verifying important
    certificates, and the CA was finally delisted in 2018.
  prefs: []
  type: TYPE_NORMAL
- en: To aid in detecting events of this type, public CAs now participate in **Certificate
    Transparency** (**CT**), as described in **Request for Comments** (**RFC**) *6962*.
    What this means is that as a certificate is issued, information on it is published
    by that CA to its CT service. This process is mandatory for all certificates used
    for **Secure Sockets Layer** (**SSL**)/TLS. This program means that any organization
    can check (or, more formally, audit) the registry for certificates that it purchased.
    More importantly, it can check/audit the registry for certificates that it *didn't*
    purchase. Let's see how that can work in practice.
  prefs: []
  type: TYPE_NORMAL
- en: Using CT for inventory or reconnaissance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we discussed, the primary reason that CT services exist is to ensure trust
    in public CAs by allowing anyone to verify or formally audit issued certificates.
  prefs: []
  type: TYPE_NORMAL
- en: However, in addition to that, an organization can query a CT service to see
    if there are legitimate certificates for their company that were purchased by
    people who shouldn't be in the server business. For instance, it's not unheard
    of for a marketing team to stand up a server with a cloud-service provider, circumventing
    all the security and cost controls that might have been discussed if the **Information
    Technology** (**IT**) group had built the server on their behalf. This situation
    is often called *shadow IT*, where a non-IT department decides to go rogue with
    their credit card and create parallel and often less-well-secured servers that
    the *real* IT group doesn't see (often until it's too late).
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, in a security assessment or penetration test context, finding
    all of your customer's assets is a key piece of the puzzle—you can only assess
    what you can find. Using a CT service will find all SSL/TLS certificates issued
    for a company, including any certificates for test, development, and **quality
    assurance** (**QA**) servers. It's the test and development servers that often
    are the least well-secured, and often these servers provide an open door to a
    penetration tester. All too often, those development servers contain recent copies
    of production databases, so in many cases, compromising the development environment
    is a full breach. Needless to say, real attackers use these same methods to find
    these same vulnerable assets. What this also means is that the *blue team* (the
    defenders in the IT group) in this scenario should be checking things such as
    CT servers frequently as well.
  prefs: []
  type: TYPE_NORMAL
- en: That being said, how exactly do you check CT? Let's use the server at [https://crt.sh](https://crt.sh),
    and search for certificates issued to `example.com`. To do this, browse to [https://crt.sh/?q=example.com](https://crt.sh/?q=example.com)
    (or use your company domain name instead if you are interested).
  prefs: []
  type: TYPE_NORMAL
- en: Note that because this is meant as a full audit trail, these certificates will
    often go *back in time*, all the way back to 2013-2014 when CT was still experimental!
    This can make for a great reconnaissance tool that can help you find hosts that
    have expired certificates or are now protected by a wildcard certificate. Old
    `*.example.com` (or `*.yourorganisation.com`). These certificates are meant to
    protect any host under the indicated parent domain (indicated by the `*`). The
    risk in using a wildcard is that if the appropriate material is stolen, perhaps
    from a vulnerable server, any or all hosts in the domain can be impersonated—this
    can, of course, be disastrous! On the other hand, after three to five individual
    certificates have been purchased, it becomes cost-effective to consolidate them
    all to one wildcard certificate that will have a lower cost, but more importantly,
    a single expiry date to keep track of. A side benefit is that using wildcard certificates
    means that reconnaissance using CT becomes much less effective for an attacker.
    The defenders, however, can still see fraudulent certificates, or certificates
    that were purchased and are in use by other departments.
  prefs: []
  type: TYPE_NORMAL
- en: We've covered a lot of ground in this chapter. Now that we've got a firm grasp
    on the place of certificates in a modern infrastructure, let's explore how we
    can use modern applications and protocols to automate the whole certificate process.
  prefs: []
  type: TYPE_NORMAL
- en: Certificate automation and the ACME protocol
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In recent years, the automation of CAs has seen some serious uptake. Let's Encrypt
    in particular has fueled this change, by offering free public-certificate services.
    They've reduced the cost of this service by using automation, in particular using
    the **ACME protocol** (*RFC 8737*/*RFC 8555*) and the **Certbot** services for
    verification of CSR information, as well as for issuing and delivering certificates.
    For the most part, this service and protocol focuses on providing automated certificates
    to web servers, but that is being scaled out to cover other use cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'Implementations such as Smallstep, which uses the ACME protocol for automating
    and issuing certificate requests, have extended this concept to include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Open Authorization (OAuth)/OpenID Connect (OIDC**) provisioning, using identity
    tokens for authentication, allowing **single sign-on** (**SSO**) integration for
    G Suite, Okta, **Azure Active Directory** (**Azure AD**), and any other OAuth
    provider'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API provisioning using APIs from **Amazon Web Services** (**AWS**), **Google
    Cloud Platform** (**GCP**), or Azure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**JavaScript Object Notation (JSON) Web Key** (**JWK**) and **JSON Web Token**
    (**JWT**) integration, allowing one-time tokens to be used for authentication
    or to leverage subsequent certificate issuance'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because certificates issued using the ACME protocol are generally free, they're
    also prime targets for malicious actors. For instance, malware often takes advantage
    of the free certificates available with Let's Encrypt to encrypt **command-and-control**
    (**C2**) operations or data exfiltration. Even for internal ACME servers such
    as Smallstep, any lapse in attention to detail could mean that malicious actors
    are able to compromise all encryption in an organization. For this reason, ACME-based
    servers typically issue only short-lived certificates, with the understanding
    that automation will "pick up the slack" by removing the increased administrative
    overhead completely. Let's Encrypt is the most well-known public CA that uses
    ACME—its certificates are valid for 90 days. Smallstep goes to the extreme, with
    the default certificate duration being 24 hours. Note that a 24-hour expiry is
    extreme, and this can have a severe impact on mobile workstations that may not
    be on the internal network each day, so a longer interval is usually set.
  prefs: []
  type: TYPE_NORMAL
- en: Previously to ACME, **Simple Certificate Enrollment Protocol** (**SCEP**) was
    used for automation, in particular for providing machine certificates. SCEP is
    still widely used in **mobile device management** (**MDM**) products to provision
    enterprise certificates to mobile phones and other mobile devices. SCEP is also
    still very much in use in Microsoft's **Network Device Enrollment Service** (**NDES**)
    component, in their **Active Directory** (**AD**)-based certificate service.
  prefs: []
  type: TYPE_NORMAL
- en: Speaking of Microsoft, their free certificate service does auto-enrollment of
    workstation and user certificates, all under Group Policy control. This means
    that as workstation and user-automated authentication requirements ramp up, so
    it seems does the use of the Microsoft CA service.
  prefs: []
  type: TYPE_NORMAL
- en: The overall trend in Linux-based CA services is to automate the issuing of certificates
    as much as possible. The underlying certificate principles, however, remain exactly
    the same as we've discussed in this chapter. As the *winners* in this trend start
    to emerge, you should have the tools in hand to understand how any CA should work
    in your environment, no matter the frontend or automation methods that may be
    in use.
  prefs: []
  type: TYPE_NORMAL
- en: With automation done, we've covered the main certificate operations and configurations
    that you'll see in a modern infrastructure. Before we wrap up the topic though,
    it's often useful to have a short "cookbook-style" set of commands to use for
    certificate operations. Since OpenSSL is our main tool for this, we've put together
    a list of common commands that should hopefully make these complex operations
    simpler to complete.
  prefs: []
  type: TYPE_NORMAL
- en: OpenSSL cheat sheet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To start this section, let me say that this covers the commands used in this
    chapter, as well as many of the commands you might use in checking, requesting,
    and issuing certificates. Some remote debugging commands are also demonstrated.
    OpenSSL has hundreds of options, so as always, the man page is your friend to
    more fully explore its capabilities. In a pinch, if you google `OpenSSL` `cheat
    sheet`, you'll find hundreds of pages showing common OpenSSL commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some steps and commands that are common in certificate creation:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a private key for a new certificate (on the applicant), run the following
    command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'To create a CSR for a new certificate (on the applicant), run the following
    command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'To verify a CSR signature, run the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'To check CSR content, run the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'To sign a CSR (on the CA server), run the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'To create a self-signed certificate (not normally a best practice), run the
    following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are some commands used when checking certificate status:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To check a standard `x.509` certificate file, run the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'To check a `PKCS#12` file (this combines the certificate and private key into
    a single file, usually with a `pfx` or `p12` suffix), run the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'To check a private key, run the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are some common commands used in remote debugging of certificates:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To check a certificate on a remote server, run the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'To check certificate revocation status using the OCSP protocol (note that this
    is a procedure, so we''ve numbered the steps), proceed as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'First, collect the public certificate and strip out the `BEGIN` and `END` lines,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, check if there''s a OCSP **Uniform Resource Identifier** (**URI**) in
    the certificate, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'If there is, you can make a request at this point, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'If there is no URI in the public certificate, we''ll need to get the certificate
    chain (that is, the chain to the issuer) then the issuer''s root CA, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This usually creates a large amount of output—to extract just the certificate
    chain to a file (in this case, `chain.pem`), run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are some OpenSSL commands used to convert between file formats:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To convert a `-----BEGIN CERTIFICATE-----`):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'To convert a DER file (`.crt`, `.cer`, or `.der`) to a PEM file, run the following
    command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'To convert a `PKCS#12` file (`.pfx`, `.p12`) containing a private key and certificates
    to a PEM file, run the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: OpenSLL commands are also used to convert a PEM certificate file and a private
    key to `PKCS#12` (`.pfx`, `.p12`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PKCS#12` format files are often required if an identity certificate is needed
    for a service but there is no CSR to provide the private key information during
    the installation. In that situation, using a **Personal Exchange Format** (**PFX**)
    file or a **Public Key Cryptography Standard #12** (**P12**) file provides all
    the information required (private key and public certificate) in one file. An
    example command is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Hopefully this short "cookbook" has helped demystify certificate operations
    and helped simplify reading the various files involved in your certificate infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With this discussion complete, you should know the basics of installing and
    configuring a certificate server using OpenSSL. You should also know the basic
    concepts needed to request a certificate and sign a certificate. The basic concepts
    and tools across different CA implementations remain the same. You should also
    have an understanding of the basic OpenSSL commands used for checking certificate
    material or debugging certificates on remote servers.
  prefs: []
  type: TYPE_NORMAL
- en: You should further understand the factors involved in securing your certificate
    infrastructure. This includes the use of CT for inventory and reconnaissance,
    for both defensive and offensive purposes.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 9*](B16336_09_Final_NM_ePub.xhtml#_idTextAnchor153), *RADIUS Services
    for Linux*, we'll build on this by adding RADIUS authentication services to our
    Linux host. You'll see that in the more advanced configurations, RADIUS can use
    your certificate infrastructure to secure your wireless network, where the certificate
    will be used both for two-way authentication and for encryption.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we conclude, here is a list of questions for you to test your knowledge
    regarding this chapter''s material. You will find the answers in the *Assessments*
    section of the *Appendix*:'
  prefs: []
  type: TYPE_NORMAL
- en: What are the two functions that a certificate facilitates in communication?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the `PKCS#12` format, and where might it be used?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is CT important?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is it important for your CA server to track the details of certificates
    that are issued?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To learn more about the subject, refer to the following material:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Certificates on Ubuntu (in particular, building a CA): [https://ubuntu.com/server/docs/security-certificates](https://ubuntu.com/server/docs/security-certificates)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'OpenSSL home page: [https://www.openssl.org/](https://www.openssl.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Network Security with OpenSSL*: [https://www.amazon.com/Network-Security-OpenSSL-John-Viega/dp/059600270X](https://www.amazon.com/Network-Security-OpenSSL-John-Viega/dp/059600270X)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'CT: [https://certificate.transparency.dev](https://certificate.transparency.dev)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'CA operations on OpenSUSE (using YaST): [https://doc.opensuse.org/documentation/leap/archive/42.3/security/html/book.security/cha.security.yast_ca.html](https://doc.opensuse.org/documentation/leap/archive/42.3/security/html/book.security/cha.security.yast_ca.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'CA operations on Red Hat-based-distributions (using Certificate Manager): [https://access.redhat.com/documentation/en-us/red_hat_certificate_system/9/html/planning_installation_and_deployment_guide/planning_how_to_deploy_rhcs](https://access.redhat.com/documentation/en-us/red_hat_certificate_system/9/html/planning_installation_and_deployment_guide/planning_how_to_deploy_rhcs)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Easy-RSA: [https://github.com/OpenVPN/easy-rsa](https://github.com/OpenVPN/easy-rsa)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ACME-enabled CAs:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Smallstep CA: [https://smallstep.com/](https://smallstep.com/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Boulder CA: [https://github.com/letsencrypt/boulder](https://github.com/letsencrypt/boulder)'
  prefs: []
  type: TYPE_NORMAL
