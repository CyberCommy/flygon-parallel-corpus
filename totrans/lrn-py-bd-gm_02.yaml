- en: Learning the Fundamentals of Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python doesn't need in-game development, design, and analysis are considered
    the steps that are done before programming. Designing and analysis require that
    we brainstorm for ideas, model the procedures, and format the input. All of these
    procedures have something to do with data. Data can be something as simple as
    a list of numbers or as complex as weather history. This data has its own types
    and structures. Data needs to have its own storage location so that we can reference
    it. Python provides an abstraction of data in the form of objects that facilitate
    us to create a nested data structure.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will give you a roller-coaster ride of the core programming paradigm
    within Python. We will begin by learning about the different data types that are
    available and ways to capture them in variables or storage units. We will learn
    about different mathematical operations (arithmetic and trigonometric) using the
    `math` module. By the end of this chapter, we will have made our first game, tic-tac-toe,
    by using the knowledge that we have learned in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Handling values and data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variables and keywords
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operators and operands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing comments in the code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Requesting User Inputs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: String Operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building your first game – tic-tac-toe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Possible errors and warnings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Game testing and possible modifications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You will need the following requirements to get the full benefits of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: You'll need the Python **IDLE**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code assets for this chapter can be found in this book's GitHub repository: [https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter02](https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter02)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Check out the following video to see the code in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://bit.ly/2o6Kto2](http://bit.ly/2o6Kto2)'
  prefs: []
  type: TYPE_NORMAL
- en: Handling values and data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Software is evaluated as good or bad based on its capability to handle data.
    Every program has its own database design and implementation. A database is a
    schema where data is stored in such a way that it can be retrieved fast and securely
    so that it can be manipulated. It is assumed that social networks such as Facebook
    and Twitter collect 1.7 billion people's data each day. Such huge amount of data,
    which is collected on a daily basis, should be addressed properly because we don't
    have enough memory to store and process it. Hence, Python provides flexible built-in
    methods to map, filter, and reduce these datasets so that they can be stored and
    fetched faster for processing.
  prefs: []
  type: TYPE_NORMAL
- en: Python is lightning-fast when it comes to storing data as a schema. Its integration
    with big data platforms such as Hadoop, which inherits its compatibility, is the
    main reason we use Python in big datasets. Powerful packages such as NumPy, pandas,
    and scikit-learn provide data support for today's data and analytical needs.
  prefs: []
  type: TYPE_NORMAL
- en: A value is the representation of data for some attributes that are computed
    by programs. Here, attributes are the properties of any object. For example, when
    we talk about a person, we reference them by name, age, and height. These attributes
    have an *r*-value (the content of the attribute) and an *l*-value (memory location)
    attached to them. The *content of the attribute* refers to the value that is stored
    as the content of the variable, while the *memory location* refers to the physical
    place where the value is stored. For example, `name = "Python"` has a `name` variable
    as an attribute; its *r*-value is `Python` and its *l*-value is a unique ID that
    is assigned by the Python parser automatically as a memory location for the name
    attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Python, values are stored in the form of objects. Objects have four particulars:
    ID, namespace, type, and value. Let''s look at a simple example to uncover the
    particulars of an object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'When the `player_age` variable is created, its instance is created, which we
    call an object. Whenever an object is created, it receives a unique memory storage
    location, that is, a unique ID number, and assigns a type dynamically, that is,
    an integer, because we are assigning 90 to it. After that, the player variable
    is added to the namespace so that we can retrieve its value, that is, 90\. The
    following diagram attempts to simplify this explanation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/f8339e73-d20e-4f62-af02-a35b4ae74219.png)'
  prefs: []
  type: TYPE_IMG
- en: Whenever any assignment statement is executed, the parser creates an object,
    which gets a unique memory ID from where we can reference the value of the variable.
    Since Python is a dynamically typed language, it assigns a type of variable dynamically
    by analyzing the value that's been assigned to the variable. Eventually, it adds
    that variable to a global namespace so that whenever you want to fetch that variable,
    you can use the variable name. Here, `memory_ID` is the location that points to
    the value of an object. Some programming languages, such as C, call this a pointer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each of these values has a type associated with it. `1` is an integer, `a` is
    a character, and `Hello World` is a string. `Hello World` is a collection of characters
    and it is called a string since it defines a string of characters. In the previous chapter,
    we saw an example where we asked a user for input. Whenever a user types something
    as input, it is considered a string. These values define objects in programming.
    Let''s use a parrot as an example. It will have a name as a string, its age as
    an integer, and its sex as male or female, denoted by *M* or *F*, which are characters.
    In Python, a character is also represented as a string. To verify that, we have
    the `type` method. The `type` method is represented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command will be `<class ''str''>`, which implies
    that the character is also part of a string. To check the type of any value, we
    can use the same `type` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The preceding commands will show class as `int` and `str`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s talk about numbers. Numbers are of two types: whole numbers and
    decimal numbers. As we saw, a whole number is an integer, but a decimal number
    is a float. We call decimal numbers floating numbers in Python as they are represented
    in floating-point format, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The output of the preceding command is `<class 'float'>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can print these values in the Terminal using the `print` method. The `print`
    method takes values within parenthesis and gives the result in the interpreter,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If you put `1` within the `print` statement, it will print `1` as a number.
    However, when you put `1` within double quotes, it will print `1` as a string,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Any number, text, or special symbols, such as @, $, %,  or * you put inside
    a single quote or double quote will eventually be a string. The following is an
    example of a string: `1`, `Hello`, `False`,  `#$(#`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you put a comma between two values in a `print` statement, it puts a space
    between them, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will give you the output of `abc abc`, but they are no longer
    considered strings. This is the first semantic error we''ve seen in Python. We
    passed `abc` as a string, but the result is a non-type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This is a perfect example of a semantic error. We got the output without any
    errors, but we didn't get the result we wanted.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also check integers. It''s not possible to print integers with a comma
    between them. The Python interpreter converts commas into spaces between each
    value that''s passed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This command will give us a result of `0 0 0`. Each comma was converted into
    spaces and printed. If you check the type of the value that is returned from the
    function, it will also be `NoneType`.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know about value and types, let's get ourselves familiar with variables
    and keywords.
  prefs: []
  type: TYPE_NORMAL
- en: Variables and keywords
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Programming is all about accepting and manipulating values that we've learned
    about. We make use of variables while accepting and manipulating those values
    so that we can reference them for future use. Variables are like boxes, where
    you put in different things and fetch them whenever they're required. A variable
    is created with a name and a value assigned to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use the equal to sign (`=`) to make an assignment statement. Variables are
    created with assignment statements; for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Here, we created three variables with assignment statements. In the first command,
    we made the `myAge` variable and assigned an integer to it. You do not have to
    specify types of variables explicitly in Python since Python does it internally.
    This is what makes Python a dynamically typed language. In the second command,
    we made the `info` variable and assigned a string to it. Finally, we made the `isHonest`
    variable and assigned a Boolean to it.
  prefs: []
  type: TYPE_NORMAL
- en: Boolean types are logic types. They are either `True` or `False`. Creating a
    Boolean variable is the same as creating other variables, for example, `is_hungry
    = True`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Variables are basic pieces of data storage. We can assign one value to a variable at
    a time. Whenever you assign another value to the same variable name, it will overwrite
    the original one. For example, here, we made the `info` variable a string, but
    if I replace it with another value, say, `integer`, this is valid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'If you make variables in Python, it will create separate memory references
    for each variable. So, any time you replace the same variable in another value,
    the value at that particular position will be retrieved and overwritten with the
    new one. Variable names are pointers to the value in the reserved memory location.
    You can''t store multiple values in a variable. You have to use advanced data
    structures to do this. We will cover this in the upcoming chapters (CHAPTER 4:
    Data Structures and Functions: Refine Your Game with Taste of AI).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Assigning multiple variables to different variables can be done in a single
    line of code. We can assign them with a single assignment statement. The variable''s
    name should be given at the left-hand side and they should have commas between
    them. You can create as many variables with distinct data types in a single line
    as you want with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see the value of your variable by directly writing the variable''s
    name in the Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If you only write the name of a variable in the script, the value won''t be
    printed. Instead, it will terminate. If you want to print something on the screen,
    you have to use the `print()` method. To print the value of any variable, type `print(variable_name)`
    in your shell or script, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to see the type of the value that''s stored in the variable, you
    can call the `type()` method. To do this, pass the variable''s name inside parentheses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command will give us the output of `<class 'int'>`, which implies
    that integer values can be stored in variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also assign the same value to multiple variables in Python. In the preceding
    command, instead of assigning multiple values, we assigned a single value to it,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding command, we assigned an integer value of 10 to two different
    variables, `even` and `num`.
  prefs: []
  type: TYPE_NORMAL
- en: Python doesn't need variable instantiation and declaration. Hence, there is
    no need for reserved memory space in Python. Python does this internally when
    we create variables with assignment statements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python has reserved 33 words as keywords for specific functionality. We cannot
    use them to name variables. Python checks the name of the variable with these
    keywords internally with its in-built script. Whenever it detects one of those
    words, it will throw a syntax error, as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command isn't executed and cannot be used as a variable name because
    it is a keyword. Python uses it to do some logical operations. However, if you
    create a variable called `And` and assign a value to it, Python will create the `And` variable
    for you. For Python, `And` and `and` are not the same. It is a case-sensitive
    language.
  prefs: []
  type: TYPE_NORMAL
- en: To avoid any issues with your variable names, we can follow a few simple rules.
    We'll go over these rules in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Rules for naming variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We normally choose meaningful variable names because, in the long run, there
    may be cases where we completely forget about code sequence and flow, and variables
    that don't have a proper name can create confusion. Although you can create variables
    with any name by following some rules, it is highly suggested to create variable
    names that make sense. Let's say you are making a game where you want to create
    a variable for the player's health; naming that variable `a` is not good practice.
    Instead, you should name it `player_Health` so that it's clear to you and those
    who may look at your code what the code in this variable does.
  prefs: []
  type: TYPE_NORMAL
- en: Usually, from a programming perspective, there are two ways of giving a variable
    a name effectively. Two of them are famously known as `CamelCase` and `PascalCase`.
    Observing the naming convention of the previously defined variable, `playerHealth`,
    the first character of the variable should be lowercase and all of the others
    should be in uppercase. Similarly, in the case of `PascalCase`, every first character
    of the variable should be in uppercase. Hence, using `PascalCase`, the previously
    defined variable can be written as `PlayerHealth`. You can use either of them
    to name your variable.
  prefs: []
  type: TYPE_NORMAL
- en: Your variable name can be any length. It can contain a combination of uppercase
    alphabetical letters (A-Z), lowercase letters (a-z), digits (0-9), and an underscore
    (_). An underscore is used in-between two words to distinguish two entities in
    a variable. For example, the `player_Health` variable is made up of two words.
    We use the underscore in-between them. Alternatively, you can also use `camelCase`,
    where you start your first word in lowercase and the first letter of the second
    word in uppercase, for example, `playerHealth`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use an underscore at the start of the variable''s name. We use
    them in our code if it''s being used as a library for others. We can use them
    in recursive statements, too, as in the example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'There are some rules we need to follow while naming a variable, otherwise Python
    will declare it illegal and throw a syntax error. The following screenshot shows
    some illegal assignment statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/32303842-b5f5-4db7-8f21-fb372bff8957.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To remove the preceding errors, we have to follow a few rules. Some are mandatory
    while some are just good practices:'
  prefs: []
  type: TYPE_NORMAL
- en: We give the variable a name that makes sense. Naming the age variable `age` is
    more meaningful than naming it `a`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We cannot use special symbols (@, #, $, and %) while naming variables. For
    example, n@me is not a valid variable name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A variable name should not start with digits. 45 age is not a proper variable
    name and Python will throw an error.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Declare constants with an uppercase name, for example, `>>> PI = 3.14`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's good practice to use `camelCase` to create variables name, for example,
    `>>> myCountry = "USA"`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have now seen what variables and keywords are and some rules to follow when
    naming them. Now, let's move on and see what operators and operands are.
  prefs: []
  type: TYPE_NORMAL
- en: Operators and operands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Math and programming are two distinct fields that are closely related. The former
    deals with theory and provides formulated principles to solve any problem domain,
    while the latter deals with using those principles to solve a business domain.
    Programming is all about accepting data using models and manipulating it with
    the appropriate mathematical operations. Operators are used to perform those operations.
    We have arithmetic and logical operators in Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'Operators are symbols that perform computations such as addition, multiplication,
    division, and so on. Symbols such as `+`, `-`, and `/` are used to perform those
    operations. The values that operators are applied to are called operands. Some
    examples of operators are shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding examples, the result of the first operation is 7, the result
    of the second operation is 0, and the result of the last operation is 8\. You
    can add or subtract as many numbers as you like within the shell. Here, all of
    the numbers are operands, and symbols such as `+`, `-`, and `*` are operators.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another important operator in Python is division (`/`). In Python 3.x, the
    division operation results in floating-point numbers, as in the example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The preceding operation gives you a result of 2.5\. This is the same result
    that we get using a calculator.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Python 2.x, the interpreter would truncate the decimal part and give us
    a result of 2\. If you want to get the same result in Python 3.x, you should use
    floor division (`//`); for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The preceding operation will give us a result of 2 instead of 2.5.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go over what we''ve learned so far, that is, values, variables, and
    operators. Let''s combine all of these into one statement. This is known as an
    expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: You can combine all of these to make any type of expression. The assignment
    operation is the simplest expression to use. We saw the assignment operation while
    creating variables.
  prefs: []
  type: TYPE_NORMAL
- en: When there are multiple operators being used in an expression, the order of
    these operations becomes important to solve the expression. We'll go over the
    order of operations in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Order of operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s recall the basic math that we mostly learned in our school days. You
    may have heard of the BODMAS rule or the PEDMAS rule. Whenever more than one operator
    is used in our expression, an operation is performed with this rule of precedence. Operations
    in brackets/parenthesis, exponentiation, division, multiplication, addition, and
    subtraction are performed in this order:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Parentheses/brackets**: This symbol has the highest precedence, which means
    that operations within parentheses are completed first. With the use of parentheses
    in your expression, you are telling the interpreter to explicitly execute a certain
    expression forcefully. For example, in `(10 - 5) + 5 * 6`, the operation within
    the parentheses is done first, that is, *10 - 5*, and then multiplication is done.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Exponential/of**: Th exponential operation is done after operations within
    parentheses are completed. The output of `9**0+1` is not 9; instead, it is 1\.
    Exponential is done first, and then addition is done.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Division**: Division operations are done after exponential if operations,
    including division if it''s not inside parentheses. For example, `10 / 2 + 3 +
    9 / 3` is 11 but not 5\. If the expression was `10 / (2 +3) + 9 /3`, the output
    would be 5.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Multiplication**: It has also the same precedence as that of division. However,
    if the expression has both division and multiplication, operations are done sequentially
    from left to right. Scanning from left to right, if we get multiplication before
    division, it is done first. For example, the output of `3*4 / 3` is `4` but not
    3.999.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Addition and subtraction**: These two operations also have the same level
    of precedence. Thus, we perform these operations according to what comes first
    while scanning from left to right. For example, in terms of `5 - 5 + 6`, we subtract
    first as it comes first and then add, which gives us 6.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you are still confused about the BODMAS/PEDMAS rule, you can simply use
    parentheses to make sure you get the intended result. In the next section, we
    will learn about two important operators: `//` and `%`. The former is known as
    floor division, while the latter is known as the modulus operator.'
  prefs: []
  type: TYPE_NORMAL
- en: Modulus operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Earlier, we saw how to use floor division (`//`) and how it provides us with
    only the quotient of the division operation. But if you want the remainder of
    your division, use the modulus operator. The modulus operator yields the remainder
    of when the first operand was divided by the second operand. The symbol for the
    modulus operator is the percentage sign (`%`). The following screenshot shows
    two operations: the first one is a floor division, which will result in a quotient,
    while the next one is a modulus operation, which will result in the remainder
    of the division:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/150412e6-94be-4faa-9bd0-32e2e6986fc7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The modulus operator is very useful when we want to search number patterns
    and make programs that can divide numbers based on that pattern. For example,
    we can check the remainder of division between any number and 2 to find whether
    the number is even or odd:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Since the preceding operation gives the remainder as 1, 5 can be considered
    an odd number.
  prefs: []
  type: TYPE_NORMAL
- en: All of the preceding operations are pretty basic and don't need any hard work
    to calculate. However, we know that computers are known for processing complex
    tasks. Hence, in the next section, we will learn about the `math` module, which
    is capable of performing intricate mathematical operations such as calculating
    trigonometric and complex equations.
  prefs: []
  type: TYPE_NORMAL
- en: Using the math module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Math is not only limited to addition and multiplication. So far, we have learned
    about various arithmetic operations. We haven't at logical operators and comparisons
    yet as those will be covered in the next chapter. To incorporate many domains
    of mathematics, Python has given us one powerful library, called the `math` module.
    We call the file that contains the code a module. These libraries are also called
    in-built libraries because they come prepackaged whenever we install Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'They are made by Python and we can call them whenever we want in our code without
    having to install it manually. If you want to use the code of any in-built library,
    you have to call it first. Calling them means importing them. To import and use
    that in-built library, we use the `import` keyword. As you may recall from the
    previous chapter, it''s a reserved word that has a specific purpose in Python.
    Hence, the `import` keyword imports any library into your code. If you want to
    import the `math` module, for example, just write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'You will instantly see the next line with an empty shell, like this: `>>>`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'That just specifies that you are importing it. Import statements are not the
    same as print or input methods, which give us an instant response. We should call
    something from that module in order to see any response or result. The `math`
    module provides us with numerous operations. These can be accessed by following
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open your IDLE and press *F1* to open the documentation. You will see the following
    window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](Images/379348e2-3ebf-4de9-94df-af2e49cd1add.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, click on modules. You will see a new window containing a list of modules:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](Images/fec0ac60-a9f1-4d65-b02d-f16e3f0f455b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Search for the math module from that tab or simply press *M* on your keyboard
    if you want to navigate through the list of modules that starts with the letter
    `m`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](Images/801ce731-abb7-479d-8898-ef017a539a56.png)'
  prefs: []
  type: TYPE_IMG
- en: There are so many methods to use! Don't get overwhelmed with the term methods;
    we have dedicated a section to object-oriented programming where we will learn
    how to create our own methods. Right now, just think of a method as operations
    we use to create expressions. The methods that are provided by the `math` module
    are also going to perform simple arithmetic operations and many other complex
    ones. If you want to get a square root, we don't have specific operators to do
    that, nor can we perform complex mathematical operations; instead, you have to
    use a math module. We'll look at square roots in the following example.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get the square root of a number, we can use the `sqrt` method. Check out
    the documentation for the `sqrt` method to find out more about it and learn how
    to call it. It''s super easy! First of all, we write `math`, then a period (`.`),
    which signifies that we want to use something from the math module and use the `sqrt`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The square root of `49` is 7\. Our interpreter prints 7.0 as `sqrt` performs
    a floating-point operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you didn''t import the `math` module and instead called `sqrt` directly,
    you will receive the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/c2a4dca0-33d7-49c1-89de-445070cc088d.png)'
  prefs: []
  type: TYPE_IMG
- en: As you may recall when we discussed the `print()` function, we didn't call it
    using any module because it was an in-built function. However, this `sqrt()` function
    is not in-built. It is from an in-built library of Python. Although we don't have
    to install it like any other third-party modules, we have to import it before
    using any of the features provided by it. All of the modules that are provided
    by Python are in lowercase.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can call a range of functions and constants from math modules. This allows
    us to do numerous operations that support complex mathematical computations. If
    you want to print the value of PI, you can do so with the `math` module, like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, we import it with `>>> import math`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we use `module_name` and provide a period (`.`) to specify we want to
    use that module and the type operations we want to perform, for example,  `>>>
    math.pi`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can perform algebraic, logarithmic, trigonometric, hyperbolic, and a wide
    range of other operations with math functions. However, this module cannot perform
    math operations for complex numbers, for example, `z = a + ib`.
  prefs: []
  type: TYPE_NORMAL
- en: For those types of complex numbers, we have to import the `cmath` module. Importing
    and working with this module is also similar to that of the `math` module.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to use the functions provided by the `math` module with calls to `print()`
    or `input()` without putting a dot, you can use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding command, `*` implies that you want to import everything. It
    is canonically saying *From the math module, import everything*. Now, if you want
    to call any functions from the math module, you can call it directly, similar
    to what we do with the input and print functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The preceding function will be executed perfectly and give us a result of 24.
  prefs: []
  type: TYPE_NORMAL
- en: You may be wondering why the concept of modules wasn't explained at the beginning
    of this book. It's simple! We just learned about operators, operations, and expressions,
    which means it's easy to relate to the math module. Every function we call from
    the `math` module contains operators, operands, and expressions, but its implementation
    is hidden from our eyes. For example, we simply use the `sqrt` function to perform
    a square root operation, but we don't know how the square root is done with expressions
    and logic. We will learn about this in the upcoming chapters when we cover flow
    controls and functions. Hence, modules provide us with a way to perform high-level
    operations without having to know how they work. However, if you want to make
    your own libraries and modules, then the upcoming chapters will help you.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to learn more about modules and functions, you can simply use the
    `help` command. The Python `help` command will give you a complete list of documentation
    for built-in functions, modules, and keywords, as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s enough talk about values and types. Now, let''s look at how we can
    make our code more readable and reusable, that is, others should be able to read
    our code easily. We talked about the rules and conventions that should be followed
    while naming the variable, which also leads to readability. There are two ways
    of making code readable:'
  prefs: []
  type: TYPE_NORMAL
- en: Write notes within the program.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Pythonic way is to make a function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can add notes to the program via commenting, which will be covered in the
    next section.
  prefs: []
  type: TYPE_NORMAL
- en: Writing comments in code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even if you are making a normal piece of software, it has to interact with data
    in one way or another. Eventually, your code will become lengthier and complicated
    and becomes hard to manage, read, and understand. Although we will eventually
    understand the code we've written, it will be harder in the long run. If you have
    50,000 lines of code and want to debug the semantic and logic errors in it, it
    would be hard for you to search and index them. Hence, comments come in handy.
    Comments are a way of writing notes along with your code so that anyone who tries
    to read your code knows what that program is doing. Comments are not interpreted
    by Python, which means whenever the Python parser sees that the statement starts
    with a hash symbol (`#`), its execution will be skipped.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python design patterns can be convoluted, which makes it difficult for any
    naive programmer to look at the code and understand what it is doing. Hence, we
    add simple notes about the program in our native language that explains why we
    are writing a particular piece of code. Comments that start with `#` are single-line
    comments. If you write something below the line containing hash, it won''t be
    considered a comment. This is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'In Python, there are no multi-line comments. People usually think that triple
    double quotes (`""" """`) are used for multi-line comments, but that''s not true.
    Using hashes is the only way of commenting in Python. In Python 3.x, a string
    inside triple quotes is considered a regular string. You can use triple double
    quotes to remove the broken string. Strings are considered to be broken when the
    scope of the string is not totally enclosed, as in the example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding string was created with a single quote. An apostrophe was used
    in the string, which creates confusion for the interpreter as it thinks `hey it` is
    a string and it ignores `s me`. This is a broken string. Not every piece of text
    you encounter will be in a string. If you run this code in IDLE, you will get
    the following syntax error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/c65043ea-afa5-48f8-ab49-d9d9bdea2ce4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To eradicate this error, you can use a triple quote. A triple quote will remove
    the broken string, even if a double quote or single quote appears on your string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Many people think that the preceding line of code represents a multi-line comment,
    and do something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/158f7921-4c38-452f-a5af-6a0edad82b41.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can clearly see that, instead of ignoring to execute that command, it has
    reflected our command by creating a string for us. If we do not assign a value
    enclosed in triple double quotes to the variable, it is treated as a garbage collector
    and gives us a string. Many people confuse it as a multi-line comment because
    of its behavior as a docstring. Docstrings are strings that are placed at the
    top of functions, modules, or classes. For example, this is the function that
    performs the add operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Obviously, we haven't learned how to create functions yet, but you can get the
    idea that a triple-double quote is used to provide some information about functions,
    classes, and modules. Hence, some people think of it as a multi-line comment.
    You can tell it is not a multi-line comment because the notes inside the triple
    quote can be accessed with a special function of Python.
  prefs: []
  type: TYPE_NORMAL
- en: Since this is docstring, we can access it through **`obj.__doc__`**. Since it
    can be accessed by a method and it is not ignored by the interpreter, it cannot
    be considered a multi-line comment. Due to this, we can conclude that there are
    only single-line comments in Python. If we do want multi-line comments, it should
    be done using triple double quotes, but we have to make sure that we place them
    above the definition of the function, class, or module.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code, `\n` represents a new line. This will cause a line break
    in the code. As we can see, the following code prints `hey` in the first line
    and `it''s me` on the next line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'From this, we can conclude the following about comments:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Comments are redundant. They simply tell us what every line of code is doing:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Comments may contain useful information about the code – even some critical
    information that we cannot extract by looking at the code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: As we discussed in the previous chapter, we have to follow a convenient pattern
    while creating programs. Although this is not mandatory, it is always good practice.
    In the *Building blocks of Python* section, the first block was requesting user
    input, which will be our next topic of discussion.
  prefs: []
  type: TYPE_NORMAL
- en: Requesting user input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the building blocks of programming is to make the user input data with
    their keyboard. Any application, whether it be for management tools or games,
    all should take input from the user. In a user management application, we gather
    user information such as their name, address, and age, and insert it into a database.
    In games, we take user input from the keyboard to make movements. Based on the
    key that's pressed by the user, we can make our character perform some actions.
    For example, pressing the *Shift* key on the keyboard will make the character
    jump. Thus, every application has to be user-friendly, which means it has to make
    the user interact with the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Letting a user input something on their keyboard and storing it in a variable
    so that we can process it further when required is a common practice. Python has
    in-built functions to get input from users, which means you don''t have to import
    or install anything to use this function. The `input()` function is used to take
    input from a user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: When you enter the preceding command, it will give you a place to write something.
    The interpreter holds its other execution until the user presses a button on their
    keyboard and presses *Enter*. On pressing the *Enter* key, the program resumes
    and gives us the text input of the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows how the `input()` function works in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/e15f0424-e5d6-4e2c-a80d-845f6acca596.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding screenshot, we used the `input()` method and entered the string
    ''I love Python''. The black text color is input from the user, and the interpreter
    instantly gave us some output, which was the same input string from user. You
    can store input text into variables so that we can perform computations on it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have seen how to input data from the user. It is always good practice
    to provide a message or prompt to the user telling them what they need to enter
    in that field. A message or prompt should be given as a string within the parentheses
    of the `input` method, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, when the user inputs something and hits *Enter*,
    our program takes the input from the user and does the specified task. But if
    you want to make an application where you want to take data from the user continuously,
    we have to make use of loops. We will study loops in the upcoming chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding statement takes input from the user continuously. It doesn''t
    stop, even after pressing *Enter* or typing in the `return` keyword. In the preceding
    command, `while` is used for looping. `True` is a Boolean type that represents
    the truth value of the logic and Boolean algebra. Boolean types are either `True`
    or `False`. Hence, the `while True` statement implies that the code inside it
    should run infinitely, which asks the user to make input infinitely. The result
    of this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/80de89ab-ae5c-4db1-8a67-6e9db7c1b42f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Anything you enter on your keyboard while calling `input()` method will be
    in string form, even you input it as integers, as in the example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'If you check the type of the `a` variable by using the `type` method, that
    is, `>>> type(a)`, you will see some unexpected results. We input `1` from the
    user and stored it in a variable, `a`. When we check the type of value that''s
    stored in the `a` variable, it won''t be an integer. Instead, it will show `str
    class: <class ''str''>`, which means anything that you enter on your keyboard
    by calling the `input()` method will be of the string type. But sometimes, it
    may be the case that we want the integer that was input by the user to remain
    an integer. In such a case, we have to perform typecasting, which will be covered
    in the next section.'
  prefs: []
  type: TYPE_NORMAL
- en: Typecasting or type conversion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There may be times where you want to use the input data of a user as an integer.
    We saw that the input data from a user will be a string, even if it is an integer,
    as in the example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Age is represented in terms of numbers. However, in the preceding code, it''s
    a string. Hence, we have to convert it into an integer so that information entered
    by the user will be meaningful for computation. This type of conversion is called
    typecasting. However, if you do some computation in this value without casting
    it to the appropriate type, your result will be undesirable. For example, if you
    want to change the value of age by adding 2 to 29, you cannot change it from 29
    to 31\. This is because strings do not support increments; instead, they support
    concatenation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Hence, if you want to use the age that was entered as an integer, we have to
    use typecasting methods. These methods are also in-built functions of Python.
    Some of them are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`int(arg1, base)`: This method converts any other data type into an integer.
    If you put a string inside the parentheses of the `int` function, it will convert
    it into an integer. `arg1` is the string to be converted and the base argument
    indicates the base of the data is a string:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '`float()`: This method converts any integer into a floating-point number, as
    in the example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '`str()`: This method converts any other data types into a string, as in the
    example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '`ord()`: This method converts a character type into integer and gives back
    its ASCII value, as in this example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Other functions such as `tuple()`, `list()`, `set()`, and `dict()` will be covered
    in the upcoming chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you are familiar with the first building block of Python, that is,
    inputting data from the user, let's see how we can format this data using different
    features provided by Python. In the next section, we will look at string operations
    that will, in turn, call different methods provided by Python to manipulate the
    input entered by the user.
  prefs: []
  type: TYPE_NORMAL
- en: String operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Any data type, be it text, an integer, or a Boolean, written either in double
    quotes (`" "`)  or single quotes (`'' ''`) is considered a string by Python. String
    values uncover the broad meaning of data. Data that''s stored as strings can be
    easily accessed but cannot be changed. Hence, it is considered as immutable data
    types. Let''s take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we created the `msg` variable and stored a string in
    it. We used the built-in method of the `string` class to manipulate that string
    and when we printed the `msg` variable back, it was unchanged. This implies that
    strings are immutable data types. If you want to change the content of a string,
    you should completely overwrite it, as in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Strings do not support item assignment. If you want to add an item to the string,
    you have to make a completely new string. Hence, this feature of Python makes
    it immutable, as in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'To use the built-in functions of a string, you have to call a method on the
    string. Let''s look at a pattern we can use in the in-built method, that is, `"String".method_name()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'You can access every element of a string by using square brackets. We should
    put the position inside the square brackets. These positions are called indexes
    in Python. The index of a string starts from 0 and increases by 1 from left to
    right:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'You can observe the indexing pattern in the following diagram. Here, we have
    a `Python` string. The index of the string starts from 0\. For each element right
    next to it that has an index, a unit is incremented to that of the previous element.
    This is called positive indexing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/0d75ec16-fe47-46f5-a0e7-5f2516730636.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Strings also support negative indexing. If you want the last digits from a
    string, you can give a `-1` index, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have learned how to extract the particular elements of a string based
    on indexing. But if you want to extract more than one element from a string, you
    can use string slicing operation. The slicing operation is the same as a pizza
    slice, which represents we are taking out some parts of the string in a sequential
    order. String slicing can be done with the same square brackets that we used for
    extracting a single character from a string. The difference between these two
    operations is seen when we extend our square brackets with a colon and provide
    start, end (exclusive), and step indexes to it. Although the theory of string
    slicing may seem complicated, it is easy to program. Let''s take a look at an
    example to clarify this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Suppose we want to extract the name of a person from this email address. We
    have to track all of the indexes to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/5bea629a-3190-4d34-8398-c196671068a8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Since we are slicing some parts of that string, we have to imagine it as a
    container where each character resides with its index so that referencing them
    would be easier. To achieve string slicing, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use `name_of_string[start: stop`: We use the `[step]]` command for string slicing.
    Here, `start` is the starting index and `stop` is an exclusive position, which
    means if you put an index on it, the element of - 1 will be included but the element
    at the stop index will be excluded. Here, step is optional. We will talk about
    the step index position in an upcoming chapter (Chapter 3: Flow Controls: Build
    Decision Maker For Your Game)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Decide what needs to be extracted first. You cannot extract any part of a string
    randomly. It should be done sequentially. For example, you cannot extract `jo`
    and `mail` with a single command. We can extract `johndoe` because every element
    is in a sequential manner. Let''s try to extract it from our code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, `email[0:7:]` or `email[:7:]` tells us that the first
    index, 0, is starting an index of a string, which means we want to print from
    `start`. Instead of 0, you can also put nothing, which represents the default
    state, and `start` will print from the start. The second index, 7, is the stopping
    position, but it is an exclusion position which means the interpreter will print
    until the `e` character but not `@` because `@` is at position 7\. Finally, the
    third index position is for step. We put an empty space here to represent the
    value it should hold by default, which means we are printing without skipping
    any numbers. If you put step as `>>> email[0:7:2]`, you will get `jhde` as the
    output; it will skip one character between each of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also perform addition and multiplication operations with strings. Adding
    two strings together is called concatenation. We make use of operators such as
    `+` and `*` to perform string operations, as in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'However, you cannot multiply two string types. One must be a string and the
    other must be an integer if we wish to perform multiplication operations with
    strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'If you also want to add strings, both of the operands must be strings. Otherwise,
    it will throw a type error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have learned about the fundamentals of string operations, such as
    assignment, concatenation, and assignment, we will learn about string formatting.
    This is an important concept if we need to change the format of the text based
    on the input.
  prefs: []
  type: TYPE_NORMAL
- en: String formatting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'String formatting is where we build our string by replacing placeholders with
    the content of variables. We apply % (the modulus operator) to perform string
    formatting. If you want to specify a digit as a placeholder, `%d` is used. If
    it is string, `%s` is used as the placeholder. The result of string formatting
    is also a string. Let''s look at a small example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the position of `%s` was replaced by the value of the
    key variable and the position of `%d` was replaced by the value of the `value` variable.
    Hence, `%d` and `%s` are placeholders. You cannot assign a string value in place
    of `%d` and cannot assign an integer value in `%d`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The number of values that are passed must match the number of format sequences
    used in a string. Otherwise, it will throw a type error, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also format your string using Python''s built-in format function. It
    is relatively easier to format using this function. Instead of using placeholders
    or format sequences such as `%d` and `%s`, we can use curly braces `{}` as placeholders.
    We can also assign numbers inside curly braces so as to format with a particular
    value, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we are familiar with the core programming paradigms of Python, let''s
    hop over to the next section, where we will learn to make our first game: **tic-tac-toe**.'
  prefs: []
  type: TYPE_NORMAL
- en: Building your first game – tic-tac-toe
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Python language is a cross-platform language, which means we can make games
    for any device. However, here, we will focus more on the logic and its implementation
    rather than coding for a specific platform. Coding games with Python is simple
    compared to other languages as its syntax is shorter and it provides rich-content
    libraries that make production faster. With that being said, it isn''t that easy
    if you don''t make plans before coding. We have to break our game entity into
    parts so that each entity can be debugged easily. We will follow these general
    steps while making games from now on:'
  prefs: []
  type: TYPE_NORMAL
- en: Brainstorming and information gathering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choosing a proper code editor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Programming model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User interaction—user input/manipulation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So far, we have covered a variety of topics, including variables, operators,
    expressions, taking input from a user, and printing it to a user. Let's apply
    all of these techniques now to make our first game.
  prefs: []
  type: TYPE_NORMAL
- en: Brainstorming and information gathering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we start coding, let''s think about the design and interface of our
    game. Pull out your pen and paper and start thinking about the interface of the
    game!  Did we learn anything about the GUI so far? Obviously not! That means we
    have to make use of a simple interface for our first game. We will modify it later,
    after we learn about some advance concepts of Python. Tic-tac-toe is a game that
    takes input from a user and places either X or O based on the player''s movement.
    Hence, our interface should be a placeholder for these symbols. We will make a
    simple interface containing `_` for now. An underscore (`_`) will be our placeholder
    where we will put either X or O based on player selection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code shows the simple layout of our game. It contains `_` (underscores)
    as placeholders and `|` to separate the symbols:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, whenever the player takes a step, we replace that underscore
    with a symbol corresponding to that user's decision. Now, we have a basic interface
    for our game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have planned the interface, we need to work out how to track the
    position of the underscore and how to find out where to replace the underscores
    with the appropriate symbols. We can assign numbers to each of these underscores
    and tell the user to choose a number. Then, based on that number, we can assign
    its symbol to that location, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Now, we have gathered enough information to start our simple game. In complex
    real-world games, the brainstorming and information gathering process would take
    around 6 months. Now, let's look at choosing a code editor.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing  proper code editor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have already installed Python On our machine, and we took a look at the
    pre-installed editor of Python, IDLE. We will use that editor for this project.
    Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Search for IDLE in your search bar and open it. You will get the following
    Shell:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](Images/87ad6991-f4ca-466c-8ff3-2724089f82d6.png)'
  prefs: []
  type: TYPE_IMG
- en: This Terminal or Shell is normally used to interpret commands instantly within
    the Shell. This means that one command will execute at a time, but we have to
    write many lines of code to make our game. Hence, writing a game with this Shell
    is not possible. We have to create a file where we can write many lines of code
    and execute them all at once. Python provides us with scripts to facilitate this
    problem.
  prefs: []
  type: TYPE_NORMAL
- en: Click on File and then New File, or press *Ctrl* + *N*. A new script file will
    open where we can write multiple lines of code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](Images/a3bf3719-f952-461e-afa9-3e591d468030.png)'
  prefs: []
  type: TYPE_IMG
- en: At the top of the window, we will see Untitled, which means we haven't saved
    our file yet. Let's save it first because we have to save it anyway afterward.
    Press *Ctrl* + *S* to save it. I have saved it as `first_game.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](Images/d9cd0064-2b31-4664-9999-1224565e887d.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that we have selected the proper IDE for development, let's start developing
    our model for the game.
  prefs: []
  type: TYPE_NORMAL
- en: Programming model or modelling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In programming, a model is a way to represent the flow of data in your program.
    In our game, it is about how to use data that's been obtained as user input. We
    uncovered some information in the *Brainstorming and information gathering* section,
    where we talked about positions and how each number was assigned to the position
    that represents player selection. The model does not contain presentation logic;
    instead, it will deal with data logic. The computer doesn't care about layouts
    or interfaces. The user, on the other hand, requires an interface in order to
    react. Thus, every program has a frontend and a backend. The frontend is everything
    that you see in the application, whether it be an aesthetic or visible part of
    the application. **User experience** (**UX**) designers work mostly on frontends
    in big projects. The backend doesn't care about designs—it only cares about the
    algorithms and security that are applied to the data layer for the transaction
    of data. Models are used as a way of communication between the frontend and the
    backend.
  prefs: []
  type: TYPE_NORMAL
- en: 'The computer does not care how the model presents data, but the user should
    get data out of the model in an informative and pretty way. Due to this, we made
    simple layouts that look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s start creating our model for the presentation layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code represents the layout for our game. It is displayed to the
    user. Let''s break it down line by line:'
  prefs: []
  type: TYPE_NORMAL
- en: '`game_board = [''_''] * 9`: This statement creates 9 underscores, which is
    the placeholder for our game characters. It is stored in the `game_board` variable.
    As you may recall, a variable cannot store multiple values. If we perform multiple
    assignments to the same variable, the variable will store the latest value that
    was added to it. Hence, this board is not a simple type of variable. This is a
    `list` variable. We can store multiple pieces of data in a list. Let''s print
    the value of the board:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '`>>> print(game_board[0] + ''|'' + game_board[1] + ''|'' + game_board[2])`:
    The preceding command prints the first line of the layout. We have learned about
    the `print` statement earlier in this chapter. Anything inside parentheses (either
    a string or variable value) is printed as it is by the `print` statement . We
    passed `board[0]` to get the first element of the board, which is the first underscore
    (`_`) We print a separator (`|`) between each underscore. The output of the preceding
    statement is `_ | _ | _ `.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We have to print the preceding layouts two more times, which means we have
    to use two more `print` statements:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The number that''s inserted in the square brackets is the position that we
    normally call an `index` in programming. This refers to a certain position of
    the `list` variable. The list index always starts with zero indexes:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code shows the final layout for our tic-tac-toe game. Make sure
    you write the program as a script and press *F5* to run it:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we did two things: first, we printed underscore in every
    position of our layout, and then we assigned a number to each of those positions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Now that we've developed the programming model that represents the basic layout
    of our game, it's time to make an interaction between the programming model and
    player of the game. In the next section, we will learn how to take user input
    and manipulate it so that we can interact with the model of our game.
  prefs: []
  type: TYPE_NORMAL
- en: User interaction – user input and manipulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We're making games for our users to play. Hence, we should make an interface
    so that we can make our application user-friendly. We did this in the previous
    section. Now, we have to take some input from the user and place it to the layout
    through the model. We know that a simple way to take the input from the user is
    by using the `input()` method. Let's use it now.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we will think of this problem: *what should we input from the user?
    Is it a symbol, like X/O, or is it positions?*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Taking input as a symbol is useless because after taking it, we should know
    where to place it. Hence, we can take the positions from the user and place the
    symbol into our code automatically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s break this down part by part:'
  prefs: []
  type: TYPE_NORMAL
- en: '`while True`: This will run an infinite amount of times. We saw this happen
    in the *Requesting user input* section. Therefore, we will take the input data
    from the user an  infinite amount of times, which means our game loop has no termination.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pos = input(" Enter any position you want from (0-8): \n")`: This statement
    will take input from the user as a position from 0 to 8 and store it in the `pos`
    variable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The data that's stored in the `pos` variable will be a string, but the position
    should be an integer. Due to this, we have to typecast it as an integer using
    the `int` method. Then, we store the integer in the `pos` variable as `x = int(x)`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`game_board[pos] = ''X''`: This statement assigns `X` to the position that''s
    selected by the user. The `pos` variable contains a position from 0 to 8 that
    was selected by the user in the previous command. Now, we are assigning `X` to
    that position in place of an underscore, like so:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'If the user enters, `4` then we will put `X` in `4th` position, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: After we assign a player symbol to the specified position, we have to print
    the board again with those three print statements. It should be kept inside the
    loop because we have to print the board every time the user enters a new position
    from the keyboard.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have finished making models for rendering layouts and user input,
    we can run the game and observe the output. The game you are going to see won't
    be appealing because it doesn't have a proper layout and it won't have as many
    features that our tic-tac-toe game should have. We will try to make the game as
    playable as possible while learning more Python in the upcoming chapter. For now,
    we will take a look at the possible errors and warnings that may be encountered
    in our game.
  prefs: []
  type: TYPE_NORMAL
- en: Possible errors and warnings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve only covered the basic fundamentals of Python so far, so you won''t
    have found many semantic errors until now. However, you are likely to be accustomed
    to the syntax error. First and foremost, an error can be caused while naming a
    variable. If you do not follow the rules or conventions for naming a variable,
    you are likely to get the following errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: The preceding name is invalid because you cannot provide spaces while creating
    variable names. You can put an underscore between them to specify that it consists
    of two words. `my_name` is a valid name for a variable.
  prefs: []
  type: TYPE_NORMAL
- en: If you spell your variable name incorrectly, you are going to get an error instantly.
    Suppose you created a variable called `Msg` and used it as `msg`. An error will
    be returned, stating that this is the wrong definition. Python is case-sensitive,
    which means that `True` and `true` are different in Python. If you name a variable
    `True`, it will be illegal because it is one of the keywords of Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, you can call a variable `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: The same rule goes for naming modules. In this chapter, we looked at how to
    import the `math` module and use its methods. However, if you spell the module's
    name wrong, it will cause many problems in the long run. You won't see an instant
    error on IDLE; you have to compile your script to see it. Thus, debugging is a
    lot harder with IDLE. Because of this, make sure you spell all of your modules
    and their methods correctly.
  prefs: []
  type: TYPE_NORMAL
- en: '`>>> import math` will successfully import the `math` module into your project,
    but if you use the wrong module name, you will get the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: There's also another type of error that's more dangerous than a syntax error;
    these are called semantic errors. A semantic error occurs when we didn't get the
    intended results. They won't be detected by the interpreter, and so they are hard
    to debug. We can get semantic errors due to executing expressions incorrectly.
    If we didn't care enough for the rule of precedence, we will end up making wrong
    statements for the program.
  prefs: []
  type: TYPE_NORMAL
- en: The output of the `1 + 3**2` expression is 10, not 16\. However, we can force
    our interpreter to make this statement print 16 by enclosing the statement with
    parenthesis. `(1 + 3) **2` will give us 16.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you've learned how to rectify errors that are encountered in your program,
    let's learn about the possible ways to modify our very first tic-tac-toe game.
  prefs: []
  type: TYPE_NORMAL
- en: Game testing and possible modifications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are several ways to find errors in your game. First of all, you can reach
    out to your friends and make them play your game. The suggestions that you gather
    the first time you test your game is known as alpha testing and it is an essential
    part of any game development life cycle. After collecting enough information through
    interviewing, you can start modifying your game.
  prefs: []
  type: TYPE_NORMAL
- en: The things we have learned so far will not be enough to make our game more appealing.
    We will learn about several topics in upcoming chapters and modify our tic-tac-toe
    game accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: The game that we made in this section is bland and does not galvanize our user
    to play, but we have learned so many things by making it. We looked at the basic
    process of creating games using the concepts of models and views. View refers
    to layouts where we render data that helps us to interact with the user through
    the interface, while model refers to the way we communicate data between our program
    and user. We haven't covered advanced Python language paradigms yet and so we
    have limited power. This means that the game in this chapter is simple. However,
    we will make changes to this game after we cover conditionals, looping, and functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are some possible modifications we could make to our game:'
  prefs: []
  type: TYPE_NORMAL
- en: Let's analyze our code and see its limitations. We told the user to explicitly
    enter a number from 0 to 8 to specify the movements of the user. What if the user
    didn't input a number and input a string? Our program will terminate the loop
    and crash with an exception. Hence, the first modification we would make is to
    restrict the user to entering only numbers. If they enter anything else, we can
    print a user-friendly message instead of crashing the program. This concept is
    called *exception handling* and will be covered in the next chapter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Currently, this game only works with one player, but tic-tac-toe is a multi-player
    game. Hence, we have to learn about conditionals and flow controls that will help
    us to achieve transition between players. We will do this in the next chapter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a user captures an entire row, column, or diagonal, then they should be
    considered the winner of the game and the game should complete its execution.
    However, we haven't created any logic to make a player a winner. What we've learned
    so far is not enough, but after we complete the next chapter, we will be able
    to make drastic changes to our game.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By looking at the modifications we can make to our game, we can see that we
    have bigger things to come in the next chapter. Although the knowledge that we
    acquired in this chapter was enough to create a programming model and allow us
    to interact with a single player, this was not enough for us to interact with
    multiple players, which requires a good understanding of looping and conditional
    structures. We'll cover these concepts in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we covered the two basic building blocks of Python: inputting
    and providing formatted output. We looked at Python''s built-in data types in
    this chapter and started by learning about the different data values and their
    types, such as integer, string, float, Boolean, and none. We took a tour of the
    Python ecosystem by learning about variables, numbers, and the `math` module.
    We saw how to use the `math` module and got a good grasp of topics such as the
    rules and conventions that need to be followed while creating variables and using
    modules. These topics are essential if you want to start your programming career
    with Python. These topics not only make for a strong foundation in Python but
    also teach you what good and bad practices in programming need to be followed
    and removed, even if you are a proficient Python programmer. Coding is not only
    writing code—it''s about presenting information in a readable and usable way.
    Hence, we saw how we can use comments in programming to make our code more readable
    and reusable for other programmers.'
  prefs: []
  type: TYPE_NORMAL
- en: Making the user input data and then using it in our program is the only way
    to make an application user-friendly. Hence, we learned how to make the user input
    data and store it in the structure so that accessing it will be easier for further
    manipulation. We eventually looked at the unusual working behavior of the `input()`
    method, which converts our integer or Boolean input data into strings. Due to
    this, we learned about typecasting methods and we saw how easy it was to perform
    data conversion with Python's built-in methods.
  prefs: []
  type: TYPE_NORMAL
- en: A string is the most fundamental and primitive data type and stores text. We
    dedicated an entire section to the creation and manipulation of strings. We learned
    how to access elements of strings. We also learned that string assignment isn't
    possible, and so we concluded that strings are immutable. We learned about the
    basic methods of the string class such as capitalize, join, upper, lower, and
    len. We looked at two formatting techniques for strings, that is, `%s` and `%d`,
    which are used as placeholders and format the method. You can use either of them,
    although it's better to have knowledge of each before you do so.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we built our first game. We saw the building games is not only about coding.
    We need to go through a variety of processes, such as brainstorming, modeling,
    and user interaction. We learned how model and view work together. Then, we made
    a simple game and had the chance to revise everything we'd learned so far. Finally,
    we suggested some modifications that we could make to that tic-tac-toe game. Every
    modification will be covered as we progress through this book. In the next chapter,
    we will learn about flow control and how to build a decision-maker for our game.
  prefs: []
  type: TYPE_NORMAL
