- en: Chapter 7. Writing Nmap Scripts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have covered how the NSE works, it's time to learn how to write
    our first Nmap script. Because of the versatile and extremely customized nature
    of writing Nmap scripts, there are several different ways to produce a script
    that performs various functions—and also many pros and cons to write your own
    script.
  prefs: []
  type: TYPE_NORMAL
- en: While creating an Nmap script from scratch may not always be the fastest way
    to get things done (as there is almost always a script that already exists for
    whatever purpose you may need), there are certain situations during which leveraging
    the powerful built-in functions of the Nmap scripting engine leads to exactly
    the right circumstances to write your own script.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The anatomy of an Nmap script
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing the Nmap script's head
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a rule
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining a script's action
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging Nmap scripts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Anatomy of an Nmap script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An Nmap script is comprised of several unique sections, each of which define
    different areas for the script to execute, or for Nmap to interpret expected output.
    There are several primary areas that we must always include in any script we create,
    in order to ensure that the script will run effectively (and that Nmap will be
    able to understand how to interpret the data).
  prefs: []
  type: TYPE_NORMAL
- en: Although Nmap scripts are written in Lua, an interpreted programming language,
    it's important to remember that these scripts are not stand-alone executables
    that can be run on their own. Rather than running a script with Nmap as a requirement,
    it's better to think of Nmap scripts as simply sets of instructions for a unique
    Nmap programming language.
  prefs: []
  type: TYPE_NORMAL
- en: 'An Nmap script is comprised of three unique sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The head**: This section of an Nmap script includes documentation and categorization
    for the script so that Nmap and the NSE database can successfully categorize the
    script into the appropriate areas.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The rule**: This section of the script defines exactly where and how an Nmap
    script is executed. Because the script is leveraging the data of the Nmap scan
    as it runs, certain elements can trigger the script to run. This is effectively
    a trigger that evaluates whether or not the script should execute.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The action**: Lastly, this section of an Nmap script is where (you guessed
    it!) the action takes place. This is the part of the script that is doing a lot
    of the processing, after the head has defined the script and the rule has triggered
    the action.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we've learned how an Nmap script is composed, it's time that we got
    to work and started writing one. Because each and every Nmap script is so unique,
    we are going to recreate a script that already works—but the one that shows how
    powerful the NSE can be.
  prefs: []
  type: TYPE_NORMAL
- en: Our case study for this script will be to write a simple, easy-to-follow Nmap
    script that uses Nmap's built-in functionality (combined with the power of the
    NSE) to determine whether a web server has a `robots.txt` file. The `robots.txt`
    files indicate which areas of a website should (and should not) be indexed by
    web crawlers and search engines, and often have sensitive directories listed with
    an instruction to not index them. For this reason, they're very interesting for
    security professionals and penetration testers—since it's exactly those sensitive
    files and directories that we're looking for!
  prefs: []
  type: TYPE_NORMAL
- en: Defining an Nmap script – script headers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Each Nmap script must be created with certain required variables defined at
    the beginning of the script. Any Nmap prerequisites that are needed for successful
    execution, definitions of how the script is categorized (for example, whether
    or not it is intrusive, safe, contains an exploit, and so on), and the license
    are also among the things necessary in the header.
  prefs: []
  type: TYPE_NORMAL
- en: '![Defining an Nmap script – script headers](img/4065OS_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding screenshot illustrates the various sections necessary for an Nmap
    script, each of which are critical to the successful execution of the program.
    Let's walk through these elements in order to determine what the author of the
    script is doing.
  prefs: []
  type: TYPE_NORMAL
- en: First, several variables (defined by the local prefix) are defined. Several
    requirements are made in order to ensure that each of the Nmap elements are included
    appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: Next, a longer variable—the description—is created. This is a multiline Lua
    variable, which is encapsulated in `[[` and `]]` brackets. This area is supposed
    to include a basic description of the Nmap script so that when run programmatically,
    it is possible to choose the correct script.
  prefs: []
  type: TYPE_NORMAL
- en: Below the description variable is a fully commented text block that defines
    the usage of the script. In Lua, the `--` preamble comments out that line of code,
    making it not run when the script is executed. You can easily see how the `@usage`
    block is formatted—simply showing how the script should be run, and any arguments
    it may accept—and how the `@output` block is formatted below. These blocks show
    how to run the script correctly, how to pass arguments on the command line (if
    any are required), and what output you should expect from the script in question.
  prefs: []
  type: TYPE_NORMAL
- en: Below the commented out block are several other variable definitions that Nmap
    parses. Specifically, the `author` block (which is how you would like to be credited
    for the script), the `license` block (which is generally listed as the same as
    Nmap for distribution purposes, but can be specified in certain ways if you want
    to protect certain elements of your script), and the `categories` array (which
    lists the categories that the script should fall into). You want to make sure
    that, for example, if your script is intrusive, you label it as such.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our script, we only need a few required `includes`, which make our header
    relatively short. Let''s create our head section, looking something like the following
    (of course, feel free to modify your script however you like!):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Very simple! We need the HTTP module in order to perform an HTTP GET request
    to `robots.txt` in question (on an open port 80), and of course we need the Nmap
    include in order to leverage the Nmap scripting engine. You can see that our description
    is very straightforward, and we defined the author, license, and categories in
    order to help our users determine when the script is safe and effective to run.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the head of our script is complete, let's turn to the rule.
  prefs: []
  type: TYPE_NORMAL
- en: Triggering functions – the rule
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The rule or portrule section of an Nmap script determines when the action should
    take place (which we''ll cover in the next section). It''s important to define
    this clearly so that we are confident that our script will run every time we need
    it to (based on port number and version). There are two ways to accomplish this
    type of rule: standard portrule documentation, and a helper library built in the
    NSE called **shortport**.'
  prefs: []
  type: TYPE_NORMAL
- en: Defining a rule is actually very simple, depending on what we're looking for.
    In the case of our `robots.txt` detection script (aptly named `robots.nse`), we
    just want to trigger on port 80 to see if `robots.txt` exists.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we were writing a production script, rather than a proof of concept, it
    would probably be a good idea to use shortport''s port or service functionality
    to trigger on port 80, or any web server that Nmap detects through its underlying
    functionality. However, in our case, we can simply define something much easier
    to digest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this is a very minimal portrule that will return `true` when
    `port.state` is `open`. These are built-in Nmap functionalities, and when the
    script is running, each port is checked against the portrule.
  prefs: []
  type: TYPE_NORMAL
- en: While our portrule is intentionally very easy to understand, many production
    scripts have very complicated portrules that are designed to trigger different
    elements of analysis, based on specific version and configuration settings. To
    learn more about advanced portrule and the shortport library, you can read the
    full overviews at the **Nmap Scripting Engine Documentation** (**NSEDoc**) portal.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a script's action
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After we define the portrule, the only step left is to define the action that
    executes when the portrule returns `true`. In our case, we want to check whether
    `robots.txt` exists on the web server we're scanning.
  prefs: []
  type: TYPE_NORMAL
- en: In order to determine whether the server exists, there's a little bit about
    the **Hypertext Transfer Protocol** (**HTTP**) that we need to learn. First of
    all, the way to request a page is through an HTTP GET request. For example, if
    we wanted to go to [http://google.com/images](http://google.com/images), our browser
    would send a request containing `GET /images` to the server at `Google.com`.
  prefs: []
  type: TYPE_NORMAL
- en: If the status of the GET request is `OK`, the web server returns the status
    code `200`. If there is a server-side error, a `500` error will return. If the
    page is moved, an error in the range of `300` will return. Lastly (for our purposes),
    if there is an authorization error or file-not-found error, the server will return
    `403` or `404` respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to define our action function, we need to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Request the `robots.txt` page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find out whether it's there or not.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following action segments define this request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the preceding code snippet, this is a very simple action
    section. Let''s walk through the process step by step:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we define the action function that takes the parameter's host and port.
    These are automatically passed to the action block once the portrule triggers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we define a local variable (called robots), which is the HTTP result of
    the NSE's `http.get` request. In this instance, we're performing a GET to the
    host and port that we're currently scanning and making a request to `/robots.txt`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once we receive the HTTP data, we can easily make an `if` statement to determine
    whether the status is a `200 OK` response or something else. We could have combined
    this with a shorter `if` statement (rather than an if/else), but it's useful to
    see how to have multiple possibilities for output.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the output is not `200`, we go to the `else` statement and see what the status
    is. For example, if the status is `404`, we know that it simply doesn't exist;
    if we get a `500` server error or a `403 not authorized`, however, it might be
    worth looking into a greater depth:![Defining a script's action](img/4065OS_07_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As you can see, running this script (and any custom Nmap script) is very straightforward.
    When scanning `scanme.nmap.org`, you can clearly see that there is no `robots.txt`—we're
    just receiving a `404` error. If we scan a service that does have a `robots.txt`
    page—I created a test case on [http://dshaw.net/](http://dshaw.net/) for this
    purpose—we see a different result.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this instance, we can clearly see that the `200` status—HTTP OK—means that
    `robots.txt` does exist:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Defining a script''s action](img/4065OS_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If this were a production Nmap script, it would probably be worth it to change
    the return associated with a `200 OK` response to show more information such as
    disallowed files and directories. However, don't spend time on this particular
    script! There is already a great HTTP `robots.txt` script (and many more) in the
    official Nmap repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'One last set of flags that can be very useful to write, understand, and debug
    Nmap scripts are the `--script-trace` and `-d` (debug) flags. The `--script-trace`
    flag shows the information on the wire about all the different requests that the
    script is making on its own, which is very useful to determine what exactly is
    happening:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Defining a script''s action](img/4065OS_07_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can see in the preceding screenshot that while there may be a little bit
    of information overload, you can see exactly what the Nmap script is doing by
    using the `--script-trace` flag. The `-d` flag, to debug, works similarly: if
    you''re writing a script and you encounter errors, try debugging it with the `-d`
    flag. You''d be surprised at the great things you can learn!'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter showed us how to write our very own Nmap scripts! The NSE is a
    powerful (and sometimes complicated) tool, which can aid Nmap users in a variety
    of interesting and automated tasks. The script we wrote as a proof of concept
    can easily detect whether a `robots.txt` file exists on a server, but the possibilities
    to write Nmap scripts—either for internal use, or to detect specific vulnerabilities—are
    nearly endless!
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to use tools that come in packages with
    the Nmap tool suite, as well as some useful tips and tricks to get the most out
    of them.
  prefs: []
  type: TYPE_NORMAL
