- en: Spring MVC Optimization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned about the Spring **Aspect-Oriented Programming**
    (**AOP**) module, AOP concepts, its various terminologies, and how to implement
    advice. We also saw the proxy concept and its implementation using the proxy pattern.
    We went through the best practices to follow to achieve quality and performance
    with the Spring AOP.
  prefs: []
  type: TYPE_NORMAL
- en: Spring MVC is the most popular Java web application framework nowadays. It is
    provided by Spring itself. Spring Web MVC helps to develop a flexible and loosely
    coupled web-based application. Spring MVC follows the **Model-View-Controller**
    (**MVC**) pattern, which separates the input logic, business logic, and presentation
    logic while providing loose coupling between components. The Spring MVC module
    allows us to write a test case without using the request and response object in
    the web application. So, it removes the overhead of testing the web components
    in the enterprise application. Spring MVC also supports multiple new view technologies
    and allows for extending. Spring MVC provides a clear definition of roles for
    controllers, view resolvers, handler mappings, and POJO beans, which makes it
    simple to create Java web applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn about the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Spring MVC configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring asynchronous processing, `@Async` annotation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CompletableFuture` with Spring Async'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Security configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authentication cache
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fast and stateless API authentication with Spring Security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring and managing Tomcat with JMX
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring MVC performance improvements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring MVC configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Spring MVC architecture is designed along with a front controller servlet,
    the `DispatcherServlet`, which is a front controller pattern implementation and
    acts as an entry point for all of the HTTP requests and responses. The `DispatcherServlet` can
    be configured and mapped using Java configuration or in the deployment descriptor
    file, `web.xml`. Before moving on to the configuration part, let's understand
    the flow of Spring MVC architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Spring MVC architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the Spring MVC framework, there are multiple core components that maintain
    the flow of request and response execution. These components are clearly separated
    and have different interfaces and implementation classes, so they can be used
    according to requirements. These core components are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Component** | **Summary** |'
  prefs: []
  type: TYPE_TB
- en: '| `DispatcherServlet` | It acts as a front controller of the Spring MVC framework
    through the life cycle of HTTP requests and responses. |'
  prefs: []
  type: TYPE_TB
- en: '| `HandlerMapping` | When a request comes, this component is responsible for
    deciding which controller will handle the URL. |'
  prefs: []
  type: TYPE_TB
- en: '| `Controller` | It executes the business logic and maps the resultant data
    in `ModelAndView`. |'
  prefs: []
  type: TYPE_TB
- en: '| `ModelAndView` | It holds the model data object in terms of the execution
    result and the view object to render. |'
  prefs: []
  type: TYPE_TB
- en: '| `ViewResolver` | It decides the view to be rendered. |'
  prefs: []
  type: TYPE_TB
- en: '| `View` | It shows the result data from a model object. |'
  prefs: []
  type: TYPE_TB
- en: 'The following diagram illustrates the flow of the preceding components in the
    Spring MVC architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/742e69c4-d5cc-407c-aa61-c4a201de15e2.png)'
  prefs: []
  type: TYPE_IMG
- en: Spring MVC architecture
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s understand the basic flow of the architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: When the incoming **request** comes, it is intercepted by the front controller,
    `DispatcherServlet`. After intercepting the **request**, the front controller
    finds the appropriate `HandlerMapping`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `HandlerMapping` maps the client **request** call to the appropriate `Controller`,
    based on the configuration file or from the annotation `Controller` list, and
    returns the `Controller` information to the front controller.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `DispatcherServlet` dispatches the **request** to the appropriate `Controller`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Controller` executes the business logic defined under the `Controller`
    method and returns the resultant data, in the form of `ModelAndView`, back to
    the front controller.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The front controller gets the **view name** based on the values in the `ModelAndView` and
    passes it to the `ViewResolver` to resolve the actual view, based on the configured
    view resolver.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **view** uses the **Model** object to render the screen. The output is generated
    in the form of `HttpServletResponse` and passed to the front controller.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The front controller sends the **response** back to the servlet container to
    send the output back to the user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, let''s understand the Spring MVC configuration methods. Spring MVC configuration
    can be set up in the following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: XML-based configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java-based configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Before we start with the configuration using the preceding methods, let''s
    define the steps that are involved in setting up the Spring MVC application:'
  prefs: []
  type: TYPE_NORMAL
- en: Configuring front controller
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating Spring application context
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configuring `ViewResolver`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: XML-based configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In an XML-based configuration, we will do the Spring MVC configuration externally,
    using the XML files. Let's move forward with the configuration, following the
    preceding steps.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring front controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To configure the front controller servlet, `DispatcherServlet`, in an XML-based
    configuration, we need to add the following XML code in the `web.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding XML code, at first, we configured the `DispatcherServlet`.
    Then, we mentioned the context configuration location, `/WEB-INF/spring-mvc-context.xml`.
    We set the `load-on-startup` value as `1`, so the servlet container will load
    this servlet upon startup. In the second part, we defined the `servlet-mapping` tag
    to map a URL `/` to `DispatcherServlet`. Now, we will define the Spring application
    context in the next step.
  prefs: []
  type: TYPE_NORMAL
- en: It is good to configure the `load-on-startup` element under the `DispatcherServlet`
    configuration to load it at the highest priority. This is because, in a cluster
    environment, you might face timeout issues if Spring is not up and you get a large
    number of calls hitting your web app once it's deployed.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Spring application context
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After configuring the `DispatcherServlet` in `web.xml`, let''s move ahead to
    create a Spring application context. For that, we need to add the following XML
    code in the `spring-mvc-context.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding XML code, we first defined a component scan tag, `<context:component-scan
    />`, for the `com.packt.springhighperformance.ch4.controller` package, so that
    all of the beans and controllers get created and autowired.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we have used `<mvc:annotation-driven />` to register automatically different
    beans and components that includes request mapping, data binding, validation,
    and auto conversion feature with `@ResponseBody`.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring ViewResolver
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To configure `ViewResolver`, we need to specify a bean for the class `InternalResourceViewResolver` in
    the `spring-mvc-context.xml` file, after `<mvc:annotation-driven />`. Let''s do
    that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: After configuring `ViewResolver`, we will create a `Controller` to test the
    configuration. But, before moving on to that, let's see the Java-based configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Java-based configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the Java-based Spring MVC configuration, we will follow the same steps that
    we did with the XML-based configuration. In a Java-based configuration, all of
    the configurations will be done under the Java class. Let's follow the sequence.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring front controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With Spring 5.0, there are three ways to configure `DispatcherServlet` programmatically,
    by implementing or extending any of the following three classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`WebAppInitializer` interface'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AbstractDispatcherServletInitializer` abstract class'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AbstractAnnotationConfigDispatcherServletInitializer` abstract class'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will use the `AbstractDispatcherServletInitializer` class, as it is the preferred
    approach for applications that use Java-based Spring configuration. It is preferred
    because it allows us to start a servlet application context, as well as a root
    application context.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to create the following class to configure `DispatcherServlet`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The previous class code is equivalent to the `web.xml` file configuration that
    we created in the *XML-based configuration* section. In the preceding class, the
    `getRootConfigClasses()` method is used to specify the root application context
    configuration classes (or `null`, if not required). `getServletConfigClasses()` is
    used to specify the web application configuration classes (or `null`, if not required).
    The `getServletMappings()` method is used to specify the servlet mappings for
    the `DispatcherServlet`. Root config classes will be loaded first, then servlet
    config classes will be loaded. Root config classes will create an `ApplicationContext`,
    which will act as a parent context, whereas servlet config classes will create
    a `WebApplicationContext`, and it will act as a child context of the parent context.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Spring application context and configuring a ViewResolver
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Spring 5.0, to create a Spring application context and to configure a `ViewResolver`
    using Java configuration, we need to add the following code in the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we created a class, `SpringMvcWebConfig`, implementing
    a `WebMvcConfigurer` interface, which provides options for customizing Spring
    MVC configuration. The `@EnableWebMvc` object enables the default configuration
    for Spring MVC. The `@ComponentScan` object specifies the base packages to scan
    for controllers. The two annotations `@EnableWebMvc` and `@ComponentScan` are
    equivalent to the `<context:component-scan />` and `<mvc:annotation-driven />`
    that we created in `spring-mvc-context.xml` in the *XML-based configuration* section.
    The `resolve()` method returns `InternalResourceViewResolver`, which helps in
    mapping logical view names from a preconfigured directory.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s create a controller class to map the `/home` request, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, `@Controller` defines a Spring MVC controller that contains
    request mappings. The `@RequestMapping(value = "home")` object defines a mapping
    URL, `/home`, to a method, `home()`. So, when the browser hits a `/home` request,
    it executes the `home()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s create a view, `home.jsp`, in the `src/main/webapp/WEB-INF/views/home.jsp`
    folder, with the following HTML content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when we run this application, it will show the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/777d9599-35dd-4ca1-bb09-689f78e850d1.png)'
  prefs: []
  type: TYPE_IMG
- en: In the next section, we will learn about Spring asynchronous processing.
  prefs: []
  type: TYPE_NORMAL
- en: Spring asynchronous processing, @Async annotation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring provides support for asynchronous method execution. This can also be
    achieved using threads, but it makes the code more complex and sometimes results
    in more bugs and errors. When we need to execute a simple action in an asynchronous
    manner, it is a cumbersome process to handle it using threads. There are cases
    in which it is necessary to perform the operation asynchronously, like sending
    a message from one machine to another machine. The main advantage of asynchronous
    processing is that the caller will not have to wait for the completion of the
    called method. In order to execute a method in a separate thread, you need to
    annotate the method with the `@Async` annotation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Asynchronous processing support can be enabled by using the `@EnableAsync`
    annotation to run the `@Async` methods in the background thread pool. The following
    is an example of Java configuration to enable asynchronous processing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Asynchronous processing can also be enabled by using XML configuration, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '@Async annotation modes'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two modes of `@Async` annotation processing methods:'
  prefs: []
  type: TYPE_NORMAL
- en: Fire and forget mode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Result retrieval mode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fire and forget mode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this mode, a method will be configured as a `void` type, to be run asynchronously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Result retrieval mode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this mode, a method will be configured with a return type by wrapping the
    result with the `Future` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Spring also provides support for the `AsyncResult` class, which implements the
    `Future` interface. It can be used to track the result of asynchronous method
    invocation.
  prefs: []
  type: TYPE_NORMAL
- en: Limitations of @Async annotation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `@Async` annotation has the following limitations:'
  prefs: []
  type: TYPE_NORMAL
- en: The method needs to be `public` so that it can be proxied
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Self-invocation of the asynchronous method would not work, because it bypasses
    the proxy and calls the underlying method directly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thread pool executor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You might wonder how we declare the thread pools that asynchronous methods will
    use. By default, for the thread pool, Spring will try to find either a unique `TaskExecutor` bean
    defined in the context or an `Executor` bean, named `TaskExecutor`. If neither
    of the preceding two options is resolvable, Spring will use `SimpleAsyncTaskExecutor` to
    process asynchronous method processing.
  prefs: []
  type: TYPE_NORMAL
- en: However, sometimes we do not want to use the same thread pool for all of the
    application's tasks. We can have different thread pools, with different configurations
    for each method. For that, we just need to pass the executor name to the `@Async` annotation
    for each method.
  prefs: []
  type: TYPE_NORMAL
- en: To enable asynchronous support, the `@Async` annotation is not enough; we need
    to use the `@EnableAsync` annotation in our configuration classes.
  prefs: []
  type: TYPE_NORMAL
- en: In Spring MVC, when we configure `DispatcherServlet` using the `AbstractAnnotationConfigDispatcherServletInitializer`
    initializer class, which extends `AbstractDispatcherServletInitializer`, it has
    the `isAsyncSupported` flag enabled by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to declare a thread pool definition for asynchronous method invocation.
    In Spring MVC Java-based configuration, this can be done by overriding the `configureAsyncSupport()` method
    of the `WebMvcConfigurer` interface in the Spring Web MVC configuration class.
    Let''s override this method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding method, we have configured the thread pool executor by overriding
    the `configureAsyncSupport()` method. Now, let''s call the asynchronous method
    created in the service class `BankAsyncService` by using a controller class, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, when we request `/syncacct`, it will invoke `syncAccount()`
    and return the result of the asynchronous method in a separate thread.
  prefs: []
  type: TYPE_NORMAL
- en: CompletableFuture with Spring Async
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `CompletableFuture` class was introduced in Java 8, and it provides a simple
    way to write asynchronous, multithreaded, non-blocking code. With Spring MVC,
    it is also possible to use `CompletableFuture` with controllers, services, and
    repositories from public methods annotated with `@Async`. `CompletableFuture`
    implements the `Future` interface, which provides the result of an asynchronous
    computation.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create `CompletableFuture` in the following simple way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'To get the result of this `CompletableFuture`, we can call the `CompletableFuture.get()`
    method. This method will be blocked until `Future` is completed. For that, we
    can manually call the `CompletableFuture.complete()` method to `complete` `Future`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: runAsync() – running a task asynchronously
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we want to execute a background activity task asynchronously and do not
    want to return anything from that task, we can use the `CompletableFuture.runAsync()`
    method. It takes a parameter as a `Runnable` object and returns the `CompletableFuture<Void>`
    type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try to use the `runAsync()` method by creating another controller method
    in our `BankController` class, with the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, when a request comes with the `/synccust` path, it
    will run `syncCustomerAccount()` in a separate thread and will complete the task
    without returning any value.
  prefs: []
  type: TYPE_NORMAL
- en: supplyAsync() – running a task asynchronously, with a return value
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we want to return a result after finishing a task asynchronously, we can
    use `CompletableFuture.supplyAsync()`. It takes `Supplier<T>` as a parameter and
    returns `CompletableFuture<T>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s check the `supplyAsync()` method by creating another controller method
    in our `BankController` class, with the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `CompletableFuture` object uses the global thread pool, `ForkJoinPool.commonPool()`,
    to execute tasks in a separate thread. We can create a thread pool and pass it
    to `runAsync()` and `supplyAsync()` methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are two variants of the `runAsync()` and `supplyAsync()` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Attaching a callback to the CompletableFuture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`CompletableFuture.get()` blocks the object and waits until the `Future` task
    is completed and the result is returned. To build an asynchronous system, there
    should be a callback, automatically called when the `Future` task has completed.
    We can attach a callback to `CompletableFuture` by using the `thenApply()`, `thenAccept()`,
    and `thenRun()` methods.'
  prefs: []
  type: TYPE_NORMAL
- en: Spring Security configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spring Security is a widely used security service framework for Java EE-based
    enterprise applications. At the authentication level, Spring Security provides
    different kinds of authentication models. Some of these models are provided by
    third parties, and some sets of authentication features are provided by Spring
    Security itself. Some of the following authentication mechanisms are provided
    by Spring Security:'
  prefs: []
  type: TYPE_NORMAL
- en: Form-based authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OpenID authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: LDAP specifically used in large environments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Container-managed authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom authentication systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JAAS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's look at an example to activate Spring Security in a web application. We
    will use an in-memory configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Spring Security dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To configure Spring Security in a web application, we need to add the following
    Maven dependencies to our **Project Object Model** (**POM**) file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Configuring a security filter for incoming requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When implementing security in a web application, it is better to validate all
    of the incoming requests. In Spring Security, the framework itself looks at the
    incoming request and authenticates the user to perform an action, based on the
    provided access. To intercept all of the incoming requests to a web application,
    we need to configure `filter`, `DelegatingFilterProxy`, which will delegate the
    requests to a Spring-managed bean, `FilterChainProxy`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Based on the `filter` configuration, all of the requests will go through this
    `filter`. Now, let's configure security-related stuff, like authentication, URL
    security, and role access.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Spring Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we will configure Spring Security authentication and authorization by
    creating a Spring Security configuration class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s understand the preceding configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@EnableWebSecurity`: It enables Spring Security''s web security support, and
    also provides the Spring MVC integration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WebSecurityConfigurerAdapter`: It provides a set of methods that are used
    to enable specific web security configuration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`protected void configure(AuthenticationManagerBuilder auth)`: We have used
    in-memory authentication in this example. It can be used to connect to the database
    using `auth.jdbcAuthentication()`, or to a **Lightweight Directory Access Protocol** (**LDAP**)
    using `auth.ldapAuthentication()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.passwordEncoder(passwordEncoder)`: We have used the password encoder `BCryptPasswordEncoder`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.withUser("user").password(passwordEncoder.encode("user@123"))`: It sets the
    user ID and encoded password for authentication.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.roles("USER")`: It assigns roles to the user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`protected void configure(HttpSecurity http)`: It is used to secure different
    URLs that need security.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.antMatchers("/login").permitAll()`: It permits all of the users to access
    the login page.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.antMatchers("/admin/**").hasRole("ADMIN")`: It permits access to the admin
    panel to the users who have the `ADMIN` role.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.antMatchers("/**").anyRequest().hasAnyRole("ADMIN", "USER")`: It means that
    to make any request with `"/"`, you must be logged in with the `ADMIN` or `USER`
    role.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.and().formLogin()`: It will provide a default login page, with username and
    password fields.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.and().logout().logoutSuccessUrl("/login").permitAll()`: It sets the logout
    success page when a user logs out.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.csrf().disable()`: By default, the **Cross Site Request Forgery** (**CSRF**)
    flag is enabled. Here, we have disabled it from configuration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will use the following `BankController` class for URL mapping:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Now, when we run this example, it will first show the login authentication form
    provided by the Spring Framework, before we try to access any URL of the web application.
    If a user logs in with the `USER` role and tries to access the admin panel, they
    will be restricted from accessing it. If a user logs in with the `ADMIN` role,
    they will be able to access both the user panel and the admin panel.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication cache
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring Security performance becomes one of the major concerns when there is
    a maximum number of calls hit on the application. By default, Spring Security
    creates a new session for each new request and prepares a new security context
    every single time. This becomes an overhead when maintaining user authentication,
    and due to that, performance is lowered.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we have an API that requires authentication on each request. If
    there are multiple calls made to this API, it will impact the performance of the
    application which uses this API. So, let''s understand this problem without a
    caching implementation. Take a look at the following logs, where we call an API
    using the `curl` command, without a caching implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Take a look at the following log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Each time we call this API, it will authenticate the username and password with
    the database value. This affects the application performance and can lead to an
    unnecessary load if users are making frequent calls.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the dignified solutions to overcome this issue is caching the user authentication
    for a specific time limit. We will use the implementation of `UserCache` with
    a properly configured `AuthenticationProvider`, and pass it to `AuthenticationManagerBuilder`.
    We will use `EhCache` to play with the cached object. We can employ this solution
    through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the caching configuration class
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Providing `UserCache` to `AuthenticationProvider`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Providing `AuthenticationProvider` to `AuthenticationManagerBuilder`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implementing the caching configuration class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have created the following class, which will provide the `UserCache` bean
    that will provide it to `AuthenticationProvider`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding class, `@EnableCaching` enables cache management.
  prefs: []
  type: TYPE_NORMAL
- en: Providing UserCache to AuthenticationProvider
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we will provide the created `UserCache` bean to `AuthenticationProvider`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Providing AuthenticationProvider to AuthenticationManagerBuilder
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s provide `AuthenticationProvider` to `AuthenticationManagerBuilder`
    in the Spring Security configuration class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s call that API and check the performance of authentication. If we
    call the API four times, the following log will be generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the preceding log, initially, `AuthenticationProvider` searches
    the `UserDetails` object from the cache; if it fails to get it from the cache, `AuthenticationProvider`
    will query the database for `UserDetails` and will put the updated object into
    the cache and for all the later calls, it will retrieve the `UserDetails` object
    from the cache.
  prefs: []
  type: TYPE_NORMAL
- en: If you update the password for a user and try to authenticate the user with
    the new password, and it fails to match the value in the cache, then it will query
    the `UserDetails` from the database.
  prefs: []
  type: TYPE_NORMAL
- en: Fast and stateless API authentication with Spring Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring Security also provides stateless APIs for securing non-browser clients,
    such as mobile applications or other apps. We will learn how to configure Spring
    Security for securing stateless APIs. Also, we will figure out the important points
    that need to be considered when designing security solutions and improving the
    performance of user authentication.
  prefs: []
  type: TYPE_NORMAL
- en: API authentication with the JSESSIONID cookie
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s not a good practice for API clients to use form-based authentication,
    due to the essential need for providing a `JSESSIONID` cookie with the chain of
    requests. Spring Security also provides an option to use HTTP basic authentication,
    which is an older approach but works fine. In the HTTP basic authentication approach,
    user/password details need to be sent with a request header. Let''s take a look
    at the following example of an HTTP basic authentication configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, the `configure()` method is from the `WebSecurityConfigurerAdapter`
    abstract class, which provides a default implementation of this method. The subclasses
    should invoke this method by calling `super`, as it may override their configuration.
    This configuration approach has one disadvantage; whenever we call the secured
    endpoint, it creates a new session. Let''s check this by using the `curl` command
    to call the endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We have one session ID cookie; let''s call it again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we have two different session IDs in each response. In the preceding
    example, for testing purposes, we sent the `Authorization` header with an encoded
    username and password. You can get the `Basic Y3VzdDAwMTpDdXN0QDEyMw==` header
    value from the browser when you hit the URL, by providing a username and password
    for authentication.
  prefs: []
  type: TYPE_NORMAL
- en: API authentication without the JSESSIONID cookie
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As there is no need for sessions for API client authentication, we can easily
    get rid of the session ID with the following configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, in the preceding configuration, we have used `SessionCreationPolicy.STATELESS`.
    With this option, there will not be a session cookie added in the response header.
    Let''s see what happens after this change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, there is no session cookie found in the response header.
    So, in this way, we can manage stateless authentication for APIs using Spring
    Security.
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring and managing Tomcat with JMX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Java Management Extension** (**JMX**) provides a powerful mechanism to monitor
    and manage Java applications. It can be enabled in Tomcat to monitor threads,
    CPU usage, and heap memory, and to configure **MBeans**. Spring provides JMX support
    out of the box, and we can use it to easily integrate our Spring application into
    JMX architecture.'
  prefs: []
  type: TYPE_NORMAL
- en: 'JMX support provides the following core features:'
  prefs: []
  type: TYPE_NORMAL
- en: Easy and flexible support for controlling the management interface of beans
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Declarative support for exposing MBeans over remote connectors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automatic registration of Spring beans as JMX MBean
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simplified support to proxy both local and remote MBean resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'JMX functionality has three levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Instrumentation level**: This level contains the components and resources
    that are represented by one or more Java beans, which are known as **managed beans,**
    or MBean.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Agent level**: This is known as an intermediate agent, called the **MBean
    server**. It gets the request from the remote management level and passes it to
    the appropriate MBean. It can also receive notifications related to state changes from
    MBeans and forward them back to the remote management level.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Remote management level:** This layer is made of connectors, adapters, or
    client programs. It sends requests to the agent level and receives the responses
    to the requests. Users can connect to the MBean server using either a connector
    or a client program, such as JConsole, with a protocol such as **Remote Method
    Invocation** (**RMI**) or **Internet Inter-ORB Protocol** (**IIOP**), and use
    an adapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In short, a user at the remote management level sends a request to the agent
    level, which finds the appropriate MBean at the instrumentation level, and sends
    the response back to the user.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting JMX to monitor Tomcat
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To configure JMX on Tomcat, we need to set the relevant system properties upon
    JVM startup. We can use the following methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can update the `catalina.sh` or `catalina.bat` file in `{tomcat-folder}\bin\`,
    adding the following values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, we can add the following values at `{tomcat-folder}\bin\catalina.bat`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to configure JMX for your Tomcat in Eclipse, you need to do the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to Window | Show View | Server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the Tomcat Overview configuration window by double-clicking on Tomcat v8.0
    Server at localhost.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under General Information, click on Open launch configuration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the Arguments tab of Edit launch configuration properties.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In VM arguments, add the following properties, and then click OK:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'After making this change, we need to restart the Tomcat server. After that,
    we need to test the connection with JConsole. After opening JConsole, we need
    to provide Remote Process with a hostname and port number, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/971e79e2-6a7a-4f18-9236-1ec792804c7e.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding screenshot, we have provided the hostname as `localhost` and
    the port number as `8990`. When you click on Connect, you will get a dialog box
    where you need to click on Insecure connection, and then you will be connected
    to JConsole.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an MBean
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create an MBean, we can use `@Managed` annotations to convert any class
    into an MBean. The class `BankTransferService` transfers an amount from one account
    to another. We will use this example for further understanding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding class, the `@ManagedResource` annotation will mark the class
    as MBean, and the `@ManagedAttribute` and `@ManagedOperation` annotations can
    be used to expose any attributes or methods. The `@Component` annotation will
    make sure that all classes annotated with `@Component`, `@Service`, or `@Repository`
    will be added to the Spring context.
  prefs: []
  type: TYPE_NORMAL
- en: Exporting an MBean in a Spring context
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we need to create an `MBeanExporter` in a Spring application context.
    We just need to add the following tag in the Spring context XML configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We need to add the `component-scan` element before the `‹context:mbean-export/›`
    element; otherwise, the JMX server will not be able to find any beans.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, our Spring context configuration will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we just need to start our Tomcat server and open the JConsole to see our
    MBean. After connecting to JConsole, go to the MBeans tab, where you can see our
    package folder, which contains our `BankMoneyTransferService` MBean, listed in
    the sidebar:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fb0dd8cb-79e4-4ea8-b8e7-d43d3b5e9989.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see in the earlier example, our MBean is generated and listed in
    the JConsole. Now, we can transfer an amount from one account to another by clicking
    on the Transfer button, invoking the method `transfer()`, which we created in
    our MBean. When we click on the checkBalance button, it will show the current
    balance in a pop up based on the entered account number. In the background, it
    will invoke the `checkBalance()` method of the `BankMoneyTransferService` class.
  prefs: []
  type: TYPE_NORMAL
- en: Spring MVC performance improvements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spring MVC application performance can be improved through multiple strategies
    and tips. Here, we have listed some of the strategies that can improve the performance
    enormously:'
  prefs: []
  type: TYPE_NORMAL
- en: High performance using connection pooling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hibernate improvements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing improvements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Proper server maintenance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the authentication cache with Spring Security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the Executor service framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: High performance using connection pooling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A standout amongst the most important features to enhance performance in Spring
    MVC is **connection pooling**. In this mechanism, *N* number of database connections
    are created and managed in a pool to increase the application's performance. When
    an application needs to utilize a connection, it just requests a connection, uses
    it, and then returns it to the pool. The main advantage of this procedure is that
    there are connections promptly available in the connection pool, so they can be
    utilized right away. The pool itself deals with the life cycle of the connection,
    so the developer doesn't have to wait for the connection to get established.
  prefs: []
  type: TYPE_NORMAL
- en: Hibernate improvements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another major point to enhance performance is regarding Hibernate. Dirty checking
    is one of the features provided by Hibernate. In dirty checking, Hibernate automatically
    distinguishes whether an object is modified and needs to be updated. Hibernate
    does the dirty work to keep a mind on the performance cost, whenever required.
    At the point when a specific entity has a corresponding table with a large number
    of columns, the cost increases. To minimize the dirty checking cost, we can set
    the transaction to `readOnly`, which will increase the performance and eliminate
    the need for any dirty checks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Another improvement related to Hibernate can be taken care is by flushing and
    clearing the Hibernate session intermittently. At the point when data is inserted/modified
    in the database, Hibernate stores a version of the entities already persisted
    in its session, just in case they are updated again before the session is closed.
    We can restrict Hibernate from storing the entities in its session longer than
    really required. Once data is inserted, we do not need to store the entities in
    the persistent state anymore. We can therefore safely flush and clear the `entityManager`
    to synchronize the state of entities with the database and delete the entities
    from the cache. This will keep the application away from memory constraints, and
    is sure to positively impact performance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: One more improvement can be made by using **lazy initialization**. If we are
    using Hibernate, we should make sure that the lazy initialization feature is used
    properly. We should only use lazy load for the entities if it is required. For
    example, if we have a custom entity collection like `Set<Employee>` which is configured
    for lazy initialization, then each entity of that collection will be loaded separately
    using individual queries. So, if there are multiple entities lazy initialized
    in a set, then there will a large number of queries executed in sequence, which
    can majorly impact the performance.
  prefs: []
  type: TYPE_NORMAL
- en: Testing improvements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For testing improvements, we can build a test environment where an application
    can be executed, and get the result inside of it. We can write repeatable performance
    testing scripts and focus on both the absolute performance (like the page rendering
    time) and the performance on a scale (like the performance degrade on load). We
    can use a profiler in our test environment.
  prefs: []
  type: TYPE_NORMAL
- en: Proper server maintenance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One major performance aspect is related to proper server maintenance (if performance
    is the main concern). The following are some important points that should be considered
    to improve performance:'
  prefs: []
  type: TYPE_NORMAL
- en: Cleaning the temporary files periodically by creating a scheduled automated
    script.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a load balancer when multiple server instances are running.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimizing the configuration based on the application needs. For example, in
    the case of Tomcat, we can refer to Tomcat configuration recommendations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the authentication cache with Spring Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There can be a significant point of view to enhance performance, which can be
    identified when using Spring Security. Spring Security should be properly configured
    to improve performance when the request handling time is measured to be on the
    undesirable side. There might be a case where the actual request handling time
    is measured around 100 ms and Spring Security authentication adds 400-500 extra
    milliseconds. We can eliminate this performance cost using an authentication cache
    with Spring Security.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing Executor service framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With all possible improvements, if concurrency is maintained in terms of request
    handling, performance can be improved. There might be a case when load testing
    is performed with multiple concurrent hits to our application, and it may affect
    our application’s performance. In such cases, we should tune up the thread defaults
    on the Tomcat server. In the event that there is high concurrency, the HTTP requests
    will be put on hold until a thread becomes available to process them.
  prefs: []
  type: TYPE_NORMAL
- en: The default server thread implementation can be extended by using the Executor
    framework within our business logic, to make concurrent asynchronous calls from
    within a method in a single thread execution flow.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we got a clear idea of the Spring MVC module and learned about
    different configuration methods. We also learned about the Spring asynchronous
    processing concept, with `CompletableFeature` implementation. After that, we went
    through the Spring Security module and learned about configuration. We also understood
    the authentication part of Spring Security with the stateless API. Then, we went
    through the monitoring part of Tomcat with JMX. At the end, we looked at Spring
    MVC performance improvements.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about Spring database interaction. We will
    start with Spring JDBC configuration with optimal database design and configuration.
    Then, we will go through the optimal connection pooling configuration. We will
    also cover the concept of `@Transactional` for performance improvement. Finally,
    we will go through database design best practices.
  prefs: []
  type: TYPE_NORMAL
