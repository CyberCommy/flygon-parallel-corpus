- en: Chapter 5. Looping Constructs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is often desirable to repeat a sequence of actions again and again. For example,
    we may want to display information about the employees in an organization stored
    in an array. Each element of the array might hold a reference to a `Employee`
    object. A call to methods of the object would be placed inside a looping construct.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Java there are four looping constructs available:'
  prefs: []
  type: TYPE_NORMAL
- en: For statement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For-each statement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While statement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: d. while statement
  prefs: []
  type: TYPE_NORMAL
- en: In addition, the break and continue statements are used within a loop to control
    how the loop behaves. The break statement is used to prematurely exit or short
    circuit the loop and is discussed in the *The break statement* section. As we
    observed in the *The switch statement* section in [Chapter 3](ch03.html "Chapter 3. Decision
    Constructs"), *Decision Constructs*, the break is also used within the switch
    statement. The continue statement is used to bypass statements in a loop and continue
    executing the loop. It is covered in the *The continue statement* section. We
    will also examine the use of labels in Java, though they should be used sparingly.
  prefs: []
  type: TYPE_NORMAL
- en: The body of the loop is iterated through a specific number of times based on
    the loop structure. Iteration is the term commonly used to describe this execution.
  prefs: []
  type: TYPE_NORMAL
- en: Loops use control information to determine how many times the body of the loop
    will be executed. For most loops there is an initial set of values, a set of operations
    to be performed at the end of the body, and a terminal condition which will stop
    the execution of the loop. Not all loops have all of these parts, as some of these
    parts are either missing or implied. The terminal condition is almost always present
    as this is needed to terminate the iteration of the loop. If the terminal condition
    is missing, an infinite loop is created.
  prefs: []
  type: TYPE_NORMAL
- en: Infinite loops refer to those loops that may never terminate without using a
    statement, such as the break statement. Despite their name, infinite loops do
    not execute indefinitely as they will always terminate at some point. They are
    useful in situations where it is inconvenient or awkward to provide a loop termination
    condition as a part of the basic loop construct.
  prefs: []
  type: TYPE_NORMAL
- en: We will also cover the use of nested loops and various pitfalls associated with
    loops. A section dealing with the development of programming logic is also presented
    to help provide an approach when creating the program logic.
  prefs: []
  type: TYPE_NORMAL
- en: The for statement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The for statement is used when the number of times the loop needs to be executed
    is known. There are two variations of the for loop. The first one is discussed
    in this section and is the traditional form. The for-each statement is the second
    form and was introduced in Java 5\. It is discussed in the *The for-each statement*
    section.
  prefs: []
  type: TYPE_NORMAL
- en: 'The for statement consists of the following three parts:'
  prefs: []
  type: TYPE_NORMAL
- en: Initial operation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Terminal condition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: End loop operation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The general form of the for loop follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The body of a for loop is typically a block statement. The initial operation
    takes place prior to the first iteration of the loop and is executed only once.
    The end loop operations take place at the end of each execution of the loop. The
    terminal condition determines when the loop will terminate and is a logical expression.
    It is executed at the beginning of each repetition of the loop. Thus, the body
    of the for loop may be executed zero times if the first time the terminal condition
    is evaluated, it evaluates to false.
  prefs: []
  type: TYPE_NORMAL
- en: 'A variable is normally used as part of the initial operation, terminal condition,
    and end loop operation . The variable is either declared as part of the loop or
    is declared external to the loop. The following code snippet is an example of
    declaring a variable, `i`, as part of the loop. An example of using an external
    variable is covered in the *The for statement and scope* section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example we used a single statement in the body of the loop. The variable
    `i` was assigned an initial value of 1 and is incremented by 1 each time the loop
    executes. The loop executed 10 times and produced 1 line of output. The statement,
    `i++`, is a more concise way of saying `i = i + 1`. The output should be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The following example uses a for statement to compute the square of the integers
    from `1` to `64`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'A partial listing of the output follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**1 squared is = 1**'
  prefs: []
  type: TYPE_NORMAL
- en: '**2 squared is = 4**'
  prefs: []
  type: TYPE_NORMAL
- en: '**3 squared is = 9**'
  prefs: []
  type: TYPE_NORMAL
- en: '**4 squared is = 16**'
  prefs: []
  type: TYPE_NORMAL
- en: '**...**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The initial value of the loop variable can be any value. In addition, the end
    loop operation can decrement or otherwise modify the variable as needed. In the
    next example, numbers are displayed from `10` to `1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this sequence follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'A common operation is to compute a cumulative sum, as illustrated with the
    following code sequence. This example is discussed in more detail in the *Timing
    is everything* section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The value of `sum` should be `55`.
  prefs: []
  type: TYPE_NORMAL
- en: The comma operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The comma operator can be used as part of a for statement to add other variables
    for use within the loop and/or to control the loop. It is used to separate the
    parts of the initial-expression and the end-loop operation sections of the for
    loop. The use of the comma operator is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Notice the use of the `%n` format specifier in the `printf` statement. This
    specifies that a new line character should be generated. In addition, this new
    line separator is platform-specific making the application more portable.
  prefs: []
  type: TYPE_NORMAL
- en: 'When executed, this code sequence will produce the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Two variables were declared for the loop, `i` and `j`. The variable `i` was
    initialed to `0` and `j` was initialized to `10`. At the end of the loop, `i`
    was incremented by `1` and `j` was decremented by `1`. The loop executed as long
    as `j` was greater than `5`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could have used a more complex terminal condition, such as illustrated in
    the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, the loop will terminate after the third iteration resulting
    in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'It is illegal to declare the variables separately, as attempted here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'A syntax error is generated, shown as follows. Only the first part of the message
    is provided as it is lengthy. This also illustrates the cryptic nature of error
    messages generated by Java and most other programming languages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The for statement and scope
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The index variable used by a for statement can have different scope depending
    on how it is declared. We can use this to control the execution of the loop and
    then use the variable outside the loop, as needed. The first example of a for
    loop is repeated as follows. In this code sequence the scope of the `i` variable
    is restricted to the body of the for loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'An alternate approach declares `i` external to the loop as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'These two for loops are equivalent as they both display the numbers 1 to 10
    on a single line. They differ in the scope of the `i` variable. In the first example,
    the scope is restricted to the body of the loop. An attempt to use the variable
    outside of the loop, as illustrated in the following code, will result in a syntax
    error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The error message follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In the second example, upon termination of the loop the variable will retain
    its value and will be available for subsequent use. The following example illustrates
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this sequence follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Scope is discussed in more detail in the *Scope and lifetime* section in [Chapter
    2](ch02.html "Chapter 2. Java Data Types and Their Usage"), *Java Data Types and
    Their Usage*.
  prefs: []
  type: TYPE_NORMAL
- en: The for loop variations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The for loop may have a body consisting of multiple statements. It is important
    to remember that the for loop body consists of a single statement. The following
    illustrates the use of multiple statements in a loop. This loop will read in a
    sequence of numbers and print them out one per line. It will continue until it
    reads in a negative value and then it will exit the loop. The `java.util.Scanner`
    class is used to read in data from the input source. In this case it uses `System.in`
    which specifies the keyboard as its input source:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'One possible output of executing this code sequence is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The initial operation, terminal condition, or end loop operation are not required.
    For example, the following statements will execute the `i++` statement 5 times
    with a value `5` assigned to `i` upon the exit from the loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following example, the body of the loop will execute forever creating
    an infinite loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The same is true for the following for loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This is called an **infinite loop** and is covered in more detail in the *Infinite
    loops* section.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The for loop is normally used when you know how many times the loop will be
    executed. A controlling integer variable is typically used as an index into an
    array or for computational purposes within the body of the loop.
  prefs: []
  type: TYPE_NORMAL
- en: The for-each statement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The for-each statement was introduced with the release of Java 5\. It is sometimes
    referred to as the enhanced for loop. Advantages of using the for-each statement
    include:'
  prefs: []
  type: TYPE_NORMAL
- en: It is unnecessary to provide end conditions for the counter variable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is simpler and more readable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The statement provides opportunities for compiler optimization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The use of generics is simplified
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The for-each statement is used in conjunction with collections and arrays. It
    provides an easier way to iterate through each member of an array or class that
    has implemented the `java.util.Iterable` interface. As the `Iterable` interface
    is the super interface of the `java.util.Collection` interface, the for-each statement
    can be used with those classes that implement the `Collection` interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax of this statement is similar to the regular for statement, except
    for the contents of its parentheses. The contents include a data type followed
    by a variable, a colon, and then an array name or collection, illustrated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Its use with a collection is illustrated in the *Using the for-each statement
    with a list* section. In the following sequence, an array of integers is declared,
    initialized, and a for-each statement is used to display each element of the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The elements of the numbers array were initialized to their index. Notice that
    a for statement was used. This was because we are unable to access an index variable
    directly in a for-each statement easily. The for-each statement in the preceding
    code snippet is read as **"**for each element in numbers". During each iteration
    of the loop, `element` corresponds to an element of the array. It starts with
    the first element and ends with the last element. The output of this sequence
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'There are drawbacks to the use of the for-each statement with an array. It
    is not possible to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Modify the current position in an array or list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Directly iterate over multiple arrays or collections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, using the previous example, if we try to modify the element of
    the array containing a 5 with the following code, it will not result in a syntax
    error. But it also will not modify the corresponding array element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this sequence is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to use one loop to access two different arrays, the for-each loop
    cannot be used. For example, if we want to copy one array to another, we need
    to use the for loop, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: While we used a for-each to initialize the source array, we can only address
    a single array at a time. Thus, in the second loop we were forced to use the for
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: Using the for-each statement with a list
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will start by illustrating the use of the for-each statement with the `ArrayList`.
    The `ArrayList` class implements the `List` interface which extends the `Collection`
    interface. The use and declaration of interfaces is addressed in more detail in
    [Chapter 6](ch06.html "Chapter 6. Classes, Constructors, and Methods"), *Classes,
    Constructors, and Methods*. As the for-each statement can be used with classes
    that implement the `Collection` interface, we can also use it with the `ArrayList`
    class. In the next section, we will create our own `Iterable` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The output, as you might predict, is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The use of the for-each in this example is not that much different from its
    use with an array. We simply used the name of the `ArrayList` instead of an array
    name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using a for-each statement with a list has similar restrictions to those we
    saw earlier with arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: May not be able to remove elements from a list as you traverse it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inability to modify the current position in a list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Not possible to iterate over multiple collections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `remove` method can throw a `UnsupportedOperationException` exception. This
    is possible because the implementation of the `Iteratable` interface's `Iterator`
    may not have implemented the `remove` method. This is elaborated on in the next
    section.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of the `ArrayList`, we can remove an element, as demonstrated in
    the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The for-each statement was used to iterate over the list. When the `bears.`
    string was found, it was removed. The output of the preceding sequence is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We cannot modify the list from within the for-each statement. For example,
    the following code sequence attempts to modify `word` and add a string to `list`.
    The list will not be affected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: While the attempt to modify the `word` variable does not do anything, it does
    not generate an exception. This is not the case with the `add` method. When used
    within the preceding for-each statement, it will generate a `java.util.ConcurrentModificationException`
    exception.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As with arrays, it is not possible to iterate over more than one collection
    at a time using the for-each statement. As the for-each statement supports only
    one reference variable, only one list can be accessed at a time.
  prefs: []
  type: TYPE_NORMAL
- en: If you need to remove an element from a list, use an iterator instead of a for-each
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Iterator interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As mentioned earlier, any class that implements the `Iterable` interface can
    be used with the for-each statement. To illustrate this we will create two classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`MyIterator`: This implements the `Iterator` interface and supports a trivial
    iteration'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MyIterable`: This uses `MyIterator` to support its use in a for-each statement'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'First, let''s examine the `MyIterator` class that follows. The class will iterate
    through the numbers 1 to 10\. It does this by comparing the `value` variable against
    an upper bound of 10 and returning either `true` or `false` in its `hasNext` method.
    The `next` method simply returns and increments the current value. The `remove`
    method is not supported:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The `MyIterable` class implements the `Iterable` interface. This interface
    consists of a single method, `iterator`. In this class, it uses an instance of
    the `MyIterator` class to provide a `Iterator` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We can test these classes with the following code sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will display the numbers from 1 to 10, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The use of the `Iterator` methods for iterating through a collection is not
    always needed. In many situations, the for-each statement provides a much more
    convenient and simple technique.
  prefs: []
  type: TYPE_NORMAL
- en: The for-each statement – usage issues
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are several issues that you should be aware of when working with the
    for-each statement:'
  prefs: []
  type: TYPE_NORMAL
- en: If the array/collection is null, you will get a null pointer exception
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It works well with a method having a variable number of arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Null values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If the array/collection is null, you will get a null pointer exception. Consider
    the following example. We create an array of strings but fail to initialize the
    third element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We can display the names using a for-each statement as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The output, shown as follows, will display `null` for the missing entry. This
    is because the `println` method checks its argument for a null value and when
    it is, it prints `null`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if we apply the `toString` method against the name as follows, we
    will get `java.lang.NullPointerException` on the third element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'This is verified, as shown in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Variable number of arguments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The for-each statement works well in methods using a variable number of arguments.
    A more detailed explanation of methods that use a variable number of arguments
    is found in the *Variable number of arguments* section in [Chapter 6](ch06.html
    "Chapter 6. Classes, Constructors, and Methods"), *Classes, Constructors, and
    Methods*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following method we pass a variable number of integer arguments. Next,
    we calculate the cumulative sum of these integers and return the sum:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'When this is executed with the following calls, we get `15` and `0` as output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'However, we need to be careful not to pass a `null` value as this will result
    in `java.lang.NullPointerException`, as illustrated in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Use the for-each loop whenever possible, instead of the for loop.
  prefs: []
  type: TYPE_NORMAL
- en: The while statement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The while statement provides an alternate way of repeatedly executing a block
    of statements. It is frequently used when the number of times the block is to
    be executed is not known. Its general form consists of the `while` keyword followed
    by a set of parentheses enclosing a logical expression and then a statement. The
    body of the loop will execute as long as the logical expression evaluates to true:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'A simple example duplicates the first for loop example where we display the
    numbers 1 to 10 on a single line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The following example is a bit more complicated and computes the factors of
    the `number` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'When executed with the input as `6`, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The following table illustrates the action of the statement''s sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Iteration count | divisor | number | Output |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1 | 6 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | 2 | 6 | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | 3 | 6 | 3 |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | 4 | 6 |   |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | 5 | 6 |   |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | 6 | 6 | 6 |'
  prefs: []
  type: TYPE_TB
- en: 'In the following example, the loop will terminate when the user types in a
    negative number. In the process, it calculates the cumulative sum of the numbers
    entered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice how this example duplicated the code needed to prompt the user for a
    number. The problem can be handled more elegantly using a do-while statement as
    discussed in the next section. The following output illustrates the execution
    of this code for a series of numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The while statement is useful for loops where the number of loop iterations
    required is not known. The body of the while loop will execute until the loop
    expression becomes false. It is also useful when the terminal condition is rather
    complex.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An important characteristic of the while statement is the evaluation of the
    expression at the beginning of the loop. As a result, the body of the loop may
    never be executed if the first evaluation of the logical expression evaluates
    to false.
  prefs: []
  type: TYPE_NORMAL
- en: The do-while statement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The do-while statement is similar to a while loop except that the body of the
    loop always executes at least once. It consists of the `do` keyword followed by
    a statement, the `while` keyword, and then a logical expression enclosed in parentheses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Typically, the body of the do-while loop, as represented by the statement,
    is a block statement. The following code snippet illustrates the use of the do
    statement. It is an improvement over the equivalent while loop used in the previous
    section, as it avoids prompting for a number before the loop starts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'When executed you should get output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The do-while statement differs from that of the while statement as the evaluation
    of the expression occurs at the end of the loop. This means that this statement
    will be executed at least once.
  prefs: []
  type: TYPE_NORMAL
- en: 'This statement is not used as frequently as the for or while statement, but
    is useful in situations where a test at the bottom of a loop is best. The next
    statement sequence will determine the number of digits in an integer number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this sequence follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The result for the value `452` is illustrated in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Iteration count | number | numOfDigits |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 452 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 45 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | 4 | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | 0 | 3 |'
  prefs: []
  type: TYPE_TB
- en: The break statement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The effect of the break statement is to terminate the current loop, whether
    it be a while, for, for-each, or do-while statement. It is also used in the switch
    statement. The break statement passes control to the next statement following
    the loop. The break statement consists of the `break` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the effect of the following statement sequence which repeatedly prompts
    the user for a command within an infinite loop. The loop will be terminated when
    the user enters the `Quit` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Notice how the `equals` method is used. The `equals` method is executed against
    the string literal and the command is used as its argument. This approach avoids
    `NullPointerException` that will result if the command contains a null value.
    As the string literals are never null, this exception will never occur.
  prefs: []
  type: TYPE_NORMAL
- en: The continue statement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The continue statement is used to transfer control from inside a loop to the
    end of the loop but does not exit the loop like the break statement does. The
    continue statement consists of the keyword, `continue`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When executed, it forces the evaluation of the loop''s logical expression.
    In the following statement sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: if `i` is less than `0`, it will bypass the rest of the body of the loop. If
    the loop condition `i<j` does not evaluate to false, the next iteration of the
    loop will be performed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The continue statement is often used to eliminate a level of nesting which
    is often necessary. The preceding example would appear as follows, if the continue
    statement was not used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Nested loops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Loops can be nested within each other. Any nested combination of the for, for-each,
    while, or do-while loops is permitted. This is useful for addressing a number
    of problems. The example that follows computes the sum of the elements of a row
    in a two-dimensional array. It starts by initializing each element to the sum
    of its indexes. The array is then displayed. This is followed by nested loops
    to compute and display the sum of the elements for each row:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice the use of the `length` method used to control the number of times the
    loops are executed. This makes the code more maintainable if the size of the arrays
    change. When executed we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Notice the use of the for-each statement when the array is displayed and the
    sum of the rows are calculated. This simplifies the calculations.
  prefs: []
  type: TYPE_NORMAL
- en: The break and continue statements can also be used within nested loops. However,
    they will only be used in conjunction with the current loop. That is, a break
    out of an inner loop will only break out of the inner loop and not the outer loop.
    As we will see in the next section, we can break out of the outer loop from an
    inner loop using labels.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following modification of the last nested loop sequence, we break out
    of the inner loop when the sum exceeds 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The execution of this nested loop will change the sum of the last row as shown
    below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: The break statement took us out of the inner loop but not the outer loop. We
    can break out of the outer loop if there was a corresponding break statement within
    the immediate body of the outer loop. The continue statement behaves in a similar
    fashion in relation to inner and outer loops.
  prefs: []
  type: TYPE_NORMAL
- en: Using labels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Labels are names of locations within a program. They can be used to alter the
    flow of control and should be used sparingly. In the previous example, we were
    unable to break out of the inner most loop using the break statement. However,
    labels can be used to break us out of more than one loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we place a label in front of the outer loop. In the
    inner loop, we execute the break statement when `i` is larger than 0 effectively
    terminating the outer loop after the sum has been calculated for the first row.
    A label consists of a name followed by a colon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this sequence is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: We can also use the continue statement with labels for a similar effect.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Labels should be avoided as they can result in unreadable and hard to maintain
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Infinite loops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An infinite loop is one that will execute forever unless a statement, such as
    the break statement is used to force its termination. Infinite loops are quite
    useful to avoid an awkward logical condition for a loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'An infinite while loop should use the `true` keyword as its logical expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'A for loop could be as simple as using nulls for each part of the for statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'A loop that never terminates would not normally be of value for most programs
    since most programs should eventually terminate. However, most infinite loops
    are designed to terminate using the break statement, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'This technique is fairly common and is used to simplify the logic of a program.
    Consider the need to read in an age and terminate when the age is negative. It
    is necessary to assign a non-negative value to age to ensure that the loop executes
    at least once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'The other option is to duplicate the user prompt and the statement used to
    read in the age before the loop begins:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Either an arbitrary value had to be assigned to age before the loop began, or
    it was necessary to duplicate code. Neither approach is satisfactory.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, the use of an infinite loop results in cleaner code. No arbitrary
    value needs to be assigned and code does not need to be duplicated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'While there are many situations where an infinite loop is desirable, they can
    also occur when the programmer is not careful, resulting in unanticipated results.
    One common way is to build a for loop without a valid termination condition, illustrated
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: The loop starts with a value of 1 for `i` and will increment `i` by 1 during
    each iteration of the loop. The termination condition suggests that the loop will
    not terminate as `i` will only get larger and would, thus, always be greater than
    0\. However, eventually the variable will overflow and `i` will become negative
    and the loop will terminate. How long this might take depends on the execution
    speed of the machine.
  prefs: []
  type: TYPE_NORMAL
- en: The moral of the story is, "Be careful with loops". Infinite loops can be both
    a useful construct for solving some problems and a problematic construct when
    used unintentionally.
  prefs: []
  type: TYPE_NORMAL
- en: Timing is everything
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A common programming need is to perform some sort of summation. We have computed
    the sum of several sequences of numbers in previous examples. While the summation
    process is relatively straightforward, it can be difficult for novice programmers.
    More importantly, we will use it here to provide an insight to the programming
    process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Programming, by its nature, is an abstract process. The programmer will need
    to look at a static code listing and infer its dynamic execution. This can be
    difficult for many people. One way of assisting the developer in writing code
    is to consider the following three issues:'
  prefs: []
  type: TYPE_NORMAL
- en: What do we want to do?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do we want to do it?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When do we want to do it?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here, we will ask and apply the answers to these three questions to address
    the summation problem. However, these questions are equally applicable to other
    programming problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s focus on calculating the average age for a group of students, which
    will involve the summation process. Assume the ages are stored in `age` array
    and then initialized as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Then the summation can be calculated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that `total` is explicitly assigned a zero value. Each iteration of
    the for loop will add the next `age` to `total`. At the completion of the loop,
    `total` will be divided by the length of the array times `1.0f` to compute the
    average. By using the array length the code expression does not need to be changed
    if the array size changes. Multiplying by `1.0f` is necessary to avoid integer
    division. The following table illustrates the variable''s values as the loop executes:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Loop count | i | total |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | - | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1 | 23 |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | 2 | 41 |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | 3 | 60 |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | 4 | 78 |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | 5 | 99 |'
  prefs: []
  type: TYPE_TB
- en: 'Let''s examine this problem from the standpoint of the three basic questions,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**What do we want to do**: We want to calculate the total pay for a department.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**How do we want to do it**: This has a multipart answer. We know we need a
    variable to hold the total pay, `total`, and that it needs to be initialized to
    0.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'We also understand the basic operation to calculate the cumulative sum is as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'The loop needs to use each element of the array so a for-each statement is
    used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: We have the foundation for a solution to our problem.
  prefs: []
  type: TYPE_NORMAL
- en: '**When do we want to do it**: The "when" in this situation suggests three basic
    choices:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before the loop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the loop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After the loop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The three parts of our solution can be combined in different ways. The basic
    operation needs to be inside the loop because it needs to be performed more than
    once. Executing the basic operation only once will not result in an answer we
    will like.
  prefs: []
  type: TYPE_NORMAL
- en: The variable, `total`, needs to be initialized with a 0\. How is this done?
    We do this by using an assignment statement. When should this be done? Before,
    in, or after the loop? Doing this after the loop would be silly. When the loop
    completes, `total` should contain the answer, not a zero. If we initialize it
    to 0 inside of the loop, then with each iteration of the loop, `total` is reset
    back to `0`. That leaves us with placing the statement before the loop as the
    only option that makes sense. The first thing we want to do is to assign a `0`
    to `total`.
  prefs: []
  type: TYPE_NORMAL
- en: 'There seems to always be variations to the solutions of most problems. For
    example, we could have used a while loop instead of a for-each loop. The `+=`
    operator could be used to shorten the basic operation. One potential solution
    that uses these techniques introduces an index variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Clearly, there is not always a best solution to a specific problem. This makes
    the programming process both a creative and potentially fun activity.
  prefs: []
  type: TYPE_NORMAL
- en: Pitfalls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As with most programming constructs, loops have their own set of potential pitfalls.
    In this section we will address areas that can present problems to the unwary
    developer.
  prefs: []
  type: TYPE_NORMAL
- en: 'One common problem occurs when programmers use a semicolon after every statement.
    For example, the following statement results in an infinite loop because of the
    extra semicolon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: The semicolon on a line by itself is the empty statement. This statement does
    nothing. However, in this example it constitutes the body of the while loop. The
    increment statement is not part of the while loop. It is the first statement that
    follows the while loop. Indention, while desirable, does not make the statement
    a part of the loop. Thus, `i` is never incremented and the logical control expression
    will always return true.
  prefs: []
  type: TYPE_NORMAL
- en: 'Failure to use a block statement for the body of a loop can be a problem. In
    the following example we attempt to calculate the sum of the product of the numbers
    from 1 to 5\. However, this does not work properly because the body of the loop
    only encompasses the calculation of the product. The summation statement, when
    it is indented, is not part of the body of the loop and is only executed once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'The correct implementation of the loop uses a block statement as shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is always a good policy to use a block statement for the body of a loop,
    even if the body consists of a single statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following sequence the body of the loop consists of multiple statements.
    However, `i` is never incremented. This will also result in an infinite loop unless
    either limit is changed or a break statement is encountered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Even simple-appearing loops may, in effect, be infinite loops if one is not
    careful with how floating-point arithmetic occurs. In this example, `0.1` is added
    to `x` with each iteration of the loop. The loop is supposed to stop when `x`
    exactly equals `1.1`. This will never occur because of issues in how floating
    point numbers are stored for certain values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'The number `0.1` cannot be stored precisely in base two in the same way that
    the decimal equivalent of the fraction 1/3 cannot be represented exactly (0.333333…).
    The result of adding this number repeatedly to `x` will result in a number that
    is not quite `1.1`. The comparison, `x != 1.1`, will return true and the loop
    will never end. The output of the `printf` statement does not show this difference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Be careful when working with operations that will involve auto-boxing. Depending
    on the implementation, it can result in a performance hit if boxing and un-boxing
    occurs frequently.
  prefs: []
  type: TYPE_NORMAL
- en: While not necessarily a pitfall, remember that logical expressions can short
    circuit. That is, the last part of a logical AND or OR operation may not be evaluated
    depending on the value returned from the evaluation of the first part. This is
    discussed in detail in the *Short circuit evaluation* section in [Chapter 3](ch03.html
    "Chapter 3. Decision Constructs"), *Decision Constructs*.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember that arrays, strings, and most collections are zero based. Forgetting
    to start the loop at `0` will overlook this first element.
  prefs: []
  type: TYPE_NORMAL
- en: Always use a block statement as the body of a loop.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we examined the support Java provides for loops. We have illustrated
    the use of the for, for-each, while, and do-while statements. These demonstrations
    provided insight into their correct usage, when they should be used, and when
    they should not be used.
  prefs: []
  type: TYPE_NORMAL
- en: The use of the break and continue statements was shown, along with the use of
    labels. We saw the utility of the break statement, in particular, in support of
    infinite loops. Labels, while they should be avoided, can be useful in breaking
    out of deeply nested loops.
  prefs: []
  type: TYPE_NORMAL
- en: Various pitfalls were examined and the creation of the summation process was
    studied to gain insight into general programming problems. Specifically, it addressed
    the question of where a code segment should be placed.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've learned about loops, we're ready to examine the creation of classes,
    methods, and data encapsulation, which is the topic of the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Certification objectives covered
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter we addressed the following certification objectives:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating and using the while loops
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating and using the for loops including the enhanced for loop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating and using the do/while loops
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparing the loop constructs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using break and continue
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In addition, we provided additional coverage of these objectives:'
  prefs: []
  type: TYPE_NORMAL
- en: Define the scope of variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use operators and decision constructs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Declaring and using an ArrayList
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test your knowledge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Given the following declarations, which of the following statement will compile?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: a. `while(i < j) {}`
  prefs: []
  type: TYPE_NORMAL
- en: b. `while(i) {}`
  prefs: []
  type: TYPE_NORMAL
- en: c. `while(i = 5) {}`
  prefs: []
  type: TYPE_NORMAL
- en: d. `while((i = 12)!=5) {}`
  prefs: []
  type: TYPE_NORMAL
- en: Given the following declaration of an array, which statement will display each
    element of the array?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'a. `for(int n : arr[]) { System.out.println(n); }`'
  prefs: []
  type: TYPE_NORMAL
- en: 'b. `for(int n : arr) { System.out.println(n); }`'
  prefs: []
  type: TYPE_NORMAL
- en: c. `for(int n=1; n < 6; n++) { System.out.println(arr[n]); }`
  prefs: []
  type: TYPE_NORMAL
- en: d. `for(int n=1; n <= 5; n++) { System.out.println(arr[n]); }`
  prefs: []
  type: TYPE_NORMAL
- en: Which of the following do/while loops will compile without errors?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: b.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: c.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: d.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: Which of the following loops are equivalent?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: b.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: c.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: What will be output by the following code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'a. `i: 1 j: 2i: 2 j: 2i: 3 j: 2`'
  prefs: []
  type: TYPE_NORMAL
- en: 'b. `i: 1 j: 3i: 2 j: 3i: 3 j: 3`'
  prefs: []
  type: TYPE_NORMAL
- en: 'c. `i: 1 j: 1i: 2 j: 1i: 3 j: 1`'
  prefs: []
  type: TYPE_NORMAL
