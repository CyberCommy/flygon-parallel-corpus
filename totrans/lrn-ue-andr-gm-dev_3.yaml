- en: Chapter 3. Building the Game – First Steps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By now, you hopefully have everything set up. You now know enough for us to
    finally get started with what you are really here for, to make games using UE4\.
    A great feature about UE4 is that it is easy to get into, yet hard to master,
    since there is so much you can do with this powerful engine. We will start by
    making the core elements of the game, namely the level, lighting, and materials.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What a project is, different types of projects offered by UE4, loading, and
    creating new projects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our game's concept, objective, genre, and features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Geometry and BSP brushes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Importing assets into the Content Browser, and onto the level
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create materials
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lighting, its types, implementation, and building lights
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Projects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A project is an entity that holds all of the assets, maps, and code that make
    up your game. Once created, you can create multiple levels, or scenes, within
    that project. You can create, and purchase your own project files and use them.
    Mostly, projects that you can purchase come as a theme with assets and levels
    made according to that theme. For instance, you can download the **Sci-Fi Hallway**
    project for free from the Marketplace. This project file contains various objects,
    materials, and an example level setup of a futuristic hallway.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When creating a new project, UE4 offers a number of templates that you can
    choose from, depending upon what type of game you wish to make. Let''s look at
    **Unreal Project Browser** again to better understand what this means:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a new project](img/image00229.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding screenshot, we see there are various types of templates available.
    These templates are project files that you can create, which contain the framework
    for the type of game you need to make. For example, if you want to make a third-person
    shooter or adventure game, you can choose **Third Person**, which contains things
    like the camera, characters, and the basic mechanics scripted. It also contains
    a sample map, where you can test the controls and the mechanics. To create a new
    project, simply highlight the type of game you wish to create, and click on **Create
    Project**.
  prefs: []
  type: TYPE_NORMAL
- en: Opening an existing project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are several ways to open a project. One way is through **My Projects**,
    in the **Engine Launcher Library** section. The second way is in **Unreal Project
    Browser**, under the **Projects** panel. The third way to load a project is in
    the Editor itself. To do so, simply click on the **File** in the menu bar to open
    the **File** menu, select **Open Project** and simply select which project you
    wish to open. Doing so will close the current project and reopen the Editor.
  prefs: []
  type: TYPE_NORMAL
- en: Project directory structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By default, any projects you create are stored in `C:\Users\*account name*\Documents\Unreal
    Projects`. On opening this folder, you will see something similar to the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Project directory structure](img/image00230.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding screenshot, each project has its own separate folder. Each
    folder contains files and folders related to that project, such as the assets,
    maps, the project file or `.uproject` files, and so on. Have a look around, see
    which folder contains what and the role each of them plays. To delete any project,
    simply delete the folder of the project you wish to remove.
  prefs: []
  type: TYPE_NORMAL
- en: Bloques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have our project setup. We can start making our game. Let's first talk about
    what the game is.
  prefs: []
  type: TYPE_NORMAL
- en: Concept
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The game we are going to make in the guide is Bloques, which is a first person
    puzzle game designed for Android. The main objective of the game is to solve a
    series of puzzles in each room to progress to the next. The game we are going
    to make is going to have four rooms; with each progressive level, the puzzle gets
    more complex.
  prefs: []
  type: TYPE_NORMAL
- en: Controls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The player controls the character using two virtual joysticks, one for moving
    and the other for looking. All of the game's interaction, such as picking up objects,
    opening doors, and so on, will be done via touch.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the project for the game
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first thing we need to do is set up a project. In the Engine Launcher,
    launch the Editor through the **Launch** button. The version used to make this
    game is 4.7.6\. After the Unreal Project Browser has opened, open the **New Project**
    panel and follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Select **First Person** from the templates section, and select the template
    in the **Blueprint** tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Target Hardware** options, pick **Mobile/Tablet**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Quality Settings**, you have two options, **Maximum Quality** and **Scalable
    2D or 3D**. As mentioned before, you should only pick **Maximum Quality** if you
    are making a game for PC or Console and **Scalable 2D or 3D** for mobile or tab.
    Keeping that in mind, select **Scalable 2D or 3D**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the menu which asks you whether you want to start with or without starter
    content, select **No Starter Content**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, set the name of the project as `Bloques`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After all of these settings, it should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the project for the game](img/image00231.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Next, simply click on **Create Project**. We have now set up our project. After
    the Editor has opened, you will see a test level already set up. The test level
    is just to showcase the basic functionalities and mechanics that the template
    you have chosen, provides. In the **First Person** template, the player will be
    able to move, jump, and shoot. Another great feature is that, when you select
    **Mobile/Tablet** as your target hardware, UE4 automatically provides two virtual
    game-pads, one for moving and the other for looking. This takes a lot of work
    out of having to script in the controls.
  prefs: []
  type: TYPE_NORMAL
- en: However, we do not want to work on this example map. We would want to work on
    a new map. To do so, simply click on **File** to open the menu, and click on **New
    Level**. Clicking on it will open up the **New Level** window, which offers two
    types of levels, **Default** and **Empty**. A **Default Level** has the very basic
    components, such as a skybox and a player start actor already set up.
  prefs: []
  type: TYPE_NORMAL
- en: '**Empty Level**, however, as the name suggests, contains absolutely nothing
    set up. If you wish to make your game from scratch, you should pick **Empty Level**.
    Since our game is going to take place indoors, we do not really need a skybox.
    Therefore, choose **Empty Level**. We have now set up our level where we are going
    to make our game. Let''s save this level as `Bloques_Game`. Your **Viewport**
    will now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the project for the game](img/image00232.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: BSP brushes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first thing we need to do is build our level. We will do this with the help
    of BSP brushes. We talked briefly about BSP brushes in the second chapter, but
    now we will talk about them in a bit more detail. BSP brushes create volumes and
    surfaces for your level. It provides a quick and easy way to block out your level
    and to make quick prototypes. You can even create the entire level itself using
    BSP brushes. If you do not have access to 3D modelling software, such as Maya
    or 3DS Max, to create assets for your level (such as walls, ceilings, and so on),
    then you can use BSP brushes instead to create your level. The BSP brushes can
    be selected in the **Modes** panel, in the **Place Mode**.
  prefs: []
  type: TYPE_NORMAL
- en: Default BSP brush shapes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As mentioned in the previous chapter, there are a total of seven default brushes
    offered by UE4\. The following is a screenshot of the geometry created by brushes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Default BSP brush shapes](img/image00233.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'From left to right, you have:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Box Brush**: This creates a cube-shaped brush. You can set the length, width,
    and height of the box. You can also set whether you want the cube to be hollow
    or not. If so, you have the option to set the thickness of the walls.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sphere Brush**: This creates a spherical brush. You can set the number of
    tessellations. Increasing the number of tessellations will make it smoother and
    more like a proper sphere. However, keep in mind that increasing the tessellations
    will increase the number of surfaces and therefore will require more memory to
    render. Keeping that and the technical limitations of mobile devices in mind,
    it is better to have a low-polygon geometry with a good texture, than a high-polygon
    geometry with a bad texture.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cylinder Brush**: This creates a cylindrical brush. You can set its radius
    and height. You can also increase or decrease the number of sides. As with the
    Sphere Brush, increasing the number of sides will increase the number of surfaces
    along the length, making it smoother, but will require more memory to render.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cone Brush**: This creates a conical brush. You can set properties such as
    the height, and the radius of the base. You can also set the number of surfaces
    in the brush.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Linear Stair Brush**: This allows you to create linear or straight stairs.
    Instead of having to model, unwrap, and import stairs into your level, you can
    create it in the engine itself. You can set properties such as the length, width,
    and height of each step, the number of steps, and the distance below the first
    step.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Curved Stair Brush**: You can also create curved stairs using the Curved
    Stair Brush. You can set properties such as the inner radius of the curve, the
    angle of the curve (the angle of curve means how much the stair will curve. You
    can set it to any value between 0 to 360 degrees), the number of steps, and the
    distance below the first step. Finally, you can also set whether you want the
    stairs to curve clockwise or counter-clockwise.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Spiral Stair Brush**: Finally, we have the Spiral Stair Brush. The difference
    between Spiral and Curved Stairs is that Spiral Stairs can repeatedly wrap over
    itself, while Curved Stairs cannot. You can set things like the inner radius,
    the width, height, and thickness of each step, number of steps, and number of
    steps in one whole spiral. Finally, you can also set options such as whether you
    want the underside and/or the surface of the stairs to be sloped or stepped and
    whether you want the spiral to be clockwise or counter-clockwise.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The preceding brush types can be used to create geometry through the use of
    additive or subtractive brush types through the **Modes** panel under **Place**/**BSP**.
    When a brush is added to your level and used to create geometry, an additive brush
    type will add geometry wherever placed. Subtractive brush types will remove any
    geometry that is overlapping additive geometry.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from these settings, you can also set the properties of each surface of
    the geometry, such as panning, rotating, flipping, and scaling the *U* and/or
    *V* coordinates. You can see their effects when you apply materials to them.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you also have the option to use brushes to create volumes, such as
    trigger volumes, blocking volumes, pain-causing volumes, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Editing BSP brushes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Say, you want to create geometry using BSP brushes, but the shape that you require
    is not one of the seven default shapes. In that case, you can create your own
    brush using the **Geometry Edit** mode. It is located on the far right of the
    **Modes** panel. Click on it to switch to the **Geometry Edit** mode.
  prefs: []
  type: TYPE_NORMAL
- en: '![Editing BSP brushes](img/image00234.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding screenshot, you can see that when you switch to the Geometry
    Edit mode, all of the vertices, faces, and edges in the geometry. You also may
    have noticed that the size of the vertices have increased. In this mode, you can
    select either the whole brush, a face, a vertex, or an edge of the geometry.
  prefs: []
  type: TYPE_NORMAL
- en: In the modes panel, you can see several operations, such as **Create**, **Delete**,
    **Flip**, and so on. Some of them you can perform, while the others you cannot.
    What operation you can and cannot perform depends upon what you have selected
    (such as a vertex, edge, or face).
  prefs: []
  type: TYPE_NORMAL
- en: Blocking out the rooms with BSP brushes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will now design the environment for our game. Make four rooms and keep them
    blocked out so the player has to solve the puzzle in one room to get to the next.
  prefs: []
  type: TYPE_NORMAL
- en: The first room
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first room is going to be relatively straightforward. The room is going
    to be cuboid. Since this is where the player starts, he/she will be introduced
    to the mechanics in this room, such as moving, looking, picking up and placing
    objects. The player simply has to pick up the key cube and place it on the pedestal
    to open the door. The player will also know, through this simple task, the main
    objective in each room.
  prefs: []
  type: TYPE_NORMAL
- en: So let's begin by making the floor. We are going to use a **Box Brush**. To
    add a **Box Brush**, simply click on **Box** in the **Modes** panel under **BSP**
    and drag it on to the **Viewport**. In the **Details** panel, set the dimensions
    of the brush as `2048 x 2048 x 64`. We want this room to be relatively small,
    since the puzzle is simple and also, to avoid unnecessary walking, as the player
    might get bored.
  prefs: []
  type: TYPE_NORMAL
- en: '![The first room](img/image00235.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: After that, let's now make the walls. Again, we will use a Box BSP brush to
    make them. Set the dimensions as `2048 x 64 x 1024`. After you have made one wall,
    simply click and hold the *Alt* key and move the wall to create a duplicate, which
    can be placed on the other side of the room.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When using BSP brushes, switch the View mode to **Unlit**. Otherwise, you will
    not be able to see the surfaces and would have to build the lighting every time
    you introduce a surface.
  prefs: []
  type: TYPE_NORMAL
- en: For the walls along the adjacent side, let's set the dimensions as `64 x 2048
    x 1024`. Again, as with the other wall, simply duplicate the BSP brush and move
    it to the far side of the room.
  prefs: []
  type: TYPE_NORMAL
- en: '![The first room](img/image00236.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, for the ceiling, simply duplicate the floor and drag it on top of the
    walls.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To prevent light bleeding and other complications regarding lighting and rendering,
    make sure that there is no gap between any of the brushes. Switch to **Top**,
    **Side**, or **Front** view to make sure all of the walls and ceilings are perfectly
    lined up.
  prefs: []
  type: TYPE_NORMAL
- en: What this room now needs is a hole for the door. Otherwise, the player would
    be stuck in the first room and would not be able to advance to the next. We are
    going to do so with the help of a subtractive BSP brush.
  prefs: []
  type: TYPE_NORMAL
- en: To create a subtractive brush, drag the **Box Brush** onto the level, and in
    the **Details** panel, set the **Brush Type** to **Subtractive**. Set the dimensions
    of this as `64 x 256 x 256`. Place this subtractive brush on any of the walls
    along the shorter side of the room.
  prefs: []
  type: TYPE_NORMAL
- en: '![The first room](img/image00237.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, let's add a pedestal near the door, where the player has to place the
    key cube in order to open the door.
  prefs: []
  type: TYPE_NORMAL
- en: '![The first room](img/image00238.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: With that, we have now blocked out the first room. Let's move on to the next.
  prefs: []
  type: TYPE_NORMAL
- en: The second room
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the second room, we will add a bit of challenge for the player. Upon entering
    the second room, there will be a large door in the middle. The player can open
    the door by touching it on the screen. However, as soon as he/she lifts his/her
    finger or moves away from it, the door closes. To the player's right will be the
    key cube; however, it is trapped. In order for the player to unlock the key cube,
    he/she will have to go past the door, retrieve another cube, place it on a platform
    near the door, to unlock the key cube, place it on the pedestal, and advance to
    the next room.
  prefs: []
  type: TYPE_NORMAL
- en: In the first room, we had created each surface (walls, floor, and ceiling) individually.
    There is an alternate method we can use to create our second room. For that, we
    will make use of the **Hollow** property in the brush's Details panel.
  prefs: []
  type: TYPE_NORMAL
- en: 'With that said, select the **Box Brush**, and drag it on to the scene. Next,
    set its dimensions as `2048 x 1544 x 1024`, and position it right next to the
    first room (remember to position it next to the wall with the door). Position
    it as in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The second room](img/image00239.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Once positioned, with the brush selected, go to the **Details** panel and tick
    **Hollow**. As soon as you tick it, a new setting becomes available, **Wall Thickness**.
    Set its value to **128** (make sure that the subtractive brush we used in the
    previous room for the door is overlapping both walls; otherwise, you will not
    be able to see the door).
  prefs: []
  type: TYPE_NORMAL
- en: '![The second room](img/image00240.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: And that is it! We have our second room blocked out without having to spend
    loads of time placing each part of the room and making sure that they are aligned
    properly. The only things left to place are the pedestals and the hole for the
    door that leads to the third room. For the door, simply do what we did for the
    first room, create a subtractive brush of dimensions `64 x 256 x 256`, and position
    it on the other side of the room. Alternatively, duplicate the subtractive brush
    for the first room and then move its copy to the far side of the room.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, to finish things off, we will add two pedestals in this room. One pedestal
    will be near the middle of the room, where the big door will be. The player will
    have to place the first key cube on this pedestal to unlock the second key cube.
  prefs: []
  type: TYPE_NORMAL
- en: '![The second room](img/image00241.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The second pedestal goes on the other side of the room, where the player has
    to place the key cube to open the door to advance on to the third room.
  prefs: []
  type: TYPE_NORMAL
- en: '![The second room](img/image00242.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: With this, we have finished blocking out the second room. Let's now move on
    to the third, where things start to get interesting.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember to keep saving, so that you do not lose your work should the Engine
    suddenly crash or any other technical issue arise. To save, just click on *Ctrl*
    + *S*, or click on the **Save** button on the **Viewport** toolbar.
  prefs: []
  type: TYPE_NORMAL
- en: The third room
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By now, the player would have understood the basic mechanics and controls in
    the game. Let's now give him/her a bigger challenge in the third room. Upon entering
    the third room, there will be a pit between the player and the door to the final
    room. For the player to be able to cross the pit, he/she will require a bridge.
  prefs: []
  type: TYPE_NORMAL
- en: To draw the bridge, the player will have to direct an AI controlled object on
    to a switch. The object will move along a path. However, parts of the bits are
    missing. The player can fill in the gaps with the help of switches placed in the
    level. Here, the challenge lies in determining which switch to press and when
    to press it. It also relies on proper timing. After the object has reached its
    destination, the bridge will be drawn, through which the player can cross, grab
    the key cube, open the door, and advance to the next level.
  prefs: []
  type: TYPE_NORMAL
- en: There are two ways of constructing the pit; the first way is to make the room
    in two parts. The first part would be on one side of the pit, and the second on
    the other side. After making the two parts, construct the pit, and finally place
    them. However, this is a bad and time-consuming way of constructing the room and
    the pit. We would also have extra surfaces, meaning more memory usage when rendering
    the level. Also, you would have to painstakingly line all of the parts up properly
    to ensure there are no gaps.
  prefs: []
  type: TYPE_NORMAL
- en: The second way, which we will use instead, is that we will create the whole
    room and with the help of a subtractive brush, carve out the pit. This way, we
    would not have to worry about extra faces aligning parts of the room, and we can
    also easily set the dimensions of the pit by moving and/or editing the subtractive
    brush.
  prefs: []
  type: TYPE_NORMAL
- en: As always, let's begin by making the floor. Now, since we are going to carve
    out the pit, the floor will have more height than the other rooms. Select the
    **Box Brush**, and set its dimensions as `4096 x 2048 x 512`. This will be the
    main area, where the puzzle is going to be.
  prefs: []
  type: TYPE_NORMAL
- en: '![The third room](img/image00243.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Since this room is higher than the previous rooms, we are going to need some
    stairs so that the player can reach the third room. First, add a small **Box Brush**,
    set its dimensions as `512 x 1544 x 64` and place it near the door of the previous
    room.
  prefs: []
  type: TYPE_NORMAL
- en: '![The third room](img/image00244.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: To add the stairs, drag the **Linear Stair Brush** from the **Modes** panel
    onto the level. Set the width of the stairs as `1544`, and the number of steps
    to `23`. Place the stairs at the edge of the **Box** **Brush** we placed earlier;
    finally, take the floor of the third room and put it adjacent to the stairs.
  prefs: []
  type: TYPE_NORMAL
- en: '![The third room](img/image00245.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: To add the pit, we are going to need a Box subtractive brush. Another way of
    selecting a subtractive brush is by first selecting the shape of the brush, which
    in this case is the **Box Brush** and then, in the **Modes** panel, at the bottom,
    you can set the brush type to be additive or subtractive. Simply select subtractive
    and drag the brush onto the level.
  prefs: []
  type: TYPE_NORMAL
- en: We have to make sure that the pit is wide enough so that the player cannot jump
    across it and deep enough that the player cannot jump out of should he/she fall
    into it. Keeping that in mind, set the dimensions of the brush as `640 x 2304
    x 512`. Place the pit near the other end of the room.
  prefs: []
  type: TYPE_NORMAL
- en: '![The third room](img/image00246.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We now have to place the walls. We will add walls to this room in a few steps.
    First up, select a Box brush, set its dimensions as `4096 x 64 x 512`, and place
    it along the longer side of the room. Duplicate and place the second wall on the
    other side.
  prefs: []
  type: TYPE_NORMAL
- en: '![The third room](img/image00247.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Next, we need to place some walls along the stairs and corridors that lead to
    the third room. For that, set the dimensions as `1202 x 64 x 1024` and place them
    on either side of the stairs, ensuring all of them line up properly and there
    is no gap anywhere between the brushes.
  prefs: []
  type: TYPE_NORMAL
- en: '![The third room](img/image00248.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding screenshot, you may have noticed that there is a gap between
    the walls of the corridor and the walls along the longer side of the room. Let's
    fill that in with a Box brush of dimensions `64 x 188 x 512`. Place two of them,
    one on either side, to fill in the gaps.
  prefs: []
  type: TYPE_NORMAL
- en: '![The third room](img/image00249.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, the wall that we are going to place is on the far side of the room,
    along the shorter side. Set the dimensions of the **Box Brush** as `64 x 2048
    x 512`, and place the final wall with a subtractive brush for the door.
  prefs: []
  type: TYPE_NORMAL
- en: '![The third room](img/image00250.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The ceiling for the corridor will be of the dimensions `1202 x 1544 x 64`, and
    that of the room will be `4096 x 2056 x 64`.
  prefs: []
  type: TYPE_NORMAL
- en: '![The third room](img/image00251.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now that we have blocked out the room, we need to add a few more things before
    we move on to the fourth and final room. First, we are going to place some panels
    on which there are switches, which the player can press to direct the object across
    the pit. Just duplicate the pedestals from the previous rooms and place them in
    this one to create the panels. Place them near any of the longer walls, and place
    them in such a way that the player can see the other wall.
  prefs: []
  type: TYPE_NORMAL
- en: '![The third room](img/image00252.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, place a pedestal near the door. With this, we have finished off blocking
    out the third room. Now, let's block out the fourth and final room.
  prefs: []
  type: TYPE_NORMAL
- en: The fourth room
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We only have one more room to block out. In the previous three rooms, we had
    different puzzles and objectives. In the fourth room, we are going to combine
    all of the puzzles from the previous room. In this room, the objective of the
    player is similar to that in the previous room, direct an AI controlled object
    through obstacles such as doors and pits towards the other side of the room. The
    object will travel in a predefined path and keep on moving until it reaches its
    target. If it hits a door or falls down a pit, it resets from its starting position.
  prefs: []
  type: TYPE_NORMAL
- en: Since we are going to have pits, the height of the room will be similar to the
    previous ones. Also, this is going to be the biggest room. Keeping that in mind,
    we will make the floor by selecting a **Box Brush** with the dimensions `5120
    x 2048 x 512`.
  prefs: []
  type: TYPE_NORMAL
- en: '![The fourth room](img/image00253.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now that we have the floor, we are going to make some pits. Again, with the
    subtractive mode selected, create a **Box brush** of dimensions `728 x 1928 x
    512`, and place it near the door. In this room, we are going to have three pits,
    so duplicate the subtractive brush by holding down the *Alt* key, and create two
    copies and place them along the map.
  prefs: []
  type: TYPE_NORMAL
- en: '![The fourth room](img/image00254.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Next, comes the wall. For the longer side, simply duplicate the walls from the
    third room. In the **Details** panel, set the value of *X* as `5120`, and simply
    place the wall. Duplicate and place the other wall. For the shorter side, you
    can do the same—replicate and place the shorter side wall (the one with the door)
    at the other end of the room.
  prefs: []
  type: TYPE_NORMAL
- en: '![The fourth room](img/image00255.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Next, duplicate, set the *Z* value of the brush to `64`, and drag it upwards
    to form the roof.
  prefs: []
  type: TYPE_NORMAL
- en: '![The fourth room](img/image00256.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, we are going to place a few pedestals where the switches are going
    to be.
  prefs: []
  type: TYPE_NORMAL
- en: '![The fourth room](img/image00257.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: With that, we have now completed blocking out our last room!
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have blocked out our rooms, let's place some assets, create materials,
    and apply them onto our level.
  prefs: []
  type: TYPE_NORMAL
- en: Content Browser
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We briefly talked about **Content Browser** when we were discussing the Editor's
    user interface in the previous chapter. Let's talk about it a bit more. The **Content
    Browser** is where all of your assets of a project are stored and displayed. These
    assets include **Meshes**, **Textures**, **Materials**, **Skeletal Meshes**, **Blueprints**,
    **Map Files**, **Audio files**, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: '![Content Browser](img/image00258.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding screenshot, you can see different folders, all named, based
    on what is contained within each of them. It is considered a good practice, and
    also prevents confusion later on if your project has a lot of assets, that you
    organize your assets based on their type.
  prefs: []
  type: TYPE_NORMAL
- en: Migrating and importing assets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When creating a game, the main thing you need are assets, as without them your
    game would just be a blank map. You would want to import the assets you created
    for the game in your Project. For that, you need to import them first to your
    project file before you can use them. Currently, UE4 accepts the following assets:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Texture files**: These are 2D images, which can be imported as `.jpg`, `.png`,
    `.bmp`, and `.tga` files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Static Meshes/Skeletal Meshes**: Static Meshes are 3D objects created using
    a 3D software, such as Maya, Max, Blender, and so on. A Skeletal Mesh is a mesh
    that can be animated. You can import them as `.obj` files, as well as `.fbx` files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Audio files**: You can import audio files, such as music, sound effects,
    dialogues, and so on (mono), as a `.wav` file. You can also import audio files
    with more than one channel (stereo).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Script files**: You can also import script files into UE4 as `.lua` files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**IES Light Profiles**: IES Light Profiles files define the intensity of light
    in an arc. This is usually used to make the light appear more realistic. These
    too can be imported into UE4 as `.ies` files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cubemap Texture**: Cubemap Texture is imported as an `.hdr` file. These files
    are used to map out the environment, especially if your game has outdoor scenes.
    These files contain information regarding color and brightness across a range.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**True Type Fonts**: You can also import various types of fonts for your game.
    Fonts are used either in huds, UI, and such, and can be imported as a `.ttf` file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Importing assets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are two ways of importing assets that you have created for your game in
    your project file.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To demonstrate how to import assets, a simple sphere was created in Maya and
    exported as an FBX file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first way is through the **Content Browser**:'
  prefs: []
  type: TYPE_NORMAL
- en: Click on the **Import** button located at the top of the **Content Browser**.![Importing
    assets](img/image00259.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once clicked, a window will open asking you which asset to import. Simply search
    where your asset is located, highlight it, and click on **Open**.![Importing assets](img/image00260.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you click on **Open**, the **Import Options** window will open up, which
    has different import options, depending upon the type of asset you have imported.
    Once satisfied with the import settings, click on **Import** and the asset will
    be imported to your project file.![Importing assets](img/image00261.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The second method to import assets to your project is by simply dragging the
    asset you want to import and dropping it in your **Content Browser**. To do so,
    simply click and drag the asset from wherever it is stored and release the left-mouse
    button over **Content Browser**. When you release the left-mouse button, the **Import
    Options** window will open, similar to the one mentioned in the first method.
    Again, once satisfied with the settings, click on **Import** and the asset will
    get imported.
  prefs: []
  type: TYPE_NORMAL
- en: Migrating assets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes, you may need certain assets from a different project file. In such
    cases, the methods mentioned previously regarding importing assets will not work,
    since the contents of a project are saved on your system as either a `.uasset`
    file or `.umap` file. Therefore, UE4 will not be able to import them. You, therefore,
    will have to perform the **Migrate Asset** action.
  prefs: []
  type: TYPE_NORMAL
- en: When we create our project, we select **No Starter Content** since we do not
    require all of them. It would eat up unnecessary space. We do, however, require
    a few assets, particularly wall and floor materials. To demonstrate this, a new
    project with all of the starter content has been set up.
  prefs: []
  type: TYPE_NORMAL
- en: '![Migrating assets](img/image00262.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here is a project with all of the starter content. What we need are two materials,
    namely **M_Basic_Floor** and **M_Basic_Wall**. Migrate these two materials and
    follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Highlight both **M_Basic_Floor** and **M_Basic_Wall** and right-click to open
    a menu. In the menu, hover the cursor over **Asset Actions**, and click on **Migrate**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After you have clicked on it, a window will open up telling you that the following
    asset(s) will be migrated to another project.![Migrating assets](img/image00263.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you click on **OK**, another window will open up asking you where you want
    to move the asset. You would want to store them in your project's `Content` folder.
    When this opens up, find your project folder (which, if you recall, is in `My
    Documents`), and store it in the **Content** subfolder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After clicking on it, you will get a prompt saying that **the asset has been
    successfully migrated**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you now go back to the Blockmania project, you will see **M_Basic_Floor**
    and **M_Basic_Wall** displayed in **Content Browser** in the **Materials** subfolder.
  prefs: []
  type: TYPE_NORMAL
- en: '![Migrating assets](img/image00264.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Placing actors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once you have all of your assets in your **Content Browser**, the next step
    is to place them in your game. We are going to use the cube mesh in the **Content
    Browser** to create objects in our game, such as the key cube, the AI-controlled
    object, the doors, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: First, let's make the door that opens when you place the key cube on the pedestal.
    Simply drag the **TemplateCube_Rounded** static mesh from **Content Browser**
    and place it in the hole where the door is supposed to go. Set its dimensions
    using the scale tool, so that it perfectly fits.
  prefs: []
  type: TYPE_NORMAL
- en: '![Placing actors](img/image00265.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: To make things easier and convenient, you can change the name of the cube to
    `Door01` in the **Details** panel. For the rest of the door, since the dimensions
    of the hole were the same, you can simply duplicate this actor and place the copies.
    Finally, since these will be moving and will not be stationary in the game, set
    its mobility type to **Movable**.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Use different perspectives to set the dimensions and to align the door with
    the hole.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's place the big doors that the player will encounter in the middle
    of the rooms. Again, take the **TemplateCube_Rounded** actor from the **Content
    Browser** and place it in the second room. Set its dimensions so that it blocks
    the character from moving to the other side of the room. Name this `Room_Door01`.
    Similarly, duplicate and place it in the fourth room, where the ledges are. However,
    you will have to modify the dimensions of the doors that go in the fourth room,
    since the dimensions of the fourth room are a little different from the second
    room.
  prefs: []
  type: TYPE_NORMAL
- en: '![Placing actors](img/image00266.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we have to place the key cubes, which the player has to collect and place
    in order to progress to the next room, or to unlock other key cubes. We will,
    again, use **TemplateCube_Rounded**. Set its scale to `0.15` along all three coordinates
    and place them in our level. Here is a quick rundown of where the key cubes will
    be placed in the four rooms:'
  prefs: []
  type: TYPE_NORMAL
- en: '**First room**: In the first room, we will only require one key cube. You can
    place it anywhere near the middle of the room.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Second room**: In the second room, we will require two key cubes. Place the
    first cube on one side of the big door and place the second cube on the other
    side. The first cube will be the locked one and the second cube is what the player
    will have to place on the pedestal to unlock it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Third room**: In the third room, we will require only one key cube, which
    the AI object will unlock upon hitting the target. So, place it on the other side
    of the pit near the door that leads to the fourth room.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fourth room**: In the fourth room, place the key cube on the other side of
    the room. This will also be unlocked once the AI object hits the target.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have placed all of the essential assets in our game. Let's add some decorative
    cubes in our level. Since decorative assets are going to remain stationary, and
    not move in the game, you should set their mobility to **Static**. Just place
    cubes around the map, in different patterns and arrange them as you see fit.
  prefs: []
  type: TYPE_NORMAL
- en: '![Placing actors](img/image00267.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Materials
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In UE4, before you can apply textures to an object, you first have to create
    materials. A material is how an object will be rendered in a game, it is a collection
    of shaders containing many properties that can be applied to objects and rendered
    in the game. In more technical terms, when light from a light sources fall on
    a surface or object, the material is what determines how the light will interact
    with said surface or object (the color, texture, how rough or smooth the surface
    is, how metallic it is, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: UE4 uses *Physically-based Shading*. In earlier versions of Unreal Engine, the
    material had some arbitrary properties, such as DiffusePower, Custom Lighting
    Diffuse, and so on. In UE4, the materials have more relatable properties, such
    as base color, metallic, roughness, and so on, making the process easier to understand.
  prefs: []
  type: TYPE_NORMAL
- en: A material is created in what is known as a Material Editor. So, before we start
    creating our own materials, let's first talk about it and its user interface.
  prefs: []
  type: TYPE_NORMAL
- en: The Material Editor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Material Editor is a simple, yet extremely powerful tool that you can use
    to create materials for your objects. For example, you can apply a texture file
    to the diffuse channel of your material and then use it on your assets. For our
    game, we are going to create our own materials from scratch. To access the Material
    Editor, you first need to create a new material, or double-click on an existing
    material. To create a new material, click on the **Add New** button located at
    the top-left corner of **Content Browser** and select **Material**, which will
    be under the **Create Basic Asset** section. Once done, you will see a new material
    created. Double-click on it to open the Material Editor. Once opened, you should
    see this window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Material Editor](img/image00268.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Let's first look at the editor itself and its user interface. As with the Editor,
    we will divide the Material Editor user interface into sections and go through
    them individually.
  prefs: []
  type: TYPE_NORMAL
- en: '![The Material Editor](img/image00269.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The tab and menu bar
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At the top, we have the tab and menu bar. The tab bar is similar to that of
    the Editor.
  prefs: []
  type: TYPE_NORMAL
- en: '![The tab and menu bar](img/image00270.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Below the tab bar, we have the menu bar. As with the menu bar in the Editor,
    it offers all of the general commands and actions. They are described as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**File**: Clicking on this will open up the **File** menu. From here, you can
    perform actions such as saving the material you have created, open an asset from
    the **Content Browser**, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Edit**: This will open up the **Edit** menu. Here, you can undo or redo any
    actions you might have performed. You can also access the Editor and project settings
    from here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Asset**: From the **Asset** menu, you can find the material you are creating
    in the **Content Browser** and open the current material''s reference viewer window.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Window**: In this menu, you can choose what panel you want in your Material
    Editor window, search for a particular node in the **Graph** panel, access the
    plugins window, and more.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Help**: Finally, if you want to learn more about the Material Editor or need
    to find a solution to a problem, you can access the wiki page and the official
    Epic documentation from here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The toolbar
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once again making the comparison with the toolbar in the Editor, the toolbar
    here displays all of the most commonly used actions that you may perform while
    making your material.
  prefs: []
  type: TYPE_NORMAL
- en: '![The toolbar](img/image00271.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '**Save**: Starting from the left, represented by a floppy disk, is the **Save**
    button. This is to save any modifications you have made to the material.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Find in CB**: **Find in CB** (or Content Browser), depicted by a magnifying
    glass, locates and highlights the current material you have opened in the Material
    Editor in the **Content Browser**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Apply**: Next, we have the **Apply** button. If you have already applied
    the current material to an object in the game, once you have made any modification
    to it, clicking on **Apply** will update the material in the current scene.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Search**: Need to find a node or connection? You can do so by clicking on
    **Search** and typing in whatever you wish to find. When you click on it, the
    **Search** panel opens up at the bottom of the material editor. Simply type in
    whatever it is you want to find, and it will give you the results in the panel.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Home**: The **Home** button refocuses the Graph panel to the material input
    description (the node that you first see in the Material Editor, with all those
    inputs). This comes in handy when you are creating a very complex material, since
    you will have a lot of nodes connected to each other and might lose sight of the
    material description.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Clean Up**: The **Clean Up** button deletes any nodes that are not connected
    to the material inputs. This is very handy since even unconnected nodes will make
    the material unnecessarily heavy in terms of memory usage.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Connectors**: This is, by default, turned on. When turned off, any unused
    input or output pins (pins that are not connected to anything), are hidden. This
    is a good way of keeping your workspace clean and organized as it removes clutter
    from view.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Live Preview**: This, too, is by default turned on. When turned on, any modifications
    you make to the material are updated in real time in the **Viewport** panel.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Live Nodes**: When enabled, it updates the material in each node in real
    time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Live Update**: When you toggle this on, it compiles the shaders and all of
    the nodes and expressions in real time, and it does so every time you change,
    add, remove a node or change a value of a parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stats**: When turned on, you can see the stats of the material you have created
    at the bottom of the Material Editor. This can give you an idea of just how heavy
    your material is.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mobile Stats**: This is similar to **Stats**, but gives you the material
    stats and any errors for mobile devices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Palette panel
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Palette panel contains all of the nodes that can be used in the Material
    Editor.
  prefs: []
  type: TYPE_NORMAL
- en: '![The Palette panel](img/image00272.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: All of the functions, expressions, and so on are categorically listed here.
    You have the category on the top and you can filter what type of nodes you want
    displayed using it.
  prefs: []
  type: TYPE_NORMAL
- en: If you wish to find a specific node, you can search for it in the **Search**
    bar, located below the **Category** bar.
  prefs: []
  type: TYPE_NORMAL
- en: The Stats panel
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As mentioned previously, the **Stats** panel displays all of the stats regarding
    the material you have created.
  prefs: []
  type: TYPE_NORMAL
- en: '![The Stats panel](img/image00273.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: If you have turned on the **Mobile Stats** in the toolbar, you will also see
    the stats for mobile devices displayed here. This basically shows you how many
    instructions and shaders are in your material. This will give you an idea as to
    how big and heavy your material is.
  prefs: []
  type: TYPE_NORMAL
- en: The Details panel
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **Details** panels displays the general properties of the material, such
    as **Material Domain**, which means what type of material you want to create.
  prefs: []
  type: TYPE_NORMAL
- en: '![The Details panel](img/image00274.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Normal materials, such as the ones you apply to actors, are **Surface** materials.
    If you want your material to be a **Decal** (which we will discuss in the next
    chapter), you can switch to **Decal**, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: You can also set properties of any node that you have selected, in this panel.
  prefs: []
  type: TYPE_NORMAL
- en: The Viewport panel
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **Viewport** panel is where you can preview the material you are creating.
    If the **Live Preview** option is enabled, any modifications you make will be
    updated in real time and previewed here.
  prefs: []
  type: TYPE_NORMAL
- en: '![The Viewport panel](img/image00275.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: By default, the shape primitive is a sphere. You can switch to either a cylinder,
    a plane, a cube, or a specific mesh from the Material Editor using the buttons
    at the top of the Viewport Panel. You can also toggle the grid on/off, and also
    toggle the Live Preview on/off from here.
  prefs: []
  type: TYPE_NORMAL
- en: The Graph panel
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The last element of the Material Editor's user interface is the Graph panel.
    This is where you create your material.
  prefs: []
  type: TYPE_NORMAL
- en: '![The Graph panel](img/image00276.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Before we continue, there are a few terms and expressions you should be aware
    of since we will be using them quite a lot in this book. Firstly, we have something
    called a node. A node is anything that you connect to either make your material
    or script in blueprint. It could be a variable, an expression, and so on. In the
    preceding screenshot, the node here would be the long panel you see.
  prefs: []
  type: TYPE_NORMAL
- en: Now, every node has either an input, an output, or both. Input is any value
    or expression a node takes, and is located on the left side of the node as white
    pins. Coming back to the screenshot above, the node accepts quite a number of
    inputs, each input corresponding to a different property of the material.
  prefs: []
  type: TYPE_NORMAL
- en: The output pin is what the node returns (a value, expression, and so on), and
    it is also represented by white circular pins. They are located on the right side
    of the node. When connected to two or more nodes, you connect the output pin of
    the first node to the input pin of the second node, and so on, to create a chain
    of nodes.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding screenshot, you can see a long node with a lot of inputs. This
    is the material input. Each input has a different effect on the material. You
    might also have noticed that some of the inputs are white, while the rest are
    darkened. The darkened nodes are the ones that are currently disabled and cannot
    be used. Which input is enabled and which is disabled depends upon the material's
    **Blend Mode**, which can be found and changed in the **Details** panel. For example,
    look at the screenshot, the **Opacity** node is currently disabled. This is because
    the **Blend Mode** set for the material is **Opaque**, so naturally, you cannot
    set the opacity of the material. To enable it, you will have to change the **Blend
    Mode** to **Translucent**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go over the most commonly used material inputs:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Base Color**: This has to do with the color of the material. What the underlying
    color will be.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Metallic**: This deals with how much metallic luster you want in your material.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Specular**: Should you want to make your material smooth and shiny, this
    is the node for you. This deals with how much light is reflected off the material.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Roughness**: The opposite of **Specular**, if you want your material to be
    unsmooth or rugged, this input is what you need.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Emissive Color**: If you want your asset to glow, you can set it here, in
    the Emissive Color input.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Opacity**: This deals with how translucent you want your object to be.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are other inputs as well, but these are the main inputs that you should
    know for now.
  prefs: []
  type: TYPE_NORMAL
- en: Applying materials
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two ways of applying materials to objects. The first way to apply
    materials is simple and straightforward. Let''s use the first method to apply
    the floor material. We will apply **M_Basic_Floor**. To apply the material:'
  prefs: []
  type: TYPE_NORMAL
- en: Select `M_Basic_Floor` from the Content Browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag it on to the floor surface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Release the left-mouse button, and the material will be applied to the floor.![Applying
    materials](img/image00277.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will use the second method of applying materials for the walls. We will
    apply `M_Basic_Wall` to our walls. To do so, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Select any of the wall surfaces.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Details** panel, under the **Surface Materials** section, you will
    see something called **Element 0**. Next to it, there will be a menu button with
    **None** written on it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the menu. You will see all of the materials in the Content Browser listed
    out. Simply select **M_Basic_Wall** from the list, and the material will be applied
    to the wall.![Applying materials](img/image00278.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using any of the two methods, apply the materials to all of the walls and floors
    in the game.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the materials
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have covered the Material Editor's user interface and seen how to
    apply them onto objects, let's go on and create the materials for our level.
  prefs: []
  type: TYPE_NORMAL
- en: Pedestals
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First, we are going to create a material for the pedestals where the player
    has to place the cubes. We are going to create a fairly simple material. The pedestal
    we will create will be yellow in color and will be a bit shiny. First, create
    a new material in **Content Browser** and name it `Pedestal_Material1`. Then double-click
    on it to open the Material Editor.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we are going to do is add something to the **Base Color** input.
    What we need to create is something called a **Constant3Vector** node. To create
    it, simply drag the node from the **Palette** panel and place it in the Graph
    panel. Another much quicker way of creating a **Constant3Vector** node is by holding
    down *3* and left-clicking anywhere in the Graph panel. The node will be formed
    wherever you click. Once formed, connect it to the **Base Color** input. You can
    set the color to yellow. To do this, simply select the **Constant3Vector** node
    and in the **Details** panel, you will see a property called **Constant**, with
    a black bar next to it. Click on the black bar, which will open the **ColorPicker**
    window. Set the color to yellow and click on **OK**. Now connect it to the Base
    Color input. You will see the Viewport panel updated with the change you have
    made.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the base color, we are going to add the shine. For this, we
    are going to create a **Constant** node. Again, you can either drag it from the
    palette panel or hold *1* and click anywhere on the Graph panel. In the Details
    panel, set its value to `0.5`, then connect it to the **Specular** input. Your
    Graph editor will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Pedestals](img/image00279.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now that you have created the material, click on **Save**, then apply it to
    the pedestals.
  prefs: []
  type: TYPE_NORMAL
- en: For the pedestals where the buttons will be, create a copy of **Pedestal_Material1**
    by right-clicking on it and selecting **Duplicate**, rename it to **Pedestal_Material2**,
    and in the material editor, simply change the base color to blue, save it, and
    apply it.
  prefs: []
  type: TYPE_NORMAL
- en: '![Pedestals](img/image00280.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Doors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For the doors, we are going to do pretty much the same thing we did when we
    created the materials for the pedestals. The only difference here is that we will
    make the doors a bit see-through, and make the material glassy. With that said,
    create a material for the door, and name it **Door_Material**.
  prefs: []
  type: TYPE_NORMAL
- en: In the Material Editor, the first thing you need to do is set the material's
    blend mode to **Translucent**. After that, create a **Constant3Vector**, pick
    a light blue color, and connect it to the **Base Color** input.
  prefs: []
  type: TYPE_NORMAL
- en: Now, create three **Constant** nodes. Set the value of the first node as `1`,
    and connect it to the **Specular** input. Set the value of the **Second** node
    as `0.5`, and connect it to the **Opacity** input. Our glass material is now translucent.
    However, there is still something left, a very fundamental property of glass—refraction!
    The refraction input is located at the bottom of the input panel. Set the value
    of the third **Constant** node to `0.35`, and connect it to the **Refraction**
    input.
  prefs: []
  type: TYPE_NORMAL
- en: '![Doors](img/image00281.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We have created a basic glass material for our door. Save this and apply it
    to the doors.
  prefs: []
  type: TYPE_NORMAL
- en: '![Doors](img/image00282.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Key Cubes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's make the set of materials a bit interesting. We are going to make it red.
    Also, we are going to make it flash so as to grab the player's attention. Create
    a material and name it **KeyCube_Material**.
  prefs: []
  type: TYPE_NORMAL
- en: First, create a **Constant3Vector** node, set the color to red, and connect
    it to the **Base Color** input. This will be our base color. For the glowing effect,
    we are going to use a **Linear Interpolate** function. A **Linear Interpolate**
    takes in three inputs. It blends the first two inputs (**A** and **B**) and the
    third input is used as a mask (Alpha). For input **A**, create a copy of the **Constant3Vector**
    node you created for the base color and connect it. For input **B**, create another
    **Constant3Vector** node, set the color to a lighter shade of red and connect
    it.
  prefs: []
  type: TYPE_NORMAL
- en: We have our inputs. We now need to create something for the **Alpha** input.
    Since the key cube will be flashing in regular intervals, we can use the **Sine**
    or **Cosine** function. You can find any of the two in the palette panel. Place
    it in the Graph panel, and connect it to the **Alpha** input. Now, for the **Sine**
    or **Cosine** function to actually work, it needs some input data. We are going
    to create a **Time input data** node. Simply type in `Time` in the Palette panel,
    place the node in the Graph panel, and connect it to the **Sine** or **Cosine**
    node. Finally, after doing all that, connect the **Linear Interpolate** to the
    **Emissive** input.
  prefs: []
  type: TYPE_NORMAL
- en: '![Key Cubes](img/image00283.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: And there you have it. We now have a flashing material for our main key cube.
    Apply it to all the key cubes.
  prefs: []
  type: TYPE_NORMAL
- en: '![Key Cubes](img/image00284.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Decorative assets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For our decorative assets, we are going to create a material that changes colors
    periodically. First up, create a material and name it **DecorativeAsset_Material**.
    For the changing effect, we are going to use a **Rotator** node. If you have a
    proper texture, and wish to have it rotate, you can do so using this. It takes
    the *UV* coordinates of the **Textures** and a **Time** function and uses that
    to rotate the texture. We are going to use it to have our material change color.
    As always, create a **Constant3Vector**, and set its color to a pale blue.
  prefs: []
  type: TYPE_NORMAL
- en: Now, instead of connecting it directly to the base color input, we are going
    to connect it to the **Rotator** node. Find the **Rotator** node in the palette
    panel, and place it in the graph panel. The **Rotator** node takes in two inputs,
    **Coordinate** and **Time**. Connect the **Constant3Vector** to the **Coordinate**
    input. Create a **Sine** function, connect a time input data to it, and connect
    it to the **Time** input. Finally, connect the **Rotator** node to the **Base
    Color** input. That is all we need to do. You will now notice the material changing
    color periodically. You can set the speed at which it changes color by changing
    the **Speed** setting in the **Rotator** node's Details panel.
  prefs: []
  type: TYPE_NORMAL
- en: '![Decorative assets](img/image00285.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Apply this material to all of the decorative assets in the game. And with that,
    we have textured our environment.
  prefs: []
  type: TYPE_NORMAL
- en: '![Decorative assets](img/image00286.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: If you test out your level, you would notice that you cannot see anything. This
    is because our level does not have any lights, therefore nothing is rendered and
    all you see is a black screen. Let's now move on to lighting.
  prefs: []
  type: TYPE_NORMAL
- en: Lighting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Lighting is a very important element of any game, as without it you cannot
    see the world around you. UE4 offers four types of lighting, namely: Directional
    light, Point light, Spot light, and Sky light. Let''s go over each of them individually
    and discuss some of their properties that you can set in the Details panel:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Directional light**: Directional light is the ideal type of light when you
    have an outdoor scene and want to simulate light coming from the sun, since directional
    light simulates light coming from a source infinitely far away. The shadows formed
    by directional lights are parallel.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can set things such as the intensity, color, whether it affects the world,
    the intensity of the indirect lights, and more in the Details panel.
  prefs: []
  type: TYPE_NORMAL
- en: '![Lighting](img/image00287.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding screenshot shows directional light and how it works in the level.
    Its icon is depicted by a sun with two parallel arrows coming out of it. The other
    single arrow shows the direction from where the light is coming. You can set the
    direction by using the rotation tool.
  prefs: []
  type: TYPE_NORMAL
- en: '**Point light**: A point simulates light coming from a single source of light,
    emitting light uniformly in all directions, much like a bulb. It is the light
    source we will be using most in the game. In an indoor scene, this will be your
    primary actor for lighting.![Lighting](img/image00288.jpeg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, the point light actor is represented by a light bulb. The sphere
    you see around it is the *Attenuation Radius*. It is represented by a sphere wireframe,
    and shows the volume where the light source has direct influence. You can set
    things such as the intensity, the color, the attenuation radius, whether the light
    source affects the world or not, the intensity of the indirect lighting, and so
    on. If you feel like you do not want a single point light source, you can set
    a radius or length of the light source, depending on your requirement.
  prefs: []
  type: TYPE_NORMAL
- en: '**Spot light**: Spot lights are similar as point light, in that, they both
    originate from a single source. The difference between the two, however, is that
    while a point light emits lights uniformly in all directions, spot light emits
    lights in one direction, in a cone.![Lighting](img/image00289.jpeg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are two cones that you may have noticed. The inner cone is where the light
    is the brightest. As you move radially outwards, towards the outer cone, the light
    becomes less bright and fall-off takes place. You can set the radius of these
    two cones, along with the intensity, color, length, and radius of the source,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: '**Sky light**: Lastly, we have the sky light. Sky light simulates light being
    reflected off the atmosphere and distant objects.![Lighting](img/image00290.jpeg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sky light is quite subtle in terms of effects. With that in mind, in the preceding
    screenshot, the left is a scene with sky light and to the right, without Sky light.
    You can see the effect of Sky light when the two are juxtaposed.
  prefs: []
  type: TYPE_NORMAL
- en: Sky light settings are a bit different than the rest of the types of lights.
    For one, you can set something called the **Sky Distance Threshold**. This is
    the distance from the Sky light actor at which any actor will be treated as part
    of the sky. You also have the **Lower Hemisphere is Black** option, which, when
    toggled, will ignore the light coming from the lower hemisphere of the scene.
    You can also use your own custom cube map to get your own type of Sky lights.
    Apart from that, you can set the color of the light, the intensity, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Mobility
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All the types of lights have three types of mobility. There are certain settings
    of light characters that you can modify while the game is running, should you
    require to. The mobility section allows you to do just that.
  prefs: []
  type: TYPE_NORMAL
- en: The mobility options are located in the **Transform** section of the light actor's
    Details panel.
  prefs: []
  type: TYPE_NORMAL
- en: '![Mobility](img/image00291.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'There are a total of three types to choose from:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Static**: When you set the light as **Static**, the properties set while
    making the game remain constant and cannot be modified with triggers or during
    gameplay. Once the lighting has been built, the light information and the shadows
    baked by that light remain static and cannot be changed. For lights that do no
    move or toggle on/off during the game, this is the most apt mobility type, since
    it requires the least amount of memory to render.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stationary**: When a light actor''s mobility is set to **Stationary**, the
    only properties that can be altered with triggers or during gameplay are things
    like intensity, color, and so on. The light, however, cannot move or translate
    under this setting. This requires more memory than static lights, and can be used
    for things like flickering lights.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Movable**: Under this setting, the light actor is totally dynamic and along
    with altering things like intensity and color, it can also move, rotate, and scale
    during gameplay. Keep in mind, however, that this type of light takes the most
    memory to render, since every time its property is altered within the game, it
    has to recalculate the shadows and lighting information in real time. Therefore,
    unless it is really required in your game, avoid using movable lights when developing
    games on mobile devices. It is better if you use static lights, for best performance.
    When you switch the mobility to **Movable**, the light actor''s icon in the game
    changes. You will see four arrows underneath the light actor.![Mobility](img/image00292.jpeg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the left, is a light actor with the mobility set to **Movable**, and to the
    right is a light actor with the mobility set to either **Static** or **Stationary**.
  prefs: []
  type: TYPE_NORMAL
- en: Lighting up the environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you are familiar with light actors, their types, and mobility types,
    let's place some lights onto our level.
  prefs: []
  type: TYPE_NORMAL
- en: For now, we are just going to place Static point lights in our level. We will
    cover stationary and movable lights later on. With that said, place a point light
    in the level. Set `intensity` to `20000`, and `attenuationradius` to `5000`. Also,
    set the mobility to `Static`. Create multiple copies of the point light and place
    them, keeping in mind that there should be sufficient lighting for the player.
    You should also switch to *Lit view mode*, so that you can figure out if there
    is enough lighting in the rooms. Finally, build the level. You can set the quality
    of the lighting build. But remember, the higher the quality of light you want,
    the longer it will take to build, but the lighting will be closer to reflecting
    production quality at these higher settings.
  prefs: []
  type: TYPE_NORMAL
- en: '![Lighting up the environment](img/image00293.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: You can now see all of the materials and textures properly rendered.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we talked about projects, what they are, what types of projects
    UE4 offers, and how to create and load projects. Following that, we covered what
    BSP brushes are, the default types of BSP brushes and how we can edit them to
    create our own geometry. We returned and took another look at Content Browser,
    how to import and migrate assets, and how to place actors from Content Browser
    onto the level. We covered the concept of materials, the material editor, its
    user interface, and how to create materials. Finally, we ended the chapter by
    talking about lighting, the different types of lights, and some of the important
    settings.
  prefs: []
  type: TYPE_NORMAL
- en: Using this knowledge, we created our environment, hence taking our first steps
    towards building our game. In the next chapter, we will discuss the concept of
    volumes, what they are, the different types of volumes, and how we can apply them
    in our game. So, without further ado, let us move on to the next chapter.
  prefs: []
  type: TYPE_NORMAL
