- en: The Landscape of Testing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the beginning of this book, we set out the primary tenets of clean code.
    Among these was reliability. There truly is no greater way to confirm reliability
    than to expose your code base to continued and multivariate usage. This means
    having real users sit in front of your software and use it, for real. Only via
    this type of exposure can we understand whether our code truly fulfills its purpose.
    However, it is usually unreasonable, and possibly even dangerous, to conduct such
    real-life tests constantly. If code is changed, it is possible for a piece of
    functionality that a user relies on to falter or regress. To prevent such cases,
    and to generally confirm that our expectations are met, we write tests. Without
    a good suite of tests, we are passively and arrogantly closing our eyes and hoping
    that nothing goes wrong.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll be covering the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: What is a test?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Types of testing
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Test-Driven Development** (**TDD**)'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is a test?
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A software test is an automated procedure that makes assertions about a piece
    of code and then reports the success of those assertions back to you. A test may
    make assertions about anything from an individual function to the behavior of
    an entire feature.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: 'Tests, much like the rest of our code, deal in layers of abstraction and granularity.
    If we were to test a car abstractly, we may simply seek to assert the following
    attributes:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: It has four wheels
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has a steering wheel
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It drives
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has a working horn
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Obviously, this is not a very useful set of assertions for car engineers, as
    these attributes are either incredibly obvious or insufficiently described. The
    assertion It drives is important, but without extra detail, all it expresses is
    a generic business-oriented objective. It's similar to a project manager asking
    for a software engineer to ensure that a user-login portal, for example, can allow
    users to log in successfully. It is the engineer's job to not only implement the
    user-login portal but to derive working tests that successfully investigate the
    truth of the assertion users can log in successfully. And it is not always easy
    to derive good tests from generic statements.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: 'To correctly engineer a test, we must take the generic and abstract requirements
    and distill them to their granular and unabstracted details. In the case of us
    asserting that our car *has a working horn*, for example, we can distill it like
    so:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: When the driver raises at least one hand and directs the hand to depress by
    2 cm the center of the steering wheel for a period of 1 second, a loud sound of
    fixed frequency at 400 Hz will be emitted by the car at approximately 107 decibels
    for 1 second.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: When we start to add crucial detail to our assertions, they become useful to
    us. We can use them as both guides of implementation and confirmations of functionality.
    Even with this added detail though, our statement is only an assertion or a *requirement*.
    Such requirements are a useful step in the design of software. In fact, we should
    be very reluctant to even begin implementing software until we have such levels
    of specificity.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: 'If a client were to ask you to implement a payment form, for example, it would
    be wise to gather the exact requirements: what types of payments shall it accept?
    What other customer information requires collection? What regulations or constraints
    are we beholden to in our storage of this data? These expanded requirements then
    become the yardstick via which we, and the client, will measure completeness.
    It follows naturally that we can then implement these requirements as individual
    tests to confirm their existence in the software.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: 'A good testing methodology will involve tests for all distinct parts of a code
    base and will provide the following benefits:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '**Prove fulfillment**: Tests allow us to prove to ourselves and our stakeholders
    that expectations and requirements are fulfilled.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Have** **confidence**: Tests allow us and our colleagues to have confidence
    in our code base—both that it works correctly and that it can accommodate changes
    without faults arising unbeknownst to us.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Share** **knowledge**: Tests allow us to share vital knowledge about how
    parts of our code operate together. In a sense, they are a form of documentation.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are many second-order effects of a good testing methodology as well. The
    increased confidence in the code base by your colleagues will mean you can be
    more productive and make more significant changes more quickly, cutting costs
    and pain in the long run. The sharing of knowledge can enable both your colleagues
    and your users to perform their actions quicker, with more understanding and less
    overhead in time and expense. The ability to prove fulfillment enables teams and
    individuals to better communicate the value of their work to stakeholders, managers,
    and users.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've discussed the obvious benefits of tests, we can discuss how we
    should go about authoring them. At the core of every test is a set of assertions,
    so we'll now explore what we mean by assertion and how we can use assertions to
    encode our expectations.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: The simple assertion
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many tools, terms, and paradigms of testing. The existence of so much
    complexity can seem intimidating but it's important to remember that, at the core,
    testing is really just about making assertions about how something works.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: 'Assertions can be made programmatically by expressing either `SUCCESS` or `FAILURE` depending
    on a specific outcome, as in the following example:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here, we will receive a our `FAILURE!` log if our `sum` function is not giving
    the expected output. We can abstract this pattern of success and failure by implementing
    an `assert` function, like so:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This can then be used to make a series of assertions with added descriptions:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This is the fundamental core of any testing framework or library. They all
    have a mechanism for making assertions and reporting both the success and failure
    of those assertions. It is also normal for testing libraries to provide a mechanism
    to wrap up or contain related assertions and, together, call them a *test* or
    *test case*. We can do something similar by providing a test function that allows
    you to pass a description and a function (to contain assertions):'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We can then use it like so:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The produced testing log from running this would be as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: From a technical perspective, the pure action of authoring assertions and simple
    tests is not too challenging. Writing a test for a singular function is rarely
    hard. However, to write entire test suites and to thoroughly test all parts of
    a code base, we must utilize several more complicated testing mechanisms and methodologies
    to help us out.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Many moving parts
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To recall the car analogy, let's imagine that we have a car sitting in front
    of us, and we wish to test its horn. The horn is not a standalone piece of machinery.
    It is embedded within the car and dependent on a power source separate to itself.
    In fact, what we may discover is that we must first start the car up via the ignition
    before the horn will work. And the success of an ignition is itself dependent
    upon several other components, including a working ignition switch, fuel in the
    tank, a working fuel filter, and a non-drained battery. The functionality of the
    horn is therefore dependent upon a series of many moving parts. So, our test of
    the horn becomes not only a test of the horn itself but effectively a test of
    almost the entire car! This is not ideal.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: To get around this issue, we could hook the horn up to a separate power supply
    just for testing purposes. By doing this, we are isolating the horn, enabling
    the test to only reflect the functionality of the horn itself. In the testing
    world, this **stand-in** power supply we're using might be called a **stub** or
    a **mock**.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: In the software world, both *stubs* and *mocks* are a type of stand-in abstraction
    for the *real* abstraction that provides appropriate outputs without carrying
    out the real work of the replaced abstraction. An example would be a `makeCreditCardPayment`
    stub, which returns `SUCCESS` without creating a real-world payment. This would
    be used in the context of testing e-commerce functionality, possibly.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: 'Our approach of isolating the power supply of the horn is unfortunately flawed.
    Even if our test is successful—and the horn works—we haven''t guaranteed that
    the horn will still work when hooked up to the real power supply within the car.
    The isolated test of the horn is still, arguably, useful because it tells us about
    any failures within the horn''s specific circuitry and mechanism, but it is not
    sufficient on its own. We need to test how the horn will work when it is embedded
    in the real-life situation of having to depend on other components. In software,
    we call such real-life tests **integration tests** or **end-to-end tests**, while
    the isolated tests are typically called **unit tests**. An effective testing methodology
    will always include both types:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/7daaa2d6-8926-4891-9f93-731f9ee697fd.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
- en: There is a risk when isolating individuals parts for testing, of creating an
    unrealistic scenario in which you end up not actually testing the true functionality
    of a code base, but instead testing the efficacy of your mocks. Here, in our car
    analogy, isolating the horn by supplying it with a *mock* power supply enables
    us to purely test the horn's circuitry and sound-making mechanism and gives us
    a clear path to debugging issues if the test fails. But we need to complement
    this test with several integration tests so that we can be confident that the
    entire system works correctly. Even if we have a thousand unit tests for all parts
    of a system, there is no guarantee of a working system without testing the integration
    of all of these parts.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Types of testing
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To ensure a thoroughly tested code base, we must engage in different types of
    testing. As touched on already, the *unit* test enables us to test isolated parts,
    while the various combinations of parts can be tested via either **integration**,
    **functional**, or **E2E** tests. It's useful first to understand what we mean
    when we talk about a *part* or a *unit*.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: 'When we talk about a unit of code, there is admittedly a fuzziness to the concept.
    Typically, it will be a piece of code that has a singular responsibility within
    a system. When a user wishes to perform an action via our software, they will,
    in fact, be activating a series of parts of our code, all working together to
    give the user the output they desire. Consider an app in which users can create
    and share images. A typical user experience (a flow or journey) may involve a
    few distinct steps that all involve different parts of the code base. Every action
    the *User* performs, often without them knowing, will encapsulate a series of
    code actions:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '(User) Create a new image by uploading a photo stored on the desktop:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: (Code) Upload the photo via `<form>`
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: (Code) Save photo to a CDN
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: (Code) Show the bitmap within `<canvas>` so that filters can be applied
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '(User) Apply a filter to the image:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: (Code) Apply the filter via `<canvas>` pixel manipulation
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: (Code) Update image stored on the CDN
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: (Code) Re-download saved image
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '(User) Share the image with friends:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: (Code) Find the user's *friends* in the database
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: (Code) Add the image to each friend's feed
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: (Code) Send the *push notification* to all friends
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Together, all of these steps, combined with all other steps a user could potentially
    take, can be considered a system. And a fully-tested system might involve **unit**
    tests for each individual step, **integration** tests for each pair of steps,
    and **functional** or **End-to-End** (**E2E**) tests for every combination of
    steps that together form a *user flow* or *user journey*. We can visualize the
    types of tests that may need to exist as part of a system as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/132ddbe3-92d9-4e98-b072-55279e538f7d.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
- en: Here, we can see one **Start** point and two **End** points, indicating two
    distinct *user journeys*. Each dot can be thought of as a single area of responsibility
    or *unit* that is activated as part of these journeys. As you can see, a unit
    test is only concerned with a single area of responsibility. The integration test
    is concerned with two (or more) neighboring areas that integrate. And an E2E or
    functional test is concerned with all of the areas involved in a singular user
    journey. In the former example of our image-sharing app, we can imagine that we
    may have specific unit tests for actions such as uploading a photo to the CDN or
    sending push notifications, an integration test that tests the integration of
    the friends database, and an E2E test that tests the entire flow from creating
    to sharing a new image. Each of these testing methodologies would be vital in
    ensuring a truly well-tested system, and each has its own unique benefits as well
    as pitfalls and challenges to overcome.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we described with our car analogy, a unit test is a test that deals with
    an isolated *unit* of code. This will usually be either a singular function or
    module that will make one or more simple assertions about the operation of the
    code.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some examples of singular unit test scenarios:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: You have a `Button` component that should contain the value `Submit My Data` and
    should have a class of `btn_success`. You can assert these characteristics via
    a simple unit test that checks the attributes of the produced DOM element.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You have a task-scheduling utility that will perform a given action at the requested
    time. You can assert that it does so by giving it a task to perform at a specific
    time and then checking for the successful execution of that task.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You have a REST API endpoint of `/todo/list/item/{ID}` that retrieves a specific
    item from a database. You can assert that the route works correctly by mocking
    the database abstraction (providing fake data) and then asserting that requesting
    the URL returns your data correctly.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are several benefits of testing individually-isolated units of code:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '**Completeness**: A given unit will typically have a small number of clearly
    defined requirements. As such, it''s easy to ensure that you''re testing the full
    gamut of a unit''s functionality. All input variations can be tested quite easily.
    The very limits of each unit can also be tested, including the often complex minutiae
    of how something operates.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reportability:** When a given unit test fails, you can quite easily discern
    the exact nature and circumstance of the failure, meaning quicker debugging and
    fixing of the underlying problem. This is in contrast to integration tests, which,
    as we will discover, may have far more generic reporting that doesn''t indicate
    the exact point of failure in the code.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Comprehension:** Unit tests are a useful and self-contained form of documentation
    for given modules or functions. The narrowness and specificity of unit tests help
    us to fully understand how something works, easing maintainability. This is especially
    useful when there isn''t up-to-date documentation elsewhere.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Completeness* here is similar to the popular concept of *test covera**ge*.
    The crucial difference is that while coverage is about maximizing the amount of
    code within a code base that is tested, completeness is about maximizing the coverage
    of each individual unit, so that the entire input space of the unit is expressed.
    Test coverage, as a metric, only tells us whether things are tested, not whether
    they''re well-tested.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: 'There are, however, challenges that come unit-testing as well:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '**Mocking correctly**: Creating properly isolated unit tests sometimes means
    we have to constructs mocks or stubs of other units, as discussed in our former
    car analogy. It''s sometimes challenging to create realistic mocks and to ensure
    that you''re not introducing new areas of complexity and potential failures.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Testing realistic inputs**: Writing unit tests that provide a wide variety
    of realistic inputs is key although it can be challenging. It''s quite easy to
    fall into a trap of writing tests that appear to give confidence but in fact don''t
    test the kinds of situations that would arise when the code is in production.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Testing true units and not combinations**: If not carefully constructed,
    unit tests can begin to bloat and become integration tests. Sometimes, a test
    can seem very simple on the surface but in fact depends on a series of integrations
    beneath the surface. To re-use our car analogy, an example of this would be if
    we were to attempt to make a simple unit test asserting the sound of the car horn
    without first isolating its circuitry. We''d unknowingly be creating an E2E test.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The unit test, as the most granular type of test, is vital to any code base.
    It is perhaps easiest to think of it as a type of double-entry bookkeeping system.
    When you make a change, you must reflect that change via an assertion. This implementation-then-testing
    cycle is best done in proximity—one after the other—perhaps via TDD, which will
    be discussed later. The unit test is your way of confirming to yourself that you
    truly wrote the code you intended to write. It provides a level of certainty and
    reliability that your team and stakeholders will be hugely grateful for.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: Integration testing
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Integration testing, as the name suggests, deals with integrations of distinct
    *units *of code. An integration test will provide a more useful signal about how
    your software will operate in production than simple unit tests. In our car analogy,
    an integration test might assert the functionality of the horn, based on how it
    operates with the car's own power supply, instead of providing a mock power supply.
    It may however still be a partially isolated test, ensuring it does not involve
    all components within the car.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a couple of examples of possible integration tests:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: You have a `Button` component that should add an item to a list when clicked.
    A possible integration test would be to render the component in the real DOM and
    check that a simulated `click` event correctly adds the item to the list. This
    tests the integration between the `Button` component, the DOM, and the logic that
    determines when items are added to the list.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You have a REST API route of `/users/get/{ID}`, which should return user profile
    data from the database. A possible integration test would be to create a genuine
    database entry with ID of `456` and then request that data back via `/users/get/456`.
    This tests the integration between the HTTP routing abstraction and the database
    layer.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are quite a few advantages of integrating modules and testing their behavior
    together:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '**Get better coverage**: Integration tests have one or more integrated modules
    as their test subject, and so by having such tests, we can increase our ''test
    coverage'' throughout our code base, meaning we are increasing the amount of our
    code that is exposed to tests and therefore increasing the likelihood that we''ll
    be able to catch faults.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Clearly see faults**: Emulating, at least in part, the integration of modules
    that we would see in production enables us to see real integration faults and
    failures as they may naturally occur. A clear view of these faults enables us
    to iterate with fixes quickly and retain a reliable system.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Expose bad expectations**: Integration tests allow us to challenge the assumptions
    we may have made when building individual units of code.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So,while unit tests give us a narrow and detailed view of the input and output
    of specific modules and functions, integration tests allow us to see how all of
    these modules work together and, by doing so, provide us with a view into potential
    problems of integration. This is incredibly useful, but there are traps and challenges
    to writing integration tests:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '**Isolating integrations** (avoiding big bang tests): When implementing integration
    tests, it is sometimes easier to avoid isolating individual integrations and instead
    just test a large part of the system with all of its integrations intact. This
    is more akin to an E2E test and is certainly useful, but it''s important to also
    have isolated integrations so you can get granular insight into potential failures.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Realistic integrations** (for example, database server and client): When
    picking and isolating integrations to test, it is sometimes difficult to create
    realistic circumstances. An example would be testing how your REST API integrates
    with your database server but instead of having a separate database server for
    testing purposes, you just have a local one. This is still an insightful test
    but because it does not emulate the remoteness of the database server (that would
    exist in production) you may get a false sense of confidence. There may be failures
    lurking, undetected.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The integration test provides vital insight at the crucial points of interfacing
    and I/O that govern how all of the individual parts of a code base work together
    as a system. Integration tests often provide the most signal about potential faults
    in a system, as they are both usually quick to run and highly transparent upon
    failures (unlike potentially clunky E2E tests). Naturally, integration tests can
    only tell you things about the points of integrations they encapsulate. For more
    complete confidence in the functionality of a system, it's always a good idea
    to employ E2E testing.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: E2E and functional testing
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: E2E testing is a more extreme form of integration test where, instead of testing
    individual integrations between modules, we'll test the entire system, usually
    by executing a series of actions that would happen in reality to produce a given
    result. These tests are sometimes also called **functional tests** because they
    are interested in testing areas of functionality from the user's perspective.
    Well-constructed E2E tests give us confidence that our entire system is working
    correctly, but are most valuable when combined with more granular unit and integration
    tests so that faults can be more quickly and precisely identified.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a quick lowdown of the benefits of writing E2E tests:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '**Correctness and health**: E2E tests give you a clear insight into the general
    health of a system. Since many individual parts will effectively be tested via
    the typical E2E test, its success can give you a good indication that things are
    okay in production. Granular unit or integration tests, while very useful in their
    own way, don''t give you this kind of systemic insight.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Realistic effects**: Via E2E tests we can tryout more realistic circumstances,
    emulating the way our code will run in the wild. By emulating the flow of a typical
    user, an E2E test can highlight potential issues that more granular unit or integration
    tests might not reveal. An example of this would be when there are race conditions
    or other timing issues that can only be revealed when a code base is made to run
    as one consolidated system.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**More holistic view**: E2E tests give developers a holistic view of a system,
    enabling them to reason more accurately about how distinct modules work together
    to produce a working user flow. This can be incredibly valuable when trying to
    build a full understanding of how a system operates. Much like both unit and integration
    tests, E2E tests can serve as a form of documentation.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are challenges involved in crafting E2E tests, however:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '**Performance and time costs**: E2E tests, because they involve the activation
    of many individual pieces of code immersed in realistic environments, can be quite
    expensive in terms of time and hardware resources. The time that E2E tests take
    to run can impede development, and so it''s not rare for teams to avoid E2E tests
    for fear of a slowed development cycle.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Realistic steps**: Accurately emulating real-life circumstances in an E2E
    test can be a challenge. Using fake or made-up situations and data can still provide
    a realistic enough test but can also provide you a false sense of confidence.
    Since E2E tests are scripted, it''s quite common to not only rely on fake data
    but to have actions conducted in an unrealistically fast or direct manner, missing
    out on possible insights you could gain by creating more human circumstances (repeat
    after me: *always think of the user*).'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Complex tooling**: The point of an E2E test is to realistically emulate a
    user flow as it would exist in the wild. To accomplish this, we need good tooling
    that enables us to set up realistic environments (for example, headless and scriptable
    browser instances). Such tooling can be buggy or complicated to use and can introduce
    yet another variable to the testing process that can result in unrealistic failures
    (tools can give you false signals about whether things are really working).'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: E2E testing, although challenging to get right, can provide a level of insight
    and confidence that is hard to get from only unit and integration tests. In terms
    of automated testing procedures, E2E testing is the closest we can reasonably
    get to getting our software in front of real users. It is the least granular and
    most systemic way of discerning whether our software works in the way our users
    expect it to, which, after all, is what we're most interested in.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Test-Driven Development
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: TDD is a paradigm in which we write tests before implementation. In doing so,
    our tests end up informing and affecting the design of our implementation and
    its interface. By doing this, we begin to see tests as not only a form of documentation
    but a form of specification. Via our tests, we can designate how we wish something
    to work, writing assertions as if the functionality existed, and then we can iteratively
    build out the implementation such that all of our tests eventually pass.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate TDD, let''s imagine that we wish to implement a word-counting
    function. Before implementing it, we can begin to write some assertions about
    how we wish for it to work:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This is a rather simple function and so we''ve been able to express most of
    its functionality in just three assertions. There are naturally other edge cases
    but we''ve pieced together enough expectations that we can begin to implement
    the function. Here is our first attempt:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Immediately running this implementation via our small test suite, we receive
    the following results:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `Hyphenated words` test is failing. TDD, by its nature, expects iterative
    failure and refactor to bring an implementation inline with a test suite. Given
    this particular failure, we can simply add a hyphen to our regular expression''s
    character class (between the `[...]` delimiters):'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This produces the following test logs:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Success! Via incremental iteration, although simplified for the sake of illustration,
    we have implemented something via TDD.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: 'As you may have observed, TDD is not a particular type or style of test, but
    rather it is a paradigm for *when*, *how*, and *why* we go about testing. The
    traditional view of testing as an afterthought is limited and often can force
    us into a position where we simply don''t have time to write a good test suite.
    TDD, however, forces us to lead with a solid test suite, giving us a few notable
    benefits:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能已经观察到的，TDD并不是一种特定类型或风格的测试，而是一种关于*何时*、*如何*和*为什么*进行测试的范式。传统观点认为测试是事后的想法，这种观点是有限的，通常会迫使我们处于这样一种境地：我们根本没有时间编写一个好的测试套件。然而，TDD迫使我们以一个完整的测试套件为先导，给我们带来了一些显著的好处：
- en: It guides implementation
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它指导实施
- en: It prioritizes the user
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它优先考虑用户
- en: It forces complete test coverage
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它强制进行完整的测试覆盖
- en: It forces single responsibility
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它强制单一责任
- en: It enables quick problem domain discovery
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它能够快速发现问题领域
- en: It gives you immediate feedback
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它给予你即时反馈
- en: TDD is an especially useful paradigm when getting started with testing as it
    will force you to take a step back before implementing something and really consider
    what you're trying to do. This planning stage is really helpful in ensuring that
    our code fully aligns with user expectations.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: TDD在开始测试时是一种特别有用的范式，因为它会迫使你在实施之前退后一步，真正考虑你想要做什么。这个规划阶段对于确保我们的代码与用户期望完全一致非常有帮助。
- en: Summary
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we introduced the concept of testing and how it relates to
    software. While brief and introductory, these foundational concepts are crucial
    if we're going to approach testing with an aim toward reliability and maintainability.
    Testing, like many other concerns in the software world, can be liable to cargo
    culting, so it's crucial to retain a perspective on the fundamentals and the theory
    behind the tests we write. Testing, at its core, is about proving expectations
    and protecting against faults. We've covered the differences between unit, integration,
    and E2E tests, discussing both the advantages and challenges inherent in each.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了测试的概念以及它与软件的关系。虽然简短和入门级，但这些基础概念对于我们以可靠性和可维护性为目标进行测试是至关重要的。测试，就像软件世界中的许多其他问题一样，可能会容易地变成一种迷信，因此保持对我们编写的测试背后的基本原理和理论的视角至关重要。测试，本质上是关于证明期望和防范故障的。我们已经讨论了单元测试、集成测试和端到端测试之间的区别，讨论了每种测试中固有的优势和挑战。
- en: In the next chapter, we'll look into how we can take this knowledge and apply
    it to crafting clean tests alongside real-life examples. Specifically, we will
    cover what measures and guiding principles we can use to ensure that our tests
    and the assertions within them are reliable, intuitive, and maximally useful.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何将这些知识应用于制定干净的测试和实际示例。具体来说，我们将介绍我们可以使用哪些措施和指导原则来确保我们的测试和其中的断言是可靠的、直观的和最大程度有用的。
