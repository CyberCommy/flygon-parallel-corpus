- en: Spring Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 7*](c46a5b67-c5be-49c0-af8e-b0c4713f890b.xhtml), *Advanced Spring
    Boot Features*, we discussed advanced Spring Boot features, such as externalized
    configuration, monitoring, embedded servers, and deploying to the Cloud. In this
    chapter, let's turn our attention to data. Where we store our data and how we
    store data has been in rapid evolution during the last decade. After a few decades
    of stability with relational databases, in the last decade, a number of unstructured,
    nonrelational databases are taking firm ground. With a variety of data stores
    in play, the frameworks that talk to these data stores are becoming more important.
    While JPA made it easy to talk to relational databases, Spring Data aims to bring
    in a common approach to talk to a wider variety of data stores--relational or
    otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are some of the questions we will answer during this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: What is Spring Data?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are the aims of Spring Data?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do you talk to a relational database using Spring Data and Spring Data JPA?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do you talk to a nonrelational database such as MongoDB using Spring Data?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Background - data stores
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Most applications talk to a variety of data stores. There has been a considerable
    evolution in how applications talk to a data store. The most basic API provided
    by Java EE is **JDBC** (**Java Database Connectivity**). JDBC is used to talk
    to relational databases from the first version of Java EE. JDBC is based on using
    SQL queries to manipulate data. The following is an example of typical JDBC code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Typical JDBC code contains the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The query (or stored procedure) to execute
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code to set parameters for query into statement objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code to liquidate ResultSet (the result of executing the query) into beans
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Typical projects involved thousands of lines of JDBC code. JDBC code was cumbersome
    to write and maintain. Two frameworks became popular in an effort to provide an
    additional layer on top of JDBC:'
  prefs: []
  type: TYPE_NORMAL
- en: '**myBatis** (earlier called iBatis): MyBatis removes the need for manually
    writing code to set parameters and retrieve results. It provides simple XML or
    annotation-based configuration to map Java POJOs to a database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hibernate**: Hibernate is an **ORM** (**Object/Relational Mapping**) framework.
    An ORM framework helps you to map your objects to tables in relational databases.
    The great thing about Hibernate is that developers do not need to write queries
    manually. Once the relationships between the objects and tables are mapped, Hibernate
    uses the mappings to create queries and populate/retrieve data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java EE came up with an API called **JPA** (Java Persistence API) that was roughly
    defined based on the popular ORM implementation at that time--the Hibernate framework.
    Hibernate (since 3.4.0.GA) supports/implements JPA.
  prefs: []
  type: TYPE_NORMAL
- en: In relational databases, data is stored in normalized, well-defined tables.
    While Java EE tried to solve the challenge of talking a relational data store,
    several other data stores became popular during the last decade. With the evolution
    of big data and real-time data needs, new and more unstructured forms of storing
    data came into existence. These kinds of databases are typically grouped under
    NoSQL databases. Examples are Cassandra (column), MongoDB (document), and Hadoop.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Each of the data stores have different ways to connect and retrieve/update data.
    Spring Data aims to provide a consistent model--another level of abstraction -
    to access data from different kinds of data stores.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the important Spring Data features are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Easy integration with multiple data stores through various repositories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to parse and form queries based on repository method names
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provides the default CRUD functionality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic support for auditing, such as created by user and last changed by user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Powerful integration with Spring
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Great integration with Spring MVC to expose REST controllers through **Spring
    Data Rest**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Spring Data is an umbrella project made up of a number of modules. A few of
    the important Spring Data modules are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Spring Data Commons**: Defines the common concepts for all Spring Data modules--repository
    and query methods'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Spring Data JPA**: Provides easy integration with JPA repositories'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Spring Data MongoDB**: Provides easy integration with MongoDB--a document-based
    data store'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Spring Data REST**: Provides the functionality to expose Spring Data repositories
    as REST services with minimal code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Spring Data for Apache Cassandra**: Provides easy integration with Cassandra'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provides easy integration with Hadoop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we will take an in-depth look at the common concepts behind
    Spring Data, repository, and query methods. In the initial examples, we will use
    Spring Data JPA to illustrate these concepts. We will also take a look at a sample
    integration with MongoDB later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Data Commons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring Data Commons provides the basic abstractions behind Spring Data modules.
    We will use Spring Data JPA as an example to illustrate these abstractions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the important interfaces in Spring Data Commons are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Repository is the core interface of Spring Data. It is a **marker interface**.
  prefs: []
  type: TYPE_NORMAL
- en: The CrudRepository interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `CrudRepository` defines the basic `Create`, `Read`, `Update`, and `Delete`
    methods. The important methods in `CrudRepository` are shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The PagingAndSortingRepository interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The PagingAndSortingRepository defines methods that provide the functionality
    to divide the ResultSet into pages as well as sort the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We will look at examples of using the `Sort` class and `Page`, `Pageable` interfaces
    in the section on Spring Data JPA.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Data JPA
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring Data JPA implements the core functionality defined in Spring Data Common
    interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: '**JpaRepository** is the JPA-specific repository interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '**SimpleJpaRepository** is the default implementation of the CrudRepository
    interface for JPA:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Spring Data JPA example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's set up a simple project to understand the different concepts related to
    Spring Data Commons and Spring Data JPA.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the steps involved:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new project with `spring-boot-starter-data-jpa` as a dependency.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add entities.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `SpringBootApplication` class to run the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create repositories.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: New project with Starter Data JPA
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will create a simple Spring Boot Maven project using the following dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '`spring-boot-starter-data-jpa` is the Spring Boot starter project for Spring
    Data JPA. Important dependencies that `spring-boot-starter-data-jpa` brings in
    are **JTA** (**Java Transaction API**), Hibernate Core, and Entity Manager (Default
    JPA Implementation). Some of the other important dependencies are shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7ef3648f-f321-4f54-9f0e-b91ce61947c7.png)'
  prefs: []
  type: TYPE_IMG
- en: Entities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s define a couple of entities to use in our example. We will create an
    entity `Todo` to manage todos. A simple example is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Important things to note are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Todo` has a title, a description, a target date, and a completion indicator
    (`isDone`). JPA needs a constructor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Entity`: The annotation specifies that the class is an entity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Id`: Specifies that ID is the primary key of the entity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@GeneratedValue(strategy = GenerationType.AUTO)`: The `GeneratedValue` annotation
    is used to specify how the primary key is generated. In this example, we are using
    a strategy of `GenerationType.AUTO`. This indicates that we would want the persistence
    provider to choose the right strategy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@ManyToOne(fetch = FetchType.LAZY)`: Indicates a many-to-one relationship
    between `User` and `Todo`. A `@ManyToOne` relationship is used on one side of
    the relationship. `FetchType.Lazy` indicates that the data can be lazily fetched.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@JoinColumn(name = "userid")`: The `JoinColumn` annotation specifies the name
    of the foreign key column.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following snippet shows the `User` entity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Important things to note are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The user is defined as an entity with the `userid` and `name` attributes. The
    ID is the primary key, which is autogenerated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `@OneToMany(mappedBy = "user")`: `OneToMany` annotation is used on the
    many side of a many-to-one relationship. The `mappedBy` attribute indicates the
    property of the owner entity of the relationship.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The SpringBootApplication class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create a `SpringBootApplication` class to be able to run the Spring
    Boot application. The following snippet shows a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The following snippet shows some of the logs generated when we run `SpringDataJpaFirstExampleApplication`
    as a Java application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Some of the important observations are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`HHH000412: Hibernate Core {5.0.11.Final}`: The Hibernate framework is initialized'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HHH000400: Using dialect: org.hibernate.dialect.H2Dialect`: The H2 in-memory
    database is initialized'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HHH000227: Running hbm2ddl schema export`: Based on the entities available
    (`Todo` and `User`) and the relationship between them, a schema is created'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A lot of magic happened in the previous execution. Let''s look at some of the
    important questions:'
  prefs: []
  type: TYPE_NORMAL
- en: How does the Hibernate framework come into the picture even though we did not
    explicitly declare a dependency in `pom.xml`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How is the H2 in-memory database used?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the schema that is created?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's now answer each of these questions.
  prefs: []
  type: TYPE_NORMAL
- en: How does the Hibernate framework come into the picture even though we did not
    explicitly declare a dependency in `pom.xml`?
  prefs: []
  type: TYPE_NORMAL
- en: Hibernate is one of the dependencies of Spring Boot Starter JPA. So, it is the
    default JPA implementation used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How is the H2 in-memory database used?
  prefs: []
  type: TYPE_NORMAL
- en: In our dependencies, we included an H2 dependency with scope runtime. When Spring
    Boot Data JPA auto-configuration runs, it notices that we have not included any
    data source in our configuration (actually, we have no configuration at all).
    Spring Boot Data JPA then tries to auto-configure an in-memory database. It sees
    H2 on the classpath. Therefore, it initializes an in-memory H2 database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the schema that is created?
  prefs: []
  type: TYPE_NORMAL
- en: 'The following snippet shows the schema that is created based on the Entity
    classes and the relationships we declared. This is auto-created by Spring Boot
    Data JPA auto-configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `todo` table has a foreign key user ID for the user table.
  prefs: []
  type: TYPE_NORMAL
- en: Populating some data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To be able to test the repositories that we will create, we will populate some
    test data into these tables. All that we need to do is include the file called
    `data.sql` with the following statements in `src\main\resources`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: These are simple insert statements. We are creating a total of four users -
    the first user has two todos, the second user has one todo, and the last two users
    have none.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you run `SpringDataJpaFirstExampleApplication` as Java application again,
    you will see a few extra statements in the log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The log statements confirm that the data is being populated into the H2 in-memory
    database. Let's turn our attention to creating repositories to access and manipulate
    the data from the Java code.
  prefs: []
  type: TYPE_NORMAL
- en: A simple repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A custom repository can be created by extending the repository marker interface.
    In the following example, we extend the repository interface with two methods--`findAll`
    and `count`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'A few important things to note are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`public interface TodoRepository extends Repository<Todo, Long>`: The `TodoRepository`
    interface extends the `Repository` interface. The two generic types indicate the
    entity being managed--Todo and the type of the primary key, that is, `Long`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Iterable<Todo> findAll()`: Used to list all the todos. Note that the name
    of the method should match what''s defined in `CrudRepository`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`long count()`: Used to find the count of all todos.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s write a simple unit test to test whether we are able to access the `todo`
    data using `TodoRepository`. The following snippet shows the important details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'A few important things to note are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@DataJpaTest`: The `DataJpaTest` annotation is typically used along with `SpringRunner`
    in JPA repository unit tests. This annotation will enable only JPA-related auto-configuration.
    The test would use an in-memory database by default.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@RunWith(SpringRunner.class)`: `SpringRunner` is a simple alias for `SpringJUnit4ClassRunner`.
    It launches a Spring context.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Autowired TodoRepository todoRepository`: Autowires `TodoRepository` to be
    used in the test.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertEquals(3, todoRepository.count())`: Checks whether the count returned
    is `3`. Remember that we inserted three todos in `data.sql`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A word of caution: We are taking a shortcut to write a unit test in the preceding
    example. Ideally, a unit test should not depend on already-created data in the
    database. We will fix this in our future tests.'
  prefs: []
  type: TYPE_NORMAL
- en: The `Extending Repository` interface helps us in exposing selected methods on
    entities.
  prefs: []
  type: TYPE_NORMAL
- en: The CrudRepository interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can extend `CrudRepository` to expose all create, read, update, and delete
    methods on an entity. The following snippet shows `TodoRepository` extending `CrudRepository`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '`TodoRepository` can be used to perform all methods exposed by the `CrudRepository`
    interface. Let''s write a few unit tests to test some of these methods.'
  prefs: []
  type: TYPE_NORMAL
- en: Unit test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `findById()` method can be used to query using the primary key. The following
    snippet shows an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '`Optional` represents a container object for an object that can be null. Some
    of the important methods in `Optional` are listed below:'
  prefs: []
  type: TYPE_NORMAL
- en: '`isPresent()`: Check if `Optional` contains a non-null value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`orElse()`: Default value if the object contained is null.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ifPresent()`: Code in `ifPresent` is executed if the object contained is not
    null.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`get()`: To retrieve the contained object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `existsById()` method can be used to check whether an entity with the given
    ID exists. The following example shows how it can be done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `deleteById()` method is used to delete an entity with a specific ID. In
    the following example, we are deleting one of the `todos`, reducing the available
    todos from three to two:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The `deleteAll()` method is used to delete all the entities managed by the
    specific repository. In the specific example here, all the `todos` from the `todo`
    table are deleted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The `save()` method can be used to update or insert an entity. The following
    example shows how the description of a `todo` can be updated. The following test
    uses `TestEntityManager` to flush the data before retrieving it. `TestEntityManager`
    is autowired as part of the functionality of `@DataJpaTest` Annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The PagingAndSortingRepository interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`PagingAndSortingRepository` extends `CrudRepository` and provides methods
    in order to retrieve entities with pagination and a specified sort mechanism.
    Take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Important things to note are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`public interface UserRepository extends PagingAndSortingRepository` : The
    `UserRepository` interface extends the `PagingAndSortingRepository` interface'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<User, Long>`: Entities are of type `User` and have an ID field of type `Long`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s write a few tests to use the sorting and pagination capabilities of
    `UserRepository`. The base of the test is very similar to `TodoRepositoryTest`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s write a simple test to sort users and print the `users` to the log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Important things to note are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`new Sort(Sort.Direction.DESC, "name")`: We would want to sort by name in descending
    order.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`and(new Sort(Sort.Direction.ASC, "userid"))`: The `and()` method is a conjunction
    method to combine different sort configurations. In this example, we are adding
    secondary criteria to sort by user ID in the ascending order.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`userRepository.findAll(sort)`: The sort criteria are passed as a parameter
    to the `findAll()` method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The output of the preceding test is as shown as follows. The users are sorted
    in descending order by name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The test for the pageable is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the test is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Important things to note are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`new PageRequest(0, 2)`: We are requesting the first page (index 0) and setting
    the size of each page to two'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`userRepository.findAll(pageable)`: The `PageRequest` object is sent as a parameter
    to the `findAll` method'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Page 1 of 2` : The output shows that we are looking at the first page in a
    total of two pages'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A couple of important things to note about `PageRequest` are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `PageRequest` object has the `next()`, `previous()`, and `first()` methods
    to traverse the pages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `PageRequest` constructor (`public PageRequest(int page, int size, Sort
    sort)`) also accepts a third parameter--`Sort order`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Important methods in Page and its child interface, Slice, are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`int getTotalPages()`: Returns the number of result pages'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`long getTotalElements()`: Returns the total number of elements in all pages'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int getNumber()`: Returns the number of the current page'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int getNumberOfElements()`: Returns the number of elements in the current
    page'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`List<T> getContent()`: Gets the content of the current slice (or page) as
    a list'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boolean hasContent()`: Returns if the current slice has any elements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boolean isFirst()`: Returns if this is the first slice'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boolean isLast()`: Returns if this is the last slice'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boolean hasNext()`: Returns if there is a next slice'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boolean hasPrevious()`: Returns if there is a previous slice'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Pageable nextPageable()`: Gets access to the next slice'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Pageable previousPageable()`: Gets access to the previous slice'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Query methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous sections, we looked at the `CrudRepository` and `PagingAndSortingRepository`
    interfaces. We looked at the different methods that they provided by default.
    Spring Data does not stop here. It defines a few patterns that allow you to define
    custom query methods. In this section, we will look at examples of some of the
    options Spring Data provides to customize your query methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start with examples related to finding rows matching specific attribute
    values. The following example shows different methods in order to search for the
    `User` by their name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Important things to note are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`List<User> findByName(String name)`: The pattern is `findBy` , followed by
    the name of the attribute that you would want to query by. The value of the attribute
    is passed in as a parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`List<User> findByName(String name, Sort sort)`: This method allows you to
    specify a specific sort order.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`List<User> findByName(String name, Pageable pageable)`: This method allows
    the use of pagination.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instead of find we can also use read, query or get to name the methods. For
    example, queryByName instead of findByName.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Similar to find..By we can use count..By to find the count, and delete..By (or
    remove..By) to delete records.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following example shows how to search by attributes of a containing element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The user contains `Todos`. `Todo` has `title` attribute. To create a method
    to search a user based on the title of the todo, we can create a method by the
    name `findByTodosTitle` in `UserRepository`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following examples show a few more variations that are possible with `findBy`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Important things to note are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`findByTitleAndDescription`: Multiple attributes can be used to query'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`findDistinctTodoByTitleOrDescription`: Find distinct rows'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`findByTitleIgnoreCase`: Illustrates the use of the ignore case'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`findByTitleOrderByIdDesc`: Illustrates an example of specifying a specific
    sort order'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following example shows how to find a specific subset of records using
    find:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Important things to note are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`findFirstByName, findTopByName`: Queries for the first user'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`findTop3ByName, findFirst3ByName`: Finds the top three users'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Queries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spring Data JPA also provides options to write custom queries. The following
    snippet shows a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Important things to note are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@Query`: The annotation to define queries for repository methods'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`select u from User u where u.name = ?1`: `Query to be executed. ?1` represents
    the first parameter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`findUsersByNameUsingQuery`: When this method is called, the query specified
    is executed with the name as the parameter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Named Parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can use named parameters to make the query more readable. The following
    snippet from UserRepository shows an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Important things to note are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`select u from User u where u.name = :name`: Defines a named parameter `"name"`
    in the query'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`findUsersByNameUsingNamedParameters(@Param("name") String name)`: `@Param("name")`
    defines the named parameter in the arguments list'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Named Query
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: is to use named queries defined on the entity itself. The following example
    shows how to define a named query on
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'To use this query in a repository, we would need to create a method with the
    same name as the named query. The following snippet shows the corresponding method
    in UserRepository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Note that the name of the named query is `User.findUsersWithNameUsingNamedQuery`.
    So, the name of the method in the repository should be `findUsersWithNameUsingNamedQuery`.
  prefs: []
  type: TYPE_NORMAL
- en: Native query
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spring Data JPA provides the option to execute native queries as well. The
    following example demonstrates a simple native query in `UserRepository`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Important things to note are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SELECT * FROM USERS WHERE u.name = ?1`: This is the native query to be executed.
    Note that we are not referring to the User entity but are using the table name
    users in the query.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nativeQuery = true`: This attribute ensures that the query is executed as
    a native query.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Data Rest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring Data Rest provides a very simple option to expose CRUD RESTful services
    around data repositories.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the important features of Spring Data Rest include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Exposing the REST API around Spring Data repositories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support for pagination and filtering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding query methods in Spring Data repositories and exposing them as
    search resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Among the frameworks supported are JPA, MongoDB, and Cassandra
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Options to customize the resources are exposed by default
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will start by including the Spring Boot Data Rest starter in our `pom.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We can make `UserRepository` expose the REST service by adding a simple annotation,
    as shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Important things to note are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@RepositoryRestResource`: The annotation used to expose a repository using
    REST'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`collectionResourceRel = "users"`: The `collectionResourceRel` value to be
    used in the generated links'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`path = "users"`: The path under which the resource has to be exposed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When we launch `SpringDataJpaFirstExampleApplication` as a Java application,
    the following can be seen in the log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The preceding log shows that the Spring MVC DispatcherServlet is launched and
    ready to serve different request methods and URIs.
  prefs: []
  type: TYPE_NORMAL
- en: The GET method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we send a `GET` request to `http://localhost:8080/users`, we get the response
    shown here. The response is edited to remove the details of `UserId2`, `UserId3`
    and `UserId4` for brevity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The POST method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following screenshot shows how to fire a `POST` request to create a new
    user:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eb8f9011-0f39-464d-a292-4e144fae7866.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following snippet shows the response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The response contains the URI of the created resource--`http://localhost:8080/users/5`.
  prefs: []
  type: TYPE_NORMAL
- en: The search resource
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spring Data Rest exposes search resources for other methods in the repository.
    For example, the `findUsersByNameUsingNamedParameters` method is exposed at `http://localhost:8080/users/search/findUsersByNameUsingNamedParameters?name=User%20Name%201`.
    The following snippet shows the response of a `Get` request to the preceding URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Big Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we discussed in the introduction to the chapter, there are a variety of
    data stores that are providing alternatives to traditional databases. The term
    **Big Data** has become popular in the last few years. While there is no agreed
    definition of Big Data, there are a few shared characteristics:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Unstructured Data**: There is no specific structure to the data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Large Volumes**: Typically, more volumes than that can be processed by traditional
    databases, for example, log streams, Facebook posts, tweets'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Easily Scalable**: Typically provides options to scale horizontally and vertically'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hadoop, Cassandra, and MongoDB are among the popular options.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will take MongoDB as an example to connect using Spring
    Data.
  prefs: []
  type: TYPE_NORMAL
- en: MongoDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Follow the instructions at [http://docs.mongodb.org/manual/installation/](http://docs.mongodb.org/manual/installation/)
    to install MongoDB on your specific operating system.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started with connecting to MongoDB, include the dependency for Spring
    Boot MongoDB starter in the `pom.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create a new Entity class `Person` to store to MongoDB. The following
    snippet shows a `Person` class with an ID and a name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'We would want to store the `Person` entities to MongoDB. We would need to create
    a new repository. The following snippet shows a MongoDB repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Important things to note are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`PersonMongoDbRepository extends MongoRepository`: `MongoRepository` is a MongoDB-specific
    Repository interface'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MongoRepository<Person, String>`: We would want to store `Person` entities
    that have a key of type String'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`List<Person> findByName(String name)`: A simple method to find a person by
    name'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will write a simple unit test to test this repository. The code for the
    unit test is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Some important things to note are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Make sure that MongoDB is running when your run the test.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@DataMongoTest`: The `DataMongoTest` annotation is used in combination with
    `SpringRunner` for a typical MongoDB unit test. This disables auto-configuration
    for everything except things related to MongoDB.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Autowired PersonMongoDbRepository personRepository`: Autowires the MongoDB
    repository to be tested.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An important thing to note is that all the code in the test is very similar
    to the code written for Spring Data JPA. This example show how simple Spring Data
    makes it to connect to different kinds of data stores. The code to interact with
    a nonrelational Big Data data store is similar to the code that talks to a relational
    database. That's the magic of Spring Data.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring Boot makes the development of Spring-based applications easy. Spring
    Data makes it easy to connect to different data stores.
  prefs: []
  type: TYPE_NORMAL
- en: r, we looked at how Spring Data makes it easy to connect to different data stores
    through simple concepts such as repository. We also came to know how to use Spring
    Data in combination with Spring Data JPA to connect to an in-memory relational
    database and how to use Spring Data MongoDB to connect and save data to a Big
    Data store, such as MongoDB.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will shift our attention toward the cloud. We will learn
    about Spring Cloud and how it solves the problems of the Cloud.
  prefs: []
  type: TYPE_NORMAL
