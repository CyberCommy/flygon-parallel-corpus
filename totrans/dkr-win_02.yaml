- en: Getting Started with Docker on Windows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker is an application platform. It's a new way of running applications in
    isolated, lightweight units called **containers**. Containers are a very efficient
    way of running apps – much more efficient than **virtual machines** (**VMs**)
    or bare-metal servers. Containers start in seconds, and they don't add any overhead
    to the memory and compute requirements of an app. Docker is completely agnostic
    to the type of apps it can run. You can run a brand new .NET Core app in one container
    and a 10-year old ASP.NET 2.0 WebForms app in another container on the same server.
  prefs: []
  type: TYPE_NORMAL
- en: Containers are isolated units, but they can integrate with other components.
    Your WebForms container can access a REST API hosted in your .NET Core container.
    Your .NET Core container can access a SQL Server database running in a container,
    or a SQL Server instance running on a separate machine. You can even set up a
    cluster with a mixture of Linux and Windows machines all running Docker, and have
    Windows containers transparently communicate with Linux containers.
  prefs: []
  type: TYPE_NORMAL
- en: Companies big and small are moving to Docker to take advantage of this flexibility
    and efficiency. Case studies from Docker, Inc. – the company behind the Docker
    platform – show that you can reduce your hardware requirements by 50% by moving
    to Docker and reduce time to release by 90%  while still maintaining your applications'
    high availability. This significant reduction applies equally to on-premises data
    centers and to the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: Efficiency isn't the only gain. When you package your application to run in
    Docker, you get portability. You can run your app in a Docker container on your
    laptop and it will behave in exactly the same way on a server in your data center
    and on a VM in any cloud. This means your deployment process is simple and risk-free,
    because you're deploying the exact same artifacts that you've tested, and you're
    also free to choose between hardware vendors and cloud providers.
  prefs: []
  type: TYPE_NORMAL
- en: The other big motivator is security. Containers add secure isolation between
    applications, so you can be confident that if one application is compromised,
    the attacker can't move on to compromise other apps on the same host. There are
    wider security benefits to the platform too. Docker can scan the contents of packaged
    applications and alert you to security vulnerabilities in your application stack.
    You can also digitally sign container images and configure Docker to run containers
    only from image authors that you trust.
  prefs: []
  type: TYPE_NORMAL
- en: Docker is built from open source components, and is shipped as **Docker Community
    Edition** (**Docker CE**) and **Docker Enterprise**. Docker CE is free to use
    and has monthly releases. Docker Enterprise is a paid subscription; it comes with
    extended features and support, and has quarterly releases. Docker CE and Docker
    Enterprise are available on Windows, and both versions use the same underlying
    platform, so you can run your apps in containers on Docker CE and Docker Enterprise
    in the same way.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter gets you up-and-running with Docker containers. It covers:'
  prefs: []
  type: TYPE_NORMAL
- en: Docker and Windows containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the key Docker concepts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running Docker on Windows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning about Docker with this book
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can follow along with the code samples from this book using the GitHub repository
    [https://github.com/sixeyed/docker-on-windows/tree/second-edition/ch01](https://github.com/sixeyed/docker-on-windows/tree/second-edition/ch01).
    You'll learn how to install Docker in this chapter - the only pre-requisite is
    Windows 10 with the 1809 Microsoft update, or Windows Server 2019.
  prefs: []
  type: TYPE_NORMAL
- en: Docker and Windows containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker was originally developed on Linux, taking advantage of core Linux features,
    but making it simple and efficient to use containers for application workloads.
    Microsoft saw the potential and worked closely with the Docker engineering team
    to bring the same functionality to Windows.
  prefs: []
  type: TYPE_NORMAL
- en: Windows Server 2016 was the first version of Windows built to run Docker containers;
    Windows Server 2019 continues the innovation with significantly improved features
    and performance for Windows containers. You can run the same Docker containers
    on Windows 10 for development and testing that you run on Windows Server in production.
    Right now, you can only run Windows applications in containers on Windows, but
    Microsoft is adding support for Linux application containers to run on Windows
    too.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing you need to know is that there is no integration between containers
    and the Windows UI. Containers are only for server-side application workloads,
    like websites, APIs, databases, message queues, message handlers, and console
    applications. You can't use Docker to run a client app, like a .NET WinForms or
    WPF application, but you could use Docker to package and distribute the application,
    which would give you a consistent build and release process for all your apps.
  prefs: []
  type: TYPE_NORMAL
- en: There's also a distinction between how containers run on Windows Server 2019
    and Windows 10\. The user experience for working with Docker is the same, but
    the way containers are hosted is different. On Windows Server the process that
    serves your application actually runs on the server, and there's no layer between
    the container and the host. In the container you may see `w3wp.exe` running to
    serve a website, but that process is actually running on the server – if you had
    10 web containers running, you would see 10 instances of `w3wp.exe` in Task Manager
    on the server.
  prefs: []
  type: TYPE_NORMAL
- en: Windows 10 doesn't have the same operating system kernel as Windows Server 2019,
    so in order to provide containers with the Windows Server kernel, Windows 10 runs
    each container in a very light VM. These are called **Hyper-V containers**, and
    if you run a web app in a container on Windows 10, you won't see `w3wp.exe` running
    on the host – it actually runs inside a dedicated Windows Server kernel in the
    Hyper-V container.
  prefs: []
  type: TYPE_NORMAL
- en: This is the default behavior, but in the latest versions of Windows and Docker
    you can run Windows Server containers in Windows 10, so you can skip the extra
    overhead of running a VM for each container.
  prefs: []
  type: TYPE_NORMAL
- en: It's good to understand the distinction between Windows Server containers and
    Hyper-V containers. You use the same Docker artifacts and the same Docker commands
    for both, so the procedures are the same, but there is a slight performance hit
    in using Hyper-V containers. Later in this chapter, I'll show you the options
    for running Docker on Windows, and you can choose the best approach for you.
  prefs: []
  type: TYPE_NORMAL
- en: Windows versions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Applications in Windows Server containers run processes directly on the host,
    and the version of Windows on your server needs to match the version of Windows
    inside the container. All of the examples in this book are based on containers
    that use Windows Server 2019, which means you need a Windows Server 2019 machine
    to run them – or Windows 10 with the 1809 update (the `winver` command will tell
    you which update version you have).
  prefs: []
  type: TYPE_NORMAL
- en: You can run containers built for a different version of Windows if you run them
    as Hyper-V containers. This gives you backward-compatibility, so you can run a
    container that was built for Windows Server 2016 on a machine running Windows
    Server 2019.
  prefs: []
  type: TYPE_NORMAL
- en: Windows licensing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Windows containers don't have the same licensing requirements as servers or
    VMs running Windows. Windows is licensed at the host level, not the container
    level. If you have 100 Windows containers running on one server, you only need
    one license for the server. There are considerable savings to be had if you currently
    use VMs to isolate application workloads. Removing the VM layer and running apps
    in containers directly on the server removes the licensing requirement for all
    of the VMs, and the management overhead for all those machines.
  prefs: []
  type: TYPE_NORMAL
- en: Hyper-V containers have separate licensing. On Windows 10 you can run multiple
    containers, but not for production deployments. On Windows Server, you can also
    run containers in Hyper-V mode to increase isolation. This can be useful in multi-tenant
    scenarios, where you need to expect and mitigate for hostile workloads. Hyper-V
    containers are separately licensed, and in a high-volume environment, you need
    a Windows Server Datacenter license to run Hyper-V containers without individual
    licenses.
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft and Docker, Inc. have partnered to provide Docker Enterprise at no
    cost with Windows Server 2016 and Windows Server 2019\. The price of the Windows
    Server license includes the Docker Enterprise Engine, which gives you support
    to run applications in containers. If you have problems with a container or with
    the Docker service you can raise it with Microsoft, and they can go on to escalate
    it to Docker's engineers.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the key Docker concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker is a very powerful but very simple application platform. You can get
    started with running your existing apps in Docker in just a few days, and be ready
    to move to production in another few days. This book will take you through lots
    of examples of .NET Framework and .NET Core applications running in Docker. You'll
    learn how to build, ship, and run applications in Docker and move on to advanced
    topics such as solution design, security, administration, instrumentation, and
    **continuous integration and continuous delivery** (**CI/CD**).
  prefs: []
  type: TYPE_NORMAL
- en: 'To start with, you need to understand the core Docker concepts: images, registries,
    containers, and orchestrators – and understand how Docker actually runs.'
  prefs: []
  type: TYPE_NORMAL
- en: The Docker Engine and Docker command-line
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker runs as a background Windows service. This service manages every running
    container – it's called the Docker Engine. The engine exposes a REST API for consumers
    to work with containers and other Docker resources. The main consumer of this
    API is the Docker **command-line tool** (**CLI**), which is what I use for most
    of the code samples in this book.
  prefs: []
  type: TYPE_NORMAL
- en: The Docker REST API is public, and there are alternative management tools that
    are powered by the API, including web UIs like  Portainer (which is open source),
    and Docker **Universal Control Plane** (**UCP**) (which is a commercial product).
    The Docker CLI is very simple to use - you use commands like `docker container
    run` to run an application in a container and `docker container rm` to remove
    a container.
  prefs: []
  type: TYPE_NORMAL
- en: You can also configure the Docker API to be remotely accessible and configure
    your Docker CLI to connect to a remote service. This means you can manage a Docker
    host running in the cloud using Docker commands on your laptop. The setup to allow
    remote access can also include encryption, so your connection is secure – and
    in this chapter, I will show you an easy way to configure this.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have Docker running, you'll start by running containers from images.
  prefs: []
  type: TYPE_NORMAL
- en: Docker images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A Docker image is a complete application package. It contains one application
    and all of its dependencies: the language runtime, the application host, and the
    underlying operating system. Logically the image is a single file, and it''s a
    portable unit – you can share your application by pushing your image to a Docker
    registry. Anyone who has access can pull the image themselves and run your application
    in a container; it will behave in exactly the same way for them as it does for
    you.'
  prefs: []
  type: TYPE_NORMAL
- en: Here's a concrete example. An ASP.NET WebForms app is going to run on **Internet
    Information Services** (**IIS**) in Windows Server. To package the application
    in Docker, you build an image that is based on Windows Server Core, add IIS, then
    add ASP.NET, copy your application, and configure it as a website in IIS. You
    describe all these steps in a simple script called a **Dockerfile**, and you can
    use PowerShell or batch files for each step you need to perform.
  prefs: []
  type: TYPE_NORMAL
- en: You build the image by running `docker image build`. The input is the Dockerfile
    and any resources that need to be packaged into the image (like the web application
    content). The output is a Docker image. In this case, the image will have a logical
    size of about 5 GB, but 4 GB of this will be the Windows Server Core image you're
    using as a base, and the image can be shared as the base across many other images.
    (I will cover image layers and caching more in [Chapter 4](cba48cea-1666-4d9a-a268-ee2a104f5565.xhtml),
    *Sharing Images with Docker* *Registries*.)
  prefs: []
  type: TYPE_NORMAL
- en: A Docker image is like a snapshot of the filesystem for one version of your
    application. Images are static, and you distribute them using an image registry.
  prefs: []
  type: TYPE_NORMAL
- en: Image registries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A registry is a storage server for Docker images. Registries can be public or
    private, and there are free public registries and commercial registry servers
    which allow fine-grained access control for images. Images are stored with a unique
    name within the registry. Anyone with access can upload an image by running `docker
    image push`, and download an image by running `docker image pull`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most popular registry is **Docker Hub**, which is the public registry hosted
    by Docker, but other companies also host their own registries to distribute their
    own software:'
  prefs: []
  type: TYPE_NORMAL
- en: Docker Hub is the default registry, and it has become hugely popular for open
    source projects, for commercial software, and for teams working on private projects.
    There are hundreds of thousands of images stored on Docker Hub, which serves billions
    of pull requests every year. You can configure Docker Hub images to be public
    or private. It's suitable for internal products, for which you can limit access
    to images. You can set up Docker Hub to automatically build images from Dockerfiles
    stored in GitHub – currently, this is supported only for Linux-based images, but
    Windows support should be coming soon.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Microsoft Container Registry** (**MCR**) is where Microsoft host their own
    Docker images for Windows Server Core and Nano Server, along with images preconfigured
    with the .NET Framework. Microsoft''s Docker images are free to download and use.
    They only run on Windows machines, which is where the Windows  licensing is applied.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In a typical workflow you might build images as part of a CI pipeline and push
    them to a registry if all the tests pass. You could use Docker Hub, or you could
    run your own private registry. The image is then available for other users to
    run your application in a container.
  prefs: []
  type: TYPE_NORMAL
- en: Docker containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A container is an instance of an application created from an image. The image
    contains the whole application stack, and it also specifies the process to start
    the application, so Docker knows what to do when you run a container. You can
    run multiple containers from the same image, and you can run containers in different
    ways. (I'll describe them all in the next chapter.)
  prefs: []
  type: TYPE_NORMAL
- en: You start your application with `docker container run`, specifying the name
    of the image and your configuration options. Distribution is built into the Docker
    platform, so if you don't have a copy of the image on the host where you're trying
    to run the container, Docker will pull the image first. Then it starts the specified
    process, and your app is running in a container.
  prefs: []
  type: TYPE_NORMAL
- en: Containers don't need a fixed allocation of CPU or memory, and the processes
    for your application can use as much of the host's compute power as they need.
    You can run dozens of containers on modest hardware, and unless the applications
    all try to use a lot of CPU at the same time, they will happily run concurrently.
    You can also start containers with resource limits to restrict how much CPU and
    memory they have access to.
  prefs: []
  type: TYPE_NORMAL
- en: Docker provides the container runtime, as well as image packaging and distribution.
    In a small environment and in development, you will manage individual containers
    on a single Docker host, which could be your laptop or a test server. When you
    move to production, you'll need high availability and the option to scale, and
    that comes with an orchestrator like  Docker Swarm.
  prefs: []
  type: TYPE_NORMAL
- en: Docker Swarm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker has the ability to run on a single machine or as one node in a cluster
    of machines all running Docker. This cluster is called a **Swarm**, and you don't
    need to install anything extra to run in swarm mode. You install Docker on a set
    of machines –  on the first, you run `docker swarm init` to initialize the swarm,
    and on the others you run `docker swarm join` to join the swarm.
  prefs: []
  type: TYPE_NORMAL
- en: I will cover swarm mode in depth in [Chapter 7](bf6a5e90-bbba-435b-b0a0-734611e0e834.xhtml),
    *Orchestrating Distributed Solutions with Docker Swarm,* but it's important to
    know before you get much further that the Docker platform has high availability,
    security, scale and resilience built in. Your Docker journey will hopefully lead
    you to production, where you'll benefit from all of these attributes.
  prefs: []
  type: TYPE_NORMAL
- en: In swarm mode Docker uses exactly the same artifacts, so you can run your app
    across 50 containers in a 20-node swarm and the functionality will be the same
    as when you run it in a single container on your laptop. On the swarm, your app
    is more performant and tolerant of failure, and you'll be able to perform automated
    rolling updates to new versions.
  prefs: []
  type: TYPE_NORMAL
- en: Nodes in a swarm use secure encryption for all communication, using trusted
    certificates for each node. You can store application secrets as encrypted data
    in the swarm too, so database connection strings and API keys can be saved securely,
    and the swarm will deliver them only to the containers that need them.
  prefs: []
  type: TYPE_NORMAL
- en: Docker is an established platform. It was new to Windows Server in 2016, but
    it arrived on Windows after four years of releases on Linux. Docker is written
    in Go, which is a cross-platform language, and only a minority of code is specific
    to Windows. When you run Docker on Windows, you're running an application platform
    that has had years of successful production use.
  prefs: []
  type: TYPE_NORMAL
- en: A note on Kubernetes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker Swarm is a very popular container orchestrator, but it isn't the only
    one. Kubernetes is one alternative that has seen huge growth, with most public
    clouds now offering a managed Kubernetes service. At the time of writing this
    book, Kubernetes is a Linux-only orchestrator, with Windows support still in beta.
    You are likely to hear a lot about Kubernetes on your container journey, so it's
    worth understanding how it compares to Docker Swarm.
  prefs: []
  type: TYPE_NORMAL
- en: First, the similarities – they are both container orchestrators, which means
    they are clusters of machines that take care of running containers in production
    at scale. They both run Docker containers, and you can use the same Docker images
    with Docker Swarm and Kubernetes. They are both built on open source projects
    and conform to the **Open Container Initiative** (**OCI**), so there's no concern
    about vendor lock-in. You can start with Docker Swarm and then move to Kubernetes,
    and vice versa, without changing your apps.
  prefs: []
  type: TYPE_NORMAL
- en: Now, the differences. Docker Swarm is very simple; you can describe a distributed
    application to run in containers on swarm in just a few lines of markup. To run
    the same app on Kubernetes, your application description would be four times as
    much markup, or even more. Kubernetes has many more abstractions and configuration
    options than swarm, so there are some things you can do with Kubernetes that you
    can't do with swarm. The cost of that flexibility is complexity, and the learning
    curve for Kubernetes is very much steeper than for swarm.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes will support Windows soon, but it's not likely to offer full feature
    compatibility between Linux servers and Windows servers for some time. Until then,
    it's fine to use Docker Swarm – Docker has hundreds of enterprise customers running
    their production clusters on Docker Swarm. And if you do find Kubernetes has some
    extra features that you need, it will be much easier to learn Kubernetes once
    you have a good understanding of swarm.
  prefs: []
  type: TYPE_NORMAL
- en: Running Docker on Windows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's easy to install Docker on Windows 10, using *Docker Desktop* – a Windows
    package that sets up all the prerequisites, deploys the latest version of the
    Docker Community Engine, and gives you a UI with some useful options to manage
    image repositories and remote clusters.
  prefs: []
  type: TYPE_NORMAL
- en: In production, you should ideally use Windows Server 2019 Core, the installation
    with no UI. This reduces the attack surface and the amount of Windows updates
    your server will need. If you move all your apps to Docker, you won't need any
    other Windows features installed; you'll just have Docker Engine running as a
    Windows service.
  prefs: []
  type: TYPE_NORMAL
- en: I'll walk through both of these installation options and show you a third option
    using a VM in Azure, which is useful if you want to try Docker but don't have
    access to Windows 10 or Windows Server 2019.
  prefs: []
  type: TYPE_NORMAL
- en: There is a fantastic online Docker playground called Play with Docker at [https://dockr.ly/play-with-docker](https://dockr.ly/play-with-docker).
    Windows support is expected soon, and it's a great way to try Docker without having
    to make any investment – you just browse the site and get started.
  prefs: []
  type: TYPE_NORMAL
- en: Docker Desktop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker Desktop is available from Docker Hub – you can find it by navigating
    to [https://dockr.ly/docker-for-windows](https://dockr.ly/docker-for-windows).
    You can choose between the **Stable channel** and the **Edge channel**. Both channels
    give you the community Docker Engine, but the Edge channel follows the monthly
    release cycle, and you will get experimental features. The Stable channel tracks
    the Docker Engine release cycle, with quarterly updates.
  prefs: []
  type: TYPE_NORMAL
- en: You should use the Edge channel in development if you want to work with the
    latest features. In test and production, you will use Docker Enterprise, so you
    need to be careful that you don't use features in development, which are not yet
    available in Enterprise. Docker recently announced **Docker Desktop Enterprise**,
    which lets developers run the exact same engine locally as their organization
    is running in production.
  prefs: []
  type: TYPE_NORMAL
- en: 'You need to download and run the installer. The installer will verify that
    you can run Docker in your setup and will configure the Windows features needed
    to support Docker. When Docker is running, you will see a whale icon in the notification
    bar, which you can right-click on for options:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/3b868f4a-752c-4445-94c1-93403f042d4a.png)'
  prefs: []
  type: TYPE_IMG
- en: You need to select Switch to Windows containers... before you do anything else.
    Docker Desktop on Windows can run Linux containers by running Docker inside a
    Linux VM on your machine. This is great for testing out Linux apps to see how
    they run in containers, but this book is all about Windows containers – so switch
    over, and Docker will remember this setting in future.
  prefs: []
  type: TYPE_NORMAL
- en: 'While Docker for Windows is running, you can open Command Prompt or a PowerShell
    session and start working with containers. First, verify that everything is working
    as expected by running `docker version`. You should see an output similar to this
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The output tells you the version of the command-line client and the Docker Engine.
    The operating system field should read *Windows* for both; if not, then you may
    still be in Linux mode, and you'll need to switch to Windows containers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now run a simple container with the Docker CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This uses a public image on Docker Hub – one of the sample images for this book,
    which Docker will pull the first time you use it. If you don't have any other
    images, this will take a few minutes, as it will also download the Microsoft Nano
    Server image, which my image uses as a base. When the container runs, it shows
    some ASCII art and then exits. Run the same command again, and you will see that
    it executes much more quickly as the images are now cached locally.
  prefs: []
  type: TYPE_NORMAL
- en: 'Docker Desktop checks for updates when it starts and will prompt you to download
    a new version when it''s ready. You can keep your Docker tools up to date just
    by installing new versions when they''re released. You can check the current versions
    you have installed by selecting **About Docker Desktop** from the taskbar menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/fdd0cd57-b688-4ead-9e85-e97216e4d720.png)'
  prefs: []
  type: TYPE_IMG
- en: That's all the setup you need. Docker Desktop also contains the Docker Compose
    tool I'll be using later in the book, so you're all set to follow along with the
    code samples.
  prefs: []
  type: TYPE_NORMAL
- en: Docker Engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker Desktop is great for developing with containers on Windows 10\. For production
    environments where you have a headless server with no UI, you install Docker Engine
    to run as a background Windows Service using a PowerShell module.
  prefs: []
  type: TYPE_NORMAL
- en: 'On a new installation of Windows Server 2019 Core, use the `sconfig` tool to
    install all the latest Windows updates, and then run these PowerShell commands
    to install the Docker Engine and Docker CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This will configure the server with the necessary Windows features, install
    Docker, and set it up to run as a Windows service. Depending on how many Windows
    updates were installed, you may need to reboot the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'When the server is online, confirm that Docker is running with `docker version`,
    and then run a container from the sample image for this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'You can update your server when a new version of Docker Engine is released
    by repeating the `Install` command, and adding the `-Update` flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: I use this configuration for some of my environments – running Windows Server
    2019 Core in a lightweight VM that only has Docker installed. You can use Docker
    on the server by connecting with Remote Desktop, or you can configure the Docker
    Engine to allow remote connections, which lets you manage Docker containers on
    your server using `docker` commands on your laptop. This is a more advanced setup,
    but it does give you secure remote access.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s best to set up the Docker Engine so that communication with the client
    is secured using TLS, the same encryption technique used by HTTPS. Clients can
    only connect if they have the right TLS certificates to authenticate with the
    service. You can set this up by running these PowerShell commands inside the VM,
    supplying the VM''s external IP address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Don't worry too much about what this command is doing. Over the next few chapters,
    you'll get a good understanding of all these Docker options. I'm using a Docker
    image based on one from Stefan Scherer, who is a Microsoft MVP and Docker Captain.
    The image has a script that secures the Docker Engine with TLS certificates. You
    can read more details on Stefan's blog at [https://stefanscherer.github.io](https://stefanscherer.github.io).
  prefs: []
  type: TYPE_NORMAL
- en: When this command completes, it will have configured the Docker Engine API to
    allow only secure remote connections and will also have created the certificates
    that the client needs to use to connect. Copy these certificates from `C:\certs\client`
    on the VM onto the machine where you want to use the Docker client.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the client machine, you can set environment variables to point the Docker
    client to use a remote Docker service. These commands will set up a remote connection
    to the VM (assuming you have used the same path for the certificate files on the
    client), as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: You can use this approach to securely connect to any remote Docker Engine. If
    you don't have access to Windows 10 or Windows Server 2019, you can create a VM
    on the cloud and connect to it using the same commands.
  prefs: []
  type: TYPE_NORMAL
- en: Docker in an Azure VM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Microsoft makes it easy to run Docker in Azure. They provide a VM image with
    Docker installed and configured and with the base Windows images already pulled
    so you can get started quickly.
  prefs: []
  type: TYPE_NORMAL
- en: For testing and exploring, I always use DevTest labs in Azure. It's a great
    feature for non-production environments. By default, any VMs you create in a DevTest
    lab will be turned off every evening, so you don't end up with a big Azure bill
    from a VM you have used for a few hours and forgotten to turn off.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can create a DevTest Lab through the Azure portal, and then create a VM
    from Microsoft''s VM image **Windows Server 2019 Datacenter with Containers**.
    As an alternative to the Azure portal, you can use the `az` command line to manage
    the DevTest lab. I''ve packaged `az` in a Docker image, which you can run in a
    Windows container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This runs an interactive Docker container that has the `az` command packaged
    and ready to use. Run `az login`, and you''ll need to open a browser and authenticate
    the Azure CLI. Then, you can run this in the container to create a VM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The VM uses the full Windows Server 2019 installation with the UI, so you can
    connect to the machine with Remote Desktop, open a PowerShell session, and start
    using Docker right away. Just as with the other options, you can check whether
    Docker is running with `docker version` and then run a container from the sample
    image for this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: If an Azure VM is your preferred option, you can follow the steps from the previous
    section to secure the Docker API for remote access. This way you can run the Docker
    command line on your laptop to manage containers on the cloud. The Azure VM deploys
    Docker using PowerShell, so you can update the Docker Engine on your VM using
    the `InstallPackage ... -Update` command from the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: All these options – Windows 10, Windows Server 2019, and the Azure VM – can
    run the exact same Docker images with the same result. The sample application
    in the Docker image, `dockeronwindows/ch01-whale:2e`, behaves in the same way
    on every environment.
  prefs: []
  type: TYPE_NORMAL
- en: Learning about Docker with this book
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every code listing in this book is accompanied by a full code sample on my GitHub
    repository at [https://github.com/sixeyed/docker-on-windows](https://github.com/sixeyed/docker-on-windows).
    There's a branch for this edition of the book, called `second-edition`. The source
    tree is organized into a folder for each chapter, and for each chapter there's
    a folder for each code sample. In this chapter, I've used three samples to create
    Docker images, which you'll find in `ch01\ch01-whale`, `ch01\ch01-az`, and `ch01\ch01-dockertls`.
  prefs: []
  type: TYPE_NORMAL
- en: The code listings in this book may be condensed, but the full code can always
    be found in the GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: I prefer to follow along with code samples when I'm learning a new technology,
    but if you want to use working versions of the demo applications, every sample
    is also available as a public Docker image on Docker Hub. Wherever you see a `docker
    container run` command, the image already exists on Docker Hub, so you can use
    mine rather than building your own if you wish. All the images in the `dockeronwindows`
    organization, like this chapter's `dockeronwindows/ch01-whale:2e`, were built
    from the relevant Dockerfile in the GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: My own development environment is split between Windows 10, where I use Docker
    Desktop, and Windows Server 2019, where I run Docker Enterprise Engine. My test
    environment is based on Windows Server 2019 Core, where I also run Docker Enterprise
    Engine. I've verified all the code samples in this book on all of these environments.
  prefs: []
  type: TYPE_NORMAL
- en: I'm using version 18.09 of Docker, which is the latest release at the time of
    writing. Docker has always been backward-compatible, so if you're using a version
    later than 18.09 with Windows 10 or Windows Server 2019, then the sample Dockerfiles
    and images should work in the same way.
  prefs: []
  type: TYPE_NORMAL
- en: My goal is for this to be the definitive book about Docker on Windows, so I've
    covered everything from a 101 on containers, through modernizing .NET apps with
    Docker and the security implications of containers, to CI/CD and administration
    in production. The book ends with a guide to moving forward with Docker in your
    own projects.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to discuss the book or your own Docker journey with me, feel free
    to ping me on Twitter at `@EltonStoneman`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter I introduced Docker, an application platform which can run
    new and old apps in lightweight units of compute called containers. Companies
    are moving to Docker for efficiency, security, and portability. I covered the
    following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: How Docker works on Windows and how containers are licensed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The key Docker concepts: images, registries, containers, and orchestrators.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The options to run Docker on Windows 10, Windows Server 2019, or Azure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you're planning to work along with the code samples in the rest of the book,
    you should have a working Docker environment by now. In [Chapter 2](5b6871d5-15a7-4dc2-9b7e-29a802491f24.xhtml),
    *Packaging and Running Applications as Docker Containers,* I'll move onto packaging
    more complex apps as Docker images and show how to manage states in containers
    with Docker volumes.
  prefs: []
  type: TYPE_NORMAL
