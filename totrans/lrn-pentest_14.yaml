- en: Antivirus Evasion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The concept of having antivirus software is nothing new. It is a common security
    control that's used to protect users against malware and other types of malicious
    software. Historically, it has been focused purely on the prevention of virus
    infections. In your penetration testing engagements, finding a customer who doesn't
    have an antivirus is extremely rare to almost impossible.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn about the evolution of antivirus technologies
    and how they are becoming more sophisticated. You will learn about various techniques
    that you can leverage for antivirus evasion, and also learn about the tools that
    can help you utilize those techniques. You will learn how to encode payloads to
    avoid detection and, finally, explore the online tools that can be used to check
    the detection rate of your payload.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you progress through this chapter, you will learn about the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The evolution of antivirus technologies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Concepts of antivirus evasion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting started with antivirus evasion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing evasion techniques
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To follow along with the examples and instructions in this chapter, please
    check that you have the following technical requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: Kali Linux 2019.1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The evolution of antivirus technologies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The threat landscape is evolving at a rapid pace. Over the past few years, there
    have been attack vectors such as automated attacks, fileless malware, firmware-based
    malware, **advanced persistent threat** (**APT**) malware, and, let's not forget,
    sophisticated ransomware. Attackers have a repertoire of attacks that can leverage
    artificial intelligence and machine learning at their disposal. Based on these
    advancements in attacks, antiviruses had to catch up.
  prefs: []
  type: TYPE_NORMAL
- en: Out with the old
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The traditional antivirus, which served the purpose of simply stopping viruses
    based on signatures and looking for changes in filesystems or applications based
    on patterns, is no longer sufficient. Even though signatures and pattern-based
    matching is still used today, there are weaknesses that exist. For example, failure
    to update the signatures, or keeping up with the large amount of malware that
    is released daily poses a massive risk. Heuristic scanning is the ability of an
    antivirus to analyze code against a set of variables that will indicate whether
    a virus exists. This approach enables the detection of an additional set of viruses,
    but it can also be circumvented as the variables can be modified. The scanning
    and interception abilities of the antivirus has its benefits, but these too can
    be bypassed.
  prefs: []
  type: TYPE_NORMAL
- en: Malware that exists now grows too rapidly for antivirus manufacturers to keep
    up with it.
  prefs: []
  type: TYPE_NORMAL
- en: In with the new
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Today's antiviruses have evolved by having the ability to detect and prevent
    hidden exploits, leverage threat intelligence, have full visibility of the endpoints
    (including applications, processes, and memory), alert automation, forensic capabilities,
    and data collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Antiviruses in this day and age can be called next-generation antiviruses,
    and use tactics such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Look at exploit techniques that block a process that is using a typical method
    to bypass a normal process operation. This method does not consider the file type
    but the process itself.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Machine learning techniques that can be used to learn hundreds of variants of
    a specific malicious file; a task which, in the older antivirus, would need some
    human interaction and a sandbox environment to test each variant.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detection capabilities that look further than the disk. Malware such as fileless
    malware doesn't drop anything on disk. Traditional antivirus software is unable
    to detect this, but the next generation of antiviruses can.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Artificial intelligence, whose role is to decrease human intervention further
    by enabling the antivirus to identify patterns, relate this to a threat, and update
    its own database with the new pattern.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It may seem that these next-generation antiviruses make it impossible to evade,
    but it is still possible. As its defense capabilities get better, so do the offensive
    tools that we can make use of.
  prefs: []
  type: TYPE_NORMAL
- en: Concepts of antivirus evasion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'During the exploitation phase of your penetration test, you will need to get
    code to run on your target system. This can be done via phishing emails, an exploit,
    or social engineering. The blocker that you will have is antivirus software (be
    it the traditional variant or the next-generation variant). The most effective
    way to bypass an antivirus is to create your own customized payload. Before we
    dive into creating the payloads, let''s consider a few tips:'
  prefs: []
  type: TYPE_NORMAL
- en: Reconnaissance plays an important role in antivirus evasion. Knowing what your
    target has is key. If you feel that you want to have a customized payload that
    avoids all antivirus products, you are misleading yourself. The time spent to
    achieve this will be too long, and with every vendor actively making improvements
    to their products, your payload will be detectable in no time at all. Narrow down
    your payload to your target's antivirus.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once you have a working shellcode, you might reuse it again in later penetration
    tests, and it may still work. To ensure that you reduce the detection capabilities
    of your exploit, never submit it to services such as VirusTotal (this will be
    covered later in this chapter) or any other online scanners. These online resources
    usually submit the samples to antivirus vendors, who, in turn, use it to amp up
    their detection capabilities.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simplicity is key. Don't go for glamorous payloads with loads of features. Remember,
    you are just trying to disable the antivirus and then use more powerful tools.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use resources that are available to you. For example, Metasploit has modules
    that can be used for antivirus evasion. Online resources such as ExploitDB have
    shellcodes that can be downloaded, customized, and used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keeping these tips in mind will help as you progress through your penetration
    testing career, as you have a good starting point in terms of what to consider
    when planning antivirus evasion.
  prefs: []
  type: TYPE_NORMAL
- en: Antivirus evasion techniques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have established the need for antivirus evasion, let's look at the
    various techniques that exist. The following are the most common techniques that
    can be used.
  prefs: []
  type: TYPE_NORMAL
- en: Encoders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Encoders allow you to avoid characters within an exploit that cause it to malfunction.
    By using MSFvenom, you have access to a number of encoders. Encoding works by
    tearing apart the payload and adding in additional code to mask the real payload.
    There are decoding instructions that get added into the payload so that before
    it is run, it can be decoded. MSFvenom has some built-in encoders, which we will
    look at later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Custom compiling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using the built-in encoders of MSFvenom is not as efficient as we would want
    it to be. Metasploit and its components are a constant highlight to antivirus
    manufacturers, and they keep a close watch on the improvements that are made to
    encoders within it. To get around this, you can leverage custom compiling to create
    an undetectable payload. Looking at the C programming language, there are some
    key components that you could leverage to add randomness to your code in an effort
    to trick antivirus programs into not detecting it.
  prefs: []
  type: TYPE_NORMAL
- en: Obfuscation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Obfuscation is the process of modifying the payload so that it's unclear to
    the antivirus, yet it is still usable for its intended purpose. One way of obfuscating
    your payload is using encryption. A tool such as Hyperion (which we will cover
    later) can be used to encrypt the payload using **Advanced Encryption Standard**
    (**AES**). Once the payload is run, decryption takes place and the payload is
    able to execute. This encryption helps reduce the detection rate by antiviruses.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, since antiviruses are constantly getting better, it's simply not
    possible to use just one method of evasion. There is no **silver bullet** for
    antivirus evasion. You will need to combine a few techniques to help reduce the
    detection rate of your payload.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with antivirus evasion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When conducting a penetration test, there is a level of trust that is defined
    between you and your client. When you drop any payloads into their environment,
    such as evading the antivirus to create a backdoor to your system, you need to
    ensure that the payload connects back to you only. There shouldn't be any bugs
    in the code that could lead to a real compromise of the client's environment.
  prefs: []
  type: TYPE_NORMAL
- en: As you work through the various tools that are defined in this section, please
    ensure that you explicitly define your system's IP that the target would connect
    back to. Doing so will ensure that you enforce the concept of trust in the initial
    learning steps of your career.
  prefs: []
  type: TYPE_NORMAL
- en: MSFvenom
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MSFvenom is a command-line tool and is part of the Metasploit Framework. It
    is used to generate various shellcodes that can be used to provide a backdoor
    into a system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the common switches within MSFvenom are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `-l` | This is used to display a list of all modules within each category
    (encoders, payloads, formats, encrypters, and more). For example, using `msfvenom
    -l payloads` will display the current set of payloads available. |'
  prefs: []
  type: TYPE_TB
- en: '| `-p` | This defines the payload that will be used. For example, using the `msfvenom
    -p windows/x64/meterpreter_reverse_https` command will define the meterpreter
    reverse HTTPS payload. |'
  prefs: []
  type: TYPE_TB
- en: '| `-f` | This defines the output format. For example, you may want to create
    an `.exe` or `.c` file. |'
  prefs: []
  type: TYPE_TB
- en: '| `-b` | This is used to eliminate bad characters. Antiviruses look for bad
    characters such as `\x00`. |'
  prefs: []
  type: TYPE_TB
- en: '| `-e` | This is used to define the encoder that will be used. For example,
    one of the commonly used encoders is `/x86/shikata_ga_nai`. |'
  prefs: []
  type: TYPE_TB
- en: '| `-i` | This is used to define the maximum number of times to encode the shellcode.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `-a` | This is used to define the architecture. For example, `-a x64` will
    create a 64-bit shellcode. |'
  prefs: []
  type: TYPE_TB
- en: '| `--platform` | This is used to define the platform that the shellcode will
    target. For example, `--platform Windows` for Windows operating systems. |'
  prefs: []
  type: TYPE_TB
- en: MSFvenom has a lot more options and switches; the preceding table describes
    what you would commonly use when creating a payload.
  prefs: []
  type: TYPE_NORMAL
- en: MSFvenom allows you to chain multiple commands together. This is done using
    the `| \` sequence at the end of each command.
  prefs: []
  type: TYPE_NORMAL
- en: To create the payload using a chain of commands, follow these steps. Take note
    of the `| \` sequence at the end of each command.
  prefs: []
  type: TYPE_NORMAL
- en: 'From a Terminal window, enter the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'When you have completed entering the preceding commands, you should get the
    following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6371948d-f93c-4879-b68a-e4bbf90c0ffd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1: MSFvenom commands chained'
  prefs: []
  type: TYPE_NORMAL
- en: In the first line of the command, we are defining the `meterpreter/reverse_tcp`
    payload to be used. We then define our attacking host's IP (`LHOST`) and port
    (`LPORT`). We then use the raw format (`-f`), and use the `shikata_ga_nai` encoder
    (`-e`) with 15 iterations (`-i 15`).
  prefs: []
  type: TYPE_NORMAL
- en: In the second line of the command, we further encode the raw file by now defining
    the architecture (`-a`), the platform, which is Windows (`--platform`) in this
    case, and the `x86/countdown` encoder with 9 iterations.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we compile this by running the `shikata_ga_nai` encoder again and creating
    an `exe` file using the `-f exe -o` option.
  prefs: []
  type: TYPE_NORMAL
- en: Once the command executes, it will create a backdoor file called `MSFV-payload.exe`,
    which is stored in the `/root/Downloads/` folder.
  prefs: []
  type: TYPE_NORMAL
- en: We will test this file's detection rate in the *Testing evasion techniques* section
    later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Veil Evasion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Veil Evasion set of tools can be used to create shellcode that would evade
    common antiviruses, and generate a reverse shell.
  prefs: []
  type: TYPE_NORMAL
- en: 'Installing the Veil suite of tools can be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Open a Terminal window in Kali Linux.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `apt install -y veil` command. This will download the Veil suite of
    tools, all dependencies, and prepare them for installation. The `-y` command is
    used to simply predefine the `yes` parameter when we are asked whether we want
    to install the software.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once everything has been downloaded, you can kick off the installation by running
    the `veil`command (see the following screenshot). Use the `s`option for silent
    installation. This will still show you what components are being installed, but
    there will be no interaction required from your side:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/08de093e-1133-458c-8311-059b417ff79f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2: Installing the components of Veil'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the installation of Veil has completed, you can run the tool by using
    the `veil` command from a Terminal window. On the first launch, you will be presented
    with the main window (see the following screenshot), which will show you the two
    tools that have been loaded. Using a specific tool is done using the `use [number]` command;
    for example, to use `Evasion`, you would use the `use 1` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/70b7e294-9cf5-4dda-8881-ac36eb613fc9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3: The Veil initial menu'
  prefs: []
  type: TYPE_NORMAL
- en: 'The tools that we have available are `Evasion` and `Ordnance`. These two tools
    perform different functions, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Evasion`: Thisis used to generate a payload that can be used to bypass the
    antivirus.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Ordnance`: This is used to generate shellcode that can be used with `Evasion`.
    `Ordnance` eliminates the need to use MSFvenom for shellcode generation. The reason
    for this is that as MSFvenom is updated, it would break the payloads created by
    `Evasion`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s create a malicious payload using Veil:'
  prefs: []
  type: TYPE_NORMAL
- en: Start `Veil` using the `veil` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once `Veil` has started, we will use the `Evasion` tool. Type in `use 1`*:*
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/727626f6-02a6-4656-b1d7-a9df8f0fd8d5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4: Selecting the Evasion tool'
  prefs: []
  type: TYPE_NORMAL
- en: To view the full list of payloads, enter the `list payloads` command. At the
    time of writing, there are 41 payloads available within Veil Evasion. We will
    create a payload using `python/shellcode_inject/aes_encrypt.py`*. *To select this
    payload, we will use the number associated with it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To use the payload, we will issue the `use 29` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/23932785-5731-4520-9af1-986c3327a0ba.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5: Selecting the payload'
  prefs: []
  type: TYPE_NORMAL
- en: Within the payload, we have a number of options that can be configured. If you
    want to configure these, we can do so using the `set [option name] [value]` command.
    For example, to configure the `CLICKTRACK` option, you will use the `set CLICKTRACK
    1` command. We won't configure any options for now, so we will type `generate`
    to proceed to the next step.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now we have options related to the shellcode (see the following screenshot).
    Here, you will notice that we can leverage `MSFVenom`, `Ordnance`, `Custom shellcode
    strings`, and more. We will use `Ordnance` to create the shellcode. Enter choice
    number `1`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c9a4e95a-3fac-47d8-b85f-bc67d2ba15df.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6: The shellcode selection'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you enter option `1`, you are taken to the `Veil-Ordnance` menu (see the
    following screenshot). Here, you have a few options, such as viewing the `payloads`
    and `encoders`. To view the payloads, enter the `list payloads`command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/47dfbafd-4a98-49ee-830c-1a6d2f01b14a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7: Ordnance payloads'
  prefs: []
  type: TYPE_NORMAL
- en: We will use the `rev_https` payload by using the `use 3` command to select it.
    Now we are presented with options for the payload.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will need to define some options here. Define the `LHOST` and `LPORT` variables.
    Remember that this is the IP address and port that the target machine will connect
    back to. I have also defined the `Encoder` to use the built-in `xor` command.
    You can define these settings using the `set` command. Your output should look
    similar to the following, with the exception of the `LHOST` IP address:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/3ff3e746-e355-4e35-9528-612f332652b7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8: Defining the payload options'
  prefs: []
  type: TYPE_NORMAL
- en: 'Type `generate` to generate the shellcode. You will now see the output of the
    shellcode, and Veil will ask you for a filename (see the following screenshot)*.*
    Give it a name and press *Enter*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/0066bdbf-42cc-43f3-b926-6aad1191e2e4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9: The generated shellcode'
  prefs: []
  type: TYPE_NORMAL
- en: Once you have provided the base name for the output files, you will have a choice
    to select an option to create the payload executable. For this demo, we will use
    the default of `PyInstaller`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the process completes, you will have the locations of the malicious executable
    and source code displayed*:*
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/19878fa6-b381-4360-8811-7dbdfb9f92ff.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10: The malicious executable created'
  prefs: []
  type: TYPE_NORMAL
- en: By running this executable on the target machine, it will create a backdoor
    reverse shell to the machine that you are using as the attacker. Of course, we
    still need to determine whether this executable will be detected by any antiviruses.
    We will perform the testing in the *Testing evasion techniques* section of this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: TheFatRat
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'TheFatRat is another tool that can be used to generate undetectable payloads.
    It supports payloads for Windows, Android, and macOS. It has a wealth of options,
    such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Automating Metasploit functions (creating backdoors, antivirus evasion, starting
    meterpreter listens, and more)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating backdoors based on Android APKs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: File pumper (used to increase file size)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating backdoors using office files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'TheFatRat is not included by default with Kali Linux. It can be installed using
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a Terminal window within Kali Linux and clone the repository for `TheFatRat`
    using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the repository is cloned, navigate to the directory using the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Change the file permissions and run the setup script using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In this command, we are changing the permissions of the `setup.sh` file so that
    we can run it.
  prefs: []
  type: TYPE_NORMAL
- en: During the setup process, all dependencies will be installed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the installation is completed, you can run TheFatRat using the `fatrat`
    command.
  prefs: []
  type: TYPE_NORMAL
- en: During startup, TheFatRat provides a warning about not uploading your generated
    payloads to VirusTotal. We will discuss this later in this chapter, under the *Testing
    evasion techniques* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a payload using `TheFatRat`:'
  prefs: []
  type: TYPE_NORMAL
- en: From a Terminal window, launch `TheFatRat` by using the `fatrat` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once the menu has loaded, you will notice there are a few options that can
    be used:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/afe68a7d-c555-4d9f-ad72-5cce6fa78fea.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11: TheFatRat main menu'
  prefs: []
  type: TYPE_NORMAL
- en: Select option `2` to create a `Fud` with `Fudwin`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Fud` is an abbreviation of **Fully Undetectable Payload**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the `Fudwin` module has loaded, we have two options. We will select option
    `2` – `Slow but Powerfull`. This tool compiles a C program with a meterpreter
    reverse TCP payload:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/136c4a48-c207-442e-a382-50b22740a19c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12: Tool selection using the Fudwin module'
  prefs: []
  type: TYPE_NORMAL
- en: Once you have selected option `2`, you will need to define the `LHOST` and `LPORT`
    options. Next, you will need to select the architecture of the target operating
    system. This can be `x86` or `x64`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the options are defined, the tool will take care of the rest. It will compile
    the malicious payload into an executable, which will be stored within the `TheFatRat`
    root folder within the `output` directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the file is run on the remote system, it will create a reverse `tcp` backdoor
    to the attacking machine. In the *Testing evasion techniques* section, we will
    compare this payload's detection rate to the others we have created.
  prefs: []
  type: TYPE_NORMAL
- en: Custom compiling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Custom compiling can help reduce detection capabilities drastically. You can
    leverage custom shellcodes that are available on the internet and tweak them,
    if needed, to perform the function you are after.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will cover the creation of a custom shellcode at a basic
    level. The creation of shellcode can become complex and, as you progress in your
    penetration testing career, you will build up your skills to write complex shellcodes.
    We will be covering shellcode creation in the C programming language.
  prefs: []
  type: TYPE_NORMAL
- en: Websites such as Exploit-DB host a number of shellcodes that are posted by the
    community. This can be accessed via the following URL: [https://www.exploit-db.com/shellcodes](https://www.exploit-db.com/shellcodes).
  prefs: []
  type: TYPE_NORMAL
- en: Let's create a custom shellcode using C.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin, we will create a shellcode file using MSFvenom. Let''s use the same
    shellcode we created earlier, but, this time, we will output it to a `.C` file:'
  prefs: []
  type: TYPE_NORMAL
- en: From a Terminal window, create a new directory using the `mkdir msfv-shellcode`
    command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory using the `cd msfv-shellcode` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, create the payload using the following commands, which are chained:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Once you have executed the preceding commands, MSFvenom will create the shellcode
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we need to add in a few variables so that we can compile this using the
    C programming language. Edit the `MSFV-shellcode.c` file that was just created
    using a text editor or nano.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add in the following lines, which are marked in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, I cut out the shellcode so that the required lines of
    code are visible. In your shellcode file, you will have a lot more characters
    underneath the `unsigned char buf [] =` line.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding code, we added the following components:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `#include<stdio.h>` | Here, we are calling a library that refers to input
    and output functions. |'
  prefs: []
  type: TYPE_TB
- en: '| `#include<string.h>` | Here, we are calling a library to manipulate strings,
    since we are using the `strlen` function for string length.  |'
  prefs: []
  type: TYPE_TB
- en: '| `int main` | This string is used to declare a function. Within the C programming
    language, the function under `main` is what is run when the program loads. |'
  prefs: []
  type: TYPE_TB
- en: '| `printf("Shellcode Length: %d\n` | This line is used to send a printed output
    and mask the shellcode length. |'
  prefs: []
  type: TYPE_TB
- en: '| `int (*ret)() = (int(*)())buf;`'
  prefs: []
  type: TYPE_NORMAL
- en: '`ret ()` | `int (*ret)()` is used to declare a pointer, while `=(int(*)())buf;`
    is the pointer that will be used. `ret()` is calling that pointer, which then
    points to the shellcode that is run. |'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have added in the additional code, we can now compile this into an
    executable file (see the following screenshot). This is done using the `mingw32`
    compiler, which would have been installed when you installed the Veil Framework.
    If this is not installed, you can install it using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'To compile the shellcode into an executable, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/75202425-ab4d-48e8-9d87-660c5000de56.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13: Compiling the shellcode into an executable'
  prefs: []
  type: TYPE_NORMAL
- en: Now, you have an executable that will create a reverse shell. Using the process
    of custom compiling, you can dramatically reduce the detection rate of antiviruses.
    You can further obscure the detection rate by adding in additional random characters.
  prefs: []
  type: TYPE_NORMAL
- en: Testing evasion techniques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing your payload can be done in two ways. One way is to test it in a lab
    environment with a replica of the target's system; however, this is not always
    possible as there might be licensing requirements for the antivirus program that
    your client is using.
  prefs: []
  type: TYPE_NORMAL
- en: The other option you have is to submit the sample of the payload to online services
    such as VirusTotal.
  prefs: []
  type: TYPE_NORMAL
- en: VirusTotal
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: VirusTotal is used by many in the security industry to submit files or URLs
    for malware analysis. VirusTotal works by cross-checking the submission with over
    70 antivirus vendors. There is one catch with VirusTotal, and that is that the
    submission is shared with antivirus vendors to help improve their detection capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: When you build your own payload, you won't want this to be shared with the antivirus
    manufacturers. If it is shared, the chances of your payload working reduces dramatically,
    as the detection rate will increase once the antivirus manufacturers use the submission
    signals to update their detection capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'VirusTotal can be accessed via the following URL: [https://www.virustotal.com/](https://www.virustotal.com/).'
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at the payloads we created in the previous section, as well
    as their detection rates.
  prefs: []
  type: TYPE_NORMAL
- en: '**MSFvenom** had a detection rate of 50 out of 71, even though we used two
    encoders with multiple iterations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/37d73c2e-6147-47ad-ad77-9edb03c4ddbc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14: The detection rate of the MSFvenom-generated shellcode'
  prefs: []
  type: TYPE_NORMAL
- en: 'Testing the custom shellcode that we have created using the same MSFvenom payload
    produced a significantly lower detection rate of 8 out of 70:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6297be12-3fb6-4bac-b1d4-ad7b1c398010.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15: Custom shell code detection rate.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Veil **had a detection rate of 35 out of 70*.* This is much lower than the
    one that was generated using MSFvenom:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eb16fe0b-1e86-4d8d-92a9-ee7bd40fff7f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16: The detection rate of the Veil-generated shellcode'
  prefs: []
  type: TYPE_NORMAL
- en: 'TheFatRat had a detection rate of 6 out of 70*.* This is far lower than both
    MSFvenom and Veil. Notice that the filename is `Powerfull-fud.exe`; TheFatRat
    would have generated a normal `Powerfull.exe` file, which can also be used. That
    one received a detection rate of 8 out of 70:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/70a5cb1e-eae7-4f00-9d99-ec37fbc038a9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17: The detection rate of the TheFatRat-generated shellcode'
  prefs: []
  type: TYPE_NORMAL
- en: We can see here that different techniques produce different results. As antiviruses
    evolve, producing a fully undetectable payload gets more difficult. However, knowing
    how to use the tools that are available will help you build a payload that is
    tailored to your target and is undetectable by their antivirus software.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you have learned about the evolution of antiviruses, and how
    they are now starting to make use of machine learning and artificial intelligence.
    You have learned about the various techniques that can be used for evading antiviruses,
    and the different tools that can be used to create undetectable payloads. We have
    created some payloads using shellcode and looked at their detection rate using
    online services such as VirusTotal.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter ([Chapter 12](e4dd2f7e-f929-4877-aef7-e97f1c359784.xhtml),
    *Maintaining Control within the Environment*), we will discuss persistence and
    how to maintain access in the compromised network.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How have antiviruses evolved?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name two antivirus evasion techniques.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What tools can be leveraged to build undetectable payloads?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the benefits of using a custom-compiled shellcode?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What should you never do once you have built your payload?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
