- en: Chapter 3. Sharing is Caring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '|   | *"Data really powers everything that we do."* |   |'
  prefs: []
  type: TYPE_TB
- en: '|   | --*– Jeff Weiner, LinkedIn* |'
  prefs: []
  type: TYPE_TB
- en: In the last chapter, we started programming our very own contact manager. We
    came across various building blocks of a database-centric application; we covered
    database handlers and building queries in order to get meaningful data from our
    database. We also explored how to make a connection between our UI and database
    and present it in a consumable manner for the end user.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will learn how to access other application's data via means
    of content providers. We will also learn how to build our very own content provider
    in order to share our data with other applications. We will look into Android's
    providers such as **contactprovider**. To wrap things up, we will construct a
    test application to use our newly constructed content provider.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What is a content provider?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a content provider
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the core methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a content provider
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is a content provider?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A content provider is the fourth component of an Android application. It is
    used to manage access to a structured set of data. Content providers encapsulate
    the data, and provide abstraction and the mechanism to define data security. However,
    content providers are primarily intended to be used by other applications that
    access the provider using a provider's client object. Together, providers and
    provider clients offer a consistent, standard interface for data, which also handles
    interprocess communication and secure data access.
  prefs: []
  type: TYPE_NORMAL
- en: 'A content provider allows one app to share data with other applications. By
    design, an Android SQLite database created by an application is private to the
    application; it is excellent if you consider the security point of view, but troublesome
    when you want to share data across different applications. This is where a content
    provider comes to the rescue; you can easily share data by building your content
    provider. It is important to note that although our discussion will focus on a
    database, a content provider is not limited to it. It can also be used to serve
    file data that normally goes into files, such as photos, audio, or videos:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What is a content provider?](img/2951OS_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding diagram, notice how the interaction between Applications A
    and B happens while exchanging data. Here, we have an **Application A** whose
    activity needs to access the database of **Application B**. As we have already
    seen, the database of **Application B** is stored in the internal memory and cannot
    be directly accessed by **Application A**. This is where **Content Provider**
    comes into the picture; it allows us to share data and modify access to other
    applications. The content provider implements methods to query, insert, update,
    and delete data in databases. **Application A** now requests the content provider
    to perform some desired operations on behalf of it. We will explore both sides
    of the coin, but we will first use **Content Provider** to fetch contacts from
    a phone's contact database, and then we will build our very own content provider
    for others to pick data from our database.
  prefs: []
  type: TYPE_NORMAL
- en: Using existing content providers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Android lists a lot of standard content providers that we can use. Some of them
    are `Browser`, `CalendarContract`, `CallLog`, `Contacts`, `ContactsContract`,
    `MediaStore`, `userDictionary`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: In our current contact manager application, we will add a new feature. In the
    UI of the `AddNewContactActivity` class, we will add a small button to fetch contacts
    from a phone's contact list with help from the system's existing `ContentProvider`
    and `ContentResolver` providers. We will be using the `ContactsContract` provider
    for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: What is a content resolver?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `ContentResolver` object in the application's context is used to communicate
    with the provider as a client. The `ContentResolver` object communicates with
    the provider object—an instance of a class that implements `ContentProvider`.
    The provider object receives data requests from clients, performs the requested
    action, and returns the results.
  prefs: []
  type: TYPE_NORMAL
- en: '`ContentResolver` is a single, global instance in our application that provides
    access to other application''s content providers; we do not need to worry about
    handling interprocess communication. The `ContentResolver` methods provide the
    basic CRUD (create, retrieve, update, and delete) functions of persistent storage;
    it has methods that call identically named methods in the provider object but
    does not know the implementation. We will cover `ContentResolver` in more detail
    as we progress through this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: '![What is a content resolver?](img/2951_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding screenshot, notice the new icon on the right-hand side to
    add contacts directly from the phone contacts; we modified the existing XML to
    add the icon. The corresponding class `AddNewContactActivity` will also be modified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We added a new method `pickContact()` to prepare an intent in order to pick
    contacts. `Intent.ACTION_PICK` allows us to pick an item from a data source; in
    addition, all we need to know is the **Uniform Resource Identifier** (**URI**)
    of the provider, which in our case is `ContactsContract.Contacts.CONTENT_URI`.
    This functionality is also provided by Messaging, Gallery, and Contacts. If you
    look into the code from [Chapter 2](ch02.html "Chapter 2. Connecting the Dots"),
    *Connecting the Dots*, you will find we have used the same code to pick images
    from Gallery. The Contacts screen will pop up allowing us to browse or search
    for contacts we require to migrate to our new application. Notice `onActivityResult`,
    that is, our next stop we will modify this method to handle our corresponding
    request to handle contacts. Let us look at the code we have to add to pick contacts
    from an Android''s contact provider:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To add a little flair to your application, download the entire set of stencils,
    sources, the action bar icon pack, color swatches, and the Roboto font family
    from the Android developer site, [http://goo.gl/4Msuct](http://goo.gl/4Msuct).
    Designing a functional application is incomplete without a consistent UI that
    follows Android guidelines.
  prefs: []
  type: TYPE_NORMAL
- en: We start by checking whether the request code matches ours. Then, we cross-check
    `resultcode`. We get the `ContentResolver` object by making a call to `getcontentresolver`
    on the `Context` object; it is a method of the `android.content.Context` class.
    As we are in an activity that inherits from `Context`, we do not need to be explicit
    in making a call to it. The same goes for services. We will now verify whether
    the contact we picked has a phone number or not. After verifying the necessary
    details, we pull the data that we require, such as contact name and phone number,
    and set them in relevant fields.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a content provider
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A content provider provides access to data in two ways: one is structured data
    that goes in the form of a database, as the example we are working on currently,
    or in the form of file data, that is, data that goes in the form of pictures,
    audio, video, and so on stored in the private space of the application. Before
    we begin digging into how to create a content provider, we should also retrospect
    whether we need one. If we want to offer data to other applications, allow users
    to copy data from our app to another, or use the search framework in our application,
    then the answer is yes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like other Android components (`Activity`, `Service`, or `BroadcastReceiver`),
    a content provider is created by extending the `ContentProvider` class. Since
    `ContentProvider` is an abstract class, we have to implement the six abstract
    methods. These methods are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Usage |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `void onCreate()` | Initializes the provider |'
  prefs: []
  type: TYPE_TB
- en: '| `String getType(Uri)` | Returns the MIME type of data in the content provider
    |'
  prefs: []
  type: TYPE_TB
- en: '| `int delete(Uri uri, String selection, String[] selectionArgs)` | Deletes
    data from the content provider |'
  prefs: []
  type: TYPE_TB
- en: '| `Uri insert(Uri uri, ContentValues values)` | Inserts new data into the content
    provider |'
  prefs: []
  type: TYPE_TB
- en: '| `Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs,
    String sortOrder)` | Returns data to the caller |'
  prefs: []
  type: TYPE_TB
- en: '| `int update(Uri uri, ContentValues values, String selection, String[] selectionArgs)`
    | Updates the existing data in the content provider |'
  prefs: []
  type: TYPE_TB
- en: These methods will be dealt with in more detail later as we progress through
    the chapter and build our application.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding content URIs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Every data access method of `ContentProvider` has a content URI, as an argument
    that allows it to determine the table, row, or file to access. It generally follows
    the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Let's analyze the breakdown of the components of the `content://` URI. The scheme
    for content providers is always `content`. The colon and double-slash (`://`)
    act as a separator from the authority part. Then, we have the `authority` part.
    By rule, authorities have to be unique for every content provider. The naming
    convention the Android documentation recommends using is the fully qualified class
    name of your content provider subclass. Generally, it is built as a package name
    plus a qualifier for each content provider we publish.
  prefs: []
  type: TYPE_NORMAL
- en: The remaining part is optional, also referred to as **path**, and is used for
    segregation between different types of data our content provider can provide.
    A very good example is the `MediaStore` provider which needs to distinguish between
    audio, video, and image files.
  prefs: []
  type: TYPE_NORMAL
- en: Another optional part is `id`, which points to a specific record; depending
    on whether `id` is present or not, the URI becomes ID-based or directory-based,
    respectively. Another way to understand it would be that an ID-based URI enables
    us to interact with data individually at row level, whereas a directory-based
    URI enables us to interact with multiple rows of a database.
  prefs: []
  type: TYPE_NORMAL
- en: For example, consider `content://com.personalcontactmanager.provider/contacts`;
    we will encounter this soon enough as we move ahead with the chapter where we
    define how to access the content provider we are currently building.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'On a side note, the package name for applications should always be unique;
    this is because all the applications on Play Store are identified by their package
    name. All the updates for an application on Play Store need to have the same package
    name and be signed with the same keystore used initially. For instance, the following
    is the Play Store link of a Gmail application; notice that at the end of URL,
    we will find the package name of the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[play.google.com/store/apps/details?id=com.google.android.gm](http://play.google.com/store/apps/details?id=com.google.android.gm)'
  prefs: []
  type: TYPE_NORMAL
- en: Declaring our contract class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Declaring a contract is a very important part of building our content provider.
    This class, as the name suggests, will act as a contract between our content provider
    and the application that is going to access our content provider. It is a `public
    final` class, which contains constant definitions for URIs, column names, and
    other metadata. It can also contain Javadoc, but the biggest advantage is that
    the developer using it need not worry about the names of tables, columns, and
    constants, leading to less error-prone code.
  prefs: []
  type: TYPE_NORMAL
- en: The contract class provides us with the necessary abstraction; we can change
    the underlying operations as and when required and we can also change the corresponding
    data manipulation affecting other dependent applications. An important thing to
    note is that we need to be careful while changing the contract in future; if we
    are not careful, we might break the other applications that are using our contract
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our contract class looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '`AUTHORITY` is the symbolic name that identifies the provider among many other
    providers registered as part of an Android system. `BASE_PATH` is the path of
    the table. `CONTENT_URI` is the URI of the table encapsulated by the provider.
    `CONTENT_TYPE` is the Android platform''s base MIME type for content URI containing
    a cursor of zero or more items. `CONTENT_ITEM_TYPE` is the Android platform''s
    base MIME type for content URIs containing a cursor of a single item. `PROJECTION_ALL`
    and `Columns` contain the column IDs of the table.'
  prefs: []
  type: TYPE_NORMAL
- en: Without this information, other developers will not be able to access your provider
    even though it is open for access.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There can be many tables inside a provider and each should have a unique path;
    the path is not a real physical path but an identifier.
  prefs: []
  type: TYPE_NORMAL
- en: Creating UriMatcher definitions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`UriMatcher` is a utility class, which aids in matching URIs in content providers.
    The `addURI()` method takes the content URI patterns that the provider should
    recognize. We add a URI to match, and the code to return when this URI is matched:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We pass `authority`, a `path` pattern, and an integer value to the `addURI()`
    method of `UriMatcher`; it returns the `int` value, which we defined as constant
    when we tried to match patterns.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `UriMatcher` looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Notice that it also supports the use of wildcards; we have used hashtag (`#`)
    in the preceding code snippet, we can also use wildcards such as `*`. In our case,
    with the hashtag, `" content://com.personalcontactmanager.provider/contacts/2"`
    this expression matches, but using `* "content://com.personalcontactmanager.provider/contacts`
    it doesn't.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the core methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to build our content provider, the next step will be to prepare our
    core database access and data modifying methods, better known as CRUD methods.
    This is where the core logic of how we want to interact with our data depending
    on the insert, query, or delete calls received is specified. We will also implement
    the Android architecture's life cycle methods such as `onCreate()`.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing the provider through the onCreate() method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We create an object of our database manager class in `onCreate()`. There should
    be minimum operations in `oncreate()` as it runs on the Main UI thread, and it
    may cause lag for some users. It is good practice to avoid long-running tasks
    in `oncreate()` as it increases the startup time of the provider. It is even recommended
    to defer database creation and data loading until our provider actually receives
    a request for the data, that is, to move long-lasting actions to the CRUD methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Querying records through the query() method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `query()` method will return a cursor over the result set. The URI is passed
    to our `UriMatcher` to see whether it matches any patterns we defined earlier.
    In our switch case statement, if it is a table-item-related case, we check whether
    the `selection` statement is empty; in case it is, we build our selection statement
    up to the `lastpathsegment`, else we append the selection to the `lastpathsegment`
    statement. We use a `DatabaseManager` object to a run query on the database and
    get a cursor as a result. It is expected of the `query()` method to throw an `IllegalArgumentException`
    to inform of an unknown URI; it is also good practice to throw a `nullPointerException`
    in case we encounter an internal error during the query process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Remember that an Android system must be able to communicate the exception across
    process boundaries. Android can do this for the following exceptions that may
    be useful in handling query errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '`IllegalArgumentException`: You may choose to throw this if your provider receives
    an invalid content URI'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NullPointerException`: This is thrown when the object is null and we try to
    access its field or method'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding records through the insert() method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As the name suggests, the `insert()` method is used to insert a value in our
    database. It returns the URI of the inserted row and, while checking the URI,
    we need to remember that an insertion can happen at the table level, hence the
    operations in the method are processed at the URI that matches the table. After
    matching, we use the standard `DatabaseManager` object to insert our new value
    into the database. The content URI for the new row is constructed by appending
    the new row''s `_ID` value to the table''s content URI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Updating records through the update() method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `update()` method updates an existing row in the appropriate table, using
    the values in the `ContentValues` argument. First, we identify the URI, whether
    it is directory-based or ID-based, then we build our selection statement as we
    did in the `query()` method. Now, we will execute the standard `updateRow()` method
    of `DatabaseManager` that we defined earlier while building this application in
    [Chapter 2](ch02.html "Chapter 2. Connecting the Dots"), *Connecting the Dots*,
    which returns the number of affected rows.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `update()` method returns the number of rows updated. Based on the selection
    clause, one or more rows can be updated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Deleting records through the delete() method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `delete()` method is very similar to the `update()` method and the process
    of using it is similar; here, the call is made to delete a row instead of updating
    it. The `delete()` method returns the number of rows deleted. Based on the selection
    clause, one or more rows can be deleted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Getting the return type of data through the getType() method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The signature of this simple method takes a URI and returns a string value;
    every content provider must return the content type for its supported URIs. A
    very interesting fact is that no permissions are needed for an application to
    access this information; if our content provider requires permissions, or is not
    exported, all the applications can still call this method regardless of their
    access permissions to retrieve MIME types.
  prefs: []
  type: TYPE_NORMAL
- en: 'All these MIME types should be declared in the contract class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Adding a provider to a manifest
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another important step is to add our content provider to a manifest, like we
    do with other Android components. We can register multiple providers here. The
    important bit here, other than `android:authorities`, is `android:exported`; it
    defines whether the content provider is available for other applications to use.
    In case of `true`, the provider is available to other applications; if it is `false`,
    the provider is not available to other applications. If applications have the
    same user ID (UID) as the provider, they will have access to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Another important concept is **permissions**. We can add additional security
    by adding read and write permissions, which the other application has to add in
    their manifest XML file and, in turn, automatically inform a user that they are
    going to use a particular application''s content provider either to read, write,
    or both. We can add permissions in the following manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Using a content provider
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The main reason we built a content provider was to allow other applications
    to access the complex data store in our database and perform CRUD operations.
    We will now build one more application in order to test our newly built content
    provider. The test application is very simple, comprising of only one activity
    class and one layout file. It has standard buttons to perform actions. Nothing
    fancy, just the tools for us to test the functionality we just implemented. We
    will now delve into the `TestMainActivity` class and look into its implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'To access a content provider, we need details such as `AUTHORITY` and `BASE_PATH`
    and the names of the columns of database tables; we need to access the public
    class `Columns` for this purpose. We have more tables and we will see more of
    these classes. Generally, all this necessary information will be taken from the
    published contract class of the content provider. Some content providers also
    require implementing read or write permissions in the manifest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In some cases, the content provider we need to access can ask us to add permissions
    in our manifest. When the users install the application, they will see an added
    permission in their permission list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To try out some other app's content provider, refer to [http://goo.gl/NEX2hN](http://goo.gl/NEX2hN).
  prefs: []
  type: TYPE_NORMAL
- en: It lists how you can use the Any.do's content provider—a very famous task application.
  prefs: []
  type: TYPE_NORMAL
- en: We will set our layout and initialize the views we require in `onCreate()` of
    activity. To query, we first need to prepare the URI object that matches the table.
  prefs: []
  type: TYPE_NORMAL
- en: 'Content resolver now comes into play; it acts as a resolver for the content
    URI we prepared. Our `getContentResolver.query()` method, in this case, will fetch
    all the columns and rows. We will now move the cursor to the first position in
    order to read the result. For testing purposes, it''s read as a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we build a URI to read a particular row instead of a complete table. We
    already mentioned that to make URI ID-based, we need to add the ID part to our
    existing `contenturi`. Now, we build our projection string array to be passed
    as a parameter in our `query()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `getFirstRowId()` method gets the ID of the first row in the table. It
    is done because the ID of the first row will not always be `1`. It changes when
    the rows are deleted. If the first item in the table with row ID `1` is deleted,
    then the second item with row ID `1` becomes the first item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a closer look at the `query()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Present in API level 1, the `query()` method returns a cursor over the result
    set against the parameters we supplied. The following are the parameters of the
    preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`uri`: This is `contentURI` in our case, using the `content://` scheme for
    the content to be retrieved. It can be ID-based or directory-based.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`projection`: This is a list of the columns to be returned as we have prepared
    using the column names. Passing `null` will return all the columns.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`selection`: Formatted as a SQL `WHERE` clause, excluding the `WHERE` itself,
    this acts as a filter declaring which rows to return.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`selectionArgs`: We may include `?` parameter markers in `selection`. Android
    SQL query builder will replace the `?` parameter markers by the values bound as
    string from `selectionArgs`, in the order that they appear in the `selection`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sortOrder`: This tells us how to order the rows, formatted as an SQL `ORDER
    BY` clause. A `null` value will use the default sort order.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'According to official documentation, there are a few guidelines we should follow
    for optimum performance:'
  prefs: []
  type: TYPE_NORMAL
- en: Provide an explicit projection to prevent reading data from storage that isn't
    going to be used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use question mark parameter markers such as `phone=?` instead of explicit values
    in the selection parameter, so that queries that differ only by those values will
    be recognized as the same for caching purposes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The same process we used earlier to check for `null` values and an empty cursor
    is performed, and finally, a required value is extracted from the cursor.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let us look at the `insert` method for our test application.
  prefs: []
  type: TYPE_NORMAL
- en: We start by building our content value object and relevant key-value pairs,
    for instance, putting a phone number in the relevant `Columns.TABLE_ROW_PHONENUM`
    field. Notice that because details such as a column's name were shared with us
    in the form of a class, we need not worry about details such as the actual column
    name. We just need to access it via means of the `Columns` class. This ensures
    that we only need to update the relevant values. If in future the content provider
    undergoes some change and changes the table names, the rest of the functionality
    and implementation remains the same. We build our projection string array with
    the column names we required, as we did earlier in the case of querying the content
    provider for data.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also build our content URI; notice that it matches the table and not individual
    rows. The `insert()` method also returns a URI unlike the `query()` method, which
    returned a cursor over the result set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The `getRandomName()` and `getRandomNumber()` methods generate a random name
    and number to insert in the table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a closer look at the `insert()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are the parameters of the preceding line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`url`: The URL of the table to insert the data into'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`values`: The values for the newly inserted row in the form of a `ContentValues`
    object, the key is the column name for the field'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notice that after inserting, we are running the `query()` method again with
    the URI that was returned by the `insert()` method. We run this to see that the
    value we intended to insert has been inserted; this query will return columns
    as per the projection of the row whose ID is appended.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have covered the `query()` and `insert()` methods; now, we will cover
    the `update()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'We progressed in the `insert()` method by preparing the `ContentValues` object.
    Similarly, we will prepare an object that we will use in the `update()` method
    of `ContentResolver` to update an existing row. We will build our URI in this
    case up to the ID, as this operation is ID based. Update the row as pointed by
    the `rowUri` object and it will return the number of rows updated, which will
    be the same as the URI; in this case, it is `rowUri` that points to only a single
    row. An alternate method could be using a combination of `contentUri` (which points
    to the table) and `selection`/`selectionArgs`. In this case, the rows updated
    could be more than one as per the `selection` clause:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a closer look at the `update()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are the parameters of the preceding line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`uri`: This is the content URI we wish to modify'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`values`: This is similar to the values we used earlier with other methods;
    passing a `null` value will remove an existing field value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`where`: A SQL `WHERE` clause that acts as a filter to rows before updating
    them'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can run the `query()` method again to see whether the change is reflected;
    this activity has been left as an exercise for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last method is `delete()`, which we require in order to complete our arsenal
    of CRUD methods. The `delete()` method begins in a similar fashion as the rest
    of the methods do; first, prepare our content URI at the directory level and then
    build it for the ID level, that is, at the individual row level. After that, we
    pass it to the `delete()` method of `ContentResolver`. Unlike the `query()` and
    `insert()` methods that return an integer value, the `delete()` method deletes
    a row as pointed by our ID-based content URI object `rowUri` and returns the number
    of rows deleted. This will be `1` in our case as our URI points to only one row.
    An alternate method could be using a combination of `contentUri`, which points
    to the table, and `selection`/`selectionArgs`. In this case, the rows deleted
    could be more than 1 as per the `selection` clause:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The UI and output look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using a content provider](img/2951_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you want to dive in a little more into how an Android content provider actually
    manages various write and read calls between various tables (hint: it uses `CountDownLatch`),
    you can check out the video at Coursera by Dr. Douglas C. Schmidt for more information.
    The video can be found at [https://class.coursera.org/posa-002/lecture/49](https://class.coursera.org/posa-002/lecture/49).'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered the basics of content providers. We learned how
    to access system-provided content providers and even our own version of a content
    provider. We went from creating a basic contact manager to evolving it into a
    fully-fledged citizen of the Android ecosystem by implementing `ContentProvider`
    in order to share data across other applications.
  prefs: []
  type: TYPE_NORMAL
- en: In the following chapter, we will cover `Loaders`, `CursorAdapters`, nifty hacks
    and tips, and some open source libraries to make our life easier while working
    with the SQLite database.
  prefs: []
  type: TYPE_NORMAL
