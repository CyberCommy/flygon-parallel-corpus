- en: Chapter 5. Peer-to-Peer Networks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **peer-to-peer** (**P2P**) computer network refers to an architecture whose
    nodes frequently serve as both a server and as a client. The primary objective
    of P2P systems is to eliminate the need for separate servers to manage the system.
    The configuration of the P2P network will change dynamically with nodes joining
    and leaving the network in an unpredictable manner. The nodes may differ in terms
    of factors, such as processing speed, bandwidth support, and storage capabilities.
    The term peer implies a level of equality between the nodes.
  prefs: []
  type: TYPE_NORMAL
- en: There are various definitions and interpretations of a P2P network. They can
    be characterized as a decentralized, constantly changing, and self-regulated architecture.
    Servers tend to provide services, while clients request them. A P2P node usually
    does both. A pure P2P network will not have nodes designated as a client or server.
    In reality, these networks are rare. Most P2P networks rely on a central facility,
    such as a DNS server, for support.
  prefs: []
  type: TYPE_NORMAL
- en: Certain networks may be a hybrid between the client/server architecture and
    a more pure P2P architecture where there is never a specific node acting as a
    "master" server. For example, a file sharing P2P may use the nodes of the network
    to download the files, while a server may provide additional supporting information.
  prefs: []
  type: TYPE_NORMAL
- en: 'P2P can be classified in several ways. We will use a couple of common classification
    categories that are useful in understanding the nature of P2P networks. One classification
    is based on how **indexing**, the process of finding a node, is performed:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Centralized**: This is when a central server keeps track of where the data
    is located among peers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Local**: This is when each peer keeps track of its own data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Distributed**: This is when the data references are maintained by multiple
    peers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hybrid P2P networks use a centralized indexing scheme. Pure P2P networks use
    local or distributed indexes.
  prefs: []
  type: TYPE_NORMAL
- en: Algorithms are used to determine the location of information in a system. The
    system is decentralized with no overriding server executing the algorithm. The
    algorithm supports a self-organizing system that dynamically reconfigures itself
    as nodes are added and removed. In addition, these systems will ideally balance
    the load and resources as the network membership changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: The P2P concepts and terminology
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java support for P2P networks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The nature of distributed hash tables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How FreePastry supports P2P applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: P2P applications provide a flexible alternative to the traditional client/server
    architecture.
  prefs: []
  type: TYPE_NORMAL
- en: P2P functions/characteristics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One way of understanding a P2P network is to examine its characteristics. These
    include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Nodes that contribute resources to the system, including:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data storage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Computational resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They provide support for a set of services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are very scalable and fault tolerant
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They support load balancing of resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They may support limited anonymity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The nature of P2P systems is that a user may not be able to access a specific
    node to use a service or resources. As nodes join and leave a system randomly,
    a specific node may not be available. The algorithm will determine how the system
    responds to requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'The basics functions of a P2P system include:'
  prefs: []
  type: TYPE_NORMAL
- en: Enrollment of peers in a network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Peer discovery—the process of determining which peer has the information of
    interest
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending messages between peers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Not all peers perform all of these functions.
  prefs: []
  type: TYPE_NORMAL
- en: The resources of a P2P system are identified using a **Globally Unique Identifier**
    (**GUID**) that is usually generated using a secure hashing function, which we
    will examine in DHT components. The GUID is not intended to be human readable.
    It is a randomly generated value providing little opportunity for conflicts.
  prefs: []
  type: TYPE_NORMAL
- en: The nodes of a P2P are organized using **routing** **overlay**s. It is a type
    of **middleware** that routes requests to the appropriate node. The overlay refers
    to a network that is on top of the physical network as identified by resources
    using IP addresses. We can envision a network as composed on a series of IP-based
    nodes. However, an overlay is a subset of these nodes usually focusing on a single
    task.
  prefs: []
  type: TYPE_NORMAL
- en: The routing overlay will take into consideration factors, such as the number
    of nodes between a user and a resource, and the bandwidth of the connection, to
    determine which node should fulfill a request. Frequently, a resource may be duplicated
    or even split across multiple nodes. A routing overlay will attempt to provide
    the optimal path to a resource.
  prefs: []
  type: TYPE_NORMAL
- en: As nodes join and leave a system, the routing overlay needs to account for these
    changes. When a node joins a system, it may be asked to take on some responsibilities.
    When a node leaves, other parts of the system may need to pick up some of the
    departing nodes responsibilities.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will explain various concepts, which are often embedded
    as part of a system. We will briefly overview different P2P application, which
    will be followed by a discussion of Java support for this architecture. The use
    of distributed hash tables is demonstrated, and an in-depth examination of FreePastry
    is presented, which will provide insight into how many of the P2P frameworks work.
  prefs: []
  type: TYPE_NORMAL
- en: When applicable, we will illustrate how some of these concepts can be implemented
    manually. While these implementations are not needed to use the system, they will
    provide a more in-depth understanding of these underlying concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Applications-based P2P networks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are many applications that are based on a P2P network. They can be used
    for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Content distribution**: This is file sharing (files, music, videos, images)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Distributed computing**: This is when a problem is divided into smaller tasks
    and executed in a parallel fashion'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Collaboration**: This is when users work together to solve a common problem'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Platforms**: These are systems on which P2P applications are built, such
    as JXTA, and Pastry'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Distributed computing leverages the power of larger numbers of smaller computers
    to perform a task. The problems amenable to this approach require that they be
    broken down into smaller units and then executed concurrently on multiple machines.
    The results of these smaller tasks then need to be combined to produce a final
    result.
  prefs: []
  type: TYPE_NORMAL
- en: 'P2P networks support a number of applications, such as the following ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Skype**: This is a video-conferencing application'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Freecast**: This is peer-to-peer streaming audio program'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**BitTorrent**: This is a popular peer-to-peer file sharing system'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tor**: This program shields users'' identities'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Haihaisoft**: This is used for distribution of prerecorded TV programs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**WoW**: This uses a P2P for game updates'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**YaCy**: This is a search engine and web crawler'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Octoshape**: This supports live TV'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A good overview of P2P applications is found at [http://p2peducation.pbworks.com/w/page/8897427/FrontPage](http://p2peducation.pbworks.com/w/page/8897427/FrontPage).
  prefs: []
  type: TYPE_NORMAL
- en: Java support for P2P applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Java support beyond the low-level socket support that was detailed in earlier
    chapters consists of various frameworks. These range from well-known frameworks,
    such as JXTA, to small limited-capability protocols. These frameworks provide
    the basis for more specialized applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table lists several of these frameworks:'
  prefs: []
  type: TYPE_NORMAL
- en: '| P2P framework | URL |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| TomP2P | [http://tomp2p.net/](http://tomp2p.net/) |'
  prefs: []
  type: TYPE_TB
- en: '| JXTA | [https://jxta.kenai.com/](https://jxta.kenai.com/) |'
  prefs: []
  type: TYPE_TB
- en: '| Hive2Hive | [https://github.com/Hive2Hive/Hive2Hive](https://github.com/Hive2Hive/Hive2Hive)
    |'
  prefs: []
  type: TYPE_TB
- en: '| jnmp2p | [https://code.google.com/p/jnmp2p/](https://code.google.com/p/jnmp2p/)
    |'
  prefs: []
  type: TYPE_TB
- en: '| FlexGP | [http://flexgp.github.io/flexgp/javalibrary.html](http://flexgp.github.io/flexgp/javalibrary.html)
    |'
  prefs: []
  type: TYPE_TB
- en: '| JMaay | [http://sourceforge.net/projects/jmaay/](http://sourceforge.net/projects/jmaay/)
    |'
  prefs: []
  type: TYPE_TB
- en: '| P2P-MPI | [http://grid.u-strasbg.fr/p2pmpi/](http://grid.u-strasbg.fr/p2pmpi/)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Pastry | [http://www.freepastry.org/](http://www.freepastry.org/) |'
  prefs: []
  type: TYPE_TB
- en: These frameworks use an algorithm to route messages between peers. Hash tables
    frequently form the basis of these frameworks, as discussed next.
  prefs: []
  type: TYPE_NORMAL
- en: Distributed hash tables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **Distributed Hash Table** (**DHT**) uses a key/value pair to locate resources
    in a network. This mapping function is spread across peers making it distributed.
    This architecture allows P2P networks to scale easily to a large number of nodes
    and to handle peers joining and leaving a network randomly. A DHT is the basis
    to support core P2P services. Many applications use DHT, including BitTorrent,
    Freenet, and YaCy.
  prefs: []
  type: TYPE_NORMAL
- en: The following figure illustrates mapping a key to a value. The key is frequently
    a string containing the identity of a resource, such as the name of a book; and
    the value is a number generated to represent the resource. The number can be used
    to locate the resource in a network and can correspond to the identifier of a
    node.
  prefs: []
  type: TYPE_NORMAL
- en: '![Distributed hash tables](img/B04915_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'P2P networks have been in use for a while. The evolution of these networks
    is reflected in how resources are mapped as typified by Napster, Gnutella, and
    Freenet:'
  prefs: []
  type: TYPE_NORMAL
- en: Napster ([https://en.wikipedia.org/wiki/Napster](https://en.wikipedia.org/wiki/Napster))
    was the first large-scale P2P content delivery system. It uses a server to keep
    track of the nodes in the network. The nodes held the actual data. When a client
    needs this data, the server will look up the current set of nodes that holds the
    data, and this node's location will be sent back to the client. The client will
    then contact the node holding the data. This made it easy for attacks to be launched
    against it and, eventually, led to its demise through lawsuits.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gnutella ([https://web.archive.org/web/20080525005017](https://web.archive.org/web/20080525005017),
    [http://www.gnutella.com/](http://www.gnutella.com/)) does not use a central server
    but broadcasts to every node in a network. This resulted in the network being
    flooded with messages, and the approach was modified in later versions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Freenet ([https://freenetproject.org/](https://freenetproject.org/)) uses a
    heuristic key-based routing scheme and focuses on censorship and anonymity issues.
    However, DHS uses a more structured key-based routing approach resulting in the
    following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decentralization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fault tolerance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scalability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Efficiency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, DHT does not support exact-match search. If this type of search is
    needed, then it has to be added.
  prefs: []
  type: TYPE_NORMAL
- en: DHT components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **keyspace** is a set of 160-bit strings (keys) that is used to identify an
    element. **Keyspace partitioning** is the process of splitting the keyspace among
    the nodes of the network. An overlay network connects the nodes.
  prefs: []
  type: TYPE_NORMAL
- en: A commonly used hashing algorithm is **Secure Hash Algorithm** (**SHA-1**) ([https://en.wikipedia.org/wiki/SHA-1](https://en.wikipedia.org/wiki/SHA-1)).
    SHA-1 was designed by the NSA and generates a 160-bit hash value known as a message
    digest. Most P2Ps do not require the developer to explicitly perform the hashing
    function. However, it is instructive to see how it is done. The following is an
    example of using Java to create a digest.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `MessageDigest` class''s `getInstance` method accepts a string specifying
    the algorithm to use and returns a `MessageDigest` instance. Its `update` method
    requires an array of bytes containing the key to hash. In this example, a string
    is used. The `digest` method returns an array of bytes holding the hash value.
    The byte array is then displayed as a hexadecimal number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Executing this sequence will produce the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Hex format : 434d902b6098ac050e4ed79b83ad93155b161d72**'
  prefs: []
  type: TYPE_NORMAL
- en: 'To store data, such as a file, we can use the filename to create a key. A put
    type function is then used to store the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'To retrieve the data corresponding to a key, a get type function is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Every node in an overlay either contains the data that is represented by the
    key, or it is a node closer to the node containing the data. The routing algorithm
    determines the next node to visit on the way to the node containing the data.
  prefs: []
  type: TYPE_NORMAL
- en: DHT implementations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are several Java implementations of DHTs, as listed in the following
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Implementation | URL |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| openkad | [https://code.google.com/p/openkad/](https://code.google.com/p/openkad/)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Open Chord | [http://open-chord.sourceforge.net/](http://open-chord.sourceforge.net/)
    |'
  prefs: []
  type: TYPE_TB
- en: '| TomP2P | [http://tomp2p.net/](http://tomp2p.net/) |'
  prefs: []
  type: TYPE_TB
- en: '| JDHT | [http://dks.sics.se/jdht/](http://dks.sics.se/jdht/) |'
  prefs: []
  type: TYPE_TB
- en: We will use the **Java Distributed Hash Table** (**JDHT**) to illustrate the
    use of a DHT.
  prefs: []
  type: TYPE_NORMAL
- en: Using JDHT
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to use JDHT, you will need the JAR files that are listed in the following
    table. The `dks.jar` file is the main jar file used. However, the other two JAR
    files are used by JDHT. Alternate sources for the `dks.jar` file is listed as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| JAR | Site |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `dks.jar` |'
  prefs: []
  type: TYPE_TB
- en: '[http://dks.sics.se/jdht/](http://dks.sics.se/jdht/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.ac.upc.edu/projects/cms/browser/cms/trunk/lib/dks.jar?rev=2](https://www.ac.upc.edu/projects/cms/browser/cms/trunk/lib/dks.jar?rev=2)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `xercesImpl.jar` | [http://www.java2s.com/Code/Jar/x/DownloadxercesImpljar.htm](http://www.java2s.com/Code/Jar/x/DownloadxercesImpljar.htm)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Apache log4j 1.2.17 | [https://logging.apache.org/log4j/1.2/download.html](https://logging.apache.org/log4j/1.2/download.html)
    |'
  prefs: []
  type: TYPE_TB
- en: 'The following example has been adapted from the one on the website. First,
    we create a `JDHT` instance. JDHT uses port `4440` as its default. With this instance,
    we can then use its `put` method to add a key/value pair to the table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In order for a client to connect with this instance, we need to get a reference
    to this node. This is achieved as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code will keep the program running until the user terminates
    it. The `close` method is then used to close the table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'When the program is executed, you will get an output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**dksref://192.168.1.9:4440/0/2179157225/0/1952355557247862269**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Press Enter to terminate application:**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The client application is described as follows. A new JDHT instance is created
    using a different port. The second argument is the reference to the first application.
    You will need to copy the reference and paste it into the client. A different
    reference will be generated each time the first application is executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we use the `get` method to retrieve the value associated with the key.
    The value is then displayed and the application is closed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**http://docs.oracle.com/javase/8/docs/api/**'
  prefs: []
  type: TYPE_NORMAL
- en: This simple demonstration illustrates the basics of a distributed hash table.
  prefs: []
  type: TYPE_NORMAL
- en: Using FreePastry
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pastry ([http://www.freepastry.org/](http://www.freepastry.org/)) is a P2P routing
    overlay system. FreePastry ([http://www.freepastry.org/FreePastry/](http://www.freepastry.org/FreePastry/))
    is an open source implementation of Pastry and is simple enough for us to use
    to illustrate many of the features of a P2P system. Pastry will route messages
    with a network of *n* nodes in *O(log n)* steps. That is, given a network of nodes,
    it requires, at most, log base 2 of *n* steps to reach the node. This is an efficient
    routing approach. However, while it may only require traversing three nodes to
    get to a resource, it may require a considerable number of IP hops to get to it.
  prefs: []
  type: TYPE_NORMAL
- en: Pastry uses the concept of **leaf sets** in the routing process. Each node has
    a leaf set. A leaf set is a collection of GUIDS and IP addresses of nodes that
    are numerically closest to this node. The nodes are logically arranged in a circle,
    as shown next.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following figure, each dot represents a node with an identifier. The
    addresses used here range from `0` to `FFFFFF`. The real addresses range from
    `0` to `2128`. If a message representing a request originates at address `9341A2`
    and needs to be sent to address `E24C12`, then based on the numerical address
    the overlay router may route the messages through the intermediate nodes, as depicted
    by the arrows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using FreePastry](img/B04915_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Other applications have been built on top of FreePastry, including:'
  prefs: []
  type: TYPE_NORMAL
- en: '**SCRIBE**: This is a group communication and event notification system supporting
    the publisher/subscriber paradigm'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PAST**: This is an archival storage utility system'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SplitStream**: This program supports content streaming and distribution'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pastiche**: This is backup system'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of these applications uses an API to support their use.
  prefs: []
  type: TYPE_NORMAL
- en: The FreePastry demonstration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To demonstrate how FreePastry supports a P2P application, we will create an
    application based on the FreePastry tutorials found at [https://trac.freepastry.org/wiki/FreePastryTutorial](https://trac.freepastry.org/wiki/FreePastryTutorial).
    In this demonstration, we will create two nodes and demonstrate how they can send
    and receive messages. The demonstration uses three classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FreePastryExample`: This is used to bootstrap the network'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FreePastryApplication`: This executes the functionality of the node'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PastryMessage`: This is the message that is sent between nodes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start with the bootstrap application.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the FreePastryExample class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are several components used with FreePastry applications. These include:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Environment**: This class represents the application''s environment'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bind port**: This represents the local port that the application will bind
    to'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Boot port**: This is the boot port that is used for the node''s `InetAddress`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Boot address**: This is the IP address of the boot node'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `FreePastryExample` class is defined next. It contains a main method and
    a constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We will start with the `main` method. An instance of the `Environment` class
    is created first. This class holds the parameter settings for the node. Next,
    the NAT search policy is set to never, which allows us to use the program in a
    local LAN without difficulty:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The ports and `InetSocketAddress` instance are initialized. We will set both
    ports to the same number at this time. We used the IP address `192.168.1.14` to
    instantiate the `InetAddress` object. You will need to use the address of your
    machine instead. This is a local LAN address. Do not use `127.0.0.1` as it will
    not work properly. The `InetAddress` object along with the `bootPort` value are
    used to create the `InetSocketAddress` instance. All of this is placed in a try
    block to handle exceptions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The last task is to create an instance of the `FreePastryExample` class by
    calling the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The constructor will create and launch the node's application. To accomplish
    this, we need to create a `PastryNode` instance and attach the application to
    it. To create the node, we will use a factory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every node needs a unique ID. The `RandomNodeIdFactory` class generates an
    ID based on the current environment. Using this object with the bind port and
    the environment, an instance of the `SocketPastryNodeFactory` is created. With
    this factory the `newNode` method is invoked to create our `PastryNode` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, an instance of the `FreePastryApplication` class is created, and the
    node is started using the `boot` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The node''s ID is then displayed as shown in the next code sequence. As there
    will be multiple nodes in the network, we pause for 10 seconds to allow the other
    nodes to start. We used the FreePastry timer to effect this delay. A random node
    ID is created, and the application''s `routeMessage` message is called to send
    a message to that node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Before we execute the program, we need to develop the application class.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the FreePastryApplication class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `FreePastryApplication` class implements the `Application` interface and
    implements the functionality of the node. The constructor creates and registers
    an `Endpoint` instance and initializes a message. The `Endpoint` instance is used
    by the node to send messages. The class and constructor are shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: You may get a "Leaking this in constructor" warning when this code is compiled.
    This is caused by a reference to the constructor's object being passed as an argument
    to the `buildEndpoint` method using the `this` keyword. This is a potentially
    bad practice because the object may have not been fully constructed when it was
    passed. Another thread may try to do something with the object before it is ready.
    It is not as much of a problem if it is passed to a package-private method that
    performs common initialization. In this situation, it is not likely to cause problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Application` interface requires that three methods be implemented:'
  prefs: []
  type: TYPE_NORMAL
- en: '`deliver`: This is called when a message is received'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`forward`: This is used to forward a message'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`update`: This informs the application that a node has joined or left a set
    of local nodes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are only interested in the `deliver` method for this application. In addition,
    we will add the `getCurrentTime` and `routeMessage` methods to the application.
    We will use the `getCurrentTime` methods to show the time that our messages are
    sent and arrive. The `routeMessage` method will send a message to another node.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `getCurrentTime` method is as follows. It uses the `EndPoint` object to
    access the node''s environment and then the time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The `routeMessage` method is passed the identifier of the destination node.
    The message text is constructed adding the end point and time information. A `PastryMessage`
    instance is created using the end-point identifier and the message text. The `route`
    method is then called to send this message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'When a message is received by a node, the `deliver` method is invoked. The
    implementation of this method is as follows. The end point identifier, the message,
    and the time of arrival are displayed. This will help us understand how messages
    are sent and received:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `PastryMessage` class implements the `Message` interface, as shown next.
    The constructor accepts the destination, source, and message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Message` interface possesses a single `getPriority` method that needs
    to be overridden. Here, we return a low priority so that it does not interfere
    with underlying P2P maintenance traffic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The `toString` method is overridden to provide a more detailed description
    of the message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we are ready to execute the example. Execute the `FreePastryExample` class.
    The initial output will consist of the following output. The abbreviated node
    identifier is displayed, which in this case is `<0xB36864..>`. The identifier
    that you get will be different:'
  prefs: []
  type: TYPE_NORMAL
- en: '**InetAddress: /192.168.1.14 Node <0xB36864..> created**'
  prefs: []
  type: TYPE_NORMAL
- en: 'After this, a pause a message is sent and subsequently received by the current
    node. This message was created in the `FreePastryExample` class using the code
    repeated here for your convenience:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'A random identifier was used because we do not have a specific node to send
    the message to. When the message is sent, the following output is generated. The
    random identifier for this run is `<0x83C7CD..>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Message Sent**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Current Node: <0xB36864..>**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Destination: <0x83C7CD..>**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Time: 1441844742906**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Message Received**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Current Node: <0xB36864..>**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Message: From: <0xB36864..> To: <0x83C7CD..> [Hello there! from Instance:
    Instance ID Sent at: [1441844732905]]**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Time: 1441844742915**'
  prefs: []
  type: TYPE_NORMAL
- en: The time between the sending and receiving of the message is minimal. If a larger
    set of nodes comprised the P2P network, more significant delays would show up.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous output, the node addresses were truncated. We can use the `toStringFull`
    method, as shown here, to get the full address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This will produce output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Node B36864DE0C4F9E9C1572CBCC095D585EA943B1B4 created**'
  prefs: []
  type: TYPE_NORMAL
- en: We did not provide a specific address for our messages. Instead, we randomly
    generated addresses. This application demonstrated the basic elements of a FreePastry
    application. Additional layers are used to facilitate communication between nodes,
    such as the publisher/provider paradigm support by Scribe.
  prefs: []
  type: TYPE_NORMAL
- en: We can start a second node using the same program, but we will need to use a
    different bind port to avoid binding conflicts. The message sent by either node
    will not necessarily be received by the other node. This is the result of the
    routes generated by FreePastry.
  prefs: []
  type: TYPE_NORMAL
- en: Sending a message to a specific node
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To send a message directly to a node, we need its identifier. To get a remote
    node's identifier, we need to use a leaf set. This collection is not strictly
    a set because for small networks, such as the one we are using, the same node
    may appear twice.
  prefs: []
  type: TYPE_NORMAL
- en: The `LeafSet` class represents this collection and has a `get` method that will
    return a `NodeHandle` instance for each node. We can send messages to nodes if
    we have this node handle.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate this approach, add the following method to the `FreePastryApplication`
    class. This is similar to the `routeMessage` method, but it uses a node handle
    as an argument of the `route` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following sequences of code to the end of the `FreePastryExample` constructor.
    Optionally, comment out the previous code that uses the `routeMessage` method.
    First, we pause for 10 seconds to allow other nodes to join the network:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we create an instance of the `LeafSet` class. The `getUniqueSet` method
    returns the leaf set, which excludes the current node. A for-each statement will
    then use the `routeMessageDirect` variable to send the message to the nodes of
    the collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Start the `FreePastryExample` class using a bind port of `9001`. Then, change
    the bind port to `9002` and start the class a second time. After several seconds,
    you will see an output similar to the following one. The first set of output corresponds
    to the first instance of the application, while the second set corresponds to
    the second instance. Each instance will send one message to the other instance.
    Note the time stamps that are used when the messages are sent and received:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: There is a lot more to FreePastry than we were able to illustrate here. However,
    the examples provide a feel for the nature of P2P application development. Other
    P2P frameworks work in a similar manner.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored the nature and use of P2P networks. This architecture
    treats all nodes as equals avoiding the use of a central server. Nodes are mapped
    using an overlay network, which effectively creates a subnetwork of nodes in an
    IP address space. These nodes will vary in their capabilities and will join and
    leave the network in a random manner.
  prefs: []
  type: TYPE_NORMAL
- en: We saw how a distributed hash table supports identifying and locating nodes
    in a network. A routing algorithm uses this table to fulfill requests by sending
    messages between nodes. We demonstrated the Java Distributed Hashing Table to
    illustrate the used of DHTs.
  prefs: []
  type: TYPE_NORMAL
- en: There are several open source Java based P2P frameworks available. We used FreePastry
    to demonstrate how P2P networks work. Specifically, we showed you how nodes join
    a network and how messages are sent between nodes. This provided a better understanding
    of how these frameworks function.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will examine the nature of the UDP protocol and how
    it supports multicasting.
  prefs: []
  type: TYPE_NORMAL
