- en: Publishing to Web Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the heart of the IoT are web services that allow interaction with physical
    devices. In this chapter, we will explore the use of web services for the purposes
    of displaying sensory data from our Raspberry Pi. We will also look into Twilio,
    a text messaging service, and how we can use this service to send ourselves a
    text message from our Raspberry Pi.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Publishing sensory data to cloud-based services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up an account for text message transmission
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Project overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will write code to display our sensory data to an IoT dashboard.
    As well as this, we will also explore Twilio, a text messaging service. We will
    then put these two concepts together to enhance the home security dashboard that
    we built in [Chapter 9](1a50006e-75d3-4dc1-96db-82114b437795.xhtml), *Building
    a Home Security Dashboard*.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To complete this project, the following will be required:'
  prefs: []
  type: TYPE_NORMAL
- en: A Raspberry Pi Model 3 (2015 model or newer)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A USB power supply
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A computer monitor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A USB keyboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A USB mouse
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A breadboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jumper wires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A DHT-11 temperature sensor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A PIR sensor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A push-button (latching)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A key switch (optional)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Publishing sensory data to cloud-based services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will publish sensory data to an online dashboard using the
    MQTT protocol. This will involve setting up an account with the ThingsBoard website
    and making use of the `demo` environment.
  prefs: []
  type: TYPE_NORMAL
- en: Install the MQTT library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will use the MQTT protocol in order to communicate with the dashboard in
    ThingsBoard. To set up the library on the Raspberry Pi, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Open a Terminal appliance from the main tool bar
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type `**sudo pip3 install pho-mqtt**`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should see the library install
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set up an account and create a device
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To start, navigate to the ThingsBoard website at [www.thingsboard.io](http://www.thingsboard.io):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the TRY IT NOW button at the top of the screen. Scroll down and click
    on the LIVE DEMO button under the Thing Board Community Edition section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/99834e79-3ac3-46de-89c3-3c7b4db4d192.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You will be presented with a sign-up window. Enter the appropriate information
    to set up an account. Once your account has been successfully set up, you will
    see a dialog showing the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/59f38928-a10e-466c-a456-09d642cd38a3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on LOGIN to get into the app. After this, you should see a menu at the
    left-hand side of the screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/ec514cbb-75e8-431b-92fa-02591dd5704c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on DEVICES. Look for a round orange graphic with a plus sign at the bottom
    right-hand side of the screen, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/9d87136a-700e-4000-b7d6-183d75e5d0cc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on this orange circle to add a new device. Type `Room Conditions` for
    the Name* and select default for the Device type* in the Add Device dialog. Do
    not select Is gateway. Click on ADD:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/853a76a0-1f4c-456a-9f12-433668ea6a8f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You should see a new box under your Devices, named Room Conditions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/18e9ccb0-00e3-4284-b5ce-fcadb263d16e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on this box and a menu should slide from the right. Click on the COPY
    ACCESS TOKEN button to copy this token to your clipboard:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/115adb70-987e-4e89-9eb4-f79a2aadefb8.png)'
  prefs: []
  type: TYPE_IMG
- en: What we have done here is set up a ThingsBoard account and a new device inside
    ThingsBoard. We will use this device to retrieve sensory information from our
    Raspberry Pi and make a dashboard of these values.
  prefs: []
  type: TYPE_NORMAL
- en: Reading sensory data and publishing to ThingsBoard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s now time to create our circuit and code. Install the DHT-11 sensor using
    GPIO pin 19 (refer to [Chapter 9](1a50006e-75d3-4dc1-96db-82114b437795.xhtml),
    *Building a Home Security Dashboard*, if you are unsure of how to connect the
    DHT-11 sensor to the Raspberry Pi):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open up Thonny and create a new file called `dht11-mqtt.py`. Type the following
    into the file and run it. Be sure to paste in the access token from your clipboard:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see an output in the shell similar to the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/b8f64a58-60a6-4d41-967e-0e21c3778318.png)'
  prefs: []
  type: TYPE_IMG
- en: There should be a new line every 10 seconds. As you can see, it's pretty hot
    and humid in the room.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s take a closer look at the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `import` statements give us access to the modules needed for our code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We are already familiar with `sleep`, `Adafruit_DHT`, and `json`. The `Paho
    MQTT` library gives us access to the `client` object, which we will use to publish
    our sensory data to the dashboard.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next two lines in the code are used to set variables for the URL of the
    `demo` server and the access token we retrieved from our device previously. We
    require both of these values in order to connect to the MQTT server and publish
    our sensory data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We define the `dht_sensor` variable as a `DHT11` object from the `Adafruit`
    library. And we use pin `19` for the sensor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We then define a `dictionary` object to store the sensory data that will be
    published to the MQTT server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We then create a `client` object of the `mqtt Client` type. The username and
    password is set with the `access_token` defined previously in the code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The continuous `while` loop contains the code that reads the sensory data,
    and then publishes it to the MQTT server. The humidity and temperature are set
    by reading from the `read_retry` method, and we set the corresponding `sensor_data`
    dictionary values as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The following `client` code is the code responsible for publishing our sensory
    data to the MQTT server. We connect using the `connect` method of the `client`
    object passing in the host value, the port (default port), and a keepalive time
    of `20` seconds. Unlike many MQTT examples, we do not create a loop and look for
    a callback, as we are only interested in publishing the sensory value, and not
    subscribing to the topic. In this case, the topic we are publishing to is `v1/devices/me/telemetry`,
    as per the ThingsBoard documentation example code. We then disconnect from `client`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We will now create a dashboard in ThingsBoard to display the sensory values
    sent from our code.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a dashboard in ThingsBoard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are the steps to add the humidity value to a dashboard:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate back to ThingsBoard and click on Devices, and then ROOM CONDITIONS.
    The side menu should slide from the right:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/e4a0f8a8-5fb8-457e-89a9-d6db6d79d54a.png)'
  prefs: []
  type: TYPE_IMG
- en: Click on the LATEST TELEMETRY tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You should see values for humidity and temperature, and the time when these
    values were last updated. Select humidity by clicking on the check box to the
    left. Now, click on SHOW ON WIDGET:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/d9de168d-ad4f-4b08-b757-c5d7553a3fd2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Select the Current bundle to Analogue gauges and cycle through the gauges until
    you get to the humidity dial widget. Click on the ADD TO DASHBOARD button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/3d991f91-b3c7-4a34-b75c-a5aebe6bd90e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Select Create new dashboard and type in `Room Conditions` as the name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/7f4d0b0c-8d41-4ba4-8d7e-eca154a676ba.png)'
  prefs: []
  type: TYPE_IMG
- en: Do not select the Open dashboard checkbox. Click on the ADD button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Repeat the previous steps for the temperature value. Select a temperature widget,
    and add your widget to the Room Conditions dashboard. This time, select Open dashboard
    before clicking on ADD:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/fa7423ba-e6b0-4d5c-ac23-d2d2a348952b.png)'
  prefs: []
  type: TYPE_IMG
- en: You should now see a dashboard with the humidity and temperature values shown
    in analogue dials.
  prefs: []
  type: TYPE_NORMAL
- en: Sharing your dashboard with a friend
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you would like to make this dashboard public, so that others may see it,
    you need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to the dashboards screen by clicking on DASHBOARDS:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/5ea867db-fe5f-48e6-aacd-5f3633c598de.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on the Make dashboard public option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/bd1baa9b-615e-4340-8ed7-212823a62971.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You will see the dialog reading Dashboard is now public, as shown in the following
    screenshot. You may copy and paste the URL, or share it via social media:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/10b1a040-1240-4aee-8848-b2c98cb8eb13.png)'
  prefs: []
  type: TYPE_IMG
- en: Setting up an account for text message transmission
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will connect to a text message transmission service and
    send a text message from our Raspberry Pi to our phone. We will use this information,
    and what we've learned so far about publishing sensory information, to create
    an enhancement to our security dashboard in [Chapter 9](1a50006e-75d3-4dc1-96db-82114b437795.xhtml),
    *Building a Home Security Dashboard*.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a Twilio account
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Twilio is a service that gives software developers the ability to create and
    receive text and phone calls programmatically through the use of its web service
    APIs. Let''s start by setting up a Twilio account:'
  prefs: []
  type: TYPE_NORMAL
- en: In a web browser, navigate to [www.twilio.com](http://www.twilio.com)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the red sign up at the top-right corner of the page
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter the appropriate personal information and a password, and then select SMS, Arrival
    Alerts, and Python for the fields below the password:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/4dda7c52-477c-4c6e-b693-bcd26b0f1239.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Provide a phone number to receive an authorization code via SMS, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/1ce5138e-b3f3-4c70-aaee-1e3368e4aa3d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Enter the authorization code you receive, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/b4d3f813-f5e9-4206-808e-2cd1f811890a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The next step is to name the project that you will be working on. We will name
    it `Doorbell`. Enter the name and click Continue:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/85292270-6310-40e4-ade5-646e203a0415.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We need a phone number for our account in order to be able to interact with
    it. Click on Get a Number:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/b9cf840a-56b8-44a5-a41d-deb6258174a9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'A number will be presented to you. If this number works for you, click on Choose
    this number:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/f0c888ec-7c2f-4a32-99a1-426eac78c2fb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You are now set up and ready to use Twilio:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/f8fcd1de-66d3-455f-8b87-d1f37e36f7bb.png)'
  prefs: []
  type: TYPE_IMG
- en: Twilio is a paid service. You will be given an initial amount to work with.
    Please check the costs of using this service before creating your apps.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Twilio on our Raspberry Pi
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To access Twilio from Python, we need to install the `twilio` library. Open
    up a Terminal and type in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: You should see the progress of Twilio being installed in the Terminal.
  prefs: []
  type: TYPE_NORMAL
- en: Sending a text through Twilio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before sending a text, we need to get credentials. In your Twilio account,
    click on Settings | General, and scroll down to API Credentials:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/287a1ff0-1d05-4954-a6ca-33d3d1cef52a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We will use both the LIVE Credentials and TEST Credentials values. Open up
    Thonny and create a new file called `twilio-test.py`. Type the following code
    into the file and run it. Be sure to paste in the LIVE Credentials (please note
    that your account will be charged for sending a text):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: You should get a text on your cell phone, with the message `Twilio says hello!`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new home security dashboard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 9](1a50006e-75d3-4dc1-96db-82114b437795.xhtml), *Building a Home
    Security Dashboard*, we created a home security dashboard using CherryPy. The
    power behind the IoT is the ability to build an application with devices, located
    anywhere in the world, that are connected to each other. We will take this idea
    to our home security dashboard. If not already assembled, build the home security
    dashboard with the temperature sensor from [Chapter 9](1a50006e-75d3-4dc1-96db-82114b437795.xhtml),
    *Building a Home Security Dashboard*:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start our code by encapsulating our sensory data in a `class` container.
    Open up Thonny and create a new file called `SensoryData.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Run the program to test our sensors. There isn't anything here we haven't covered
    already. We are basically just testing out our circuit and sensors. You should
    see the sensory data print out in the shell.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, let''s create our sensory dashboard. Open up Thonny and create a new file
    called `SensoryDashboard.py`. The code is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: What we've done here is encapsulate the `dht-mqtt.py` file, from the previous
    code, in a `class` container. We instantiate our object with a `SensoryData` object
    in order to obtain data from our sensors. The `publishSensoryData()` method sends
    the sensory data to our MQTT dashboard. Notice how it returns the state of the
    motion sensor? We use this return value in our main loop to print out the value
    of the motion sensor. However, this return value will be more useful in our future
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add the motion sensor to our ThingsBoard dashboard:'
  prefs: []
  type: TYPE_NORMAL
- en: Open up ThingsBoard in a browser
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the Devices menu
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the Room Conditions device
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select LATEST TELEMETRY
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the Motion Detected value
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on SHOW ON WIDGET
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Under Cards, find the widget made up of a big orange square, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/6cfc62b4-a7ca-4364-8662-c59f77450cb0.png)'
  prefs: []
  type: TYPE_IMG
- en: Click on ADD TO DASHBOARD
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the existing Room Conditions dashboard
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check off Open Dashboard
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click Add
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You should see the new widget added to the Room Conditions dashboard. By clicking
    on the orange pencil icon at the bottom-right of the page, you are able to move
    and resize the widgets. Edit the widgets so they look like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/f83cee48-8874-4e06-92e9-86ec54584e03.png)'
  prefs: []
  type: TYPE_IMG
- en: What we have done here is recreate the first version of the home security dashboard
    from [Chapter 9](1a50006e-75d3-4dc1-96db-82114b437795.xhtml), *Building a Home
    Security Dashboard*, with a more distributed architecture. No longer are we relying
    on our Raspberry Pi to serve up the sensory information via a CherryPy web page.
    We are able to reduce the role of our Raspberry Pi to a source of sensory information.
    As you can imagine, it is quite easy to use multiple Raspberry Pis with the same
    dashboard.
  prefs: []
  type: TYPE_NORMAL
- en: Test out this new dashboard by moving near the PIR sensor. See if you can get
    the Motion Detected widget to change to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make our new home security dashboard even more distributed, let''s add the
    ability to send a text message whenever the PIR motion sensor is activated. Open
    up Thonny and create a new file called `SecurityDashboardDist.py`. The following
    is the code to insert into the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Utilizing the first version of the home security dashboard circuit from [Chapter
    9](1a50006e-75d3-4dc1-96db-82114b437795.xhtml), *Building a Home Security Dashboard*,
    this code uses the key switch in order to arm the call to send out a text message
    if the motion sensor detects motion. With the key switch in the off position,
    you will get a message, reading `Alarm triggered but Not Armed`, whenever the
    motion sensor detects motion.
  prefs: []
  type: TYPE_NORMAL
- en: If not already turned on, turn on the key switch to arm the circuit. Activate
    the motion sensor by moving around. You should get a notification that a text
    message was sent. The SID of the message should show as well. You may have noticed
    that you didn't actually get a text message. This is due to the fact that the
    code defaults to the Twilio test environment. Before we turn on the live environment,
    let's go over the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start out by importing the libraries we need for our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: There's not too much here that we haven't seen before; however, take note of
    the `SensoryData` and `SensoryDashboard` imports. As we have encapsulated the
    code to read sensory data, we can now just look at it as a black box. We know
    we need sensory data for our security dashboard, but we don't care how we get
    this data and where it will be displayed. `SensoryData` gives us access to the
    sensory data we need, and `SensoryDashboard` sends it off to a dashboard somewhere.
    We don't have to concern ourselves with these details in our `SecurityDashboardDist.py`
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'We create a class called `SecurityDashboardDist` for our distributed security
    dashboard. It is important to distinguish our classes by their names, and to pick
    names that describe what the `class` is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'After declaring some class variables that are accessible throughout the class,
    we then come to our class initialization method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `initialization` method, we set our class scoped `test_env` variable
    (for the `test` environment). The default is `True`, meaning we have to conscientiously
    override the default in order to run the dashboard live. We use the `setEnvironment()`
    method to set `test_env`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `setEnvironment()` method sets up the class scoped `account_id` and `auth_token`
    values to either the test environment, or the live environment, depending on the
    value of `test_env`. We are basically just passing back the state of `test_env`
    with the `setEnvironment()` method, while setting up the variables we need to
    enable a test or live text message environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `update_dashboard()` method makes the call to the sensors and sensory dashboard
    through the use of the `SensoryDashboard` object that we pass into the method.
    This here is the beauty of the object-oriented approach we have taken, as we do
    not need to concern ourselves with how the sensors are read or how the dashboard
    is updated. We only need to pass in a `SensoryDashboard` object to get this done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `update_dashboard` method is also responsible for determining whether or
    not a text message will be sent, by checking on the status of the motion sensor.
    Do you remember how we returned the state of the motion sensor when we called
    the `publishSensoryData()` method on our `SensoryDashboard` class? This is where
    it comes in really handy. We can use this return value to determine whether or
    not we should send an alert. We don't have to check on the state of the motion
    sensor in our class at all, as it is easily available from the `SensoryDashboard`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `send_alert()` method checks on the state of the switch in order to determine
    whether a text message should be sent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: You may be wondering why we are checking on the state of a sensor (a switch,
    in this case) here, as opposed to checking it from the `SensoryDashboard` class.
    The answer? We are building a home security dashboard by encapsulating a sensory
    data dashboard. There is no need for a switch in the `SensorDashboard` class,
    as it is not concerned with turning on and off the reading and transmitting of
    sensory data from the GPIO to the MQTT dashboard. The switch is the domain of
    a security system; in this case, the `SecurityDashboardDist` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The heart of the `SecurityDasboardDist` class is the `sendTextMessage()` method,
    outlined here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We use the `message_interval` method variable to set the duration of time between
    texts. We do not want to send a text message every time the motion sensor has
    detected motion. In our case, the minimum time left between texts is `600` seconds,
    or `10` minutes.
  prefs: []
  type: TYPE_NORMAL
- en: If this is the first time, or if it has been more than 10 minutes since the
    time that a text message was last sent, then the code sends the text message in
    either the test environment, or simply live. Take note of how the `15005550006`
    phone number is used for the test environment. Your Twilio number is required
    for the live environment, and your own phone number for the `to` field. For both
    the test and live environments, the `Alarm triggered and text message sent` message
    is returned, followed by the SID of the message. The difference is that you will
    not actually receive a text message (although there is a call to Twilio from the
    code).
  prefs: []
  type: TYPE_NORMAL
- en: If it has been less than 10 minutes since the last time a text message was sent,
    then the message will read `Alarm triggered and text message sent less than 10
    minutes ago`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our main function, we create a `SecurityDashboardDist` object and call it
    `security_dashboard`. By not passing in anything, we allow the dashboard to be
    set up for the test environment by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The continuous loop that follows creates a `SensoryData` and `SensoryDashboard`
    object every 5 seconds. The `SensoryData` object (`sensory_data`) is used to instantiate
    a `SensoryDashboard` object (`sensory_dashboard`), as it is the former that gives
    us the current sensory data, and the latter that creates the sensory dashboard.
  prefs: []
  type: TYPE_NORMAL
- en: By naming our classes according to what they are, and our methods by what they
    do, the code becomes pretty self-explanatory.
  prefs: []
  type: TYPE_NORMAL
- en: We then pass this `SensoryDashboard` object (`sensory_dashboard`) to the `update_dashboard`
    method of the `SecurityDashboard` (`security_dashboard`). As the `update_dashboard`
    method returns a string, we are able to use it to print to our shell, and thus,
    see the status of our dashboard printed every 5 seconds. We keep the instantiation
    of the `SecurityDashboardDist` object out of the loop, as we only need to set
    the environment once.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we understand the code, it''s time to run it in the live Twilio environment.
    Please note that the only part of the code that changes when we switch to live
    is the actual sending of text messages. To turn our dashboard into a live text-sending
    machine, simply change the first line of the main method to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After completing this chapter, we should be very familiar with publishing sensory
    data to an IoT dashboard. We should also be familiar with sending text messages
    from our Raspberry Pi using the Twilio web service.
  prefs: []
  type: TYPE_NORMAL
- en: We will take a look at Bluetooth libraries in [Chapter 11](1668a45a-408f-4732-8643-623297983690.xhtml),
    *Creating a Doorbell Button Using Bluetooth*, before putting that information
    and the information we acquired in this chapter together to make an IoT doorbell.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the name of the service we used to send text messages from our Raspberry
    Pi?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: True or false? We use a PIR sensor to read temperature and humidity values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you create a dashboard in ThingsBoard?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: True or false? We built our enhanced security dashboard by using a sensory dashboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the name of the library we use to read temperature and humidity sensory
    data?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: True or false? The library that we require to send text messages comes pre-installed
    with Raspbian.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When naming classes in our code, what do we try to do?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: True or false? In order to change our environment from test to live, do we have
    to rewrite the entire code in our enhanced home security dashboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: True or false? The `account_sid` number for our Twilio account is the same for
    the live environment as it is for the test environment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Where do we create a `SecurityDashboardDist` object in our `SecurityDashboardDist.py`
    code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To further your understanding of the technologies behind Twilio and ThingsBoard,
    please refer to the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: The Twilio documentation:  [https://www.twilio.com/docs/quickstart](https://www.twilio.com/docs/quickstart)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The documentation for ThingsBoard:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://thingsboard.io/docs/](https://thingsboard.io/docs/)'
  prefs: []
  type: TYPE_NORMAL
