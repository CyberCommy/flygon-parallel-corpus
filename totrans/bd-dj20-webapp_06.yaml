- en: Starting Answerly
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The second project that we will build is a Stack Overflow clone called Answerly.
    Users who register for Answerly will be able to ask and answer questions. A question's
    asker will also be able to accept answers to mark them as useful.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll do the following things:'
  prefs: []
  type: TYPE_NORMAL
- en: Create our new Django project—Answerly, a Stack Overflow clone
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create the models for Answerly (`Question` and `Answer`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let users register
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create forms, views, and templates to let users interact with our models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run our code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code for this project is available online at [https://github.com/tomaratyn/Answerly](https://github.com/tomaratyn/Answerly).
  prefs: []
  type: TYPE_NORMAL
- en: This chapter won't go deeply into topics already covered in [Chapter 1](df6a3177-07c4-4edb-84b8-a01a6fd8ad0e.xhtml),
    *Building MyMDB*, although it will touch upon many of the same points. Instead,
    this chapter will focus on going a bit further and introducing new views and third-party
    libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start our project!
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Answerly Django project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, let’s make a directory for our project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: All our future commands and paths will be relative to this project directory.
    A Django project is composed of multiple Django apps.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll install Django using `pip`, Python''s preferred package manager. We will
    also track the packages that we install in a `requirements.txt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s install the packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s generate the actual Django project using `django-admin`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: By default, Django creates a project that will use SQLite, but that's not usable
    for production; so, we'll follow the best practice of using the same database
    in development as in production.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s open up `django/config/settings.py` and update it to use our Postgres
    server. Find the line in `settings.py` that starts with `DATABASES`; to use Postgres,
    change the `DATABASES` value to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our project started and configured, we can create and install
    the two Django apps we''ll make as part of this project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: A Django project is composed of apps. Django apps are where all the functionalities
    and code live. Models, forms, and templates all belong to Django apps. An app,
    like every other Python module, should have a clearly defined scope. In our case,
    we have two apps each with different roles. The `qanda` app will be responsible
    for the question and answer functionality of our app. The `user` app will be responsible
    for user management of our app. Each of them will also rely on other apps and
    Django's core functionality to work effectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s install our apps in our project by updating `django/config/settings.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now that Django knows about our app, let’s install start with the models for
    `qanda`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Answerly models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Django is particularly helpful for creating data-driven apps. Models, representing
    the data in the apps, are often the core of these apps. Django encourages this
    with the best practice of *fat models, thin views, dumb templates*. The advice
    encourages us to place business logic in our models rather than our views.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start building our `qanda` models with the `Question` model.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Question model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll create our `Question` model in `django/qanda/models.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'A `Question` model, like all Django models, is derived from `django.db.models.Model`.
    It has the following four fields that will become columns in a `questions_question`
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '`title`: A character field that will become a `VARCHAR` column of maximum 140
    characters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`question`: This is the body of the question. Since we can''t predict how long
    this will be, we use a `TextField`, which will become a `TEXT` column.The `TEXT`
    columns don''t have a size limit.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`user`: This will create a foreign key to the project''s configured user model.
    In our case, we will go with the default `django.contrib.auth.models.User` that
    comes with Django. However, it''s still recommended to not hardcode this when
    we can avoid it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`created`: This will be automatically set to the date and time that the `Question` model
    was created.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Question` also implements the following two methods commonly seen on Django
    models (`__str__` and `get_absolute_url`):'
  prefs: []
  type: TYPE_NORMAL
- en: '`__str__()`: This tells Python how to convert our model to a string. This is
    useful in the admin backend, our own templates, and in debugging.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`get_absolute_url()`: This is a commonly implemented method that lets the model
    return the path of a URL to view this model. Not all models need this method.
    Django’s built-in views, such as `CreateView`, will use this method to redirect
    the user to the view after the model is created.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, in the spirit of *fat models*, we also have `can_accept_answers()`.
    The decision of who can accept an `Answer` to a `Question` lies with the `Question`.
    Currently, only the user who asked the question can accept an answer.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the `Question` s, we naturally need `Answer` s.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Answer model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll create the `Answer` model in the `django/questions/models.py` file as
    shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Answer` model has five fields and a `Meta` class. Let''s take a look at
    the fields first:'
  prefs: []
  type: TYPE_NORMAL
- en: '`answer`: This is an unlimited text field for the user''s answer. `answer`
    will become a `TEXT` column.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`user`: This will create a foreign key to the user model that our project has
    been configured to use. The user model will gain a new `RelatedManager` under
    the name `answer_set`, which will be able to query all the `Answer` s for a user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`question`: This will create a foreign key to our `Question` model. `Question`
    will also gain a new `RelatedManager` under the name `answer_set`, which will
    be able to query all the `Answer` s to a `Question`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`created`: This will be set to the date and time when the `Answer` was created.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`accepted`: This is a Boolean that will be set to `False` by default. We''ll
    use it to mark accepted answers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A model's `Meta` class lets us set metadata for our model and table. For `Answer`,
    we're using the `ordering` option to ensure that all queries will be ordered by
    `created`, in descending order. In this way, we ensure that the newest answers
    will be listed first, by default.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have `Question` and `Answer` models, we will need to create migrations
    to create their tables in the database.
  prefs: []
  type: TYPE_NORMAL
- en: Creating migrations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Django comes with a built-in migration library. This is part of Django's *batteries
    included* philosophy. Migrations provide a way to manage the changes that we will
    need to make to our schema. Whenever we make a change to a model, we can use Django
    to generate a migration, which will contain the instructions on how to create
    or change the schema to fit the new model's definition. To make the change to
    our database, we will apply the schema.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like many operations we perform on our project, we''ll use the `manage.py`
    script Django provides for our project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Now that we've created the migrations and applied them, let's set up a base
    template for our project so that our code works well.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a base template
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we create our views, let's create a base template. Django's template
    language allows templates to inherit from each other. A base template is a template
    that all our other project's templates will extend. This will give our entire
    project a common look and feel.
  prefs: []
  type: TYPE_NORMAL
- en: Since a project is composed of multiple apps and they will all use the same
    base template, a base template belongs to the project, not to any particular app.
    This is a rare exception to the rule that everything lives in an app.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add a project-wide templates directory, update `django/config/settings.py`.
    Check the `TEMPLATES` setting and update it to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In particular, the `DIRS` option for the `django.template.backends.django.DjangoTemplates` setting
    sets a project-wide template directory that will be searched. `''APP_DIRS'': True`
    means that each installed app’s `templates` directory will also be searched. In
    order for Django to search `django/templates`, we must add `os.path.join(BASE_DIR,
    ''templates'')` to the `DIRS` list.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating base.html
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Django comes with its own template language eponymously called the Django Template
    Language. Django templates are text files, which are rendered using a dictionary
    (called a context) to look up values. A template can also include tags (which
    use the `{% tag argument %}` syntax). A template can print values from its context
    using the `{{ variableName }}` syntax. Values can be sent to filters to tweak
    them before being displayed (for example, `{{ user.username | uppercase }}` will
    print the user’s username with all uppercase characters). Finally, the `{# ignored
    #}` syntax can comment out multiple lines of text.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll create our base template in `django/templates/base.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We won''t go over this HTML, but it''s worth reviewing the Django template
    tags involved:'
  prefs: []
  type: TYPE_NORMAL
- en: '`{% load static %}`: `load` lets us load template tag libraries that aren''t
    available by default. In this case, we''re loading the static library, which provides
    the `static` tag. The library and tag don''t always share their name. This is
    provided with Django by the `django.contrib.static` app.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`{% block title %}Answerly{% endblock %}`: Blocks let us define areas that
    templates can override when extending this template.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`{% static ''base.css'' %}`: The `static` tag (loaded in from the preceding `static`
    library) uses the `STATIC_URL` setting to create a reference to a static file.
    In this case, it will return `/static/base.css`. As long as the file is in a directory
    listed in `settings.STATICFILES_DIRS` and Django is in debug mode, Django will
    serve that file for us. For production, refer to [Chapter 9](2c6bf064-57ff-41bc-89d0-21fac1308186.xhtml),
    *Deploying Answerly*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That's enough for our `base.html` file to start. We'll update the navigation
    in `base.html` later, in the *Updating base.html navigation* section.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's configure Django to know how to find our `base.css` file by configuring
    static files.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring static files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next, let''s configure a directory for project-wide static files in `django/config/settings.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This will tell Django that any file in `django/static/` should be served while
    Django is in debug mode. For production, refer to [Chapter 9](2c6bf064-57ff-41bc-89d0-21fac1308186.xhtml),
    *Deploying Answerly*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s put some basic CSS in `django/static/base.css`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have created the foundation, let's create `AskQuestionView`.
  prefs: []
  type: TYPE_NORMAL
- en: Letting users post questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will now create a view for letting users post questions that they need answered.
  prefs: []
  type: TYPE_NORMAL
- en: Django follows **Model-View-Template** (**MVT**) pattern separate model, control,
    and presentation logic and encourage reusability. Models represent the data we'll
    store in the database. Views are responsible for handling a request and returning
    a response. Views should not have HTML. Templates are responsible for the body
    of a response and defining the HTML. This separation of responsibilities has proven
    to make it easy to write code.
  prefs: []
  type: TYPE_NORMAL
- en: 'To let users post questions, we''ll perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Make a form to process the questions
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make a view that uses Django forms to create questions
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make a template that renders the form in HTML
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `path` to the view
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: First, let's make the `QuestionForm` class.
  prefs: []
  type: TYPE_NORMAL
- en: Ask question form
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Django forms serve two purposes. They make it easy to render the body of a form
    to receive user input. They also validate the user input. When a form is instantiated,
    it can be given initial values (by the `intial` parameter) and data to validate
    (by the `data` parameter). A form which has been provided data is said to be bound.
  prefs: []
  type: TYPE_NORMAL
- en: Much of the power of Django comes from how easy it is to join models, forms,
    and views together to build features.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll make our form in `django/qanda/forms.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '`ModelForm` makes creating forms from Django models easier. We use the inner
    `Meta` class of `QuestionForm` to specify the model and fields that are part of
    the form.'
  prefs: []
  type: TYPE_NORMAL
- en: By adding a `user` field, we're able to override how Django renders the `user`
    field. We tell Django to use the `HiddenInput` widget, which will render the field
    as `<input type='hidden'>`. The `queryset` argument lets us restrict the users
    that are valid values (in our case, all users are valid). Finally, the `disabled`
    argument says that we will ignore any values provided by `data` (that is, from
    a request) and rely on the `initial` values we provide to the form.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how to render and validate a question form, let's create our
    view.
  prefs: []
  type: TYPE_NORMAL
- en: Creating AskQuestionView
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will create our `AskQuestionView` class in `django/qanda/views.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '`AskQuestionView` is derived from `CreateView` and uses the `LoginRequiredMixin`.
    The `LoginRequiredMixin` ensures that any request made by a user who is not logged
    in will be redirected to the login page. The `CreateView` knows to render the
    template for `GET` requests and to validate the form on `POST` requests. If a
    form is valid, `CreateView` will call `form_valid`. If the form is not valid,
    `CreateView` will re-render the template.'
  prefs: []
  type: TYPE_NORMAL
- en: Our `form_valid` method overrides the original `CreateView` method to support
    a save and preview mode. When we want to save, we will call the original `form_valid`
    method. The original method saves the new question and returns an HTTP response
    that redirects the user to the new question (using `Question.get_absolute_url()`).
    When we want to preview the question, we will re-render our template with the
    new `preview` variable in our template's context.
  prefs: []
  type: TYPE_NORMAL
- en: When our view is instantiating the form, it will pass the result of `get_initial()`
    as the `initial` argument and the `POST` data as the `data` argument.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our view, let's create `ask.html`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating ask.html
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create our template in `django/qanda/ask.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This template uses our `base.html` template and puts all its HTML in the `blocks`
    defined by there. When we render the template, Django renders `base.html` and
    then fills in the values of the blocks with the contents defined in `ask.html`.
  prefs: []
  type: TYPE_NORMAL
- en: '`ask.html` also loads two third-party tag libraries, `markdownify` and `crispy_forms_tags`.
    `markdownify` provides the `markdownify` filter used in the preview card’s body
    (`{{preview.question | markdownify}}`). The `crispy_forms_tags` library provides
    the `crispy` filter, which applies Bootstrap 4 CSS classes to help the Django
    form render nicely.'
  prefs: []
  type: TYPE_NORMAL
- en: Each of these libraries needs to be installed and configured, which we do in
    the following sections (*Installing and configuring Markdownify* and *Installing
    and configuring Django Crispy Forms*, respectively).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are a few more new tags that `ask.html` shows us:'
  prefs: []
  type: TYPE_NORMAL
- en: '`{% if preview %}`: This demonstrates how to use an `if` statement in the Django
    template language. We only want to render a preview of the `Question` if we have
    a `preview` variable in our context.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`{% csrf_token %}`: This tag adds the expected CSRF token to our form. CSRF
    tokens help protect us against malicious scripts trying to submit data on behalf
    of an innocent but logged-in user; refer to [Chapter 3](0121ce03-4293-49ea-b9ab-fb7956cb1a3c.xhtml),
    *Posters, Headshots, and Security*, for more information. In Django, CSRF tokens
    are not optional, and `POST` requests missing a CSRF token will not be processed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's take a closer look at those third-party libraries, starting with Markdownify.
  prefs: []
  type: TYPE_NORMAL
- en: Installing and configuring Markdownify
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Markdownify is a Django app available on the **Python Package Index** (**PyPI**)
    created by R Moelker and Erwin Matijsen and licensed under the MIT license (a
    popular open source license). Markdownify provides the Django template filter
    `markdownify`, which will convert Markdown to HTML.
  prefs: []
  type: TYPE_NORMAL
- en: Markdownify works by using the **python-markdown** package to convert Markdown
    to HTML. Marodwnify then uses Mozilla's `bleach`library to sanitize the resultiant
    HTML from Cross Site Scripting (**XSS**) attacks. The result is then returned
    to the template for output.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install Markdownify, let''s add it to our `requirements.txt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, run `pip` to install it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Now, we will need to add `markdownify` to our list of `INSTALLED_APPS` in `django/config/settings.py`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last step is to configure Markdownify to let it know which HTML tags to
    whitelist. Add the following settings to `settings.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This will whitiest all the text, list, and heading tags we want available to
    our users. Setting `MARKDOWNIFY_STRIP` to `False` tells Markdownify to HTML encode
    (rather than strip) any other HTML tag.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've configured Markdownify, let's install and configure Django Crispy
    Forms.
  prefs: []
  type: TYPE_NORMAL
- en: Installing and configuring Django Crispy Forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Django Crispy Forms is a third-party Django app available on PyPI. Miguel Araujo
    is the development lead. It is licensed under the MIT license. Django Crispy Forms
    is one of the most popular Django libraries because it makes it so easy to render
    pretty (crisp) forms.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the problems we encounter in Django is that when Django renders a field
    it will render it something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'However, in order to style that form nicely, for example, using Bootstrap 4,
    we would like to render something more like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Sadly, Django doesn't provide hooks that would let us easily wrap the field
    in a `div` with class `form-group`, or add CSS classes such as `form-control`
    or `form-control-label`.
  prefs: []
  type: TYPE_NORMAL
- en: Django Crispy Forms solves this with its `crispy` filter. If we send a form
    into it by performing `{{ form | crispy}}`, Django Crispy Forms will correctly
    transform the form's HTML and CSS to work with a variety of CSS frameworks (including
    Zurb Foundation, Bootstrap 3, and Bootstrap 4). You can further customize the
    form’s rendering through more advanced usage of Django Crispy Forms, but we won't
    be doing that in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install Django Crispy Forms, let''s add it to our `requirements.txt` and
    install it using `pip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Now, we will need to install it as a Django app in our project by editing `django/config/settings.py`
    and adding `'crispy_forms'` to our list of `INSTALLED_APPS`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will need to configure our project so that Django Crispy Forms knows
    to use the Bootstrap 4 template pack. Update `django/config/settings.py` with
    a new config:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Now that we've installed all the libraries our template relies on, we can configure
    Django to route requests to our `AskQuestionView`.
  prefs: []
  type: TYPE_NORMAL
- en: Routing requests to AskQuestionView
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Django routes requests using a URLConf. It's a list of `path()` objects that
    a request's path is matched against. The view of the first matching `path()` gets
    to process the request. A URLConf can include another URLConf. A project's settings
    defines its root URLConf (in our case, `django/config/urls.py`).
  prefs: []
  type: TYPE_NORMAL
- en: Defining all the `path()` objects for all the views in a project in the root
    URLConf can get messy and makes the apps less reusable. It’s often convenient
    to put a URLConf (usually in a `urls.py` file) in each app. Then, the root URLConf
    can use the `include()` function to include other apps' URLConfs to route requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a URLConf for our `qanda` app in `django/qanda/urls.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'A path has at least two components:'
  prefs: []
  type: TYPE_NORMAL
- en: First, a string defining the matching path. This may have named parameters that
    will be passed to the view. We'll see an example of this later, in the *Routing
    requests to the QuestionDetail view* section.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Second, a callable that takes a request and returns a response. If your view
    is a function (also known as a **Function-Based View** (**FBV**)), then you can
    just pass a reference to your function. If you're using a **Class-Based View**
    (**CBV**), then you can use its `as_view()` class method to return the required
    callable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optionally, a `name` parameter which we can use to reference this `path()` object
    in our view or template (for example, like the `Question` model does in its `get_absolute_url()`
    method).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is very strongly recommended that you name all your `path()` objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s update our root URLConf to include the `qanda` URLConf:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This means that requests to `answerly.example.com/ask` will route to our `AskQuestionView.`
  prefs: []
  type: TYPE_NORMAL
- en: A quick review of the section
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we have performed the following actions:'
  prefs: []
  type: TYPE_NORMAL
- en: Created our first form, `QuestionForm`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Created `AskQuestionView` that uses the `QuestionForm` to create `Question`
    s
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Created a template to render `AskQuestionView` and `QuestionForm`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installed and configured third-party libraries that provide filters for our
    template
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let’s allow our users to view questions with a `QuestionDetailView` class.
  prefs: []
  type: TYPE_NORMAL
- en: Creating QuestionDetailView
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `QuestionDetailView` has to offer quite a bit of functionality. It must
    be able to do the following things:'
  prefs: []
  type: TYPE_NORMAL
- en: Show the question
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Show all the answers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let users post additional answers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let the asker accept answer(s)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let the asker reject previously-accepted answers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although `QuestionDetailView` won't process any forms, it will have to display
    many forms, leading to a complicated template. This complexity will give us a
    chance to note how to split a template up into separate subtemplates to make our
    code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Answer forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We’ll need to make two forms to make `QuestionDetailView` work as described
    in the preceding section:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AnswerForm`: For users to post their answers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AnswerAcceptanceForm`: For the question''s asker to accept or reject answers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating AnswerForm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `AnswerForm` will have to reference a `Question` model instance and a user
    because both are required to create an `Answer` model instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add our `AnswerForm` to `django/qanda/forms.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The `AnswerForm` class looks a lot like the `QuestionForm` class, though with
    slightly differently named fields. It uses the same technique of preventing a
    user from tampering with the `Question` associated with an `Answer` just as `QuestionForm`
    used to prevent tampering with the user of `Question`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we'll create a form to accept an `Answer`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating AnswerAcceptanceForm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An `Answer` is accepted if its `accepted` field is `True`. We''ll use a simple
    form to edit this field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Using `BooleanField` comes with a small wrinkle. If we want `BooleanField` to
    accept `False` values as well as `True` values, we must set `required=False`.
    Otherwise, `BooleanField` will get confused when it gets a `False` value, thinking
    that it actually didn’t receive a value.
  prefs: []
  type: TYPE_NORMAL
- en: We use a hidden input because we don't want users checking a checkbox and then
    having to click on submit. Instead, for each answer, we'll generate an accept
    form and a reject form, which the user can just submit with one click.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's write the `QuestionDetailView` class.
  prefs: []
  type: TYPE_NORMAL
- en: Creating QuestionDetailView
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have the forms we''ll use, we can create `QuestionDetailView` in
    `django/qanda/views.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '`QuestionDetailView` lets Django''s `DetailView` do most of the work. `DetailView`
    gets a `Question` `QuerySet` out of the default manager of `Question` (`Question.objects`).
    `DetailView` then uses the `QuerySet` to get a `Question` based on the `pk` it
    received in the path of the URL. `DetailView` also knows which template to render
    based on our app and model name (`appname/modelname_detail.html`).'
  prefs: []
  type: TYPE_NORMAL
- en: The only area where we've had to customize behavior of `DetailView` is `get_context_data()`.
    `get_context_data()` provides the context used to render the template. In our
    case, we use the method to add the forms we want rendered to context.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's make the template for `QuestionDetailView`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating question_detail.html
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our template for the `QuestionDetailView` will work slightly differently to our
    previous templates.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s what we''ll put in `django/qanda/templates/qanda/question_detail.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The preceding template seemingly doesn’t do anything itself. Instead, we use
    the `{% include %}` tag to include other templates inside this template, to make
    organizing our code simpler. `{% include %}` passes the current context to the
    new template, renders it, and inserts it in place.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at each of these sub templates in turn, staring with `dispaly_question.html`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the display_question.html common template
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ve put the HTML to display a question into its own sub template. This template
    can then be included by other templates to render a `question`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create it in `django/qanda/templates/qanda/common/display_question.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The HTML itself is pretty simple, and there are no new tags here. We reuse the
    `markdownify` tag and library that we have previously configured.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's look at the answer list template.
  prefs: []
  type: TYPE_NORMAL
- en: Creating list_answers.html
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The answer list template has to list all the answers for the question and also
    render whether the answer is accepted. If the user can accept (or reject) answers,
    then those forms are rendered too.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create the template in `django/qanda/templates/qanda/view_questions/question_answers.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Two things to observe about this template are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: There's a rare bit of logic in the template, `{% if answer.accepted and reject_form
    %}`. Generally, templates should be dumb and avoid knowing about business logic.
    However, avoiding this would have created a more complex view. This is a trade-off
    that we must always evaluate on a case-by-case basis.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `{% empty %}` tag is related to our `{% for answer in question.answer_set.all
    %}` loop. The `{% empty %}` is used in the case of an empty list, much like the
    Python's `for ... else` syntax.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, let's take a look at the post answer template.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the post_answer.html template
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the next template we're going to create, the user can post and preview their
    answer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create our next template in `django/qanda/templates/qanda/common/post_answer.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This template is quite simple, sampling rendering the `answer_form` using the `crispy`
    filter.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have all our subtemplates done, let's create a `path` to route requests
    to `QuestionDetailView`.
  prefs: []
  type: TYPE_NORMAL
- en: Routing requests to the QuestionDetail view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To be able to route requests to our `QuestionDetailView`, we need to add it
    to the URLConf in `django/qanda/urls.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we see `path` taking a named parameter `pk`, which must
    be an integer. This will be passed to the `QuestionDetailView` and available in
    the `kwargs` dictionary. `DetailView` will rely on the presence of this argument
    to know which `Question` to retrieve.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we'll create some of the form-related views we referenced in our templates.
    Let's start with the `CreateAnswerView` class.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the CreateAnswerView
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `CreateAnswerView` class will be used to create and preview `Answer` model
    instance for a `Question` model instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create it in `django/qanda/views.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The `CreateAnswerView` class follows a similar pattern to the `AskQuestionView` class:'
  prefs: []
  type: TYPE_NORMAL
- en: It's a `CreateView`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s protected by `LoginRequiredMixin`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It uses `get_initial()` to provide initial arguments to its form so malicious
    users can't tamper with the question or user associated with the answer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It uses `form_valid()` to perform a preview or save operation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The main difference is that we will need to add a `get_question()` method in `CreateAnswerView` to
    retrieve the question we're answering. `kwargs['pk']` will be populated by the
    `path` we'll create (just like we did for `QuestionDetailView`).
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's create the template.
  prefs: []
  type: TYPE_NORMAL
- en: Creating create_answer.html
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This template will be able to leverage the common template elements we've already
    created to make rendering the question and answer forms easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create it in `django/qanda/templates/qanda/create_answer.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The preceding template introduces a new use of `{% include %}`. When we use
    the `with` argument, we can then pass a series of new names that values should
    have in the subtemplate’s context. In our case, we will only add the `answer_form`
    to the context of `post_answer.html`. The rest of the context is still passed
    to `{% include %}`. We can prevent the rest of the context being passed if we
    add `only` as the last argument to `{% include %}`.
  prefs: []
  type: TYPE_NORMAL
- en: Routing requests to CreateAnswerView
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The final step is to connect the `CreateAnswerView` to the `qanda` URLConf
    by adding a new `path` to the `urlpatterns` list in `qanda/urls.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Next, we’ll make a view to process the `AnswerAcceptanceForm`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating UpdateAnswerAcceptanceView
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `accept_form` and `reject_form` variables we use in the `list_answers.html`
    template need a view to process their form submissions. Let’s add it to `django/qanda/views.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '`UpdateView` works like a mix of `DetailView` (since it works on a single model)
    and `CreateView` (since it processes a form). Both `CreateView` and `UpdateView`
    share a common ancestor: `ModelFormMixin`. `ModelFormMixin` provides us with the
    hooks we’ve used so often in the past: `form_valid()`, `get_success_url()`, and
    `form_invalid()`.'
  prefs: []
  type: TYPE_NORMAL
- en: Thanks to the simplicity of this form, we will just respond to an invalid form
    by redirecting the user to the question.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s add it to our URLConf in `django/qanda/urls.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Remember to have a parameter named `pk` in your `path()` object's first argument
    so that `UpdateView` can retrieve the correct `Answer`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's create a daily list of questions.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the daily questions page
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To help people find questions, we'll create a list of each day's questions.
  prefs: []
  type: TYPE_NORMAL
- en: Django offers views to create yearly, monthly, weekly, and daily archive views.
    In our case, we'll use the `DailyArchiveView`, but they all work basically the
    same. They take a date from the URL's path and search for everything related during
    that period.
  prefs: []
  type: TYPE_NORMAL
- en: Let's build a daily question list using Django's `DailyArchiveView`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating DailyQuestionList view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s add our `DailyQuestionList` view to `django/qanda/views.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '`DailyQuestionList` need not override any methods of `DayArchiveView` just
    to let Django do the work. Let''s look at how it does it.'
  prefs: []
  type: TYPE_NORMAL
- en: '`DayArchiveView` expects to get a day, month, and year in the URL''s path.
    We can specify the format of these using `day_format`, `month_format`, and `year_format`.
    In our case, we change the expected format to `''%m''` so that the month is parsed
    as a number instead of the default `''%b''`, which is the short name of the month.
    These formats are the same, Python''s standard `datetime.datetime.strftime`. Once
    `DayArchiveView` has the date, it uses that date to filter the provided `queryset`
    using field named in the `date_field` attribute. The `queryset` is ordered by
    date. If `allow_empty` is `True`, then results will be rendered, otherwise a 404
    exception is thrown, for days with no items to list. To render the template, the
    object list is passed to the template much like a `ListView`. The default template
    is assumed to follow the `appname/modelname_archive_day.html` format.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's create the template for this view.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the daily question list template
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s add our template to `django/qanda/templates/qanda/question_archive_day.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The list of questions is much like one would expect, that is, a `<ul>` tag with
    a `{% for %}` loop creating `<li>` tags with links.
  prefs: []
  type: TYPE_NORMAL
- en: One of the conveniences of the `DailyArchiveView` (and all the date archive
    views) is that they provide their template's context with next and previous dates.
    These dates let us create a kind of pagination across dates.
  prefs: []
  type: TYPE_NORMAL
- en: Routing requests to DailyQuestionLists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finally, we''ll create a `path` to our `DailyQuestionList` view so that we
    can route requests to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Next, let's create a view to represent *today'*s questions.
  prefs: []
  type: TYPE_NORMAL
- en: Getting today’s question list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having a daily archive is good, but we want to provide a convenient way to access
    today's archive. We'll use a `RedirectView` to always redirect the user to the
    `DailyQuestionList` of today’s date.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add it to `django/qanda/views.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '`RedirectView` is a simple view that returns a 301 or 302 redirect response.
    We use Django’s `django.util.timezone` to get today''s date according to how Django
    has been configured. By default, Django is configured using **Coordinated Universal
    Time** (**UTC**). Due to the complexity of time zones, it''s often simplest to
    track everything in UTC and then adjust the display on the client side.'
  prefs: []
  type: TYPE_NORMAL
- en: We've now created all the views for our initial `qanda` app, letting users ask
    and answer questions. The asker can also accept answer(s) to their question.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's actually let the users log in, log out, and register with a `user`
    app.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the user app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we mentioned before, a Django app should have a clear scope. To that end,
    we'll create a separate Django app to manage users, which we will call `user`.
    We shouldn't place our user management code in `qanda` or the `Question` model
    in the `user` app.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create the app using `manage.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, add it to our list of `INSTALLED_APPS` in `django/config/settings.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: It's particularly important to keep the `user` app *before* the `admin` app,
    as they will both define login templates. The app that comes first will have their
    login template resolved first. We don't want our users redirected to the admin
    app.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s create a URLConf for our `user` app in `django/user/urls.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we''ll have the main URLConf in `django/config/urls.py` include the `user`
    app''s URLConf:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have our app configured, we can add our login and logout views.
  prefs: []
  type: TYPE_NORMAL
- en: Using Django's LoginView and LogoutView
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To provide the login and logout functionalities, we''ll use views provided
    by the `django.contrib.auth` app. Let''s update the `django/users/urls.py` to
    reference them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: These views take care of logging a user in and out. However, the login view
    requires a template to render nicely. The `LoginView` expects it under the `registration/login.html`
    name.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll put our template in `django/user/templates/registration/login.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The `LogoutView` doesn't require a template.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will need to inform our Django project''s `settings.py` about the login
    view''s location and the function it should perform when the user logs in and
    out. Let’s add some settings to `django/config/settings.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: This way, the `LoginRequiredMixin` can know the view to which we need to redirect
    unauthenticated users. We are also informing `LoginView` and `LogoutView` of  `django.contrib.auth` where
    to redirect the user when they log in and log out, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's give users a way to register for our site.
  prefs: []
  type: TYPE_NORMAL
- en: Creating RegisterView
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Django doesn''t provide a user registration view, but it does offer a `UserCreationForm`
    if we''re using `django.conrib.auth.models.User` as our user model. Since we are
    using `django.conrib.auth.models.User` we can use a simple `CreateView` for our
    registration view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we just need to create a template at `django/user/templates/register.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Again, our template is following a familiar pattern similar what we've seen
    in past views. We use our base template, blocks, and Django Crispy Form to create
    our page quickly and simply.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we can add a `path` to the view in the `user` URLConf''s `urlpatterns`
    list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Updating base.html navigation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have created all our views, we can update our base template''s
    `<nav>` to list all our URLs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Great! Now our user can always reach the most important pages on our site.
  prefs: []
  type: TYPE_NORMAL
- en: Running the development server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finally, we can access our development server using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Now we can open the site in a browser at [http://localhost:8000/](http://localhost::8000/).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we started our Answerly project. Answerly is composed of two
    apps (`user` and `qanda`), two third-party apps installed via PyPI (Markdownify
    and Django Crispy Forms), and a number of Django's built-in apps (`django.contrib.auth`
    being used most directly).
  prefs: []
  type: TYPE_NORMAL
- en: A logged-in user can now ask a question, answer questions, and accept answers.
    We can also see each day's highest-voted questions.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we'll help users discover questions more easily by adding search functionality
    using ElasticSearch.
  prefs: []
  type: TYPE_NORMAL
