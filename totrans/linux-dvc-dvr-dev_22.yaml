- en: Network Interface Card Drivers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We all know that networking is inherent to the Linux kernel. Some years ago,
    Linux was only used for its network performances, but things have changed now;
    Linux is much more than a server, and runs on billions of embedded devices. Through
    the years, Linux gained the reputation of being the best network operating system.
    In spite of all this, Linux cannot do everything. Given the huge variety of Ethernet
    controllers that exist, Linux has found no other way than to expose an API to
    developers who need a writing driver for their network device, or who need to
    perform kernel networking development in a general manner. This API offers a sufficient
    abstraction layer, allowing for gauranteeing the generosity of the developed code,
    as well as porting on other architectures. This chapter will simply walk through
    the part of this API that deals with **Network Interface Card** (**NIC** ) driver
    development, and discuss its data structures and methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: NIC driver data structure and a walk through its main socket buffer structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NIC driver architecture and methods description, as well as packets transmission
    and reception
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing a dummy NIC driver for testing purposes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Driver data structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you deal with NIC devices, there are two data structures that you need
    to play with:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `struct sk_buff` structure, defined in `include/linux/skbuff.h` , which
    is the fundamental data structure in the Linux networking code, and which should
    be included in your code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Each packet sent or received is handled using this data structure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `struct net_device` structure; this is the structure by which any NIC device
    is represented in the kernel. It is the interface by which data transit takes
    place. It is defined in `include/linux/netdevice.h` , which should also be included
    in your code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Other files that one should include in the code are `include/linux/etherdevice.h`
    for MAC and Ethernet-related functions (such as `alloc_etherdev()` ) and `include/linux/ethtool.h`
    for ethtools support:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The socket buffer structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This structure wraps any packet that transits through an NIC:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the meanings of the elements in the structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '`next` and `prev` : This represents the next and previous buffer in the list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sk` : This is the socket associated with this packet.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tstamp` : This is the time when the packet arrived/left.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rbnode` : This is an alternative to `next` /`prev` represented in a red-black
    tree.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dev` : This represents the device this packet arrived on/is leaving by. This
    field is associated with two other fields not listed here. These are `input_dev`
    and `real_dev` . They track devices associated with the packet. Therefore, `input_dev`
    always refers to a device the packet is received from.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`len` : This is the total number of bytes in the packet. Socket Buffers (SKBs)
    are composed of a linear data buffer and, optionally, a set of one or more regions
    called **rooms** . In case there are such rooms, `data_len` will hold the total
    number of bytes of the data area.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mac_len` : This holds the length of the MAC header.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`csum` : This contains the checksum of the packet.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Priority` : This represents the packet priority in QoS.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`truesize` : This keeps track of how many bytes of system memory are consumed
    by a packet, including the memory occupied by the `struct sk_buff` structure itself.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`users` : This is used for reference counting for the SKB objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Head` : Head, data, tail are pointers to different regions (rooms) in the
    socket buffer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`end` : This points to the end of the socket buffer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Only a few fields of this structure have been discussed here. A full description
    is available in `include/linux/skbuff.h` ., which is the header file you should
    include to deal with socket buffers.
  prefs: []
  type: TYPE_NORMAL
- en: Socket buffer allocation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Allocation of a socket buffer is a bit tricky, since it needs at least three
    different functions:'
  prefs: []
  type: TYPE_NORMAL
- en: First of all, the whole memory allocation should be done using the `netdev_alloc_skb()`
    function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Increase and align header room with the `skb_reserve()` function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extend the used data area of the buffer (which will contain the packet) using
    the `skb_put()` function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let us have a look at the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00044.gif)'
  prefs: []
  type: TYPE_IMG
- en: Socket buffers allocation process
  prefs: []
  type: TYPE_NORMAL
- en: 'We allocate a buffer large enough to contain a packet along with the Ethernet
    header by means of the `netdev_alloc_skb()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This function returns `NULL` on failure. Therefore, even if it allocates memory,
    `netdev_alloc_skb()` can be called from an atomic context.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the Ethernet header is 14 bytes long, it needs to have some alignment
    so that the CPU does not encounter any performance issues while accessing that
    part of the buffer. The appropriate name of the `header_len` parameter should
    be `header_alignment` , since this parameter is used for alignment. The usual
    value is 2, and it is the reason why the kernel defined a dedicated macro for
    this purpose, `NET_IP_ALIGN` , in `include/linux/skbuff.h` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The second step reserves aligned memory for the header by reducing the tail
    room. The function that does is `skb_reserve()` :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The last step consists of extending the used data area of the buffer to as
    large as the packet size, by means of the `skb_put()` function. This function
    returns a pointer to the first byte of the data area:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The allocated socket buffer should be forwarded to the kernel-networking layer.
    This is the last step of the socket buffer''s lifecycle. One should use the `netif_rx_ni()`
    function for that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We will discuss how to use the preceding steps in the section of this chapter
    that deals with packet reception.
  prefs: []
  type: TYPE_NORMAL
- en: Network interface structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A network interface is represented in the kernel as an instance of `struct
    net_device` structure, defined in `include/linux/netdevice.h` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `struct net_device` structure belongs to the kernel data structures that
    need to be allocated dynamically, having their own allocation function. An NIC
    is allocated in the kernel by means of the `alloc_etherdev()` function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The function returns `NULL` on failure. The `sizeof_priv` parameter represents
    the memory size to be allocated for a private data structure, attached to this
    NIC, and which can be extracted with the `netdev_priv()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Given the `struct priv_struct,` which is our private structure, the following
    is an implementation of how you allocate a network device along with the private
    data structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Unused network devices should be freed with the `free_netdev()` function, which
    also frees memory allocated for private data. You should call this method only
    after the device has been unregistered from the kernel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: After your `net_device` structure has been completed and filled, you should
    call `register_netdev()` on it. This function is explained later in this chapter
    in the section *Driver Methods* . Just keep in mind this function registers our
    network device with the kernel, so that it can be used. That being said, you should
    make sure the device really can process network operations before calling this
    function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The device methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Network devices fall into the category of devices not appearing in the `/dev`
    directory (unlike block, input, or char devices). Therefore, like all of those
    kinds of devices, the NIC driver exposes a set of facilities in order to perform.
    The kernel exposes operations that can be performed on the network interfaces
    by means of the `struct net_device_ops` structure, which is a field of the `struct
    net_device` structure, representing the network device (`dev->netdev_ops` ). The
    `struct net_device_ops` fields are described as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us see what the meaning of each element in the structure is:'
  prefs: []
  type: TYPE_NORMAL
- en: '`int (*ndo_init)(struct net_device *dev)` and `void(*ndo_uninit)(struct net_device
    *dev)` ; They are extra initialization/unitialization functions, respectively
    executed when the driver calls `register_netdev()` /`unregister_netdev()` in order
    to register/unregister the network device with the kernel. Most drivers do not
    provide those functions, since the real job is done by `ndo_open()` and `ndo_stop()`
    functions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int (*ndo_open)(struct net_device *dev)` ; Prepares and opens the interface.
    The interface is opened whenever `ip` or `ifconfig` utilities activate it. In
    this method, the driver should request/map/register any system resource it needs
    (I/O ports, IRQ, DMA, and so on), turn on the hardware, and perform any other
    setup the device requires.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int (*ndo_stop)(struct net_device *dev)` :The kernel executes this function
    when the interface is brought down (For example, `ifconfig <name> down` and so
    on). This function should perform reverse operations of what has been done in
    `ndo_open()` .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int (*ndo_start_xmit) (struct sk_buff *skb, struct net_device *dev)` : This
    method is called whenever the kernel wants to send a packet through this interface.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void (*ndo_set_rx_mode)(struct net_device *dev)` : This method is called to
    change the interface address list filter mode, multicast or promiscuous. It is
    recommended to provide this function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void (*ndo_tx_timeout)(struct net_device *dev)` : The kernel calls this method
    when a packet transmission fails to complete within a reasonable period, usually
    for `dev->watchdog` ticks. The driver should check what happened, handle the problem,
    and resume packet transmission.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`struct net_device_stats *(*get_stats)(struct net_device *dev)` : This method
    returns the device statistic. It is what one can see when `netstat -i` or `ifconfig`
    is run.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The preceding descriptions miss a lot of fields. The complete structure description
    is available in the `include/linux/netdevice.h` file. Actually, only `ndo_start_xmit`
    is mandatory, but it is a good practice to provide as many helper hooks as your
    device has features.
  prefs: []
  type: TYPE_NORMAL
- en: Opening and closing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `ndo_open()` function is called by the kernel whenever this network interface
    is configured by authorized users (admin for example) who make use of any user
    space utilities like `ifconfig` or `ip` .
  prefs: []
  type: TYPE_NORMAL
- en: Like other network device operations, the `ndo_open()` function receives a `struct
    net_device` object as its parameter, from which the driver should get the device-specific
    object stored in the `priv` field at the time of allocating the `net_device` object.
  prefs: []
  type: TYPE_NORMAL
- en: The network controller usually raises an interrupt whenever it receives or completes
    a packet transmission. The driver needs to register an interrupt handler that
    will be called whenever the controller raises an interrupt. The driver can register
    the interrupt handler either in the `init()` /`probe()` routine or in the `open`
    function. Some devices need the interrupt to be enabled by setting this in a special
    register in the hardware. In this case, one can request the interrupt in the `probe`
    function and just set/clear the enable bit in the open/close method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us summarize what the `open` function should do:'
  prefs: []
  type: TYPE_NORMAL
- en: Update the interface MAC address (in case the user changed it and if your device
    allows this).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reset the hardware if necessary, and take it out of the low-power mode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Request any resources (I/O memory, DMA channels, IRQ).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Map IRQ and register interrupt handlers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check the interface link status.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call `net_if_start_queue()` on the device in order to let the kernel know that
    your device is ready to transmit packets.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'An example of `open` function is follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '`netif_start_queue()` simply allows upper layers to call the device `ndo_start_xmit`
    routine. In other words, it informs the kernel that the device is ready to handle
    transmit requests.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The closing method on the other side just has to do the reverse of the operations
    done when the device was opened:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '`netif_stop_queue()` simply does the reverse of `netif_start_queue()` , telling
    the kernel to stop calling the device `ndo_start_xmit` routine. We can''t handle
    transmit request anymore.'
  prefs: []
  type: TYPE_NORMAL
- en: Packet handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Packet handling consists of transmission and reception of packets. This is the
    main task of any network interface driver. Transmission refers only to sending
    outgoing frames, whereas reception refers to frames coming in.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to drive networking data exchange: by polling or by interrupt.
    Polling, which is a kind of timer-driven interrupt, consists of a kernel continuously
    checking at given intervals for any change from the device. On the other hand,
    interrupt mode consists of the kernel doing nothing, listening to an IRQ line,
    and waiting for the device to notify a change, by means of the IRQ. Interrupt-driven
    data exchange can increase system overhead during time of high traffic. That is
    why some drivers mix the two methods. The part of the kernel that allows mixing
    of the two methods is called **New API** (**NAPI** ), which consists of using
    polling during times of high traffic and using interrupt IRQ-driven management
    when the traffic becomes normal. New drivers should use NAPI if the hardware can
    support it. However, NAPI is not discussed in this chapter, which will focus on
    the interrupt-driven method.'
  prefs: []
  type: TYPE_NORMAL
- en: Packet reception
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a packet arrives into the network interface card, the driver must build
    a new socket buffer around it, and copy the packet into the `sk_ff->data` field.
    The kind of copy does not really matter, and DMA can be used too. The driver is
    generally aware of new data arrivals by means of interrupts. When the NIC receives
    a packet, it raises an interrupt, which will be handled by the driver, which has
    to check the interrupt status register of the device and check the real reason
    why this interrupt was raised (in could be RX ok, RX error, and so on). Bit(s)
    that correspond to the event that raised the interrupt will be set in the status
    register.
  prefs: []
  type: TYPE_NORMAL
- en: 'The tricky part will be in allocating and building the socket buffer. But fortunately,
    we already discussed that in the first section of this chapter. So let''s not
    waste time and let''s jump to a sample RX handler. The driver has to perform as
    many `sk_buff` allocations as the number of packets it received:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The following helper is responsible for getting one packet from the device,
    forwarding it to the kernel network, and decrementing the packet counter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Of course the only reason we call the RX handler from within a deferred work
    is because we sit on an SPI bus. All of the preceding operations could be performed
    from within the hwriq in case of an MMIO device. Have a look at the NXP FEC driver,
    in `drivers/net/ethernet/freescale/fec.c` to see how this is achieved.
  prefs: []
  type: TYPE_NORMAL
- en: Packet transmission
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When the kernel needs to send packets out of the interface, it calls the driver's
    `ndo_start_xmit` method, which should return `NETDEV_TX_OK` on success, or `NETDEV_TX_BUSY`
    on failure, and in this case you can't do anything to the socket buffer since
    it is still owned by the network queuing layer when the error is returned. This
    means you cannot modify any SKB fields, or free the SKB, and so on. This function
    is protected from the concurrent call by a spinlock.
  prefs: []
  type: TYPE_NORMAL
- en: Packet transmission is done asynchronously in most cases. The `sk_buff` of the
    transmitted packet is filled by the upper layers. Its `data` field contains packets
    to be sent. Drivers should extract packet from `sk_buff->data` and write it into
    the device hardware FIFO, or put it into a temporary TX buffer (if the device
    needs a certain size of data before sending it) before writing it into the device
    hardware FIFO. Data is really only sent once the FIFO reaches a threshold value
    (usually defined by the driver, or provided in a device datasheet) or when the
    driver intentionally starts the transmission, by setting a bit (a kind of trigger)
    in a special register of the device. That being said, the driver needs to inform
    the kernel not to start any transmissions until the hardware is ready to accept
    new data. This notification is done by means of the `netif_st` `op_queue()` function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'After sending the packet, the network interface card will raise an interrupt.
    The interrupt handler should check why the interrupt has occurred. In case of
    transmission interrupt, it should update its statistics (`net_device->stats.tx_errors`
    and `net_device->stats.tx_packets` ), and notify the kernel that the device is
    free for sending new packets. This notification is done by means of `netif_wake_queue()`
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'To summarize, packet transmission is split into two parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ndo_start_xmit` operation, which notifies the kernel that the device is busy,
    set up everything, and starts the transfer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The TX interrupt handler, which updates TX statistics and notifies the kernel
    that the device is available again.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `ndo_start_xmit` function must roughly contain the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Call `netif_stop_queue()` on the network device in order to inform the kernel
    that the device will be busy in data transmission.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write `sk_buff->data` content into the device FIFO.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Trigger the transmission (instruct the device to start transmission).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Operations (2) and (3) may lead to sleep for devices sitting on slow buses (SPI
    for example) and may need to be deferred to the work structure. This is the case
    for our sample.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the packet is transferred, the TX interrupt handler should perform the
    following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Depending on the device being memory mapped or sitting on a bus whose access
    functions may sleep, the following operations should be performed directly in
    the hwirq handler or scheduled in a work (or threaded IRQ):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 1\. Check if the interrupt is a transmission interrupt.
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Read the transmission descriptor status register and see what the status
    of the packet is.
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Increment error statistics if there are any problems in the transmission.
  prefs: []
  type: TYPE_NORMAL
- en: 4\. Increment statistics of successful transmitted packets.
  prefs: []
  type: TYPE_NORMAL
- en: Start the transmission queue allowing the kernel to call the driver's `ndo_start_xmit`
    method again, by means of the `netif_wake_queue()` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let us summarize in a short sample code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: TX interrupt management will be discussed in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Driver example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can summarize the concepts discussed above in the following fake Ethernet
    driver:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the module is loaded and a device matched, an Ethernet interface will
    be created on the system. First, let us see what the `dmesg` command shows us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'If one runs the `ifconfig -a` command, the interface will be printed on the
    screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'One can finally configure the interface, assigning an IP address, so that it
    can be shown by using `ifconfig` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Status and control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Device control refers to a situation where the kernel needs to change properties
    of the interface on its own initiative, or in response to a user action. It can
    then use either operations exposed through the `struct net_device_ops` structure,
    as discussed, or use another control tool, **ethtool** , which requires the driver
    to introduce a new set of hooks that we will discuss in the next section. Conversely,
    status consists of reporting the state of the interface.
  prefs: []
  type: TYPE_NORMAL
- en: The interrupt handler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have only dealt with two different interrupts: when a new packet
    has arrived or when the transmission of an outgoing packet is complete; but now-a-days
    hardware interfaces are becoming smart, and they able to report their status either
    for sanity purposes, or for data transfer purposes. This way, network interfaces
    can also generate interrupts to signal errors, link status changes, and so on.
    They should all be handled in the interrupt handler.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what our hwrirq handler looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Because our device sits on an SPI bus, everything is deferred into a `work_struct`
    , which is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Ethtool support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Ethtool is a small utility for examining and tuning the settings of Ethernet-based
    network interfaces. With ethtool, it is possible to control various parameters
    like:'
  prefs: []
  type: TYPE_NORMAL
- en: Speed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Media type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Duplex operation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get/set eeprom register content
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hardware check summing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wake-on-LAN, and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drivers that need support from ethtool should include `<linux/ethtool.h>` .
    It relies on the `struct ethtool_ops` structure which is the core of this feature,
    and contains a set of methods for ethtool operations support. Most of these methods
    are relatively straightforward; see `include/linux/ethtool.h` for the details.
  prefs: []
  type: TYPE_NORMAL
- en: For ethtool support to be fully part of the driver, the driver should fill an
    `ethtool_ops` structure and assign it to the `.ethtool_ops` field of the `struct`
    `net_device` structure.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The macro `SET_ETHTOOL_OPS` can be used for this purpose too. Do note that your
    ethtool methods can be called even when the interface is down.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following drivers implement ethtool support:'
  prefs: []
  type: TYPE_NORMAL
- en: '`drivers/net/ethernet/microchip/enc28j60.c`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`drivers/net/ethernet/freescale/fec.c`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`drivers/net/usb/rtl8150.c`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Driver methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Driver methods are the `probe()` and `remove()` functions. They are responsible
    for (un)registering the network device with the kernel. The driver has to provide
    its functionalities to the kernel through the device methods by means of the `struct`
    `net_device` structure. These are the operations that can be performed on the
    network interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The preceding are the operations that most drivers implement.
  prefs: []
  type: TYPE_NORMAL
- en: The probe function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `probe` function is quite basic, and only needs to perform a device's early
    `init` , and then register our network device with the kernel.
  prefs: []
  type: TYPE_NORMAL
- en: 'In other words, the `probe` function has to:'
  prefs: []
  type: TYPE_NORMAL
- en: Allocate the network device along with its private data using the `alloc_etherdev()`
    function (helped by `netdev_priv()` ).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Initialize private data fields (mutexes, spinlock, work_queue, and so on). One
    should use work queues (and mutexes) in case the device sits on a bus whose access
    functions may sleep (SPI for example). In this case, the hwirq just has to acknowledge
    the kernel code, and schedule the work that will perform operations on the device.
    The alternative solution is to use threaded IRQs. If the device is MMIO, one can
    use spinlock to protect critical sections and get rid of work queues.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Initialize bus-specific parameters and functionalities (SPI, USB, PCI, and so
    on).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Request and map resources (I/O memory, DMA channel, IRQ).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If necessary, generate a random MAC address and assign it to the device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Fill the mandatories (or useful) netdev properties: `if_port` , `irq` , `netdev_ops`
    , `ethtool_ops` , and so on.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Put the device into the low-power state (the `open()` function will remove it
    from this mode).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, call `register_netdev()` on the device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With an SPI network device, the `probe` function can look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This whole chapter is heavily inspired by the enc28j60 from Microchip. You may
    have a look into its code in `drivers/net/ethernet/microchip/enc28j60.c` .
  prefs: []
  type: TYPE_NORMAL
- en: The `register_netdev()` function takes a completed `struct net_device` object
    and adds it to the kernel interfaces; 0 is returned on success and a negative
    error code is returned on failure. The `struct net_device` object should be stored
    in your bus device structure so that it can be accessed later. That being said,
    if your net device is part of a global private structure, it is that structure
    that you should register.
  prefs: []
  type: TYPE_NORMAL
- en: Do note that the duplicate device name may lead to registration failure.
  prefs: []
  type: TYPE_NORMAL
- en: Module unloading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is the cleaning function, which relies on two functions. Our driver release
    function could look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The `unregister_netdev()` function removes the interface from the system, and
    the kernel can no longer call its methods; `free_netdev()` frees the memory used
    by the `struct net_device` structure itself along with the memory allocated for
    private data, as well as any internally allocated memory related to the network
    device. Do note that you should never free `netdev->priv` by yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter has explained everything needed to write an NIC device driver.
    Even if the chapter relies on a network interface sitting on an SPI bus, the principle
    is the same for USB or PCI network interfaces. One can also use the dummy driver
    provided for testing purposes. After this chapter, it is obvious NIC drivers will
    no longer be mystery to you.
  prefs: []
  type: TYPE_NORMAL
