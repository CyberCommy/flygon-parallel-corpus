- en: Dynamic Typing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we explored JavaScript''s built-in values and types
    and covered some of the challenges involved when using them. The next natural
    step is for us to explore how JavaScript''s dynamic system plays out in the real
    world. Since JavaScript is a dynamically typed language, the variables in your
    code are not constrained in terms of the type of values they refer to. This introduces
    a huge challenge for the clean coder. Without certainty regarding our types, our
    code can break in unexpected ways and can become incredibly fragile. This fragility
    can be explained quite simply by imagining a numeric value embedded within a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we can see that the value is numeric but that it has been wrapped in
    a string literal and so, as far as JavaScript is concerned, is just a regular
    string. But because JavaScript is dynamic, we can freely pass this value around
    to any function—even a function that is expecting a number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The function adds a margin value to the number via the `+=` operator. This operator,
    as we will learn later in this chapter, is an alias for the operation `a = a +
    b`, and the `+` operator here will, in the case of either operand being a `String`
    type, simply concatenate the two strings together. What's funny is that this simple
    and innocent-looking implementation detail is the crux of millions of exhausting
    debugging sessions that have occurred around the world at various times. Thankfully,
    knowing about this operator and its exact behavior will save you countless hours
    of pain and exhaustion, and will cement in your mind the importance of writing
    code that avoids the very trap we've fallen into with our `possiblyNumeric` value.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Detection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conversion, coercion, and casting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first crucial step in being able to wrangle our types with more ease is
    to learn about detection, which is the skill of being able to discern what type
    or types you're dealing with in the least complex way.
  prefs: []
  type: TYPE_NORMAL
- en: Detection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Detection refers to the practice of determining a value's type. Usually, this
    will be done with the intention of using that determined type to carry out specific
    behavior such as falling back to a default value or throwing an error in the case
    of misuse.
  prefs: []
  type: TYPE_NORMAL
- en: Due to JavaScript's dynamic nature, detecting types is an important practice
    that can often be a great aid to other programmers. If you can usefully throw
    errors or warnings when someone is using an interface incorrectly, it can mean
    a much more fluid and speedy flow of development for them. And if you can helpfully
    populate `undefined`, `null`, or empty values with smart defaults, then it'll
    allow you to provide a more seamless and intuitive interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, due to legacies within JavaScript, and some choices made in
    its design, detecting types can be challenging. A number of different approaches
    are used, some of which are not considered best practice. We will be going over
    all of these practices within this section. First, however, it''s worth discussing
    one fundamental question regarding detection: **what exactly are you trying to
    detect**?'
  prefs: []
  type: TYPE_NORMAL
- en: We often think we require a specific type in order to carry out certain actions,
    but due to JavaScript's dynamic nature, we may not need to do so. In fact, doing
    so can lead us to create needlessly restrictive or rigid code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider a function that accepts an array of `people` objects, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In our `registerPeopleForMarathon`, we may be tempted to implement some kind
    of check to ensure that the passed argument is of the expected type and structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Are these checks necessary? You may be inclined to say yes as they're ensuring
    our code is resilient (or defensive) toward potential error cases and is thus
    more reliable. But if we think about it, none of these checks are necessary to
    ensure the kind of reliability we're seeking. The intention of our checks, presumably,
    is to prevent downstream errors in the case that the wrong types or structures
    are passed to our function, but if we look closely at the preceding code, there
    are no risks of downstream errors of the types we're worried about.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first check we conduct is `Array.isArray(people)` to determine whether
    the `people` value is indeed an array. We are doing this, ostensibly, so that
    we can safely loop through the array. But, as we discovered in the previous chapter,
    the `for...of` iteration style is not dependent on its `of {...}` value being
    an array. All it cares about is that the value is iterable. An example of this
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we''ve used a generator as our iterable. This will work just an array
    would when being iterated over in `for...of`, so, technically, we could argue
    that our `registerPeopleForMarathon` function should accept such values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The checks we''ve made thus far would reject this value as it is not an array.
    Is there any sense in that? Do you remember the principle of abstraction and how
    we should be concerned with interface, not implementation? Seen this way, arguably,
    our `registerPeopleForMarathon` function does not need to know about the implementation
    detail of the passed value''s type. It only cares that the value performs according
    to its needs. In this case, it needs to loop through the value via `for...of`,
    so any iterable is suitable. To check for an iterable, we might employ a helper
    such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, consider that we are currently checking that all of our `person` values
    are instances of the `Person` constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Is it necessary for us to explicitly check the instance in this way? Could
    we, instead, simply check for the properties that we wish to access? Perhaps all
    we need to assert is that the properties are non-falsy (empty strings, null, undefined,
    zero, and so on):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This check is arguably more specific to our true needs. Checks like these are
    often called **duck-typing**, that is, *If it walks like a duck and it quacks
    like a duck, then it must be a duck*. We don't always need to check for specific
    types; we can check for the properties, methods, and characteristics that we're
    truly dependent on. By doing so, we are creating code that is more flexible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our new checks, when integrated into our function, would look something like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'By using a more flexible `isIterable` check and employing *duck-typing* on
    our `person` objects, our `registerPeopleForMarathon` function can now be passed;
    for example, here, we have a generator that yields plain objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This level of flexibility wouldn't have been possible if we had kept our strict
    type-checking in place. Stricter checks usually create more rigid code and needlessly
    limit flexibility. There is a balance to strike here, however. We cannot be endlessly
    flexible. It may even be the case that the rigidity and certainty provided by
    stricter type-checks enable us to ensure cleaner code in the long run. But the
    opposite may also be true. The balancing act of flexibility versus rigidity is
    one you should be constantly considering.
  prefs: []
  type: TYPE_NORMAL
- en: Generally, an interface's expectations should attempt to be as close as possible
    to the demands of the implementation. That is, we should not be performing detection
    or other checks unless the checks genuinely prevent errors within our implementation.
    Over-zealous checking may seem safer but may only mean that future requirements
    and use cases are more awkward to accommodate.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've covered the question of why we detect things and exposed some
    use cases, we can begin to cover the techniques of detection that JavaScript provides
    us with. We'll begin with the `typeof` operator.
  prefs: []
  type: TYPE_NORMAL
- en: The typeof operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first thing you''ll often be exposed to when you first try to detect a
    type in JavaScript is the `typeof` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The `typeof` operator accepts a single operand, to its right-hand-side, and
    will evaluate to one of eight possible string values, depending on the value that''s
    passed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If your operand is an identifier without a binding, that is, an undeclared
    variable, then `typeof` will usefully return `"undefined"` instead of throwing
    a `ReferenceError` like any other reference to that variable would do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '`typeof` is the only operator in the JavaScript language that does this. Every
    other operator and every other way of referencing a value will throw an error
    if that value is not yet declared.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Outside of detecting undeclared variables, `typeof` is really only useful when
    determining primitive types—and even that''s too generous since not all primitive
    types are detectable. A `null` value, for example, when passed to `typeof`, will
    evaluate to a rather useless `"object"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This is an unfortunate and unfixable legacy of the JavaScript language. It
    will likely never be fixed. To check for `null`, it is preferred to explicitly
    check for the value itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The `typeof` operator does not differentiate between different types of objects,
    except for functions. All non-function objects in JavaScript will return, plainly,
    `"object"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'All functions, whether declared via class definitions, method definitions,
    or plain function expressions, will evaluate to `"function"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: If `typeof class {}` evaluating to `"function"` is confusing, consider that,
    as we've learned, all classes are just constructor functions with a prepared prototype
    (which will later determine the `[[Prototype]]` of any produced instances). There's
    nothing special about them. Classes are not a unique type or entity within JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'When it comes to comparing the result of `typeof` to a given string, we can
    use either the strict equality (`===`) or abstract equality (`==`) operator. Since
    `typeof` always returns a string, we don''t have to worry about any discrepancies
    here, so whether you adopt a strict versus abstract equality check is up to you.
    These would both be fine, technically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The strict and abstract equality operators (double-equals and triple-equals)
    behave slightly differently, although when the values on both sides of the operator
    are of the same type, they act identically. Skip ahead to the *Operator* section
    to get the lowdown on how they differ. In general, it's best to prefer `===` over
    `==`.
  prefs: []
  type: TYPE_NORMAL
- en: In conclusion, the `typeof` operator is only a fair-weather friend. We cannot
    rely on it in all circumstances. Sometimes, we'll need to use other type detection
    techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Type-detecting techniques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Given the unsuitability of the `typeof` operator for detecting a number of types,
    especially objects, we have to rely on a number of different approaches, depending
    on the exact thing we want to check. Sometimes, we may want to detect a characteristic
    instead of a type, for example, whether an object is an instance of a constructor
    or whether it's just a plain object. In this section, we'll be exploring a number
    of common detection needs and their solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting Booleans
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Booleans are thankfully very simple to check. The `typeof` operator correctly
    evaluates to `"boolean"` for values of `true` and `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: It's rare that we'll want to do this, though. Usually, when you are receiving
    a `Boolean` value, you are most interested in checking its truthiness rather than
    its type.
  prefs: []
  type: TYPE_NORMAL
- en: 'When placing a Boolean value in a Boolean context, such as a conditional statement,
    we are implicitly relying on its truthiness or falsiness. For example, take the
    following check:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This check does not determine whether the `isEnabled` value is truly Boolean.
    It just checks that it evaluates to something truthy. What are all the possible
    values that `isEnabled` could be? Is there a list of all these truthy values?
    These values are virtually infinite, so there is no list. All we can say about
    truthy values is that they are not falsy. And as we know, there are only seven
    falsy values. If we wish to observe the truthiness or falsiness of specific values,
    we can always cast to a `Boolean` via the `Boolean` constructor invoked as a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In most situations, the implicit coercion to a `Boolean` is sufficient and
    won''t end up biting us, but if we ever wish to absolutely determine that a value
    is both `Boolean` and specifically `true` or `false`, we can use the strict equality
    operator to compare them, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Due to the dynamic nature of JavaScript, some people prefer this level of certainty
    but usually, it isn't necessary. If the value we are checking is obviously intended
    as a `Boolean` value, then we can use it as so. Checking for its type via `typeof`
    or strict equality is usually unnecessary unless there is a possibility that the
    value may be non-`Boolean`.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the case of a `Number`, we can rely on the `typeof` operator to correctly
    evaluate to `"number"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'However, it will also evaluate to `"number"` in the case of `NaN`, `Infinity`,
    and `-Infinity`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Because of this, we may wish to carry out additional checks to determine whether
    a number is not any of those values. Thankfully, JavaScript provides native helpers
    for just this scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '`isFinite(n)`: Returns `true` if `Number(n)` is not `Infinity`, `-Infinity`,
    or `NaN`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isNaN(n)`: Returns `true` if `Number(n)` is not `NaN`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Number.isNaN(n)`: Returns `true` if `n` is not `NaN`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Number.isFinite(n)`: Returns `true` if `n` is not `Infinity`, `-Infinity`,
    or `NaN`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both of the global variants are older parts of the language and, as you can
    see, are slightly different than their `Number.*` equivalents. Global `isFinite`
    and `isNaN` cast their values to a number via `Number(n)`, while the equivalent
    `Number.*` methods do not do this. The reason for this difference is mostly one
    of legacy.
  prefs: []
  type: TYPE_NORMAL
- en: 'The more recently added `Number.isNaN` and `Number.isFinite` were introduced
    to enable more explicit checks without relying on casting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, `Number.isNaN` is more restrictive as it won''t cast the value
    to a `Number` before checking for `NaN`. With the `''foo''` string, we would need
    to cast it to `Number` (and thus evaluate to `NaN`) before we passed it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The global `isFinite` function works in the same way, that is, it casts its
    value to a number before checking for finiteness, while the `Number.isFinite`
    method will do no casting whatsoever:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: If you are confident that your value is already a number, then you may as well
    use the more succinct `isNaN` and `isFinite` as their implicit casting will have
    no effect on you. And if you'd like for JavaScript to attempt to cast your non-`Number`
    value to `Number`, then you should, once again, use `isNaN` and `isFinite`. If,
    however, you require an explicit check for whatever reason, then you should use
    `Number.isNaN` and `Number.isFinite`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Combining all of these discussed checks, we are able to confidently detect
    a number that is neither `NaN` nor `Infinity` by using `typeof` in combination
    with the global `isFinite`. As we mentioned previously, `isFinite` will check
    for `NaN` itself, so we needn''t bother with an additional `isNaN` check:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: When it comes to detection, your needs should be driven by the context of your
    code. For example, it may not be necessary to check for finite numbers if you're
    embedded in a piece of code where you can safely assume the number is finite.
    But if you're building a more public API, then you may want to conduct such checks
    before sending those values down into your internal interfaces, both to reduce
    the possibilities of bugs and to provide your users with helpful and sensible
    errors or warnings.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Detecting strings is pleasantly simple. The `typeof` operator is all we need:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to check for the length of a given `String`, we can simply use the
    `length` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'If we need to check whether a `String` has a length greater than 0, we can
    either explicitly do so via `length` or rely on the falsiness of a 0 length, or
    even rely on the falsiness of the empty `string` itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'If we''re only checking for the truthiness of a value, then we are also potentially
    detecting all potential truthy values, including non-zero numbers and objects.
    To be completely sure that you have a `String` and that it is not empty, the most
    succinct technique is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Emptiness by itself, however, may not be all we''re interested in. We may wish
    to detect whether a string has actual content in it. In most cases, *actual content*
    starts at the beginning of the `String` and ends at the end of the `String`, but
    in some cases, it may be embedded within whitespace on either side. To account
    for this, we can trim the `String` and then confirm its emptiness:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Notice that our function, `isNonEmptyString`, is using a `length > 0` check
    on the trimmed string instead of just relying on its falsiness as an empty string.
    This is so that we can safely and confidently know that our `isNonEmptyString`
    function will always return a Boolean value. Even though, 99% of the time, it
    will be used in a Boolean context such as `if (isNonEmptyString(...))`, we should
    still ensure that our function has an intuitive and consistent contract.
  prefs: []
  type: TYPE_NORMAL
- en: The logical `AND` operator (`a && b`) will, if its left-hand side is truthy,
    return its right-hand side. Therefore, expressions such as `typeof str === "string"
    && str` are not always guaranteed to return a `Boolean`. Go to the *Operator –
    Logical Operators – Logical AND Operator* section of [Chapter 8](d8c326c9-db6f-4562-b92d-975dd0159182.xhtml),
    *Operators* for more information.
  prefs: []
  type: TYPE_NORMAL
- en: Strings are simple to detect, but as we mentioned in the previous chapter, working
    with them can be a challenge due to Unicode. Therefore, it's vital to remember
    that while the detection of a string may provide us some certainty, it does not
    tell us what is inside the string and whether it is the value we're expecting.
    If your detections have the intention of providing a guide or warning to those
    who are using your interface, you might be better served by explicitly checking
    the contents of the value.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting undefined
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `undefined` type can be checked directly by referring to its globally available
    value via the strict equality operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Unfortunately, however, since undefined can be overridden within non-global
    scopes (depending on your precise setup and environment), this approach can be
    troublesome. Historically, `undefined` could be overridden globally. This meant
    that things like this were possible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The `void` operator, as we will explore later, takes one operand to its right-hand
    side (`void foo`) and will always evaluate to `undefined`. As such, `void 0` has
    become a synonym for `undefined` and is useful as a substitute. So, if you have
    low confidence in the `undefined` value, then you can simply check for `void 0`
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Various other approaches emerged to ensure a reliable `undefined` value. One,
    for example, would simply declare an unassigned variable (which will always default
    to `undefined`) and then use that within the scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Over time, the mutability of the `undefined` value has been locked down. *ECMAScript
    2015* forbade global modification, but curiously still allowed local modification.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thankfully, it has always remained possible to check for `undefined` via the
    simple `typeof` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Using `typeof` in this way is far less risky than relying on `undefined` as
    a literal value, though with the advent of linting tools, it is generally safe
    to directly check for `undefined`.
  prefs: []
  type: TYPE_NORMAL
- en: We'll explore ESLint, a popular JavaScript linting tool, in [Chapter 15](be9ab437-faeb-4a14-8a5f-663ddba470fd.xhtml),
    *Tools For Cleaner Code*. In the case of overwriting `undefined` in a local scope,
    which is unquestionably a bad thing to do, it'll helpfully give us a warning.
    Such warnings can provide us with a level of confidence, allowing us to safely
    use previously risky aspects of the language.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting null
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we''ve seen, `typeof null` evaluates to `"object"`. This is an odd legacy
    of the language. Unfortunately, it means that we cannot rely on `typeof` for the
    detection of `null`. Instead, we must compare to the literal `null` value directly
    using a strict quality operator, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Unlike `undefined`, `null` cannot be overwritten in any version of the language,
    nor in any environment, and so it doesn't come with any headaches around its usage.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting null or undefined
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we''ve covered how to independently check for both `undefined` and
    `null`, but we may want to check for both at the same time. It''s quite common,
    for example, to have a function signature that has an optional argument. And if
    that argument is not passed or is explicitly set to `null`, it''s normal to fall
    back to some default value. This can be achieved by explicitly checking for both
    `null` and `undefined`, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Often, since both `null` and `undefined` are falsy values, it is quite normal
    to imply their presence by checking the falsiness of a given value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'This, however, will also check whether the value is any of the other falsy
    values (including, `false`, `NaN`, 0, and so on). So, if we want to confirm that
    a value is specifically `null` or `undefined`, and no other falsy value, then
    we should stick to the explicit variation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Even more succinctly, however, we can adopt the abstract (non-strict) equality
    operator to check for either `null` or `undefined` since it considers these values
    to be equal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Although this utilizes the generally frowned-upon abstract equality operator
    (which we'll explore later in this chapter), it is still a popular way to check
    for both `undefined` and `null`. This is due to its succinct nature. However,
    adopting this more succinct check makes the code less obvious. It may even leave
    the impression that the author meant to check solely for `null`. This ambiguity
    of intent should leave us doubting its cleanliness. Therefore, in most situations,
    we should opt for the more explicit and strict check.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Detecting arrays in JavaScript is thankfully very straightforward due to the
    `Array.isArray` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: What this method tells us is that the passed value was constructed via the array
    constructor or an array literal. However, it does not check the `[[Prototype]]`
    of the value, so it is entirely possible (although unlikely) that the value, although
    appearing like an array, may not have the characteristics you desire.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we believe that we need to check whether a value is an array, it''s important
    to ask ourselves what we''re really trying to detect. It may be the case that
    we can check for the characteristics we desire instead of the type itself. It''s
    crucial to consider what we will be doing with the value. If we are intending
    to loop over it via `for...of`, then it may be more suitable for us to check for
    its iterable-ness instead of its array-ness. As we mentioned earlier, we can employ
    a helper like this to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'If, alternatively, we are looking to use specific array methods such as `forEach`
    or `map`, then it''s best to check via `isArray` as this will give us as a reasonable
    level of confidence that these methods exist:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'If we were inclined to be really thorough, we could also individually check
    for specific methods, or we could even force the value into an array of our own
    so that we could operate on it freely while knowing that the value is truly an
    array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that copying an array-like value via the spread syntax (`[...value]`)
    will only work if the value is iterable. An example of when using `[...value]`
    is appropriate is when operating on `NodeLists` that have been returned from the
    DOM API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: A `NodeList` is not a true `Array`, so it does not give us access to native
    array methods. Due to this, it is useful to create and use a copy of it that is
    a true `Array`.
  prefs: []
  type: TYPE_NORMAL
- en: On the whole, it is safe to adopt and rely on `Array.isArray`, but it's important
    to consider whether you even need to check for `Array`, whether it's more appropriate
    to check for whether the value is iterable, or even whether it has a specific
    method or property. As with all other checks, we should seek to make it obvious
    what our intent is. If we're employing checks that are more obscure than `Array.isArray`,
    then it may be prudent to add a comment or abstract the operation away with a
    descriptively named function.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting instances
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To detect whether an object is an instance of a constructor, we can simply
    use the `instanceof` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The `instanceof` operator will be covered in more detail in [Chapter 8](d8c326c9-db6f-4562-b92d-975dd0159182.xhtml)*,
    Operators*.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting plain objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we say *plain* objects, we are typically referring to those that are constructed
    as either `Object` literals or via the `Object` constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'This is in contrast to other objects, such as those provided natively by the
    language (for example, arrays) and those that we construct ourselves via instantiating
    constructors (for example, `new Pokemon()`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The simplest way to detect a plain object is to inquire as to its `[[Prototype]]`.
    If it has a `[[Prototype]]` equal to `Object.prototype`, then we can say it is
    plain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Why would we need to know whether a value is a plain object? It may, for example,
    be useful to discern plain from non-plain objects when creating an interface or
    function that accepts configuration objects in addition to more complex object
    types.
  prefs: []
  type: TYPE_NORMAL
- en: In most situations, we will need to detect a plain object explicitly. Instead,
    we should rely only on the interface or data that it provides us. If a user of
    our abstraction wishes to pass us a non-plain object but it still has the properties
    that we require, then who are we to complain?
  prefs: []
  type: TYPE_NORMAL
- en: Conversion, coercion, and casting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have learned how to tell the difference between various types and
    characteristics within JavaScript using detection. As we have seen, detection
    is useful when needing to provide alternative values or warnings in the case of
    unexpected or incompatible values. There is an additional mechanism for dealing
    with such values, however: we can convert them from the values we don''t desire
    into the values we do desire.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to convert a value, we use a mechanism known as **casting**. Casting
    is the intentional and explicit derivation of one type from another type. In contrast
    to casting, there is also **coercion**. Coercion is the implicit and internal
    process of conversion employed by JavaScript when we use operators or language
    constructs that require specific types. An example of this would be when passing
    `String` values to a multiplication operator. The operator will naturally coerce
    its `String` operands to numbers so that it can attempt to multiply them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The underlying mechanisms in both *casting* and *coercion* are identical. They
    are both mechanisms of conversion. But how we access these low-level behaviors
    is key. If we do so explicitly, clearly communicating our intent, then the readers
    of our code will have a far nicer time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code, which contains two different mechanisms for converting
    a `String` into a `Number`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are using two different techniques to force the conversion of a value
    from a `String` into a `Number`. The `Number()` constructor, when called as a
    function, will internally convert the passed value into a `Number` primitive.
    The unary `+` operator will do the same, although it is arguably less clear. Coercion
    is even less clear as it often appears to occur as a side effect of some other
    operation. Here are some examples of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The `+` operator, when either operand is a string, will coerce the opposite
    operand to a string and then concatenate them both together. The `*` operator,
    when given arrays, will call `toString()` on them and then coerce the resulting
    `String` into `Number`, effectively meaning that `[2] * [3]` is equal to `2 *
    3`. Also, the division operator will coerce its operands to numbers before operating
    on them. All of these coercive behaviors are happening implicitly.
  prefs: []
  type: TYPE_NORMAL
- en: The line between *coercion* and *casting* is not set in stone. It is possible,
    for example, to explicitly and intentionally convert a type via a coercive side
    effect. Consider the expression `someString * 1`, which could be used to *cast*
    a string to a number, using coercion to do so. In our conversions, what's crucial
    is that we **clearly communicate our intent**.
  prefs: []
  type: TYPE_NORMAL
- en: Coercion, since it happens implicitly, can be the cause of many bugs and unexpected
    behaviors. To avoid this trap, we should always have a strong level of confidence
    in the types of our operands. Casting, however, is entirely intentional and can
    help create a more reliable code base. It's common, on the more public or exposed
    sides of your interfaces, to preemptively cast to the types you desire, just in
    case the types you've received are not correct.
  prefs: []
  type: TYPE_NORMAL
- en: 'Observe here how we are explicitly casting both `haystack` and `needle` values
    to the `String` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Since we're relying on the `indexOf()` method on the `haystack` string, it makes
    sense, depending on our desired level of defensiveness, to cast the `haystack`
    to a string so that we can ensure it has the method available. Casting `needle`
    to a string also encodes a higher level of certainty so that we, and fellow programmers,
    can feel at ease.
  prefs: []
  type: TYPE_NORMAL
- en: The defensive approach of preemptively casting values to protect against undesirable
    types is best when we're crafting reusable utilities, public-facing APIs, or any
    interfaces that'll be consumed in a way that reduces your confidence in the types
    you'll be receiving.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamically typed languages such as JavaScript are seen by many as an invitation
    to chaos. Such people may be used to the comfort and certainty provided by strictly
    typed languages. In truth, if wielded fully and carefully, a dynamic language
    can allow our code to be more thoughtfully composed and more resilient to the
    changing needs of users. In the remainder of this section, we'll be discussing
    the conversion to individual types, including the explicit casting mechanisms
    we can utilize and the various coercive behaviors the language adopts internally.
    We'll begin by looking at Boolean conversion.
  prefs: []
  type: TYPE_NORMAL
- en: Converting into a Boolean
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All values in JavaScript when converted into a Boolean will return `true` unless
    they are one of the seven falsy primitives (`false`, `null`, `undefined`, `0n`,
    `0`, `""`, and `NaN`), in which case they will return `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To cast a value to a Boolean, we can simply pass the value to the Boolean constructor,
    invoking it as a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The language will coerce values to Booleans when the values exist in a Boolean
    context. Here are some examples of such contexts (each marked with `HERE`):'
  prefs: []
  type: TYPE_NORMAL
- en: '`if ( HERE ) {...}`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`do {...} while (HERE)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`while (HERE) {...}`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`for (...; HERE; ...) {...}`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[...].filter(function() { return HERE })`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[...].some(function() { return HERE })`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This list is not exhaustive. There are quite a few other situations in which
    our values will be coerced to Booleans. It's usually quite easy to tell. If a
    language construct or natively-provided function or method allows you to specify
    one of two possible pathways (that is, *if X then do THIS otherwise do THAT*),
    then you can bet that it will be internally coercing whatever value you've expressed
    to a Boolean.
  prefs: []
  type: TYPE_NORMAL
- en: 'A common idiom for casting to a Boolean, in addition to the more explicit call
    to `Boolean()`, is the *double-bang*, that is, the unary logical `NOT` operator
    (`!`) repeated twice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Repeating the logical `NOT` operator twice will invert the Boolean representation
    of the value twice. It''s easier to understand the semantics of the *double-bang*
    by seeing it parenthesized:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'This is effectively doing four things:'
  prefs: []
  type: TYPE_NORMAL
- en: Casting the value to a Boolean (`Boolean(value)`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the value is `true`, then make it `false`. If the value is `false`, then
    return `true`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cast the resulting value to a Boolean (`Boolean(value)`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the value is `true`, then make it `false`. If the value is false, then return
    `true`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In other words: this does one logical NOT, followed by another, resulting in
    the Boolean representation of the original value itself.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Explicitly casting values to Booleans is especially useful when you''re creating
    a function or method that must return a Boolean value but deals with values that
    are not Boolean. For example, I may wish to create an `isNamePopulated` function
    that returns `false` if the name variable is not a populated string or is `null`
    or `undefined`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'This will helpfully return `false` if `name` is an empty `String`, `null`,
    or `undefined`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'It will incidentally also return `false` if `name` were any other falsy value
    (such as 0) and it would return `true` if `name` were any truthy value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: This may seem entirely undesirable but, in this context, it may be okay since
    we're already operating under the assumption that `name` is a `String`, `null`,
    or `undefined`, and so we only care about the function's fulfillment of its contract
    in regards to those values. How comfortable you are with this would depend entirely
    on your specific implementation and the interface it provides.
  prefs: []
  type: TYPE_NORMAL
- en: Converting into a String
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Casting a value to a `String` can be achieved by invoking the `String` constructor
    as a regular function (that is, not as a constructor):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Calling `String()` with your value is the most explicit and clear way of casting
    to a `String`, although there are more succinct patterns that are sometimes used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'These two expressions may appear equivalent, and for many values, they are.
    But, internally, they work differently. As we''ll see later, the `+` operator
    will discern whether a given operand is a `String` by calling its internal `ToPrimitive`
    mechanism in such a way that the operand''s `valueOf` (if it has one) will be
    queried before its `toString` implementation. However, when using template literals
    (such as ``${value}``), any interpolated values will be converted directly to
    strings (without going via `ToPrimitive`). There is always the possibility that
    a value''s `valueOf` and `toString` methods will provide different values. Take
    a look at the following example, which shows how we can manipulate the return
    values of the two seemingly equivalent expressions by defining our own `toString`
    and `valueOf` implementations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: This would be a rare situation to encounter but is still worth thinking about.
    Often, we presume that we can reliably cast *any* value to a string quite easily,
    but that may not always be the case.
  prefs: []
  type: TYPE_NORMAL
- en: 'Traditionally, it''s quite common to rely on a value''s `toString()` method
    and call it directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if the value is `null` or `undefined`, then you''ll receive a `TypeError`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, the `toString` method is not guaranteed to return `string`. Observe
    here how we can implement our own `toString` method that returns `Array`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Therefore, it is always advisable to cast to a `string` via the very explicit
    and clear `String(...)`. Using indirect forms of coercion, side effects, or blindly
    relying on `toString` can create unexpected results. Remember that even if you
    have a good knowledge of these mechanisms and feel comfortable using them, it
    doesn't mean other programmers will.
  prefs: []
  type: TYPE_NORMAL
- en: Converting into a Number
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Casting a value to a `Number` can be achieved by invoking the `Number` constructor
    as a regular function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, there is the unary plus `+` operator, which does essentially
    the same thing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'These are the only two approaches available for casting a non-`Number` to a
    `Number` type, but JavaScript also provides other techniques for extracting numerical
    values from strings. One such technique is `parseInt`, a globally available native
    function that accepts both a `String` and an optional `radix` argument (which
    defaults to *base 10*, that is, decimal). It will, naturally, coerce its first
    argument to a `String` if it is not already a `String` and then attempt to extract
    the first integer of the specified `radix` from the `String`. By doing this, you
    can achieve the following outcomes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'If the string has a prefix of `0x` or `0X`, then `parseInt` will assume the
    `radix` to be `16` (*hexadecimal*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Some browsers and other environments may also treat a prefix of `0` as an indicator
    of an octal `radix`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '`parseInt()` will also effectively trim the `String`, ignoring any initial
    whitespace, and will ignore all the content of the `String` beyond the first found
    integer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '`parseInt` is usually frowned upon due to its obscure mechanism of extracting
    an integer from `String` and the fact that it may dynamically pick its own `radix`
    if none is provided. If you must use `parseInt`, use it with caution and full
    awareness of how it operates. And always provide a `radix` argument.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In a similar spirit to `parseInt` there is also a native `parseFloat` function,
    which will attempt to extract a *float* (that is*, a floating-point number*) from
    a given `String`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '`parseFloat` will trim the string and then look for the longest set of characters
    from the *0^(th)* character that can be naturally parsed by the language in the
    same way a numeric literal may be parsed. As such, it works fine with Strings
    that include non-numeric characters beyond a parseable numeric sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Such a string would cause `NaN` to be evaluated if we passed it to `Number(...)`.
    So, in some rare cases, `parseFloat` may be more useful to you.
  prefs: []
  type: TYPE_NORMAL
- en: 'Both `parseFloat` and `parseInt` will convert their initial argument into a
    `String` before attempting extraction. As such, if your first argument is an object,
    you should be wary of how it may naturally coerce to a string. If your object
    implements distinct `toString` and `valueOf` methods, then you should expect `parseInt`
    and `parseFloat` to only use `toString` (unless `[Symbol.toPrimitive]()` is also
    implemented). This is in contrast to `Number(...)`, which will attempt to convert
    its argument into a `Number` directly (without first converting it into a `String`)
    and will thus prioritize `valueOf` over `toString`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: In most situations, converting any value into a `Number` should be attempted
    via `Number` or the unary plus `+` operator. You should only use `parseFloat`
    or `parseInt` if you have a specific need for their numerical extraction algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: Converting into a primitive
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Converting a value into its primitive representation is not something we can
    do directly, but is done implicitly (that is, *coercively*) by the language in
    a number of different situations, such as when you try to use the abstract equality
    operator, `==`, to compare a `String`, `Number`, or `Symbol` to a value that is
    an `Object`. The `Object`, in that scenario, will be converted into its primitive
    representation via an internal procedure called `ToPrimitive`, which in summary
    does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: If `object[Symbol.toPrimitive]` exists, and when called it returns a primitive
    value, use that
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If `object.valueOf` exists, and it returns a primitive (non-`Object`), use its
    return value
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If `object.toString` exists, use its return value
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can see `ToPrimitive` in action if we attempt a comparison with `==`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, if an object has all three methods (`[Symbol.toPrimitive]`,
    `valueOf`, and `toString`), then `[Symbol.toPrimitive]` will be used. If it has
    just `valueOf` and `toString`, then `valueOf` will be used. And, of course, if
    there is only `toString`, then it will be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is the possibility that `*2*` and `*3*` in that procedure will swap if
    `ToPrimitive` is called with a hint of `String` (meaning that it has been instructed
    to attempt to coerce to a `String` instead of any primitive). An example of such
    a case would be when you use a computed member access operator (`object[something]`),
    where if `something` is an object, it would be converted into a `String` via `ToPrimitive`
    with a hint of `String`, meaning `toString()` will be attempted before `valueOf()`.
    We can see this in action here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: We have both `toString` and `valueOf` defined on `something`, but only `toString`
    is used to determine which property to access on `object`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we do not define our own methods, such as `valueOf` and `toString`, then
    the default methods available on the `[[Prototype]]` of whatever object we''re
    using will be used instead. The primitive representation of an array, for example,
    is defined by `Array.prototype.toString`, which will simply join its elements
    together with a comma as a separator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'All types have their own natively provided `valueOf` and `toString` methods,
    so if we wish to force the `ToPrimitive` internal procedure to use our own methods,
    then we''ll need to override the native ones by supplying our object with its
    own methods directly or by inheriting from the `[[Prototype]]`. For example, if
    you wished to provide a custom array abstraction that had its own primitive conversion
    behavior, then you could implement it by extending the `Array` constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you''d be able to rely on your `CustomArray` instances being handled
    in their own unique way by the `ToPrimitive` procedure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: The coercive behaviors of all operators and native language constructs will
    vary. Any time you pass a value to a language construct or operator that is expecting
    a primitive (typically either a string or a number), it will likely be passed
    through `ToPrimitive`. As such, it's useful to know about this internal procedure.
    We'll refer to this section as well as we start to explore all of JavaScript's
    operators in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have continued to explore the innards of JavaScript, covering
    the dynamic nature of the language. We've seen how we can go about detecting various
    types and the nuanced intricacies of coercion and casting. These topics are difficult
    to pick up, but they will be useful. Many anti-patterns that appear in JavaScript
    code come down to fundamental misunderstandings of language constructs and mechanisms,
    so having a deep understanding of these topics will aid our ambition of writing
    clean code tremendously.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will continue our exploration of types by exploring
    JavaScript's operators. It's likely that you will already have a very good knowledge
    of many of these, but thanks to JavaScript's dynamic nature, their usage can sometimes
    yield unexpected results. For this reason, the next chapter dedicates itself fully
    to the careful exploration of the language's operators.
  prefs: []
  type: TYPE_NORMAL
