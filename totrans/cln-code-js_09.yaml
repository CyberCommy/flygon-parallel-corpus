- en: Dynamic Typing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态类型化
- en: 'In the previous chapter, we explored JavaScript''s built-in values and types
    and covered some of the challenges involved when using them. The next natural
    step is for us to explore how JavaScript''s dynamic system plays out in the real
    world. Since JavaScript is a dynamically typed language, the variables in your
    code are not constrained in terms of the type of values they refer to. This introduces
    a huge challenge for the clean coder. Without certainty regarding our types, our
    code can break in unexpected ways and can become incredibly fragile. This fragility
    can be explained quite simply by imagining a numeric value embedded within a string:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们探讨了JavaScript的内置值和类型，并涉及了在使用它们时涉及的一些挑战。接下来自然的步骤是探索JavaScript的动态系统在现实世界中是如何发挥作用的。由于JavaScript是一种动态类型的语言，代码中的变量在所引用的值的类型方面没有限制。这给清洁的编码者带来了巨大的挑战。由于我们的类型不确定，我们的代码可能以意想不到的方式中断，并且可能变得非常脆弱。这种脆弱性可以很简单地解释为想象一个嵌入在字符串中的数值：
- en: '[PRE0]'
  id: totrans-2
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here, we can see that the value is numeric but that it has been wrapped in
    a string literal and so, as far as JavaScript is concerned, is just a regular
    string. But because JavaScript is dynamic, we can freely pass this value around
    to any function—even a function that is expecting a number:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到该值是数值，但它已被包装在一个字符串文字中，因此在JavaScript看来，它只是一个普通的字符串。但由于JavaScript是动态的，我们可以自由地将这个值传递给任何函数，甚至是一个期望一个数字的函数：
- en: '[PRE1]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The function adds a margin value to the number via the `+=` operator. This operator,
    as we will learn later in this chapter, is an alias for the operation `a = a +
    b`, and the `+` operator here will, in the case of either operand being a `String`
    type, simply concatenate the two strings together. What's funny is that this simple
    and innocent-looking implementation detail is the crux of millions of exhausting
    debugging sessions that have occurred around the world at various times. Thankfully,
    knowing about this operator and its exact behavior will save you countless hours
    of pain and exhaustion, and will cement in your mind the importance of writing
    code that avoids the very trap we've fallen into with our `possiblyNumeric` value.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数通过`+=`运算符向数字添加了一个边距值。正如我们将在本章后面学到的那样，这个运算符是操作`a = a + b`的别名，而这里的`+`运算符，在任一操作数为`String`类型的情况下，将简单地将这两个字符串连接在一起。有趣的是，这个简单而无辜的实现细节是世界各地在不同时间发生的数百万次令人筋疲力尽的调试会话的关键。幸运的是，了解这个运算符及其确切的行为将为你节省无数个小时的痛苦和筋疲力尽，并且会牢固地铭记在你的脑海中，即避免我们已经陷入的`possiblyNumeric`值的陷阱的代码的重要性。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Detection
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测
- en: Conversion, coercion, and casting
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转换、强制转换和转型
- en: The first crucial step in being able to wrangle our types with more ease is
    to learn about detection, which is the skill of being able to discern what type
    or types you're dealing with in the least complex way.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 能够更轻松地处理我们的类型的第一个关键步骤是学习检测，即能够以最简单的方式辨别你正在处理的类型或类型的技能。
- en: Detection
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测
- en: Detection refers to the practice of determining a value's type. Usually, this
    will be done with the intention of using that determined type to carry out specific
    behavior such as falling back to a default value or throwing an error in the case
    of misuse.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 检测是指确定值的类型的实践。通常，这将是为了使用确定的类型来执行特定的行为，比如回退到默认值或在误用的情况下抛出错误。
- en: Due to JavaScript's dynamic nature, detecting types is an important practice
    that can often be a great aid to other programmers. If you can usefully throw
    errors or warnings when someone is using an interface incorrectly, it can mean
    a much more fluid and speedy flow of development for them. And if you can helpfully
    populate `undefined`, `null`, or empty values with smart defaults, then it'll
    allow you to provide a more seamless and intuitive interface.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 由于JavaScript的动态特性，检测类型是一种重要的实践，通常可以帮助其他程序员。如果你可以在某人错误地使用接口时有用地抛出错误或警告，那么对于他们来说，这意味着开发流程更加流畅和迅速。如果你可以有用地用智能默认值填充`undefined`、`null`或空值，那么它将允许你提供一个更无缝和直观的接口。
- en: 'Unfortunately, due to legacies within JavaScript, and some choices made in
    its design, detecting types can be challenging. A number of different approaches
    are used, some of which are not considered best practice. We will be going over
    all of these practices within this section. First, however, it''s worth discussing
    one fundamental question regarding detection: **what exactly are you trying to
    detect**?'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，由于JavaScript中的遗留问题和设计中的一些选择，检测类型可能是具有挑战性的。使用了许多不被认为是最佳实践的不同方法。我们将在本节中讨论所有这些实践。然而，首先值得讨论一个关于检测的基本问题：**你究竟想要检测什么**？
- en: We often think we require a specific type in order to carry out certain actions,
    but due to JavaScript's dynamic nature, we may not need to do so. In fact, doing
    so can lead us to create needlessly restrictive or rigid code.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常认为我们需要特定的类型才能执行某些操作，但由于JavaScript的动态特性，我们可能并不需要这样做。事实上，这样做可能导致我们创建不必要的限制性或僵化的代码。
- en: 'Consider a function that accepts an array of `people` objects, like so:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个接受`people`对象数组的函数，如下所示：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In our `registerPeopleForMarathon`, we may be tempted to implement some kind
    of check to ensure that the passed argument is of the expected type and structure:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`registerPeopleForMarathon`中，我们可能会想要实现某种检查，以确保传递的参数是预期的类型和结构：
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Are these checks necessary? You may be inclined to say yes as they're ensuring
    our code is resilient (or defensive) toward potential error cases and is thus
    more reliable. But if we think about it, none of these checks are necessary to
    ensure the kind of reliability we're seeking. The intention of our checks, presumably,
    is to prevent downstream errors in the case that the wrong types or structures
    are passed to our function, but if we look closely at the preceding code, there
    are no risks of downstream errors of the types we're worried about.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: 'The first check we conduct is `Array.isArray(people)` to determine whether
    the `people` value is indeed an array. We are doing this, ostensibly, so that
    we can safely loop through the array. But, as we discovered in the previous chapter,
    the `for...of` iteration style is not dependent on its `of {...}` value being
    an array. All it cares about is that the value is iterable. An example of this
    is as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here, we''ve used a generator as our iterable. This will work just an array
    would when being iterated over in `for...of`, so, technically, we could argue
    that our `registerPeopleForMarathon` function should accept such values:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The checks we''ve made thus far would reject this value as it is not an array.
    Is there any sense in that? Do you remember the principle of abstraction and how
    we should be concerned with interface, not implementation? Seen this way, arguably,
    our `registerPeopleForMarathon` function does not need to know about the implementation
    detail of the passed value''s type. It only cares that the value performs according
    to its needs. In this case, it needs to loop through the value via `for...of`,
    so any iterable is suitable. To check for an iterable, we might employ a helper
    such as this:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Also, consider that we are currently checking that all of our `person` values
    are instances of the `Person` constructor:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Is it necessary for us to explicitly check the instance in this way? Could
    we, instead, simply check for the properties that we wish to access? Perhaps all
    we need to assert is that the properties are non-falsy (empty strings, null, undefined,
    zero, and so on):'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This check is arguably more specific to our true needs. Checks like these are
    often called **duck-typing**, that is, *If it walks like a duck and it quacks
    like a duck, then it must be a duck*. We don't always need to check for specific
    types; we can check for the properties, methods, and characteristics that we're
    truly dependent on. By doing so, we are creating code that is more flexible.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: 'Our new checks, when integrated into our function, would look something like
    this:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'By using a more flexible `isIterable` check and employing *duck-typing* on
    our `person` objects, our `registerPeopleForMarathon` function can now be passed;
    for example, here, we have a generator that yields plain objects:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This level of flexibility wouldn't have been possible if we had kept our strict
    type-checking in place. Stricter checks usually create more rigid code and needlessly
    limit flexibility. There is a balance to strike here, however. We cannot be endlessly
    flexible. It may even be the case that the rigidity and certainty provided by
    stricter type-checks enable us to ensure cleaner code in the long run. But the
    opposite may also be true. The balancing act of flexibility versus rigidity is
    one you should be constantly considering.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: Generally, an interface's expectations should attempt to be as close as possible
    to the demands of the implementation. That is, we should not be performing detection
    or other checks unless the checks genuinely prevent errors within our implementation.
    Over-zealous checking may seem safer but may only mean that future requirements
    and use cases are more awkward to accommodate.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've covered the question of why we detect things and exposed some
    use cases, we can begin to cover the techniques of detection that JavaScript provides
    us with. We'll begin with the `typeof` operator.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: The typeof operator
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first thing you''ll often be exposed to when you first try to detect a
    type in JavaScript is the `typeof` operator:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当你第一次尝试在JavaScript中检测类型时，你通常会接触到的第一件事是`typeof`运算符：
- en: '[PRE11]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `typeof` operator accepts a single operand, to its right-hand-side, and
    will evaluate to one of eight possible string values, depending on the value that''s
    passed:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`typeof`运算符接受一个操作数，位于其右侧，并将根据传递的值之一求值为八种可能的字符串值之一：'
- en: '[PRE12]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If your operand is an identifier without a binding, that is, an undeclared
    variable, then `typeof` will usefully return `"undefined"` instead of throwing
    a `ReferenceError` like any other reference to that variable would do:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的操作数是一个没有绑定的标识符，也就是一个未声明的变量，那么`typeof`将有用地返回`"undefined"`，而不是像对该变量的任何其他引用一样抛出`ReferenceError`：
- en: '[PRE13]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`typeof` is the only operator in the JavaScript language that does this. Every
    other operator and every other way of referencing a value will throw an error
    if that value is not yet declared.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`typeof`是JavaScript语言中唯一执行此操作的运算符。如果尚未声明该值，那么任何其他运算符和引用值的方式都会抛出错误。'
- en: 'Outside of detecting undeclared variables, `typeof` is really only useful when
    determining primitive types—and even that''s too generous since not all primitive
    types are detectable. A `null` value, for example, when passed to `typeof`, will
    evaluate to a rather useless `"object"`:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 除了检测未声明的变量外，`typeof`在确定原始类型时真的只有用处——即使这太宽泛了，因为并非所有原始类型都是可检测的。例如，当传递给`typeof`时，`null`值将求值为一个相当无用的`"object"`：
- en: '[PRE14]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This is an unfortunate and unfixable legacy of the JavaScript language. It
    will likely never be fixed. To check for `null`, it is preferred to explicitly
    check for the value itself:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这是JavaScript语言的一个不幸且无法修复的遗留问题。它可能永远不会被修复。要检查`null`，最好明确检查值本身：
- en: '[PRE15]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `typeof` operator does not differentiate between different types of objects,
    except for functions. All non-function objects in JavaScript will return, plainly,
    `"object"`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`typeof`运算符在不是函数的不同类型的对象之间没有区别，除了函数。JavaScript中的所有非函数对象都会返回简单的`"object"`：'
- en: '[PRE16]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'All functions, whether declared via class definitions, method definitions,
    or plain function expressions, will evaluate to `"function"`:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 所有函数，无论是通过类定义、方法定义还是普通函数表达式声明的，都将求值为`"function"`：
- en: '[PRE17]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If `typeof class {}` evaluating to `"function"` is confusing, consider that,
    as we've learned, all classes are just constructor functions with a prepared prototype
    (which will later determine the `[[Prototype]]` of any produced instances). There's
    nothing special about them. Classes are not a unique type or entity within JavaScript.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`typeof class {}`求值为`"function"`让你感到困惑，那么请考虑我们所学到的，所有类都只是具有准备好的原型的构造函数（这将稍后确定任何生成实例的`[[Prototype]]`）。它们没有什么特别之处。类不是JavaScript中的独特类型或实体。
- en: 'When it comes to comparing the result of `typeof` to a given string, we can
    use either the strict equality (`===`) or abstract equality (`==`) operator. Since
    `typeof` always returns a string, we don''t have to worry about any discrepancies
    here, so whether you adopt a strict versus abstract equality check is up to you.
    These would both be fine, technically:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在比较`typeof`的结果与给定字符串时，我们可以使用严格相等(`===`)或抽象相等(`==`)运算符。由于`typeof`始终返回一个字符串，我们不必担心任何差异，所以你可以选择使用严格相等还是抽象相等检查。从技术上讲，这两种方法都可以：
- en: '[PRE18]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The strict and abstract equality operators (double-equals and triple-equals)
    behave slightly differently, although when the values on both sides of the operator
    are of the same type, they act identically. Skip ahead to the *Operator* section
    to get the lowdown on how they differ. In general, it's best to prefer `===` over
    `==`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 严格相等和抽象相等运算符（双等号和三等号）的行为略有不同，尽管当运算符两侧的值是相同类型时，它们的行为是相同的。请跳转到*运算符*部分，了解它们的区别。一般来说，最好优先使用`===`而不是`==`。
- en: In conclusion, the `typeof` operator is only a fair-weather friend. We cannot
    rely on it in all circumstances. Sometimes, we'll need to use other type detection
    techniques.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，`typeof`运算符只是一个晴天朋友。我们不能在所有情况下依赖它。有时，我们需要使用其他类型检测技术。
- en: Type-detecting techniques
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型检测技术
- en: Given the unsuitability of the `typeof` operator for detecting a number of types,
    especially objects, we have to rely on a number of different approaches, depending
    on the exact thing we want to check. Sometimes, we may want to detect a characteristic
    instead of a type, for example, whether an object is an instance of a constructor
    or whether it's just a plain object. In this section, we'll be exploring a number
    of common detection needs and their solutions.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到`typeof`运算符对于检测多种类型的不适用性，特别是对象，我们必须依赖于许多不同的方法，具体取决于我们想要检查的确切内容。有时，我们可能想要检测特征而不是类型，例如，一个对象是否是构造函数的实例，或者它只是一个普通对象。在本节中，我们将探讨一些常见的检测需求及其解决方案。
- en: Detecting Booleans
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测布尔值
- en: 'Booleans are thankfully very simple to check. The `typeof` operator correctly
    evaluates to `"boolean"` for values of `true` and `false`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔值检测起来非常简单。`typeof`运算符对`true`和`false`的值正确地求值为`"boolean"`：
- en: '[PRE19]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: It's rare that we'll want to do this, though. Usually, when you are receiving
    a `Boolean` value, you are most interested in checking its truthiness rather than
    its type.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，我们很少会想要这样做。通常，当你接收到一个`Boolean`值时，你最感兴趣的是检查它的真实性而不是它的类型。
- en: 'When placing a Boolean value in a Boolean context, such as a conditional statement,
    we are implicitly relying on its truthiness or falsiness. For example, take the
    following check:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当将布尔值放置在布尔上下文中时，比如条件语句，我们隐含地依赖于它的真实性或虚假性。例如，看下面的检查：
- en: '[PRE20]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This check does not determine whether the `isEnabled` value is truly Boolean.
    It just checks that it evaluates to something truthy. What are all the possible
    values that `isEnabled` could be? Is there a list of all these truthy values?
    These values are virtually infinite, so there is no list. All we can say about
    truthy values is that they are not falsy. And as we know, there are only seven
    falsy values. If we wish to observe the truthiness or falsiness of specific values,
    we can always cast to a `Boolean` via the `Boolean` constructor invoked as a function:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In most situations, the implicit coercion to a `Boolean` is sufficient and
    won''t end up biting us, but if we ever wish to absolutely determine that a value
    is both `Boolean` and specifically `true` or `false`, we can use the strict equality
    operator to compare them, like so:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Due to the dynamic nature of JavaScript, some people prefer this level of certainty
    but usually, it isn't necessary. If the value we are checking is obviously intended
    as a `Boolean` value, then we can use it as so. Checking for its type via `typeof`
    or strict equality is usually unnecessary unless there is a possibility that the
    value may be non-`Boolean`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: Detecting numbers
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the case of a `Number`, we can rely on the `typeof` operator to correctly
    evaluate to `"number"`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'However, it will also evaluate to `"number"` in the case of `NaN`, `Infinity`,
    and `-Infinity`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Because of this, we may wish to carry out additional checks to determine whether
    a number is not any of those values. Thankfully, JavaScript provides native helpers
    for just this scenario:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '`isFinite(n)`: Returns `true` if `Number(n)` is not `Infinity`, `-Infinity`,
    or `NaN`'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isNaN(n)`: Returns `true` if `Number(n)` is not `NaN`'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Number.isNaN(n)`: Returns `true` if `n` is not `NaN`'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Number.isFinite(n)`: Returns `true` if `n` is not `Infinity`, `-Infinity`,
    or `NaN`'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both of the global variants are older parts of the language and, as you can
    see, are slightly different than their `Number.*` equivalents. Global `isFinite`
    and `isNaN` cast their values to a number via `Number(n)`, while the equivalent
    `Number.*` methods do not do this. The reason for this difference is mostly one
    of legacy.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: 'The more recently added `Number.isNaN` and `Number.isFinite` were introduced
    to enable more explicit checks without relying on casting:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'As you can see, `Number.isNaN` is more restrictive as it won''t cast the value
    to a `Number` before checking for `NaN`. With the `''foo''` string, we would need
    to cast it to `Number` (and thus evaluate to `NaN`) before we passed it:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The global `isFinite` function works in the same way, that is, it casts its
    value to a number before checking for finiteness, while the `Number.isFinite`
    method will do no casting whatsoever:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: If you are confident that your value is already a number, then you may as well
    use the more succinct `isNaN` and `isFinite` as their implicit casting will have
    no effect on you. And if you'd like for JavaScript to attempt to cast your non-`Number`
    value to `Number`, then you should, once again, use `isNaN` and `isFinite`. If,
    however, you require an explicit check for whatever reason, then you should use
    `Number.isNaN` and `Number.isFinite`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: 'Combining all of these discussed checks, we are able to confidently detect
    a number that is neither `NaN` nor `Infinity` by using `typeof` in combination
    with the global `isFinite`. As we mentioned previously, `isFinite` will check
    for `NaN` itself, so we needn''t bother with an additional `isNaN` check:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: When it comes to detection, your needs should be driven by the context of your
    code. For example, it may not be necessary to check for finite numbers if you're
    embedded in a piece of code where you can safely assume the number is finite.
    But if you're building a more public API, then you may want to conduct such checks
    before sending those values down into your internal interfaces, both to reduce
    the possibilities of bugs and to provide your users with helpful and sensible
    errors or warnings.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: Detecting strings
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Detecting strings is pleasantly simple. The `typeof` operator is all we need:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In order to check for the length of a given `String`, we can simply use the
    `length` property:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'If we need to check whether a `String` has a length greater than 0, we can
    either explicitly do so via `length` or rely on the falsiness of a 0 length, or
    even rely on the falsiness of the empty `string` itself:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'If we''re only checking for the truthiness of a value, then we are also potentially
    detecting all potential truthy values, including non-zero numbers and objects.
    To be completely sure that you have a `String` and that it is not empty, the most
    succinct technique is as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Emptiness by itself, however, may not be all we''re interested in. We may wish
    to detect whether a string has actual content in it. In most cases, *actual content*
    starts at the beginning of the `String` and ends at the end of the `String`, but
    in some cases, it may be embedded within whitespace on either side. To account
    for this, we can trim the `String` and then confirm its emptiness:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Notice that our function, `isNonEmptyString`, is using a `length > 0` check
    on the trimmed string instead of just relying on its falsiness as an empty string.
    This is so that we can safely and confidently know that our `isNonEmptyString`
    function will always return a Boolean value. Even though, 99% of the time, it
    will be used in a Boolean context such as `if (isNonEmptyString(...))`, we should
    still ensure that our function has an intuitive and consistent contract.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: The logical `AND` operator (`a && b`) will, if its left-hand side is truthy,
    return its right-hand side. Therefore, expressions such as `typeof str === "string"
    && str` are not always guaranteed to return a `Boolean`. Go to the *Operator –
    Logical Operators – Logical AND Operator* section of [Chapter 8](d8c326c9-db6f-4562-b92d-975dd0159182.xhtml),
    *Operators* for more information.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Strings are simple to detect, but as we mentioned in the previous chapter, working
    with them can be a challenge due to Unicode. Therefore, it's vital to remember
    that while the detection of a string may provide us some certainty, it does not
    tell us what is inside the string and whether it is the value we're expecting.
    If your detections have the intention of providing a guide or warning to those
    who are using your interface, you might be better served by explicitly checking
    the contents of the value.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Detecting undefined
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `undefined` type can be checked directly by referring to its globally available
    value via the strict equality operator:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Unfortunately, however, since undefined can be overridden within non-global
    scopes (depending on your precise setup and environment), this approach can be
    troublesome. Historically, `undefined` could be overridden globally. This meant
    that things like this were possible:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The `void` operator, as we will explore later, takes one operand to its right-hand
    side (`void foo`) and will always evaluate to `undefined`. As such, `void 0` has
    become a synonym for `undefined` and is useful as a substitute. So, if you have
    low confidence in the `undefined` value, then you can simply check for `void 0`
    like so:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Various other approaches emerged to ensure a reliable `undefined` value. One,
    for example, would simply declare an unassigned variable (which will always default
    to `undefined`) and then use that within the scope:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Over time, the mutability of the `undefined` value has been locked down. *ECMAScript
    2015* forbade global modification, but curiously still allowed local modification.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: 'Thankfully, it has always remained possible to check for `undefined` via the
    simple `typeof` operator:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Using `typeof` in this way is far less risky than relying on `undefined` as
    a literal value, though with the advent of linting tools, it is generally safe
    to directly check for `undefined`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: We'll explore ESLint, a popular JavaScript linting tool, in [Chapter 15](be9ab437-faeb-4a14-8a5f-663ddba470fd.xhtml),
    *Tools For Cleaner Code*. In the case of overwriting `undefined` in a local scope,
    which is unquestionably a bad thing to do, it'll helpfully give us a warning.
    Such warnings can provide us with a level of confidence, allowing us to safely
    use previously risky aspects of the language.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: Detecting null
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we''ve seen, `typeof null` evaluates to `"object"`. This is an odd legacy
    of the language. Unfortunately, it means that we cannot rely on `typeof` for the
    detection of `null`. Instead, we must compare to the literal `null` value directly
    using a strict quality operator, as shown here:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Unlike `undefined`, `null` cannot be overwritten in any version of the language,
    nor in any environment, and so it doesn't come with any headaches around its usage.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Detecting null or undefined
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we''ve covered how to independently check for both `undefined` and
    `null`, but we may want to check for both at the same time. It''s quite common,
    for example, to have a function signature that has an optional argument. And if
    that argument is not passed or is explicitly set to `null`, it''s normal to fall
    back to some default value. This can be achieved by explicitly checking for both
    `null` and `undefined`, like so:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Often, since both `null` and `undefined` are falsy values, it is quite normal
    to imply their presence by checking the falsiness of a given value:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This, however, will also check whether the value is any of the other falsy
    values (including, `false`, `NaN`, 0, and so on). So, if we want to confirm that
    a value is specifically `null` or `undefined`, and no other falsy value, then
    we should stick to the explicit variation:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Even more succinctly, however, we can adopt the abstract (non-strict) equality
    operator to check for either `null` or `undefined` since it considers these values
    to be equal:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Although this utilizes the generally frowned-upon abstract equality operator
    (which we'll explore later in this chapter), it is still a popular way to check
    for both `undefined` and `null`. This is due to its succinct nature. However,
    adopting this more succinct check makes the code less obvious. It may even leave
    the impression that the author meant to check solely for `null`. This ambiguity
    of intent should leave us doubting its cleanliness. Therefore, in most situations,
    we should opt for the more explicit and strict check.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: Detecting arrays
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Detecting arrays in JavaScript is thankfully very straightforward due to the
    `Array.isArray` method:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: What this method tells us is that the passed value was constructed via the array
    constructor or an array literal. However, it does not check the `[[Prototype]]`
    of the value, so it is entirely possible (although unlikely) that the value, although
    appearing like an array, may not have the characteristics you desire.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: 'When we believe that we need to check whether a value is an array, it''s important
    to ask ourselves what we''re really trying to detect. It may be the case that
    we can check for the characteristics we desire instead of the type itself. It''s
    crucial to consider what we will be doing with the value. If we are intending
    to loop over it via `for...of`, then it may be more suitable for us to check for
    its iterable-ness instead of its array-ness. As we mentioned earlier, we can employ
    a helper like this to do so:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'If, alternatively, we are looking to use specific array methods such as `forEach`
    or `map`, then it''s best to check via `isArray` as this will give us as a reasonable
    level of confidence that these methods exist:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'If we were inclined to be really thorough, we could also individually check
    for specific methods, or we could even force the value into an array of our own
    so that we could operate on it freely while knowing that the value is truly an
    array:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Note that copying an array-like value via the spread syntax (`[...value]`)
    will only work if the value is iterable. An example of when using `[...value]`
    is appropriate is when operating on `NodeLists` that have been returned from the
    DOM API:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: A `NodeList` is not a true `Array`, so it does not give us access to native
    array methods. Due to this, it is useful to create and use a copy of it that is
    a true `Array`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: On the whole, it is safe to adopt and rely on `Array.isArray`, but it's important
    to consider whether you even need to check for `Array`, whether it's more appropriate
    to check for whether the value is iterable, or even whether it has a specific
    method or property. As with all other checks, we should seek to make it obvious
    what our intent is. If we're employing checks that are more obscure than `Array.isArray`,
    then it may be prudent to add a comment or abstract the operation away with a
    descriptively named function.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Detecting instances
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To detect whether an object is an instance of a constructor, we can simply
    use the `instanceof` operator:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The `instanceof` operator will be covered in more detail in [Chapter 8](d8c326c9-db6f-4562-b92d-975dd0159182.xhtml)*,
    Operators*.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: Detecting plain objects
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we say *plain* objects, we are typically referring to those that are constructed
    as either `Object` literals or via the `Object` constructor:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'This is in contrast to other objects, such as those provided natively by the
    language (for example, arrays) and those that we construct ourselves via instantiating
    constructors (for example, `new Pokemon()`):'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The simplest way to detect a plain object is to inquire as to its `[[Prototype]]`.
    If it has a `[[Prototype]]` equal to `Object.prototype`, then we can say it is
    plain:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Why would we need to know whether a value is a plain object? It may, for example,
    be useful to discern plain from non-plain objects when creating an interface or
    function that accepts configuration objects in addition to more complex object
    types.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: In most situations, we will need to detect a plain object explicitly. Instead,
    we should rely only on the interface or data that it provides us. If a user of
    our abstraction wishes to pass us a non-plain object but it still has the properties
    that we require, then who are we to complain?
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Conversion, coercion, and casting
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have learned how to tell the difference between various types and
    characteristics within JavaScript using detection. As we have seen, detection
    is useful when needing to provide alternative values or warnings in the case of
    unexpected or incompatible values. There is an additional mechanism for dealing
    with such values, however: we can convert them from the values we don''t desire
    into the values we do desire.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to convert a value, we use a mechanism known as **casting**. Casting
    is the intentional and explicit derivation of one type from another type. In contrast
    to casting, there is also **coercion**. Coercion is the implicit and internal
    process of conversion employed by JavaScript when we use operators or language
    constructs that require specific types. An example of this would be when passing
    `String` values to a multiplication operator. The operator will naturally coerce
    its `String` operands to numbers so that it can attempt to multiply them:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The underlying mechanisms in both *casting* and *coercion* are identical. They
    are both mechanisms of conversion. But how we access these low-level behaviors
    is key. If we do so explicitly, clearly communicating our intent, then the readers
    of our code will have a far nicer time.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code, which contains two different mechanisms for converting
    a `String` into a `Number`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Here, we are using two different techniques to force the conversion of a value
    from a `String` into a `Number`. The `Number()` constructor, when called as a
    function, will internally convert the passed value into a `Number` primitive.
    The unary `+` operator will do the same, although it is arguably less clear. Coercion
    is even less clear as it often appears to occur as a side effect of some other
    operation. Here are some examples of this:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The `+` operator, when either operand is a string, will coerce the opposite
    operand to a string and then concatenate them both together. The `*` operator,
    when given arrays, will call `toString()` on them and then coerce the resulting
    `String` into `Number`, effectively meaning that `[2] * [3]` is equal to `2 *
    3`. Also, the division operator will coerce its operands to numbers before operating
    on them. All of these coercive behaviors are happening implicitly.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: The line between *coercion* and *casting* is not set in stone. It is possible,
    for example, to explicitly and intentionally convert a type via a coercive side
    effect. Consider the expression `someString * 1`, which could be used to *cast*
    a string to a number, using coercion to do so. In our conversions, what's crucial
    is that we **clearly communicate our intent**.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Coercion, since it happens implicitly, can be the cause of many bugs and unexpected
    behaviors. To avoid this trap, we should always have a strong level of confidence
    in the types of our operands. Casting, however, is entirely intentional and can
    help create a more reliable code base. It's common, on the more public or exposed
    sides of your interfaces, to preemptively cast to the types you desire, just in
    case the types you've received are not correct.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: 'Observe here how we are explicitly casting both `haystack` and `needle` values
    to the `String` type:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Since we're relying on the `indexOf()` method on the `haystack` string, it makes
    sense, depending on our desired level of defensiveness, to cast the `haystack`
    to a string so that we can ensure it has the method available. Casting `needle`
    to a string also encodes a higher level of certainty so that we, and fellow programmers,
    can feel at ease.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: The defensive approach of preemptively casting values to protect against undesirable
    types is best when we're crafting reusable utilities, public-facing APIs, or any
    interfaces that'll be consumed in a way that reduces your confidence in the types
    you'll be receiving.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: Dynamically typed languages such as JavaScript are seen by many as an invitation
    to chaos. Such people may be used to the comfort and certainty provided by strictly
    typed languages. In truth, if wielded fully and carefully, a dynamic language
    can allow our code to be more thoughtfully composed and more resilient to the
    changing needs of users. In the remainder of this section, we'll be discussing
    the conversion to individual types, including the explicit casting mechanisms
    we can utilize and the various coercive behaviors the language adopts internally.
    We'll begin by looking at Boolean conversion.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: Converting into a Boolean
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All values in JavaScript when converted into a Boolean will return `true` unless
    they are one of the seven falsy primitives (`false`, `null`, `undefined`, `0n`,
    `0`, `""`, and `NaN`), in which case they will return `false`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: 'To cast a value to a Boolean, we can simply pass the value to the Boolean constructor,
    invoking it as a function:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The language will coerce values to Booleans when the values exist in a Boolean
    context. Here are some examples of such contexts (each marked with `HERE`):'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '`if ( HERE ) {...}`'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`do {...} while (HERE)`'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`while (HERE) {...}`'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`for (...; HERE; ...) {...}`'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[...].filter(function() { return HERE })`'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[...].some(function() { return HERE })`'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This list is not exhaustive. There are quite a few other situations in which
    our values will be coerced to Booleans. It's usually quite easy to tell. If a
    language construct or natively-provided function or method allows you to specify
    one of two possible pathways (that is, *if X then do THIS otherwise do THAT*),
    then you can bet that it will be internally coercing whatever value you've expressed
    to a Boolean.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: 'A common idiom for casting to a Boolean, in addition to the more explicit call
    to `Boolean()`, is the *double-bang*, that is, the unary logical `NOT` operator
    (`!`) repeated twice:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Repeating the logical `NOT` operator twice will invert the Boolean representation
    of the value twice. It''s easier to understand the semantics of the *double-bang*
    by seeing it parenthesized:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'This is effectively doing four things:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Casting the value to a Boolean (`Boolean(value)`).
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the value is `true`, then make it `false`. If the value is `false`, then
    return `true`.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cast the resulting value to a Boolean (`Boolean(value)`).
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the value is `true`, then make it `false`. If the value is false, then return
    `true`.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In other words: this does one logical NOT, followed by another, resulting in
    the Boolean representation of the original value itself.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: 'Explicitly casting values to Booleans is especially useful when you''re creating
    a function or method that must return a Boolean value but deals with values that
    are not Boolean. For example, I may wish to create an `isNamePopulated` function
    that returns `false` if the name variable is not a populated string or is `null`
    or `undefined`:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'This will helpfully return `false` if `name` is an empty `String`, `null`,
    or `undefined`:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'It will incidentally also return `false` if `name` were any other falsy value
    (such as 0) and it would return `true` if `name` were any truthy value:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: This may seem entirely undesirable but, in this context, it may be okay since
    we're already operating under the assumption that `name` is a `String`, `null`,
    or `undefined`, and so we only care about the function's fulfillment of its contract
    in regards to those values. How comfortable you are with this would depend entirely
    on your specific implementation and the interface it provides.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: Converting into a String
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Casting a value to a `String` can be achieved by invoking the `String` constructor
    as a regular function (that is, not as a constructor):'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Calling `String()` with your value is the most explicit and clear way of casting
    to a `String`, although there are more succinct patterns that are sometimes used:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'These two expressions may appear equivalent, and for many values, they are.
    But, internally, they work differently. As we''ll see later, the `+` operator
    will discern whether a given operand is a `String` by calling its internal `ToPrimitive`
    mechanism in such a way that the operand''s `valueOf` (if it has one) will be
    queried before its `toString` implementation. However, when using template literals
    (such as ``${value}``), any interpolated values will be converted directly to
    strings (without going via `ToPrimitive`). There is always the possibility that
    a value''s `valueOf` and `toString` methods will provide different values. Take
    a look at the following example, which shows how we can manipulate the return
    values of the two seemingly equivalent expressions by defining our own `toString`
    and `valueOf` implementations:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: This would be a rare situation to encounter but is still worth thinking about.
    Often, we presume that we can reliably cast *any* value to a string quite easily,
    but that may not always be the case.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: 'Traditionally, it''s quite common to rely on a value''s `toString()` method
    and call it directly:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'However, if the value is `null` or `undefined`, then you''ll receive a `TypeError`:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Additionally, the `toString` method is not guaranteed to return `string`. Observe
    here how we can implement our own `toString` method that returns `Array`:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Therefore, it is always advisable to cast to a `string` via the very explicit
    and clear `String(...)`. Using indirect forms of coercion, side effects, or blindly
    relying on `toString` can create unexpected results. Remember that even if you
    have a good knowledge of these mechanisms and feel comfortable using them, it
    doesn't mean other programmers will.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: Converting into a Number
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Casting a value to a `Number` can be achieved by invoking the `Number` constructor
    as a regular function:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Additionally, there is the unary plus `+` operator, which does essentially
    the same thing:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'These are the only two approaches available for casting a non-`Number` to a
    `Number` type, but JavaScript also provides other techniques for extracting numerical
    values from strings. One such technique is `parseInt`, a globally available native
    function that accepts both a `String` and an optional `radix` argument (which
    defaults to *base 10*, that is, decimal). It will, naturally, coerce its first
    argument to a `String` if it is not already a `String` and then attempt to extract
    the first integer of the specified `radix` from the `String`. By doing this, you
    can achieve the following outcomes:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'If the string has a prefix of `0x` or `0X`, then `parseInt` will assume the
    `radix` to be `16` (*hexadecimal*):'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Some browsers and other environments may also treat a prefix of `0` as an indicator
    of an octal `radix`:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '`parseInt()` will also effectively trim the `String`, ignoring any initial
    whitespace, and will ignore all the content of the `String` beyond the first found
    integer:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '`parseInt` is usually frowned upon due to its obscure mechanism of extracting
    an integer from `String` and the fact that it may dynamically pick its own `radix`
    if none is provided. If you must use `parseInt`, use it with caution and full
    awareness of how it operates. And always provide a `radix` argument.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: 'In a similar spirit to `parseInt` there is also a native `parseFloat` function,
    which will attempt to extract a *float* (that is*, a floating-point number*) from
    a given `String`:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '`parseFloat` will trim the string and then look for the longest set of characters
    from the *0^(th)* character that can be naturally parsed by the language in the
    same way a numeric literal may be parsed. As such, it works fine with Strings
    that include non-numeric characters beyond a parseable numeric sequence:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Such a string would cause `NaN` to be evaluated if we passed it to `Number(...)`.
    So, in some rare cases, `parseFloat` may be more useful to you.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: 'Both `parseFloat` and `parseInt` will convert their initial argument into a
    `String` before attempting extraction. As such, if your first argument is an object,
    you should be wary of how it may naturally coerce to a string. If your object
    implements distinct `toString` and `valueOf` methods, then you should expect `parseInt`
    and `parseFloat` to only use `toString` (unless `[Symbol.toPrimitive]()` is also
    implemented). This is in contrast to `Number(...)`, which will attempt to convert
    its argument into a `Number` directly (without first converting it into a `String`)
    and will thus prioritize `valueOf` over `toString`:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: In most situations, converting any value into a `Number` should be attempted
    via `Number` or the unary plus `+` operator. You should only use `parseFloat`
    or `parseInt` if you have a specific need for their numerical extraction algorithms.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: Converting into a primitive
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Converting a value into its primitive representation is not something we can
    do directly, but is done implicitly (that is, *coercively*) by the language in
    a number of different situations, such as when you try to use the abstract equality
    operator, `==`, to compare a `String`, `Number`, or `Symbol` to a value that is
    an `Object`. The `Object`, in that scenario, will be converted into its primitive
    representation via an internal procedure called `ToPrimitive`, which in summary
    does the following:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: If `object[Symbol.toPrimitive]` exists, and when called it returns a primitive
    value, use that
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If `object.valueOf` exists, and it returns a primitive (non-`Object`), use its
    return value
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If `object.toString` exists, use its return value
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can see `ToPrimitive` in action if we attempt a comparison with `==`:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: As you can see, if an object has all three methods (`[Symbol.toPrimitive]`,
    `valueOf`, and `toString`), then `[Symbol.toPrimitive]` will be used. If it has
    just `valueOf` and `toString`, then `valueOf` will be used. And, of course, if
    there is only `toString`, then it will be used.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: 'There is the possibility that `*2*` and `*3*` in that procedure will swap if
    `ToPrimitive` is called with a hint of `String` (meaning that it has been instructed
    to attempt to coerce to a `String` instead of any primitive). An example of such
    a case would be when you use a computed member access operator (`object[something]`),
    where if `something` is an object, it would be converted into a `String` via `ToPrimitive`
    with a hint of `String`, meaning `toString()` will be attempted before `valueOf()`.
    We can see this in action here:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: We have both `toString` and `valueOf` defined on `something`, but only `toString`
    is used to determine which property to access on `object`.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: 'If we do not define our own methods, such as `valueOf` and `toString`, then
    the default methods available on the `[[Prototype]]` of whatever object we''re
    using will be used instead. The primitive representation of an array, for example,
    is defined by `Array.prototype.toString`, which will simply join its elements
    together with a comma as a separator:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'All types have their own natively provided `valueOf` and `toString` methods,
    so if we wish to force the `ToPrimitive` internal procedure to use our own methods,
    then we''ll need to override the native ones by supplying our object with its
    own methods directly or by inheriting from the `[[Prototype]]`. For example, if
    you wished to provide a custom array abstraction that had its own primitive conversion
    behavior, then you could implement it by extending the `Array` constructor:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Then, you''d be able to rely on your `CustomArray` instances being handled
    in their own unique way by the `ToPrimitive` procedure:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: The coercive behaviors of all operators and native language constructs will
    vary. Any time you pass a value to a language construct or operator that is expecting
    a primitive (typically either a string or a number), it will likely be passed
    through `ToPrimitive`. As such, it's useful to know about this internal procedure.
    We'll refer to this section as well as we start to explore all of JavaScript's
    operators in detail.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have continued to explore the innards of JavaScript, covering
    the dynamic nature of the language. We've seen how we can go about detecting various
    types and the nuanced intricacies of coercion and casting. These topics are difficult
    to pick up, but they will be useful. Many anti-patterns that appear in JavaScript
    code come down to fundamental misunderstandings of language constructs and mechanisms,
    so having a deep understanding of these topics will aid our ambition of writing
    clean code tremendously.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will continue our exploration of types by exploring
    JavaScript's operators. It's likely that you will already have a very good knowledge
    of many of these, but thanks to JavaScript's dynamic nature, their usage can sometimes
    yield unexpected results. For this reason, the next chapter dedicates itself fully
    to the careful exploration of the language's operators.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
