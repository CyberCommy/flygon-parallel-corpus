- en: '*Chapter 9*: Image Scanning in DevOps Pipelines'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is a good practice to find defects and vulnerabilities in the early stages
    of the development life cycle. Identifying issues and fixing them in the early
    stages helps improve the robustness and stability of an application. It also helps
    to reduce the attack surface in the production environment. Securing Kubernetes
    clusters has to cover the entire DevOps flow. Similar to hardening container images
    and restricting powerful security attributes in the workload manifest, image scanning
    can help improve the security posture on the development side. However, image
    scanning can definitely go beyond that.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, first, we will introduce the concept of image scanning and
    vulnerabilities, then we'll talk about a popular open source image scanning tool
    called **Anchore Engine** and show you how you can use it to do image scanning.
    Last but not least, we will show you how image scanning can be integrated into
    CI/CD pipelines.
  prefs: []
  type: TYPE_NORMAL
- en: After this chapter, you should be familiar with the concept of image scanning
    and feel comfortable using Anchore Engine to scan images. More importantly, you
    need to start thinking of a strategy for integrating image scanning into your
    CI/CD pipeline if you haven't so far.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing container images and vulnerabilities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scanning images with Anchore Engine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating image scanning into the CI/CD pipeline
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing container images and vulnerabilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Image scanning can be used to identify vulnerabilities or violations of best
    practices (depending on the image scanner's capability) inside an image. Vulnerabilities
    may come from application libraries or tools inside the image. Before we jump
    into image scanning, it would be good to know a little bit more about container
    images and vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Container images
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A container image is a file that bundles the microservice binary, its dependency,
    configurations of the microservice, and so on. Nowadays, application developers
    not only write code to build microservices but also need to build an image to
    containerize an application. Sometimes application developers may not follow the
    security best practices to write code or download libraries from uncertified sources.
    This means vulnerabilities could potentially exist in your own application or
    the dependent packages that your application relies on. Still, don''t forget the
    base image you use, which might include another set of vulnerable binaries and
    packages. So first, let''s look at what an image looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding output shows the file layer of the image `kaizheh/anchore-cli`
    (show full commands with the `--no-trunc` flag). You may notice that each file
    layer has a corresponding command that creates it. After each command, a new file
    layer is created, which means the content of the image has been updated, layer
    by layer (basically, Docker works on copy-on-write), and you can still see the
    size of each file layer. This is easy to understand: when you install new packages
    or add files to the base, the image size increases. The `missing` image ID is
    a known issue because Docker Hub only stores the digest of the leaf layer and
    not the intermediate ones in the parent image. However, the preceding image history
    does tell how the image was in the Dockerfile, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The workings of the preceding Dockerfile are described as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: To build the `kaizheh/anchore-cli` image, I chose to build from `ubuntu`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, I installed the packages `python-pip`, `jq`, and `vim`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, I installed `anchore-cli` using `pip`, which I installed in the previous
    step.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then I configured the environment variable path.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Lastly, I copied a shell script, `demo.sh`, to the image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following figure shows the image file layers mapped to the Dockerfile instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1 – Dockerfile instructions map to image file layers'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15566_09_001.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.1 – Dockerfile instructions map to image file layers
  prefs: []
  type: TYPE_NORMAL
- en: You don't have to remember what has been added in each layer. Ultimately, a
    container image is a compressed file that contains all the binaries and packages
    required for your application. When a container is created from an image, the
    container runtime extracts the image and then creates a directory purposely for
    the extracted content of the image, then configures chroot, cgroup, Linux namespaces,
    Linux capabilities, and so on for the entry point application in the image before
    launching it.
  prefs: []
  type: TYPE_NORMAL
- en: Now you know the magic done by the container runtime to launch a container from
    an image. But you are still not sure whether your image is vulnerable so that
    it could easily be hacked. Let's look at what image scanning really does.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting known vulnerabilities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: People make mistakes and so do developers. If flaws in an application are exploitable,
    those flaws become security vulnerabilities. There are two types of vulnerability—one
    is those that have been discovered, while the other type remains unknown. Security
    researchers, penetration testers, and others work very hard to look for security
    vulnerabilities so that corresponding fixes reduce the potential for compromise.
    Once security vulnerabilities have been patched, developers apply patches as updates
    to the application. If these updates are not applied on time, there is a risk
    of the application getting compromised. It would cause huge damage to companies
    if these known security issues were exploited by malicious guys.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we're not going to talk about how to hunt for security vulnerabilities.
    Let the security researchers and ethical hackers do their job. Instead, we will
    talk about how to discover and manage those known vulnerabilities uncovered by
    image scanning tools by performing vulnerability management. In addition, we also
    need to know how vulnerabilities are tracked and shared in the community. So,
    let's talk about CVE and NVD.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to vulnerability databases
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**CVE** stands for **Common Vulnerability and Exposure**. When a vulnerability
    is identified, there is a unique ID assigned to it with a description and a public
    reference. Usually, there is impacted version information inside the description.
    This is one CVE entry. Every day, there are hundreds of vulnerabilities that are
    identified and get a unique CVE ID assigned by MITRE.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NVD** stands for **National Vulnerability Database**. It synchronizes the
    CVE list. Once there is a new update to the CVE list, the new CVE will show up
    in NVD immediately. Besides NVD, there are some other vulnerability databases
    available, such as Synk.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To explain the magic done by an image scanning tool in a simple way: the image
    scanning tool extracts the image file, then looks for all the available packages
    and libraries in the image and looks up their version within the vulnerability
    database. If there is any package whose version matches with any of the CVE''s
    descriptions in the vulnerability database, the image scanning tool will report
    that there is a vulnerability in the image. You shouldn''t be surprised if there
    are vulnerabilities found in a container image. So, what are you going to do about
    them? The first thing you need to do is stay calm and don''t panic.'
  prefs: []
  type: TYPE_NORMAL
- en: Managing vulnerabilities
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you have a vulnerability management strategy, you won't panic. In general,
    every vulnerability management strategy will start with understanding the exploitability
    and impact of the vulnerability based on the CVE detail. NVD provides a vulnerability
    scoring system also known as **Common Vulnerability Scoring System** (**CVSS**)
    to help you better understand how severe the vulnerability is.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following information needs to be provided to calculate the vulnerability
    score based on your own understanding of the vulnerability:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Attack vector**: Whether the exploit is a network attack, local attack, or
    physical attack'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Attack complexity**: How hard it is to exploit the vulnerability'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Privileges required**: Whether the exploit requires any privileges, such
    as root or non-root'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**User interaction**: Whether the exploit requires any user interaction'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scopes**: Whether the exploit will lead to cross security domain'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Confidentiality impact**: How much the exploit impacts the confidentiality
    of the software'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integrity impact**: How much the exploit impacts the integrity of the software'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Availability impact**: How much the exploit impacts the availability of the
    software'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The CVSS calculator is available at [https://nvd.nist.gov/vuln-metrics/cvss/v3-calculator](https://nvd.nist.gov/vuln-metrics/cvss/v3-calculator):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.2 – CVSS calculator'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15566_09_002.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.2 – CVSS calculator
  prefs: []
  type: TYPE_NORMAL
- en: 'Though the input fields in the preceding screenshot only cover the base score
    metrics, they serve as fundamental factors that decide how critical the vulnerability
    is. There are two other metrics that can be used to evaluate the criticalness
    of the vulnerability but we''re not going to cover them in this section. According
    to CVSS (version 3), there are four ranges of score:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Low**: 0.1-3.9'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Medium**: 4-6.9'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**High**: 7-8.9'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Critical**: 9-10'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Usually, image scanning tools will provide the CVSS score when they report
    any vulnerabilities in an image. There is at least one more step for the vulnerability
    analysis before you take any response action. You need to know that the severity
    of the vulnerability may be influenced by your own environment as well. Let me
    give you a few examples:'
  prefs: []
  type: TYPE_NORMAL
- en: The vulnerability is only exploitable in Windows, but the base OS image is not
    Windows.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The vulnerability can be exploited from network access but the processes in
    the image only send outbound requests and never accept inbound requests.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The preceding scenarios show good examples that the CVSS score is not the only
    factor that matters. You should focus on the vulnerabilities that are both critical
    and relevant. However, our recommendation is still to prioritize vulnerabilities
    wisely and fix them as soon as possible.
  prefs: []
  type: TYPE_NORMAL
- en: If there is a vulnerability found in an image, it is always better to fix it
    early. If vulnerabilities are found in the development stage, then you should
    have enough time to respond. If vulnerabilities are found in a running production
    cluster, you should patch the images and redeploy as soon as a patch is available.
    If a patch is not available, having a mitigation strategy in place prevents compromise
    of the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: This is why an image scanning tool is critical to your CI/CD pipeline. It's
    not realistic to cover vulnerability management in one section, but I think a
    basic understanding of vulnerability management will help you make the most use
    of any image scanning tool. There are a few popular open source image scanning
    tools available, such as Anchore, Clair, Trivvy, and so on. Let's look at one
    such image scanning tool with examples.
  prefs: []
  type: TYPE_NORMAL
- en: Scanning images with Anchore Engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Anchore Engine is an open source image scanning tool. It not only analyzes Docker
    images but also allows users to define an acceptance image scanning policy. In
    this section, we will first give a high-level introduction to Anchore Engine,
    then we will show how to deploy Anchore Engine and the basic image scanning use
    case of Anchore Engine by using Anchore's own CLI tool, `anchore-cli`.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Anchore Engine
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When an image is submitted to Anchore Engine for analysis, Anchore Engine will
    first retrieve the image metadata from image registry, then download the image
    and queue the image for analysis. The following are the items that Anchore Engine
    will analyze:'
  prefs: []
  type: TYPE_NORMAL
- en: Image metadata
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Image layers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operating system packages such as `deb`, `rpm`, `apkg`, and so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: File data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Application dependency packages:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '- Ruby gems'
  prefs: []
  type: TYPE_NORMAL
- en: '- Node.js NPMs'
  prefs: []
  type: TYPE_NORMAL
- en: '- Java archives'
  prefs: []
  type: TYPE_NORMAL
- en: '- Python packages'
  prefs: []
  type: TYPE_NORMAL
- en: File content
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To deploy Anchore Engine in a Kubernetes cluster with **Helm**—CNCF project
    which is a package manage tool for the Kubernetes cluster, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Anchore Engine is composed of a few microservices. When deployed in a Kubernetes
    cluster, you will find the following workloads are running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Anchore Engine decouples image scanning services into the microservices shown
    in the preceding log:'
  prefs: []
  type: TYPE_NORMAL
- en: '**API**: Accepts the image scan request'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Catalog**: Maintains the states of the image scan job'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Policy**: Loads image analysis results and performs policy evaluation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Analyzer**: Pulls images from image registry and performs analysis'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Simplequeue**: Queues image scanning tasks'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PostgreSQL**: Stores image analysis results and state'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now Anchore Engine is successfully deployed in a Kubernetes cluster, let's see
    how we can do image scanning with `anchore-cli`.
  prefs: []
  type: TYPE_NORMAL
- en: Scanning images with anchore-cli
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Anchore Engine supports access both from the RESTful API and `anchore-cli`.
    `anchore-cli` is handy to use in an iterative way. `anchore-cli` does not need
    to run in a Kubernetes cluster. You need to configure the following environment
    variables to enable CLI access to Anchore Engine:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ANCHORE_CLI_URL`: Anchore Engine API endpoint'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ANCHORE_CLI_USER`: Username to access Anchore Engine'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ANCHORE_CLI_PASS`: Password to access Anchore Engine'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once you''ve configured the environment variables successfully, you can verify
    the connectivity to Anchore Engine with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'And the output should be like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '`anchore-cli` is able to talk to Anchore Engine in a Kubernetes cluster. Now
    let''s scan an image with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'And the output should be like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You will get the image digest, full tag, and more from the image. It may take
    some time for Anchore Engine to analyze the image depending on the image size.
    Once it is analyzed, you will see the `Analysis Status` field has been updated
    to `analyzed`. Use the following command to check the image scanning status:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'And the output should be like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We briefly mentioned Anchore Engine policies earlier; Anchore Engine policies
    allow you to define rules to handle vulnerabilities differently based on their
    severity. In the default Anchore Engine policy, you will find the following rules
    in the default policy with two rules. The first rule is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The first rule defines that any package that has medium-level vulnerability
    will still set the policy evaluation result to pass. The second rule is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The second rule defines that any package that has high or critical vulnerability
    will set the policy evaluation result to fail. After the image is analyzed, use
    the following command to check with the policy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'And the output should be like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'So the image `docker.io/kaizheh/nginx-docker:latest` failed the default policy
    evaluation. This means that there must be some vulnerabilities at a high or critical
    level. Use the following command to list all the vulnerabilities in the image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'And the output should be like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The preceding list shows all the vulnerabilities in the image with information
    including CVE ID, package name, severity, whether a fix is available, and references.
    Anchore Engine policies essentially help you filter out less severe vulnerabilities
    so that you can focus on the more severe ones. Then you can start engaging with
    the security team for vulnerability analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, if a fix is not available for a high-level or critical-level vulnerability
    in a package or library, you should find an alternative instead of continuing
    to use the vulnerable one.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we are going to talk about how to integrate image scanning
    into the CI/CD pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating image scanning into the CI/CD pipeline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Image scanning can be triggered at multiple stages in the DevOps pipeline and
    we''ve already talked about the advantages of scanning an image in an early stage
    of the pipeline. However, new vulnerabilities will be discovered, and your vulnerability
    database should be updated constantly. This indicates that passing an image scan
    in the build stage doesn''t mean it will pass at the runtime stage if there is
    a new critical vulnerability found that also exists in the image. You should stop
    the workload deployment when it happens and apply mitigation strategies accordingly.
    Before we dive into integration, let''s look at a rough definition of the DevOps
    stages that are applicable for image scanning:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Build**: When the image is built in the CI/CD pipeline'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deployment**: When the image is about to be deployed in a Kubernetes cluster'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Runtime**: After the image is deployed to a Kubernetes cluster and the containers
    are up and running'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Though there are many different CI/CD pipelines and many different image scanning
    tools for you to choose from, the notion is that integrating image scanning into
    the CI/CD pipeline secures Kubernetes workloads as well as Kubernetes clusters.
  prefs: []
  type: TYPE_NORMAL
- en: Scanning at the build stage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are so many CI/CD tools, such as Jenkins, Spinnaker, and Screwdriver,
    for you to use. In this section, we're going to show how image scanning can be
    integrated into a GitHub workflow. A workflow in GitHub is a configurable automated
    process that contains multiple jobs. It is a similar concept to the Jenkins pipeline
    but defined in YAML format. A simple workflow with image scanning is like defining
    a trigger. Usually done when a pull request or commit is pushed, setting up the
    build environment, for example, Ubuntu.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then define the steps in the workflow:'
  prefs: []
  type: TYPE_NORMAL
- en: Check out the PR branch.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build the image from the branch.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Push the image to the registry – this is optional. You should be able to launch
    the image scanner to scan the image when the image is built locally.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Scan the newly built or pushed image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fail the workflow if policy violations occur.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following is a sample workflow defined in GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In the first step of the build pipeline, I used the `checkout` GitHub action
    to check out the branch. A GitHub action to a workflow is like a function to a
    programming language. It encapsulates the details you don't need to know but performs
    tasks for you. It may take input parameters and return results. In the second
    step, we ran a few commands to build the image `kaizheh/anchore-cli` and push
    the image to the registry. In the third step, we used `anchore-cli` to scan the
    image (yes, we use Anchore Engine to scan our own `anchore-cli` image).
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that I configured the GitHub secrets to store sensitive information such
    as the Docker Hub access token, Anchore username, and password. In the last step,
    we failed purposely for demo purposes. But usually, the last step comes with a
    notification and response to the image scanning result as the comments suggest.
    And you will find the result details of the workflow in GitHub, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.3 – GitHub image scanning workflow'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15566_09_003.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.3 – GitHub image scanning workflow
  prefs: []
  type: TYPE_NORMAL
- en: The preceding screenshot shows the status of each step in the workflow, and
    you will find the detail of each step when you click into it. Anchore also offers
    an image scan GitHub action called **Anchore Container Scan**. It launches the
    Anchore Engine scanner on the newly built image and returns the vulnerabilities,
    manifests, and a pass/fail policy evaluation that can be used to fail the build
    if desired.
  prefs: []
  type: TYPE_NORMAL
- en: Scanning at the deployment stage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Though deployment is a seamless process, I want to bring it up in a separate
    section about conducting image scanning at the deployment stage for two reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: New vulnerabilities may be found when you deploy applications to a Kubernetes
    cluster, even though they passed the image scanning check when they were built.
    It is better to block them before you find the vulnerabilities when they are running
    in a Kubernetes cluster.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Image scanning can be part of the validation admission process in Kubernetes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We''ve already introduced the concept of `ValidatingAdmissionWebhook` in [*Chapter
    7*](B15566_07_Final_ASB_ePub.xhtml#_idTextAnchor186), *Authentication, Authorization,
    and Admission Control*. Now, let''s see how image scanning can help validate the
    workload by scanning its images before the workload is admitted to run in the
    Kubernetes cluster. Image scanning admission controller is an open source project
    from Sysdig. It scans images from the workload that is about to be deployed. If
    an image fails the image scanning policy, the workload will be rejected. The following
    is the workflow diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.4 – Image scanning admission workflow'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15566_09_004.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.4 – Image scanning admission workflow
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding diagram shows the workload admission process validated based
    on image scanning:'
  prefs: []
  type: TYPE_NORMAL
- en: There is a workload creation request sent to `kube-apiserver`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`kube-apiserver` forwards the request to the registered validating webhook
    server based on the validating webhook configurations.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The validating webhook server extracts image information from the workload's
    specification and sends it to the Anchore Engine API server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Based on the image scanning policy, Anchore Engine will return the policy evaluation
    result as a validation decision back to the server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The validating webhook server forwards the validation decision to `kube-apiserver`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`kube-apiserver` either admits or rejects the workload based on the validation
    decision from the image scan policy evaluation result.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To deploy the image scanning admission controller, first check out the GitHub
    repository ([https://github.com/sysdiglabs/image-scanning-admission-controller](https://github.com/sysdiglabs/image-scanning-admission-controller))
    and then run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'And you should find the webhook servers and services are created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Besides the webhook server deployment, the script also creates a `ValidatingWebhookConfiguration`
    object to register the image scan admission webhook server, which is defined in
    `generic-validatingewebhookconfig.yaml` to the `kube-apiserver`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The validating webhook configuration object basically tells `kube-apiserver`
    to forward any pod creation request to `webhook-server-service` in the `image-scan-webhook-system`
    namespace using the `/validating-create-pod` URL path.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the test cases provided by image scanning admission controller
    to verify your setup as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In the test, three different pods will be deployed in the Kubernetes cluster.
    One of them has a critical vulnerability that violates the image scanning policy.
    So, the workload with the critical vulnerability is rejected as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The preceding output shows that the workload with image `kaizheh/apache-struts2-cve-2017-5638`
    is rejected. The image runs the Apache Struts 2 service, which contains a critical
    vulnerability with a CVSS score of 10 ([https://nvd.nist.gov/vuln/detail/CVE-2017-5638](https://nvd.nist.gov/vuln/detail/CVE-2017-5638)).
    Though the CVE in the test is old, you should be able to discover it at an earlier
    stage. However, new vulnerabilities will be found, and the vulnerability database
    keeps updating. It's critical to set a gatekeeper for any workload that is going
    to be deployed in a Kubernetes cluster. Image scanning as validating admission
    is a good security practice for Kubernetes deployment. Now, let's talk about image
    scanning at the runtime stage in a Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Scanning at the runtime stage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Good job! The workload''s image passed the image scanning policy evaluation
    in the build and deployment stages. But it still doesn''t mean the image is vulnerability
    free. Remember, new vulnerabilities will be discovered. Usually, the vulnerability
    database that the image scanner uses will update every few hours. Once the vulnerability
    database is updated, you should trigger the image scanner to scan images that
    are actively running in the Kubernetes cluster. There are a couple of ways to
    do it:'
  prefs: []
  type: TYPE_NORMAL
- en: Scan images pulled on each worker node directly. To scan images on the worker
    nodes, you can use tools such as `secure-inline-scan` from Sysdig ([https://github.com/sysdiglabs/secure-inline-scan](https://github.com/sysdiglabs/secure-inline-scan)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scan images in the registry regularly, directly after the vulnerability database
    has been updated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Again, once you identify impactful vulnerabilities in the images in use, you
    should patch vulnerable images and redeploy them to reduce the attack surface.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we first briefly talked about container images and vulnerabilities.
    Then we introduced an open source image scanning tool, Anchore Engine, and showed
    how to use `anchore-cli` to do image scanning. Last but not least, we talked about
    how to integrate image scanning into a CI/CD pipeline at three different stages:
    build, deployment, and runtime. Image scanning showed great value in securing
    the DevOps flow. A secure Kubernetes cluster requires securing the entire DevOps
    flow.'
  prefs: []
  type: TYPE_NORMAL
- en: You should now feel comfortable deploying Anchore Engine and using `anchore-cli`
    to trigger image scanning. Once you find any vulnerabilities in an image, filter
    them out by using an Anchore Engine policy and understand their real impact. I
    know it's going to take time, but it is necessary and awesome to set up image
    scanning as gatekeepers in your CI/CD pipeline. By doing so, you'll make your
    Kubernetes cluster more secure.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will talk about resource management and real-time monitoring
    in a Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s use some questions to help you understand this chapter better:'
  prefs: []
  type: TYPE_NORMAL
- en: Which Docker command can be used to list image file layers?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: According to the CVSS3 standard, what vulnerability score range is considered
    high?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the `anchore-cli` command to start scanning an image?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the `anchore-cli` command to list an image's vulnerabilities?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the `anchore-cli` command to evaluate an image with an Anchore Engine
    policy?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is it so important to integrate image scanning into CI/CD pipelines?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further references
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To learn more about Anchore Engine, read: [https://docs.anchore.com/current/docs/engine/general/](https://docs.anchore.com/current/docs/engine/general/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To learn more about the Anchore scan action: [https://github.com/marketplace/actions/anchore-container-scan](https://github.com/marketplace/actions/anchore-container-scan)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To learn more about Sysdig''s image scanning admission controller: [https://github.com/sysdiglabs/image-scanning-admission-controller](https://github.com/sysdiglabs/image-scanning-admission-controller)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To learn more about GitHub actions: [https://help.github.com/en/actions](https://help.github.com/en/actions)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
