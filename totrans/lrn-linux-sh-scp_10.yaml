- en: Regular Expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter introduces regular expressions, and the main commands that we can
    use to leverage their power. We'll first look at the theory behind regular expressions,
    before moving deeper into practical examples of using regular expressions with
    `grep` and `sed`.
  prefs: []
  type: TYPE_NORMAL
- en: We will also explain globbing, and how it is used on the command line.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following commands will be introduced in this chapter: `grep`, `set`, `egrep`,
    and `sed`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: What are regular expressions?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Globbing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using regular expressions with `egrep` and `sed`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All scripts for this chapter can be found on GitHub: [https://github.com/tammert/learn-linux-shell-scripting/tree/master/chapter_10](https://github.com/tammert/learn-linux-shell-scripting/tree/master/chapter_10).
    Other than this, the Ubuntu virtual machine is still our way of testing and running
    the scripts in this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing regular expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You might have heard the term *regular expression*, or *regex*, before. For
    many people, a regular expression is something that seems very complicated, and
    is often plucked somewhere from the internet or a textbook, without fully grasping
    what it does.
  prefs: []
  type: TYPE_NORMAL
- en: While that is fine for completing a set task, understanding regular expressions
    better than the average systems administrator really allows you to differentiate
    yourself, both in creating scripts and working on the Terminal.
  prefs: []
  type: TYPE_NORMAL
- en: A nicely tailored regular expression can really help you keep your scripts short,
    simple, and robust to changes in the future.
  prefs: []
  type: TYPE_NORMAL
- en: What is a regular expression?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In essence, a regular expression is a *piece of text* that functions as a *search
    pattern* for other text. Regular expressions make it possible to easily say, for
    example, that I want to select all lines that contain a word that is five characters
    in length, or look for all files that end in `.log`.
  prefs: []
  type: TYPE_NORMAL
- en: An example might help with your understanding. First, we need a command that
    we can use to explore regular expressions. The most famous command used in Linux
    with regular expressions is `grep`.
  prefs: []
  type: TYPE_NORMAL
- en: '`grep` is an acronym meaning ***g**lobal **r**egular **e**xpression **p**rint*.
    As you can see, this seems like a good candidate for explaining the concept!'
  prefs: []
  type: TYPE_NORMAL
- en: grep
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to dive right in as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'First of all, let''s explore the basic functionality of `grep`, before we move
    on to regular expressions. What `grep` does is really simple, as stated in `man
    grep`: *print lines matching a pattern*.'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, we created a file with some sentences. Some of these
    start with capital letters; they mostly end differently; and they use some words
    that are similar, but not really the same. These and more characteristics will
    be used in further examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, we use `grep` to match a single word (the search is case-sensitive
    by default), and print that. `grep` has two operating modes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`grep <pattern> <file>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`grep <pattern>` (which needs input in the form of a pipe, or `|`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first operating mode lets you specify a filename from which you want to
    specify the lines that need to be printed, if they match the pattern you specify.
    The `grep 'cool' grep-file.txt` command is an example of this.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is another way of using `grep`: in streams. A stream is something *in
    transit* to your Terminal, but which can be changed while on the move. In this
    case, a `cat` of the file would normally print all lines to your Terminal.'
  prefs: []
  type: TYPE_NORMAL
- en: However, with the pipe symbol (`|`) we redirect the output of `cat` to `grep`;
    in this case, we only need to specify the pattern to match. Any line that does
    not match will be discarded, and will not be shown in your Terminal.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the full syntax for this is `cat grep-file.txt | grep 'USA'`.
  prefs: []
  type: TYPE_NORMAL
- en: Piping is a form of redirection that we will further discuss in [Chapter 12](15141e02-be0c-4709-90f4-a172809217c4.xhtml),
    *Using Pipes and Redirection in Scripts*. For now, keep in mind that by using
    the pipe, the *output* of `cat` is used as *input* for `grep`, in the same manner
    as the filename is used as input. While discussing `grep`, we will (for now) use
    the method explained first, which does not use redirection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because the words *cool* and *USA* are only found in a single line, both instances
    of `grep` print just that line. But if a word is found in multiple lines, all
    of them are printed in the order `grep` encounters them (which is normally from
    top to bottom):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'With `grep`, it is possible to specify that instead of the default case-sensitive
    approach, we would like the search to be case-insensitive. This is, for example,
    a great way of finding errors in a log file. Some programs use the word *error*,
    others *ERROR*, and we''ve even come across the occasional *Error*. All of these
    results can be returned by supplying the `-i` flag to `grep`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: By supplying `-i`, we see now that both 'regular*'* and 'Regular*'* have been
    matched, and their lines have been printed.
  prefs: []
  type: TYPE_NORMAL
- en: Greediness
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By default, regular expressions are considered greedy. This might seem a strange
    term to describe a technical concept, but it does fit really well. To illustrate
    why regular expressions are considered greedy, look at this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, `grep` does not by default look for full words. It looks at
    the characters in the file, and if a string matches the search (regardless of
    what comes before or after them), the line is printed.
  prefs: []
  type: TYPE_NORMAL
- en: In the first example, `in` matches both the normal word **in**, but also test**in**g.
    In the second example, both lines have two matches, both **the** and **the**y.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to return whole words only, be sure to include the spaces in your
    `grep` search pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the search for `' in '` now does not return the line with the
    word **testing**, since the string of characters **in** isn't surrounded by spaces
    there.
  prefs: []
  type: TYPE_NORMAL
- en: A regular expression is just a definition of a particular search pattern, which
    is implemented differently by individual scripting/programming languages. The
    regular expressions we are using with Bash are different from those in Perl or
    Java, for example. While in some languages, greediness can be tuned or even turned
    off, regular expressions under `grep` and `sed` are always greedy. This is not
    really an issue, just something to consider when defining your search patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Character matching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now know how we can search for whole words, even if we're not entirely sure
    about uppercase and lowercase yet.
  prefs: []
  type: TYPE_NORMAL
- en: We've also seen that regular expressions under (most) Linux applications are
    greedy, so we need to be sure that we're dealing with this properly by specifying
    whitespace and character anchors, which we will explain shortly.
  prefs: []
  type: TYPE_NORMAL
- en: In both these cases, we knew what we were looking for. But what if we do not
    really know what we are looking for, or perhaps only part of it? The answer to
    this dilemma is character matching.
  prefs: []
  type: TYPE_NORMAL
- en: 'In regular expressions, there are two characters we can use as substitutes
    for other characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`.` (dot) matches any one character (except a newline)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*` (asterisk) matches any number of repeats of the character before (even
    zero instances)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An example will help in understanding this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'A lot of things happened there, some of which may feel very counter-intuitive.
    We''ll walk through them one by one and go into detail on what is happening:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we use the dot to substitute for *any character*. As we can
    see, this includes both letters (e**e**e) and numbers (e**2**e). However, it also
    matches the space character between the two es on the last line.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s another example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'When we use the `*` substitution, we''re looking for **zero or more** instances
    of the preceding character. In the search pattern `aaa*`, this means the following
    strings are valid:'
  prefs: []
  type: TYPE_NORMAL
- en: '`aa`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`aaa`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`aaaa`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`aaaaa`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '... and so on. While everything after the first result should be clear, why
    does `aa` also match `aaa*`? Because of the zero in *zero or more!* In that case,
    if the last `a` is zero, we''re left with only `aa`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The same thing happens in the last example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The pattern `aab*` matches the aa within **aa**a, since the `b*` can be zero,
    which makes the pattern end up as `aa`. Of course, it also matches one or more
    bs (`aabb` is fully matched).
  prefs: []
  type: TYPE_NORMAL
- en: These wildcards are great when you have only a general idea about what you're
    looking for. Sometimes, however, you will have a more specific idea of what you
    need.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we can use brackets, [...], to narrow our substitution to a certain
    character set. The following example should give you a good idea of how to use
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: First, we demonstrate using `.` (dot) to replace any character. In this scenario,
    the pattern **f.r** matches both **for** and **far**.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we use the bracket notation in `f[ao]r` to convey that we'll accept a
    single character between `f` and `r`, which is in the character set of `ao`. As
    expected, this again returns both **far** and **for**.
  prefs: []
  type: TYPE_NORMAL
- en: If we do this with the `f[az]r` pattern, we can only match with **far** and
    **fzr**. Since the string `fzr` isn't in our text file (and not a word, obviously),
    we only see the line with **far** printed.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's say you wanted to match with a letter, but not a number. If you
    used `.` (dot) to search, as in the first example, this would return both letters
    and numbers. So, you would also get, for example, **f2r** as a match (should that
    be in the file, which it is not).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you used the bracket notation, you could use the following notation: `f[abcdefghijklmnopqrstuvwxyz]r`.
    That matches on any letter, a-z, between `f` and `r`. However, it''s not great
    to type that out on a keyboard (trust me on this).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Luckily, the creators of POSIX regular expressions introduced a shorthand for
    this: `[a-z]`, as shown in the previous example. We can also use a subset of the
    alphabet, as shown: `f[a-k]r`. Since the letter **o** is not between a and k,
    it does not match on **for**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A last example demonstrates that this is a powerful, and also practical, pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Hopefully, this still all makes sense. Before moving on to line anchors, we're
    going to go one step further by combining notations.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, you see that we can use bracket notation to handle
    some of the differences between American and British English. However, this only
    works when the difference in spelling is a single letter, as with realise/realize.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of color/colour, there is an extra letter we need to deal with.
    This sounds like a case for zero or more, does it not?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: By using the pattern `colo[u]*r`, we're searching for a line containing a word
    that starts with **colo**, may or may not contain any number of **u**s, and ends
    with an **r**. Since both `color` and `colour` are acceptable for this pattern,
    both lines are printed.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might be tempted to use the dot character with the zero-or-more `*` notation.
    However, look closely at what happens in that case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Again, both lines are matched. But, since the second line contains another **r**
    further on, the string `color (and r` is matched, as well as `colour` and `color`.
  prefs: []
  type: TYPE_NORMAL
- en: This is a typical instance where the regular expression pattern is too greedy
    for our purposes. While we cannot tell it to be less greedy, there is an option
    in `grep` that lets us only look for single words that match.
  prefs: []
  type: TYPE_NORMAL
- en: 'The notation `-w` evaluates whitespaces and line endings/beginnings to find
    only whole words. This is how it is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now, only the words `colour` and `color` are matched. Earlier, we put whitespace
    around our word to facilitate this behavior, but as the word `colour` is at the
    end of the line, it is not followed by a whitespace.
  prefs: []
  type: TYPE_NORMAL
- en: Try for yourself and see why enclosing the `colo.*r` search pattern does not
    work with whitespace, but does work with the `-w` option.
  prefs: []
  type: TYPE_NORMAL
- en: Some implementations of regular expressions have the `{3}` notation, to supplement
    the `*` notation. In this notation, you can specify exactly how often a pattern
    should be present. The search pattern `[a-z]{3}` would match all lowercase strings
    of exactly three characters. In Linux, this can only be done with extended regular
    expressions, which we will see later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Line anchors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've already briefly mentioned line anchors. With the explanations we have
    presented up until now, we were only able to search for words in a line; we weren't
    yet able to set expectations on *where* those words were in the line. For this,
    we use line anchors.
  prefs: []
  type: TYPE_NORMAL
- en: 'In regular expressions, the `^` (caret) character signifies the beginning of
    a line, and a `$` (dollar) represents the end of a line. We can use these within
    a search pattern, for example, in the following scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Look for the word error, but only at the beginning of a line: `^error`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Look for lines ending in a dot: `\.$`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Look for an empty line: `^$`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The first usage, looking for something at the beginning of a line, should be
    pretty clear. The following example, which uses `grep -i` (remember, this allows
    us to search without case sensitivity), shows how we can use this to filter by
    line position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In the first search pattern, `regular`, we are returned two lines. This is not
    unexpected, since both lines contain the word *regular* (albeit with different
    casing).
  prefs: []
  type: TYPE_NORMAL
- en: Now, to just select the line that starts with the word *Regular*, we use the
    caret character `^` to form the pattern `^regular`. This only returns the line
    where the word is in the first position on that line. (Note that if we did not
    choose to include `-i` on `grep`, we could have used `[Rr]egular` instead.)
  prefs: []
  type: TYPE_NORMAL
- en: The next example, where we look for lines ending in a dot, is a little bit more
    tricky. As you recall, the dot in regular expressions is considered a special
    character; it is a substitute for any other one character. If we use it normally,
    we will see all lines in the file return (since all lines end in *any one character*).
  prefs: []
  type: TYPE_NORMAL
- en: 'To actually search for a dot in the text, we need to **escape** the dot by
    prefixing it with a backslash; this tells the regular expression engine to not
    interpret the dot as a special character, but to search for it instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Since the `\` is used to escape special characters, you might encounter a situation
    where you are looking for a backslash in the text. In that case, you can use the
    backslash to escape the special functionality of the backslash! Your pattern will
    be `\\` in this case, which matches with the `\` strings.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we run into one other issue. So far, we have always quoted
    all patterns with single quotes. However, this isn't always needed! For example,
    `grep cool grep-file.txt` works just as well as `grep 'cool' grep-file.txt`.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, why are we doing it? Hint: try the previous example, with the dot line
    endings, without quotes. Then remember that a dollar character in Bash is also
    used to denote variables. If we quote it, the `$` will not be expanded on by Bash,
    which returns problematic results.'
  prefs: []
  type: TYPE_NORMAL
- en: We will discuss Bash expansion in [Chapter 16](89ec6d77-023a-482a-bd93-23e3945002bf.xhtml),
    *Bash Parameter Substitution and Expansion*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we presented the `^$` pattern. This searches for a line beginning,
    followed directly by a line ending. There is only one situation where that occurs:
    an empty line.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate why you would want to find empty lines, let''s look at a new
    `grep` flag: `-v`. This flag is shorthand for `--invert-match`, which should give
    a nice clue about what it actually does: instead of printing lines that match,
    it prints lines that do not match.'
  prefs: []
  type: TYPE_NORMAL
- en: 'By using `grep -v ''^$'' <file name>`, you can print a file without empty lines.
    Give it a go on a random configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `/etc/ssh/ssh_config` file starts with an empty line. Then,
    in between comment blocks, there is another empty line. By using `grep -v '^$'`,
    these empty lines are removed. While this is a nice exercise, this does not really
    save us that many lines.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is, however, one search pattern that is widely used and very powerful:
    filtering out comments from a configuration file. This operation gives us a quick
    overview of what is actually configured, and omits all comments (which have their
    own merit, but can be obstructive when you just want to see which options are
    configured).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we combine the beginning-of-line caret with a hashtag, which denotes
    a comment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This still prints all empty lines, but no longer prints the comments. In this
    particular file, out of the 51 lines, only four lines contain actual configuration
    directives! All other lines are either empty or contain comments. Pretty cool,
    right?
  prefs: []
  type: TYPE_NORMAL
- en: With `grep`, it is also possible to use multiple patterns at the same time.
    By using this, you can combine the filtering of empty lines and comment lines
    for a condensed, quick overview of configuration options. Multiple patterns are
    defined using the `-e` option. The full command in this case is `grep -v -e '^$'
    -e '^#' /etc/ssh/ssh_config`. Try it!
  prefs: []
  type: TYPE_NORMAL
- en: Character classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've now seen many examples of how to use regular expressions. While most things
    are pretty intuitive, we have also seen that if we want to filter for both uppercase
    and lowercase strings, we'd either have to specify the `-i` option for `grep`,
    or change the search pattern from `[a-z]` to `[a-zA-z]`. For numbers, we would
    need to use `[0-9]`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some might find this fine to work with, but others might disagree. In this
    case, there is an alternative notation that can be used: `[[:pattern:]]`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The next example uses both this new double bracket notation, and the old single
    bracket one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, both patterns result in the same lines: those with a digit.
    The same can be done with uppercase characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'At the end of the day, it is a matter of preference which notation you use.
    There is one thing to be said for the double bracket notation, though: it is much
    closer to implementations of other scripting/programming languages. For example,
    most regular expression implementations use `\w` (word) to select letters, and
    `\d` (digit) to search for digits. In the case of `\w`, the uppercase variant
    is intuitively `\W`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For your convenience, here is a table with the most common POSIX double-bracket
    character classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Notation** | **Description** | **Single bracket equivalent** |'
  prefs: []
  type: TYPE_TB
- en: '| `[[:alnum:]]` | Matches lowercase and uppercase letters or digits | [a-z
    A-Z 0-9] |'
  prefs: []
  type: TYPE_TB
- en: '| `[[:alpha:]]` | Matches lowercase and uppercase letters | [a-z A-Z] |'
  prefs: []
  type: TYPE_TB
- en: '| `[[:digit:]]` | Matches digits | [0-9] |'
  prefs: []
  type: TYPE_TB
- en: '| `[[:lower:]]` | Matches lowercase letters | [a-z] |'
  prefs: []
  type: TYPE_TB
- en: '| `[[:upper:]]` | Matches uppercase letters | [A-Z] |'
  prefs: []
  type: TYPE_TB
- en: '| `[[:blank:]]` | Matches spaces and tabs | [ \t] |'
  prefs: []
  type: TYPE_TB
- en: 'We prefer to use the double bracket notation, as it maps better to other regular
    expression implementations. Feel free to use either in your scripting! However,
    as always: make sure you choose one, and stick with it; not following a standard
    results in sloppy scripts that are confusing to readers. The rest of the examples
    in this book will use the double bracket notation.'
  prefs: []
  type: TYPE_NORMAL
- en: Globbing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We now have the basics of regular expressions under control. There is another
    subject closely related to regular expressions on Linux: *globbing*. Even though
    you probably didn''t realize it, you''ve already seen examples of globbing in
    this book.'
  prefs: []
  type: TYPE_NORMAL
- en: Even better, there is actually a good chance you've used a *glob pattern* in
    practice. If, when working on the command line, you've ever used the wildcard
    character, `*`, you've been globbing!
  prefs: []
  type: TYPE_NORMAL
- en: What is globbing?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Simply said, a glob pattern describes injecting a wildcard character into a
    file path operation. So, when you do a `cp * /tmp/`, you copy all files (not directories!)
    in the current working directory to the `/tmp/` directory.
  prefs: []
  type: TYPE_NORMAL
- en: The `*` expands to all regular files inside the working directory, and then
    all of those are copied to `/tmp/`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of executing both `cp grep-file.txt /tmp/` and `cp character-class.txt
    /tmp/`, we used `*` to select both of them. The same glob pattern can be used
    with `rm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: By default, `rm` only deletes files and not directories (as you can see from
    the errors in the previous example). As stated in [Chapter 6](371361ae-92fe-4963-82d6-6e65ae450135.xhtml),
    *File Manipulation*, adding a `-r` will delete directories *recursively* too.
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, do think about how destructive this is: without warning, you could delete
    every file within the current tree location (if you have the permissions, of course).
    The preceding example shows how powerful the `*` glob pattern is: it expands to
    every file it can find, whatever the type.'
  prefs: []
  type: TYPE_NORMAL
- en: Similarities with regular expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As stated, glob commands achieve a similar effect to regular expressions. There
    are some differences though. For example, the `*` character in regular expressions
    stood for *zero or more occurrences of the preceding character*. For globbing,
    it is a wildcard for any and all characters, more similar to the `.*` notation
    of regular expressions.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with regular expressions, a glob pattern can consist of normal characters,
    combined with special characters. Take a look at an example where `ls` is used
    with different arguments/globbing patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In the `scripts` directory for the previous chapter, we first run a normal `ls
    -l`. As you know, this prints all files in the directory. Now, if we use `ls -l
    *`, we get the exact same result. It would seem that, given an absence of arguments,
    `ls` will inject a wildcard glob for us.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we use the alternative mode of `ls`, which is where we present a filename
    as the argument. In this case, because filenames are unique for each directory,
    we only see a single line returned.
  prefs: []
  type: TYPE_NORMAL
- en: But, what if we wanted all *scripts* (ending in `.sh`) that *start with* `if-`?
    We use the globbing pattern of `if-*.sh`. In this pattern, the `*` wildcard is
    expanded to match, as `man glob` says, *any string, including the empty string*.
  prefs: []
  type: TYPE_NORMAL
- en: More globbing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Globbing is very present in Linux. If you''re dealing with a command that handles
    files (which, under the *everything is a file principle*, is most commands), there
    is a good chance that you can use globbing. To give you an impression of this,
    consider the following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `cat` command, combined with the wildcard glob pattern, prints the contents
    of **all files** in the current working directory. In this case, since all files
    are ASCII text, this was not really a problem. As you can see, the files are printed
    right after each other; there's not so much as an empty line in between.
  prefs: []
  type: TYPE_NORMAL
- en: 'Should you `cat` a binary file, your screen will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The worst case scenario is that the binary file contains a certain character
    sequence that makes temporary changes to your Bash shell, which will make it unusable
    (yes, this has happened to us many times). The lesson here should be simple: **watch
    out when globbing!**'
  prefs: []
  type: TYPE_NORMAL
- en: Other commands we've seen up until now that can deal with globbing patterns
    include `chmod`, `chown`, `mv`, `tar`, `grep`, and so on. Perhaps the most interesting
    for now is `grep`. We've used regular expressions with `grep` on a single file,
    but we can also select files using a glob.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the most ridiculous example of `grep` with globbing: finding
    *anything* in *everything*.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Here, we used the regular expression `.*` search pattern (anything, zero or
    more times) with the glob pattern of `*` (any file). As you might expect, this
    should match every line in every file.
  prefs: []
  type: TYPE_NORMAL
- en: When we use `grep` in this manner, it has pretty much the same functionality
    as the earlier `cat *`. However, when `grep` is used on multiple files, the output
    includes the filename (so you know where the line was found).
  prefs: []
  type: TYPE_NORMAL
- en: 'Make a note: a globbing pattern is always related to files, whereas a regular
    expression is used *inside* the files, on the actual content. Since the syntax
    is similar, you will probably not be too confused about this, but if you ever
    run into a situation where your pattern is not working as you''d expect, it would
    be good to take a moment and consider whether you''re globbing or regexing!'
  prefs: []
  type: TYPE_NORMAL
- en: Advanced globbing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Basic globbing is done mainly with the wildcard, sometimes combined with part
    of a filename. However, just as regular expressions allow us to substitute a single
    character, so do globs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Regular expressions achieve this with the dot; in globbing patterns, the question
    mark is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The globbing pattern `if-then-e???.sh` should speak for itself now. Where the
    `?` is present, any character (letter, digit, special character) is a valid substitute.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding example, all three question marks are replaced by letters.
    As you might have deduced, the regular expression `.` character serves the same
    function as the globbing pattern `?` character: it is valid for exactly one character.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the single bracket notation we use for regular expressions can also
    be used in globbing. A quick example shows how we can use this with `cat`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Disabling globbing, and other options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As powerful as globbing is, this is also what makes it dangerous. For that reason,
    you might want to take drastic measures and turn globbing off. While this is possible,
    we have not seen it in practice. However, for some work or scripts, turning off
    globbing might be a good safeguard.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the `set` command, we can, as the man page states, *change the value
    of a shell option*. In this case, using `-f` will turn off globbing, as we can
    see when we try to repeat our previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Options are turned off by prefixing a minus (`-`), and turned on by prefixing
    a plus (`+`). As you might remember, this is not the first time you're using this
    functionality. When we debugged our Bash scripts, we started those not with `bash`,
    but with `bash -x`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, the Bash subshell executes a `set -x` command before calling
    the scripts. If you use `set -x` in your current terminal, your commands would
    start to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we can now see how the globbing pattern is resolved: from `cat p?ng`
    to `cat ping pong`. Try to remember this functionality; if you''re ever at the
    point of pulling your hair out because you have no idea why a script isn''t doing
    what you want, a simple `set -x` might make all the difference! And if it doesn''t,
    you can always revert to normal behavior with `set +x`, as shown in the example.'
  prefs: []
  type: TYPE_NORMAL
- en: '`set` has many interesting flags that can make your life easier. To see an
    overview of the capabilities of `set` in your Bash version, use the `help set` command.
    Because `set` is a shell builtin (which you can verify with `type set`), looking
    for a man page with `man set` does not work, unfortunately.'
  prefs: []
  type: TYPE_NORMAL
- en: Using regular expressions with egrep and sed
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have now discussed both regular expressions and globbing. As we saw, they
    were very similar, but still had differences to be aware of. In our examples for
    regular expressions, and a little for globbing, we have already seen how `grep`
    can be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this part, we''ll introduce another command, which is very handy when combined
    with regular expressions: `sed` (not to be confused with `set`). We''ll start
    with some advanced uses for `grep`.'
  prefs: []
  type: TYPE_NORMAL
- en: Advanced grep
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have already discussed a few popular options for `grep` to alter its default
    behavior: `--ignore-case` (`-i`), `--invert-match` (`-v`), and `--word-regexp`
    (`-w`). As a reminder here''s what they do:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-i` allows us to search case-insensitively'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-v` only prints lines that are *not* matched, instead of matched lines'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-w` only matches on full words that are surrounded by spaces and/or line anchors
    and/or punctuation marks'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are three other options we''d like to share with you. The first new option,
    `--only-matching` (`-o`) prints only the matching words. If your search pattern
    does not contain any regular expressions, this will probably be a pretty boring
    option, as you can see in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'It does exactly as you expected: it printed the word you were looking for.
    However, unless you just wanted to confirm this, it is probably not that interesting.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if we do the same thing when using a more interesting search pattern (containing
    a regular expression), this option makes more sense:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'In this (simplified!) example, you actually get new information: whichever
    words fell within your search pattern are now printed. While this might not seem
    impressive for such a short word in such a small file, imagine a more complex
    search pattern on a much larger file!'
  prefs: []
  type: TYPE_NORMAL
- en: 'This brings up another point: `grep` is *fast*. Because of the Boyer-Moore
    algorithm, `grep` can search very fast even in very large files (100 MB+).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The second extra option, `--count` (`-c`), does not return any lines. It does,
    however, return a single digit: the number of lines for which the search pattern
    matched. A well-known example of when this comes in handy is when looking at log
    files for package installations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In the regular `grep` here, we see log lines that show which package was installed
    on which date. But what if we just wanted to know *how many packages were installed
    on a certain date*? `--count` to the rescue!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We perform this `grep` operation in two stages. The first `grep 'status installed'`
    filters out all lines related to successful installations, skipping intermediate
    steps such as *unpacked* and *half-configured*.
  prefs: []
  type: TYPE_NORMAL
- en: We use the alternative form of `grep` behind a pipe (which we will discuss further
    in [Chapter 12](15141e02-be0c-4709-90f4-a172809217c4.xhtml), *Using Pipes and
    Redirection* *in Scripts*) to match another search pattern to the already-filtered
    data. This second `grep '2018-08-26'` filters on the date.
  prefs: []
  type: TYPE_NORMAL
- en: Now, without the `-c` option, we would see 40 lines. If we were curious about
    the packages, this might have been a good option, but otherwise, just the printed
    number is better than counting the lines by hand.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, we could have written this as a single grep search pattern,
    using regular expressions. Try it yourself: `grep ''2018-08-26 .* status installed''
    dpkg.log` (be sure to replace the date with some day on which you have run updates/installations).'
  prefs: []
  type: TYPE_NORMAL
- en: The final option, which is very interesting, especially for scripting, is the
    `--quiet` (`-q`) option. Imagine a situation where you want to know if a certain
    search pattern is present in a file. If you find the search pattern, you delete
    the file. If you do not find the search pattern, you'll add it to the file.
  prefs: []
  type: TYPE_NORMAL
- en: As you know, you can use a nice `if-then-else` construct to accomplish that.
    However, if you use a normal `grep`, you will see the text printed in the Terminal
    when you run your script.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is not really that big an issue, but once your scripts get sufficiently
    large and complicated, a lot of output to the screen will make a script hard to
    use. For this, we have the `--quiet` option. Look at this example script to see
    how you would do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the trick is in the exit status. If `grep` finds one or more
    matches of the search pattern, an exit code of 0 is given. If `grep` does not
    find anything, this return code will be 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see this for yourself on the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'In `grep-then-else.sh`, we suppress all output from `grep`. Still, we can achieve
    what we want: each run of the script changes between the *then* and *else* condition,
    as our `bash -x` debug output clearly shows.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Without the `--quiet`, the non-debug output of the script would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: It doesn't really add anything to the script, does it? Even better, a lot of
    commands have a `--quiet`, `-q`, or equivalent option.
  prefs: []
  type: TYPE_NORMAL
- en: When you're scripting, always consider whether the output of a command is relevant.
    If it is not, and you can use the exit status, this almost always makes for a
    cleaner output experience.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing egrep
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Until now, we''ve seen `grep` used with various options that alter its behavior.
    There is one final important option we''d like to share with you: `--extended-regexp`
    (`-E`). As the `man grep` page states, this means *interpret PATTERN as an extended
    regular expression.*'
  prefs: []
  type: TYPE_NORMAL
- en: In contrast to the default regular expressions found in Linux, extended regular
    expressions have search patterns that are a lot closer to regular expressions
    in other scripting/programming languages (should you already have experience with
    those).
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, the following constructs are available when using extended regular
    expressions over default regular expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '| ? | Matches a repeat of the previous character *zero or more times* |'
  prefs: []
  type: TYPE_TB
- en: '| + | Matches a repeat of the previous character *one or more times* |'
  prefs: []
  type: TYPE_TB
- en: '| {n} | Matches a repeat of the previous character *exactly n times* |'
  prefs: []
  type: TYPE_TB
- en: '| {n,m} | Matches a repeat of the previous character *between n and m times*
    |'
  prefs: []
  type: TYPE_TB
- en: '| {,n} | Matches a repeat of the previous character *n or fewer times* |'
  prefs: []
  type: TYPE_TB
- en: '| {n,} | Matches a repeat of the previous character *n or more times* |'
  prefs: []
  type: TYPE_TB
- en: '| (xx&#124;yy) | Alternation character, allows us to find xx *OR* yy in the
    search pattern (great for patterns with more than one character, otherwise, `[xy]`
    notation would suffice) |'
  prefs: []
  type: TYPE_TB
- en: As you might have seen, the man page for `grep` contains a dedicated section
    on regular expressions and search patterns, which you may find very convenient
    as a quick reference.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, before we start using the new ERE search patterns, we''ll look at a *new*
    command: `egrep`. If you tried to find out what it does, you might start with
    a `which egrep`, which would result in `/bin/egrep`. This might lead you to think
    it was a separate binary from `grep`, which you''ve used so much by now.'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, in the end, `egrep` is nothing more than a small wrapper script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, it's just a shell script, but without the customary `.sh` extension.
    It uses the `exec` command to *replace the current process image with a new process
    image*.
  prefs: []
  type: TYPE_NORMAL
- en: You might recall that normally, a command is executed in a fork of the current
    environment. In this case, since we use this script to *wrap* (hence why it is
    called a wrapper script) `grep -E` as `egrep`, it makes sense to replace it instead
    of forking it again.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `"$@"` construct is new as well: it is an *array* (if you aren''t familiar
    with this term, think of an ordered list) of arguments. In this case, it essentially
    passes all arguments received by `egrep` into `grep -E`.'
  prefs: []
  type: TYPE_NORMAL
- en: So, if the full command was `egrep -w [[:digit:]] grep-file.txt`, it would be
    wrapped and finally executed in place as `grep -E -w [[:digit:]] grep-file.txt`.
  prefs: []
  type: TYPE_NORMAL
- en: In practice, it does not matter whether you use `egrep` or `grep -E`. We prefer
    using `egrep` so we know for sure that we're dealing with extended regular expressions
    (since the extended functionality is often used in practice, in our experience).
    For simple search patterns, however, there is no need for ERE.
  prefs: []
  type: TYPE_NORMAL
- en: We advise you to find your own system for when to use each one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now for some examples of the extended regular expression search pattern capabilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The first command, `egrep -w [[:lower:]]{5} grep-file.txt`, shows us all words
    that are exactly five characters long, using lowercase letters. Don''t forget
    we need the `-w` option here, because otherwise, any five letters in a row match
    as well, ignoring word boundaries (in this case, the **prett** in **prett**y matches
    as well). The result is only one five-letter word: color.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we do the same for seven-letter words. We now get more results. However,
    because we are only using lowercase letters, we''re missing two words that are
    also seven letters long: Regular and Zealand. We fix this by using `[[:alpha:]]`
    instead of `[[:lower:]]`. (We could have also used the `-i` option to make everything
    case-insensitive—`egrep -iw [[:lower:]]{7} grep-file.txt`.'
  prefs: []
  type: TYPE_NORMAL
- en: While this is functionally acceptable, think about it for a second. In that
    case, you would be searching for *case-insensitive* words made up of exactly seven
    *lowercase* letters. That doesn't really make any sense. In situations such as
    these, we always choose logic over functionality, which in this case means changing
    `[[:lower:]]` to `[[:alpha:]]`, instead of using the `-i` option.
  prefs: []
  type: TYPE_NORMAL
- en: So we know how we can search for words (or lines, if we omit the `-w` option)
    of a specific length. How about we now look for words longer or shorter than a
    minimum or maximum length?
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This example demonstrates boundary syntax. This first command, `egrep -w '[[:lower:]]{5,}'
    grep-file.txt`, looks for lowercase words that are five letters or more. If you
    compare these results to the previous examples, where we were looking for words
    exactly five letters long, you now see that longer words are also matched.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we reverse the boundary condition: we only want to match on words that
    are three letters or fewer. We see that all two- and three-letter words are matched
    (and, because we switched from `[[:lower:]]` to `[[:alpha:]]`, UK and capitalized
    letters at the beginning of the lines are matched as well).'
  prefs: []
  type: TYPE_NORMAL
- en: In the final example, `egrep '.{40,}' grep-file.txt`, we remove the `-w` so
    we're matching on whole lines. We match on any character (as denoted by the dot),
    and we want at least 40 characters on a line (as denoted by the `{40,}`). In this
    case, only three lines of the five are matched (as the other two are shorter).
  prefs: []
  type: TYPE_NORMAL
- en: 'Quoting is very important for search patterns. If you do not use quotes in
    your pattern, especially when using special characters, such as { and }, you will
    need to escape them with a backslash. This can and will lead to confusing situations,
    where you''re staring at the screen wondering why on earth your search pattern
    is not working, or even throwing errors. Just remember: if you single-quote the
    search pattern at all times, you will have a much better chance of avoiding these
    frustrating situations.'
  prefs: []
  type: TYPE_NORMAL
- en: The final concept of extended regular expressions we want to show is *alternation*.
    This uses pipe syntax (not to be confused with pipes used for redirection, which
    will be further discussed in [Chapter 12](15141e02-be0c-4709-90f4-a172809217c4.xhtml),
    *Using Pipes and Redirection in Scripts*) to convey the meaning of *match on xxx
    OR yyy*.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example should make this clear:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: In the case of a single letter difference, we can choose whether we want to
    use extended alternation syntax, or the earlier-discussed bracket syntax. We would
    advise using the simplest syntax that accomplishes the goal, which, in this case,
    is bracket syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, once we are looking for patterns of more than one character difference,
    using bracket syntax becomes prohibitively complex. In this case, extended alternation
    syntax is clear and concise, especially since `|` or `||` represents an `OR` construct
    in most scripting/programming logic. For this example, this would be like saying:
    I want to find lines that contain either the word USA or the word UK.'
  prefs: []
  type: TYPE_NORMAL
- en: Because this syntax corresponds nicely with a semantic view, it feels intuitive
    and is understandable, something we should always strive for in our scripts!
  prefs: []
  type: TYPE_NORMAL
- en: sed, the stream editor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since we''re now fully familiar with regular expressions, search patterns,
    and (extended) `grep`, it''s time to move to one of the most powerful tools in
    the GNU/Linux landscape: `sed`. The term is short for **s**tream **ed**itor, and
    it does exactly what is implied: editing streams.'
  prefs: []
  type: TYPE_NORMAL
- en: In this context, a stream can be a lot of things, but in general, it is text.
    This text may be found within a file, but can also be *streamed* from another
    process, such as a `cat grep-file.txt | sed ...`. In that example, the output
    of the `cat` command (equal to the content of `grep-file.txt`) serves as input
    for the `sed` command.
  prefs: []
  type: TYPE_NORMAL
- en: We will look at both in-place file editing and stream editing in our examples.
  prefs: []
  type: TYPE_NORMAL
- en: Stream editing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll first look at actual stream editing with `sed`. Stream editing allows
    us to do really cool stuff: we could, for example, change some words in a text.
    We could also delete certain lines we do not care about (everything that does
    not contain the word ERROR, for example).'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll begin with a simple example, searching for and replacing a word in a
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Just like that, `sed` transformed my positive sentence into something... less
    positive. The pattern `sed` uses (in `sed` terms, this is just called a *script*)
    is `s/wicked/stupid/`*.* The `s` stands for search-replace, and the first word
    of the *script* is substituted for the second word.
  prefs: []
  type: TYPE_NORMAL
- en: 'Observe what happens for multiple lines with multiple matches for the search
    word:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'From this example, we can learn two things:'
  prefs: []
  type: TYPE_NORMAL
- en: By default, `sed` only replaces the first instance of each word *for each line.*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sed` does not match only on whole words, but also on partial words.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'What if we wanted to replace all instances within each line? This is called
    a *global* search-replace, and the syntax is only very slightly different:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: By adding a `g` at the end of the `sed` *script*, we are now globally replacing
    all instances, instead of just the first instance for each line.
  prefs: []
  type: TYPE_NORMAL
- en: Another possibility is that you would only want to search-replace on the first
    line. You could use `head -1` to only select that line before you send it through
    `sed`, but that would mean you would need to append the other lines afterwards.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can select which lines we want to edit by placing the line numbers in front
    of the `sed` script, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The first script, `'1s/wood/stone/'`, instructs `sed` to replace the first instance
    of *wood* on the first line with *stone*. The next script, `'1s/wood/stone/g'`,
    tells `sed` to replace all instances of *wood* with *stone*, but only on the first
    line. The last script, `'1,2s/wood/stone/g'`, makes `sed` replace all instances
    of *wood* on all lines between (and including!) `1` and `2`.
  prefs: []
  type: TYPE_NORMAL
- en: In-place editing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While it is not *that* big a deal to `cat` a file before we send it to `sed`,
    fortunately, we don''t really need to do that. The usage for `sed` is as follows:
    `sed [OPTION] {script-only-if-no-other-script} [input-file]`. As you can see at
    the end, there is an option for `[input-file]`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take one of the previous examples, and remove the `cat`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, by using the optional `[input-file]` argument, `sed` processes
    all lines in that file according to the script. By default, `sed` prints everything
    it processes. In some cases, this causes lines to be printed twice, namely when
    using the `print` function of `sed` (which we will see in a bit).
  prefs: []
  type: TYPE_NORMAL
- en: 'Another very important thing that this example demonstrates: this syntax does
    not edit the original file; only what is printed out to `STDOUT` is changed. Sometimes,
    you will want to edit the file itself—for these scenarios, `sed` has the `--in-place`
    (`-i`) option.'
  prefs: []
  type: TYPE_NORMAL
- en: Make sure you understand that this **irreversibly changes the file on disk**.
    And, as with most things in Linux, there is no such thing as an undo button or
    a recycle bin!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how we can use `sed -i` to persistently change a file (after we
    make a backup, of course):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, instead of printing the processed text onto your screen, `sed` quietly
    changed the file on disk. Because of the destructive nature of this, we created
    a backup beforehand. However, the `--in-place` option of `sed` can provide that
    functionality as well, by adding a file suffix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '`sed` is a bit stingy with the syntax. If you put a space between `-i` and
    `''.bak''`, you will get weird errors (this normally works fine for commands whose
    options have arguments). In this case, because the script definition follows right
    after, `sed` is having trouble differentiating between what is the file suffix
    and script string.'
  prefs: []
  type: TYPE_NORMAL
- en: Just remember that if you want to use this, you need to be careful about this
    syntax!
  prefs: []
  type: TYPE_NORMAL
- en: Line manipulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While the word manipulation functionality of `sed` is great, it also allows
    us to manipulate whole lines. For example, we can delete certain lines, by number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: By using `echo -e` combined with the newline character (`\n`), we can create
    multi-line statements. `-e` is explained on the `man echo` page as *enable interpretation
    of backslash escapes*. By piping this multi-line output into `sed`, we can use
    the delete functionality, which is a script that simply uses the character `d`.
  prefs: []
  type: TYPE_NORMAL
- en: If we prefix this with a line number, for example `1d`, the first line is deleted.
    If we do not, all lines are deleted, which results in no output for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another, often more interesting, possibility is deleting lines that contain
    a certain word:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: In the same way as we used a script with word matching for the search-replace
    function of `sed`, so can we also delete a whole line if a word is present. As
    you can see from the preceding example, this is case-sensitive. Luckily, there's
    always a solution if we want to do this in a case-insensitive manner. In `grep`,
    this would be the `-i` flag, but for `sed` this `-i` is already reserved for `--in-place`
    functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'How do we do it then? By using our old friends regular expressions, of course!
    See the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: While it's not as graceful as the functionality provided by `grep`, it does
    get the job done in most situations. It should at least make you aware of the
    fact that using regular expressions with `sed` makes the whole thing much more
    flexible and much more powerful.
  prefs: []
  type: TYPE_NORMAL
- en: As with most things, with added flexibility and power comes added complexity.
    However, we hope that with this gentle introduction to regular expressions and
    `sed`, the combination of both does not feel unmanageably complex.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of deleting lines from a file or stream, you might have a better use
    case for just showing a few files. There is a small issue with this, however:
    by default, `sed` prints all lines it processes. If you give `sed` the instruction
    to print a line (with the `p` script*)*, it will print that line two times—once
    for the match on the script, and the other time for the default print.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The syntax for the print and delete scripts is similar: `''/word/d''` and `''/word/p''`.
    To suppress the default behavior of `sed`, which prints all lines, add a `-n`
    (also known as `--quiet` or `--silent`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: You might have figured out that printing and deleting lines with `sed` scripts
    shares the same functionality as `grep` and `grep -v`. In most cases, you can
    choose which you prefer to use. However, some advanced functionality, like deleting
    lines that match, but only from the first 10 lines of a file, can only be done
    with `sed`. As a rule of thumb, anything that can be achieved with `grep` using
    a single statement should be handled with `grep`; otherwise, turn to `sed`.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one final use case for `sed` that we would like to highlight: you
    have a file or stream, and you need to delete not a whole line, but only some
    words in those lines. With `grep`, this cannot be (easily) achieved. `sed` has
    a very simple way of doing this, however.'
  prefs: []
  type: TYPE_NORMAL
- en: What makes searching and replacing different to just plain deleting a word?
    Just the replacement pattern!
  prefs: []
  type: TYPE_NORMAL
- en: 'See the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'By *replacing* the word stone with *nothing* (as that is exactly what is present
    between the second and third backslash in the `sed` script), we delete the word
    stone completely. In this example, however, you can see a common problem you will
    undoubtedly run across: extra whitespace after deleting a word.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This leads us to one more trick for `sed`, which helps you out in this regard:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: By supplying `-e`, followed by a `sed` script, you can make `sed` run multiple
    scripts (in order!) over your stream. By default, `sed` expects at least one script,
    which is why you do not need to supply the `-e` if you're only processing a single
    script. For more scripts than this, you'll need to add a `-e` before each.
  prefs: []
  type: TYPE_NORMAL
- en: Final remarks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Regular expressions are **hard**. What makes this even harder on Linux is that
    regular expressions have been implemented by different programs (which have different
    maintainers, with different opinions) slightly differently.
  prefs: []
  type: TYPE_NORMAL
- en: To make matters worse, some features of regular expressions have been hidden
    as extended regular expressions by some programs, whereas they are considered
    the default by other programs. In past years, the maintainers of these programs
    seemed to have moved towards a more global POSIX standard for *regular* regular
    expressions and *extended* regular expressions, but still to this day, there are
    some discrepancies.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have some very simple advice for dealing with this: **just try it out**.
    You might not remember what the asterisk represents in globbing, as opposed to
    regular expressions, or why the question mark does something different. Perhaps
    you''ll forget to ''activate'' extended syntax with `-E`, and your extended search
    pattern will return weird errors.'
  prefs: []
  type: TYPE_NORMAL
- en: You will definitely forget to quote a search pattern once, and if it contains
    a character such as a dot or $ (which is interpreted by Bash,) your command will
    crash and burn, often with a not-too-clear error message.
  prefs: []
  type: TYPE_NORMAL
- en: Just know that we have all made these mistakes, and only experience will make
    this easier. In fact, in writing this chapter, almost none of the commands as
    we had them in our heads worked right away! You are not alone in this, and you
    should not feel bad about it. *Just keep going and keep trying until it works,
    and until you understand why it did not work the first time.*
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter explained regular expressions, and two common tools that use them
    under Linux: `grep` and `sed`.'
  prefs: []
  type: TYPE_NORMAL
- en: We began by explaining that regular expressions are *search pattern**s,* used
    in combination with text to find matches. These search patterns allow us to search
    very flexibly in text where its contents are not necessarily known at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Search patterns allow us, for example, to look only for words and not numbers,
    for words at the beginnings or endings of lines, or for empty lines. Search patterns
    include wildcards, which can represent one or more of a certain character or character
    class.
  prefs: []
  type: TYPE_NORMAL
- en: We introduced the `grep` command to show how we can use the basic functionality
    of regular expressions in Bash.
  prefs: []
  type: TYPE_NORMAL
- en: The second part of this chapter dealt with globbing. Globbing is used as a wildcard
    mechanism for file names and paths. It has similarities with regular expressions,
    but also some key differences. Globbing can be used with most commands that deal
    with files (and, since most *things* under Linux can be considered files, this
    means almost all commands support some form of globbing).
  prefs: []
  type: TYPE_NORMAL
- en: The last half of the chapter described using regular expressions with `egrep`
    and `sed`. `egrep`, being a simple wrapper for `grep -E`, allows us to use extended
    syntax for regular expressions, which we discussed along with some often-used,
    advanced features of `grep`.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast to default regular expressions, extended regular expressions allow
    us to specify the length of certain patterns and how often they repeat, as well
    as allowing us to use alternation.
  prefs: []
  type: TYPE_NORMAL
- en: The final part of this chapter described `sed`, the stream editor. `sed` is
    a complex but very powerful command, which allows us to do even more exciting
    stuff than `grep`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following commands were introduced in this chapter: `grep`, `set`, `egrep`,
    and `sed`.'
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is a search pattern?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why are regular expressions considered greedy?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which character in search patterns is considered a wildcard for any one character,
    except newlines?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How is the asterisk used in Linux regular expression search patterns?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are line anchors?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name three character types.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is globbing?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is possible in extended regular expression syntax that is not possible
    with normal regular expressions under Bash?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What would be a good rule of thumb for deciding whether to use `grep` or `sed`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why are regular expressions on Linux/Bash so hard?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following resources might be interesting if you''d like to go deeper into
    the subjects of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The Linux Documentation Project on Regular Expressions**: [http://www.tldp.org/LDP/abs/html/x17129.html](http://www.tldp.org/LDP/abs/html/x17129.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The Linux Documentation Project on Globbing**: [http://www.tldp.org/LDP/abs/html/globbingref.html](http://www.tldp.org/LDP/abs/html/globbingref.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The Linux Documentation Project on Sed**: [http://tldp.org/LDP/abs/html/x23170.html](http://tldp.org/LDP/abs/html/x23170.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
