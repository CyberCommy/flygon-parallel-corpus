- en: From Loose Types to Strict Types
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*JavaScript is loosely typed.* It''s worth repeating, *JavaScript is loosely
    typed*. Notice how the sentence is passive--we cannot categorically hold someone
    responsible for the loose-type nature of JavaScript just as we can''t do so for
    other famousglitches of JavaScript.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: A detailed discussion on what loose-types and loosely typed languages are will
    help aid your understanding of the problem that we plan to solve with this book.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: When a programming language is loosely typed, it means that the data passed
    around using variables, functions, or whatever member applicable to the language
    does *not* have a defined type. A variable *x*could be declared, but the kind
    of data it holds is never certain. Loosely typed languages are contrary to strongly
    typed languages, which enforce that every declared member must strictly define
    what sort of data it can hold.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'These types are categorized into:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Strings
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Numbers (int, float, and so on.)
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data structures (arrays, lists, objects, maps, and so on.)
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Boolean (true and false)
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaScript, PHP, Perl, Ruby, and so on, are all examples of loosely typed languages.
    Java, C, C#, are examples of strongly typed languages.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: In loosely typed languages, a member may be initially defined as a string. Down
    the line, this member could end up storing a number, a boolean, or even a data
    structure. This instability leads us to the implications of loosely typed languages.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Term definitions
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we keep moving, it would be nice to define the common jargon you may
    have met or will meet with in the course of understanding loose and strict types:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**: These are the features of a language that describe how the data
    is stored and manipulated. Variables, functions, properties, classes, interfaces,
    and so on, are all examples of the possible members a language can have.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Declared versus defined versus assigned**: When a variable is initialized
    with no value, it is said to be *declared*. When it is declared and has a type,
    it is said to be *defined*. When the variable has a value, whether typed or not,
    it is *assigned*.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Types**: These are used to categorize the data based on how they are parsed
    and manipulated. For example, numbers, strings, booleans, arrays, and so on.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Values**: The data assigned to a given member is known as the member''s value.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implications of loose types
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start out with an example to show how loosely typed languages behave:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The variable `x`was initially declared and assigned a string value, `Hello`.
    The same `x` got re-assigned to a numeric value,`1`. Nothing went wrong; the code
    was interpreted and when we logged the value to the console, it logged the latest
    value of `x`, which is `1`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: 'This is not just a string-number thing; the same thing applies to every other
    type, including complex data structures:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The important thing to note here is not that the *values* are changing. Rather,
    it's the fact that both values and *types* are changing. The change in the type
    does not affect the execution. Everything works fine, and we have our expected
    result in the console.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: 'The function parameters and return types are not left out either. You can have
    a function signature that accepts a string parameter, but JavaScript will keep
    silent when you, or any other developer, pass in a number while calling the function:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If you're coming from a strong-type background and have no previous experience
    with loosely typed languages, the preceding example must feel weird. This is because
    in strongly typed languages, it's hard to change the type of the particular member
    (variables, functions, and so on).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: So, what is the implication to take note of? The obvious implication is that
    the members that are loosely typed are inconsistent. Therefore, their value types
    can change, and this is something that you, the developer, will need to watch
    out for. There are challenges in doing so; let's talk about them.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: The problem
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Loose types are tricky. At first glance, they appear to be all nice and flexible
    to work with--flexibility, as in giving you the freedom to change types anytime
    and anywhere, without the interpreter screaming errors like other strongly typed
    languages do. Just like any other form of freedom, this one also comes with a
    price.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: 'The major problem is inconsistency. It is very easy to forget the original
    type for a member. This could lead you to handling, say, a string as if it were
    still a string when its value is now Boolean. Let''s see an example:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding example, we have a function that greets the users based on
    their usernames. Before it does the greeting, it first reverses the username.
    We can call the function by passing in a username string.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: 'What happens when we pass in a Boolean or some other type that does not have
    a `split` method? Let''s check it out:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The first log output, which prints the greeting with a string, comes out fine.
    But the second attempt fails because we passed in a Boolean. In as much as *everything*
    in JavaScript is an object, a Boolean does not have a `split` method. The image
    ahead shows a clear output of the preceding example:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a942f086-3e4c-43e5-abca-0f09ed2fec74.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
- en: Yes, you might be thinking that you're the author of this code; why would you
    pass in a Boolean when you designed the function to receive a string? Remember
    that a majority of the code that we write in our lifetime is not maintained by
    us, but by our colleagues.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: When another developer picks up `greetUser` and decides to use the function
    as an API without digging the code's source or documentation, there is a high
    possibility that he/she won't pass in the right value type. This is because *he/**she
    is blind*. Nothing tells him/her what is right and what is not. Even the name
    of the function is not obvious enough to make her pass in a string.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript evolved. This evolution was not just experienced internally but was
    also seen in its vast community. The community came up with best practices on
    tackling the challenges of the loose-type nature of JavaScript.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Mitigating loose-type problems
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JavaScript does not have any native obvious solution to the problems that loose
    types bring to the table. Rather, we can use all forms of manual checks using
    JavaScript's conditions to see whether the value in question is still of the intended
    type.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: We are going to have a look at some examples where manual checks are applied
    in order to retain the integrity of the value types.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: The popular saying that *Everything is an Object* in JavaScript is not entirely
    true ([https://blog.simpleblend.net/is-everything-in-javascript-an-object/](https://blog.simpleblend.net/is-everything-in-javascript-an-object/)).
    There are *Objects* and there are*Primitives*. Strings, numbers, Boolean, null,
    undefined, are primitives but are handled as objects only during computation.
    That's why you can call something like `.trim()` on a string. Objects, arrays,
    dates, and regular expressions are valid objects. It's mind-troubling to say that
    an object is an object, but that is JavaScript for you.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: The typeof operator
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `typeof` operator is used to check the type of a given operand. You can
    use the operator to control the harm of loose types. Let''s see some examples:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Rather than waiting for the system to tell us that we''re wrong when an invalid
    type is passed in, we catch the error as early as possible and throw a custom
    and more friendly error, as shown in the following screenshot:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/2486fb07-13a0-43b5-acdc-5f21028a041b.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
- en: 'The `typeof` operator returns a string, which represents the value''s type.
    The `typeof`operator is not entirely perfect and should only be used when you
    are sure about how it works. See the following issue:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You may have expected an error to be thrown when the function was called with
    an array for the second time. Instead, the program got past the check and executed
    `user.name` before realizing that it is undefined. Why did it get past this check?
    Remember that an array is an object. Therefore, we need something more specific
    to catch the check. Date and regex could have passed the check as well, even though
    that may not have been the intent.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: The toString method
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `toString` method is prototypically inherited by all the objects and wrapped
    objects (primitives). When you call this method on them, it returns a string token
    of the type. See the following examples:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now you can use this to check the types, as shown by Todd Motto ([https://toddmotto.com/understanding-javascript-types-and-reliable-type-checking/#true-object-types](https://toddmotto.com/understanding-javascript-types-and-reliable-type-checking/#true-object-types)):'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: What the preceding example does is check the part of the string returned by
    the `toString` method to determine its type.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: Final Note
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The examples we saw previously are just an overkill for a simple type check.
    If JavaScript had strict type features, we wouldn't have gone through this stress.
    In fact, this chapter would never have existed.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine that JavaScript could do this:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We wouldn't have gone through all that type checking hell because the compiler
    (as well as the editors) would have thrown errors when it encountered type inconsistency.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: This is where TypeScript comes in. Luckily, with TypeScript, we can write code
    that looks like the preceding one, and we can have it transpiled to JavaScript.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this book, we will be talking about TypeScript for building not just
    JavaScript apps but also Angular apps. Angular is a JavaScript framework; therefore,
    it will be characterized with the discussed limitations unless mitigated with
    TypeScript.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know the problem at hand, buckle up while we dig Angular with the
    possible solutions that TypeScript provides.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道手头的问题了，那就做好准备，让我们深入研究 Angular，并探讨 TypeScript 提供的可能解决方案。
- en: 'So far, so good! We have been able to discuss the following concerns to help
    us move forward:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 目前为止，一切都很顺利！我们已经能够讨论以下关注点，以帮助我们继续前进：
- en: Understanding loose types
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解松散类型
- en: Differences between loose types and strict types
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 松散类型和严格类型之间的区别
- en: Challenges of loosely typed programming languages, including JavaScript
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 松散类型编程语言的挑战，包括 JavaScript
- en: Mitigating the effects of loose types
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减轻松散类型的影响
