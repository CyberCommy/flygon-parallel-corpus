- en: Files and Data Persistence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"Persistence is the key to the adventure we call life." – Torsten Alexander
    Lange'
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapters, we have explored several different aspects of Python.
    As the examples have a didactic purpose, we've run them in a simple Python shell,
    or in the form of a Python module. They ran, maybe printed something on the console,
    and then they terminated, leaving no trace of their brief existence.
  prefs: []
  type: TYPE_NORMAL
- en: Real-world applications though are generally much different. Naturally, they
    still run in memory, but they interact with networks, disks, and databases. They
    also exchange information with other applications and devices, using formats that
    are suitable for the situation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to start closing in to the real world by exploring
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Files and directories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compression
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Networks and streams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The JSON data-interchange format
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data persistence with pickle and shelve, from the standard library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data persistence with SQLAlchemy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As usual, I will try to balance breadth and depth, so that by the end of the
    chapter, you will have a solid grasp of the fundamentals and will know how to
    fetch further information on the web.
  prefs: []
  type: TYPE_NORMAL
- en: Working with files and directories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When it comes to files and directories, Python offers plenty of useful tools.
    In particular, in the following examples, we will leverage the `os` and `shutil` modules.
    As we'll be reading and writing on the disk, I will be using a file, `fear.txt`,
    which contains an excerpt from *Fear*, by Thich Nhat Hanh, as a guinea pig for
    some of our examples.
  prefs: []
  type: TYPE_NORMAL
- en: Opening files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Opening a file in Python is very simple and intuitive. In fact, we just need
    to use the `open` function. Let''s see a quick example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The previous code is very simple. We call `open`, passing the filename, and
    telling `open` that we want to read it in text mode. There is no path information
    before the filename; therefore, `open` will assume the file is in the same folder
    the script is run from. This means that if we run this script from outside the
    `files` folder, then `fear.txt` won't be found.
  prefs: []
  type: TYPE_NORMAL
- en: Once the file has been opened, we obtain a file object back, `fh`, which we
    can use to work on the content of the file. In this case, we use the `readlines()`
    method to iterate over all the lines in the file, and print them. We call `strip()`
    on each line to get rid of any extra spaces around the content, including the
    line termination character at the end, since `print` will already add one for
    us. This is a quick and dirty solution that works in this example, but should
    the content of the file contain meaningful spaces that need to be preserved, you
    will have to be slightly more careful in how you sanitize the data. At the end
    of the script, we flush and close the stream.
  prefs: []
  type: TYPE_NORMAL
- en: 'Closing a file is very important, as we don''t want to risk failing to release
    the handle we have on it. Therefore, we need to apply some precaution, and wrap
    the previous logic in a `try`/`finally` block. This has the effect that, whatever
    error might occur while we try to open and read the file, we can rest assured
    that `close()` will be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The logic is exactly the same, but now it is also safe.
  prefs: []
  type: TYPE_NORMAL
- en: Don't worry if you don't understand `try`/`finally` for now. We will explore
    how to deal with exceptions in a later chapter. For now, suffice to say that putting
    code within the body of a `try` block adds a mechanism around that code that allows
    us to detect errors (which are called *exceptions*) and decide what to do if they
    happen. In this case, we don't really do anything in case of errors, but by closing
    the file within the `finally` block, we make sure that line is executed whether
    or not any error has happened.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can simplify the previous example this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, `rt` is the default mode for opening files, so we don't need
    to specify it. Moreover, we can simply iterate on `fh`, without explicitly calling `readlines()`
    on it. Python is very nice and gives us shorthands to make our code shorter and
    simpler to read.
  prefs: []
  type: TYPE_NORMAL
- en: 'All the previous examples produce a print of the file on the console (check
    out the source code to read the whole content):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Using a context manager to open a file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s admit it: the prospect of having to disseminate our code with `try`/`finally`
    blocks is not one of the best. As usual, Python gives us a much nicer way to open
    a file in a secure fashion: by using a c*ontext manager*. Let''s see the code
    first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The previous example is equivalent to the one before it, but reads so much better.
    The `with` statement supports the concept of a runtime context defined by a context
    manager. This is implemented using a pair of methods, `__enter__` and `__exit__`,
    that allow user-defined classes to define a runtime context that is entered before
    the statement body is executed and exited when the statement ends. The `open`
    function is capable of producing a file object when invoked by a context manager,
    but the true beauty of it lies in the fact that `fh.close()` will be called automatically
    for us, even in case of errors.
  prefs: []
  type: TYPE_NORMAL
- en: Context managers are used in several different scenarios, such as thread synchronization,
    closure of files or other objects, and management of network and database connections.
    You can find information about them in the `contextlib` documentation page ([https://docs.python.org/3.7/library/contextlib.html](https://docs.python.org/3.7/library/contextlib.html)).
  prefs: []
  type: TYPE_NORMAL
- en: Reading and writing to a file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we know how to open a file, let''s see a couple of different ways
    that we have to read and write to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: A first approach uses the `print` function, which you've seen plenty of times
    in the previous chapters. After obtaining a file object, this time specifying
    that we intend to write to it ("`w`"), we can tell the call to `print` to direct
    its effects on the file, instead of the default `sys.stdout`, which, when executed
    on a console, is mapped to it.
  prefs: []
  type: TYPE_NORMAL
- en: The previous code has the effect of creating the `print_example.txt` file if
    it doesn't exist, or truncate it in case it does, and writes the line `Hey I am
    printing into a file!!!` to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is all nice and easy, but not what we typically do when we want to write
    to a file. Let''s see a much more common approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the previous example, we first open `fear.txt` and collect its content into
    a list, line by line. Notice that this time, I'm calling a more precise method, `rstrip()`,
    as an example, to make sure I only strip the whitespace on the right-hand side
    of every line.
  prefs: []
  type: TYPE_NORMAL
- en: In the second part of the snippet, we create a new file, `fear_copy.txt`, and
    we write to it all the lines from the original file, joined by a newline, `\n`.
    Python is gracious and works by default with *universal newlines*, which means
    that even though the original file might have a newline that is different than `\n`,
    it will be translated automatically for us before the line is returned. This behavior
    is, of course, customizable, but normally it is exactly what you want. Speaking
    of newlines, can you think of one of them that might be missing in the copy?
  prefs: []
  type: TYPE_NORMAL
- en: Reading and writing in binary mode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Notice that by opening a file passing `t` in the options (or omitting it, as
    it is the default), we're opening the file in text mode. This means that the content
    of the file is treated and interpreted as text. If you wish to write bytes to
    a file, you can open it in binary mode. This is a common requirement when you
    deal with files that don't just contain raw text, such as images, audio/video,
    and, in general, any other proprietary format.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to handle files in binary mode, simply specify the `b` flag when opening
    them, as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In this example, I'm still using text as binary data, but it could be anything
    you want. You can see it's treated as a binary by the fact that you get the `b'This
    ...'` prefix in the output.
  prefs: []
  type: TYPE_NORMAL
- en: Protecting against overriding an existing file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Python gives us the ability to open files for writing. By using the `w` flag,
    we open a file and truncate its content. This means the file is overwritten with
    an empty file, and the original content is lost. If you wish to only open a file
    for writing in case it doesn''t exist, you can use the `x` flag instead, in the
    following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run the previous snippet, you will find a file called `write_x.txt`
    in your directory, containing only one line of text. The second part of the snippet,
    in fact, fails to execute. This is the output I get on my console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Checking for file and directory existence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you want to make sure a file or directory exists (or it doesn''t), the `os.path`
    module is what you need. Let''s see a small example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The preceding snippet is quite interesting. After declaring the filename with
    a relative reference (in that it is missing the path information), we use `abspath`
    to calculate the full, absolute path of the file. Then, we get the path information
    (by removing the filename at the end) by calling `dirname` on it. The result,
    as you can see, is printed on the last line. Notice also how we check for existence,
    both for a file and a directory, by calling `isfile` and `isdir`. In the `os.path`
    module, you find all the functions you need to work with pathnames.
  prefs: []
  type: TYPE_NORMAL
- en: Should you ever need to work with paths in a different way, you can check out `pathlib`.
    While `os.path` works with strings, `pathlib` offers classes representing filesystem
    paths with semantics appropriate for different operating systems. It is beyond
    the scope of this chapter, but if you're interested, check out PEP428 ([https://www.python.org/dev/peps/pep-0428/](https://www.python.org/dev/peps/pep-0428/)),
    and its page in the standard library.
  prefs: []
  type: TYPE_NORMAL
- en: Manipulating files and directories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s see a couple of quick examples on how to manipulate files and directories.
    The first example manipulates the content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The previous example defines two functions: `sanitize` and `reverse`. They are
    simple functions whose purpose is to remove anything that is not a letter or space
    from a string, and produce the reversed copy of a string, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'We open `fear.txt` and we read its content into a list. Then we create a new
    file, `raef.txt`, which will contain the horizontally-mirrored version of the
    original one. We write all the content of `lines` with a single operation, using `join`
    on a new line character. Maybe more interesting, is the bit in the end. First,
    we reassign `lines` to a sanitized version of itself, by means of list comprehension.
    Then we put them together in the `whole` string, and finally, we pass the result
    to `Counter`. Notice that we split the string and put it in lowercase. This way,
    each word will be counted correctly, regardless of its case, and, thanks to `split`,
    we don''t need to worry about extra spaces anywhere. When we print the three most
    common words, we realize that truly Thich Nhat Hanh''s focus is on others, as
    `we` is the most common word in the text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now see an example of manipulation more oriented to disk operations,
    in which we put the `shutil` module to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code, we start by declaring a base path, which will safely contain
    all the files and folders we're going to create. We then use `makedirs` to create
    two directories: `ops_example/A/B` and `ops_example/A/C`. (Can you think of a
    way of creating the two directories by using `map`?).
  prefs: []
  type: TYPE_NORMAL
- en: We use `os.path.join` to concatenate directory names, as using `/` would specialize
    the code to run on a platform where the directory separator is `/`, but then the
    code would fail on platforms with a different separator. Let's delegate to `join`
    the task to figure out which is the appropriate separator.
  prefs: []
  type: TYPE_NORMAL
- en: 'After creating the directories, within a simple `for` loop, we put some code
    that creates three files in directory `B`. Then, we move the folder `B` and its
    content to a different name: `D`. And finally, we rename `ex1.txt` to `ex1d.txt`.
    If you open that file, you''ll see it still contains the original text from the `for`
    loop. Calling `tree` on the result produces the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Manipulating pathnames
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s explore a little more the abilities of `os.path` by means of a simple
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Reading the result is probably a good enough explanation for this simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Temporary files and directories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, it''s very useful to be able to create a temporary directory or
    file when running some code. For example, when writing tests that affect the disk,
    you can use temporary files and directories to run your logic and assert that
    it''s correct, and to be sure that at the end of the test run, the test folder
    has no leftovers. Let''s see how you do it in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding example is quite straightforward: we create a temporary directory
    in the current one ("`.`"), and we create a named temporary file in it. We print
    the filename, as well as its full path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Running this script will produce a different result every time. After all, it's
    a temporary random name we're creating here, right?
  prefs: []
  type: TYPE_NORMAL
- en: Directory content
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With Python, you can also inspect the content of a directory. I''ll show you
    two ways of doing this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This snippet uses `os.scandir`, called on the current directory. We iterate
    on the results, each of which is an instance of `os.DirEntry`, a nice class that
    exposes useful properties and methods. In the code, we access a subset of those:
    `name`, `path`, and `is_file()`. Running the code yields the following (I omitted
    a few results for brevity):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'A more powerful way to scan a directory tree is given to us by `os.walk`. Let''s
    see an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Running the preceding snippet will produce a list of all files and directories
    in the current one, and it will do the same for each sub-directory.
  prefs: []
  type: TYPE_NORMAL
- en: File and directory compression
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we leave this section, let me give you an example of how to create a
    compressed file. In the source code of the book, I have two examples: one creates
    a ZIP file, while the other one creates a `tar.gz` file. Python allows you to
    create compressed files in several different ways and formats. Here, I am going
    to show you how to create the most common one, ZIP:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we import `ZipFile`, and then, within a context manager,
    we write into it four dummy context files (two of which are in a sub-folder, to
    show ZIP preserves the full path). Afterwards, as an example, we open the compressed
    file and extract a couple of files from it, into the `extract_zip` directory.
    If you are interested in learning more about data compression, make sure you check
    out the *Data Compression and Archiving* section on the standard library ([https://docs.python.org/3.7/library/archiving.html](https://docs.python.org/3.7/library/archiving.html)),
    where you'll be able to learn all about this topic.
  prefs: []
  type: TYPE_NORMAL
- en: Data interchange formats
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Modern software architecture tends to split an application into several components.
    Whether you embrace the service-oriented architecture paradigm, or you push it
    even further into the microservices realm, these components will have to exchange
    data. But even if you are coding a monolithic application, whose code base is
    contained in one project, chances are that you have to still exchange data with
    APIs, other programs, or simply handle the data flow between the frontend and
    the backend part of your website, which very likely won't speak the same language.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing the right format in which to exchange information is crucial. A language-specific
    format has the advantage that the language itself is very likely to provide you
    with all the tools to make serialization and deserialization a breeze. However,
    you will lose the ability to talk to other components that have been written in
    different versions of the same language, or in different languages altogether.
    Regardless of what the future looks like, going with a language-specific format
    should only be done if it is the only possible choice for the given situation.
  prefs: []
  type: TYPE_NORMAL
- en: A much better approach is to choose a format that is language agnostic, and
    can be spoken by all (or at least most) languages. In the team I lead, we have
    people from England, Poland, South Africa, Spain, Greece, India, Italy, to mention
    just a few. We all speak English, so regardless of our native tongue, we can all
    understand each other (well... mostly!).
  prefs: []
  type: TYPE_NORMAL
- en: In the software world, some popular formats have become the de facto standard
    over recent years. The most famous ones probably are XML, YAML, and JSON. The
    Python standard library features the `xml` and `json` modules, and, on PyPI ([https://docs.python.org/3.7/library/archiving.html](https://docs.python.org/3.7/library/archiving.html)),
    you can find a few different packages to work with YAML.
  prefs: []
  type: TYPE_NORMAL
- en: In the Python environment, JSON is probably the most commonly used one. It wins
    over the other two because of being part of the standard library, and for its
    simplicity. If you have ever worked with XML, you know what a nightmare it can
    be.
  prefs: []
  type: TYPE_NORMAL
- en: Working with JSON
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**JSON** is the acronym of **JavaScript Object Notation**, and it is a subset
    of the JavaScript language. It has been there for almost two decades now, so it
    is well known and widely adopted by basically all languages, even though it is
    actually language independent. You can read all about it on its website ([https://www.json.org/](https://www.json.org/)),
    but I''m going to give you a quick introduction to it now.'
  prefs: []
  type: TYPE_NORMAL
- en: 'JSON is based on two structures: a collection of name/value pairs, and an ordered
    list of values. You will immediately realize that these two objects map to the
    dictionary and list data types in Python, respectively. As data types, it offers
    strings, numbers, objects, and values, such as true, false, and null. Let''s see
    a quick example to get us started:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We begin by importing the `sys` and `json` modules. Then we create a simple
    dictionary with some numbers inside and a list. I wanted to test serializing and
    deserializing using very big numbers, both `int` and `float`, so I put *2^(3141)*
    and whatever is the biggest floating point number my system can handle.
  prefs: []
  type: TYPE_NORMAL
- en: 'We serialize with `json.dumps`, which takes data and converts it into a JSON
    formatted string. That data is then fed into `json.loads`, which does the opposite:
    from a JSON formatted string, it reconstructs the data into Python. On the last
    line, we make sure that the original data and the result of the serialization/deserialization
    through JSON match.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see, in the next example, what JSON data would look like if we printed
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we create a dictionary with Sherlock Holmes' data in it. If,
    like me, you're a fan of Sherlock Holmes, and are in London, you'll find his museum
    at that address (which I recommend visiting, it's small but very nice).
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice how we call `json.dumps`, though. We have told it to indent with two
    spaces, and sort keys alphabetically. The result is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The similarity with Python is huge. The one difference is that if you place
    a comma on the last element in a dictionary, like I've done in Python (as it is
    customary), JSON will complain.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let me show you something interesting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we have put a tuple, instead of a list. The interesting bit
    is that, conceptually, a tuple is also an ordered list of items. It doesn't have
    the flexibility of a list, but still, it is considered the same from the perspective
    of JSON. Therefore, as you can see by the first `print`, in JSON a tuple is transformed
    into a list. Naturally then, the information that it was a tuple is lost, and
    when deserialization happens, what we have in `data_out`, `a_tuple` is actually
    a list. It is important that you keep this in mind when dealing with data, as
    going through a transformation process that involves a format that only comprises
    a subset of the data structures you can use implies there will be information
    loss. In this case, we lost the information about the type (tuple versus list).
  prefs: []
  type: TYPE_NORMAL
- en: This is actually a common problem. For example, you can't serialize all Python
    objects to JSON, as it is not clear if JSON should revert that (or how). Think
    about `datetime`, for example. An instance of that class is a Python object that
    JSON won't allow serializing. If we transform it into a string such as `2018-03-04T12:00:30Z`,
    which is the ISO 8601 representation of a date with time and time zone information,
    what should JSON do when deserializing? Should it say *this is actually deserializable
    into a datetime object, so I'd better do it*, or should it simply consider it
    as a string and leave it as it is? What about data types that can be interpreted
    in more than one way?
  prefs: []
  type: TYPE_NORMAL
- en: The answer is that when dealing with data interchange, we often need to transform
    our objects into a simpler format prior to serializing them with JSON. This way,
    we will know how to reconstruct them correctly when we deserialize them.
  prefs: []
  type: TYPE_NORMAL
- en: 'In some cases, though, and mostly for internal use, it is useful to be able
    to serialize custom objects, so, just for fun, I''m going to show you how with
    two examples: complex numbers (because I love math) and *datetime* objects.'
  prefs: []
  type: TYPE_NORMAL
- en: Custom encoding/decoding with JSON
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the JSON world, we can consider terms like encoding/decoding as synonyms
    to serializing/deserializing. They basically all mean transforming to and back
    from JSON. In the following example, I''m going to show you how to encode complex
    numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We start by defining a `ComplexEncoder` class, which needs to implement the `default`
    method. This method is passed to all the objects that have to be serialized, one
    at a time, in the `obj` variable. At some point, `obj` will be our complex number, *3+4j*.
    When that is true, we return a dictionary with some custom meta information, and
    a list that contains both the real and the imaginary part of the number. That
    is all we need to do to avoid losing information for a complex number.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then call `json.dumps`, but this time we use the `cls` argument to specify
    our custom encoder. The result is printed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Half the job is done. For the deserialization part, we could have written another
    class that would inherit from `JSONDecoder`, but, just for fun, I've used a different
    technique that is simpler and uses a small function: `object_hook`.
  prefs: []
  type: TYPE_NORMAL
- en: Within the body of `object_hook`, we find another `try` block. The important
    part is the two lines within the body of the `try` block itself. The function
    receives an object (notice, the function is only called when `obj` is a dictionary),
    and if the metadata matches our convention for complex numbers, we pass the real
    and imaginary parts to the `complex` function. The `try`/`except` block is there
    only to prevent malformed JSON from ruining the party (and if that happens, we
    simply return the object as it is).
  prefs: []
  type: TYPE_NORMAL
- en: 'The last print returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: You can see that `a_complex` has been correctly deserialized.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see a slightly more complex (no pun intended) example now: dealing with
    `datetime` objects. I''m going to split the code into two blocks, the serializing
    part, and the deserializing afterwards:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The reason why this example is slightly more complex lies in the fact that `datetime`
    objects in Python can be time zone aware or not; therefore, we need to be more
    careful. The flow is basically the same as before, only it is dealing with a different
    data type. We start by getting the current date and time information, and we do
    it both without (`now`) and with (`now_tz`) time zone awareness, just to make
    sure our script works. We then proceed to define a custom encoder as before, and
    we implement once again the `default` method. The important bits in that method
    are how we get the time zone offset (`off`) information, in seconds, and how we
    structure the dictionary that returns the data. This time, the metadata says it's
    a *datetime* information, and then we save the first six items in the time tuple
    (year, month, day, hour, minute, and second), plus the microseconds in the `data`
    key, and the offset after that. Could you tell that the value of `data` is a concatenation
    of tuples? Good job if you could!
  prefs: []
  type: TYPE_NORMAL
- en: 'When we have our custom encoder, we proceed to create some data, and then we
    serialize. The `print` statement returns (after I''ve done some prettifying):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Interestingly, we find out that `None` is translated to `null`, its JavaScript
    equivalent. Moreover, we can see our data seems to have been encoded properly.
    Let''s proceed to the second part of the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Once again, we first verify that the metadata is telling us it''s a `datetime`,
    and then we proceed to fetch the time zone information. Once we have that, we
    pass the 7-tuple (using `*` to unpack its values in the call) and the time zone
    information to the `datetime` call, getting back our original object. Let''s verify
    it by printing `data_out`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we got everything back correctly. As an exercise, I'd like to
    challenge you to write the same logic, but for a `date` object, which should be
    simpler.
  prefs: []
  type: TYPE_NORMAL
- en: Before we move on to the next topic, a word of caution. Perhaps it is counter-intuitive,
    but working with `datetime` objects can be one of the trickiest things to do,
    so, although I'm pretty sure this code is doing what it is supposed to do, I want
    to stress that I only tested it very lightly. So if you intend to grab it and
    use it, please do test it thoroughly. Test for different time zones, test for
    daylight saving time being on and off, test for dates before the epoch, and so
    on. You might find that the code in this section then would need some modifications
    to suit your cases.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now move to the next topic, IO.
  prefs: []
  type: TYPE_NORMAL
- en: IO, streams, and requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**IO** stands for **input**/**output**, and it broadly refers to the communication
    between a computer and the outside world. There are several different types of
    IO, and it is outside the scope of this chapter to explain all of them, but I
    still want to offer you a couple of examples.'
  prefs: []
  type: TYPE_NORMAL
- en: Using an in-memory stream
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first will show you the `io.StringIO` class, which is an in-memory stream
    for text IO. The second one instead will escape the locality of our computer,
    and show you how to perform an HTTP request. Let''s see the first example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, we import the `io` module from the standard library.
    This is a very interesting module that features many tools related to streams
    and IO. One of them is `StringIO`, which is an in-memory buffer in which we're
    going to write two sentences, using two different methods, as we did with files
    in the first examples of this chapter. We can both call `StringIO.write` or we
    can use `print`, and tell it to direct the data to our stream.
  prefs: []
  type: TYPE_NORMAL
- en: By calling `getvalue`, we can get the content of the stream (and print it),
    and finally we close it. The call to `close` causes the text buffer to be immediately
    discarded.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a more elegant way to write the previous code (can you guess it, before
    you look?):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Yes, it is again a context manager. Like `open`, `io.StringIO` works well within
    a context manager block. Notice the similarity with `open`: in this case too,
    we don''t need to manually close the stream.'
  prefs: []
  type: TYPE_NORMAL
- en: In-memory objects can be useful in a multitude of situations. Memory is much
    faster than a disk and, for small amounts of data, can be the perfect choice.
  prefs: []
  type: TYPE_NORMAL
- en: 'When running the script, the output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Making HTTP requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s now explore a couple of examples on HTTP requests. I will use the `requests`
    library for these examples, which you can install with `pip`. We''re going to
    perform HTTP requests against the [httpbin.org](http://httpbin.org/) API, which,
    interestingly, was developed by Kenneth Reitz, the creator of the `requests` library
    itself. This library is amongst the most widely adopted all over the world:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The preceding snippet should be simple to understand. I declare a dictionary
    of URLs against which I want to perform `requests`. I have encapsulated the code
    that performs the request into a tiny function: `get_content`. As you can see,
    very simply, we perform a GET request (by using `requests.get`), and we print
    the title and the JSON decoded version of the body of the response. Let me spend
    a word about this last bit.
  prefs: []
  type: TYPE_NORMAL
- en: When we perform a request to a website, or API, we get back a response object,
    which is, very simply, what was returned by the server we performed the request
    against. The body of all responses from [httpbin.org](https://httpbin.org/) happens
    to be JSON encoded, so instead of getting the body as it is (by getting `resp.text`)
    and manually decoding it, calling `json.loads` on it, we simply combine the two
    by leveraging the `json` method on the response object. There are plenty of reasons
    why the `requests` package has become so widely adopted, and one of them is definitely
    its ease of use.
  prefs: []
  type: TYPE_NORMAL
- en: Now, when you perform a request in your application, you will want to have a
    much more robust approach in dealing with errors and so on, but for this chapter,
    a simple example will do.
  prefs: []
  type: TYPE_NORMAL
- en: 'Going back to our code, in the end, we run a `for` loop and get all the URLs.
    When you run it, you will see the result of each call printed on your console,
    like this (prettified and trimmed for brevity):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that you might get a slightly different output in terms of version numbers
    and IPs, which is fine. Now, GET is only one of the HTTP verbs, and it is definitely
    the most commonly used. The second one is the ubiquitous POST, which is the type
    of request you make when you need to send data to the server. Every time you submit
    a form on the web, you''re basically making a POST request. So, let''s try to
    make one programmatically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The previous code is very similar to the one we saw before, only this time we
    don't call `get`, but `post`, and because we want to send some data, we specify
    that in the call. The `requests` library offers much, much more than this, and
    it has been praised by the community for the beautiful API it exposes. It is a
    project that I encourage you to check out and explore, as you will end up using
    it all the time, anyway.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the previous script (and applying some prettifying magic to the output)
    yields the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Notice how the headers are now different, and we find the data we sent in the `form`
    key/value pair of the response body.
  prefs: []
  type: TYPE_NORMAL
- en: I hope these short examples are enough to get you started, especially with requests.
    The web changes every day, so it's worth learning the basics and then brush up
    every now and then.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now move on to the last topic of this chapter: persisting data on disk
    in different formats.'
  prefs: []
  type: TYPE_NORMAL
- en: Persisting data on disk
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last section of this chapter, we're exploring how to persist data on
    disk in three different formats. We will explore `pickle`, `shelve`, and a short
    example that will involve accessing a database using SQLAlchemy, the most widely
    adopted ORM library in the Python ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: Serializing data with pickle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `pickle` module, from the Python standard library, offers tools to convert
    Python objects into byte streams, and vice versa. Even though there is a partial
    overlap in the API that `pickle` and `json` expose, the two are quite different.
    As we have seen previously in this chapter, JSON is a text format, human readable,
    language independent, and supports only a restricted subset of Python data types.
    The `pickle` module, on the other hand, is not human readable, translates to bytes,
    is Python specific, and, thanks to the wonderful Python introspection capabilities,
    it supports an extremely large amount of data types.
  prefs: []
  type: TYPE_NORMAL
- en: Regardless of these differences, though, which you should know when you consider
    whether to use one or the other, I think that the most important concern regarding `pickle`
    lies in the security threats you are exposed to when you use it. *Unpickling*
    erroneous or malicious data from an untrusted source can be very dangerous, so
    if you decide to adopt it in your application, you need to be extra careful.
  prefs: []
  type: TYPE_NORMAL
- en: 'That said, let''s see it in action, by means of a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: In the previous example, we create a `Person` class using the `dataclass` decorator
    (we will cover how to do this in later chapters). The only reason I wrote this
    example with a data class is to show you how effortlessly `pickle` deals with
    it, with no need for us to do anything we wouldn't do for a simpler data type.
  prefs: []
  type: TYPE_NORMAL
- en: The class has three attributes: `first_name`, `last_name`, and `id`. It also
    exposes a `greet` method, which simply prints a hello message with the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'We create a list of instances, and then we save it to a file. In order to do
    so, we use `pickle.dump`, to which we feed the content to be *pickled*, and the
    stream to which we want to write. Immediately after that, we read from that same
    file, and by using `pickle.load`, we convert back into Python the whole content
    of that stream. Just to make sure that the objects have been converted correctly,
    we call the `greet` method on both of them. The result is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The `pickle` module also allows you to convert to (and from) byte objects, by
    means of the `dumps` and `loads` functions (note the `s` at the end of both names).
    In day-to-day applications, `pickle` is usually used when we need to persist Python
    data that is not supposed to be exchanged with another application. One example
    I stumbled upon recently was the session management in a `flask` plugin, which pickles
    the session object before sending it to Redis. In practice, though, you are unlikely
    to have to deal with this library very often.
  prefs: []
  type: TYPE_NORMAL
- en: Another tool that is possibly used even less, but that proves to be very useful
    when you are short of resources, is `shelve`.
  prefs: []
  type: TYPE_NORMAL
- en: Saving data with shelve
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A `shelf`, is a persistent dictionary-like object. The beauty of it is that
    the values you save into a `shelf` can be any object you can `pickle`, so you''re
    not restricted like you would be if you were using a database. Albeit interesting
    and useful, the `shelve` module is used quite rarely in practice. Just for completeness,
    let''s see a quick example of how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Apart from the wiring and the boilerplate around it, the previous example resembles
    an exercise with dictionaries. We create a simple `Person` class and then we open
    a `shelve` file within a context manager. As you can see, we use the dictionary
    syntax to store four objects: two `Person` instances, a list, and a string. If
    we print the `keys,` we get a list containing the four keys we used. Immediately
    after printing it, we delete the (aptly named) `delete_me` key/value pair from shelf.
    Printing the `keys` again shows the deletion has succeeded. We then test a couple
    of keys for membership, and finally, we append number `7` to `a_list`. Notice
    how we have to extract the list from the shelf, modify it, and save it again.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In case this behavior is undesired, there is something we can do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: By opening the shelf with `writeback=True`, we enable the `writeback` feature,
    which allows us to simply append to `a_list` as if it actually was a value within
    a regular dictionary. The reason why this feature is not active by default is
    that it comes with a price that you pay in terms of memory consumption and slower
    closing of the shelf.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have paid homage to the standard library modules related to data
    persistence, let's take a look at the most widely adopted ORM in the Python ecosystem: *SQLAlchemy*.
  prefs: []
  type: TYPE_NORMAL
- en: Saving data to a database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this example, we are going to work with an in-memory database, which will
    make things simpler for us. In the source code of the book, I have left a couple
    of comments to show you how to generate a SQLite file, so I hope you'll explore
    that option as well.
  prefs: []
  type: TYPE_NORMAL
- en: You can find a free database browser for SQLite at [sqlitebrowser.org](http://sqlitebrowser.org/).
    If you are not satisfied with it, you will be able to find a wide range of tools,
    some free, some not free, that you can use to access and manipulate a database
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Before we dive into the code, allow me to briefly introduce the concept of a
    relational database.
  prefs: []
  type: TYPE_NORMAL
- en: 'A relational database is a database that allows you to save data following
    the **relational model**, invented in 1969 by Edgar F. Codd. In this model, data
    is stored in one or more tables. Each table has rows (also known as **records**,
    or **tuples**), each of which represents an entry in the table. Tables also have
    columns (also known as **attributes**), each of which represents an attribute
    of the records. Each record is identified through a unique key, more commonly
    known as the **primary key**, which is the union of one or more columns in the
    table. To give you an example: imagine a table called `Users`, with columns `id`,
    `username`, `password`, `name`, and `surname`. Such a table would be perfect to
    contain users of our system. Each row would represent a different user. For example,
    a row with the values `3`, `gianchub`, `my_wonderful_pwd`, `Fabrizio`, and `Romano`,
    would represent my user in the system.'
  prefs: []
  type: TYPE_NORMAL
- en: The reason why the model is called **relational** is because you can establish
    relations between tables. For example, if you added a table called `PhoneNumbers`
    to our fictitious database, you could insert phone numbers into it, and then,
    through a relation, establish which phone number belongs to which user.
  prefs: []
  type: TYPE_NORMAL
- en: In order to query a relational database, we need a special language. The main
    standard is called **SQL**, which stands for **Structured Query Language**. It
    is born out of something called **relational algebra**, which is a very nice family
    of algebras used to model data stored according to the relational model, and performing
    queries on it. The most common operations you can perform usually involve filtering
    on the rows or columns, joining tables, aggregating the results according to some
    criteria, and so on. To give you an example in English, a query on our imaginary
    database could be: *Fetch all users (username, name, surname) whose username starts
    with "m", who have at most one phone number*. In this query, we are asking for
    a subset of the columns in the `User` table. We are filtering on users by taking
    only those whose username starts with the letter *m*, and even further, only those
    who have at most one phone number.
  prefs: []
  type: TYPE_NORMAL
- en: Back in the days when I was a student in Padova, I spent a whole semester learning
    both the relational algebra semantics, and the standard SQL (amongst other things).
    If it wasn't for a major bicycle accident I had the day of the exam, I would say
    that this was one of the most fun exams I ever had to prepare.
  prefs: []
  type: TYPE_NORMAL
- en: Now, each database comes with its own *flavor* of SQL. They all respect the
    standard to some extent, but none fully does, and they are all different from
    one another in some respects. This poses an issue in modern software development.
    If our application contains SQL code, it is quite likely that if we decided to
    use a different database engine, or maybe a different version of the same engine,
    we would find our SQL code needs amending.
  prefs: []
  type: TYPE_NORMAL
- en: This can be quite painful, especially since SQL queries can become very, very
    complicated quite quickly. In order to alleviate this pain a little, computer
    scientists (*bless them*) have created code that maps objects of a particular
    language to tables of a relational database. Unsurprisingly, the name of such
    tools is **Object-Relational Mapping** (**ORM**s).
  prefs: []
  type: TYPE_NORMAL
- en: In modern application development, you would normally start interacting with
    a database by using an ORM, and should you find yourself in a situation where
    you can't perform a query you need to perform, through the ORM, you would then
    resort to using SQL directly. This is a good compromise between having no SQL
    at all, and using no ORM, which ultimately means specializing the code that interacts
    with the database, with the aforementioned disadvantages.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, I'd like to show an example that leverages SQLAlchemy, the
    most popular Python ORM. We are going to define two models (`Person` and `Address`)
    which map to a table each, and then we're going to populate the database and perform
    a few queries on it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the model declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'At the beginning, we import some functions and types. The first thing we need
    to do then is to create an engine. This engine tells SQLAlchemy about the type
    of database we have chosen for our example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Each model then inherits from the `Base` table, which in this example consists
    of the mere default, returned by `declarative_base()`. We define `Person`, which
    maps to a table called `person`, and exposes the attributes `id`, `name`, and `age`.
    We also declare a relationship with the `Address` model, by stating that accessing
    the `addresses` attribute will fetch all the entries in the `address` table that
    are related to the particular `Person` instance we're dealing with. The `cascade`
    option affects how creation and deletion work, but it is a more advanced concept,
    so I'd suggest you glide on it for now and maybe investigate more later on.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we declare is the `__repr__` method, which provides us with the official string
    representation of an object. This is supposed to be a representation that can
    be used to completely reconstruct the object, but in this example, I simply use
    it to provide something in output. Python redirects `repr(obj)` to a call to `obj.__repr__()`.
  prefs: []
  type: TYPE_NORMAL
- en: We also declare the `Address` model, which will contain email addresses, and
    a reference to the person they belong to. You can see the `person_id` and `person` attributes are
    both about setting a relation between the `Address` and `Person` instances. Note
    how I declared the `__str__` method on `Address`, and then assigned an alias to
    it, called `__repr__`. This means that calling both `repr` and `str` on `Address`
    objects will ultimately result in calling the `__str__` method. This is quite
    a common technique in Python, so I took the opportunity to show it to you here.
  prefs: []
  type: TYPE_NORMAL
- en: On the last line, we tell the engine to create tables in the database according
    to our models.
  prefs: []
  type: TYPE_NORMAL
- en: A deeper understanding of this code would require much more space than I can
    afford, so I encourage you to read up on **database management systems** (**DBMS**),
    SQL, Relational Algebra, and SQLAlchemy.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our models, let's use them to persist some data!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'First we create `session`, which is the object we use to manage the database.
    Next, we proceed by creating two people:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'We then add email addresses to both of them, using two different techniques.
    One assigns them to a list, and the other one simply appends them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'We haven''t touched the database yet. It''s only when we use the session object
    that something actually happens in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Adding the two `Person` instances is enough to also add their addresses (this
    is thanks to the cascading effect). Calling `commit` is what actually tells SQLAlchemy
    to commit the transaction and save the data in the database. A transaction is
    an operation that provides something like a sandbox, but in a database context.
    As long as the transaction hasn't been committed, we can roll back any modification
    we have done to the database, and by so doing, revert to the state we were before
    starting the transaction itself. SQLAlchemy offers more complex and granular ways
    to deal with transactions, which you can study in its official documentation,
    as it is quite an advanced topic.
  prefs: []
  type: TYPE_NORMAL
- en: We now query for all the people whose name starts with `Obi` by using `like`,
    which hooks to the `LIKE` operator in SQL*:*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'We take the first result of that query (we know we only have Obi-Wan anyway),
    and print it. We then fetch `anakin`, by using an exact match on his name (just
    to show you a different way of filtering):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'We then capture Anakin''s ID, and delete the `anakin` object from the global
    frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The reason we do this is because I want to show you how to fetch an object
    by its ID. Before we do that, we write the `display_info` function, which we will
    use to display the full content of the database (fetched starting from the addresses,
    in order to demonstrate how to fetch objects by using a relation attribute in SQLAlchemy):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The `display_info` function prints all the addresses, along with the respective
    person''s name, and, at the end, produces a final piece of information regarding
    the number of objects in the database. We call the function, then we fetch and
    delete `anakin` (think about *Darth Vader* and you won''t be sad about deleting
    him), and then we display the info again, to verify he''s actually disappeared
    from the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of all these snippets run together is the following (for your convenience,
    I have separated the output into four blocks, to reflect the four blocks of code
    that actually produce that output):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the last two blocks, deleting `anakin` has deleted one `Person`
    object, and the three addresses associated with it. Again, this is due to the
    fact that cascading took place when we deleted `anakin`.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes our brief introduction to data persistence. It is a vast and,
    at times, complex domain, which I encourage you to explore learning as much theory
    as possible. Lack of knowledge or proper understanding, when it comes to database
    systems, can really bite.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we have explored working with files and directories. We have
    learned how to open files for reading and writing and how to do that more elegantly
    by using context managers. We also explored directories: how to list their content,
    both recursively and not. We also learned about pathnames, which are the gateway
    to accessing both files and directories.'
  prefs: []
  type: TYPE_NORMAL
- en: We then briefly saw how to create a ZIP archive, and extract its content. The
    source code of the book also contains an example with a different compression
    format: `tar.gz`.
  prefs: []
  type: TYPE_NORMAL
- en: We talked about data interchange formats, and have explored JSON in some depth.
    We had some fun writing custom encoders and decoders for specific Python data
    types.
  prefs: []
  type: TYPE_NORMAL
- en: Then we explored IO, both with in-memory streams and HTTP requests.
  prefs: []
  type: TYPE_NORMAL
- en: And finally, we saw how to persist data using `pickle`, `shelve`, and the SQLAlchemy
    ORM library.
  prefs: []
  type: TYPE_NORMAL
- en: You should now have a pretty good idea of how to deal with files and data persistence,
    and I hope you will take the time to explore these topics in much more depth by
    yourself.
  prefs: []
  type: TYPE_NORMAL
- en: From the next chapter, we will begin our journey into data structures and algorithms,
    beginning with the principles of algorithm design.
  prefs: []
  type: TYPE_NORMAL
