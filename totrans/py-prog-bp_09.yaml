- en: Notification Serverless Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are going to explore AWS Lambda Functions and AWS API Gateway.
    AWS Lambda enables us to create serverless functions. *Serverless* doesn't mean
    that it is without a server; in reality, it means that these functions don't require
    the DevOps overhead that you would have if you were running the application on,
    for example, an EC2 instance.
  prefs: []
  type: TYPE_NORMAL
- en: Serverless architecture is not the silver bullet or the solution to all the
    problems, but there are many advantages, such as pricing, the fact that almost
    no DevOps is required, and support for different programming languages.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of Python, tools like Zappa and the microframework for AWS Chalice,
    which is also developed by Amazon, make creating and deploying serverless functions
    incredibly easy.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter you will learn how to:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a service using Flask framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Install and configure the AWS CLI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the CLI to create S3 buckets and upload files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Install and configure Zappa
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploy an application using Zappa
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So without further ado, let's dive right into it!
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start by creating the folder in which we will place the application
    files. First, create a directory called `notifier` and go into that directory
    so we can create the virtual environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We create the virtual environment using `pipenv`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember that if Python 3 is in our `path`, you can simply call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'To build this service we are going to use the micro web framework Flask, so
    let''s install that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We are also going to install the requests package, which will be used when
    sending requests to the order service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: That should be everything we need for now. Next, we are going to see how we
    can use AWS Simple Email Service to send emails from our applications.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the Amazon Web Services CLI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We also need to install the AWS command-line interface, which will save us a
    lot of time when deploying serverless functions and also when creating S3 buckets.
  prefs: []
  type: TYPE_NORMAL
- en: The installation is quite simple, as it can be installed via `pip`, and the
    AWS CLI has support for Python 2 and Python 3 and runs on different operating
    systems, such as Linux, macOS, and Windows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a terminal and type the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The upgrade option will tell pip to update all the requirements that are already
    installed, and the `--user` option means that pip will install the AWS CLI in
    our local directory, so it won't touch any library that is installed globally
    on our system. On Linux systems, when installing a Python package using the `--user` option,
    the package will be installed in the directory `.local/bin`, so make sure that
    you have that in your `path`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just to verify that the installation worked properly, type the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see an output similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here you can see the AWS CLI version, as well as the operating system version,
    Python version, and which version of `botocore` is currently in use. `botocore`
    is the core library used by the AWS CLI. Also, boto is an SDK for Python, which
    allows developers to write software to work with Amazon services like EC2 and
    S3.
  prefs: []
  type: TYPE_NORMAL
- en: Now we need to configure the CLI, and we will need to have some information
    at hand. First, we need the `aws_access_key_id` and the `aws_secret_access_key`,
    as well as your preferred region and output. The most common value, the output
    option, is JSON.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create the access keys, click on the drop-down menu with your username on
    the top right hand of the AWS console page, and select My Security Credentials.
    You will land on this page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/7ed0edf2-f265-4321-9cd2-a78f41501ae2.png)'
  prefs: []
  type: TYPE_IMG
- en: Here you can configure different account security settings, such as changing
    the password or enabling multi-factor authentication, but the one you should choose
    now is Access keys (access key ID and secret access key). Then click on Create
    New Access Key, and a dialog will be opened with your keys. You will also be given
    the option to download the keys. I suggest you download them and keep them in
    a safe place.
  prefs: []
  type: TYPE_NORMAL
- en: Go here [https://docs.aws.amazon.com/general/latest/gr/rande.html](https://docs.aws.amazon.com/general/latest/gr/rande.html)
    to see the AWS regions and endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can `configure` the CLI. In the command line, type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: You will be asked to provide the access key, the secret access key, the region,
    and the default output format.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring a Simple Email Service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Amazon already has a service called Simple Email Service that we can use in
    order to send email through our application. We will be running the service in
    sandbox mode, which means that we will also be able to send emails to verified
    email addresses. This can be changed if you plan to use the service in production,
    but for the purposes of this book, it will suffice to just have it running in
    sandbox mode.
  prefs: []
  type: TYPE_NORMAL
- en: If you plan to have this application running in production and wish to move
    out of the Amazon SES sandbox, you can easily open a support case for increasing
    the email limit. To send the request, you can go to the SES home page, and on
    the left-hand menu, under the section *Email Sending*, you will find the link
    `Dedicated IPs`. There, you will find more information and also a link where you
    can apply to increase your email limit.
  prefs: []
  type: TYPE_NORMAL
- en: To get it working, we will need to have two email accounts that we can use.
    In my case, I have my own domain. I have also created two email accounts—`donotreply@dfurtado.com`,
    which will be the email that I will use to send emails, and `pythonblueprints@dfurtado.com`,
    which is the email that will receive the email. A user in an online (video) game
    store application will use this email address and we will place a few orders so
    we can test the notification later on.
  prefs: []
  type: TYPE_NORMAL
- en: Registering the emails
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So let''s start adding the emails. We are going to register `donotreply@dfurtado.com`
    first. Log in to the AWS console and search for Simple Email Service in the search
    bar. On the left side, you will see a few options. Under Identity Management, click
    on Email Addresses. You will see a screen like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/4b285c53-779c-4a7a-8775-d9a40cbddf2b.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the list is empty, so let's go ahead and add two emails. Click
    on Verify a New Email Address and a dialog will appear where you can enter an
    email address. Just enter the email that you wish to use and click on Verify This
    Email Address button. By doing this a verification email will be sent to the email
    address that you specified, and therein you will find a link for the verification.
  prefs: []
  type: TYPE_NORMAL
- en: Repeat the same steps for the second email, the one that will receive the messages.
  prefs: []
  type: TYPE_NORMAL
- en: Now, go over to the left side menu again and click on SMTP Settings under Email
    Sending.
  prefs: []
  type: TYPE_NORMAL
- en: There you will see all the configurations necessary to send emails, and you
    will also have to create SMTP credentials. So click on the button Create My SMTP
    Credentials, and a new page will be opened where you can input the IAM username
    that you wish. In my case, I'm adding `python-blueprints`. After you have done
    that, click the button Create. After the credentials have been created, you will
    be presented with a page where you can see the SMTP username and password. You
    will have the option to download these credentials if you like.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an S3 bucket
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to send a template email to the users, we need to copy our templates
    to an S3 bucket. We can easily do that through the web, or you can use the AWS
    CLI that we just installed. The command to create the S3 bucket in the `es-west-2`
    region is something like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Here we use the command `s3api`, which will provide us with different sub-commands
    to interact with the AWS S3 service. We call the sub-command `create-bucket`,
    which, as the name suggests, will create a new S3 bucket. To this sub-command,
    we specify three arguments. First, `--bucket`, which specifies the S3 bucket's
    name, then `--region`, to specify which region the bucket will be created - in
    this case, we are going to create the bucket in the `eu-west-2`. Lastly, locations
    outside the region `us-east-1` request the setting  `LocationConstraint` so the
    bucket can be created in the region that we wish.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the notification service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have everything set up, and the files that we are going to use as
    a template to send emails to the customers of the online (video) game store are
    in place in the `python-blueprints` S3 bucket, it is time to start implementing
    the notification service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go ahead and create a file called `app.py` in the `notifier` directory,
    and to start with, let''s add some imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: First, we import the JSON module so we can serialize and deserialize data. We
    import `HTTPStatus` from the HTTP module so we can use the HTTP status constants
    when sending responses back from the service's endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: Then we import the modules that we will need to send emails. We start by importing
    the `smtplib` and also some exceptions that we want to handle.
  prefs: []
  type: TYPE_NORMAL
- en: We also import `MIMEText`, which will be used to create a `MIME` object out
    of the email content, and the `MIMEMultipart` that will be used to create the
    message that we are going to send.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we import the `boto3` package so we can work with the *AWS* services.
    There are some exceptions that we will be handling; in this case, both exceptions
    are related to the *S3* buckets.
  prefs: []
  type: TYPE_NORMAL
- en: Next are some Flask related imports, and last but not least, we import the `Jinja2`
    package to template our emails.
  prefs: []
  type: TYPE_NORMAL
- en: 'Continuing working on the `app.py` file, let''s define the constant that will
    hold the name or the *S3* bucket that we created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we create the Flask app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We are also going to add a custom exception called `S3Error`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we are going to define two helper functions. The first one is to send
    emails:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Here, we define the function `_send_message`, which gets just one argument, `message`.
    We start this function by creating an object that will encapsulate an SMTP connection.
    We use `SMTP_SSL` because the AWS Simple Email Service required TLS. The first
    argument is the SMTP host, which we created at the AWS Simple Email Service, and
    the second argument is the port, which will be set as `456` when SMTP connections
    over SSL are required.
  prefs: []
  type: TYPE_NORMAL
- en: Then we call the login method, passing the username and the password, which
    can also be found in the AWS Simple Email Service. In cases where an `SMTPAuthenticationError` exception
    is thrown we send an `UNAUTHORIZED` response back to the client.
  prefs: []
  type: TYPE_NORMAL
- en: If logging into the SMTP server is successful, we call the `sendmail` method,
    passing the email that is sending the message, the destination recipient, and
    the message. We handle the situation where some of the recipients reject our message,
    in that we return an `INTERNAL SERVER ERROR` response, and then we just quit the
    connection.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we return the `OK` response stating that the message has been sent successfully.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we create a helper function to load the template file from the S3 bucket
    and return a rendered template for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Here we define the function `_prepare_template` and we take two arguments; `template_name`,
    which is the file name that we stored in the S3 bucket, and `context_data`, which
    is a dictionary containing the data that we are going to render in the template.
  prefs: []
  type: TYPE_NORMAL
- en: First, we create an S3 client, then we use the `get_object` method to pass the
    bucket name and the `Key`. We set the bucket keyword argument to `S3_BUCKET_NAME`,
    which we defined at the top of this file with the value of `python-blueprints`.
    The `Key` keyword argument is the name of the file; we set it to the value that
    we specified in the argument `template_name`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we access the key `Body` in the object returned from the S3 bucket, and
    call the method `read`. This will return a string with the file contents. Then,
    we create a Jinja2 Template object passing the contents of the template's file,
    and finally, we call the render method passing the `context_data`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s implement the endpoint that will be called to send a confirmation
    email to the customer whose order we receive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: So here, define a function called `notify_order_received`, which we decorate
    with the `@app.route` to define the route and the methods that are allowed when
    calling this endpoint. The route is defined as `/notify/order-received/` and the
    `methods` keyword argument takes a list with the allowed HTTP methods. In this
    case, we want to allow only POST requests.
  prefs: []
  type: TYPE_NORMAL
- en: We start this function by getting all the data that has been passed in the request.
    In Flask applications this data can be accessed on `request.data`; we use the
    `json.loads` method to pass `request.data` as an argument, so it will deserialize
    the JSON objects into a Python object. Then we get the items, which are a list
    with all the items included in the order, and we get the value of the attribute
    `order_customer` so we can get the customer's email and the customer's name.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we get the order ID, which can be accessed via the property `id`,
    and lastly, we get the total purchase value that is in the property `total` of
    the data that has been sent to this endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: Then we create an instance of `MIMEMultiPart` that passes as an argument `alternative`,
    which means that we will create a message with the `MIME` type set to multipart/alternative.
    After that, we configure a context that will be passed to the email template,
    and we use the `_prepare_template` function to pass the template that we want
    to render and the context with the data that will be displayed in the email. The
    value of the rendered template will be stored in the variable `email_content`.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we do the final setup for our email message; we attach the rendered
    template to the message, we set subject, sender, and destinations, and we call
    the `_send_message` function to send the message.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we are going to add the endpoint that will notify the users when their
    order has changed status to `Shipping`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Here we define a function called `notify_order_shipped` and decorate it with
    the `@app.route` decorator, passing two arguments and the route, which is set
    to `/notify/order-shipped/`, and define that the method that is going to be accepted
    in this endpoint is the `POST` method.
  prefs: []
  type: TYPE_NORMAL
- en: We start by getting the data that has been passed in the request - basically
    the same as the previous function, the `notify_order_received`. We also create
    an instance of `MIMEMultipart`, setting the `MIME` type to multipart/alternative.
    Next, we use the `_prepare_template` function to load the template and render
    using the context that we are passing in the second argument; in this case, we
    are passing only the customer's name.
  prefs: []
  type: TYPE_NORMAL
- en: Then we attach the template to the message and do the final set up, setting
    the subject, the send, and the destination. Finally, we call `_send_message` to
    send the message.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we are going to create two email templates, one that we are going to use
    when sending an order confirmation notification to the user and the other for
    when an order has been shipped.
  prefs: []
  type: TYPE_NORMAL
- en: Email templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we are going to create the templates that are going to be used when sending
    the notification emails to the online (video) game store's customers.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the application''s `root` directory, create a directory called `templates` and
    create a file called  `order_received_template.html`, with the contents shown
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s create another template in the same directory called `order_shipped_template.html`,
    with the contents shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: If you have read [Chapter 7](a8e0af3b-67d9-4649-986b-041d136af0e8.xhtml), *Online
    Video Game Store with Django*, you should be familiar with this syntax. The Jinja
    2 syntax has a lot of similarities when compared to the Django template language.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can copy the template to the S3 bucket that we created previously. Open
    a terminal and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Perfect! Next, we are going to deploy our project.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying the application with Zappa
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we have got to a very interesting section of the chapter. We are going to
    deploy the Flask app that we created using a tool called **Zappa** ([https://github.com/Miserlou/Zappa](https://github.com/Miserlou/Zappa)).
    Zappa is a tool developed in Python (by **Rich Jones**, the principal author of
    Zappa) that makes it very easy to build and deploy serverless Python applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'The installation is pretty straightforward. Within the virtual environment
    that we have been using to develop this project, you can just run the `pipenv`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: After the installation, you can start the configuration. You just need to make
    sure that you have a valid AWS account and the AWS credentials file is in place.
    If you followed this chapter from the beginning and installed and configured the
    AWS CLI you should be all set.
  prefs: []
  type: TYPE_NORMAL
- en: 'To configure Zappa for our project you can run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see the ASCII Zappa logo (very beautiful BTW), and it will start asking
    some questions. The first one is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'You can just hit *Enter* to default to `dev`. Next, Zappa will ask the name
    of an AWS S3 bucket:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you can either specify an existent or create a new one. Then, Zappa will
    try to detect the application that we are trying to deploy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, Zappa automatically found the Flask app defined in the `notify-service.py`
    file. You can just hit *Enter *to set the default value.
  prefs: []
  type: TYPE_NORMAL
- en: Next, Zappa will ask if you would like to deploy the application globally; we
    can keep the default and answer `n`. Since we are deploying this application in
    a development environment, we don't really need to deploy it globally. When your
    application goes into production you can evaluate if you need to deploy it globally.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, the complete configuration will be displayed, and here you have to change
    the review and make any modifications if needed. You don't need to be too worried
    about saving the configuration or not because the Zappa settings file is just
    a text file with the settings in JSON format.  You can just edit the file at any
    time and change it manually.
  prefs: []
  type: TYPE_NORMAL
- en: 'If everything went well, you should see a file called `zappa_settings.json`
    on the root''s directory of your application, with the contents similar to the
    content shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Here you can see the `dev` environment settings. The `app_function` specifies
    the Flask app that I created on the `notify-service.py` file, the `aws_region`
    specifies in which region the application will be deployed - in my case since
    I'm in Sweden, I chose `eu-west-2` *(*London*)* which is the closest region to
    me. The `project_name` will get by default the name of the directory where you
    run the command `zappa init`.
  prefs: []
  type: TYPE_NORMAL
- en: Then we have the runtime, which refers to the Python version that you are running
    with the application. Since the virtual environment that we created for this project
    used Python 3*,* the value for this property should be a version of Python 3 *-* in
    my case, I have installed 3.6.2\. Lastly, we have the name of the AWS S3 bucket
    that Zappa will use to upload the project files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s deploy the application that we just created! On the terminal, simply
    run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Zappa will perform lots of tasks for you, and at the end it will display the
    URL where the application has been deployed. In my case I''ve got:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Yours will look slightly different. So, we have defined two endpoints in our
    Flask application, `/notify/order-received` and `/notify/order-shipped`. These
    endpoints can be called with the following URLs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to see more information about the deployment, you can use the Zappa
    command: `zappa status`.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we are going to learn how to restrict access to these endpoints
    and create an access key that can be used to make the API calls.
  prefs: []
  type: TYPE_NORMAL
- en: Restricting access to the API's endpoints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our Flask application has been deployed, and at this point anyone can make a
    request to the endpoints that have been configured on the AWS API Gateway. What
    we want to do is restrict the access only to requests that contain an access key.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do that, log into our account on AWS console and on the Services menu search
    for and select Amazon API Gateway*.* Under the API on the left side menu, you
    will see the notifier-dev:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/abc851ca-9fc3-4626-986b-5cb84a46bdb2.png)'
  prefs: []
  type: TYPE_IMG
- en: Great! Here we are going to define a usage plan. Click on Usage Plans and then
    click on the Create button, and you will see a form for creating a new usage plan.
    Enter the name `up-blueprints`, uncheck the checkboxes for Enable throttling and
    Enable Quota*,* and click the Next button.
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to associate an API stage. So far we have only dev, so let's
    add the stage dev; click on Add API Stage button, and on the drop-down list select
    the notifier-dev and the stage dev. Make sure to click on the check button, the
    same row as the drop-down menus, otherwise, the Next button won't be enabled.
  prefs: []
  type: TYPE_NORMAL
- en: 'After clicking Next you will have to add an API key to the Usage Plan that
    we just created. Here you will have two options; add a new one or pick an existing
    one:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c6112886-16da-4ef5-a61d-759f7705a0f4.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's add a new one. Click on the button labeled Create API Key and add to Usage
    Plan. The API Key creation dialog will be shown, so just enter the name `notifiers-devs` and
    click save.
  prefs: []
  type: TYPE_NORMAL
- en: 'Great! Now if you select API Keys on the left side menu, you should see the
    newly created API Key on the list. If you selected it, you will be able to see
    all the details regarding the key:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a128780e-ca68-4ff5-97de-9a01b6be4413.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, on the left side menu, select APIs -> notifier-dev -> Resources, and on
    the tab Resources, select the root route /. On the right side panel, you can see
    the / Methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/bdc9760b-78aa-4d93-9ff3-69744d5d3f86.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Note that ANY says Authorization None and that API Key is set to Not required.
    Let''s change that so the API Key is required. On the Resources panel, click on
    ANY, you should see now a panel similar to the screenshot shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/adc0d6fd-888b-4f1f-b754-da4c176a292f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on Method Request:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/bc95c53f-b152-4b64-becd-b97ba441d619.png)'
  prefs: []
  type: TYPE_IMG
- en: Click on the pen icon next to API Key Required and, on the drop-down menu, select
    the value true*.*
  prefs: []
  type: TYPE_NORMAL
- en: Great! Now, the API calls to the stage dev should be restricted to requests
    with the API key notifier-dev in the request's Header.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, head over to API Keys and click on notifier-keys. On the right side
    panel, in the API `Key`, click on the link show, and the API key will be displayed
    for you. Copy that key, because we are going to use it in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying the order service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have the notifier application deployed, we have to modify our previous
    project, the order microservice, to make use of the notifier application and send
    notifications when a new order arrives and when the status of the order changes
    to shipped.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we have to do is to include the notifier service API key and
    its base URL in the `settings.py` file in the directory, called `order` on the
    order''s `root` directory, and include the following content at the end of the
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace these values with the corresponding values on your environment. If
    you don''t have the value for the `NOTIFIER_BASEURL`, you can obtain it running
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The value you want is the API Gateway URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we are going to create two files. The first one it is a file called `notification_type.py` in
    the `order/main` directory. In this file, we will define an enumeration with the
    notification types that we want to make available in our service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we are going to create a file with a helper function that will make the
    calls to the notification service. Create a file called `notifier.py` in the `order/main/`
    directory with the contents shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: From the top, we included some import statements; we are importing requests
    to perform the request to the notifier service, so we import the module json,
    so we can serialize the data to be sent to the notifier service. Then we import
    the settings so we can get hold of the constants that we defined with the base
    URL to the notifier service and the API key. Lastly, we import the notification
    type enumeration.
  prefs: []
  type: TYPE_NORMAL
- en: The function `notify` that we defined here takes two arguments, the order and
    the notification type, which are the values defined in the enumeration `NotificationType`.
  prefs: []
  type: TYPE_NORMAL
- en: We start by deciding which endpoint we are going to use, depending on the notification's
    type. Then we add an entry `X-API-KEY` to the request's `HEADER` with the API
    key.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we make a `POST` request that passes a few arguments. The first
    argument is the endpoint's URL, the second is the data that we are going to send
    to the notifier service (we use the `json.dumps` function so the data is sent
    in JSON format), and the third argument is the dictionary with the header data.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, when we get the response back we just return it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need to modify the view that is responsible for handling a `POST` request
    to create a new order, so that it calls the notify function when an order is created
    in the database. Let''s go ahead and open the file `view.py` in the `order/main`
    directory and add two import statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The two lines can be added before the first class in the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perfect, now we need to change the method post in the `CreateOrderView` class.
    Before the first return statement in that method, where we return a `201` (`CREATED`)
    response, include the code shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: So here we call the notify function, passing the serialized order using the
    `OrderSerializer` on the first argument, and the notification type - in this case,
    we want to send an `ORDER_RECEIVED` notification.
  prefs: []
  type: TYPE_NORMAL
- en: We will allow the user of the order service application to update the order
    using the Django Admin. There, they will be able to, for example, update an order's
    status, so we need to implement some code that will handle data changes made by
    users using the Django Admin.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we need to create a `ModelAdmin` class inside of the `admin.py`
    file in the `order/main` directory. First, we add some import statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we add the following class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Here, we create a class called `OrderAdmin` that inherits from the `admin.ModelAdmin`,
    and we override the method `save_model` so we have the chance to perform some
    actions before the data is saved. First, we get the order current status, then
    we check if the field `status` is between the list of fields that have been changed.
  prefs: []
  type: TYPE_NORMAL
- en: The if statement checks if the status field has changed, and if the current
    status of the order equals to `Status.Shipping` then we call the notify function,
    passing the serialized order object and the notification type `NotificationType.ORDER_SHIPPED`.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we call the `save_model` method on the super class to save the object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last piece of this puzzle is to replace this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead, put this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This will register the admin model `OrderAdmin` for the `Order` model. Now,
    when the user saves the order in the Django admin UI, it will call the `save_model`
    in the `OrderAdmin` class.
  prefs: []
  type: TYPE_NORMAL
- en: Testing all the pieces together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have the notifier application deployed and we have also made all
    the necessary modifications to the order service, it is time to test if all the
    applications are working together.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a terminal, change to the directory where you have implemented the online
    (video) game store, and execute the following command to start up the Django development
    server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This command will start the Django development server running on the default
    port `8000`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s start the order microservice. Open another terminal window, change
    to the directory where you implemented the order microserver, and run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can browse to `http://127.0.0.1:8000`, log in to the application and
    add some items to the cart:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/20a6d3cd-f8f3-4541-8c78-caecf5121171.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, I added three items and the total amount of this order is $32.75.
    Click on the button SEND ORDER, and you should get a notification on the page
    that the order has been sent.
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a31cb284-c9ec-4db6-ad49-a14fe17cd8e8.png)'
  prefs: []
  type: TYPE_IMG
- en: Great! Working as expected so far. Now we check the user's email, to verify
    if the notification service actually sent the order confirmation email.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fair enough, the user just got the email:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/8fd748de-ba5d-48ac-be77-58e7f81d223c.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that the sender and the destination recipients are the emails that I registered
    in the AWS Simple Email Service.
  prefs: []
  type: TYPE_NORMAL
- en: So now let's log in to the order service's Django admin and change the status
    for the same order to verify that the confirmation email that the order has been
    shipped will be sent to the user. Remember that the email will only be sent if
    the order has changed its status field to shipped.
  prefs: []
  type: TYPE_NORMAL
- en: 'Browse to `http://localhost:8001/admin/` and log in with the administrator
    credentials. You will see a page with the menu shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/063496f6-7f0d-40f4-ad9e-5916bdcdcc20.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on Orders and then select the order that we just submitted:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/92f7f9f5-dd5c-425b-a89e-269748d2f1b4.png)'
  prefs: []
  type: TYPE_IMG
- en: On the drop-down menu Status, change the value to Shipping and click the button
    SAVE.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if we verify the order customer''s email again we should have got another
    email confirming that the order has been shipped:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/0b0f6c48-27a2-4936-86d4-6d3386d1547c.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you have learned a bit more about serverless functions architecture,
    how to build a notification service using the web framework Flask, and how to
    deploy the final application to AWS Lambda using the great project Zappa.
  prefs: []
  type: TYPE_NORMAL
- en: Then, you learned how to install, configure, and use the AWS CLI tool, and used
    it to upload files to an AWS S3 bucket.
  prefs: []
  type: TYPE_NORMAL
- en: We also learned how to integrate the web application that we developed in [Chapter
    7](a8e0af3b-67d9-4649-986b-041d136af0e8.xhtml)*, Online Video Game Store with
    Django*,andthe order microservice that we developed in [Chapter 8](27b45ac1-0112-4b71-a3ee-d7c62a740a57.xhtml)*,*
    *Order Microservice*, with the serverless notification application.
  prefs: []
  type: TYPE_NORMAL
