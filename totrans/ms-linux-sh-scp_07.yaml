- en: Chapter 7. Creating Building Blocks with Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will dive into the wonderful world of functions. We can
    look at these as modular building blocks creating powerful and adaptive scripts.
    By creating functions, we add the code in a single building block isolated from
    the rest of the script. Focusing on improvements of a single function is a lot
    easier than trying to improve the script as a single object. Without functions,
    it is difficult to hone in on problem areas and the code is often repeated, it
    means that updates need to happen in many locations. Functions are named as blocks
    of code or scripts within scripts and they can overcome many problems associated
    with a more complex code.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we make our way through the chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing parameters to functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returning values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Menu using functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Functions are blocks of code that exist in memory as **named elements**. These
    elements can be created within the shell environment, as well as within the script
    execution. When a command is issued at the command line, aliases are checked first
    and following this we check for a matching function name. To display the functions
    residing in your shell environment, you can use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will vary depending on the distribution you are using and the number
    of functions you have created. On my Raspbian OS, the partial output is shown
    in the flowing screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introducing functions](img/00064.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Using the `-f` option, you can display the function and the associated definition.
    However, if we want to see just a single function definition, we can use the `type`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous code example will display the code block for the `quote` function,
    if it exists within your shell. We can see the output of this command in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introducing functions](img/00065.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `quote` function in bash inserts single quotes around a supplied input
    parameter. For example, we can expand the `USER` variable and display the value
    as a string literal; this is shown in the following screenshot. The screenshot
    captures the command and output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introducing functions](img/00066.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Most codes can be represented by a pseudo-code which shows an example layout.
    Functions are no different and the code to create a function is listed in the
    following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The function is created without a `do` and `done` block, as we have used in
    the previous loops. It is the purpose of the brace brackets to define the code
    block boundaries.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple function to display aggregated system information is shown in the
    following code. This can be created at the command line and will be a resident
    in your shell. This will not persist the logins and will be lost when the shell
    is closed or the function is unset. To allow the function to persist, we need
    to add this to the login script of our user account. The sample code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We can print the detail of the function similar to the prior instance using
    the type command; this is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introducing functions](img/00067.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'To execute the function, we need to simply type `show_system` and we will see
    the static text and output from the three commands: `uptime`, `lscpu`, and `who`.
    This of course is a very simple function but we can start to add more functionality
    by allowing parameters to be passed at runtime.'
  prefs: []
  type: TYPE_NORMAL
- en: Passing parameters to functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Earlier within this chapter, we referred to functions as scripts within scripts
    and we will still maintain that analogy. Similar to how a script can have input
    parameters, we can create functions that also accept parameters that can make
    their operation less static. Before we work on a script, we can look at a useful
    function in the command line.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of my pet-peeves is over commented configuration files, especially where
    documentation exists to detail the options available.
  prefs: []
  type: TYPE_NORMAL
- en: The GNU Linux command `sed` can easily edit the file for us and remove commented
    lines and empty lines. We are introducing the stream editor, `sed`, here but we
    will look at it in more detail in the following chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `sed` command line that runs the in-place edit will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We can run out forensics in the command line by breaking it down element by
    element. Let''s take a deeper look:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sed -i.bak`: This edits the file and creates a backup with the extension `.bak`.
    The original file will then be accessible as `<filename>.bak`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/^`: Lines that start with, that is the first character of the line.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\s*`: This means any amount of white space including no spaces or tabs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`#/`: Followed by the comment. Altogether `/^\s*#/` we are looking for lines
    that begin with a comment or spaces and a comment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`d`: The action delete to remove matching lines.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`;/^$/d`: The semi-colon is used to separate expressions and the second expression
    is similar to the first but this time we are preparing to delete empty lines or
    lines that being with the end of line marker `$`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To move this into a function, we will simply need to think of a great name.
    I like to build verbs into function names; it helps with the uniqueness and identifies
    the purpose of the function. We will create the `clean_file` function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'As within scripts, we use positional parameters to accept command-line arguments.
    We can replace the hard-coded filename that we used previously with `$1` within
    the function. We will quote this variable to protect against spaces within the
    filename. To test the `clean_file` function, we will make a copy of a system file
    and work with the copy. In this way, we can be sure that no harm comes to any
    system file. We can assure all readers that no system files were harmed during
    the making of this book. The following are the detailed steps we need to follow
    to perform the test on the new function:'
  prefs: []
  type: TYPE_NORMAL
- en: Create the `clean_file` function as described.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Move to your home directory using the `cd` command without arguments.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Copy the time configuration file to your home directory: `cp /etc/ntp.conf
    $HOME`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Count the number of lines in the file with the following command: `wc -l $HOME/ntp.conf`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, remove the commented and empty lines with: `clean_file $HOME/ntp.conf`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, recount the lines using: `wc -l $HOME/ntp.conf`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From the backup of the original that we created: `wc -l $HOME/ntp.conf.bak`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The sequence of commands is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Passing parameters to functions](img/00068.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We can direct the attention of the function to the required file using the argument
    that was supplied while executing the function. If we need to persist this function,
    then we should add it to a login script. However, if we want to test this within
    a shell script, we can create the following file to do this and practice some
    of the other elements we have learned. We will need to take notice that the functions
    should always be created at the start of the script as they need to be stored
    in memory by the time they are called. Just think that your function needs to
    be unlocked and loaded before you pull the trigger.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create a new shell script, `$HOME/bin/clean.sh` and the execute permission,
    as always, will need to be set. The code of the script is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We have provided two functions within the script. The first, `is_file`, simply
    tests to ensure that the filename we have entered is a regular file. Then we declare
    the `clean_file` function with a little added functionality, displaying the line
    count of the file before and after the operation. We can also see that functions
    can be nested and we call the `is_file` function with `clean_file`.
  prefs: []
  type: TYPE_NORMAL
- en: Without the function definitions we have only three lines of code at the end
    of the file that we can see in the example code laid out in the previous code
    block and has been save as `$HOME/bin/clean.sh`. We first prompt for the filename
    and then run the `clean_file` function, which in turn calls the `is_file` function.
    The simplicity of the main code is important here. The complexity is in the functions,
    as each function can be worked on as a standalone unit.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now test the script operation, first using a wrong filename, as we can
    see in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Passing parameters to functions](img/00069.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that we have seen the operation with an incorrect file, we can try again
    using an actual file! We can use the same system file we worked on before. We
    need to first return the files to their original state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'With the file now ready, we can execute the script from the `$HOME` directory
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Passing parameters to functions](img/00070.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Returning values from functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Whenever we have statements that are printed on the screen within the function,
    we can see their result. However, many times we will want the function to populate
    a variable within the script and not display anything. In this case, we use `return`
    in the function. This is especially important when we are gaining input from users.
    We may prefer the case to translate the input to a known case to make the condition
    testing easier. Embedding the code in a function allows it to be used many times
    within a script. The following code shows how we can achieve this by creating
    the `to_lower` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Stepping through the code we can begin to understand the operation of this
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '`input="$1"`: This is more for ease than anything else; we assign the first
    input parameter to a named variable input.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`output=$(tr [A-Z] [a-z] <<< "$input")`: This is the main engine of the function
    where the translation from upper case to lower case occurs. The use of the here
    string operator `<<<` allows us to expand the variable to read in to the contents
    to the `tr` program. This is a form of input redirection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`return$output`: This is how we create the return value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'One use of this function will be within a script that reads the user''s input
    and simplifies the test to see if they choose `Q` or `q`. This can be seen in
    the following extract of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Using functions in menus
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the last chapter, [Chapter 6](part0046_split_000.html#1BRPS1-747571d9b4814e1dbffcdef2eb0dec8d
    "Chapter 6. Iterating with Loops"), *Iterating with Loops* we created the `menu.sh`
    file. Menus are great targets to use functions, as the `case` statement is maintained
    very simply with single line entries, while the complexity can still be stored
    in each function. We should consider creating a function for each menu item. If
    we copy the previous `$HOME/bin/menu.sh` to `$HOME/bin/menu2.sh`, we can improve
    the functionality. The new menu should look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, we still maintain the simplicity of the case statement; however,
    we can develop the script to add in more complexity through the functions. For
    example, when choosing option b for the calendar, we now check to see if the `ncal`
    command is available. If it is, we use `ncal` and use the `-w` option to print
    the week number. We can see this in the following screenshot where we have chosen
    to display the calendar and install `ncal`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Using functions in menus](img/00071.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We can also not be concerned about the caps-lock key as the `to_lower` function
    converts our selection to lower case. Over time it would be very easy to add additional
    elements to the functions knowing that we only affect that single function.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are still making progress by leaps and bounds in script writing. I hope these
    ideas stay with you and you find the code examples useful. Functions are very
    important for the ease of maintenance of your scripts and their ultimate functionality.
    The easier the scripts are to maintain, the more likely you are to add improvements
    over time. We can define functions at the command line or within scripts but they
    need to be included in the script before they are used.
  prefs: []
  type: TYPE_NORMAL
- en: The functions themselves are loaded in to memory while the script is running,
    but as long as the script is forked and not sourced, they will be released from
    memory once the script is finished. We have touched a little upon `sed` in this
    chapter and we will look more at using the stream editor (`sed`) in the next chapter.
    The `sed` command is very powerful and we can make good use of it within scripts.
  prefs: []
  type: TYPE_NORMAL
