- en: Chapter 2. GoF Design Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a handful of things that make a great software developer. Knowledge
    and usage of design patterns is one of them. Design patterns empower developers
    to communicate using well-known names for various software interactions. Whether
    someone is a PHP, Python, C#, Ruby, or any other language developer, design patterns
    provide language agnostic solutions for frequently occurring software problems.
  prefs: []
  type: TYPE_NORMAL
- en: The concept of design patterns emerged in 1994 as part of the *Elements of Reusable
    Object-Oriented Software* book. Detailing 23 different design patterns, the book
    was written by four authors Erich Gamma, Richard Helm, Ralph Johnson, and John
    Vlissides. The authors are often referred to as the **Gang of Four** (**GoF**),
    and the presented design patterns are sometimes referred to as GoF design patterns.
    In Today, more than two decades later, designing software that is extensible,
    reusable, maintainable, and adaptable is near to impossible without embracing
    design patterns as part of implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three types of design patterns which we will cover in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Creational
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Structural
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Behavioral
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Throughout this chapter we will not go deep into the theory of each of them,
    as that alone is an entire book's worth of material. Moving forward, we will focus
    more on simple PHP implementation examples for each of the patterns, just so we
    get a more visual sense of things.
  prefs: []
  type: TYPE_NORMAL
- en: Creational patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Creational patterns, as the name suggests, create *objects* for us, so we do
    not have to instantiate them directly. Implementing creation patterns gives our
    application a level of flexibility, where the application itself can decide what
    objects to instantiate at a given time. The following is a list of patterns we
    categorize as creational patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: Abstract factory pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Builder pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Factory method pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prototype pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Singleton pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: See [https://en.wikipedia.org/wiki/Creational_pattern](https://en.wikipedia.org/wiki/Creational_pattern)
    for more information about creational design patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Abstract factory pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Building portable applications requires a great level of dependencies encapsulation.
    The abstract factory facilitates this by *abstracting the creation of families
    of related or dependent objects*. Clients never create these platform objects
    directly, the factory does it for them, making it possible to interchange concrete
    implementations without changing the code that uses them, even at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of possible abstract factory pattern implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We started off by creating an interface `Button`, which is later implemented
    by our `SubmitButton` and `ResetButton` concrete classes. `GUIFactory` and `ResetFactory`
    implement the `GUIFactory` interface, which specifies the `createButton` method.
    The client then simply instantiates factories and calls for `createButton`, which
    returns a proper button instance that we call the `render` method.
  prefs: []
  type: TYPE_NORMAL
- en: Builder pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The builder pattern separates the construction of a complex object from its
    representation, making it possible for the same construction process to create
    different representations. While some creational patterns construct a product
    in one call, builder pattern does it step by step under the control of the director.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of builder pattern implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We started off by creating a concrete `Car` class with several methods defining
    some base characteristics of a car. We then created a `CarBuilderInterface` that
    will control some of those characteristics and get the final result (`car`). The
    concrete class `CarBuilder` then implemented the `CarBuilderInterface`, followed
    by the concrete `CarBuildDirector` class, which defined build and the `getCar`
    method. The client then simply instantiated a new instance of `CarBuilder`, passing
    it as a constructor parameter to a new instance of `CarBuildDirector`. Finally,
    we called the `build` and `getCar` methods of `CarBuildDirector` to get the actual
    car `Car` instance.
  prefs: []
  type: TYPE_NORMAL
- en: Factory method pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `factory` method pattern deals with the problem of creating objects without
    having to specify the exact class of the object that will be created.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of factory method pattern implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We started off by creating a `ProductFactory` and `Product` interfaces. The
    `SimpleProductFactory` implements the `ProductFactory` and returns the new `product`
    instance via its `makeProduct` method. The `SimpleProduct` class implements `Product`,
    and returns the product type. Finally, the client creates the instance of `SimpleProductFactory`,
    calling the `makeProduct` method on it. The `makeProduct` returns the instance
    of the `Product`, whose `getType` method returns the `SimpleProduct` string.
  prefs: []
  type: TYPE_NORMAL
- en: Prototype pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The prototype pattern replicates other objects by use of cloning. What this
    means is that we are not using the `new` keyword to instantiate new objects. PHP
    provides a `clone` keyword which makes a shallow copy of an object, thus providing
    pretty much straight forward prototype pattern implementation. Shallow copy does
    not copy references, only values to the new object. We can further utilize the
    magic `__clone` method on our class in order to implement more robust clone behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of prototype pattern implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We started off by creating a simple `User` class. The `Employee` then extends
    the `User`, while setting `name` and `email` in its constructor. The client then
    instantiates the `Employee` via the `new` keyword, and clones it into the `director`
    variable. The `$director` variable is now a new instance, one made not by the
    `new` keyword, but with cloning, using the `clone` keyword. Changing `name` and
    `email` on `$director`, does not affect `$employee`.
  prefs: []
  type: TYPE_NORMAL
- en: Singleton pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The purpose of singleton pattern is to restrict instantiation of class to a
    *single* object. It is implemented by creating a method within the class that
    creates a new instance of that class if one does not exist. If an object instance
    already exists, the method simply returns a reference to an existing object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of singleton pattern implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We started off by creating a `Logger` class with a static `$instance` member,
    and the `getInstance` method that always returns a single instance of the class.
    Then we added a few sample methods to demonstrate the client executing various
    methods on a single instance.
  prefs: []
  type: TYPE_NORMAL
- en: Structural patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Structural patterns deal with class and object composition. Using interfaces
    or abstract classes and methods, they define ways to compose objects, which in
    turn obtain new functionality. The following is a list of patterns we categorize
    as structural patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: Adapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bridge
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Composite
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decorator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Facade
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flyweight
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Proxy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: See [https://en.wikipedia.org/wiki/Structural_pattern](https://en.wikipedia.org/wiki/Structural_pattern)
    for more information about structural design patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Adapter pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The adapter pattern allows the interface of an existing class to be used from
    another interface, basically, helping two incompatible interfaces to work together
    by converting the interface of one class into an interface expected by another
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of adapter pattern implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We started off by creating a concrete `Stripe` class. We then defined the `PaymentService`
    interface with some basic payment handling methods. The `StripePaymentServiceAdapter`
    implements the `PaymentService` interface, providing concrete implementation of
    payment handling methods. Finally, the client instantiates the `StripePaymentServiceAdapter`
    and executes the payment handling methods.
  prefs: []
  type: TYPE_NORMAL
- en: Bridge pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The bridge pattern is used when we want to decouple a class or abstraction from
    its implementation, allowing them both to change independently. This is useful
    when the class and its implementation vary often.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of bridge pattern implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We started off by creating a `MailerInterface`. The concrete `Mailer` class
    then implements the `MailerInterface`, providing a base class for `PHPMailer`
    and `SwiftMailer`. We then define the `MessagingInterface`, which gets implemented
    by the `TextMessage` and `HtmlMessage` classes. Finally, the client instantiates
    `PHPMailer` and `SwiftMailer`, passing on instances of `TextMessage` and `HtmlMessage`
    prior to calling the `send` method.
  prefs: []
  type: TYPE_NORMAL
- en: Composite pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The composite pattern is about treating the hierarchy of objects as a single
    object, through a common interface. Where the objects are composed into three
    structures and the client is oblivious to changes in the underlying structure
    because it only consumes the common interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of composite pattern implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We started off by creating a `Graphic` interface. We then created the `CompositeGraphic`,
    `Circle`, `Square`, and `Triangle`, all of which implement the `Graphic` interface.
    Aside from just implementing the `draw` method from the `Graphic` interface, the
    `CompositeGraphic` adds two more methods, used to track internal collection of
    graphics added to it. The client then instantiates all of these `Graphic` classes,
    adding them all to the `CompositeGraphic`, which then calls the `draw` method.
  prefs: []
  type: TYPE_NORMAL
- en: Decorator pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The decorator pattern allows behavior to be added to an individual object instance,
    without affecting the behavior of other instances of the same class. We can define
    multiple decorators, where each adds new functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of decorator pattern implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We started off by creating a `LoggerInterface`, with a simple `log` method.
    We then defined `Logger` and `LoggerDecorator`, both of which implement the `LoggerInterface`.
    Followed by `ErrorLoggerDecorator`, `WarningLoggerDecorator`, and `NoticeLoggerDecorator`
    which implement the `LoggerDecorator`. Finally, the client part instantiates the
    `logger` three times, passing it different decorators.
  prefs: []
  type: TYPE_NORMAL
- en: Facade pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The facade pattern is used when we want to simplify the complexities of large
    systems through a simpler interface. It does so by providing convenient methods
    for most common tasks, through a single wrapper class used by a client.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of facade pattern implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We started off by creating a `Product` class, with a single `getQty` method.
    We then created a `QuickOrderFacade` class that accepts `product` instance and
    quantity via a `constructor` and further provides the `generateOrder` method that
    aggregates all of the order generating actions. Finally, the client instantiates
    the `product`, which it passes onto the instance of `QuickOrderFacade`, calling
    the `generateOrder` on it.
  prefs: []
  type: TYPE_NORMAL
- en: Flyweight pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The flyweight pattern is about performance and resource reduction, sharing as
    much data as possible between similar objects. What this means is that instances
    of a class which are identical are shared in an implementation. This works best
    when a large number of same class instances are expected to be created.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of flyweight pattern implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We started off by creating a `Shape` interface, with a single `draw` method.
    We then defined the `Circle` class implementing the `Shape` interface, followed
    by the `ShapeFactory` class. Within the `ShapeFactory`, the `getCircle` method
    returns an instance of a new `Circle`, based on the `color` option. Finally, the
    client instantiates several `ShapeFactory` objects, passing in different colors
    to the `getCircle` method call.
  prefs: []
  type: TYPE_NORMAL
- en: Proxy pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The proxy design pattern functions as an interface to an original object behind
    the scenes. It can act as a simple forwarding wrapper or even provide additional
    functionality around the object it wraps. Examples of extra added functionality
    might be lazy loading or caching that might compensate for resource intense operations
    of an original object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of proxy pattern implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We started off by creating an `ImageInterface`, with a single `draw` method.
    We then defined the `Image` and `ProxyImage` classes, both of which extend the
    `ImageInterface`. Within the `__construct` of the `Image` class, we simulated
    the **resource intense** operation with the `sleep` method call. Finally, the
    client instantiates both `Image` and `ProxyImage`, showing the execution time
    difference between the two.
  prefs: []
  type: TYPE_NORMAL
- en: Behavioral patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Behavioral patterns tackle the challenge of communication between various objects.
    They describe how different objects and classes send messages to each other to
    make things happen. The following is a list of patterns we categorize as behavioral
    patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: Chain of responsibility
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interpreter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Iterator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mediator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memento
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Observer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: State
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Strategy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Template method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visitor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chain of responsibility pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The chain of responsibility pattern decouples the sender of a request from its
    receiver, by enabling more than one object to handle requests, in a chain manner.
    Various types of handling objects can be added dynamically to the chain. Using
    a recursive composition chain allows for an unlimited number of handling objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of chain of responsibility pattern implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We started off by creating an abstract `SocialNotifier` class with the abstract
    method `publish`, `notifyNext`, and `push` method implementations. We then defined
    `TwitterSocialNotifier`, `FacebookSocialNotifier`, and `PinterestSocialNotifier`,
    all of which extend the abstract `SocialNotifier`. The client starts by instantiating
    the `TwitterSocialNotifier`, followed by two `notifyNext` calls, passing it instances
    of two other `notifier` types before it calls the final `push` method.
  prefs: []
  type: TYPE_NORMAL
- en: Command pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The command pattern decouples the object that executes certain operations from
    objects that know how to use it. It does so by encapsulating all of the relevant
    information needed for later execution of a certain action. This implies information
    about object, method name, and method parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of command pattern implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We started off by creating a `LightBulbCommand` interface. We then defined the
    `LightBulbControl` class that provides two simple `turnOn` / `turnOff` methods.
    Then we defined the `TurnOnLightBulb` and `TurnOffLightBulb` classes which implement
    the `LightBulbCommand` interface. Finally, the client is instantiating the `TurnOffLightBulb`
    object with an instance of `LightBulbControl`, and calling the `execute` method
    on it.
  prefs: []
  type: TYPE_NORMAL
- en: Interpreter pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The interpreter pattern specifies how to evaluate language grammar or expressions.
    We define a representation for language grammar along with an interpreter. Representation
    of language grammar uses composite class hierarchy, where rules are mapped to
    classes. The interpreter then uses the representation to interpret expressions
    in the language.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of interpreter pattern implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We started off by creating a `MathExpression` interface, with a single `interpret`
    method. We then add `Variable`, `Literal`, `Sum`, and `Product` classes, all of
    which implement the `MathExpression` interface. The client then instantiates from
    the `Product` class, passing it instances of `Literal` and `Sum`, finishing with
    an `interpret` method call.
  prefs: []
  type: TYPE_NORMAL
- en: Iterator pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The iterator pattern is used to traverse a container and access its elements.
    In other words, one class becomes able to traverse the elements of another class.
    The PHP has a native support for the iterator as part of built in `\Iterator`
    and `\IteratorAggregate` interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of iterator pattern implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We started off by creating a `ProductIterator` which implements the standard
    PHP `\Iterator` interface. We then added the `ProductCollection` which implements
    the standard PHP `\IteratorAggregate` interface. The client creates an instance
    of `ProductCollection`, stacking values into it via the `addProduct` method call
    and loops through the entire collection.
  prefs: []
  type: TYPE_NORMAL
- en: Mediator pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The more classes we have in our software, the more complex their communication
    becomes. The mediator pattern addresses this complexity by encapsulating it into
    a mediator object. Objects no longer communicate directly, but rather through
    a mediator object, therefore lowering the overall coupling.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of mediator pattern implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We started off by creating a `MediatorInterface` with several methods, implemented
    by the `ConcreteMediator` class. We then defined the abstract class `Colleague`
    to force the `doSomething` method implementation on the following `ColleagueA`
    and `ColleagueB` classes. The client instantiates the `ConcreteMediator` first,
    and passes its instance to the instances of `ColleagueA` and `ColleagueB`, upon
    which it calls the `doSomething` method.
  prefs: []
  type: TYPE_NORMAL
- en: Memento pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The memento pattern provides the object restore functionality. Implementation
    is done through three different objects; originator, caretaker, and a memento,
    where the originator is the one preserving the internal state required for a later
    restore.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of memento pattern implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We started off by creating a `Memento` class, which will provide the a current
    state of the object through the `getState` method. We then defined the `Originator`
    class that pushed the state to `Memento`. Finally, the client takes the role of
    `caretaker` by instantiating `Originator`, juggling among its few states, saving
    and restoring them from `memento`.
  prefs: []
  type: TYPE_NORMAL
- en: Observer pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The observer pattern implements a one-too-many dependency between objects. The
    object that holds the list of dependencies is called **subject**, while the dependents
    are called **observers**. When the subject object changes state, all of the dependents
    are notified and updated automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of observer pattern implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We started off by creating a `Customer` class which implements the standard
    PHP `\SplSubject` interface. We then defined the `CustomerObserver` class which
    implements the standard PHP `\SplObserver` interface. Finally, the client instantiates
    the `Customer` and `CustomerObserver` objects and attaches the `CustomerObserver`
    objects to `Customer`. Any changes to `name` and `email` properties are then caught
    by the `observer`.
  prefs: []
  type: TYPE_NORMAL
- en: State pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The state pattern encapsulates the varying behavior for the same object based
    on its internal state, making an object appear as if it has changed its class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of state pattern implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We started off by creating a `Statelike` interface, followed by `StateLowerCase`
    and `StateMultipleUpperCase` which implement that interface. The `StateMultipleUpperCase`
    has a bit of counting logic added to its `writeName`, so it kicks off the new
    state after two invocations. We then defined the `StateContext` class, which we
    will use to switch contexts. Finally, the client instantiates the `StateContext`,
    and passes an instance of `StateLowerCase` to it through the `setState` method,
    followed by several `writeName` methods.
  prefs: []
  type: TYPE_NORMAL
- en: Strategy pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The strategy pattern defines a family of algorithms, each of which is encapsulated
    and made interchangeable with other members within that family.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of strategy pattern implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We started off by creating a `PaymentStrategy` interface followed with concrete
    classes `StripePayment` and `PayPalPayment` which implement it. We then defined
    the `Checkout` class with a bit of decision making logic within the `capturePayment`
    method. Finally, the client instantiates the `Checkout`, passing a certain amount
    through its constructor. Based on the amount, the `Checkout` internally triggers
    one or another `payment` when `capturePayment` is called.
  prefs: []
  type: TYPE_NORMAL
- en: Template pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The template design pattern defines the program skeleton of an algorithm in
    a method. It lets us, via use of class overriding, redefine certain steps of an
    algorithm without really changing the algorithm's structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of template pattern implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We started off by creating an abstract `Game` class that provides all of the
    actual abstract methods encapsulating the game-play. We then defined the `Monopoly`
    and `Chess` classes, both of which extend from the `Game` class, implementing
    game specific method game-play for each. The client simply instantiates the `Monopoly`
    and `Chess` objects, calling the `playOneGame` method on each.
  prefs: []
  type: TYPE_NORMAL
- en: Visitor pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The visitor design pattern is a way of separating an algorithm from an object
    structure on which it operates. As a result, we are able to add new operations
    to existing object structures without actually modifying those structures.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of visitor pattern implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We started off by creating a `RoleVisitorInterface`, followed by `RolePrintVisitor`
    which implements the `RoleVisitorInterface` itself. We then defined the abstract
    class `Role`, with an accept method taking in the `RoleVisitorInterface` parameter
    type. We further defined the concrete `User` and `Group` classes, both of which
    extend from `Role`. The client instantiates `User`, `Group`, and the `RolePrintVisitor`;
    passing in the `visitor` to the accept method call of `User` and `Group` instances.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Design patterns are a common, high-level language for developers. They enable
    a short-hand way of communicating application design among team members. Understanding
    how to recognize and implement design patterns shifts our focus to business requirement
    solving, rather than tinkering with how to glue our solution together on a code
    level.
  prefs: []
  type: TYPE_NORMAL
- en: Coding, like most hand-crafted disciplines, is one of those where you get what
    you pay for. While implementing a number of design patterns takes a certain amount
    of time, lack of doing so on a larger project will likely catch up with us in
    the future, one way or another. Similar to the "use a framework or not" debate,
    implementing the right design patterns affects *extensibility*, *re-usability*,
    *adaptability*, and *maintainability* of our code. Therefore, making it more future
    proof.
  prefs: []
  type: TYPE_NORMAL
- en: Moving forward, in the next chapter, we will look into the SOLID design principles
    and the role they play in software development processes.
  prefs: []
  type: TYPE_NORMAL
