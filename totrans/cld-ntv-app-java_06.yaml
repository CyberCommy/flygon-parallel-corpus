- en: Extending Your Cloud-Native Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having understood the design principles, let's take the skeleton services developed
    in [Chapter 2](8a0a7cae-4aaa-460d-a760-59d0ffde9b48.xhtml), *Writing Your First
    Cloud-Native Application*, and do some real work on them to make them production-ready.
  prefs: []
  type: TYPE_NORMAL
- en: 'We defined two get services; `getProduct` for a given a product ID, and `getProducts`
    for a given category. These two services have highly non-functional requirements.
    They always have to be available and serve the data with the lowest possible latency.
    The following steps will take us there:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Accessing data**: Service access to data across various resources'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Caching**: Options to do caching and their considerations'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Applying CQRS**: Enable us to have different data models to service different
    requests'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Error handling**: How to recover, what return codes to send, and implementation
    of patterns such as a circuit breaker'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will also look at adding methods to modify the data, such as `insert`, `update`,
    and `delete`. In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Validations**: Ensuring that the data is clean before being processed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Keeping two models of CQRS in sync**: For data consistency'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Event driven and a****synchronous updates**: How it scales the architecture
    and decouples it at the same time'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the get services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's take our `product` project developed in [Chapter 2](8a0a7cae-4aaa-460d-a760-59d0ffde9b48.xhtml),
    *Writing Your First Cloud-Native Application*, forward. We will incrementally
    enhance it while discussing the concepts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s think carefully about the database of our two services. `getProduct`
    returns the product information, while `getProducts` searches a list of products
    that fall into this category. To begin with, for simple and standard requirements,
    both queries can be answered by a single data model in a relational database:'
  prefs: []
  type: TYPE_NORMAL
- en: You would store a product in a product table with a fixed number of columns.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You would then index the category so that the queries against it can run quickly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, this design will be fine for most requirements for an average-sized company.
  prefs: []
  type: TYPE_NORMAL
- en: Simple product table
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's use a product table in a standard relational database and access it in
    our service using Spring Data. Spring Data provides excellent abstractions to
    use the **Java Persistence API** (**JPA**) and makes coding **data access objects**
    (**DAO**) much easier. Spring Boot further helps in writing minimal code to begin
    with and extending it as we go ahead.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Boot can work with embedded databases, such as H2, HSQLDB, or the external
    database. In-process embedded database starts with our Java service in a process
    and then terminates when the process dies. This is fine to begin with. Later on,
    the dependencies and URLs can be changed to point to actual databases.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can take the project from [Chapter 2](8a0a7cae-4aaa-460d-a760-59d0ffde9b48.xhtml),
    *Writing Your First Cloud-Native Application,* and add the following steps, or
    just download the completed code from GitHub ([https://github.com/PacktPublishing/Cloud-Native-Applications-in-Java](https://github.com/PacktPublishing/Cloud-Native-Applications-in-Java)):'
  prefs: []
  type: TYPE_NORMAL
- en: '**Maven POM**: Including POM dependencies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/eea764ef-0caa-4040-a8bb-c3268da21093.png)'
  prefs: []
  type: TYPE_IMG
- en: This will tell Spring Boot to include the Spring Boot starter JPA and use HSQLDB
    in embedded mode.
  prefs: []
  type: TYPE_NORMAL
- en: '**Entity**: As per the JPA, we will start using the concept of entity. We already
    have a domain object named `Product` from our previous project. Refactor it to
    put in an entity package. Then, add the notations of `@Entity`, `@Id`, and `@Column`,
    as shown in the following `Product.java` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The rest of the code, such as constructors and getters/setters, remains the
    same.
  prefs: []
  type: TYPE_NORMAL
- en: '**Repository**: Spring Data provides a repository, which is like a DAO class
    and provides methods to do **Create**, **Read**, **Update**, and **Delete** (**CRUD**)
    operations on the data. A lot of standard operations are already provided in the
    `CrudRepository` interface. We will be using only the query operations from now
    on.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In our case, since our domain entity is `Product`, the repository will be `ProductRepository`,
    which extends Spring''s `CrudRepository`, and manages the `Product` entity. During
    extension, the entity and the data type of the primary key needs to be specified
    using generics, as shown in the following `ProductRepository.java` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The first question that would come to mind is whether this code is sufficient
    enough to work. It has just one interface definition. How can it be enough to
    handle our two methods, namely `getProduct` (given a product ID) and `getProducts`
    (for a given category)?
  prefs: []
  type: TYPE_NORMAL
- en: The magic happens in Spring Data, which helps with the boilerplate code. The
    `CrudRepository` interface comes with a set of default methods to implement the
    most common operations. These include `save`, `delete`, `find`, `count`, and `exists`
    operations which suffice for most of the query and update tasks. We will look
    at the `update` operations in the second half of this chapter, but let's focus
    on the query operations first.
  prefs: []
  type: TYPE_NORMAL
- en: The operation of finding a product given an ID is already present in the `CrudRepository`
    as a `findOne` method. Hence, we do not need to call it explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: The task of finding products for a given category is done by the `findByCatId`
    method in our `ProductRepository` interface. The query builder mechanism built
    into the Spring Data repository infrastructure is useful for building queries
    over entities of the repository. The mechanism strips the prefixes, such as `find`,
    `read`, `query`, `count`, and `get` from the method and starts parsing the rest
    of it based on the entity. This mechanism is very powerful because the choice
    of keywords and the combinations means the method name is enough to do most of
    the query operations including operators (`and`/`or`) distinct clauses, and so
    on. Do refer to the Spring Data reference documentation ([https://docs.spring.io/spring-data/jpa/docs/current/reference/html/](https://docs.spring.io/spring-data/jpa/docs/current/reference/html/))
    to see the details.
  prefs: []
  type: TYPE_NORMAL
- en: These conventions allow Spring Data and Spring Boot to inject implementations
    of the methods based on parsing the interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: '**Changing the service**: In [Chapter 2](8a0a7cae-4aaa-460d-a760-59d0ffde9b48.xhtml),
    *Writing Your First Cloud-Native Application,* our `product` service was returning
    dummy hard-coded data. Let''s change it to something useful that goes against
    the database. We achieve this by using the `ProductRepository` interface that
    we defined earlier, and injecting it through `@Autowiring` annotation into our
    `ProductService` class, as shown in the following `ProductService.java` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `findOne` method from the repository gets the object given a primary key,
    and the `findByCatId` method we defined helps to find products given a category.
  prefs: []
  type: TYPE_NORMAL
- en: '**Schema definition**: For now, we will leave the schema creation to the `hibernate`
    capability to auto generate a script. Since we do want to see what script got
    created, let''s enable `logging` for the classes as follows in the `application.properties`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '**Test data**: Since we are going to insert the products later, we need our
    database to be initialized with some products. Hence, add the following lines
    into `import.sql` and place it in resources (where the `application.properties`
    and bootstrap files reside):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '**Leave Spring Data and Spring Boot to figure out the rest: **But in a production
    application, we would want to have fine-grained control over the connection URL,
    user ID, password, connection pool properties, and so on.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Running the service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To run our `product` service, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Fire up the Eureka server (as we did in [Chapter 2](8a0a7cae-4aaa-460d-a760-59d0ffde9b48.xhtml),
    *Writing Your First Cloud-Native Application*) using the `EurekaApplication` class.
    We are going to keep the Eureka service running at all times.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the `Eureka` project starts, run the `product` service.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Notice the logs generated by `hibernate`. It first uses an HSQLDB dialect automatically, and
    then creates and runs the `Product` table SQL as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the service starts to listen on a port, fire a query in your browser: `http://localhost:8082/product/1`.
    This will return the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'When you see the logs, you will observe the SQL that ran in the background:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, fire another query that returns products for a given category: `http://localhost:8082/products?id=1`.
    This will return the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The SQL that ran for this condition was as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'And trying with a different category, `http://localhost:8082/products?id=2`,
    will return something as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This completes a simple query service going against a data source.
  prefs: []
  type: TYPE_NORMAL
- en: For production purposes, this will need enhancement to take a standard database
    as an Oracle, PostgreSQL, or MySQL database. You will introduce an index on the
    category column so that the queries run faster.
  prefs: []
  type: TYPE_NORMAL
- en: Limitations of traditional databases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: But what happens as the company expands its products and customers in the following
    scenarios?
  prefs: []
  type: TYPE_NORMAL
- en: The scalability of a relational database (in terms of volume of products and
    number of concurrent requests) becomes a bottleneck.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The product structure is different based on the category and is difficult to
    model in a fixed schema of a relational database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The search criteria starts increasing in scope. As of now, we are searching
    only by category; later on, we might want to search by product description, filter
    fields, and also by category description.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Will a single relational database suffice for all requirements?
  prefs: []
  type: TYPE_NORMAL
- en: Let's address the concerns with a few design techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Caching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the service scales in terms of the amount of data and concurrency of requests,
    the database will start becoming a bottleneck. In order to scale, we can adopt
    a caching solution that will reduce the number of hits to the database by servicing
    the requests from a cache if the value is available in the cache.
  prefs: []
  type: TYPE_NORMAL
- en: Spring provides mechanisms to include caching through annotations, so that Spring
    can return cached values instead of calling the actual processing or retrieval
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: Conceptually, caching comes in two types, as discussed in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Local cache
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The local cache is present in the same JVM as that of the service. Its scope
    is limited as it can be accessed by the service instance and has to be entirely
    managed by the service instance.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by making our products cacheable in a local cache.
  prefs: []
  type: TYPE_NORMAL
- en: Spring 3.1 introduced its own notations for returning cached entries, evicting,
    or populating entries. But later on, JSR 107 JCache introduced different notations.
    Spring 4.1 and higher supports these as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use the Spring notations to begin with:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Tell the Spring application to enable caching and look for cacheable instances.
    This is a one-time declaration and hence is best done in the start-up class. Add
    the `@``EnableCaching` annotation into the main class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Enable the cache in our `ProductRepository` for getting products by category,
    by adding a cacheable notation. We will give a cache name that is explicit and
    will be used for this method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, run the service again and observe the logs when you run the following
    set of queries in your browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '`http://localhost:8082/products?id=1`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`http://localhost:8082/products?id=2`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`http://localhost:8082/products?id=1`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`http://localhost:8082/products?id=2`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will see that the following SQL has been fired only twice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This means that the repository executed the `findByCatId` method only when it
    did not find a category entry in the cache.
  prefs: []
  type: TYPE_NORMAL
- en: Under the hood
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While it is nice that Spring handles a lot of concerns such as caching implementation
    under the hood, it is important to understand what is happening and be aware of
    the limitations.
  prefs: []
  type: TYPE_NORMAL
- en: Internally, caching is implemented by internal classes such as cache manager
    and cache resolver. When no caching product or framework is supplied, Spring uses
    `ConcurrentHashMap` by default. Spring's caching implements many other local caches
    such as EHCache, Guava, and Caffeine.
  prefs: []
  type: TYPE_NORMAL
- en: Check out the Spring documentation ([https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/cache/annotation/Cacheable.html](https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/cache/annotation/Cacheable.html))
    for more intricacies such as `sync=true` and conditional caching.
  prefs: []
  type: TYPE_NORMAL
- en: Limitations of a local cache
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Local cache is useful in limited use cases (such as non-changing static data)
    as the updates done in one service using Spring annotations such as `@CachePut`,
    `@CacheEvict`, and so on cannot be synchronized with a cache on the other instance
    of services if we are running more than one instance of a service for load balancing
    or resiliency purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Distributed cache
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A distributed cache such as Hazelcast, Gemfire, and/or Coherence is network-aware
    and the cache instances operate either as an in-process model (peer-peer model),
    where the cache is part of the service runtime, or a client-server model, where
    the cache request goes from the service to separate dedicated cache instances.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this example, we have selected Hazelcast, as it is a very lightweight but
    powerful distributed caching solution. It also integrates very well with Spring
    Boot. Here is how:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the POM (Maven file), add a dependency to `hazelcast-spring`. The `hazelcast-spring`
    has a `HazelcastCacheManager` that configures a Hazelcast instance to be used:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Since Hazelcast is a distributed cache, it needs the elements to be serializable.
    Hence, we need to ensure that our `Product` entity is serializable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'A simplified Hazelcast configuration file that tells the various Hazelcast
    instances to discover and synchronize with each other:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s test these changes. For this, we have to run two instances of the
    `product` service to check if it works. We can run two instances by changing the
    port number:'
  prefs: []
  type: TYPE_NORMAL
- en: Run the service with port `8082` (which is configured).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the `application.properties` to `8083`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the service again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will see Hazelcast messages on one service that starts as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'But as soon as the second service is started, the member definitions get updated
    by `2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, on the browser, run the following queries and observe the logs in the
    console:'
  prefs: []
  type: TYPE_NORMAL
- en: '`http://localhost:8082/products?id=1`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`http://localhost:8082/products?id=2`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`http://localhost:8082/products?id=1`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`http://localhost:8082/products?id=2`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`http://localhost:8083/products?id=1`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`http://localhost:8083/products?id=2`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will find that in the SQL, debug logs come only twice in the first service.
    The other four times, the cache entries are picked from Hazelcast. Unlike the
    previous local cache, the cache entries are synchronized between two instances.
  prefs: []
  type: TYPE_NORMAL
- en: Applying CQRS to separate data models and services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A distributed cache is one way to solve the scaling problem. However, it introduces
    certain challenges, such as cache staleness (keeping the cache in sync with the
    database) and additional memory requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Also, caching is the beginning of the transition to the CQRS paradigm. Revisit
    the concepts of CQRS that we discussed in Chapter 3, *Designing Your Cloud-Native
    Application*.
  prefs: []
  type: TYPE_NORMAL
- en: The queries are answered from the cache (apart from the first hit), which is
    query segregation from the commands that go from the system of record (which is
    the database) and update the query model (cache update) later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take the next step in CQRS to do this segregation cleanly. The complexity
    that CQRS introduces is:'
  prefs: []
  type: TYPE_NORMAL
- en: Having two (or multiple) models to maintain instead of one
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overheads of updating all models when the data changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consistency guarantees between the different models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hence, this model should be followed only if the use case demands separation
    for high concurrency, high volume, and rapid agility requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Materialized views on a relational database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Materialized views are the simplest form of CQRS. If we assume that the updates
    to products happen less frequently as compared to the reads on the product and
    category, then we can have two different models supporting the `getProduct` (for
    an ID) and `getProducts` (for a given category).
  prefs: []
  type: TYPE_NORMAL
- en: The search query `getProducts` goes against this view, while the traditional
    `getProduct` based on the primary key goes to the regular table.
  prefs: []
  type: TYPE_NORMAL
- en: This should be pretty easy if supported by a database such as Oracle. If a database
    does not support a materialized view by default, it can be done manually if there
    is a need, by manually updating statistics or summary tables when the main product
    table is updated using triggers or better event-driven architecture, such as business
    events. We shall see this in the second half of this chapter, when we add `addProduct` functionality
    to our set of services.
  prefs: []
  type: TYPE_NORMAL
- en: Elasticsearch and a document database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To address limitations of flexible schema, high search ability, and higher
    volume handling, we can go for NoSQL technologies:'
  prefs: []
  type: TYPE_NORMAL
- en: For serving different types of products, we could choose to use a document database
    with its flexible schema, for example, MongoDB.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For serving search requests, Elasticsearch, a Lucene based technology, will
    be beneficial due to its powerful indexing capability.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why not use only a document database or Elasticsearch?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is quite possible to think of these options as well:'
  prefs: []
  type: TYPE_NORMAL
- en: Elasticsearch is typically a complementary technology and not used as a master
    database. Hence, the product information should be maintained in a reliable, relational,
    or NoSQL database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A document database such as MongoDB can build indexes too. However, the performance
    or indexing capability cannot equal Elasticsearch.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is a classic example for fit for purpose. Your choice will depend on your
    use case:'
  prefs: []
  type: TYPE_NORMAL
- en: Whether you have flexible schema needs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scalable and high volume applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Highly flexible search requirements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Core product service on a document database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Keeping the REST interface the same, let's change the internal implementation
    from using a relational database (HSQLDB, in our example) to MongoDB. Instead
    of running MongoDB in a process such as HSQLDB, we will run it separately as a
    server.
  prefs: []
  type: TYPE_NORMAL
- en: Getting MongoDB ready with test data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The steps to download and install MongoDB are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Install MongoDB. It is fairly easy to follow the instructions for various platforms
    on the MongoDB website ([https://www.mongodb.com/](https://www.mongodb.com/)).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run `mongod.exe` to start an instance of MongoDB.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a test file with our sample data (similar to `import.sql`). This time,
    however, we will keep the data in JSON format instead of SQL statements. The `products.json`
    file is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Note the `_id`, which is the primary key notation for MongoDB. If you do not
    provide an `_id`, MongoDB will auto generate that field with the `ObjectId` definition.
  prefs: []
  type: TYPE_NORMAL
- en: 'Load the sample data into MongoDB. We will create a database called `masterdb`
    and load into a collection called `product`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Check whether the data got loaded on the command line, by using the `db.product.find()`
    command, after `use masterdb` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/dc4d8193-a647-4c3a-b209-b18fe87c4f86.png)'
  prefs: []
  type: TYPE_IMG
- en: Creating the product service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The steps to create a `product` service are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: It is better to start with a clean slate. Copy your project from the earlier
    example with Hazelcast and HSQLDB or pull from the GitHub repository ([https://github.com/PacktPublishing/Cloud-Native-Applications-in-Java](https://github.com/PacktPublishing/Cloud-Native-Applications-in-Java)).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Adjust the Maven POM file to have the following dependencies. Remove the other
    ones since they are not required for our small example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Product` entity should just have an `@Id` field. It is optional to put
    a `@Document` annotation at the class level. If not, the first insert performance
    suffers. For now, let''s have the annotation in the `Product.java` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `id` here is `String` instead of `int`. The reason for that is
    that NoSQL databases are much better at generating the ID as a string (GUID) compared
    to incrementing integers in relational systems such as databases. The reason for
    that is databases are getting more distributed, so generating incrementing numbers
    reliably is a little more difficult compared to generating GUIDs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ProductRepository` now extends the `MongoRepository` which has methods
    for retrieving the product from MongoDB as follows in the `ProductRepository.java`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We just add one property to `application.properties` to tell the service to
    get our data from the `masterdb` database in MongoDB. Also, it is probably better
    to run it on a different port so that we can run the services in parallel if we
    want to do so later:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The `ProductService` class does not change as there is no change in the interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, start the Eureka server, then the service, and fire the following queries
    in the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '`http://localhost:8085/products?id=1`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`http://localhost:8085/products?id=2`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`http://localhost:8085/product/1`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`http://localhost:8085/product/2`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will get the same JSONs back as before. This is an internal implementation
    change of the microservice.
  prefs: []
  type: TYPE_NORMAL
- en: Splitting the services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's go with a simple implementation of the suggested separation from a learning
    perspective. Since we are separating the master and search models, it makes sense
    to split the services, as the functionality of the search can be considered a
    downstream function to the **Product** master.
  prefs: []
  type: TYPE_NORMAL
- en: The `getProducts` function for a category is part of the search functionality,
    which can become a complex and independent business area in itself. Hence, it
    is time to rethink whether it makes sense to keep them both in the same microservice
    or split them into core **Product** service and **Product Search** services.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ae3c783c-1df2-4e72-9162-7d4bb4cac904.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The product-search service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's create a new microservice that specializes in high speed, high volume
    searches. The search data store backing the search microservice need not be a
    master of the product data, but can act as a complementary search model. Elasticsearch
    has been extremely popular for a variety of search use cases and fits the need
    for extreme search requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Elasticsearch ready with test data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are the steps to get Elasticsearch ready with test data:'
  prefs: []
  type: TYPE_NORMAL
- en: Install the Elastic version. Use version 2.4.3, since the recent 5.1 versions
    are not compatible with Spring Data. Spring Data uses Java drivers that communicate
    on port `9300` with the server, and hence having the same version on the client
    and server is important.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a test file with our sample data (similar to `products.json`). The format
    is only slightly different from the previous case, but for Elasticsearch instead
    of MongoDB. The `products.json` file is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Use Postman or cURL to call a REST service on Elasticsearch to load the data.
    See the following screenshot for output in the Postman extension. In Elasticsearch,
    the equivalent of a database is an index, and we can name our index `product`.
    Elasticsearch also has a concept of type, but more on that later:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/223b6d21-d33a-439d-aa8f-268b9c4872f7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Check whether the data got loaded by running a simple `*` query in Postman,
    the browser, or cURL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: As a result, you should get the four products added.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the product-search service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With two databases done so far, you must be familiar with the drill by now.
    It is not very different from what we did for HSQLDB and MongoDB. Copy the Mongo
    project to create a `productsearch` service and make the changes as before to
    the Maven POM, entity, repository classes, and the application properties:'
  prefs: []
  type: TYPE_NORMAL
- en: In the Maven POM, `spring-boot-starter-data-elasticsearch` replaces `spring-boot-starter-data-mongodb`
    or `spring-boot-starter-data-jpa` in the earlier two service examples.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Product` entity, `@Document` now represents an Elasticsearch document.
    It should have an `index` and `type` defined the same since we used to load the
    test data as shown in the `Product.java` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ProductRepository` now extends `ElasticsearchRepository` as shown in the
    `ProductRepository.java` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Make changes in the `application.properties` to indicate a server model of `elasticsearch`
    (versus the embedded model, like we did for HSQLDB):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, start the Eureka server and then the `productsearch` service and fire
    the following queries in the browser, in the following order:'
  prefs: []
  type: TYPE_NORMAL
- en: '`http://localhost:8085/products?id=1`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`http://localhost:8085/products?id=2`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will get the same JSONs back as before. This is an internal implementation
    change of the microservice from the hard coded implementation in [Chapter 2](8a0a7cae-4aaa-460d-a760-59d0ffde9b48.xhtml), *Writing
    Your First Cloud-Native Application,* to HSQLDB, MongoDB, and now Elasticsearch.
  prefs: []
  type: TYPE_NORMAL
- en: 'Due to the Spring Data framework, the code to access the driver and communicate
    with it has been heavily abstracted from us, so all we need to do is add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Dependencies in the Maven POM file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Base class to extend from in the case of a repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Annotations to use for the entities.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Properties to configure in application properties.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Data update services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have looked at getting the data. Let's look at some of the data modification
    operations, such as creating, updating, and deleting (CRUD operations).
  prefs: []
  type: TYPE_NORMAL
- en: Given the popularity of REST for cloud-based API operations, we will do our
    data manipulation through REST methods.
  prefs: []
  type: TYPE_NORMAL
- en: Let's pick the HSQLDB example with Hazelcast that we worked on previously in
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: REST conventions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `GET` method was a no-brainer, but the choice of the methods for operations
    such as creating, inserting, and deleting require some deliberation. We will follow
    the conventions as per industry guidelines:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **URL** | **HTTP operation** | **Service method** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `/product/{id}` | `GET` | `getProduct` | Gets a product given an ID |'
  prefs: []
  type: TYPE_TB
- en: '| `/product` | `POST` | `insertProduct` | Inserts the product and returns a
    new ID |'
  prefs: []
  type: TYPE_TB
- en: '| `/product/{id}` | `PUT` | `updateProduct` | Updates a product for a given
    ID with the data in the request body |'
  prefs: []
  type: TYPE_TB
- en: '| `/product/{id}` | `DELETE` | `deleteProduct` | Deletes the product with a
    provided ID |'
  prefs: []
  type: TYPE_TB
- en: Let's look at the implementations in the `ProductService` class. We already
    had the `getProduct` implementation from earlier in the chapter. Let's add the
    other methods.
  prefs: []
  type: TYPE_NORMAL
- en: Inserting a product
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Leaving aside validations for a minute (which we will cover in a while), the
    insertion looks very simple to implementing the REST interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'We map the `POST` operation to the `insertProduct` method and in the implementation,
    we just call `save` on the repository that was already defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice a few differences from the `getProduct` method we coded earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: We have added a `POST` method in `@RequestMapping` so that the URL will map
    to the `insertProduct` method when HTTP `POST` is used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are capturing the `product` details from the `@RequestBody` annotation. This
    is expected to be supplied when inserting a new product. Spring does the job of
    mapping JSON (or XML) to the `Product` class for us.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are returning a `ResponseEntity` instead of just a `Product` object as we
    did in the `getProduct` method. This allows us to customize the HTTP responses
    and headers, which is important in REST architecture. For a successful insert,
    we are returning an HTTP `OK` (`200`) response, telling the client that his request
    to add a product was successful.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The steps to test our `insertProduct` method are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Start the Eureka server, then the `product` service (assuming it is listening
    on `8082`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that a browser will not suffice now, as we want to indicate the HTTP methods
    and provide a response body. Use Postman or cURL instead.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the content-type to application/json, since we will be submitting the new
    product information as a JSON.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Provide the production information in JSON format, such as `{"name":"Grapes","catId":1}`.
    Note we are not providing a product ID:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/26243ae4-d45a-4ae7-8006-12028ba5a606.png)'
  prefs: []
  type: TYPE_IMG
- en: Hit Send. You will get a response with the product JSON. This time, an ID will
    be populated. This is the ID generated by the repository (which in turn got it
    from the underlying database).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Updating a product
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here, instead of `POST`, we will use a `PUT` method indicating the ID of the
    product to be updated in the URL pattern. Like the `POST` method, the details
    of the product to be updated are provided in the `@RequestBody` annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The implementation involves:'
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving an existing product from the repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Making changes to it as per business logic.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Saving it back to the repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Returning the updated product (for client verification) with an `OK` status
    as before.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you hadn't noticed, the last two steps are exactly like the insert case.
    It is just the retrieval and update of the product that are the new steps.
  prefs: []
  type: TYPE_NORMAL
- en: Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The steps to test our `insertProduct` method are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: As we did for inserting a product, fire up Eureka and `ProductService` again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's change the product description of the first product to `Fuji Apples`.
    So, our JSON looks like `{"id":1,"name":"Fuji Apples","catId":1}`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Prepare Postman to submit the `PUT` request as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f2d1f8ef-960a-431f-803a-8c92e2f6f31f.png)'
  prefs: []
  type: TYPE_IMG
- en: Hit Send. You will get a response 200 OK with the body containing the JSON `{"id":1,"name":"Fuji
    Apples","catId":1}`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fire a `GET` request `http://localhost:8082/product/1` to check the change.
    You will find `apples` changed to `Fuji Apples`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Deleting a product
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The mapping and implementation for deleting a product looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We invoke the `delete` operation on the repository and return `OK` to the client,
    assuming everything is fine.
  prefs: []
  type: TYPE_NORMAL
- en: Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To test, fire a `DELETE` request through Postman on the product ID `1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/77d19943-8481-434f-8cdb-1c02cbcfa091.png)'
  prefs: []
  type: TYPE_IMG
- en: You will get a 200 OK response. To check whether it really got deleted, try
    a `GET` request on the same product. You will get an empty response.
  prefs: []
  type: TYPE_NORMAL
- en: Cache invalidation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you do a get operation that populates the cache, then either the cache updates,
    or invalidation has to take place when `PUT`/`POST`/`DELETE` operations occur
    that update the data.
  prefs: []
  type: TYPE_NORMAL
- en: If you recollect, we had a cache that held the products corresponding to a category
    ID. As we add and remove products using the APIs created for inserting, updating,
    and deleting, the cache needs to be refreshed. Our first preference is to check
    if we can update the cache entry. However, the business logic of pulling the categories
    corresponding to the cache is present in the database (through a `WHERE` clause).
    Hence, it is best to invalidate the cache containing the relations when a product
    update happens.
  prefs: []
  type: TYPE_NORMAL
- en: The general assumption for a caching use case is that the reads are much higher
    than inserts and updates.
  prefs: []
  type: TYPE_NORMAL
- en: 'To enable cache eviction, we have to add the methods in the `ProductRepository`
    class and provide an annotation. Hence, we add two new methods to the interface
    in addition to the existing `findByCatId` method, and mark eviction to be false:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Though the preceding code is a valid solution, it is not efficient. It clears
    the entire cache. Our cache could have 100s of categories and it is not right
    to clear the ones that are not related to the product being inserted, updated,
    or deleted.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could be a little more intelligent in only clearing the entries related
    to the category being operated upon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The code is a little cryptic because of the **Spring Expression Language**
    (**SpEL**), and the documentation of `CacheEvict`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`key` indicates what cache entry we want to clear.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`#result` indicates the return result. We extract the `catId` out of it and
    use it to clear the data.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`#p0` indicates the first parameter in the method called. This is the `product`
    object that we want to use the category from and then delete the object.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To test whether cache removal is working fine, start the service and Eureka,
    fire the following requests, and observe the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Request** | **Result** |'
  prefs: []
  type: TYPE_TB
- en: '| `http://localhost:8082/products?id=1` | Gets the product corresponding to
    category `1` and caches it. SQL will be displayed in the out log. |'
  prefs: []
  type: TYPE_TB
- en: '| `http://localhost:8082/products?id=1` | Gets the products from cache. No
    entry in the SQL updated. |'
  prefs: []
  type: TYPE_TB
- en: '| `POST` to `http://localhost:8082/product`Add `{"name":"Mango","catId":1}`
    as `application/json` | Adds the new Mango product to the database. |'
  prefs: []
  type: TYPE_TB
- en: '| `http://localhost:8082/products?id=1` | Reflects the newly added Mango. SQL
    indicates the data was refreshed. |'
  prefs: []
  type: TYPE_TB
- en: Validations and error messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have been treading in very safe territory and assuming happy paths.
    But not everything will be right all the time. There are many scenarios such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GET`, `PUT`, `DELETE` requests for products that don''t exist.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`PUT` and `POST` missing critical information, for example, no product name
    or category.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Business validations, such as products, should belong to known categories and
    names should be more than 10 characters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Incorrect formats of the data submitted, such as alphanumeric for category ID
    where only an integer was expected.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: And these are not exhaustive. Therefore, it is always important to do validations
    and return appropriate error codes and messages when things go wrong.
  prefs: []
  type: TYPE_NORMAL
- en: Format validations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If the request has errors in the format of the request body being submitted
    (for example, invalid JSON), then Spring throws an error before it reaches the
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, for a `POST` request to `http://localhost:8082/product`, if the
    submitted body is missing commas, such as `{"id":1 "name":"Fuji Apples" "catId":1}`,
    then the error returned is `400` as follows. This indicates it is a badly formed
    request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Likewise, a letter instead of a number, for example, in ID, will be caught
    early enough. For example, `http://localhost:8082/product/A` will result in a
    `Failed to convert value` error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/be5bdaae-67c1-4cd8-820c-797df80d1548.png)'
  prefs: []
  type: TYPE_IMG
- en: Data validations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A few errors can be caught at the entity level, if they are not allowed. For
    example, not providing a product description when we have annotated the `Product`
    entity as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This will cause the error message while trying to save the product supplied
    in the request without the name, for example, `{"id":1, "catId":1}`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The server returns a `500` internal server error and gives a detailed message
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This is not a very clean message to return to the client. Therefore, it is better
    to catch the validations upfront and return a `400` error code back to the client.
  prefs: []
  type: TYPE_NORMAL
- en: Business validations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This will typically be done in code, as it is specific to the functionality
    or business use case being addressed. For example, checking for a product before
    updating or deleting it. This is a simple code-based validation as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Exceptions and error messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In case of error, the simplest thing to begin with is to indicate an error message
    telling us what went wrong, especially in case of a bad input request or business
    validations since the client (or requestor) may have no idea of what went wrong.
    For example, in the preceding case, the `NOT_FOUND` status code is returned, But
    no other details are supplied.
  prefs: []
  type: TYPE_NORMAL
- en: Spring provides interesting notations such as `ExceptionHandler` and `ControllerAdvice`
    to handle this error. Let's see how this works.
  prefs: []
  type: TYPE_NORMAL
- en: 'Secondly, the service method earlier was directly manipulating the `ResponseEntity`
    by sending HTTP codes. We will revert it back to return business objects such
    as `Product` instead of `ResponseEntity`, making it more POJO-like. Revert back
    the `deleteProduct` code discussed earlier to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: We are returning `Product` instead of `ResponseEntity`, as handling error codes
    and responses will be done externally.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An exception is thrown (a runtime exception or its extended version) that tells
    us what was wrong in the request.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The scope of the `Product` method ends here.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `BadRequestException` class is a simple class that provides an ID and extends
    from the `RuntimeException` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'When you execute the service now, instead of just getting a `404 Not Found`
    status, we will get a proper message indicating what went wrong. See the screenshot
    of the request sent and the exception received:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/560efdc6-1e05-47da-ad36-c1a27415a0bf.png)'
  prefs: []
  type: TYPE_IMG
- en: However, sending `500` and getting an exception stack in the logs is not clean.
    `500` gives an indication that the error handling is not robust and stack traces
    are thrown around.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, we should capture and handle this error. Spring provides `@ExceptionHandler`
    that can be used in the service. This annotation on a method enables Spring to
    call the method to handle the error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'When we execute the service now, and call the `DELETE` method with a product
    ID that is not available, the error code becomes more specific and looks clean
    enough:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4990398e-de85-4c46-a6e4-6752e4549d3c.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, taking a step further, what if we want all our services to follow this
    pattern of raising a `BadRequestException` and returning the correct error codes?
    Spring provides a mechanism called `ControllerAdvice` which when used in a class,
    the exception handlers within the class can be applied universally to all services
    in the scope.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new class as follows and put it in the exception package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: This allows the exceptions to be handled across the services in a consistent
    way.
  prefs: []
  type: TYPE_NORMAL
- en: Data updates for CQRS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As discussed in the previous chapter, and we saw in action in the previous section,
    the CQRS pattern provides an efficient and fit for purpose data model for handling
    commands and queries separately. To recap, we had a flexible document model in
    MongoDB to handle the command pattern with transaction guarantees. We had a flexible
    query model in Elasticsearch to handle complex search conditions.
  prefs: []
  type: TYPE_NORMAL
- en: Though this pattern allows easier queries due to fit for purpose query models,
    the challenge comes in updating data across the various models. In the previous
    chapter, we discussed multiple mechanisms of keeping the information updated across
    the models, such as distributed transactions, and eventually consistent models
    using Publish-Subscribe messaging.
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, we will look at using messaging and the asynchronous
    mechanism of updating data.
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous messaging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: HTTP/REST provides for a request response mechanism to execute the service.
    The client waits (or rather, blocks) till the processing is complete and uses
    the result provided at the end of the service. Therefore, the processing is said
    to be synchronous.
  prefs: []
  type: TYPE_NORMAL
- en: In asynchronous processing, the client does not wait for the response. Asynchronous
    processing can be used in two scenarios, such as **fire-and-forget** and **request/response**.
  prefs: []
  type: TYPE_NORMAL
- en: In fire and forget, the client sends a command or request to the downstream
    service, and then does not require a response. It is used typically in pipeline
    processing architecture, where one service does enrichment and processing of the
    request and sends it to the other service, which sends to a third service, and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: In asynchronous request/response, the client sends a request to the service,
    but unlike synchronous processing, it does not wait or block for the response.
    When the service finishes processing, it has to notify the client so that the
    client can use the response.
  prefs: []
  type: TYPE_NORMAL
- en: In CQRS, we use messaging to send update events to the various services, so
    that the read or query models can be updated.
  prefs: []
  type: TYPE_NORMAL
- en: To begin with, we will use ActiveMQ as a reliable messaging mechanism in this
    chapter and then look at Kafka as a scalable distributed messaging system in the
    chapters ahead.
  prefs: []
  type: TYPE_NORMAL
- en: Starting ActiveMQ
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The steps to set up ActiveMQ are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Download ActiveMQ from the Apache website ([http://activemq.apache.org/](http://activemq.apache.org/)).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unzip it to a folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the `bin` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the `activemq start` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the console to see messages and manage ActiveMQ at `http://localhost:8161/admin`
    and log in with `admin/admin`. You should see the UI interface as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1cfc6980-39fc-4595-944b-cb0924b5375e.png)'
  prefs: []
  type: TYPE_IMG
- en: Creating a topic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Click on the Topics link and create a topic named `ProductT`. You can follow
    the naming convention you are used to. This topic will get all the updates for
    a product. These updates can be used for various downstream processing purposes,
    such as keeping the local data models up to date. Once you create a topic, it
    will appear in the list of topics on the admin console which is shown as follows.
    The other two topics are ActiveMQ''s own topics and we will leave them alone:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2a58660a-8356-411e-b92e-d158436391dd.png)'
  prefs: []
  type: TYPE_IMG
- en: Golden source update
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When there are multiple models in CQRS, we follow the golden source pattern,
    as discussed earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: One model (command model) is considered the golden source.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All validations are performed before updating to the golden source.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The update to the golden source happens in a transaction to avoid any inconsistent
    update and failure states. So, the update operation is automatic.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the update is complete, a broadcast message is put on a topic.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If there is an error in putting the message on topic, the transaction is rolled
    back and the client is sent an error.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We did a CQRS implementation using MongoDB and Elasticsearch. In our case, MongoDB
    is the golden source of the product data (also the command model). Elasticsearch
    is the query model that contains the data organized from a search perspective.
  prefs: []
  type: TYPE_NORMAL
- en: Let's first look at updating the command model or the golden source.
  prefs: []
  type: TYPE_NORMAL
- en: Service methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We did three methods in HSQLDB implementation: inserting, updating, and deleting.
    Copy the same methods to the MongoDB-based project, so that the service class
    in this project is exactly the same as that in the HSQLDB project.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, copy the exception class and `ControllerAdvice` that we did in the HSQLDB
    project. Your package structure should look identical to the HSQLDB project, which
    is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6f296550-226c-45be-add3-8137c49cb1f2.png)'
  prefs: []
  type: TYPE_IMG
- en: The difference in this project is that the ID is a string, as that supports
    better native handling in MongoDB for ID creation. Therefore, the method signatures
    will be string for ID instead of integer as in our HSQLDB project.
  prefs: []
  type: TYPE_NORMAL
- en: 'A `PUT` operation that updates the MongoDB is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Test whether the get, insert, update, and delete operations run as they should.
  prefs: []
  type: TYPE_NORMAL
- en: Raising an event on data updates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When an insert, delete, or update operation happens, it is important for the
    golden source system to broadcast the change, so that a lot of downstream actions
    can happen. This includes:'
  prefs: []
  type: TYPE_NORMAL
- en: Cache clearance by dependent systems.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update of the local data models in the system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Doing further business processing, for example, sending emails to interested
    customers on the addition of a new product.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using Spring JMSTemplate to send a message
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The steps to use JMSTemplate are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Include Spring starter for ActiveMQ in our POM file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'We have to enable JMS support for our Spring application. Therefore, include
    an annotation in the `ProductSpringApp.java` file as follows, and provide a message
    converter. The message converter will help convert objects to JSON and vice versa:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an entity that encapsulates the `Product` and the action, so that whoever
    gets the product message will also know if the action performed was delete or
    insert/update, by adding the entity in the `ProductUpdMsg.java` file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: If there are more actions, feel free to change the `isDelete` flag to a string
    action flag based on your use case.
  prefs: []
  type: TYPE_NORMAL
- en: 'Configure the JMS properties in the `application.properties` file. The `pub-sub-domain`
    indicates a topic should be used instead of a queue. Note that by default, the
    message is persistent:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a message producer component that will do the job of sending messages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is based on Spring's `JmsMessagingTemplate`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uses `JacksonJmsMessageConverter` to convert from object to message structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `ProductMsgProducer.java` file is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, in your service, declare the `producer` and invoke it after finishing
    the insert, update, and delete operations and before returning the response. The
    `DELETE` method is shown in the following, where the flag `isDelete` is true.
    The other methods will have the flag as false. The `ProductService.java` file
    is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: This will send the message on the topic, which you can see in the admin console
    under the topics section.
  prefs: []
  type: TYPE_NORMAL
- en: Query model update
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: On the `productsearch` project, we will have to make changes to update the records
    in Elasticsearch.
  prefs: []
  type: TYPE_NORMAL
- en: Insert, update, and delete methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These methods are very different from the ones we designed in MongoDB. Here
    are the differences:'
  prefs: []
  type: TYPE_NORMAL
- en: MongoDB methods had stringent validations. Validations are not required for
    Elasticsearch as the master (command model or golden source) is assumed to be
    updated and we have to apply the updates to the query model.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Any error in updating the query model has to be alerted, and should not go unnoticed.
    We will look at that aspect in the chapters ahead.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We do not separate the insert and update method. The single save method suffices
    for both purposes due to our `ProductRepository` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Also, these methods do not have to be exposed as REST HTTP services, as they
    might not be called directly other than through message updates. We do that here
    only for convenience.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `product-nosql` (MongoDB) project, we called our `ProductMsgProducer`
    class from the `ProductService` class. In this `productsearch-nosql` project,
    it will be the other way around, with the `ProductUpdListener` calling the service
    methods.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here are the changes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Maven POM—dependency on the ActiveMQ:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Application properties to include the topic and connection details:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '`Product` service to include calls to repository save and delete methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'JMS-related classes and changes as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: In `ProductSpringApp`, include annotation `EnableJms`, as done in the MongoDB
    project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a `ProductUpdListener` class that calls the service:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Testing the CQRS update scenario end to end
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To test our scenario, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start the three server processes on a local machine, such as Elasticsearch,
    MongoDB, and ActiveMQ, as discussed earlier.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start the Eureka server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start the two applications, one connecting to MongoDB (golden source, command
    model), listening on `8085` and the other connecting to Elasticsearch (query model),
    listening on `8086`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Test the `GET` request on Elasticsearch—`http://localhost:8086/products?id=1`,
    and note the IDs and descriptions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, change the product description on the golden source by issuing the following
    on your Postman, assuming the service is listening on port `8085`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b2aaaef2-606a-4c9f-a861-bf5f1e3325e0.png)'
  prefs: []
  type: TYPE_IMG
- en: Test the `GET` request on Elasticsearch again—`http://localhost:8086/products?id=1`.
    You will find the product description in Elasticsearch is updated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered a lot of core concepts, starting with adding a regular
    relational database to back our get requests. We enhanced its performance with
    a local cache and then a distributed cache, Hazelcast. We also looked at a CQRS
    pattern, replacing our relational databases with a MongoDB for flexible schema
    and Elasticsearch for flexible search and query capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: We added insert, update, and delete operations to our `product` service and
    ensured that the necessary cache invalidation happens in the case of the relational
    project. We added input validations and proper error messages to our APIs. We
    covered eventing to ensure that the query model stays up to date with the command
    model. This is achieved by command model services sending a broadcast of changes,
    and query model services listening to the changes and updating their data model.
  prefs: []
  type: TYPE_NORMAL
- en: Up next, we will look at how to make these projects robust enough to work in
    a runtime environment.
  prefs: []
  type: TYPE_NORMAL
