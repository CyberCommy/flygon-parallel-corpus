- en: Extending Your Cloud-Native Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展您的云原生应用
- en: Having understood the design principles, let's take the skeleton services developed
    in [Chapter 2](8a0a7cae-4aaa-460d-a760-59d0ffde9b48.xhtml), *Writing Your First
    Cloud-Native Application*, and do some real work on them to make them production-ready.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在理解了设计原则之后，让我们拿出在[第2章](8a0a7cae-4aaa-460d-a760-59d0ffde9b48.xhtml)中开发的骨架服务，*编写您的第一个云原生应用*，并对它们进行一些真正的工作，使它们能够投入生产。
- en: 'We defined two get services; `getProduct` for a given a product ID, and `getProducts`
    for a given category. These two services have highly non-functional requirements.
    They always have to be available and serve the data with the lowest possible latency.
    The following steps will take us there:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了两个获取服务；`getProduct`用于给定产品ID，`getProducts`用于给定类别。这两个服务具有高度的非功能性要求。它们必须始终可用，并以尽可能低的延迟提供数据。以下步骤将带领我们实现这一目标：
- en: '**Accessing data**: Service access to data across various resources'
  id: totrans-3
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问数据：服务访问跨各种资源的数据
- en: '**Caching**: Options to do caching and their considerations'
  id: totrans-4
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 缓存：进行缓存的选项及其考虑因素
- en: '**Applying CQRS**: Enable us to have different data models to service different
    requests'
  id: totrans-5
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用CQRS：使我们能够拥有不同的数据模型来服务不同的请求
- en: '**Error handling**: How to recover, what return codes to send, and implementation
    of patterns such as a circuit breaker'
  id: totrans-6
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 错误处理：如何恢复，发送什么返回代码，以及实现断路器等模式
- en: 'We will also look at adding methods to modify the data, such as `insert`, `update`,
    and `delete`. In this chapter, we will cover:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将研究添加修改数据的方法，例如`insert`，`update`和`delete`。在本章中，我们将涵盖：
- en: '**Validations**: Ensuring that the data is clean before being processed'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证：确保数据在处理之前是干净的
- en: '**Keeping two models of CQRS in sync**: For data consistency'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持两个CQRS模型同步：数据一致性
- en: '**Event driven and a****synchronous updates**: How it scales the architecture
    and decouples it at the same time'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件驱动和异步更新：它如何扩展架构并同时解耦
- en: Implementing the get services
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现获取服务
- en: Let's take our `product` project developed in [Chapter 2](8a0a7cae-4aaa-460d-a760-59d0ffde9b48.xhtml),
    *Writing Your First Cloud-Native Application*, forward. We will incrementally
    enhance it while discussing the concepts.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续开发在[第2章](8a0a7cae-4aaa-460d-a760-59d0ffde9b48.xhtml)中开发的`product`项目，*编写您的第一个云原生应用*。我们将在讨论概念的同时逐步增强它。
- en: 'Let''s think carefully about the database of our two services. `getProduct`
    returns the product information, while `getProducts` searches a list of products
    that fall into this category. To begin with, for simple and standard requirements,
    both queries can be answered by a single data model in a relational database:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们仔细考虑一下我们两个服务的数据库。`getProduct`返回产品信息，而`getProducts`搜索属于该类别的产品列表。首先，对于简单和标准的要求，这两个查询都可以由关系数据库中的单个数据模型回答：
- en: You would store a product in a product table with a fixed number of columns.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您将在一个固定数量的列中的产品表中存储产品。
- en: You would then index the category so that the queries against it can run quickly.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，您将对类别进行索引，以便对其进行的查询可以快速运行。
- en: Now, this design will be fine for most requirements for an average-sized company.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这个设计对于大多数中等规模公司的要求来说都是可以的。
- en: Simple product table
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单的产品表
- en: Let's use a product table in a standard relational database and access it in
    our service using Spring Data. Spring Data provides excellent abstractions to
    use the **Java Persistence API** (**JPA**) and makes coding **data access objects**
    (**DAO**) much easier. Spring Boot further helps in writing minimal code to begin
    with and extending it as we go ahead.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在标准关系数据库中使用产品表，并使用Spring Data在我们的服务中访问它。Spring Data提供了优秀的抽象，以使用**Java持久化API**（**JPA**），并使编写**数据访问对象**（**DAO**）变得更加容易。Spring
    Boot进一步帮助我们开始时编写最少的代码，并在前进时进行扩展。
- en: Spring Boot can work with embedded databases, such as H2, HSQLDB, or the external
    database. In-process embedded database starts with our Java service in a process
    and then terminates when the process dies. This is fine to begin with. Later on,
    the dependencies and URLs can be changed to point to actual databases.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot可以与嵌入式数据库一起工作，例如H2、HSQLDB或外部数据库。进程内嵌入式数据库在我们的Java服务中启动一个进程，然后在进程终止时终止。这对于开始是可以的。稍后，依赖项和URL可以更改为指向实际数据库。
- en: 'You can take the project from [Chapter 2](8a0a7cae-4aaa-460d-a760-59d0ffde9b48.xhtml),
    *Writing Your First Cloud-Native Application,* and add the following steps, or
    just download the completed code from GitHub ([https://github.com/PacktPublishing/Cloud-Native-Applications-in-Java](https://github.com/PacktPublishing/Cloud-Native-Applications-in-Java)):'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[第2章](8a0a7cae-4aaa-460d-a760-59d0ffde9b48.xhtml)中获取项目，*编写您的第一个云原生应用*，并添加以下步骤，或者只需从GitHub（[https://github.com/PacktPublishing/Cloud-Native-Applications-in-Java](https://github.com/PacktPublishing/Cloud-Native-Applications-in-Java)）下载已完成的代码：
- en: '**Maven POM**: Including POM dependencies:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Maven POM：包括POM依赖项：
- en: '![](img/eea764ef-0caa-4040-a8bb-c3268da21093.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eea764ef-0caa-4040-a8bb-c3268da21093.png)'
- en: This will tell Spring Boot to include the Spring Boot starter JPA and use HSQLDB
    in embedded mode.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这将告诉Spring Boot包含Spring Boot starter JPA并在嵌入模式下使用HSQLDB。
- en: '**Entity**: As per the JPA, we will start using the concept of entity. We already
    have a domain object named `Product` from our previous project. Refactor it to
    put in an entity package. Then, add the notations of `@Entity`, `@Id`, and `@Column`,
    as shown in the following `Product.java` file:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实体：根据JPA，我们将开始使用实体的概念。我们已经有一个名为`Product`的领域对象来自我们之前的项目。重构它以放入一个实体包中。然后，添加`@Entity`，`@Id`和`@Column`的标记，如下所示的`Product.java`文件：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The rest of the code, such as constructors and getters/setters, remains the
    same.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的代码，如构造函数和getter/setter，保持不变。
- en: '**Repository**: Spring Data provides a repository, which is like a DAO class
    and provides methods to do **Create**, **Read**, **Update**, and **Delete** (**CRUD**)
    operations on the data. A lot of standard operations are already provided in the
    `CrudRepository` interface. We will be using only the query operations from now
    on.'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**存储库**：Spring Data提供了一个存储库，类似于DAO类，并提供了执行数据的**创建**、**读取**、**更新**和**删除**（**CRUD**）操作的方法。`CrudRepository`接口中已经提供了许多标准操作。从现在开始，我们将只使用查询操作。'
- en: 'In our case, since our domain entity is `Product`, the repository will be `ProductRepository`,
    which extends Spring''s `CrudRepository`, and manages the `Product` entity. During
    extension, the entity and the data type of the primary key needs to be specified
    using generics, as shown in the following `ProductRepository.java` file:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，由于我们的领域实体是`Product`，所以存储库将是`ProductRepository`，它扩展了Spring的`CrudRepository`，并管理`Product`实体。在扩展期间，需要使用泛型指定实体和主键的数据类型，如下面的`ProductRepository.java`文件所示：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The first question that would come to mind is whether this code is sufficient
    enough to work. It has just one interface definition. How can it be enough to
    handle our two methods, namely `getProduct` (given a product ID) and `getProducts`
    (for a given category)?
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要考虑的问题是，这段代码是否足够工作。它只有一个接口定义。如何能足够处理我们的两个方法，即`getProduct`（根据产品ID）和`getProducts`（根据类别）？
- en: The magic happens in Spring Data, which helps with the boilerplate code. The
    `CrudRepository` interface comes with a set of default methods to implement the
    most common operations. These include `save`, `delete`, `find`, `count`, and `exists`
    operations which suffice for most of the query and update tasks. We will look
    at the `update` operations in the second half of this chapter, but let's focus
    on the query operations first.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Data中发生的魔术有助于处理样板代码。`CrudRepository`接口带有一组默认方法来实现最常见的操作。这些包括`save`、`delete`、`find`、`count`和`exists`操作，这些操作足以满足大部分查询和更新任务。我们将在本章的后半部分讨论`update`操作，但让我们先专注于查询操作。
- en: The operation of finding a product given an ID is already present in the `CrudRepository`
    as a `findOne` method. Hence, we do not need to call it explicitly.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 根据`CrudRepository`中的`findOne`方法，已经存在根据ID查找产品的操作。因此，我们不需要显式调用它。
- en: The task of finding products for a given category is done by the `findByCatId`
    method in our `ProductRepository` interface. The query builder mechanism built
    into the Spring Data repository infrastructure is useful for building queries
    over entities of the repository. The mechanism strips the prefixes, such as `find`,
    `read`, `query`, `count`, and `get` from the method and starts parsing the rest
    of it based on the entity. This mechanism is very powerful because the choice
    of keywords and the combinations means the method name is enough to do most of
    the query operations including operators (`and`/`or`) distinct clauses, and so
    on. Do refer to the Spring Data reference documentation ([https://docs.spring.io/spring-data/jpa/docs/current/reference/html/](https://docs.spring.io/spring-data/jpa/docs/current/reference/html/))
    to see the details.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`ProductRepository`接口中，根据给定类别查找产品的任务由`findByCatId`方法完成。Spring Data存储库基础设施内置的查询构建器机制对于构建存储库实体的查询非常有用。该机制会剥离方法的前缀，如`find`、`read`、`query`、`count`和`get`，然后根据实体解析剩余部分。该机制非常强大，因为关键字和组合的选择意味着方法名足以执行大部分查询操作，包括操作符（`and`/`or`）、distinct子句等。请参阅Spring
    Data参考文档（[https://docs.spring.io/spring-data/jpa/docs/current/reference/html/](https://docs.spring.io/spring-data/jpa/docs/current/reference/html/)）了解详细信息。
- en: These conventions allow Spring Data and Spring Boot to inject implementations
    of the methods based on parsing the interfaces.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这些约定允许Spring Data和Spring Boot根据解析接口来注入方法的实现。
- en: '**Changing the service**: In [Chapter 2](8a0a7cae-4aaa-460d-a760-59d0ffde9b48.xhtml),
    *Writing Your First Cloud-Native Application,* our `product` service was returning
    dummy hard-coded data. Let''s change it to something useful that goes against
    the database. We achieve this by using the `ProductRepository` interface that
    we defined earlier, and injecting it through `@Autowiring` annotation into our
    `ProductService` class, as shown in the following `ProductService.java` file:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**更改服务**：在[第2章](8a0a7cae-4aaa-460d-a760-59d0ffde9b48.xhtml)中，*编写您的第一个云原生应用程序*，我们的`product`服务返回了虚拟的硬编码数据。让我们将其更改为针对数据库的有用内容。我们通过使用之前定义的`ProductRepository`接口，并通过`@Autowiring`注入到我们的`ProductService`类中来实现这一点，如下面的`ProductService.java`文件所示：'
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `findOne` method from the repository gets the object given a primary key,
    and the `findByCatId` method we defined helps to find products given a category.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 存储库中的`findOne`方法根据主键获取对象，我们定义的`findByCatId`方法有助于根据类别查找产品。
- en: '**Schema definition**: For now, we will leave the schema creation to the `hibernate`
    capability to auto generate a script. Since we do want to see what script got
    created, let''s enable `logging` for the classes as follows in the `application.properties`
    file:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**模式定义**：目前，我们将模式创建留给`hibernate`自动生成脚本。由于我们确实想要看到生成的脚本，让我们在`application.properties`文件中启用对类的`logging`，如下所示：'
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '**Test data**: Since we are going to insert the products later, we need our
    database to be initialized with some products. Hence, add the following lines
    into `import.sql` and place it in resources (where the `application.properties`
    and bootstrap files reside):'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**测试数据**：由于我们将稍后插入产品，因此需要初始化数据库并添加一些产品。因此，请将以下行添加到`import.sql`中，并将其放在资源中（与`application.properties`和引导文件所在的位置）：'
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '**Leave Spring Data and Spring Boot to figure out the rest: **But in a production
    application, we would want to have fine-grained control over the connection URL,
    user ID, password, connection pool properties, and so on.'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**让Spring Data和Spring Boot来解决其余问题：**但在生产应用程序中，我们希望对连接URL、用户ID、密码、连接池属性等进行精细控制。'
- en: Running the service
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行服务
- en: 'To run our `product` service, perform the following steps:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行我们的`product`服务，请执行以下步骤：
- en: Fire up the Eureka server (as we did in [Chapter 2](8a0a7cae-4aaa-460d-a760-59d0ffde9b48.xhtml),
    *Writing Your First Cloud-Native Application*) using the `EurekaApplication` class.
    We are going to keep the Eureka service running at all times.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Eureka服务器（就像我们在[第2章](8a0a7cae-4aaa-460d-a760-59d0ffde9b48.xhtml)中所做的那样，*编写您的第一个云原生应用程序*），使用`EurekaApplication`类。我们将始终保持Eureka服务运行。
- en: Once the `Eureka` project starts, run the `product` service.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦“Eureka”项目启动，运行“product”服务。
- en: 'Notice the logs generated by `hibernate`. It first uses an HSQLDB dialect automatically, and
    then creates and runs the `Product` table SQL as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 注意由`hibernate`生成的日志。它首先自动使用HSQLDB方言，然后创建并运行以下`Product`表SQL：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Once the service starts to listen on a port, fire a query in your browser: `http://localhost:8082/product/1`.
    This will return the following:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦服务开始监听端口，请在浏览器中发出查询：`http://localhost:8082/product/1`。这将返回以下内容：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'When you see the logs, you will observe the SQL that ran in the background:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当您看到日志时，您会观察到后台运行的SQL：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, fire another query that returns products for a given category: `http://localhost:8082/products?id=1`.
    This will return the following:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，再次发出一个返回给定类别产品的查询：`http://localhost:8082/products?id=1`。这将返回以下内容：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The SQL that ran for this condition was as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 为此条件运行的SQL如下：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'And trying with a different category, `http://localhost:8082/products?id=2`,
    will return something as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用不同的类别，`http://localhost:8082/products?id=2`，将返回如下内容：
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This completes a simple query service going against a data source.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了一个针对数据源的简单查询服务。
- en: For production purposes, this will need enhancement to take a standard database
    as an Oracle, PostgreSQL, or MySQL database. You will introduce an index on the
    category column so that the queries run faster.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 为了生产目的，这将需要增强以将标准数据库作为Oracle、PostgreSQL或MySQL数据库。您将在类别列上引入索引，以便查询运行更快。
- en: Limitations of traditional databases
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传统数据库的局限性
- en: But what happens as the company expands its products and customers in the following
    scenarios?
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 但是在以下情况下，公司扩大产品和客户会发生什么？
- en: The scalability of a relational database (in terms of volume of products and
    number of concurrent requests) becomes a bottleneck.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关系数据库的可伸缩性（产品数量和并发请求数量）成为瓶颈。
- en: The product structure is different based on the category and is difficult to
    model in a fixed schema of a relational database.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 产品结构根据类别不同，在关系数据库的固定模式中很难建模。
- en: The search criteria starts increasing in scope. As of now, we are searching
    only by category; later on, we might want to search by product description, filter
    fields, and also by category description.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搜索条件开始扩大范围。目前，我们只按类别搜索；以后，我们可能希望按产品描述、过滤字段以及类别描述进行搜索。
- en: Will a single relational database suffice for all requirements?
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 单个关系数据库是否足以满足所有需求？
- en: Let's address the concerns with a few design techniques.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一些设计技术来解决这些问题。
- en: Caching
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存
- en: As the service scales in terms of the amount of data and concurrency of requests,
    the database will start becoming a bottleneck. In order to scale, we can adopt
    a caching solution that will reduce the number of hits to the database by servicing
    the requests from a cache if the value is available in the cache.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 随着服务在数据量和并发请求方面的扩展，数据库将开始成为瓶颈。为了扩展，我们可以采用缓存解决方案，通过从缓存中服务请求来减少对数据库的访问次数，如果值在缓存中可用的话。
- en: Spring provides mechanisms to include caching through annotations, so that Spring
    can return cached values instead of calling the actual processing or retrieval
    methods.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Spring提供了通过注解包含缓存的机制，以便Spring可以返回缓存值而不是调用实际处理或检索方法。
- en: Conceptually, caching comes in two types, as discussed in the following sections.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 从概念上讲，缓存分为两种类型，如下节所讨论的。
- en: Local cache
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本地缓存
- en: The local cache is present in the same JVM as that of the service. Its scope
    is limited as it can be accessed by the service instance and has to be entirely
    managed by the service instance.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 本地缓存存在于与服务相同的JVM中。它的范围是有限的，因为它只能被服务实例访问，并且必须完全由服务实例管理。
- en: Let's start by making our products cacheable in a local cache.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先使我们的产品在本地缓存中可缓存。
- en: Spring 3.1 introduced its own notations for returning cached entries, evicting,
    or populating entries. But later on, JSR 107 JCache introduced different notations.
    Spring 4.1 and higher supports these as well.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 3.1引入了自己的注释来返回缓存条目、清除或填充条目。但后来，JSR 107 JCache引入了不同的注释。Spring 4.1及更高版本也支持这些。
- en: 'Let''s use the Spring notations to begin with:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先使用Spring的注释：
- en: 'Tell the Spring application to enable caching and look for cacheable instances.
    This is a one-time declaration and hence is best done in the start-up class. Add
    the `@``EnableCaching` annotation into the main class:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 告诉Spring应用程序启用缓存并寻找可缓存的实例。这是一次性声明，因此最好在启动类中完成。在主类中添加`@``EnableCaching`注释：
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Enable the cache in our `ProductRepository` for getting products by category,
    by adding a cacheable notation. We will give a cache name that is explicit and
    will be used for this method:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的`ProductRepository`中启用缓存以通过添加可缓存注释获取产品，我们将提供一个明确的缓存名称，并将用于此方法：
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, run the service again and observe the logs when you run the following
    set of queries in your browser:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，再次运行服务，并观察当您在浏览器中运行以下一组查询时的日志：
- en: '`http://localhost:8082/products?id=1`'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`http://localhost:8082/products?id=1`'
- en: '`http://localhost:8082/products?id=2`'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`http://localhost:8082/products?id=2`'
- en: '`http://localhost:8082/products?id=1`'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`http://localhost:8082/products?id=1`'
- en: '`http://localhost:8082/products?id=2`'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`http://localhost:8082/products?id=2`'
- en: 'You will see that the following SQL has been fired only twice:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 您会看到以下SQL只被触发了两次：
- en: '[PRE13]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This means that the repository executed the `findByCatId` method only when it
    did not find a category entry in the cache.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着仓库只有在缓存中找不到类别条目时才执行了`findByCatId`方法。
- en: Under the hood
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 底层
- en: While it is nice that Spring handles a lot of concerns such as caching implementation
    under the hood, it is important to understand what is happening and be aware of
    the limitations.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Spring在幕后处理了许多关注点，如缓存实现，但重要的是要了解正在发生的事情，并意识到其中的局限性。
- en: Internally, caching is implemented by internal classes such as cache manager
    and cache resolver. When no caching product or framework is supplied, Spring uses
    `ConcurrentHashMap` by default. Spring's caching implements many other local caches
    such as EHCache, Guava, and Caffeine.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，缓存是通过内部类（如缓存管理器和缓存解析器）实现的。当没有提供缓存产品或框架时，Spring默认使用`ConcurrentHashMap`。Spring的缓存实现了许多其他本地缓存，如EHCache、Guava和Caffeine。
- en: Check out the Spring documentation ([https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/cache/annotation/Cacheable.html](https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/cache/annotation/Cacheable.html))
    for more intricacies such as `sync=true` and conditional caching.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 查看Spring文档（[https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/cache/annotation/Cacheable.html](https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/cache/annotation/Cacheable.html)）以获取更多诸如`sync=true`和条件缓存等复杂性。
- en: Limitations of a local cache
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本地缓存的局限性
- en: Local cache is useful in limited use cases (such as non-changing static data)
    as the updates done in one service using Spring annotations such as `@CachePut`,
    `@CacheEvict`, and so on cannot be synchronized with a cache on the other instance
    of services if we are running more than one instance of a service for load balancing
    or resiliency purposes.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 本地缓存在有限的用例中很有用（例如非更改静态数据），因为使用Spring注释（如`@CachePut`、`@CacheEvict`等）在一个服务中进行的更新无法与运行多个服务实例的其他实例上的缓存同步，以实现负载平衡或弹性目的。
- en: Distributed cache
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分布式缓存
- en: A distributed cache such as Hazelcast, Gemfire, and/or Coherence is network-aware
    and the cache instances operate either as an in-process model (peer-peer model),
    where the cache is part of the service runtime, or a client-server model, where
    the cache request goes from the service to separate dedicated cache instances.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Hazelcast、Gemfire和/或Coherence等分布式缓存是网络感知的，缓存实例作为进程模型（对等模型）运行，其中缓存是服务运行时的一部分，或者作为客户端-服务器模型运行，其中缓存请求从服务到单独的专用缓存实例。
- en: 'For this example, we have selected Hazelcast, as it is a very lightweight but
    powerful distributed caching solution. It also integrates very well with Spring
    Boot. Here is how:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此示例，我们选择了Hazelcast，因为它是一个非常轻量但功能强大的分布式缓存解决方案。它还与Spring Boot集成得非常好。以下是如何操作的：
- en: 'In the POM (Maven file), add a dependency to `hazelcast-spring`. The `hazelcast-spring`
    has a `HazelcastCacheManager` that configures a Hazelcast instance to be used:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在POM（Maven文件）中，添加对`hazelcast-spring`的依赖。`hazelcast-spring`具有一个`HazelcastCacheManager`，用于配置要使用的Hazelcast实例：
- en: '[PRE14]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Since Hazelcast is a distributed cache, it needs the elements to be serializable.
    Hence, we need to ensure that our `Product` entity is serializable:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于Hazelcast是一个分布式缓存，它需要元素是可序列化的。因此，我们需要确保我们的`Product`实体是可序列化的：
- en: '[PRE15]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'A simplified Hazelcast configuration file that tells the various Hazelcast
    instances to discover and synchronize with each other:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个简化的Hazelcast配置文件，告诉各种Hazelcast实例如何发现并与彼此同步：
- en: '[PRE16]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, let''s test these changes. For this, we have to run two instances of the
    `product` service to check if it works. We can run two instances by changing the
    port number:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们测试这些更改。为此，我们必须运行两个`product`服务的实例来检查它是否有效。我们可以通过更改端口号来运行两个实例：
- en: Run the service with port `8082` (which is configured).
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用端口`8082`（已配置）运行服务。
- en: Change the `application.properties` to `8083`.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`application.properties`更改为`8083`。
- en: Run the service again.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行服务。
- en: 'You will see Hazelcast messages on one service that starts as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在一个服务上看到Hazelcast消息，该服务启动如下：
- en: '[PRE17]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'But as soon as the second service is started, the member definitions get updated
    by `2`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，一旦第二个服务启动，成员定义就会被`2`更新：
- en: '[PRE18]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, on the browser, run the following queries and observe the logs in the
    console:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在浏览器上运行以下查询，并观察控制台中的日志：
- en: '`http://localhost:8082/products?id=1`'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`http://localhost:8082/products?id=1`'
- en: '`http://localhost:8082/products?id=2`'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`http://localhost:8082/products?id=2`'
- en: '`http://localhost:8082/products?id=1`'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`http://localhost:8082/products?id=1`'
- en: '`http://localhost:8082/products?id=2`'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`http://localhost:8082/products?id=2`'
- en: '`http://localhost:8083/products?id=1`'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`http://localhost:8083/products?id=1`'
- en: '`http://localhost:8083/products?id=2`'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`http://localhost:8083/products?id=2`'
- en: You will find that in the SQL, debug logs come only twice in the first service.
    The other four times, the cache entries are picked from Hazelcast. Unlike the
    previous local cache, the cache entries are synchronized between two instances.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 您会发现在SQL中，调试日志只在第一个服务中出现两次。其他四次，缓存条目都是从Hazelcast中提取的。与以前的本地缓存不同，缓存条目在两个实例之间是同步的。
- en: Applying CQRS to separate data models and services
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将CQRS应用于分离数据模型和服务
- en: A distributed cache is one way to solve the scaling problem. However, it introduces
    certain challenges, such as cache staleness (keeping the cache in sync with the
    database) and additional memory requirements.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式缓存是解决扩展问题的一种方法。但是，它引入了某些挑战，例如缓存陈旧（使缓存与数据库同步）和额外的内存需求。
- en: Also, caching is the beginning of the transition to the CQRS paradigm. Revisit
    the concepts of CQRS that we discussed in Chapter 3, *Designing Your Cloud-Native
    Application*.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，缓存是过渡到CQRS范例的开始。重新审视我们在第3章*设计您的云原生应用程序*中讨论的CQRS概念。
- en: The queries are answered from the cache (apart from the first hit), which is
    query segregation from the commands that go from the system of record (which is
    the database) and update the query model (cache update) later.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 查询是从缓存中回答的（除了第一次命中），这是查询与从记录系统（即数据库）传递的命令进行分离，并稍后更新查询模型（缓存更新）。
- en: 'Let''s take the next step in CQRS to do this segregation cleanly. The complexity
    that CQRS introduces is:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在CQRS中迈出下一步，以便清晰地进行这种分离。CQRS引入的复杂性是：
- en: Having two (or multiple) models to maintain instead of one
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要维护两个（或多个）模型，而不是一个
- en: Overheads of updating all models when the data changes
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consistency guarantees between the different models
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hence, this model should be followed only if the use case demands separation
    for high concurrency, high volume, and rapid agility requirements.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Materialized views on a relational database
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Materialized views are the simplest form of CQRS. If we assume that the updates
    to products happen less frequently as compared to the reads on the product and
    category, then we can have two different models supporting the `getProduct` (for
    an ID) and `getProducts` (for a given category).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: The search query `getProducts` goes against this view, while the traditional
    `getProduct` based on the primary key goes to the regular table.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: This should be pretty easy if supported by a database such as Oracle. If a database
    does not support a materialized view by default, it can be done manually if there
    is a need, by manually updating statistics or summary tables when the main product
    table is updated using triggers or better event-driven architecture, such as business
    events. We shall see this in the second half of this chapter, when we add `addProduct` functionality
    to our set of services.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: Elasticsearch and a document database
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To address limitations of flexible schema, high search ability, and higher
    volume handling, we can go for NoSQL technologies:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: For serving different types of products, we could choose to use a document database
    with its flexible schema, for example, MongoDB.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For serving search requests, Elasticsearch, a Lucene based technology, will
    be beneficial due to its powerful indexing capability.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why not use only a document database or Elasticsearch?
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is quite possible to think of these options as well:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: Elasticsearch is typically a complementary technology and not used as a master
    database. Hence, the product information should be maintained in a reliable, relational,
    or NoSQL database.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A document database such as MongoDB can build indexes too. However, the performance
    or indexing capability cannot equal Elasticsearch.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is a classic example for fit for purpose. Your choice will depend on your
    use case:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: Whether you have flexible schema needs
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scalable and high volume applications
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Highly flexible search requirements
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Core product service on a document database
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Keeping the REST interface the same, let's change the internal implementation
    from using a relational database (HSQLDB, in our example) to MongoDB. Instead
    of running MongoDB in a process such as HSQLDB, we will run it separately as a
    server.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: Getting MongoDB ready with test data
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The steps to download and install MongoDB are as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Install MongoDB. It is fairly easy to follow the instructions for various platforms
    on the MongoDB website ([https://www.mongodb.com/](https://www.mongodb.com/)).
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run `mongod.exe` to start an instance of MongoDB.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a test file with our sample data (similar to `import.sql`). This time,
    however, we will keep the data in JSON format instead of SQL statements. The `products.json`
    file is as follows:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note the `_id`, which is the primary key notation for MongoDB. If you do not
    provide an `_id`, MongoDB will auto generate that field with the `ObjectId` definition.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: 'Load the sample data into MongoDB. We will create a database called `masterdb`
    and load into a collection called `product`:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Check whether the data got loaded on the command line, by using the `db.product.find()`
    command, after `use masterdb` as follows:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/dc4d8193-a647-4c3a-b209-b18fe87c4f86.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
- en: Creating the product service
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The steps to create a `product` service are as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: It is better to start with a clean slate. Copy your project from the earlier
    example with Hazelcast and HSQLDB or pull from the GitHub repository ([https://github.com/PacktPublishing/Cloud-Native-Applications-in-Java](https://github.com/PacktPublishing/Cloud-Native-Applications-in-Java)).
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Adjust the Maven POM file to have the following dependencies. Remove the other
    ones since they are not required for our small example:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `Product` entity should just have an `@Id` field. It is optional to put
    a `@Document` annotation at the class level. If not, the first insert performance
    suffers. For now, let''s have the annotation in the `Product.java` file:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note that the `id` here is `String` instead of `int`. The reason for that is
    that NoSQL databases are much better at generating the ID as a string (GUID) compared
    to incrementing integers in relational systems such as databases. The reason for
    that is databases are getting more distributed, so generating incrementing numbers
    reliably is a little more difficult compared to generating GUIDs.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ProductRepository` now extends the `MongoRepository` which has methods
    for retrieving the product from MongoDB as follows in the `ProductRepository.java`
    file:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We just add one property to `application.properties` to tell the service to
    get our data from the `masterdb` database in MongoDB. Also, it is probably better
    to run it on a different port so that we can run the services in parallel if we
    want to do so later:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `ProductService` class does not change as there is no change in the interface.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, start the Eureka server, then the service, and fire the following queries
    in the browser:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '`http://localhost:8085/products?id=1`'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`http://localhost:8085/products?id=2`'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`http://localhost:8085/product/1`'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`http://localhost:8085/product/2`'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will get the same JSONs back as before. This is an internal implementation
    change of the microservice.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Splitting the services
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's go with a simple implementation of the suggested separation from a learning
    perspective. Since we are separating the master and search models, it makes sense
    to split the services, as the functionality of the search can be considered a
    downstream function to the **Product** master.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: The `getProducts` function for a category is part of the search functionality,
    which can become a complex and independent business area in itself. Hence, it
    is time to rethink whether it makes sense to keep them both in the same microservice
    or split them into core **Product** service and **Product Search** services.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ae3c783c-1df2-4e72-9162-7d4bb4cac904.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
- en: The product-search service
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's create a new microservice that specializes in high speed, high volume
    searches. The search data store backing the search microservice need not be a
    master of the product data, but can act as a complementary search model. Elasticsearch
    has been extremely popular for a variety of search use cases and fits the need
    for extreme search requirements.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: Getting Elasticsearch ready with test data
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are the steps to get Elasticsearch ready with test data:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: Install the Elastic version. Use version 2.4.3, since the recent 5.1 versions
    are not compatible with Spring Data. Spring Data uses Java drivers that communicate
    on port `9300` with the server, and hence having the same version on the client
    and server is important.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a test file with our sample data (similar to `products.json`). The format
    is only slightly different from the previous case, but for Elasticsearch instead
    of MongoDB. The `products.json` file is as follows:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Use Postman or cURL to call a REST service on Elasticsearch to load the data.
    See the following screenshot for output in the Postman extension. In Elasticsearch,
    the equivalent of a database is an index, and we can name our index `product`.
    Elasticsearch also has a concept of type, but more on that later:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/223b6d21-d33a-439d-aa8f-268b9c4872f7.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
- en: 'Check whether the data got loaded by running a simple `*` query in Postman,
    the browser, or cURL:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As a result, you should get the four products added.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Creating the product-search service
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With two databases done so far, you must be familiar with the drill by now.
    It is not very different from what we did for HSQLDB and MongoDB. Copy the Mongo
    project to create a `productsearch` service and make the changes as before to
    the Maven POM, entity, repository classes, and the application properties:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经完成了两个数据库，现在你一定对这个流程很熟悉了。这与我们为HSQLDB和MongoDB所做的并没有太大的不同。复制Mongo项目以创建`productsearch`服务，并像以前一样对Maven
    POM、实体、存储库类和应用程序属性进行更改：
- en: In the Maven POM, `spring-boot-starter-data-elasticsearch` replaces `spring-boot-starter-data-mongodb`
    or `spring-boot-starter-data-jpa` in the earlier two service examples.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Maven POM中，`spring-boot-starter-data-elasticsearch`取代了之前两个服务示例中的`spring-boot-starter-data-mongodb`或`spring-boot-starter-data-jpa`。
- en: 'In the `Product` entity, `@Document` now represents an Elasticsearch document.
    It should have an `index` and `type` defined the same since we used to load the
    test data as shown in the `Product.java` file:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Product`实体中，`@Document`现在表示一个Elasticsearch文档。它应该有一个定义相同的`index`和`type`，因为我们用来加载测试数据，如`Product.java`文件所示：
- en: '[PRE27]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `ProductRepository` now extends `ElasticsearchRepository` as shown in the
    `ProductRepository.java` file:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ProductRepository`现在扩展了`ElasticsearchRepository`，如`ProductRepository.java`文件所示：'
- en: '[PRE28]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Make changes in the `application.properties` to indicate a server model of `elasticsearch`
    (versus the embedded model, like we did for HSQLDB):'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`application.properties`中进行更改，指示`elasticsearch`的服务器模型（与嵌入式模型相对，就像我们为HSQLDB所做的那样）：
- en: '[PRE29]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, start the Eureka server and then the `productsearch` service and fire
    the following queries in the browser, in the following order:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，启动Eureka服务器，然后启动`productsearch`服务，并按照以下顺序在浏览器中发出以下查询：
- en: '`http://localhost:8085/products?id=1`.'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`http://localhost:8085/products?id=1`。'
- en: '`http://localhost:8085/products?id=2`.'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`http://localhost:8085/products?id=2`。'
- en: You will get the same JSONs back as before. This is an internal implementation
    change of the microservice from the hard coded implementation in [Chapter 2](8a0a7cae-4aaa-460d-a760-59d0ffde9b48.xhtml), *Writing
    Your First Cloud-Native Application,* to HSQLDB, MongoDB, and now Elasticsearch.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '你将得到与之前相同的JSON。这是微服务的内部实现变化，从[第2章](8a0a7cae-4aaa-460d-a760-59d0ffde9b48.xhtml)中的硬编码实现到HSQLDB、MongoDB，现在是Elasticsearch。 '
- en: 'Due to the Spring Data framework, the code to access the driver and communicate
    with it has been heavily abstracted from us, so all we need to do is add the following:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Spring Data框架，访问驱动程序并与其通信的代码已经被大大抽象化，所以我们只需要添加以下内容：
- en: Dependencies in the Maven POM file.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Maven POM文件中的依赖项。
- en: Base class to extend from in the case of a repository.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在存储库的情况下扩展的基类。
- en: Annotations to use for the entities.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于实体的注解。
- en: Properties to configure in application properties.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用程序属性中配置的属性。
- en: Data update services
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据更新服务
- en: So far, we have looked at getting the data. Let's look at some of the data modification
    operations, such as creating, updating, and deleting (CRUD operations).
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看过了获取数据。让我们看一些数据修改操作，比如创建、更新和删除（CRUD操作）。
- en: Given the popularity of REST for cloud-based API operations, we will do our
    data manipulation through REST methods.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于REST在基于云的API操作中的流行度，我们将通过REST方法进行数据操作。
- en: Let's pick the HSQLDB example with Hazelcast that we worked on previously in
    this chapter.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们选择在本章之前使用Hazelcast的HSQLDB示例。
- en: REST conventions
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: REST惯例
- en: 'The `GET` method was a no-brainer, but the choice of the methods for operations
    such as creating, inserting, and deleting require some deliberation. We will follow
    the conventions as per industry guidelines:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: GET方法是一个不用大脑思考的选择，但是对于创建、插入和删除等操作的方法的选择需要一些考虑。我们将遵循行业指南的惯例：
- en: '| **URL** | **HTTP operation** | **Service method** | **Description** |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| **URL** | **HTTP操作** | **服务方法** | **描述** |'
- en: '| `/product/{id}` | `GET` | `getProduct` | Gets a product given an ID |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| `/product/{id}` | `GET` | `getProduct` | 获取给定ID的产品 |'
- en: '| `/product` | `POST` | `insertProduct` | Inserts the product and returns a
    new ID |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| `/product` | `POST` | `insertProduct` | 插入产品并返回一个新的ID |'
- en: '| `/product/{id}` | `PUT` | `updateProduct` | Updates a product for a given
    ID with the data in the request body |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| `/product/{id}` | `PUT` | `updateProduct` | 使用请求体中的数据更新给定ID的产品 |'
- en: '| `/product/{id}` | `DELETE` | `deleteProduct` | Deletes the product with a
    provided ID |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| `/product/{id}` | `DELETE` | `deleteProduct` | 删除提供的ID的产品 |'
- en: Let's look at the implementations in the `ProductService` class. We already
    had the `getProduct` implementation from earlier in the chapter. Let's add the
    other methods.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`ProductService`类中的实现。我们已经在本章前面有了`getProduct`的实现。让我们添加其他方法。
- en: Inserting a product
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插入产品
- en: Leaving aside validations for a minute (which we will cover in a while), the
    insertion looks very simple to implementing the REST interface.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 暂且不考虑验证（我们一会儿会讨论），插入看起来非常简单，实现REST接口。
- en: 'We map the `POST` operation to the `insertProduct` method and in the implementation,
    we just call `save` on the repository that was already defined:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`POST`操作映射到`insertProduct`方法，在实现中，我们只需在已经定义的存储库上调用`save`：
- en: '[PRE30]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Notice a few differences from the `getProduct` method we coded earlier:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 注意一下我们之前编码的`getProduct`方法有一些不同之处：
- en: We have added a `POST` method in `@RequestMapping` so that the URL will map
    to the `insertProduct` method when HTTP `POST` is used.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在`@RequestMapping`中添加了一个`POST`方法，这样当使用HTTP `POST`时，URL将映射到`insertProduct`方法。
- en: We are capturing the `product` details from the `@RequestBody` annotation. This
    is expected to be supplied when inserting a new product. Spring does the job of
    mapping JSON (or XML) to the `Product` class for us.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们从`@RequestBody`注解中捕获`product`的详细信息。这在插入新产品时应该提供。Spring会为我们将JSON（或XML）映射到`Product`类。
- en: We are returning a `ResponseEntity` instead of just a `Product` object as we
    did in the `getProduct` method. This allows us to customize the HTTP responses
    and headers, which is important in REST architecture. For a successful insert,
    we are returning an HTTP `OK` (`200`) response, telling the client that his request
    to add a product was successful.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The steps to test our `insertProduct` method are as follows:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: Start the Eureka server, then the `product` service (assuming it is listening
    on `8082`).
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that a browser will not suffice now, as we want to indicate the HTTP methods
    and provide a response body. Use Postman or cURL instead.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the content-type to application/json, since we will be submitting the new
    product information as a JSON.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Provide the production information in JSON format, such as `{"name":"Grapes","catId":1}`.
    Note we are not providing a product ID:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/26243ae4-d45a-4ae7-8006-12028ba5a606.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
- en: Hit Send. You will get a response with the product JSON. This time, an ID will
    be populated. This is the ID generated by the repository (which in turn got it
    from the underlying database).
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Updating a product
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here, instead of `POST`, we will use a `PUT` method indicating the ID of the
    product to be updated in the URL pattern. Like the `POST` method, the details
    of the product to be updated are provided in the `@RequestBody` annotation:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The implementation involves:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving an existing product from the repository.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Making changes to it as per business logic.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Saving it back to the repository.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Returning the updated product (for client verification) with an `OK` status
    as before.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you hadn't noticed, the last two steps are exactly like the insert case.
    It is just the retrieval and update of the product that are the new steps.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: Testing
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The steps to test our `insertProduct` method are as follows:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: As we did for inserting a product, fire up Eureka and `ProductService` again.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's change the product description of the first product to `Fuji Apples`.
    So, our JSON looks like `{"id":1,"name":"Fuji Apples","catId":1}`.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Prepare Postman to submit the `PUT` request as follows:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f2d1f8ef-960a-431f-803a-8c92e2f6f31f.png)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
- en: Hit Send. You will get a response 200 OK with the body containing the JSON `{"id":1,"name":"Fuji
    Apples","catId":1}`.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fire a `GET` request `http://localhost:8082/product/1` to check the change.
    You will find `apples` changed to `Fuji Apples`.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Deleting a product
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The mapping and implementation for deleting a product looks as follows:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We invoke the `delete` operation on the repository and return `OK` to the client,
    assuming everything is fine.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: Testing
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To test, fire a `DELETE` request through Postman on the product ID `1`:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/77d19943-8481-434f-8cdb-1c02cbcfa091.png)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
- en: You will get a 200 OK response. To check whether it really got deleted, try
    a `GET` request on the same product. You will get an empty response.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: Cache invalidation
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you do a get operation that populates the cache, then either the cache updates,
    or invalidation has to take place when `PUT`/`POST`/`DELETE` operations occur
    that update the data.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: If you recollect, we had a cache that held the products corresponding to a category
    ID. As we add and remove products using the APIs created for inserting, updating,
    and deleting, the cache needs to be refreshed. Our first preference is to check
    if we can update the cache entry. However, the business logic of pulling the categories
    corresponding to the cache is present in the database (through a `WHERE` clause).
    Hence, it is best to invalidate the cache containing the relations when a product
    update happens.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: The general assumption for a caching use case is that the reads are much higher
    than inserts and updates.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: 'To enable cache eviction, we have to add the methods in the `ProductRepository`
    class and provide an annotation. Hence, we add two new methods to the interface
    in addition to the existing `findByCatId` method, and mark eviction to be false:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Though the preceding code is a valid solution, it is not efficient. It clears
    the entire cache. Our cache could have 100s of categories and it is not right
    to clear the ones that are not related to the product being inserted, updated,
    or deleted.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: 'We could be a little more intelligent in only clearing the entries related
    to the category being operated upon:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The code is a little cryptic because of the **Spring Expression Language**
    (**SpEL**), and the documentation of `CacheEvict`:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '`key` indicates what cache entry we want to clear.'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`#result` indicates the return result. We extract the `catId` out of it and
    use it to clear the data.'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`#p0` indicates the first parameter in the method called. This is the `product`
    object that we want to use the category from and then delete the object.'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To test whether cache removal is working fine, start the service and Eureka,
    fire the following requests, and observe the results:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '| **Request** | **Result** |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
- en: '| `http://localhost:8082/products?id=1` | Gets the product corresponding to
    category `1` and caches it. SQL will be displayed in the out log. |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
- en: '| `http://localhost:8082/products?id=1` | Gets the products from cache. No
    entry in the SQL updated. |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
- en: '| `POST` to `http://localhost:8082/product`Add `{"name":"Mango","catId":1}`
    as `application/json` | Adds the new Mango product to the database. |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
- en: '| `http://localhost:8082/products?id=1` | Reflects the newly added Mango. SQL
    indicates the data was refreshed. |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
- en: Validations and error messages
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have been treading in very safe territory and assuming happy paths.
    But not everything will be right all the time. There are many scenarios such as:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '`GET`, `PUT`, `DELETE` requests for products that don''t exist.'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`PUT` and `POST` missing critical information, for example, no product name
    or category.'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Business validations, such as products, should belong to known categories and
    names should be more than 10 characters.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Incorrect formats of the data submitted, such as alphanumeric for category ID
    where only an integer was expected.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: And these are not exhaustive. Therefore, it is always important to do validations
    and return appropriate error codes and messages when things go wrong.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: Format validations
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If the request has errors in the format of the request body being submitted
    (for example, invalid JSON), then Spring throws an error before it reaches the
    method.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, for a `POST` request to `http://localhost:8082/product`, if the
    submitted body is missing commas, such as `{"id":1 "name":"Fuji Apples" "catId":1}`,
    then the error returned is `400` as follows. This indicates it is a badly formed
    request:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Likewise, a letter instead of a number, for example, in ID, will be caught
    early enough. For example, `http://localhost:8082/product/A` will result in a
    `Failed to convert value` error:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/be5bdaae-67c1-4cd8-820c-797df80d1548.png)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
- en: Data validations
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A few errors can be caught at the entity level, if they are not allowed. For
    example, not providing a product description when we have annotated the `Product`
    entity as follows:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This will cause the error message while trying to save the product supplied
    in the request without the name, for example, `{"id":1, "catId":1}`.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: 'The server returns a `500` internal server error and gives a detailed message
    as follows:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This is not a very clean message to return to the client. Therefore, it is better
    to catch the validations upfront and return a `400` error code back to the client.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: Business validations
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This will typically be done in code, as it is specific to the functionality
    or business use case being addressed. For example, checking for a product before
    updating or deleting it. This is a simple code-based validation as follows:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Exceptions and error messages
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In case of error, the simplest thing to begin with is to indicate an error message
    telling us what went wrong, especially in case of a bad input request or business
    validations since the client (or requestor) may have no idea of what went wrong.
    For example, in the preceding case, the `NOT_FOUND` status code is returned, But
    no other details are supplied.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: Spring provides interesting notations such as `ExceptionHandler` and `ControllerAdvice`
    to handle this error. Let's see how this works.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: 'Secondly, the service method earlier was directly manipulating the `ResponseEntity`
    by sending HTTP codes. We will revert it back to return business objects such
    as `Product` instead of `ResponseEntity`, making it more POJO-like. Revert back
    the `deleteProduct` code discussed earlier to the following:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In the preceding code:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: We are returning `Product` instead of `ResponseEntity`, as handling error codes
    and responses will be done externally.
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An exception is thrown (a runtime exception or its extended version) that tells
    us what was wrong in the request.
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The scope of the `Product` method ends here.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `BadRequestException` class is a simple class that provides an ID and extends
    from the `RuntimeException` class:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'When you execute the service now, instead of just getting a `404 Not Found`
    status, we will get a proper message indicating what went wrong. See the screenshot
    of the request sent and the exception received:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/560efdc6-1e05-47da-ad36-c1a27415a0bf.png)'
  id: totrans-318
  prefs: []
  type: TYPE_IMG
- en: However, sending `500` and getting an exception stack in the logs is not clean.
    `500` gives an indication that the error handling is not robust and stack traces
    are thrown around.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, we should capture and handle this error. Spring provides `@ExceptionHandler`
    that can be used in the service. This annotation on a method enables Spring to
    call the method to handle the error:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'When we execute the service now, and call the `DELETE` method with a product
    ID that is not available, the error code becomes more specific and looks clean
    enough:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4990398e-de85-4c46-a6e4-6752e4549d3c.png)'
  id: totrans-323
  prefs: []
  type: TYPE_IMG
- en: Now, taking a step further, what if we want all our services to follow this
    pattern of raising a `BadRequestException` and returning the correct error codes?
    Spring provides a mechanism called `ControllerAdvice` which when used in a class,
    the exception handlers within the class can be applied universally to all services
    in the scope.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new class as follows and put it in the exception package:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This allows the exceptions to be handled across the services in a consistent
    way.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: Data updates for CQRS
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As discussed in the previous chapter, and we saw in action in the previous section,
    the CQRS pattern provides an efficient and fit for purpose data model for handling
    commands and queries separately. To recap, we had a flexible document model in
    MongoDB to handle the command pattern with transaction guarantees. We had a flexible
    query model in Elasticsearch to handle complex search conditions.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: Though this pattern allows easier queries due to fit for purpose query models,
    the challenge comes in updating data across the various models. In the previous
    chapter, we discussed multiple mechanisms of keeping the information updated across
    the models, such as distributed transactions, and eventually consistent models
    using Publish-Subscribe messaging.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, we will look at using messaging and the asynchronous
    mechanism of updating data.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous messaging
  id: totrans-332
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: HTTP/REST provides for a request response mechanism to execute the service.
    The client waits (or rather, blocks) till the processing is complete and uses
    the result provided at the end of the service. Therefore, the processing is said
    to be synchronous.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: In asynchronous processing, the client does not wait for the response. Asynchronous
    processing can be used in two scenarios, such as **fire-and-forget** and **request/response**.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: In fire and forget, the client sends a command or request to the downstream
    service, and then does not require a response. It is used typically in pipeline
    processing architecture, where one service does enrichment and processing of the
    request and sends it to the other service, which sends to a third service, and
    so on.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: In asynchronous request/response, the client sends a request to the service,
    but unlike synchronous processing, it does not wait or block for the response.
    When the service finishes processing, it has to notify the client so that the
    client can use the response.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: In CQRS, we use messaging to send update events to the various services, so
    that the read or query models can be updated.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: To begin with, we will use ActiveMQ as a reliable messaging mechanism in this
    chapter and then look at Kafka as a scalable distributed messaging system in the
    chapters ahead.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: Starting ActiveMQ
  id: totrans-339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The steps to set up ActiveMQ are as follows:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: Download ActiveMQ from the Apache website ([http://activemq.apache.org/](http://activemq.apache.org/)).
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unzip it to a folder.
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the `bin` folder.
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the `activemq start` command.
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the console to see messages and manage ActiveMQ at `http://localhost:8161/admin`
    and log in with `admin/admin`. You should see the UI interface as follows:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1cfc6980-39fc-4595-944b-cb0924b5375e.png)'
  id: totrans-346
  prefs: []
  type: TYPE_IMG
- en: Creating a topic
  id: totrans-347
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Click on the Topics link and create a topic named `ProductT`. You can follow
    the naming convention you are used to. This topic will get all the updates for
    a product. These updates can be used for various downstream processing purposes,
    such as keeping the local data models up to date. Once you create a topic, it
    will appear in the list of topics on the admin console which is shown as follows.
    The other two topics are ActiveMQ''s own topics and we will leave them alone:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2a58660a-8356-411e-b92e-d158436391dd.png)'
  id: totrans-349
  prefs: []
  type: TYPE_IMG
- en: Golden source update
  id: totrans-350
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When there are multiple models in CQRS, we follow the golden source pattern,
    as discussed earlier:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: One model (command model) is considered the golden source.
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All validations are performed before updating to the golden source.
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The update to the golden source happens in a transaction to avoid any inconsistent
    update and failure states. So, the update operation is automatic.
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the update is complete, a broadcast message is put on a topic.
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If there is an error in putting the message on topic, the transaction is rolled
    back and the client is sent an error.
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We did a CQRS implementation using MongoDB and Elasticsearch. In our case, MongoDB
    is the golden source of the product data (also the command model). Elasticsearch
    is the query model that contains the data organized from a search perspective.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: Let's first look at updating the command model or the golden source.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: Service methods
  id: totrans-359
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We did three methods in HSQLDB implementation: inserting, updating, and deleting.
    Copy the same methods to the MongoDB-based project, so that the service class
    in this project is exactly the same as that in the HSQLDB project.'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, copy the exception class and `ControllerAdvice` that we did in the HSQLDB
    project. Your package structure should look identical to the HSQLDB project, which
    is shown as follows:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6f296550-226c-45be-add3-8137c49cb1f2.png)'
  id: totrans-362
  prefs: []
  type: TYPE_IMG
- en: The difference in this project is that the ID is a string, as that supports
    better native handling in MongoDB for ID creation. Therefore, the method signatures
    will be string for ID instead of integer as in our HSQLDB project.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: 'A `PUT` operation that updates the MongoDB is shown as follows:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Test whether the get, insert, update, and delete operations run as they should.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: Raising an event on data updates
  id: totrans-367
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When an insert, delete, or update operation happens, it is important for the
    golden source system to broadcast the change, so that a lot of downstream actions
    can happen. This includes:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: Cache clearance by dependent systems.
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update of the local data models in the system.
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Doing further business processing, for example, sending emails to interested
    customers on the addition of a new product.
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using Spring JMSTemplate to send a message
  id: totrans-372
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The steps to use JMSTemplate are as follows:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: 'Include Spring starter for ActiveMQ in our POM file:'
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We have to enable JMS support for our Spring application. Therefore, include
    an annotation in the `ProductSpringApp.java` file as follows, and provide a message
    converter. The message converter will help convert objects to JSON and vice versa:'
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Create an entity that encapsulates the `Product` and the action, so that whoever
    gets the product message will also know if the action performed was delete or
    insert/update, by adding the entity in the `ProductUpdMsg.java` file as follows:'
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: If there are more actions, feel free to change the `isDelete` flag to a string
    action flag based on your use case.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: 'Configure the JMS properties in the `application.properties` file. The `pub-sub-domain`
    indicates a topic should be used instead of a queue. Note that by default, the
    message is persistent:'
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Create a message producer component that will do the job of sending messages:'
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is based on Spring's `JmsMessagingTemplate`
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uses `JacksonJmsMessageConverter` to convert from object to message structure
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `ProductMsgProducer.java` file is as follows:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Finally, in your service, declare the `producer` and invoke it after finishing
    the insert, update, and delete operations and before returning the response. The
    `DELETE` method is shown in the following, where the flag `isDelete` is true.
    The other methods will have the flag as false. The `ProductService.java` file
    is as follows:'
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This will send the message on the topic, which you can see in the admin console
    under the topics section.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: Query model update
  id: totrans-391
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: On the `productsearch` project, we will have to make changes to update the records
    in Elasticsearch.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: Insert, update, and delete methods
  id: totrans-393
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These methods are very different from the ones we designed in MongoDB. Here
    are the differences:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: MongoDB methods had stringent validations. Validations are not required for
    Elasticsearch as the master (command model or golden source) is assumed to be
    updated and we have to apply the updates to the query model.
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Any error in updating the query model has to be alerted, and should not go unnoticed.
    We will look at that aspect in the chapters ahead.
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We do not separate the insert and update method. The single save method suffices
    for both purposes due to our `ProductRepository` class.
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Also, these methods do not have to be exposed as REST HTTP services, as they
    might not be called directly other than through message updates. We do that here
    only for convenience.
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `product-nosql` (MongoDB) project, we called our `ProductMsgProducer`
    class from the `ProductService` class. In this `productsearch-nosql` project,
    it will be the other way around, with the `ProductUpdListener` calling the service
    methods.
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here are the changes:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: 'Maven POM—dependency on the ActiveMQ:'
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Application properties to include the topic and connection details:'
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '`Product` service to include calls to repository save and delete methods:'
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'JMS-related classes and changes as follows:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: In `ProductSpringApp`, include annotation `EnableJms`, as done in the MongoDB
    project.
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a `ProductUpdListener` class that calls the service:'
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Testing the CQRS update scenario end to end
  id: totrans-411
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To test our scenario, perform the following steps:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: Start the three server processes on a local machine, such as Elasticsearch,
    MongoDB, and ActiveMQ, as discussed earlier.
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start the Eureka server.
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start the two applications, one connecting to MongoDB (golden source, command
    model), listening on `8085` and the other connecting to Elasticsearch (query model),
    listening on `8086`.
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Test the `GET` request on Elasticsearch—`http://localhost:8086/products?id=1`,
    and note the IDs and descriptions.
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, change the product description on the golden source by issuing the following
    on your Postman, assuming the service is listening on port `8085`:'
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b2aaaef2-606a-4c9f-a861-bf5f1e3325e0.png)'
  id: totrans-418
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b2aaaef2-606a-4c9f-a861-bf5f1e3325e0.png)'
- en: Test the `GET` request on Elasticsearch again—`http://localhost:8086/products?id=1`.
    You will find the product description in Elasticsearch is updated.
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次在Elasticsearch上测试`GET`请求——`http://localhost:8086/products?id=1`。您会发现Elasticsearch中的产品描述已更新。
- en: Summary
  id: totrans-420
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered a lot of core concepts, starting with adding a regular
    relational database to back our get requests. We enhanced its performance with
    a local cache and then a distributed cache, Hazelcast. We also looked at a CQRS
    pattern, replacing our relational databases with a MongoDB for flexible schema
    and Elasticsearch for flexible search and query capabilities.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了许多核心概念，从添加常规关系数据库来支持我们的GET请求开始。我们通过本地缓存和分布式缓存Hazelcast增强了其性能。我们还研究了CQRS模式，用MongoDB替换了我们的关系数据库，以实现灵活的模式和Elasticsearch的灵活搜索和查询功能。
- en: We added insert, update, and delete operations to our `product` service and
    ensured that the necessary cache invalidation happens in the case of the relational
    project. We added input validations and proper error messages to our APIs. We
    covered eventing to ensure that the query model stays up to date with the command
    model. This is achieved by command model services sending a broadcast of changes,
    and query model services listening to the changes and updating their data model.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为我们的`product`服务添加了插入、更新和删除操作，并确保在关系项目的情况下进行必要的缓存失效。我们为我们的API添加了输入验证和适当的错误消息。我们涵盖了事件处理，以确保查询模型与命令模型保持最新。这是通过命令模型服务发送更改的广播，以及查询模型服务监听更改并更新其数据模型来实现的。
- en: Up next, we will look at how to make these projects robust enough to work in
    a runtime environment.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看看如何使这些项目足够健壮，以在运行时环境中运行。
