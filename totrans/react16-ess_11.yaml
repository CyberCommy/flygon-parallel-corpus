- en: Chapter 11. Preparing Your React Application for Painless Maintenance with Flux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The reason why we decided to implement the Flux architecture in our React application
    is that we want to have a data flow that is easier to maintain. In the previous
    chapter, we implemented `AppDispatcher`, `TweetActionCreators`, and `TweetStore`.
    Let’s quickly remember what they are used for:'
  prefs: []
  type: TYPE_NORMAL
- en: '`TweetActionCreators`: This creates and dispatches the actions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AppDispatcher`: This dispatches all the actions to all stores'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TweetStore`: This stores and manages the application data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The only missing parts in our data flow are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Using `TweetActionCreators` to create the actions and start the data flowing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `TweetStore` to get data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are a couple of important questions to ask: where in our application does
    the data flow start? What is our data? If we answer these questions, we will understand
    where to start refactoring our application to adapt the Flux architecture.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Snapterest allows users to receive and collect the latest tweets. The only
    data that our application is concerned with is tweets. So our data flow begins
    with receiving new tweets. What part of our application is responsible for receiving
    new tweets at the moment? You might remember that our `Stream` component has the
    following `componentDidMount()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Yes, currently, we initiate a stream of new tweets after we render the `Stream`
    component. Wait, you might ask, "Didn’t we learn that React components should
    only be concerned with rendering the user interface?" You’re correct. Unfortunately,
    at the moment, the `Stream` component is responsible for two different things:'
  prefs: []
  type: TYPE_NORMAL
- en: Rendering the `StreamTweet` component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initiating the data flow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clearly, it’s a potential maintenance issue in the future. Let’s decouple these
    two different concerns with the help of Flux.
  prefs: []
  type: TYPE_NORMAL
- en: Decoupling concerns with Flux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we’ll create a new utility module called `WebAPIUtils`. Create the `WebAPIUtils.js`
    file in the `~/snapterest/source/utils/` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In this utility module, we first import the `SnapkiteStreamClient` library
    and `TweetActionCreators`. Then, we create the `initializeStreamOfTweets()` function
    that initializes a stream of new tweets, just like in the `componentDidMount()`
    method of the `Stream` component. Except with one key difference: whenever `SnapkiteStreamClient`
    receives a new tweet, it calls the `TweetActionCreators.receiveTweet` method that
    passes a new tweet to it as an argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember that the `receiveTweet` function expects to receive a `tweet` argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This tweet will then be dispatched as a property of a new action object that
    the `receiveTweet()` function creates.
  prefs: []
  type: TYPE_NORMAL
- en: Then, the `WebAPIUtils` module exports our `initializeStreamOfTweets()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we have a module with a method that initiates the data flow in our Flux
    architecture. Where should we import and call it? Since it’s decoupled from the
    `Stream` component, and in fact, it doesn’t depend on any React component at all,
    we can use it even before React renders anything. Let’s use it in our `app.js`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, all that we need to do is to import and call the `initializeStreamOfTweets()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We do this before calling React’s `render()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In fact, as an experiment, you can remove the `ReactDOM.render()` line of code
    altogether, and put a log statement in the `TweetActionCreators.receiveTweet`
    function. For example, run the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now run the `npm start` command. Then, open `~/snapterest/build/index.html`
    in a web browser—you’ll see the following text rendered on the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '**I am about to learn the essentials of React.js.**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now open JavaScript Console and you’ll see this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This log message will be printed out for each new tweet that our application
    receives. Even though we didn’t render any React component, our Flux architecture
    is still there:'
  prefs: []
  type: TYPE_NORMAL
- en: Our application receives a new tweet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It creates and dispatches a new action.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: No stores have registered with the dispatcher, so there is no one to receive
    the new action; hence, nothing is happening.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now you can clearly see how React and Flux are two separate things that don’t
    depend on each other at all.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, we do want to render our React components. After all, we’ve put so
    much effort into creating them in the previous ten chapters! To do this, we need
    to put our `TweetStore` store into action. Can you guess where we should use it?
    Here’s a hint: in a React component that needs a tweet to render itself—our good
    old `Stream` component.'
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring the Stream component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now with the Flux architecture in place, we will rethink how our React components
    get data that they need to render. As you know, there are usually two sources
    of data for a React component:'
  prefs: []
  type: TYPE_NORMAL
- en: Calling another library, for example, calling the `jQuery.ajax()` method, or
    in our case, `SnapkiteStreamClient.initializeStream()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Receiving data from a parent React component via the `props` object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We want our React components to not use any external libraries to receive data.
    Instead, from now on, they will get that same data from stores. Keeping this plan
    in mind, let’s refactor our `Stream` component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how it looks now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'First, let’s get rid of the `componentDidMount()`, `componentWillUnmount()`,
    and `handleNewTweet()` methods and import the `TweetStore` store:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: There is also no need to import the `snapkite-stream-client` module anymore.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to change how the `Stream` component gets its initial tweet.
    Let’s update its initial state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Code-wise, this might look like a small change, but it’s a significant architectural
    improvement. We are now using the `getTweet()` method to get data from the `TweetStore`
    store. In the previous chapter, we discussed how stores expose the public methods
    in Flux in order to allow other parts of our application to get data from them.
    The `getTweet()` method is an example of one of these public methods, which are
    called *getters*.
  prefs: []
  type: TYPE_NORMAL
- en: You can get data from a store, but you can’t set data on a store directly just
    like that. Stores have no public *setter* methods. They are purposely designed
    with this limitation in mind so that when you write your application with Flux,
    your data can only flow in one direction. This will benefit you hugely down the
    road when you’ll need to maintain your Flux application.
  prefs: []
  type: TYPE_NORMAL
- en: Now we know how to get our initial tweet, but how do we get all the other new
    tweets that will arrive later? We can create a timer and call `TweetStore.getTweet()`
    repeatedly; however, this is not the best solution because it assumes that we
    don’t know when `TweetStore` updates its tweet with a new one. However, we do
    know that.
  prefs: []
  type: TYPE_NORMAL
- en: 'How? Remember that in the previous chapter, we implemented the following public
    methods on the `TweetStore` object, that is, the `addChangeListener()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We implemented the `removeChangeListener()` method as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: That’s right. We can ask `TweetStore` to tell us when it changes its data. For
    this, we need to call its `addChangeListener()` method and pass it a callback
    function that `TweetStore` will call for each new tweet. The question is that
    in our `Stream` component, where do we call the `TweetStore.addChangeListener()`
    method?
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we need to add the `change` event listener to `TweetStore` only once
    per component’s lifecycle, it makes `componentDidMount()` a perfect candidate.
    Add the following `componentDidMount()` method to the `Stream` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Here, we add our own `change` event listener, `this.onTweetChange`, to `TweetStore`.
    Now when `TweetStore` changes its data, it will trigger our `this.onTweetChange`
    method. We will create this method shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Don’t forget that we need to remove any event listeners before we unmount our
    React component. To do this, add the following `componentWillUnmount()` method
    to the `Stream` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Removing an event listener is very similar to adding it. We call the `TweetStore.removeChangeListener()`
    method and pass our `this.onTweetChange` method as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, it’s time to create the `onTweetChange` method in our `Stream` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, it updates the component’s state with a new tweet stored in
    `TweetStore` using the `TweetStore.getTweet()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one final change that we need to make in our `Stream` component. Later
    in this chapter, you’ll learn that our `StreamTweet` component doesn’t need the
    `handleAddTweetToCollection()` callback function anymore; therefore, in this component,
    we’re going to change the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace it with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let’s take a look at our newly refactored `Stream` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s recap to see how our `Stream` component always has the latest tweet:'
  prefs: []
  type: TYPE_NORMAL
- en: We set the component’s initial tweet to the latest tweet that we get from `TweetStore`
    using the `getTweet()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we listen to changes in `TweetStore`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When `TweetStore` changes its tweet, we update the component’s state to the
    latest tweet that we get from `TweetStore` using the `getTweet()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the component is about to unmount, we stop listening to the changes in
    `TweetStore`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is how a React component interacts with a Flux store.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we move on to make the rest of our application Flux-strong, let’s take
    a look at our current data flow:'
  prefs: []
  type: TYPE_NORMAL
- en: '`app.js`: This receives the new tweets and calls `TweetActionCreators` for
    each tweet'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TweetActionCreators`: This creates and dispatches a new action with a new
    tweet'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AppDispatcher`: This dispatches all the actions to all stores'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TweetStore`: This registers with a dispatcher and emits the change event on
    every new action received from a dispatcher'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Stream`: This listens to changes in `TweetStore`, gets a new tweet from `TweetStore`,
    updates the state with a new tweet, and re-renders'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can you see how we can now scale the number of React components, action creators,
    and stores, and still be able to maintain Snapterest? With Flux, it will always
    be a one-way data flow. It will be the same mental model regardless of how many
    new features we’ll implement. We will hugely benefit in the long run, when we’ll
    need to maintain our app.
  prefs: []
  type: TYPE_NORMAL
- en: Did I mention that we’re going to adapt Flux in our application even more? Next,
    let’s do exactly that.
  prefs: []
  type: TYPE_NORMAL
- en: Creating CollectionStore
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Not only does Snapterest store the latest tweet, but it also stores a collection
    of tweets that users create. Let’s refactor this feature with Flux.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s create a collection store. Navigate to the `~/snapterest/source/stores/`
    directory and create the `CollectionStore.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `CollectionStore` is a bigger store, but it has the same structure as `TweetStore`.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we import the dependencies and assign a `change` event name to the `CHANGE_EVENT`
    variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we define our data and the four private methods that mutate this data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we store a collection of tweets in an object that is initially
    empty, and we also store the collection name that is initially set to `new`. Then,
    we create three private functions that mutate `collectionTweets`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`addTweetToCollection()`: As the name suggests, it adds the `tweet` object
    to the `collectionTweets` object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`removeTweetFromCollection()`: This removes the `tweet` object from the `collectionTweets`
    object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`removeAllTweetsFromCollection()`: This removes all the `tweet` objects from
    `collectionTweets` by setting it to an empty object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, we define one private function that mutates `collectionName` called `setCollectionName`,
    which changes the existing collection name to a new one.
  prefs: []
  type: TYPE_NORMAL
- en: 'These functions are regarded as private because they are not accessible outside
    the `CollectionStore` module; for example, you *can’t* access them like that in
    any other module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: As we discussed earlier, this is done on purpose to enforce a one-way data flow
    in your application.
  prefs: []
  type: TYPE_NORMAL
- en: We create the `emitChange()` method that emits the `change` event.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we create the `CollectionStore` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This is very similar to the `TweetStore` object, except for two methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`getCollectionTweets()`: This returns a collection of tweets'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getCollectionName()`: This returns the collection name'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These methods are accessible outside the `CollectionStore.js` file and should
    be used in React components to get data from `CollectionStore`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we create the `handleAction()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This function handles the actions that are dispatched by `AppDispatcher`, but
    unlike `TweetStore` in our `CollectionStore` module, we can handle more than one
    action. In fact, we can handle the four actions that are related to the collection
    of tweets:'
  prefs: []
  type: TYPE_NORMAL
- en: '`add_tweet_to_collection`: This adds a tweet to a collection'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`remove_tweet_from_collection`: This removes a tweet from a collection'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`remove_all_tweets_from_collection`: This removes all the tweets from a collection'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`set_collection_name`: This sets a collection name'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remember that all the stores receive all the actions, so `CollectionStore` will
    receive the `receive_tweet` action as well, but we simply ignore it in this store,
    just like `TweetStore` ignores `add_tweet_to_collection`, `remove_tweet_from_collection`,
    `remove_all_tweets_from_collection`, and `set_collection_name`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we register the `handleAction` callback with `AppDispatcher`, and save
    `dispatchToken` in the `CollectionStore` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we export `CollectionStore` as a module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Now since we have the collection store ready, let’s create action creator functions
    next.
  prefs: []
  type: TYPE_NORMAL
- en: Creating CollectionActionCreators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Navigate to `~/snapterest/source/actions/` and create the `CollectionActionCreators.js`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'For each action that we handle in `CollectionStore`, we have an action creator
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '`addTweetToCollection()`: This creates and dispatches the `add_tweet_to_collection`
    action with a new tweet'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`removeTweetFromCollection()`: This creates and dispatches the `remove_tweet_from_collection`
    action with the ID of the tweet that must be removed from the collection'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`removeAllTweetsFromCollection()`: This creates and dispatches the `remove_all_tweets_from_collection`
    action'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setCollectionName()`: This creates and dispatches the `set_collection_name`
    action with a new collection name'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now when we’ve created both the `CollectionStore` and `CollectionActionCreators`
    modules, we can start refactoring our React components to adopt the Flux architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring the Application component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Where do we start refactoring our React components? Let’s start with our topmost
    React component in our components hierarchy, `Application`.
  prefs: []
  type: TYPE_NORMAL
- en: At the moment, our `Application` component stores and manages the collection
    of tweets. Let’s remove this functionality as it’s now managed by the collection
    store.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the `constructor()`, `addTweetToCollection()`, `removeTweetFromCollection()`,
    and `removeAllTweetsFromCollection()` methods from the `Application` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Now the `Application` component has only the `render()` method that renders
    the `Stream` and `Collection` components. Since it doesn’t manage the collection
    of tweets anymore, we don’t need to pass any properties to the `Stream` and `Collection`
    components as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `Application` component’s `render()` function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The adoption of the Flux architecture allows the `Stream` component to manage
    the latest tweet and the `Collection` component to manage the collection of tweets,
    whereas the `Application` component doesn’t need to manage anything anymore, so
    it becomes a container component that wraps the `Stream` and `Collection` components
    in the additional HTML markup.
  prefs: []
  type: TYPE_NORMAL
- en: 'In fact, you might have noticed that our current version of `Application` component
    is a good candidate to become a functional React component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Our `Application` component is now much simpler and its markup looks much cleaner.
    This improves the component’s maintainability. Well done!
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring the Collection component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next, let’s refactor our `Collection` component. Replace the existing `Collection`
    component with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'What did we change here? A few things. First, we imported the two new modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We created the `CollectionUtils` module in [Chapter 9](ch09.html "Chapter 9. Testing
    Your React Application with Jest"), *Testing Your React Application with Jest*,
    and in this chapter, we’re using it. `CollectionStore` is where we get our data
    from.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you should be able to spot the familiar pattern of the four methods:'
  prefs: []
  type: TYPE_NORMAL
- en: In the initial state, we set the collection of tweets to what is stored in `CollectionStore`
    at that moment. As you may recall that `CollectionStore` provides the `getCollectionTweets()`
    method to get the data from it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `componentDidMount()` method, we add the `change` event listener, `this.onCollectionChange`
    to `CollectionStore`. Whenever the collection of tweets is updated, `CollectionStore`
    will call our `this.onCollectionChange` callback function to notify the `Collection`
    component of that change.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `componentWillUnmount()` method, we remove the `change` event listener
    that we added to the `componentDidMount()` method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `onCollectionChange()` method, we set the component’s state to whatever
    is stored in `CollectionStore` at that moment in time. Updating the component’s
    state triggers a re-render.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `Collection` component’s `render()` method is now simpler and cleaner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We use the `CollectionUtils` module to get a number of tweets in the collection,
    and we pass fewer properties to the child components: `CollectionControls` and
    `TweetList`.'
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring the CollectionControls component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `CollectionControls` component gets some major improvements as well. Let’s
    take a look at the refactored version first and then discuss what was updated
    and why:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we import the two additional modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that we don’t manage the collection name in this component anymore.
    Instead, we get it from our `CollectionStore` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we make one of the key changes. We replace the `setCollectionName()`
    method with a new one, `removeAllTweetsFromCollection()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The `removeAllTweetsFromCollection()` method is called when a user clicks on
    the `Empty Collection` button. This user action triggers the `removeAllTweetsFromCollection()`
    action creator function that creates and dispatches the action to stores. In turn,
    `CollectionStore` removes all the tweets from the collection and emits the `change`
    event.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s refactor our `CollectionRenameForm` component.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring the CollectionRenameForm component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`CollectionRenameForm` is a controlled form component. This means that its
    input value is stored in the component’s state, and the only way to update that
    value is to update the component’s state. It has the initial value that it should
    get from `CollectionStore`, so let’s make that happen.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, import the `CollectionActionCreators` and `CollectionStore` modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to remove its existing `constructor()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace the preceding code with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the only difference is that now we get the initial `inputValue`
    from `CollectionStore`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s update the `handleFormSubmit()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the preceding code with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The important difference here is that when a user submits a form, we will create
    a new action that sets a new name in our collection store:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to change the source of the collection name in the `handleFormCancel()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Change the preceding code with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Once again, we get the collection name from a collection store:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: This is all that we need to change in the `CollectionRenameForm` component.
    Let’s refactor the `TweetList` component next.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring the TweetList component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `TweetList` component renders a list of tweets. Each tweet is a `Tweet`
    component that a user can click on to remove it from a collection. Does it sound
    to you like it could make use of `CollectionActionCreators`?
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s right. Let’s add the `CollectionActionCreators` module to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we’ll create the `removeTweetFromCollection()` callback function that
    will be called when a user clicks on a tweet image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, it creates a new action using the `removeTweetFromCollection()`
    function by passing the tweet ID as an argument to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we need to make sure that `removeTweetFromCollection()` is actually
    called. In the `getTweetElement()` method, find the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Now replace it with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: We’re all done with this component. `StreamTweet` is next in our refactoring
    journey.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring the StreamTweet component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`StreamTweet` renders a tweet image that a user can click on to add it to a
    collection of tweets. You might have already guessed that we’re going to create
    and dispatch a new action when a user clicks on that tweet image.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, import the `CollectionActionCreators` module to the `StreamTweet` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, add a new `addTweetToCollection()` method to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The `addTweetToCollection()` callback function should be invoked when a user
    clicks on a tweet image. Let’s take a look at this line in the `render()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace the preceding code with the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to replace the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Use this one instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The `StreamTweet` component is now done.
  prefs: []
  type: TYPE_NORMAL
- en: Building and going beyond
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: That’s all the effort that is needed to integrate the Flux architecture into
    our React application. If you compare your React application without Flux and
    with Flux, you’ll quickly see how much easier it is to understand how your application
    works when Flux is part of it. You can learn more about Flux at [https://facebook.github.io/flux/](https://facebook.github.io/flux/).
  prefs: []
  type: TYPE_NORMAL
- en: I think it’s a good time to check that everything is in perfect working order.
    Let’s build and run Snapterest!
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to `~/snapterest` and run the following command in your Terminal window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Make sure that you’re running the Snapkite Engine application that we have installed
    and configured in [Chapter 2](ch02.html "Chapter 2. Installing Powerful Tools
    for Your Project"), *Installing Powerful Tools for Your Project*. Now open the
    `~/snapterest/build/index.html` file in your web browser. You should see new tweets
    appearing on the left-hand side, one at a time. Click on a tweet to add it to
    a collection that appears on the right-hand side.
  prefs: []
  type: TYPE_NORMAL
- en: Does it work? Check JavaScript Console for any errors. No errors?
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations on integrating the Flux architecture into our React application!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we completed refactoring our application to use the Flux architecture.
    You learned what it takes to combine React with Flux and what advantages Flux
    has to offer.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll simplify our application’s architecture further with
    the Redux library.
  prefs: []
  type: TYPE_NORMAL
