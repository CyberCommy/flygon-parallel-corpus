- en: Chapter 14. Extensions in C/C++, System Calls, and C/C++ Libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we know a bit more about performance and multiprocessing, we will explain
    another subject that is at least somewhat performance-related—the usage of C and/or
    C++ extensions.
  prefs: []
  type: TYPE_NORMAL
- en: There are multiple reasons to consider C/C++ extensions. Having existing libraries
    available is an important one, but truthfully, the most important reason is performance.
    In [Chapter 12](ch12.html "Chapter 12. Performance – Tracking and Reducing Your
    Memory and CPU Usage"), *Performance – Tracking and Reducing Your Memory and CPU
    Usage*, we saw that the `cProfile` module is about 10 times faster than the `profile`
    module, which indicates that at least some C extensions are faster than their
    pure Python equivalents. This chapter will not focus on performance that much,
    however. The goal here is interaction with non-Python libraries. Any performance
    improvement will just be a completely unintentional side effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will discuss the following options in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Ctypes for handling foreign (C/C++) functions and data from Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CFFI** (short for **C Foreign Function Interface**), similar to `ctypes`
    but with a slightly different approach'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing native C/C++ to extend Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before you start with this chapter, it is important to note that this chapter
    will require a working compiler that plays nicely with your Python interpreter.
    Unfortunately, these vary from platform to platform. While generally easy enough
    for most Linux distributions, this can be a big challenge on Windows. With OS
    X, it's generally easy enough provided you install the correct tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'The generic building instructions are always available in the Python manual:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.python.org/3.5/extending/building.html](https://docs.python.org/3.5/extending/building.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Do you need C/C++ modules?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In almost all cases, I'm inclined to say that you don't need C/C++ modules.
    If you are really strapped for best performance, then there are almost always
    highly optimized libraries available that fit your purpose. There are some cases
    where native C/C++ (or just "not Python") is a requirement. If you need to communicate
    directly with hardware that has specific timings, then Python might just not do
    the trick for you. Generally, however, that kind of communication should be left
    to a driver that takes care of the specific timings. Regardless, even if you will
    never write one of these modules yourself, you might still need to know how they
    work when you are debugging a project.
  prefs: []
  type: TYPE_NORMAL
- en: Windows
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For Windows, the general recommendation is Visual Studio. The specific version
    depends on your Python version:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Python 3.2 and lower: Microsoft Visual Studio 2008'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Python 3.3 and 3.4: Microsoft Visual Studio 2010'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Python 3.5 and 3.6: Microsoft Visual Studio 2015'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The specifics of installing Visual Studio and compiling Python modules fall
    a bit outside of the scope of this book. Luckily, the Python documentation has
    some documentation available to get you started:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.python.org/3.5/extending/windows.html](https://docs.python.org/3.5/extending/windows.html)'
  prefs: []
  type: TYPE_NORMAL
- en: OS X
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For a Mac, the process is mostly straightforward, but there are a few tips specific
    to OS X.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, install Xcode through the Mac App Store. Once you have done that, you
    should be able to run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Next up is the fun part. Because OS X comes with a bundled Python version (which
    is generally out of date), I would recommend installing a new Python version through
    Homebrew instead. The most up-to-date instructions for installing Homebrew can
    be found on the Homebrew homepage ([http://brew.sh/](http://brew.sh/)), but the
    gist of installing Homebrew is this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, make sure you check whether everything is set up correctly using
    the `doctor` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'When all of this is done, simply install Python through Homebrew and make sure
    you use that Python release when executing your scripts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Also ensure that the Python process is in `/usr/local/bin`, that is, the homebrewed
    version. The regular OS X version would be in `/usr/bin/` instead.
  prefs: []
  type: TYPE_NORMAL
- en: Linux/Unix
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The installation for Linux/Unix systems greatly depends on the distribution,
    but it is generally simple to do.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Fedora, Red Hat, Centos, and other systems that use `yum` as the package
    manager, use these lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'For Debian, Ubuntu, and other systems that use `apt` as the package manager,
    use the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Note that Python 3.5 is not available everywhere yet, so you might need Python
    3.4 instead.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For most systems, to get help with the installation, a web search along the
    lines of `<operating system> python.h` should do the trick.
  prefs: []
  type: TYPE_NORMAL
- en: Calling C/C++ with ctypes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `ctypes` library makes it easily possible to call functions from C libraries,
    but you do need to be careful with memory access and data types. Python is generally
    very lenient in memory allocation and type casting; C is, most definitely, not
    that forgiving.
  prefs: []
  type: TYPE_NORMAL
- en: Platform-specific libraries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Even though all platforms will have a standard C library available somewhere,
    the location and the method of calling it differs per platform. For the purpose
    of having a simple environment that is easily accessible to most people, I will
    assume the use of an Ubuntu (virtual) machine. If you don't have a native Ubuntu
    available, you can easily run it through VirtualBox on Windows, Linux, and OS
    X.
  prefs: []
  type: TYPE_NORMAL
- en: Since you will often want to run examples on your native system instead, we
    will first show the basics of loading `printf` from the standard C library.
  prefs: []
  type: TYPE_NORMAL
- en: Windows
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One problem of calling C functions from Python is that the default libraries
    are platform-specific. While the following example will work just fine on Windows
    systems, it won''t run on other platforms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Because of these limitations, not all examples can work for every Python version
    and distribution without requiring manual compilation. The basic premise of calling
    functions from external libraries functions is to simply access their names as
    properties of the `ctypes` import. There is a difference, however; on Windows,
    the modules will generally be auto-loaded, while on Linux/Unix systems, you will
    need to load them manually.
  prefs: []
  type: TYPE_NORMAL
- en: Linux/Unix
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Calling standard system libraries from Linux/Unix does require manual loading,
    but it''s nothing too involved luckily. Fetching the `printf` function from the
    standard C library is quite simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: OS X
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For OS X, explicit loading is also required, but beyond that, it is quite similar
    to how everything works on regular Linux/Unix systems:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Making it easy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Besides the way libraries are loaded, there are more differences—unfortunately—but
    these examples at least give you the standard C library. It allows you to call
    functions such as `printf` straight from your C implementation. If, for some reason,
    you have trouble loading the right library, there is always the `ctypes.util.find_library`
    function. As always, I recommend explicit over implicit declarations, but things
    can be made easier using this function. Let''s illustrate a run on an OS X system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Calling functions and native types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Calling a function through `ctypes` is nearly as simple as calling native Python
    functions. The notable difference is the arguments and return statements. These
    should be converted to native C variables:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These examples will assume that you have `libc` in your scope from one of the
    examples in the previous paragraphs.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, to call the `printf` function you *must*—and I cannot stress
    this enough—convert your values from Python to C explicitly. While it might appear
    to work without this initially, it really doesn''t:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember to use the `faulthandler` module from [Chapter 11](ch11.html "Chapter 11. Debugging
    – Solving the Bugs"), *Debugging – Solving the Bugs* to debug segfaults.
  prefs: []
  type: TYPE_NORMAL
- en: Another thing to note from the example is that `ctypes.sizeof(spam)` returns
    `5` instead of `4`. This is caused by the trailing null character, which C strings
    require. This is visible in the raw property of the C string. Without it, the
    `printf` function won't know where the string will end.
  prefs: []
  type: TYPE_NORMAL
- en: 'To pass along other types (such as integers) towards `libc` functions, we have
    to use some conversion as well. In some cases, it is optional:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'But not in all cases, so it''s definitely recommended that you convert your
    values explicitly in all cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s important to note that even though these values are usable as native
    C types, they are still mutable through the `value` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: However, this is not the case if the original object was immutable, which is
    a very important distinction to make. The `create_string_buffer` object creates
    a mutable string object, whereas `c_wchar_p`, `c_char_p`, and `c_void_p` create
    references to the actual Python string. Since strings are immutable in Python,
    these values are also immutable. You can still change the `value` property, but
    it will only assign a new string. Actually, passing one of these to a C function
    that mutates the internal value will cause problems.
  prefs: []
  type: TYPE_NORMAL
- en: The only values that should convert to C without any issues are integers, strings,
    and bytes, but I personally recommend that you always convert all of your values
    so that you are certain of which type you will get and how to treat it.
  prefs: []
  type: TYPE_NORMAL
- en: Complex data structures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have already seen that we can''t just pass along Python values to C, but
    what if we need more complex objects? That is, not just bare values that are directly
    translatable to C but complex objects containing multiple values. Luckily, we
    can easily create (and access) C structures using `ctypes`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Within Python, we generally use a list to represent a collection of objects.
    These are very convenient in that you can easily add and remove values. Within
    C, the default collection object is the array, which is just a block of memory
    with a fixed size.
  prefs: []
  type: TYPE_NORMAL
- en: The size of the block in bytes is decided by multiplying the number of items
    with the size of the type. In the case of a `char`, this is `8` bits, so if you
    wish to store `100` chars, you would have `100 * 8 bits = 800 bits = 100 bytes`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is literally all it is—a block of memory—and the only reference you receive
    from C is a pointer to the memory address where the block of memory begins. Since
    the pointer does have a type, `char*` in this case, C will know how many bytes
    to jump ahead when trying to access a different item. Effectively, when trying
    to access item 25 in a `char` array, you simply need to do `array_pointer + 25
    * sizeof(char)`. This has a convenient shortcut: `array_pointer[25]`.'
  prefs: []
  type: TYPE_NORMAL
- en: Note that C does not store the number of items in the array, so even though
    our array has only 100 items, it won't block us from doing `array_pointer[1000]`
    and reading other (random) memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you take all of that into account, it is definitely usable, but mistakes
    are quickly made and C is unforgiving. No warnings, just crashes and strangely
    behaving code. Beyond that, let''s see how easily we can declare an array with
    `ctypes`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, because of the fixed sizes and the requirement of declaring
    the type before using it, its usage is slightly awkward. However, it does function
    as you would expect, and the values are initialized to zero by default. Obviously,
    this can be combined with the previously discussed structures as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Even though you cannot simply append to these arrays to resize them, they are
    actually resizable with a few constraints. Firstly, the new array needs to be
    larger than the original array. Secondly, the size needs to be specified in bytes,
    not items. To illustrate, we have this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Gotchas with memory management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Besides the obvious memory allocation issues and mixing mutable and immutable
    objects, there is one more strange memory mutability issue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Why didn't we get `2, 3, 4, 5, 0, 1`? The problem is that these objects are
    copied to a temporary buffer variable. In the meantime, the values of that object
    are being changed because it contains separate objects internally. After that,
    the object is transferred back, but the values have already changed, giving the
    incorrect results.
  prefs: []
  type: TYPE_NORMAL
- en: CFFI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `CFFI` library offers options very similar to `ctypes`, but it''s a bit
    more direct. Unlike the `ctypes` library, a C compiler is really a necessity for
    `CFFI`. With it comes the opportunity to directly call your C compiler in a very
    easy way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Okay… so that looks a bit weird right? We had to define how the `printf` function
    looks and specify the arguments to `printf` with a valid C type declaration. Getting
    back to the declarations, however, instead of `None` to `ffi.dlopen`, you can
    also specify the library you wish to load. If you remember the `ctypes.util.find_library`
    function, you can use that again in this case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: But it still won't make its definitions readily available for you. The function
    definitions are still required to make sure that everything works as you would
    like it to.
  prefs: []
  type: TYPE_NORMAL
- en: Complex data structures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `CFFI` definitions are somewhat similar to the `ctypes` definitions, but
    instead of having Python emulating C, it''s just plain C that is accessible from
    Python. In reality, it''s just a small syntactical difference. Whereas `ctypes`
    is a library for accessing C from Python while remaining as close to the Python
    syntax as possible, `CFFI` uses plain C syntax to access C systems, which actually
    removes some confusion for people experienced with C. I personally find `CFFI`
    easier to use because I know what is actually happening, whereas I am not always
    a 100% certain with `ctypes`. Let''s repeat the `Vertex` and `Point` example with
    CFFI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the mutable variable issues remain but the code is just as usable.
  prefs: []
  type: TYPE_NORMAL
- en: Arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Allocation memory for new variables is almost trivial with `CFFI`. The previous
    paragraph showed you an example of array allocation; let''s see the possibilities
    of array definitions now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In this case, you might wonder why the slice includes both the start and the
    stop. This is actually a requirement for `CFFI`. Not always problematic but a
    tad annoying nonetheless. Currently, however, it's unavoidable.
  prefs: []
  type: TYPE_NORMAL
- en: ABI or API?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As always, there are some caveats—unfortunately. The examples so far have partially
    used the ABI, which loads the binary structures from the libraries. With the standard
    C library, this is generally safe; with other libraries, it generally isn't. The
    difference between the API and the ABI is that the latter calls the functions
    at a binary level, directly addressing memory, directly calling memory locations,
    and expecting them to be functions. Effectively, it's the difference between `ffi.dlopen`
    and `ffi.cdef`. Here, the `dlopen` is not always safe but `cdef` is, because it
    passes a compiler instead of just guessing how to call a method.
  prefs: []
  type: TYPE_NORMAL
- en: CFFI or ctypes?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This really depends on what you are looking for. If you have a C library that
    you simply need to call and you don't need anything special, then `ctypes` is
    most likely the better choice. If you're actually writing your own C library and
    trying to link it, well, `CFFI` is probably a more convenient option. If you're
    not familiar with the C programming language, then I would definitely recommend
    `ctypes`. Alternatively, you'll find `CFFI` to be a more convenient option.
  prefs: []
  type: TYPE_NORMAL
- en: Native C/C++ extensions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The libraries that we have used so far only showed us how to access a C/C++
    library within our Python code. Now we are going to look at the other side of
    the story—how C/C++ functions/modules within Python are actually written and how
    modules such as `cPickle` and `cProfile` are created.
  prefs: []
  type: TYPE_NORMAL
- en: A basic example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we can actually start with writing and using native C/C++ extensions,
    we have a few prerequisites. First of all, we need the compiler and Python headers;
    the instructions in the beginning of this chapter should have taken care of this
    for us. After that, we need to tell Python what to compile. The `setuptools` package
    mostly takes care of this, but we do need to create a `setup.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This tells Python that we have an `Extension` object named `Spam` that will
    be based on `spam.c`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s write a function in C that sums all perfect squares (`2*2`, `3*3`,
    and so on) up to a given number. The Python code will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The raw C version of this code would look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'And the Python C version looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'It looks quite complicated, but it''s really not that hard. There is just a
    lot of overhead in this case because we only have a single function. Generally,
    you would have several functions, in which case you only need to expand the `spam_methods`
    array and create the functions. The next paragraph will explain the code in more
    detail, but first let''s look at how to run our first example. We need to build
    and install the module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s create a little test script to time the difference between the
    Python version and the C version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'And now let''s execute it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Perfect! Exactly the same results but more than 200 times faster!
  prefs: []
  type: TYPE_NORMAL
- en: C is not Python – size matters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Python language makes programming so easy that you might forget about the
    underlying data structures at times; with C, you can''t afford to do that. Just
    take our example from the previous chapter but with different parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: It's still very fast, but what happened to the numbers? The Python and C versions
    give different results, `1953214233` versus `10543148825`. This is caused by integer
    overflows in C. Whereas Python numbers can essentially have any size, with C,
    a regular number has a fixed size. How much you get depends on the type you use
    (`int`, `long`, and so on) and your architecture (32-bit, 64-bit, and so on),
    but it's definitely something to be careful with. It might be hundreds of times
    faster in some cases, but that is meaningless if the results are incorrect.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can increase the size a bit, of course. This makes it better:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'If we test it now, we realize that it works great:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Unless we make the number even larger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'So how can you fix this? The simple answer is that you can''t. The complex
    answer is that you can if you use a different data type to store your data. The
    C language by itself doesn''t have the "big number support" that Python has. Python
    supports infinitely large numbers by combining several regular numbers in the
    actual memory. Within C, there are no commonly available provisions for this,
    so there is simply no easy way to get this working. But we can check for errors
    instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Note that this only works for `PyObject*`, which means it doesn't work for internal
    C overflows. But you can, of course, just keep the original Python long around
    and perform operations on that instead. So, you do have big number support in
    C without too much effort.
  prefs: []
  type: TYPE_NORMAL
- en: The example explained
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have seen the results from our example, but if you''re not familiar with
    the Python C API, you might be confused as to why the function parameters look
    the way they do. The basic calculations within `spam_sum_of_squares` are identical
    to the regular C `sum_of_squares` function, but there are a few small differences.
    Firstly, the type definition for a function using the Python C API should look
    something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: static
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This means that the function is `static`. A function that's static can be called
    only from the same translation unit within the compiler. This effectively results
    in a function that cannot be linked from other modules, which allows the compiler
    to optimize a bit further. Since functions in C are global by default, this can
    be very useful to prevent collisions. Just to be sure, however, we have prefixed
    the function name with `spam_` to indicate that this function comes from the `spam`
    module.
  prefs: []
  type: TYPE_NORMAL
- en: Be careful not to confuse the word `static` here with the `static` before a
    variable. They are completely different beasts. A `static` variable means that
    the variable that will exist for the entire runtime of the program instead of
    the runtime of just the function.
  prefs: []
  type: TYPE_NORMAL
- en: PyObject*
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `PyObject` type is the basic type for Python data types, which means that
    all Python objects can be cast to `PyObject*` (the `PyObject` pointer). Effectively,
    it only tells the compiler what kind of properties to expect, which can be used
    later for type identification and memory management. Instead of direct access
    to `PyObject*`, it is generally a better idea to use the available macros, such
    as `Py_TYPE(some_object)`. Internally, this expands to `(((PyObject*)(o))->ob_type)`,
    which is why the macro is generally a better idea. Besides being unreadable, a
    typo can easily happen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The list of properties is long and depends greatly on the type of object. For
    those, I would like to refer to the Python documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.python.org/3/c-api/typeobj.html](https://docs.python.org/3/c-api/typeobj.html)'
  prefs: []
  type: TYPE_NORMAL
- en: The entire Python C API could fill a book of its own, but it is luckily well
    documented within the Python manual. The usage, on the other hand, might be less
    obvious.
  prefs: []
  type: TYPE_NORMAL
- en: Parsing arguments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With regular C and Python, you specify the arguments explicitly, since variable-sized
    arguments are a bit tricky with C. This is because they need to be parsed separately.
    `PyObject* args` is the reference to objects containing the actual values. To
    parse these, you need to know how many and which type of variables to expect.
    In the example, we used the `PyArg_ParseTuple` function, which parses the arguments
    as positional arguments only, but it is quite easily possible to parse named arguments
    as well using `PyArg_ParseTupleAndKeywords` or `PyArg_VaParseTupleAndKeywords`.
    The difference between the last two is that the first one uses a variable number
    of arguments to specify the destination and the latter uses a `va_list` to set
    the values to. But first, let''s analyze the code from the actual example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We know that `args` is the object containing the reference to the actual arguments.
    The `"i"` is a format string, which in this case will try to parse a single integer.
    And `&n` tells the function to store the value at the memory address of the `n`
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: The format string is the important part here. Depending on the character, you
    get a different data type, but there are many; `i` specifies a regular integer,
    and `s` converts your variable to a c-string (actually a `char*`, which is a null-terminated
    character array). It should be noted that this function is, luckily, smart enough
    to take overflows into consideration as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parsing multiple arguments is quite similar; you simply need to add multiple
    characters to the format string and multiple destination variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The version with keyword arguments is similar but requires a few more code
    changes as the list of methods needs to be informed that the function takes keyword
    arguments. Otherwise, the `kwargs` parameter would never arrive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Note that this still supports normal arguments, but keyword arguments are also
    supported now.
  prefs: []
  type: TYPE_NORMAL
- en: C is not Python – errors are silent or lethal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we saw in the previous example, integer overflows are not something you
    will generally notice, and unfortunately there''s no good cross-platform way to
    catch them. However, those are actually the easier errors to handle; the worst
    one is generally memory management. With Python, if you get an error, you will
    get an exception that you can catch. But with C, you can''t really handle it gracefully.
    Take a division by zero for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'This is simple enough to catch with `try: ... except ZeroDivisionError: ...`.
    With C on the other hand, if you get a bad error, it will kill your entire process.
    But debugging C code is what C compilers have debuggers for, and to find the cause
    of the error, you can use the `faulthandler` module discussed in [Chapter 11](ch11.html
    "Chapter 11. Debugging – Solving the Bugs"), *Debugging – Solving the Bugs*. Right
    now, let''s see how we can properly throw errors from C. Let''s use the `spam`
    module from earlier, but for brevity, we will omit the rest of the C code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The syntax is slightly different—`PyErr_SetString` instead of `raise`—but it's
    the same basic principle, luckily.
  prefs: []
  type: TYPE_NORMAL
- en: Calling Python from C – handling complex types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have seen how to call C functions from Python, but now let''s try Python
    from C and back. Instead of using the readily available `sum` function, we will
    build one of our own with a callback and handling of any type of iterable. While
    this sounds simple enough, it does actually require a bit of type meddling as
    you can only expect `PyObject*` as arguments. This is contrary to the simple types,
    such as integers, chars, and strings, which are immediately converted to the native
    Python version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Make sure you note the `PyDECREF` calls, which ensure that you don't leak these
    objects. Without them, the objects will stay in use and the Python interpreter
    won't be able to clear them.
  prefs: []
  type: TYPE_NORMAL
- en: 'This function is callable in three different ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Another important issue is that even though we catch overflow errors when converting
    to `long long int`, this code is still not safe. If we sum even two very large
    numbers (close to the `long long int` limit), we will still have an overflow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned the most important aspects of writing code that
    uses `ctypes`, `CFFI`, and how to extend the Python functionality using native
    C. These topics can be extensive enough to fill books on their own, but you should
    have a grasp of the most important topics now. Even though you are able to create
    C/C++ extensions now, I still recommend that you avoid these as much as possible.
    This is because bugs are so easily made by not being careful enough. It is actually
    likely that at least some of the examples given in this chapter contain bugs when
    it comes to memory management and can crash your Python interpreter when given
    the wrong input. Unfortunately, this is a side effect of C. A tiny mistake can
    have a huge impact.
  prefs: []
  type: TYPE_NORMAL
- en: While building the examples in this chapter, you may have noticed that we used
    a `setup.py` file and imported from the `setuptools` library. This is what the
    next chapter will cover—packaging your code into an installable Python library
    and distributing it on the Python package index.
  prefs: []
  type: TYPE_NORMAL
