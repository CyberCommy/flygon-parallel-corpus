- en: Chapter 4. Touch and Gestures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating iPhone web applications, by default, involves touch interaction. This
    is obvious, and luckily Apple has done a great job getting us up and going quickly
    by mapping clicks to touch events by default. However, what if we wanted a slideshow
    that reacted to a swipe from the user? Or, what if we wanted to zoom into a photo,
    without affecting the layout of a page, when the user pinched within a defined
    area of our application? Well, that's all up to us as developers.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter we'll go over touch events and gestures, and use the technology
    to build a slideshow that is responsive to a user's touch and gestures. Most of
    the concepts here will be basic to help you understand these new events that were
    not common in traditional web development. However, we'll also dive into some
    more advanced features using the pinch gesture to zoom in and out of an image.
    But, first we need to do some adjusting to our app by reorganizing our navigation,
    so that it does not take up most of the screen real estate, from there we'll start
    our dive into touch and gestures.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Simplifying our navigation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a responsive photo gallery
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Listening to and handling touch events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interpreting touch events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Responding to gestures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extending touch events as a plugin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simplifying the navigation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our navigation is currently taking up some serious real estate, and although
    it worked for our previous examples, it just won't work well with the rest of
    the examples for this book. So, first we need to clean up this application in
    order to focus on the actual content of our application. We'll clean up our markup
    to use the `select` component. Then we'll add interactivity, so that our `select`
    element actually switches between pages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we start coding, create an `App.Nav.js` file in our JavaScript directory.
    Once the file is created, let''s include it at the bottom of our page with the
    following script tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Navigation markup and styling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section of the chapter we look at reworking the navigation for our applications.
    In most cases we want to make sure to use native controls on the device, so the
    goal here is to provide the user the ability to use the custom select control
    in iOS, but give us the same flexibility to customize the look and feel while
    having the same interaction. We'll modify the markup, look at customizing controls,
    and then simulating the same experience.
  prefs: []
  type: TYPE_NORMAL
- en: The basic template
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First, let''s get rid of the anchor tags that we are using within the navigation.
    Once we''re done removing those links, let''s create a `select` element with options
    and have the values point to the appropriate pages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code we have replaced anchor tags with a `select` element with
    options. Each option has a value that points to the specific page and within the
    option is the chapter name. Since we've removed the anchor tags, we need to adjust
    the styling.
  prefs: []
  type: TYPE_NORMAL
- en: Styling a select component
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There's not much we need to do here, but remove the styling we had in place.
    Although it's not necessary, for best practice, you always want to remove unused
    styling. This helps increase the performance of your application by lowering the
    page load.
  prefs: []
  type: TYPE_NORMAL
- en: 'So let''s remove the following styles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now, we need to add the interactivity that mimics the default actions of an
    anchor tag.
  prefs: []
  type: TYPE_NORMAL
- en: Navigation interactivity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Mimicking the default behavior of an anchor tag is pretty simple. Let's start
    by creating a basic template, such as those we've done in previous chapters, then
    cache the navigation and add the behavior to switch between pages. So let's get
    started!
  prefs: []
  type: TYPE_NORMAL
- en: The basic template
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Following is our default template. As before, it's just a simple IIFE that establishes
    a class for our navigation. This closure accepts the `window`, `document`, and
    `Zepto` objects, aliasing the `Zepto` object to the dollar sign.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Caching our navigation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now, we could just use Zepto to find the navigation in the DOM each time we
    need it. But following our best practices, we can cache the navigation and have
    a variable contained in the closure scope that can be used by private and public
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have created a `$nav` variable that is contained within
    the closure scope, so we can now reference it within all methods contained in
    this closure. Then in the constructor we set the variable to the `nav` element.
  prefs: []
  type: TYPE_NORMAL
- en: Listening and handling the change event
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now the fun begins. We need to listen to when the `select` element's change
    event is fired. We have done this before for our audio player. However, we'll
    briefly go over how to do this here in case you haven't been following along in
    order.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s call an `attachEvents` method that we will define next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we are calling the `attachEvents` method, we need to create it. In
    this method, we want to listen to the change event and then handle it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code we use Zepto's `on` method to tell the cached navigation
    to listen to the change event on a `select` element, which is contained within
    the navigation. From there we assign a method we have not created, `handleSelectChange`.
    This method is a handler that we will define next.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to define our handler. All this handler needs to do is switch
    pages based on the changed value of the `select` element.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The preceding handler accepts the event parameter, but we actually don't use
    it. You can remove this parameter, but usually I like to keep the parameters a
    handler accepts. Either way, we are telling the window object to switch locations
    by setting `window.location` to the value that the `select` element has been changed
    to.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that we are using `this.value` to set the location of the window object.
    In this case, `this` refers to the select element itself or the element the on
    event targets.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing the navigation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Finally, all we need to do is initialize this class. Because this navigation
    will theoretically be on every page of our application, we can immediately create
    a new instance of `App.Nav` after we have created this call. So let''s add the
    following code at the end of `App.Nav.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This is all we need to mimic the behavior of our previous anchor tags. With
    this done, we now have plenty of screen real estate to proceed with touch events.
    Next, let's discuss touch events and gestures on the iPhone.
  prefs: []
  type: TYPE_NORMAL
- en: Touch and Gesture events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Touch events are easy to handle on the iPhone; however, there are a couple of
    "gotchas" when you start diving into when events are fired and how they are interpreted
    in certain situations. Luckily for us, gestures are also easily implemented with
    the `GestureEvent` object. In this section we'll go over touch and gestures in
    general, getting a fundamental understanding of the technology behind these user
    experiences so that in the next section, we can successfully create a swipeable
    slideshow.
  prefs: []
  type: TYPE_NORMAL
- en: Touch events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Touch events include one or more inputs received by your mobile device. In
    this book we''ll focus on up to two-finger events that we can handle in several
    ways. iOS does a great job at interpreting these inputs; however, elements can
    be either clickable or scrollable as described by Apple''s Developer documentation
    ([http://developer.apple.com/library/ios/#documentation/AppleApplications/Reference/SafariWebContent/HandlingEvents/HandlingEvents.html#pageTitle](http://developer.apple.com/library/ios/#documentation/AppleApplications/Reference/SafariWebContent/HandlingEvents/HandlingEvents.html)):'
  prefs: []
  type: TYPE_NORMAL
- en: A clickable element is a link, form element, image map area, or any other element
    with mousemove, mousedown, mouseup, or onclick handlers. A scrollable element
    is any element with appropriate overflow style, text areas, and scrollable iframe
    elements. Because of these differences, you might need to change some of your
    elements to clickable elements, as described in "Making Elements Clickable," to
    get the desired behavior in iOS.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '>'
  prefs: []
  type: TYPE_NORMAL
- en: In addition, you can turn off the default Safari on iOS behavior as described
    in "Preventing Default Behavior" and handle your own multi-touch and gesture events
    directly. Handling multi-touch and gesture events directly gives developers the
    ability to implement unique touch-screen interfaces similar to native applications.
    Read "Handling Multi-Touch Events" and "Handling Gesture Events" to learn more
    about DOM touch events.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This is essential to keep in mind because, depending on the kind of functionality
    we require, certain elements behave differently by default. If we want to modify
    this functionality, we need to override the defaults by attaching certain events
    to those elements, as described earlier. By preventing the default functionality
    and overriding it with our own, we can create experiences that are greatly customized
    to our needs. An example of this would be creating a full page parallax experience
    that plays an animation as we scroll.
  prefs: []
  type: TYPE_NORMAL
- en: Once we know what kind of behavior we want, there are a couple of important
    things we need to keep in mind. For example, events are conditional, so depending
    on the user interaction some gestures might not generate any events. Let's take
    a look at some of these events.
  prefs: []
  type: TYPE_NORMAL
- en: On scroll
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A good example of a conditional event is when the user scrolls a page. In this
    interaction the scroll event only fires when the page stops moving and redraws.
    For this reason, on most parallax-driven sites the default behavior is prevented
    on the page and a custom scroll solution is implemented.
  prefs: []
  type: TYPE_NORMAL
- en: On touch and hold
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When a user touches a clickable element and holds down their finger, an information
    bubble is displayed. But if you were hoping to catch this gesture, you're out
    of luck. Based on the official Apple documentation, no events are dispatched during
    this type of interaction.
  prefs: []
  type: TYPE_NORMAL
- en: On double-tap zoom
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this interaction, the user double-taps the screen and the page zooms in.
    You would think that there would be an event for this type of interaction, but
    again we don't have any events we can tie into.
  prefs: []
  type: TYPE_NORMAL
- en: If we keep in mind the exceptions discussed earlier, we should be good with
    developing our application and handling our touch events correctly. Now we need
    to know what events we can tie into for touch, including how to listen and handle
    them appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: Supported touch events and how they work
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Apple documentation officially lists out all events that are supported
    on iOS, including the following touch and gesture events and when they were supported:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Event | Generated | Conditional | Available |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `gesturestart` | yes | N/A | iOS 2.0 and later |'
  prefs: []
  type: TYPE_TB
- en: '| `gesturechange` | yes | N/A | iOS 2.0 and later |'
  prefs: []
  type: TYPE_TB
- en: '| `gestureend` | yes | N/A | iOS 2.0 and later |'
  prefs: []
  type: TYPE_TB
- en: '| `touchcancel` | yes | N/A | iOS 2.0 and later |'
  prefs: []
  type: TYPE_TB
- en: '| `touchend` | yes | N/A | iOS 2.0 and later |'
  prefs: []
  type: TYPE_TB
- en: '| `touchmove` | yes | N/A | iOS 2.0 and later |'
  prefs: []
  type: TYPE_TB
- en: '| `touchstart` | yes | N/A | iOS 2.0 and later |'
  prefs: []
  type: TYPE_TB
- en: 'Based on the preceding list, we''ve got everything we need in order to make
    complex user experiences on the iPhone using mobile Safari. If you were worried
    how these events are handled, there''s no need to be, based on the development
    documentation by Apple ([http://developer.apple.com/library/ios/#documentation/AppleApplications/Reference/SafariWebContent/HandlingEvents/HandlingEvents.html](http://developer.apple.com/library/ios/#documentation/AppleApplications/Reference/SafariWebContent/HandlingEvents/HandlingEvents.html))
    these events are delivered in the same way as any other browser:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Mouse events are delivered in the same order you''d expect in other web browsers
    (…). If the user taps a nonclickable element, no events are generated. If the
    user taps a clickable element, events arrive in this order: mouseover, mousemove,
    mousedown, mouseup, and click. The mouseout event occurs only if the user taps
    on another clickable item. Also, if the contents of the page changes on the mousemove
    event, no subsequent events in the sequence are sent. This behavior allows the
    user to tap in the new content.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Now that we have a good understanding of one-finger touch events, including
    the exceptions and the way they work, we should take some time to understand gestures.
  prefs: []
  type: TYPE_NORMAL
- en: Gestures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Technically, gestures are touch events and so the preceding information also
    applies to single-touch events because panning, zooming, and scrolling are all
    considered gestures. But, gestures are also complex interactions that can be interpreted
    differently. Based on the Apple documentation ([http://developer.apple.com/library/ios/#documentation/AppleApplications/Reference/SafariWebContent/HandlingEvents/HandlingEvents.html](http://developer.apple.com/library/ios/#documentation/AppleApplications/Reference/SafariWebContent/HandlingEvents/HandlingEvents.html))
    we can combine multi-touch events to create custom gestures;
  prefs: []
  type: TYPE_NORMAL
- en: Typically, you implement multi-touch event handlers to track one or two touches.
    But you can also use multi-touch event handlers to identify custom gestures. That
    is, custom gestures that are not already identified (...)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'We''ve seen from the chart in the previous sections that we can listen to gestures
    and thus create custom experiences; however, one thing that is confusing about
    gestures and normal touch events is when they happen. But this is not a mystery,
    because Apple''s documentation ([http://developer.apple.com/library/safari/#documentation/UserExperience/Reference/GestureEventClassReference/GestureEvent/GestureEvent.html#//apple_ref/javascript/cl/GestureEvent](http://developer.apple.com/library/safari/#documentation/UserExperience/Reference/GestureEventClassReference/GestureEvent/GestureEvent.html))
    provides the following information to us:'
  prefs: []
  type: TYPE_NORMAL
- en: '*(...) for a two finger multi-touch gesture, the events occur in the following
    sequence:*'
  prefs: []
  type: TYPE_NORMAL
- en: '*1\. touchstart for finger 1\. Sent when the first finger touches the surface.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*2\. gesturestart. Sent when the second finger touches the surface.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*3\. touchstart for finger 2\. Sent immediately after gesturestart when the
    second finger touches the surface.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*4\. gesturechange for current gesture. Sent when both fingers move while still
    touching the surface.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*5\. gestureend. Sent when the second finger lifts from the surface.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*6\. touchend for finger 2\. Sent immediately after gestureend when the second
    finger lifts from the surface.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*7\. touchend for finger 1\. Sent when the first finger lifts from the surface.*'
  prefs: []
  type: TYPE_NORMAL
- en: From the preceding information, we can gather that both touch and gesture events
    go hand-in-hand. This allows us to do some interesting things on the frontend
    without any guesswork. But, how do we do this? Well, the next section tackles
    this by creating a photo gallery that responds to both touch and gestures.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a responsive photo gallery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll get a better understanding of touch and gesture events if we focus on
    small pieces of functionality that we have already seen in traditional mobile
    applications, such as an interactive slideshow. We've seen this everywhere, a
    slideshow with next and previous buttons but also the ability to swipe from left
    to right or vice versa. The buttons are easy, and attaching touch events is also
    fairly simple; however, swiping does not come out of the box in mobile Safari,
    so we need to build that. So let's get started by first laying out our gallery
    and then styling it.
  prefs: []
  type: TYPE_NORMAL
- en: Gallery markup and styling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As with any slideshow gallery, it's essential that we create a good structure.
    This structure should be easy to follow and doesn't really require too many elements
    if we want to modularize it.
  prefs: []
  type: TYPE_NORMAL
- en: The basic gallery slide list
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s start with something extremely basic. First, let''s create a `div` with
    a class of `gallery`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: From here, we want a content area that will contain all our slides. You may
    very well be asking why we just don't dump our slides inside the parent gallery
    container, and the reason for this is so that we can extend our gallery with other
    functionality, such as a play and pause button, without compromising the structure
    of the slides themselves.
  prefs: []
  type: TYPE_NORMAL
- en: 'So let''s create another `div` inside our gallery that contains a class of
    `gallery-content`, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have a content area for our gallery, we want to make an unordered
    list of slides that contain our images. When we finally do this, our `gallery`
    markup should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you look at the preceding markup, you may be in shock that I left out content
    for the `alt` attribute on the `image` tag. Yes, this is a bad practice, but I
    do this here to move a bit quicker. However, you shouldn't do this in your applications,
    always give your images an `alt` attribute with relative content.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a basic markup structure we should start styling this slideshow,
    but keep in mind that the preceding markup is not end all, be all. I've seen some
    extraordinary work on other sites, and that's cool, but we want to keep things
    simple here and give you a foundation to build upon. I encourage you to experiment
    and try new things out, but don't let the preceding markup be the final solution
    for you. Before we get to styling this, let's take a step back and understand
    why we have a content area.
  prefs: []
  type: TYPE_NORMAL
- en: Adding simple gallery controls
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We don't want to complicate the styling for the content area. If we do, this
    can lead to some messy styling that "fixes our markup". For this reason, we created
    a content area and are now going to add a `controls` group to our slideshow.
  prefs: []
  type: TYPE_NORMAL
- en: So let's follow the same principle; let's create a `div` with a class of `gallery-controls`
    that contains two anchor tags, one for the next button and another for the previous
    button.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Now, both the content area and the control are two separate areas that can be
    controlled independently. You'll see how this makes things easy for us when we
    start styling our gallery. For now, trust me, this will make it simpler for you
    to control your gallery. But now, on to our styling!
  prefs: []
  type: TYPE_NORMAL
- en: Making images responsive
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We've gone over responsive design in the very first chapter of this book, and
    hopefully you do understand the principles. But if you don't, this chapter should
    give you a good idea of what we can do to make sure our application not only works
    on iPhone, but also on other touch devices as well.
  prefs: []
  type: TYPE_NORMAL
- en: So let's say we want our gallery to exist on mobile and desktop versions of
    our site, which is a highly desirable feature because now you are building a component
    that is reusable and device agnostic. But this also makes things difficult, not
    taking into account asset management, we need to calculate how big our images
    must be. Well, for this example, we want our images to scale to 100 percent of
    the slideshow's width, we want the slideshow to take up 100 percent of our screen
    width, and have 12 pixel padding on the sides.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to accomplish this, we can simply set the width of all images to 100
    percent and have our gallery apply padding of 12 pixels on the sides, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Note that our gallery will already take 100 percent of our screen width, minus
    the padding we give it on the sides. For this reason you don''t see a property
    of `width: 100%` in `.gallery`. Also, take into account that we added 12 pixels
    to the top of the gallery to give it some room from the main navigation. And last
    but not least, we are using shorthand properties here, so that we don''t use padding-left,
    margin-top, and so on. This makes our code, not only shorter, but easier to understand
    and maintain.'
  prefs: []
  type: TYPE_NORMAL
- en: This is all that's needed to make a responsive gallery using CSS, the rest of
    the styling will be applied via JavaScript. Some of you may balk at this, but
    it's a fairly used technique because we need to know the device's width in order
    to set our gallery correctly for responsive use. But before we get to that, let's
    start out by finishing up the styling for our gallery.
  prefs: []
  type: TYPE_NORMAL
- en: Styling our gallery
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now let's finish up the styling for our gallery in the CSS. Some of this will
    still apply for responsive applications, but the previous section helps define
    the principles. Don't worry though; I'll go over the styling for each part of
    this application so that you can understand it thoroughly.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s make sure our gallery content scales to 100 percent in width,
    and because eventually our slides will float left, we want the parent container
    to have a height; so let''s add a property of `overflow: hidden`. When you''re
    done, your styles should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we want to make sure that the unordered list also has a height for when
    the slides are floated left, so that this height gets applied to the gallery content.
    Not only that, but because we want to animate the unordered list left or right,
    based on user interaction, we need to make sure the position and starting `left`
    value are defined. When you''re done applying this styling, it should look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here we've also applied a `0` value to `margin` and `padding`. This is mostly
    a reset so that we don't run into any layout issues later on. `Normalize.css`
    applies some `padding` and `margin` to unordered lists by default, and this is
    good but not necessary for our application so we wipe out those values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s focus on styling the controls of our slideshow. This next step
    is mostly a setup style, so that we don''t run into any issues when we float elements
    within a container; such as what we did for the `gallery` content and unordered
    list previously. So let''s make sure `overflow` is set to `hidden` for our controls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Since our controls are now set to `hidden` when elements overflow, we can float
    our next and previous buttons accordingly so that they are on the appropriate
    side of the slideshow.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This is all that's needed to get the basic styling done for your slideshow.
    Unfortunately it still doesn't look pretty, and that's because we need to use
    JavaScript in order to determine the screen size, apply widths to our slides,
    and an overall width to our unordered list. However, there's one more thing we
    can do here that brings some serious performance optimization to our application,
    and that's using CSS3 transitions.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we move on, it's important to note that our CSS selectors are cascading
    from the `gallery` `div`. This is a good practice because it allows you to compartmentalize
    your styles. What we are doing is basically creating default styles for our gallery,
    and if anyone wanted to customize it, they could add their own class before `.gallery`
    to override these styles, allowing the gallery to be much more customizable. This
    is a basic CSS fundamental, but I thought I'd point it out in order to show the
    importance of creating styles that are modular.
  prefs: []
  type: TYPE_NORMAL
- en: Using CSS3 transitions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: CSS3 transitions are extremely important to our applications. Not only because
    it makes things easier for us, but also because it gives us performance optimization.
    By default, mobile Safari uses hardware acceleration for CSS3 transitions; what
    this means is that the hardware will handle the rendering of these transitions,
    and as such we won't need to do it manually. Traditionally, we needed to do this
    using JavaScript, and because of that we gained no performance optimization, but
    now we do with CSS3 transitions. So let's use them!
  prefs: []
  type: TYPE_NORMAL
- en: This is a basic gallery, and we want to keep it simple. So let's just add our
    transition to the unordered list. After all, the unordered list is what we want
    to animate when the user swipes or initiates an action from the controls. To do
    this, we will use the `transition` property and use shorthand to define what property
    we want to animate, how long, and what transition-timing-function, otherwise known
    as easing method, to use.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The only thing we have done here is added the `transition` property to our unordered
    list. This property tells the unordered list to animate the `left` property within
    500 milliseconds and to use the default easing method.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here we are defining five transition properties, each one being prefixed to
    the browser vendor while the last is the supported standard property. This is
    done so that our gallery is usable across devices. Yes, it's a bit complicated
    and messy, but it is a necessary evil given the fact that browser vendors have
    prefixed this property and only now have begun to use the non-prefixed version.
  prefs: []
  type: TYPE_NORMAL
- en: Gallery interactivity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The heart of our slideshow lies in its interactivity; from next and previous
    buttons, swipeable content and animation rich displays—our slideshow is dependent
    on JavaScript. In this section we dive deep into what makes our slideshow work;
    using our basic framework, we'll build a `Gallery` class that is efficient and
    achieves the goals stated previously. In reality, our gallery should just have
    functionality that allows it to resize and play in a certain direction. But, as
    always, this takes some setup work and then we hook everything up. So let's get
    started!
  prefs: []
  type: TYPE_NORMAL
- en: The basic template
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First, we''ll create our `Gallery` class. This class should be set up in the
    same way as any other class we''ve built. But in case you haven''t been following
    the book in order, all we need to do is check for the `App` namespace and then
    create a `Gallery` class underneath it. Wrapped in a closure, we''ll have some
    defaults and a `Gallery` function, and return it at the end of the closure declaration.
    As we have mentioned previously, we''ll have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The only thing that is different here is that we are only passing in the `Zepto`
    object. Previously, we were passing in `window` and `document`, but for this class
    we won't need those two objects, so we limit it to the Zepto library.
  prefs: []
  type: TYPE_NORMAL
- en: That's all we need for now, but what's more critical is to cache the elements
    we will be re-using, plus they will need to be available in the closure so that
    they are available in private and public methods.
  prefs: []
  type: TYPE_NORMAL
- en: Caching the gallery
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Caching objects is extremely helpful in our applications, especially since it
    increases the performance and makes our app extremely efficient. By cutting down
    on the number of lookups we need to do in the DOM, we allow for faster processing
    and create a less error-prone application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Not only do we want to cache certain elements, but we want them to also be
    available in the closure so that they are accessible by all methods. To do this,
    all we need to do is add the cached variables after the `_defaults` variable located
    above our construct, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we can see that the gallery, its slides, the container
    of the slides, the number of slides, gallery controls, and slide and gallery width
    will be cached. However, at this point in time we haven't cached anything. So
    let's start assigning them the values they should have.
  prefs: []
  type: TYPE_NORMAL
- en: 'The best place to initialize your values would be in the constructor, or when
    you create an instance of a gallery. The constructor should go ahead and cache
    the values we need for the rest of the running application. On top of that, each
    variable semantically describes what it should be holding, making it easier for
    you to understand what''s going on. Let''s take a look at the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: From this function we can gather that we cache the gallery, and from that all
    other values are determined. For example, we use `$gallery` to find all the slides,
    or list items. This is extremely useful, because what we are doing is telling
    our application to begin with the `gallery` element and then dive into it to find
    the appropriate values. Otherwise, we would typically begin at the top of the
    document and then go down, which is extremely costly when it comes to DOM lookups.
  prefs: []
  type: TYPE_NORMAL
- en: This is a critical step in the process, because everything else should be easy
    as pie. So let's start hooking up some interactivity!
  prefs: []
  type: TYPE_NORMAL
- en: Connecting our controls
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First, we want the user to be able to click on the next and previous buttons.
    However, we don't want anything to happen just yet, we just want to capture those
    events. As always let's start small and then work up, what we want to do is have
    a foundation to work with.
  prefs: []
  type: TYPE_NORMAL
- en: Attaching the events
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We''ve previously gone over how to attach events, and in this chapter it''s
    no different. So first create an `attachEvents` method that looks up the next
    and previous buttons from the gallery and then calls a `play` method. When you''re
    done writing the code, you should have something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Nothing is different here. We use the cached `$galleryControls` variable and
    tell it to listen to the `click` event coming from our next and previous buttons.
    When that `click` event comes from the designated element, then call our `play`
    method. If we run our code now, nothing would happen, except that we would probably
    get an error because `play` does not exist. But let''s not do that; instead we''ll
    call our `attachEvents` method in our constructor after all of the setup code
    takes place:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Nothing crazy here, we're just calling `attachEvents`, a private method. Did
    you notice how we are using `$galleryControls` even though it's a private method?
    That's because that variable exists within the closure scope, so this makes it
    easier to manage variables without polluting the global scope of the program.
    If you don't yet understand what's going on here, don't worry. With time and practice
    this will make sense and things will just be that much easier.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we still have a problem. There is no `play` method, so let's create it!
  prefs: []
  type: TYPE_NORMAL
- en: Handling our events
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Because our `play` method does not exist, our application fails; so we need
    to write it. But what should it do? Well, for this application, we want it to
    determine the direction in which the gallery should play. Then we want it to animate
    left or right based on the current position in which the gallery is located. You
    might be saying, that sounds easier than you think. But in reality it is. So let's
    go step-by-step.
  prefs: []
  type: TYPE_NORMAL
- en: Caching variables, again
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Yes, we want to cache as much as possible. Again this is a mobile application
    we are creating for iPhone and because of the nature of mobile, we need to optimize
    where we can. But what should we be caching? Well, the first thing we''ll be checking
    is direction, and then manipulating a current left position of the unordered list.
    To prevent lookups of these values, let''s just state a `currentLeftPos` and direction
    at the top of the method, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Simple! Now, let''s determine these values. An easy way to determine direction
    is to have it based on the value of the element clicked. In this case, we can
    check for #next or #previous, the values of the `href` attributes. To make it
    simpler, we may want to remove the hash tag as well, just in case we ever wanted
    to expose this method and allow ourselves to pass in `next` or `previous`. So
    let''s do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Don't worry too much about the details here, but essentially since `play` is
    an event handler, `this` has become the target event, which would be our anchor
    tag. This is how we can get the `href` value from those elements. Also, don't
    be too nervous about the string manipulation going on there. Basically we are
    using `substr`, a built-in `string` method, and passing it `1` so that it starts
    at position one and then gets the rest of the string. This is how we are able
    to get the word next or previous from the `href` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'Great, at this point we have determined the direction. Now we want to get the
    latest left position of the unordered list. To do this, we can add the following
    bit of code after we''ve set the direction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that we are using `parseInt`, a built-in number method that accepts an
    integer as its first parameter and then the base as its second. We do this because
    when we request the value of the `left` property, we get something like `0px`,
    and we want the value that we are using to be an integer, not a string. So `parseInt`
    helps us out by taking `0px` and interpreting it as an integer of `0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now it''s time to create the magical part of our application. This part is
    a bit complex, but in the end will help us achieve the effect we are looking for.
    But let''s first focus on getting our application to move on the next call to
    action. To do this, we want to set the left position of the unordered list to
    the current left position minus the width of a single slide. To do this, we can
    simply write the following code after the setting of `currentLeftPos`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will do exactly as we ask it; however, there are a couple
    of issues we run into. First, this will always run, even if the previous button
    is hit. Two, there''s no check for when you have reached the very end of your
    gallery. This can easily be added to our application like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You may have noticed that we are using `Math.abs` on the `currentLeftPos`. That
    is because we'll be getting a negative number as our value, and since we don't
    want to complicate the math or comparison, we simply turn it into a positive integer
    using `Math.abs`. Keep it simple!
  prefs: []
  type: TYPE_NORMAL
- en: In this adjusted code we check the direction, looking for `next`, and then checking
    to make sure the current left position is less than the gallery width minus a
    single slide's width. This helps prevent any errors that might come up.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now on to implementing our `previous` functionality. For this step, we''ll
    follow the same procedure; we''ll make sure we want to go in the `previous` direction,
    then we''ll do a comparison to make sure we don''t go below the `0` mark, and
    finally we''ll execute the code if the conditions have been met. When we''re done
    implementing this functionality, we should have the following bit of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The only difference here is that we are comparing against the static number
    `0`. This is to prevent any positive values that will cause a visual error in
    our gallery. Then instead of negating our numbers, we use the correct values in
    order to add to a negative number, thus giving the appearance of a `Previous`
    action.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the end, our `play` method should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Are we done? Yes we are! Even though we are only switching the left position
    value of our unordered list. We are actually animating because, if you remember,
    we've told our element to transition the left property within our CSS. See how
    easy and effective using CSS3 properties is? With a simple declaration we have
    been able to minimize code and make a highly optimized version of our gallery.
  prefs: []
  type: TYPE_NORMAL
- en: Now, that we have the core of our gallery completed, let's make it responsive!
  prefs: []
  type: TYPE_NORMAL
- en: Gallery responsiveness
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We're going to side-step here a bit, but it's worth the necessary effort! In
    this step, we're going to look into making our gallery responsive to our user's
    device's width. So let's get started by setting our styles.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the gallery styles
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Here we''re going to set all the styles necessary to make our gallery responsive.
    There are a couple of things we need to do. First, let''s create a public `setStyles`
    method using the `Gallery` function''s `prototype`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding method, as you may have noticed, returns the instance of `Gallery`
    and thus allows you to chain your methods. Next, get an individual slide''s width.
    This width is 100 percent of the container it''s in, so it should be of the same
    width as the gallery itself. To get this width we can do the following within
    `setStyles`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can determine the full width of the gallery by multiplying the number
    of slides by the width each is set to, which we''ve already determined in the
    previous step. When we do this, we achieve the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This following step may be confusing, however it is critical because we need
    to manually set the width of each slide in order to float them next to each other.
    So what we need to do now is apply the `slideWidth` value to each slide, like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can also set the width of the slides container using the calculate
    gallery width. Again, we need to do this in order to keep a gallery that has slides
    which are floated to the left. So we''ll set the slide container''s width and
    then float all our slides to the left. Your `setStyles` method will look like
    this, when we code these requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This is all it takes in order to set our gallery's styles in a responsive manner.
    However, there's one issue here; the styles cannot reset, which is needed in order
    to determine the widths of the slides and containers appropriately when the device's
    orientation or width changes in some way. Let's do some setup work in order to
    get this reset going.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we''ll simply wrap our functionality within a method that we then
    pass to a public `resetStyles` method. In this technique, we are essentially sending
    in a `callback` that will get executed when `resetStyles` functionality has finished
    taking place. For now, your code should result in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, all the functionality we originally created for `setStyles`
    has been wrapped in an anonymous function, also known as a `callback`, that will
    get called when `resetStyles` is done running. To get the full picture, let's
    continue on by creating our `resetStyles` function.
  prefs: []
  type: TYPE_NORMAL
- en: Resetting the gallery styles
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Resetting an element's style is actually not that complicated, so we'll go head
    first into this method. Check out the following code that should be within your
    `reset` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Not too crazy right? We are basically just removing the inline styles that Zepto
    applies when we set an element's style using JavaScript, or what we've done in
    our `setStyles` method. When we remove these styles, we then check for a `callback`
    method and execute that method. This is a good practice because, let's say we
    need to reset the styles of our gallery for any other reason; we don't want to
    create unnecessary functions for no reason.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing the gallery styles
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The last thing we need to do is initialize our styles. To do this, let's call
    `setStyles` when our code initializes in the `Gallery` constructor.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'When we finally have our styles in place, our application should look like
    the following in the portrait mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Initializing the gallery styles](img/1024OT_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Responsive gallery
  prefs: []
  type: TYPE_NORMAL
- en: 'In landscape mode, our application should like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Initializing the gallery styles](img/1024OT_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Responsive gallery
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Unfortunately, your application won't look or behave like the one shown in these
    screenshots; this is because nothing is hooked up right now and we haven't even
    gone through initializing any of our code. But if you do want to get to that immediately
    and see how we do it, you can check out the last section in this chapter, right
    before our conclusion. If you follow those steps, you should have an application
    that will look similar to what we have just seen.
  prefs: []
  type: TYPE_NORMAL
- en: Technically, our gallery is now completely built and we can now fully interact
    with it using our next and previous buttons. But now, it's on to the fun we've
    all been waiting for, touch events!
  prefs: []
  type: TYPE_NORMAL
- en: Extending the gallery for touch
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We could, by default, include touch interactivity into the `Gallery` class,
    but this wouldn't be reusable and couldn't be applied to other parts of the application.
    So in this section we'll create a new class called `Swipe`, and it will contain
    everything that's needed to detect swiping gestures on a specific module.
  prefs: []
  type: TYPE_NORMAL
- en: The basic template
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As always we want to start out with our basic framework, similar to the other
    classes we''ve written before. To get started we can write the following basic
    template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The `Swipe` class is a bit different from our `Gallery` class in that it accepts
    the `window`, `document`, and `Zepto` objects. Another difference is that the
    `Swipe` constructor accepts one parameter called `options`, used to override default
    values that we will set soon.
  prefs: []
  type: TYPE_NORMAL
- en: Default options and modularizing swipe events
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a couple things we want to do inside the `Swipe` class. First, we
    want to make sure it only applies to the particular container and not the entire
    document. Then, we want to be able to cache certain values like the initial x
    position of the touch and the end x position. These cached values should also
    be available in the closure scope, so that they are available across all methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the defaults we would like to have and the cached values that will
    be available in the closure''s scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: What we're basically saying in the preceding code is that the default element,
    the swipe functionality, should be attached to is the document's `body` element.
    From here we make sure that we can access these cached elements in the closure's
    scope. Finally we set up some variables that will store the information about
    the touch gesture we will be listening for.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now in our constructor we want to override these defaults and make sure some
    of these initial values will exist in the global scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Here we are using Zepto's `extend` method to create a new object that contains
    a merge of the options parameter into the defaults object. We then make sure that
    the closure's scope contains the cached element the swipe class will be attached
    to. Finally we check if a custom threshold was passed in and override the default
    30\. After all this, we call an initialize method at the end of the constructor
    so that the Swipe class starts automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Listening to touch events
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now we need to attach the appropriate events to the `Swipe` class. These events
    will be based on the touch events we covered earlier, but they will be used in
    such a way that mimics swipe gestures. To achieve this, we first need to listen
    to the `touchstart`, `touchend`, and `touchmove` events and assign event handlers
    to each of these. We can do all of this inside the `init` method that we are calling
    from the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'So first let''s create our `init` method on the Swipe''s `prototype`, and let''s
    make sure we are returning the instance at the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside this method we want to listen to the touch events mentioned previously
    and make sure they have event handlers. To do this, we''ll use Zepto''s `on` method
    and attach the events to the element we''ve cached:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code we pass in the event as a string to the `on` method's
    first parameter, and then assign an event handler, which we have not yet created.
    What you'll also notice is that these methods are chainable, allowing us to attach
    several events all at once. This is why we return `this` at the end of our public
    methods, so that we can allow ourselves to make calls synchronously.
  prefs: []
  type: TYPE_NORMAL
- en: Handling touch events
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now we need to create the event handlers we've assigned to each listener. We'll
    go through one handler at a time so that we can explain how the swipe gesture
    is created from these touch events. The first we want to look at is the `touchstart`
    handler.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we place our finger on the phone, the first thing we want to do is store
    the initial x position of the finger. To access this information, there is a `touches`
    array on the event triggered. Because we only want to use the first touch, we
    need to access the first touch in the `touches` array. Once we get the first touch,
    we can get the x position by using the `pageX` attribute on that object. This
    is what the functionality for `handleTouchStart` will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: As you can see the `handleTouchStart` method accepts one parameter, the event
    object. We then set `initXPos` to the `pageX` attribute on the first touch in
    the `touches` array on the event object. That might sound like a huge mess, but
    basically we are just accessing the objects we need to in order to hold the initial
    x value of your touch.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we want to create the `handleTouchMove` event handler. This handler will
    contain the same concepts as `handleTouchStart`, but instead of the initial x
    position, we want to update the ending x position. This can be seen in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: There are a couple of differences here that I'll explain. First, we prevent
    the default behavior of a touch move. This is to stop any weird behavior from
    happening and is usually suggested when we want to create a unique experience,
    such as a swipeable gallery.
  prefs: []
  type: TYPE_NORMAL
- en: Another difference you'll notice is that we are looking into the `changedTouches`
    object on the event. This is because the `move` event does not contain a `touches`
    object. Although a bit contentious, this helps keep track of each touch and the
    changed attributes of that specific touch. So if I had multiple touches, then
    my `changedTouches` object would contain each changed touch appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: Up until now, all we have done is set the initial and ending x position. Now
    we need to use those values to create a `delta` value that is then used to trigger
    a swipe in the left or right direction. This is what our `handleTouchEnd` event
    handler will be doing for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the code that `handleTouchEnd` should contain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Now let's go over this code, one line at a time. First we do the exact same
    thing that `handleTouchMove` does, and that's setting the end x position. Next,
    we set our delta value, which is the difference calculated by subtracting the
    end x position from the initial x position. Now we do a comparison; if the delta
    is larger than the threshold, then trigger a custom event called `SwipeLeft`.
    Our next comparison is a bit more confusing but basically we check to see if the
    `delta` value is less than a negative threshold. This is so that we can detect
    a swipe in the right direction.
  prefs: []
  type: TYPE_NORMAL
- en: Our `Swipe` class is now complete. We have created the necessary functionality
    that listens to our touch events and then mimics a gesture that we can tie into
    to. But we haven't actually connected it to our gallery, which is the last step
    in the process. Feel proud that you've reached this point, because now the easy
    stuff happens!
  prefs: []
  type: TYPE_NORMAL
- en: Putting it all together
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Okay, so at this point we have a gallery and the ability to detect swipe gestures
    using touch events. But right now, nothing is really connected, and in fact we
    haven't initialized our `Gallery` class so nothing should be working right now.
    But this is what this last section is about; we'll go through initializing our
    `Gallery` class, adding the `Swipe` functionality and then reacting to our swipe
    events.
  prefs: []
  type: TYPE_NORMAL
- en: The JavaScript
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first thing we want to do is open our `App.Touch.js` file, as you recall
    this file pertains to the functionality of our touch page and thus is the file
    that will contain all our initialization. When we have this file open, go to the
    `init` method, or if it''s not created already, then create it and initialize
    an instance of `Gallery`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have initialized our `Gallery` class, the gallery should instantly
    initialize. But keep in mind we have not modified our markup to include this file.
    So even at this point, you won''t see the fruits of your labor. But let''s make
    sure we continue the setup work. In this next step, we want to initialize our
    `Swipe` class and make sure it sets itself to the `gallery` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, even at this point our gallery does not respond to swipe events. That
    is because our swipe functionality only detects touches and dispatches those custom
    events we set up previously, so what we need to do is listen for those events
    on the gallery and then tell it to play the next or previous slide:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we listen for the `SwipeLeft` and `SwipeRight` events
    that get dispatched by our instance of swipe. When either event is dispatched,
    based on the event, we simulate a click on either the previous or next button.
    In this way we are able to give the appearance that the user is swiping throughout
    our gallery, while at the same time eliminating any kind of complications.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you are done writing your `init` method, it should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The markup
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The final item that needs to be taken care of is the markup on the page—the
    scripts being included. To make things simpler and get you to finally run your
    application correctly, here''s what you need to include on your page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The difference here, compared to other pages, is that we are only including
    the items we need, including `App.Nav.js`, `App.Gallery.js`, `App.Swipe.js`, and
    `App.Touch.js`. In comparison to other pages, we were including the entire framework,
    but we don't really need to do that for this page or any pages moving forward.
    One thing to note is that we have also created a global touch object that gets
    set to an instance of our `App.Touch` class. This is so that we can reference
    it in the debugger easily, but this should be replaced with `App.touch`, so that
    it is not polluting the global namespace.
  prefs: []
  type: TYPE_NORMAL
- en: We've reached the end! At this point you should have a fully functional gallery
    that has swipeable interactivity. Now pat yourself on the back; it's been a long
    journey, but I hope you can appreciate the fact that we have created reusable,
    modular code that is completely self-contained. On top of that, our gallery is
    completely responsive and adapts to users' devices, allowing them to enjoy the
    experience consistently.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we have restyled our main navigation, gone over the fundamentals
    of both touch and gesture events, and then implemented both types of events using
    a responsive photo gallery that will adapt to the user's device. We have also
    gone through attaching these events and handling them appropriately for our requirements
    in the slideshow. From here on out you should have a good understanding about
    how to use touch events to create unique experiences on the iPhone, as well as
    on other mobile devices. Next, let's take a look at some special interactions
    that come with handling forms in HTML5 on the iPhone.
  prefs: []
  type: TYPE_NORMAL
