- en: '*Chapter 3*: Implementing Matrices'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the context of game animation, a matrix represents an affine transformation.
    It linearly maps points from one space to another. A mesh is represented by vertices,
    which are just points in space. These vertices are moved by multiplying them by
    a matrix.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn matrix math and how to implement matrices in
    code. By the end of this chapter, you will have built a robust matrix library
    that can be used in any project. Matrices are important; they play a big role
    in the graphics pipeline. It's hard to render anything without using matrices.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will only need to implement a square, 4 x 4 matrix. By the end of this
    chapter, you should be able to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Understand what a matrix is
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand column-major matrix storage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiply matrices together
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Invert a matrix
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transform points and vectors by using a matrix
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand how to create matrices to view a three-dimensional world
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Important information
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will implement a 4 x 4 matrix. The matrix implementation
    will rely on code to demonstrate concepts, rather than through the format of math
    definitions. If you're interested in the formal math behind matrices, check out
    [https://gabormakesgames.com/matrices.html](https://gabormakesgames.com/matrices.html).
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are two samples provided in the downloadable materials for the book for
    this chapter. `Sample00` shows the matrix code as it is written throughout the
    chapter. `Sample01` shows an alternative implementation that uses explicit lower-order
    matrices to implement the matrix inverse function.
  prefs: []
  type: TYPE_NORMAL
- en: What is a matrix?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A matrix is a two-dimensional array of numbers. A square matrix is one whose
    width and height are the same. In this chapter, you will implement a 4 x 4 matrix;
    that is, a matrix with four rows and four columns. The elements of this matrix
    will be stored as a linear array.
  prefs: []
  type: TYPE_NORMAL
- en: A 4 x 4 matrix can be thought of as four vectors that have four components each,
    or an array of `vec4s`. If the vectors represent the columns of the matrix, the
    matrix is column-major. If the vectors represent the rows of the matrix, it is
    row-major.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming a 4 x 4 matrix contains the letters *A, B, C, D â€¦ P* of the alphabet,
    it can be constructed as either a row- or column-major matrix. This is demonstrated
    in the following *Figure 3.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1: Comparing row- and column-major matrices'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.1_B16191.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.1: Comparing row- and column-major matrices'
  prefs: []
  type: TYPE_NORMAL
- en: 'Most math books and OpenGL use column-major matrices. In this chapter, you
    will be implementing column-major matrices as well. Understanding what is in a
    matrix is important. The diagonal of the matrix contains scaling information,
    and the final column contains translation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2: What is stored in a matrix?'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.2_B16191.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.2: What is stored in a matrix?'
  prefs: []
  type: TYPE_NORMAL
- en: The upper 3 x 3 submatrix contains three vectors; each of these is a basis vector
    for the matrix's rotation. The basis vectors are the up, right, and forward directions
    stored in the matrix. You might have noticed that the rotation and scale components
    occupy the same space in the matrix.
  prefs: []
  type: TYPE_NORMAL
- en: Matrix storage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you know that the matrix layout is going to be column matrices, the
    next question is how to store the actual matrix. Matrix storage is a confusing
    topic.
  prefs: []
  type: TYPE_NORMAL
- en: Since a matrix is stored in memory as a linear array, let's figure out what
    elements should be placed where. A row-major matrix is stored in memory one row
    at a time. A column-major matrix is stored one column at a time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since both row- and column-major matrices contain the same vectors, the final
    linear mapping ends up being the same, regardless of the major of the matrix.
    The following *Figure 3.3* demonstrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3: Matrix storage mapping to a linear array'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.3_B16191.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.3: Matrix storage mapping to a linear array'
  prefs: []
  type: TYPE_NORMAL
- en: The matrix class you will be building is a column-major matrix with column storage;
    this means there will be a discrepancy between the physical memory layout of the
    matrix and the logical placement of its elements. It's easy to treat a matrix
    with a linear memory layout as a row matrix but remember that each of those rows
    is actually a column.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The typical mapping of a two-dimensional grid to linear storage is `"row * numberOfColumns
    + column"`. This mapping won't work for storing a column-major matrix. When looking
    at a matrix, the element in column 2, row 3 should have a linear index of 7, but
    the previous mapping yields 14\. Instead, to account for the column-major storage,
    the mapping formula is `"column * numberOfRows + row"`.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding how a matrix is stored in memory is important, it's going to affect
    how data is stored and how APIs can access that data. In the next section, you
    will start to implement a matrix structure.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a matrix
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, you will create a new 4 x 4 matrix. This matrix will be stored
    as a 16-element array of floats. A union will be used to allow access to the data
    in the matrix in an easier-to-use fashion:'
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The identity matrix is a special matrix that multiplies anything by the identity
    matrix results in the original matrix. The identity matrix does no mapping. An
    identity matrix contains 0 in all elements except the main diagonal, which is
    made up entirely of 1.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file, `mat4.h`. This file is needed to declare the `mat4` struct.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following structure declaration to `mat4.h`, which starts a union by
    declaring a flat array of 16 elements as the first member of the union:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The next member of the union is a structure of `vec4` variables. Each of the
    `vec4` variables represents one column of the matrix; they are named after the
    basis vector stored in those columns:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'It might be useful to access members by element based on the basis vector.
    The following struct contains named pairs; the first letter represents the basis
    vector and the second letter represents the component of that vector:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The next struct will allow you to access the matrix using column-row notation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The final struct will allow you to access the matrix using row-column notation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Add an `inline` constructor that will create the identity matrix:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Add an `inline` constructor that will create a matrix from a float array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Add an `inline` constructor that will let you create a matrix by specifying
    each element inside the matrix:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The matrix struct you just declared is the final `mat4` struct; the anonymous
    union provides five different ways of accessing matrix data. Matrix data can be
    accessed as a flat array, as four columns each stored as `vec4`, or as one of
    three mnemonics. The three mnemonics name elements using their basis vectors,
    their row and then column, or their column and then row.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you will start working on functions that operate on the `mat4` structure.
    You will implement common matrix operations, such as adding, scaling, and multiplying
    matrices, and see how to use matrices to transform vectors and points.
  prefs: []
  type: TYPE_NORMAL
- en: Common matrix operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you will learn how to implement some common matrix operations.
    These operations will be used in later chapters of this book to display animated
    models. Specifically, this section will cover how to compare, add, scale, and
    multiply matrices as well as how to transform vectors and points using matrices.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing matrices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Comparing matrices is a component-wise operation. Two matrices are the same
    only if all their components are the same. To compare two matrices, loop through
    and compare all of their components. Since you are comparing floating point numbers,
    an epsilon should be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file, `mat4.cpp`. Implement the matrix equality and inequality
    operators in this file. The equality operator should check whether two matrices
    are the same; the inequality operator returns the opposite of the equality operator.
    Don''t forget to add the function declarations to `mat4.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The `MAT4_EPSILON` constant should be defined in `mat4.h`. `0.000001f` is a
    good default value to use.
  prefs: []
  type: TYPE_NORMAL
- en: When comparing matrices by component, you are checking for literal equality.
    There are other ways to define matrix equality; for example, regardless of shape,
    the volume of two matrices can be compared using their determinants. Matrix determinants
    will be covered later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you will learn how to add matrices together.
  prefs: []
  type: TYPE_NORMAL
- en: Adding matrices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Two matrices can be added together by component. To add two matrices together,
    sum their respective components and store the result in a new matrix. Matrix addition
    can be used with scalar multiplication to interpolate or blend between multiple
    matrices. Later, you will learn how to use this property to implement animation
    skinning.
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement the matrix addition function in `mat4.cpp`. Don''t forget to add
    the function declaration to `mat4.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Matrix addition is simple but it will play a big role in displaying an animated
    mesh. In the next section, you will learn how to scale a matrix by a scalar value.
  prefs: []
  type: TYPE_NORMAL
- en: Scaling a matrix
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Matrices can be scaled by floating point numbers; this kind of scaling is a
    component-wise operation. To scale a matrix, multiply every element by the provided
    floating point number.
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement matrix scaling in `mat4.cpp`. Don''t forget to add the function declaration
    to `mat4.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Scaling matrices and then adding them allows you to "lerp" or "mix" between
    two matrices, so long as both matrices represent a linear transform. In the next
    section, you will learn how to multiply matrices together.
  prefs: []
  type: TYPE_NORMAL
- en: Matrix multiplication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Matrix multiplication combines the transformation of two matrices into one
    matrix. Two matrices can only be multiplied together if their inner dimensions
    are the same. The following are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: A 4 x **4** and a **4** x 4 matrix could be multiplied together, since both
    inner dimensions are 4.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A 4 x **4** and a **4** x 1 matrix could be multiplied together, since both
    inner dimensions are 4.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A 4 x **4** and a **1** x 4 matrix could not be multiplied together, since the
    inner dimensions, 4 and 1, don't match.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The resulting matrix from a matrix multiplication will have the outer dimensions
    of the matrices being multiplied together. The following is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: A **4** x 4 and a 4 x **4** matrix would yield a 4 x 4 matrix.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **4** x 4 and a 4 x **1** matrix would yield a 4 x 1 matrix.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **1** x 4 and a 4 x **2** matrix would yield a 1 x 2 matrix.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assume there are two matrices, *A* and *B*. Matrix *A* translates 10 units on
    the *X* axis. Matrix *B* rotates by 30 degrees around the *Y* axis. If the matrices
    where to be multiplied as *A * B*, the resulting matrix would rotate by 30 degrees
    around the *Y* axis then translate 10 units on the *X* axis.
  prefs: []
  type: TYPE_NORMAL
- en: Matrix multiplication is not cumulative. Consider the last example but multiply
    *B * A*, instead. When multiplying *B * A*, the resulting matrix will translate
    10 units on the *X* axis and then rotate 30 degrees around the *Y* axis. Multiplication
    order matters; *A * B* is not the same as *B * A*.
  prefs: []
  type: TYPE_NORMAL
- en: This brings up a new questionâ€”what order should matrices be multiplied together
    in? If *M = A * B * C*, in what order do those matrices concatenate? *A*, *B*,
    and then *C* or *C*, *B*, and then *A*? If it's *A*, *B*, and then *C*, the matrix
    multiplication is defined as left to right. But if it's *C*, *B*, and then *A*,
    the matrix multiplication is right to left.
  prefs: []
  type: TYPE_NORMAL
- en: To maintain consistency with OpenGL, in this chapter you will be implementing
    right-to-left multiplication. But how are two matrices multiplied together? Each
    element of a matrix has a row and a column. The resulting value for any element
    is the dot product of that row from the left matrix and that column forms the
    right matrix.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, suppose you want to find the value of the element in row 2 column
    3 when multiplying two matrices. This means taking the dot product of row 2 from
    the left-hand side matrix and column 3 from the right-hand side matrix. *Figure
    3.4* demonstrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4: Multiplying matrices'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.4_B16191.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.4: Multiplying matrices'
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed, in the previous figure, that even though the matrices
    are column-major, the subscript of the elements appears as row first, then column.
    The subscript references the physical topology of the matrix; it has nothing to
    do with what is stored in the matrix or how the matrix is laid out. Subscript
    indices remain the same, no matter what major the matrix is. Perform the following
    steps to implement matrix multiplication:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To keep the code for multiplying matrices short, you will need to create a
    helper macro. This macro will assume that there are two matrices, `a` and `b`.
    The macro will take two numbers, the row of `a` and the column of `b`, to dot
    together and the result will bet the dot product of the two. Define the `M4D`
    macro in `mat4.cpp`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'With the `M4D` macro in place, implement the matrix multiplication function
    in `mat4.cpp`. Don''t forget to add the function declaration to `mat4.h`. Remember
    that the `(2, 1)` element, for example, should take the dot product of row `2`
    from matrix `a` and column `1` of matrix `b`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The most important property of matrix multiplication is that it combines the
    transformation encoded in both matrices into a single matrix. This is useful because
    you can pre-multiply certain matrices to perform fewer multiplications per frame.
    Next, you will learn about how matrices can apply their transformation data to
    vectors and points.
  prefs: []
  type: TYPE_NORMAL
- en: Transforming vectors and points
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Transforming points and vectors is done in the same way as multiplying matrices.
    In fact, the vector being transformed can be thought of as a matrix with 4 columns
    and 1 row. This means transforming vectors is a matter of multiplying a 4 x 4
    and a 4 x 1 matrix together.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a matrix transforms a vector, it affects both the orientation and scale
    of the vector. When a matrix transforms a point, it just translates the point
    in space. So, what''s the difference between vectors and points? The *w* component
    of a vector is *0* and the *W* component of a point is *1*. The following steps
    will guide you through implementing matrix-vector multiplication:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To make the matrix-vector multiplication a little easier to read, you will
    need to once again create a macro. This macro will take the row of a matrix and
    perform a dot product of that row against the provided column vector. Implement
    the `M4VD` macro in `mat4.cpp`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'With the `M4V4D` macro in place, implement the matrix-vector multiplication
    function in `mat4.cpp`. Don''t forget to add the function definition to `mat4.h`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Most of the data in this book will be stored as three-component vectors, not
    four. There is no need to create a new four-component vector every time one needs
    to be transformed by a matrix; instead, you will create a specialized function
    for just this occasion.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Define a new function in `mat4.cpp`: `transformVector`. Don''t forget to add
    the function declaration to `mat4.h`. This function will take `vec3` and transform
    it using the provided matrix, assuming the vector represents the direction and
    magnitude:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, define the `transformPoint` function in `mat4.cpp`. It should multiply
    the vector and the matrix, assuming that the W component of the vector is 1:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Define an overload for `transformPoint` that takes an additional *W* component.
    The *W* component is a referenceâ€”it is a read-write. After the function is executed,
    the *w* component holds the value for *W*, if the input vector had been `vec4`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Throughout the rest of this book, most data is stored in `vec3` structures.
    This means `transformVector` and `transformPoint` will be used, rather than the
    overloaded multiplication operator. This should help reduce ambiguity as to what
    the data being transformed is. Next, you will learn how to invert a matrix.
  prefs: []
  type: TYPE_NORMAL
- en: Inverting a matrix
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Multiplying a matrix by its inverse will always result in the identity matrix.
    An inverted matrix has the opposite mapping of the non-inverted matrix. Not all
    matrices have an inverse. Only matrices with a non-zero determinant can be inverted.
  prefs: []
  type: TYPE_NORMAL
- en: Inverting matrices is an important operation; the view matrix that is used to
    transform three-dimensional objects to be displayed on-screen is the inverse of
    the camera's position and rotation. Another place where inverted matrices become
    important is skinning, which will be covered in [*Chapter 10*](B16191_10_Final_JC_ePub.xhtml#_idTextAnchor167)*,
    Mesh Skinning*.
  prefs: []
  type: TYPE_NORMAL
- en: Finding the inverse of a matrix is rather complicated as it needs other support
    functions (such as transpose and adjugate). In this section, you will build these
    support functions first and then build the inverse function after they have all
    been built. So firstly, we need to transpose the matrix.
  prefs: []
  type: TYPE_NORMAL
- en: Transpose
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To transpose a matrix, flip every element of the matrix across its main diagonal.
    For example, the *2, 1* element would become the *1, 2* element. Elements where
    both subscripts are the same, such as *1, 1*, will remain the same:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement the `transpose` function in `mat4.cpp`. Don''t forget to add the
    function declaration to `mat4.h`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `transposed` function in `mat4.cpp`. The `transposed` function modifies
    a matrix that is passed into it. Don''t forget to add the function declaration
    to `mat4.h`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Transposing a matrix is useful if you need to convert a matrix from row-major
    to column-major or the other way around. In the next section, you will learn how
    to calculate the determinant of a square matrix.
  prefs: []
  type: TYPE_NORMAL
- en: Determinant and minors of lower-order matrices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To find the determinant of a 4 x 4 matrix, it's important to first understand
    what the determinant and minor of lower-order matrices are. The determinant function
    is recursive; to find the determinant of a 4 x 4 matrix, we need to find the determinants
    of several 3 x 3 and 2 x 2 matrices as well.
  prefs: []
  type: TYPE_NORMAL
- en: The determinant of a matrix is always a scalar value; only square matrices have
    a determinant. The determinant of a matrix remains the same if the matrix is transposed.
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, you will learn how to find the determinant of 2 x
    2 matrices, the matrix of minors for any sized matrices, and the cofactor of any
    sized matrices. These methods are the building blocks of Laplace expansion, which
    you will use to find the determinant of any sized matrices.
  prefs: []
  type: TYPE_NORMAL
- en: A 2 x 2 determinant
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To find the determinant of a 2 x 2 matrix, subtract the product of the diagonal
    elements. The following diagram demonstrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.5: A 2 x 2 matrix and the formula for the determinant'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.5_B16191.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.5: A 2 x 2 matrix and the formula for the determinant'
  prefs: []
  type: TYPE_NORMAL
- en: Minor
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Every element in a matrix has a minor. The minor of an element is the determinant
    of a smaller matrix that eliminates the row and column of the element. For example,
    consider a 3 x 3 matrixâ€”what is the minor of element *2, 1*?
  prefs: []
  type: TYPE_NORMAL
- en: 'First, eliminate row 2 and column 1 from the matrix. This will result in a
    smaller 2 x 2 matrix. The determinant of this 2 x 2 matrix is the minor of element
    *2, 1*. The following diagram demonstrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.6: The minor of element 2, 1 in a 3 x 3 matrix'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.6_B16191.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.6: The minor of element 2, 1 in a 3 x 3 matrix'
  prefs: []
  type: TYPE_NORMAL
- en: This formula works for higher-dimension matrices as well. For example, the minor
    of an element in a 4 x 4 matrix is the determinant of some smaller, 3 x 3 matrix.
    A matrix of minors is a matrix where every element is the minor of the corresponding
    element from the input matrix.
  prefs: []
  type: TYPE_NORMAL
- en: Cofactor
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To find the cofactor of a matrix, first, calculate the matrix of minors. After
    the matrix of minors is known, multiply every element, *(i, j)*, in the matrix
    by *-1* to the *i + j* power. The value of Add -1(i+j)power forms a convenient
    checkerboard pattern with *+* always being at the top left:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.7: A checkerboard pattern of -1 to the i + j power'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.7_B16191.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.7: A checkerboard pattern of -1 to the i + j power'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding diagram shows the checkerboard pattern that Add -1(i+j) creates.
    Notice how the pattern always starts with a positive element in the top left.
  prefs: []
  type: TYPE_NORMAL
- en: Laplace expansion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The determinant (if one exists) of any square matrix can be found through Laplace
    expansion. To perform this, first find the cofactor matrix. Next, multiply every
    element in the first row of the original matrix by the corresponding element in
    the first row of the cofactor matrix. The determinant is the sum of these multiplications:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_03_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Adjugate
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The final operation before you can invert a matrix is to find the adjugate of
    a matrix. The adjugate of a matrix is the transpose of the cofactor matrix. Implementing
    the adjugate is simple since you already know how to find the cofactor of a matrix
    and how to transpose a matrix.
  prefs: []
  type: TYPE_NORMAL
- en: Inverse
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To find the inverse of a matrix, divide the adjugate of the matrix by its determinant.
    Since the scalar matrix division is not defined, you will need to multiply the
    adjugate by the reciprocal of the determinant.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will build a matrix multiplication function that uses macros
    to avoid the need for lower-order matrices. The `Chapter03/Sample01` sample in
    the downloadable materials for this book provides an implementation that utilizes
    lower-order matrices and is easier to work through with a debugger.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement a matrix inverse function, you will first need to be able to find
    the determinant and adjugate of a 4 x 4 matrix. Both functions rely on being able
    to find the minor of an element in the matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new macro in `mat4.cpp`. This macro will find the minor of one element
    in the matrix, given an array of floats, and three rows and three columns to cut
    from the matrix:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'With the `M4_3X3MINOR` macro defined, implement the `determinant` function
    in `mat4.cpp`. Since the determinant will multiply each element by the cofactor,
    some of the values need to be negated. Don''t forget to add the function declaration
    to `mat4.h`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, implement the `adjugate` function in `mat4.cpp`. Don''t forget to add
    the function declaration to `mat4.h`. Use the `M4_3X3MINOR` macro to find the
    matrix of minors, then negate the appropriate elements to create the cofactor
    matrix. Finally, return the transpose of the cofactor matrix:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the `determinant` and `adjugate` functions are finished, the implementation
    of the `inverse` function for a 4 x 4 matrix should be straightforward. Implement
    the `inverse` function in `mat4.cpp`. Don''t forget to add the function declaration
    to `mat4.h`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The `inverse` function takes a constant matrix reference and returns a new
    matrix that is the inverse of the provided matrix. Implement an `invert` convenience
    function in `mat4.cpp`. This convenience function will invert the matrix inline,
    modifying the argument. Don''t forget to add the function declaration to `mat4.h`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Inverting matrices is a relatively expensive function. Matrices that only encode
    the position and rotation can be inverted faster because the inverse of a 3 x
    3 rotation matrix is the same as its transpose.
  prefs: []
  type: TYPE_NORMAL
- en: You will learn how to implement this fast inverse in the next section when implementing
    the `lookAt` function.
  prefs: []
  type: TYPE_NORMAL
- en: Creating camera matrices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Matrices are also used for camera transformations, including perspective transforms.
    A perspective transform maps a frustum to NDC space. NDC space typically has a
    range of -1 to +1 on all axes. Unlike world/eye coordinates, NDC space is left-handed.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you will learn how to create camera transformation matrices.
    The first camera matrix is a frustum, which looks like a pyramid with the tip
    cut off. A frustum represents everything that is visible to the camera. You will
    also learn how to create different projections and how to implement a "look at"
    function that lets you easily create a view matrix.
  prefs: []
  type: TYPE_NORMAL
- en: Frustum
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Visually, a frustum looks like a pyramid with the tip cut off. A frustum has
    six sides; it represents the space that a camera can see. Create the `frustum`
    function in `mat4.cpp`. This function takes left, right, bottom, top, near, and
    far values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The details of deriving the frustum matrix are beyond the scope of this book.
    For more information on how to derive the function, check out [http://www.songho.ca/opengl/gl_projectionmatrix.html](http://www.songho.ca/opengl/gl_projectionmatrix.html).
  prefs: []
  type: TYPE_NORMAL
- en: The `frustum` function can be used to construct a view frustum, but the function
    parameters are not intuitive. In the next section, you will learn how to create
    a view frustum from more intuitive arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Perspective
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A perspective matrix is built from a field of view (typically in degrees), an
    aspect ratio, and near and far distances. It serves as an easy way to create a
    view frustum.
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement the `perspective` function in `mat4.cpp`. Don''t forget to add the
    function declaration to `mat4.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The `perspective` function will be used in almost all visual graphics demonstrations
    throughout the rest of this book. It's a really convenient way of creating a view
    frustum.
  prefs: []
  type: TYPE_NORMAL
- en: Orthographic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An orthographic projection has no perspective to it. An orthographic projection
    maps linearly to NDC space. Orthographic projections are often used for two-dimensional
    games. It's often used to achieve an isometric perspective.
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement the `ortho` function in `mat4.cpp`. Don''t forget to add the function
    declaration to `mat4.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Orthographic view projections are generally useful for displaying UI or other
    two-dimensional elements.
  prefs: []
  type: TYPE_NORMAL
- en: Look at
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The view matrix is the inverse of the camera's transformation (the position,
    rotation, and scale of the camera). Instead of having to create the camera's transform
    matrix and then invert it, you will be implementing a `lookAt` function that generates
    this matrix directly.
  prefs: []
  type: TYPE_NORMAL
- en: A `lookAt` function typically takes a `position`, the `target point` at which
    the camera is looking and a reference `up direction`. The rest of the work is
    finding the inverted basis vectors and figuring out where the position is.
  prefs: []
  type: TYPE_NORMAL
- en: Since the basis vectors are orthonormal, their inverse is the same as their
    transpose. The position can be calculated by negating the dot product of the position
    column vector with the inverted basis vectors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement the `lookAt` function in `mat4.cpp`. Don''t forget to add the function
    declaration to `mat4.h`. Remember, the view matrix maps the game world forward
    to the positive *Z* axis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The `lookAt` function is the most convenient way of constructing a view matrix.
    All of the code samples throughout the rest of this book will use the `lookAt`
    function to set up a view matrix.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned the math required to work with four-dimensional
    square matrices and implemented a reusable matrix library. Matrices are commonly
    used to encode transformation information; they are used at almost every step
    of the graphics pipeline to display models on screen.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn about encoding rotation data using quaternions.
  prefs: []
  type: TYPE_NORMAL
